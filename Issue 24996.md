# Issue 24996: gcd() of stacked polynomial rings broken with repeated variable names

Issue created by migration from Trac.

Original creator: mmezzarobba

Original creation time: 2018-04-23 16:03:41


```
sage: p = QQ['x']['x'].one()
sage: p.gcd(p)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-10-dc64a434c240> in <module>()
----> 1 p.gcd(p)

sage/structure/element.pyx in sage.structure.element.coerce_binop.new_method (build/cythonized/sage/structure/element.c:27055)()

sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.gcd (build/cythonized/sage/rings/polynomial/polynomial_element.c:43278)()

/usr/lib/python2.7/dist-packages/sage/rings/polynomial/polynomial_ring_constructor.pyc in PolynomialRing(base_ring, *args, **kwds)
    566             raise TypeError("you must specify the names of the variables")
    567 
--> 568     names = normalize_names(n, names)
    569 
    570     # At this point, we have only handled the "names" keyword if it was

sage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:9519)()

sage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:9368)()

sage/structure/category_object.pyx in sage.structure.category_object.certify_names (build/cythonized/sage/structure/category_object.c:10035)()

ValueError: variable name 'x' appears more than once
```



---

Comment by mmezzarobba created at 2018-04-23 16:07:17

I guess the natural fix would be to add support for repeated variables (renaming some automatically if necessary) in `FlatteningMorphism`, and use that in `Polynomial.gcd()` and `MPolynomial.gcd())`.


---

Comment by mmezzarobba created at 2018-04-23 19:25:27

not finished yet
----
New commits:


---

Comment by git created at 2018-04-24 07:38:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-24 08:57:12

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-04-24 08:57:45

Changing priority from minor to major.


---

Comment by mmezzarobba created at 2018-04-24 08:57:45

New commits:


---

Comment by mmezzarobba created at 2018-04-24 08:57:45

Changing status from new to needs_review.


---

Comment by git created at 2018-04-24 09:10:36

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-04-24 09:41:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-11 18:21:07

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-05-11 18:23:17

Moving the last two commits (plus further improvements) to a separate ticket #25346.


---

Comment by vdelecroix created at 2018-05-12 19:24:02

A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace

```
if hasattr(a, 'f'):
    return a.f()
else:
    raise NotImplementedError
```

by

```
try:
    return a.f()
except AttributeError:
    raise NotImplementedError
```



---

Comment by vdelecroix created at 2018-05-12 19:25:10

(rest looks good)


---

Comment by mmezzarobba created at 2018-05-12 19:28:15

Replying to [comment:10 vdelecroix]:
> A small performance notice: `hasattr` should be avoided as much as possible

Not in Cython, in think, but I would need to double check.


---

Comment by bhutz created at 2018-05-12 20:25:28

adding my comment on #25346 here as this is where that error was added.



I've run a few tests on this and haven't come up with anything that does not work correctly.

However, I'd like to know what prompted the addition of ArithmeticError? to the gcd check in dehomomgenize for affine morphisms.

It is likely that whatever this is will also occur in normalize_coordinates for projective morphisms.


---

Comment by mmezzarobba created at 2018-05-13 08:29:50

Replying to [comment:12 mmezzarobba]:
> Replying to [comment:10 vdelecroix]:
> > A small performance notice: `hasattr` should be avoided as much as possible
> 
> Not in Cython, in think, but I would need to double check.

Actually it looks like you are right, Cython doesn't seem to be able to optimize these two lines as well as I'd thought.


---

Comment by mmezzarobba created at 2018-05-13 09:07:24

Replying to [comment:13 bhutz]:
> However, I'd like to know what prompted the addition of ArithmeticError? to the gcd check in dehomomgenize for affine morphisms.

I don't really remember. Here's what I'm getting without it:

```
File "src/sage/schemes/affine/affine_morphism.py", line 519, in sage.schemes.affine.affine_morphism.SchemeMorphism_polynomial_affine_space.homogenize
Failed example:
    F.homogenize(1)
Exception raised:
    Traceback (most recent call last):
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 562, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 972, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.schemes.affine.affine_morphism.SchemeMorphism_polynomial_affine_space.homogenize[47]>", line 1, in <module>
        F.homogenize(Integer(1))
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/schemes/affine/affine_morphism.py", line 561, in homogenize
        g = gcd(F)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/arith/misc.py", line 1604, in gcd
        return __GCD_sequence(seq, **kwargs)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/arith/misc.py", line 1652, in __GCD_sequence
        g = vi.gcd(g, **kwargs)
      File "sage/rings/polynomial/multi_polynomial.pyx", line 1872, in sage.rings.polynomial.multi_polynomial.MPolynomial.gcd (build/cythonized/sage/rings/polynomial/multi_polynomial.c:20533)
        return self._parent(unibase._gcd_univariate_polynomial(uniself, other.polynomial(x)))
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/categories/unique_factorization_domains.py", line 185, in _gcd_univariate_polynomial
        B = B // b
      File "sage/rings/polynomial/polynomial_element.pyx", line 10566, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.__floordiv__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:97097)
        cdef Polynomial_generic_dense res = (<Polynomial_generic_dense>self)._new_c([c // d for c in (<Polynomial_generic_dense>self).__coeffs], P)
      File "sage/rings/polynomial/polynomial_element.pyx", line 10563, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.__floordiv__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:96973)
        return (<Polynomial_generic_dense>self)._floordiv_(<Polynomial_generic_dense>right)
      File "sage/rings/polynomial/polynomial_element.pyx", line 2700, in sage.rings.polynomial.polynomial_element.Polynomial._floordiv_ (build/cythonized/sage/rings/polynomial/polynomial_element.c:29855)
        Q, _ = self.quo_rem(right)
      File "sage/structure/element.pyx", line 4260, in sage.structure.element.coerce_binop.new_method (build/cythonized/sage/structure/element.c:28282)
        return method(self, other, *args, **kwargs)
      File "sage/rings/polynomial/polynomial_element.pyx", line 10812, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.quo_rem (build/cythonized/sage/rings/polynomial/polynomial_element.c:100180)
        raise ArithmeticError("Division non exact (consider coercing to polynomials over the fraction field)")
    ArithmeticError: Division non exact (consider coercing to polynomials over the fraction field)
```

I guess that, since this was the only failure of this kind, I thought it would be best to catch the `ArithmeticError` there (instead of keeping a `try/catch` block in `gcd()`). But if you're saying the same issue will occur elsewhere, I'm not sure what to do. Opinions anyone?


---

Comment by bhutz created at 2018-05-13 11:57:51

Looking at that example failure, here is what is boils down to: the following gets the ArithmeticError


```
R.<d,c>=QQbar[]
S.<x0,x1>=R[]
f=d*x0^2+x0;g=S(x0^2)
gcd(f,g)
```


It used to return

```
  File "/home/ben/sage/sage-release/local/lib/python2.7/site-packages/sage/arith/misc.py", line 1584, in gcd
    raise TypeError("unable to find gcd")
TypeError: unable to find gcd
```


So if this is just a case of gcd returning an error in an uncomputable case, then adding to the try/except in homogenize is the right thing to do. Homogenize is still perfectly valid without removing the gcd and that try/except is exactly to catch the failures from gcd.

normalize_coordinates for projective morphisms and points must have the gcd removed (that is their whole point) so they don't do a try/except and just throw the error from gcd. But similar examples should fail here as well (and this one does).


Looking at little further into the example, it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes

```
R.<d,c>=QQbar[]
S.<x0>=R[]
f=d*x0^2+d*x0;g=S(c*d*x0^2)
gcd(f,g)
```

That seems to say to me that there may still be an underlying issue with gcd here since if you are using Flattening to take the gcd, I don't see how this change should affect anything.


---

Comment by tscrim created at 2018-05-13 12:53:23

Replying to [comment:10 vdelecroix]:
> A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace
> {{{
> if hasattr(a, 'f'):
>     return a.f()
> else:
>     raise NotImplementedError
> }}}
> by
> {{{
> try:
>     return a.f()
> except AttributeError:
>     raise NotImplementedError
> }}}

Yes and no in Python, it depends on what you expect to happen more often:

```sage
sage: class Foo(object):
....:     def bar(self):
....:         return
....:
sage: def test1(F):
....:     if hasattr(F, 'bar'):
....:         return F.bar()
....:     return
sage: def test2(F):
....:     try:
....:         return F.bar()
....:     except AttributeError:
....:         return
sage: class Baz(object):
....:     pass
```


```
sage: F = Foo()
sage: B = Baz()
sage: %timeit test1(F)
The slowest run took 15.48 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 323 ns per loop
sage: %timeit test2(F)
The slowest run took 9.63 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 198 ns per loop

sage: %timeit test1(B)
The slowest run took 8.00 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 506 ns per loop
sage: %timeit test2(B)
The slowest run took 6.16 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.28 µs per loop
```

It is clearly faster to do the `try-except` when the object has the method by about 50%, but when it does not, it is 2x slower and needs over a microsecond on my laptop to do said test. Considering the slowdown for doing the `hasattr` check is modest compared to the raising and catching of an exception, unless you expect the method to typically be there, I think the `hasattr` is a better way to go. Plus, it usually makes the logic easier to follow.


---

Comment by vdelecroix created at 2018-05-13 21:12:16

Replying to [comment:17 tscrim]:
> Replying to [comment:10 vdelecroix]:
> > A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace
> > {{{
> > if hasattr(a, 'f'):
> >     return a.f()
> > else:
> >     raise NotImplementedError
> > }}}
> > by
> > {{{
> > try:
> >     return a.f()
> > except AttributeError:
> >     raise NotImplementedError
> > }}}
> 
> <SNIP>
> It is clearly faster to do the `try-except` when the object has the method by about 50%
> <SNIP>

This is precisely the point here. When the method is not there an error is triggered anyway.


---

Comment by tscrim created at 2018-05-13 21:38:13

Replying to [comment:18 vdelecroix]:
> Replying to [comment:17 tscrim]:
> > Replying to [comment:10 vdelecroix]:
> > > A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace
> > > {{{
> > > if hasattr(a, 'f'):
> > >     return a.f()
> > > else:
> > >     raise NotImplementedError
> > > }}}
> > > by
> > > {{{
> > > try:
> > >     return a.f()
> > > except AttributeError:
> > >     raise NotImplementedError
> > > }}}
> > 
> > <SNIP>
> > It is clearly faster to do the `try-except` when the object has the method by about 50%
> > <SNIP>
> 
> This is precisely the point here. When the method is not there an error is triggered anyway.

You're missing my point about a rebuttal against your comment about avoiding `hasattr` as much as possible. In this case it is less important because the other code is to raise an error. In general where there can be two genuine code paths, there are other factors to consider.


---

Comment by mmezzarobba created at 2018-05-14 09:25:33

Replying to [comment:16 bhutz]:
> Looking at little further into the example, it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes
> {{{
> R.<d,c>=QQbar[]
> S.<x0>=R[]
> f=d*x0<sup>2+d*x0;g=S(c*d*x0</sup>2)
> gcd(f,g)
> }}}
> That seems to say to me that there may still be an underlying issue with gcd here since if you are using Flattening to take the gcd, I don't see how this change should affect anything.

The difference—I think—is that the new code for multivariate polynomials checks whether the flattened polynomial ring “`_has_singular`” before trying to call `gcd` on the flattened polynomials. In you example, this is not the case, and hence it continues with the original polynomial and ends up doing

```
        x = self._parent.gens()[-1]
        uniself = self.polynomial(x)
        unibase = uniself.base_ring()
        if hasattr(unibase, "_gcd_univariate_polynomial"):
            return self._parent(unibase._gcd_univariate_polynomial(uniself, other.polynomial(x)))
```

with `uniself` in QQbar[c,d][x₀][x₁], which fails with an `ArithmeticError`. In contrast, the previous version would call itself recursively on a polynomial in QQbar[c,d,x₀,x₁], which would then be turned into an element of QQbar[c,d,x₀][x₁] during the recursive call, and fail with a different error.


---

Comment by git created at 2018-05-14 10:07:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2018-05-14 10:20:33

Replying to [comment:16 bhutz]:
> it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes

Of course, this also means that it should be possible to make gcds over QQbar[c,d][x₀,x₁] work too... But I'd prefer to keep that for another ticket.

On a related note, I doubt that the code path of MPolynomial.gcd() that reduces to a univariate gcd is actually used in any successful computation. It may be possible to simplify the method to something like

```
flatten = self._parent.flattening_morphism()
tgt = flatten.codomain()
if not tgt._has_singular:
    raise NotImplementedError("GCD is not implemented for multivariate polynomials over {}".format(self._parent._mpoly_base_ring()))
self, other = flatten(self), flatten(other)
tgt._singular_().set_ring()
g = self._singular_().gcd(other._singular_())
return flatten.section()(tgt(g))
```

without losing any functionality...


---

Comment by mmezzarobba created at 2018-05-19 08:57:34

Replying to [comment:11 vdelecroix]:
> (rest looks good)

Does it mean that we can set this ticket to positive_review now that this issue is solved?


---

Comment by vdelecroix created at 2018-05-29 06:10:15

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-05-30 19:19:37

Resolution: fixed
