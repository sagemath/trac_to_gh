# Issue 19908: Hilbert series bug

archive/issues_019908.json:
```json
{
    "body": "Keywords: Hilbert series, polynomial ring\n\nThis works correctly:\n\n```\nsage: n=4;m=10;P = PolynomialRing(QQ,n*m,\"x\"); x = P.gens(); M = Matrix(n,x)\nsage: M\n[ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9]\n[x10 x11 x12 x13 x14 x15 x16 x17 x18 x19]\n[x20 x21 x22 x23 x24 x25 x26 x27 x28 x29]\n[x30 x31 x32 x33 x34 x35 x36 x37 x38 x39]\nsage: I = P.ideal(M.minors(2))\nsage: I.hilbert_series().numerator()\n-84*t^3 - 108*t^2 - 27*t - 1\nsage: factor(I.hilbert_series().denominator())\n(t - 1)^13\n```\n\nbut if I increase the number of columns by one, I get\n\n```\nsage: n=4;m=11;P = PolynomialRing(QQ,n*m,\"x\"); x = P.gens(); M = Matrix(n,x)\nsage: M\n[ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9 x10]\n[x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21]\n[x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32]\n[x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43]\nsage: I = P.ideal(M.minors(2))\nsage: I.hilbert_series().numerator()\n120*t^33 - 3465*t^32 + 48180*t^31 - 429374*t^30 + 2753520*t^29 - 13522410*t^28 + 52832780*t^27 - 168384150*t^26 + 445188744*t^25 - 987193350*t^24 + 1847488500*t^23 + 1372406746*t^22 - 403422496*t^21 - 8403314*t^20 - 471656596*t^19 + 1806623746*t^18 + 752776200*t^17 + 752776200*t^16 - 1580830020*t^15 + 1673936550*t^14 - 1294246800*t^13 + 786893250*t^12 - 382391100*t^11 + 146679390*t^10 - 42299400*t^9 + 7837830*t^8 - 172260*t^7 - 468930*t^6 + 183744*t^5 - 39270*t^4 + 5060*t^3 - 330*t^2 + 1\nsage: factor(I.hilbert_series().denominator())\n(t - 1)^44\n```\n\nwhich is clearly not correct, as it can be checked with\n\n```\nsage: from sage.libs.singular.function import singular_function\nsage: hilb = singular_function(\"hilb\")\nsage: std = singular_function(\"std\")\nsage: hilb(std(I))\n// ** _ is no standard basis\n...\n//         1 t^0\n//        30 t^1\n//       135 t^2\n//       120 t^3\n// dimension (proj.)  = 13\n// degree (proj.)   = 286\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/20145\n\n",
    "created_at": "2016-03-02T07:57:48Z",
    "labels": [
        "commutative algebra",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.4",
    "title": "Hilbert series bug",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19908",
    "user": "stumpc5"
}
```
Keywords: Hilbert series, polynomial ring

This works correctly:

```
sage: n=4;m=10;P = PolynomialRing(QQ,n*m,"x"); x = P.gens(); M = Matrix(n,x)
sage: M
[ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9]
[x10 x11 x12 x13 x14 x15 x16 x17 x18 x19]
[x20 x21 x22 x23 x24 x25 x26 x27 x28 x29]
[x30 x31 x32 x33 x34 x35 x36 x37 x38 x39]
sage: I = P.ideal(M.minors(2))
sage: I.hilbert_series().numerator()
-84*t^3 - 108*t^2 - 27*t - 1
sage: factor(I.hilbert_series().denominator())
(t - 1)^13
```

but if I increase the number of columns by one, I get

```
sage: n=4;m=11;P = PolynomialRing(QQ,n*m,"x"); x = P.gens(); M = Matrix(n,x)
sage: M
[ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9 x10]
[x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21]
[x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32]
[x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43]
sage: I = P.ideal(M.minors(2))
sage: I.hilbert_series().numerator()
120*t^33 - 3465*t^32 + 48180*t^31 - 429374*t^30 + 2753520*t^29 - 13522410*t^28 + 52832780*t^27 - 168384150*t^26 + 445188744*t^25 - 987193350*t^24 + 1847488500*t^23 + 1372406746*t^22 - 403422496*t^21 - 8403314*t^20 - 471656596*t^19 + 1806623746*t^18 + 752776200*t^17 + 752776200*t^16 - 1580830020*t^15 + 1673936550*t^14 - 1294246800*t^13 + 786893250*t^12 - 382391100*t^11 + 146679390*t^10 - 42299400*t^9 + 7837830*t^8 - 172260*t^7 - 468930*t^6 + 183744*t^5 - 39270*t^4 + 5060*t^3 - 330*t^2 + 1
sage: factor(I.hilbert_series().denominator())
(t - 1)^44
```

which is clearly not correct, as it can be checked with

```
sage: from sage.libs.singular.function import singular_function
sage: hilb = singular_function("hilb")
sage: std = singular_function("std")
sage: hilb(std(I))
// ** _ is no standard basis
...
//         1 t^0
//        30 t^1
//       135 t^2
//       120 t^3
// dimension (proj.)  = 13
// degree (proj.)   = 286
```


Issue created by migration from https://trac.sagemath.org/ticket/20145





---

archive/issue_comments_273945.json:
```json
{
    "body": "Where is the error?\n\n44 is the number of generators of P in `n=4;m=11;P = PolynomialRing(QQ,n*m,\"x\");`, and Sage simply returns `(1-t)^P.ngens()`\nas the denominator. Is this wrong mathematically?",
    "created_at": "2016-03-02T09:32:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273945",
    "user": "dimpase"
}
```

Where is the error?

44 is the number of generators of P in `n=4;m=11;P = PolynomialRing(QQ,n*m,"x");`, and Sage simply returns `(1-t)^P.ngens()`
as the denominator. Is this wrong mathematically?



---

archive/issue_comments_273946.json:
```json
{
    "body": "The correct answer, as given in the second computation `hilb(std(I))`, is\n\n```\n( 120*t^3 + 135*t^2 + 30*t + 1 ) / (t-1)^14\n```\n\nwhich is not what Sage outputs. (But the total degree `-11` is still correct...)",
    "created_at": "2016-03-02T09:51:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273946",
    "user": "stumpc5"
}
```

The correct answer, as given in the second computation `hilb(std(I))`, is

```
( 120*t^3 + 135*t^2 + 30*t + 1 ) / (t-1)^14
```

which is not what Sage outputs. (But the total degree `-11` is still correct...)



---

archive/issue_comments_273947.json:
```json
{
    "body": "well, for m=10 you only get the output above due to the fact that numerator has a factor (t-1)<sup>27</sup> that gets cancelled.\n\nAnd for m=11 the numerator is irreducible, so no cancellation happens. Does this mean that it's only due to this cancellation accident in the m=10 case you get the same output in Sage as you expect?\n\nNumerator is computed by Singular and so it should not give any bug, I guess...",
    "created_at": "2016-03-02T10:15:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273947",
    "user": "dimpase"
}
```

well, for m=10 you only get the output above due to the fact that numerator has a factor (t-1)<sup>27</sup> that gets cancelled.

And for m=11 the numerator is irreducible, so no cancellation happens. Does this mean that it's only due to this cancellation accident in the m=10 case you get the same output in Sage as you expect?

Numerator is computed by Singular and so it should not give any bug, I guess...



---

archive/issue_comments_273948.json:
```json
{
    "body": "Replying to [comment:3 dimpase]:\n> well, for m=10 you only get the output above due to the fact that numerator has a factor (t-1)<sup>27</sup> that gets cancelled.\n\nI am not sure I follow what you mean -- in the m=10 case, the (afaik) correct Hilbert series is\n\n```\n( 84*t^3 + 108*t^2 + 27*t + 1 ) / (1 - t)^13\n```\n\nwhich is what I get above. But in the m=11 case, the (afaik) correct Hilbert series is\n\n```\n( 120*t^3 + 135*t^2 + 30*t + 1 ) / (1 - t)^14\n```\n\nwhich is not what I get above. In particular, the numerator output of singular should be divisible by `(1-t)^30`, but - as you write - it is irreducible instead.",
    "created_at": "2016-03-02T10:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273948",
    "user": "stumpc5"
}
```

Replying to [comment:3 dimpase]:
> well, for m=10 you only get the output above due to the fact that numerator has a factor (t-1)<sup>27</sup> that gets cancelled.

I am not sure I follow what you mean -- in the m=10 case, the (afaik) correct Hilbert series is

```
( 84*t^3 + 108*t^2 + 27*t + 1 ) / (1 - t)^13
```

which is what I get above. But in the m=11 case, the (afaik) correct Hilbert series is

```
( 120*t^3 + 135*t^2 + 30*t + 1 ) / (1 - t)^14
```

which is not what I get above. In particular, the numerator output of singular should be divisible by `(1-t)^30`, but - as you write - it is irreducible instead.



---

archive/issue_comments_273949.json:
```json
{
    "body": "Replying to [comment:3 dimpase]:\n> Numerator is computed by Singular and so it should not give any bug, I guess...\n\nAt least luisfe on sage-devel (https://groups.google.com/d/msg/sage-devel/tyTDd5dEDGw/8FxH9hUzBwAJ) seems to confirm this to be a bug in `Singular`...",
    "created_at": "2016-03-02T10:24:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273949",
    "user": "stumpc5"
}
```

Replying to [comment:3 dimpase]:
> Numerator is computed by Singular and so it should not give any bug, I guess...

At least luisfe on sage-devel (https://groups.google.com/d/msg/sage-devel/tyTDd5dEDGw/8FxH9hUzBwAJ) seems to confirm this to be a bug in `Singular`...



---

archive/issue_comments_273950.json:
```json
{
    "body": "Replying to [comment:4 stumpc5]:\n> Replying to [comment:3 dimpase]:\n> > well, for m=10 you only get the output above due to the fact that numerator has a factor (t-1)<sup>27</sup> that gets cancelled.\n> \n> I am not sure I follow what you mean\n\nYou can read the code of `I.hilbert_series` to see that it takes `I.hilbert_numerator()`, which is computed by Singular (again, read the code), and divides it by (t-1)<sup>P.ngens()</sup>. \n\n\n\n>  -- in the m=10 case, the (afaik) correct Hilbert series is\n> {{{\n> ( 84*t^3 + 108*t^2 + 27*t + 1 ) / (1 - t)^13\n> }}}\n> which is what I get above. But in the m=11 case, the (afaik) correct Hilbert series is\n> {{{\n> ( 120*t^3 + 135*t^2 + 30*t + 1 ) / (1 - t)^14\n> }}}\n> which is not what I get above. In particular, the numerator output of singular should be divisible by `(1-t)^30`, but - as you write - it is irreducible instead.\n\nSo it is a bug in Singular, indeed.",
    "created_at": "2016-03-02T10:36:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273950",
    "user": "dimpase"
}
```

Replying to [comment:4 stumpc5]:
> Replying to [comment:3 dimpase]:
> > well, for m=10 you only get the output above due to the fact that numerator has a factor (t-1)<sup>27</sup> that gets cancelled.
> 
> I am not sure I follow what you mean

You can read the code of `I.hilbert_series` to see that it takes `I.hilbert_numerator()`, which is computed by Singular (again, read the code), and divides it by (t-1)<sup>P.ngens()</sup>. 



>  -- in the m=10 case, the (afaik) correct Hilbert series is
> {{{
> ( 84*t^3 + 108*t^2 + 27*t + 1 ) / (1 - t)^13
> }}}
> which is what I get above. But in the m=11 case, the (afaik) correct Hilbert series is
> {{{
> ( 120*t^3 + 135*t^2 + 30*t + 1 ) / (1 - t)^14
> }}}
> which is not what I get above. In particular, the numerator output of singular should be divisible by `(1-t)^30`, but - as you write - it is irreducible instead.

So it is a bug in Singular, indeed.



---

archive/issue_comments_273951.json:
```json
{
    "body": "Replying to [comment:6 dimpase]:\n> Replying to [comment:4 stumpc5]:\n> > Replying to [comment:3 dimpase]:\n> You can read the code of `I.hilbert_series` to see that it takes `I.hilbert_numerator()`, which is computed by Singular (again, read the code), and divides it by (t-1)<sup>P.ngens()</sup>.\n\nI actually did read the code, but\n* I only see \"Singular is doing the computation\" in `sage.libs.singular.function_factory.ff.hilb`,\n* the output is then going to Sage in a way I don't know, and finally\n* there is a polynomial division.\nSo a priori, the bug can be in either of these parts.\n\nAnyway, it seems to be a bug in Singular, so I suggest to leave this ticket open until that is fixed, and then add a doctest for checking...\n\nI would also appreciate if someone knowing how this Hilbert numerator is computed in Singular would send a bug report there (or shows me how to reproduce the bug in Singular).",
    "created_at": "2016-03-02T10:43:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273951",
    "user": "stumpc5"
}
```

Replying to [comment:6 dimpase]:
> Replying to [comment:4 stumpc5]:
> > Replying to [comment:3 dimpase]:
> You can read the code of `I.hilbert_series` to see that it takes `I.hilbert_numerator()`, which is computed by Singular (again, read the code), and divides it by (t-1)<sup>P.ngens()</sup>.

I actually did read the code, but
* I only see "Singular is doing the computation" in `sage.libs.singular.function_factory.ff.hilb`,
* the output is then going to Sage in a way I don't know, and finally
* there is a polynomial division.
So a priori, the bug can be in either of these parts.

Anyway, it seems to be a bug in Singular, so I suggest to leave this ticket open until that is fixed, and then add a doctest for checking...

I would also appreciate if someone knowing how this Hilbert numerator is computed in Singular would send a bug report there (or shows me how to reproduce the bug in Singular).



---

archive/issue_comments_273952.json:
```json
{
    "body": "Replying to [comment:7 stumpc5]:\n \n> Anyway, it seems to be a bug in Singular, so I suggest to leave this ticket open until that is fixed, and then add a doctest for checking...\n> \n> I would also appreciate if someone knowing how this Hilbert numerator is computed in Singular would send a bug report there (or shows me how to reproduce the bug in Singular).\n\nI think you know that in the output of hilb(std(I)) (the part you omitted and indicated by ...) is the numerator that should be divisible by the appropriate power of t-1, but it is not.\n\nAs to writing up the corresponding Singular commands to show this... I can do this for you, although I didn't touch it for 5+ years...",
    "created_at": "2016-03-02T10:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273952",
    "user": "dimpase"
}
```

Replying to [comment:7 stumpc5]:
 
> Anyway, it seems to be a bug in Singular, so I suggest to leave this ticket open until that is fixed, and then add a doctest for checking...
> 
> I would also appreciate if someone knowing how this Hilbert numerator is computed in Singular would send a bug report there (or shows me how to reproduce the bug in Singular).

I think you know that in the output of hilb(std(I)) (the part you omitted and indicated by ...) is the numerator that should be divisible by the appropriate power of t-1, but it is not.

As to writing up the corresponding Singular commands to show this... I can do this for you, although I didn't touch it for 5+ years...



---

archive/issue_comments_273953.json:
```json
{
    "body": "Replying to [comment:8 dimpase]:\n> Replying to [comment:7 stumpc5]:\n> I think you know that in the output of hilb(std(I)) (the part you omitted and indicated by ...) is the numerator that should be divisible by the appropriate power of t-1, but it is not.\n\nOh, I didn't know, thanks. If that is the not correct Singular output, how is the stuff below\n\n```\n//         1 t^0\n//        30 t^1\n//       135 t^2\n//       120 t^3\n// dimension (proj.)  = 13\n```\n\nthen again correct (saying that it gives the numerator divided by the maximal power of `(t-1)`?",
    "created_at": "2016-03-02T11:05:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273953",
    "user": "stumpc5"
}
```

Replying to [comment:8 dimpase]:
> Replying to [comment:7 stumpc5]:
> I think you know that in the output of hilb(std(I)) (the part you omitted and indicated by ...) is the numerator that should be divisible by the appropriate power of t-1, but it is not.

Oh, I didn't know, thanks. If that is the not correct Singular output, how is the stuff below

```
//         1 t^0
//        30 t^1
//       135 t^2
//       120 t^3
// dimension (proj.)  = 13
```

then again correct (saying that it gives the numerator divided by the maximal power of `(t-1)`?



---

archive/issue_comments_273954.json:
```json
{
    "body": "Replying to [comment:9 stumpc5]:\n> Replying to [comment:8 dimpase]:\n> > Replying to [comment:7 stumpc5]:\n> > I think you know that in the output of hilb(std(I)) (the part you omitted and indicated by ...) is the numerator that should be divisible by the appropriate power of t-1, but it is not.\n> \n> Oh, I didn't know, thanks. If that is the not correct Singular output, how is the stuff below\n> {{{\n> //         1 t^0\n> //        30 t^1\n> //       135 t^2\n> //       120 t^3\n> // dimension (proj.)  = 13\n> }}}\n> then again correct (saying that it gives the numerator divided by the maximal power of `(t-1)`?\n\nIt's all a bit Greek to me now, and https://www.singular.uni-kl.de/Manual/latest/sing_310.htm#SEC349 does not help much. \n\nPerhaps there is more than one way to compute this info, and Singular does something leading to the correct answer, even though the data it supplies to Sage is not correct.\n\nYou seem to know a reference for the correct answers to this question for all m, no? This would be handy in the bug report upstream.",
    "created_at": "2016-03-02T11:18:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273954",
    "user": "dimpase"
}
```

Replying to [comment:9 stumpc5]:
> Replying to [comment:8 dimpase]:
> > Replying to [comment:7 stumpc5]:
> > I think you know that in the output of hilb(std(I)) (the part you omitted and indicated by ...) is the numerator that should be divisible by the appropriate power of t-1, but it is not.
> 
> Oh, I didn't know, thanks. If that is the not correct Singular output, how is the stuff below
> {{{
> //         1 t^0
> //        30 t^1
> //       135 t^2
> //       120 t^3
> // dimension (proj.)  = 13
> }}}
> then again correct (saying that it gives the numerator divided by the maximal power of `(t-1)`?

It's all a bit Greek to me now, and https://www.singular.uni-kl.de/Manual/latest/sing_310.htm#SEC349 does not help much. 

Perhaps there is more than one way to compute this info, and Singular does something leading to the correct answer, even though the data it supplies to Sage is not correct.

You seem to know a reference for the correct answers to this question for all m, no? This would be handy in the bug report upstream.



---

archive/issue_comments_273955.json:
```json
{
    "body": "Replying to [comment:10 dimpase]:\n> You seem to know a reference for the correct answers to this question for all m, no? This would be handy in the bug report upstream.\n\nThis Hilbert series is known (though maybe implicit as some h vector of a simplicial complex), but I don't have a reference at hand. I will try to get one.\n\nThe reason it seemed suspicious is that I conjecture a term order for which its initial ideal is the Stanley-Reisner ideal of a simplicial sphere I was studying for completely different reasons. And this example was spit out to contradict that conjecture. But, as often, it was the code that's buggy and and not the conjectural description. That's anyway not yet in a form to be made public.",
    "created_at": "2016-03-02T11:27:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273955",
    "user": "stumpc5"
}
```

Replying to [comment:10 dimpase]:
> You seem to know a reference for the correct answers to this question for all m, no? This would be handy in the bug report upstream.

This Hilbert series is known (though maybe implicit as some h vector of a simplicial complex), but I don't have a reference at hand. I will try to get one.

The reason it seemed suspicious is that I conjecture a term order for which its initial ideal is the Stanley-Reisner ideal of a simplicial sphere I was studying for completely different reasons. And this example was spit out to contradict that conjecture. But, as often, it was the code that's buggy and and not the conjectural description. That's anyway not yet in a form to be made public.



---

archive/issue_comments_273956.json:
```json
{
    "body": "One would try to compute the same with Macaulay2. Did you try this?",
    "created_at": "2016-03-02T11:28:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273956",
    "user": "dimpase"
}
```

One would try to compute the same with Macaulay2. Did you try this?



---

archive/issue_comments_273957.json:
```json
{
    "body": "Yes, I did -- here it is the output again (with a few long outputs `...`'ed):\n\n```\ni31 : R = QQ[x11,x12,x13,x14,x15,x16,x17,x18,x19,x110,x111,x21,x22,x23,x24,x25,x26,x27,x28,x29,x210,x211,x31,x32,x33,x34,x35,x36,x37,x38,x39,x310,x311,x41,x42,x43,x44,x45,x46,x47,x48,x49,x410,x411]\n\no31 = R\n\no31 : PolynomialRing\n\ni32 : M = matrix{{x11,x12,x13,x14,x15,x16,x17,x18,x19,x110,x111},{x21,x22,x23,x24,x25,x26,x27,x28,x29,x210,x211},{x31,x32,x33,x34,x35,x36,x37,x38,x39,x310,x311},{x41,x42,x43,x44,x45,x46,x47,x48,x49,x410,x411}}\n\no32 = | x11 x12 x13 x14 x15 x16 x17 x18 x19 x110 x111 |\n      | x21 x22 x23 x24 x25 x26 x27 x28 x29 x210 x211 |\n      | x31 x32 x33 x34 x35 x36 x37 x38 x39 x310 x311 |\n      | x41 x42 x43 x44 x45 x46 x47 x48 x49 x410 x411 |\n\n              4       11\no32 : Matrix R  <--- R\n\ni33 : I = minors(2,M) \n\no33 = ...\no33 : Ideal of R\n\ni34 : s = hilbertSeries (R/I)\n\no34 = ...\no34 : Expression of class Divide\n\ni35 : denominator s\n\n             44\no35 = (1 - T)\n\no35 : Expression of class Product\n\ni36 : n = numerator s\n\no36 = ...\no36 : ZZ[T]\n\ni37 : factor n\n\n               30               2       3\no37 = (- 1 + T)  (1 + 30T + 135T  + 120T )\n\no37 : Expression of class Product\n\n```\n",
    "created_at": "2016-03-02T11:45:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273957",
    "user": "stumpc5"
}
```

Yes, I did -- here it is the output again (with a few long outputs `...`'ed):

```
i31 : R = QQ[x11,x12,x13,x14,x15,x16,x17,x18,x19,x110,x111,x21,x22,x23,x24,x25,x26,x27,x28,x29,x210,x211,x31,x32,x33,x34,x35,x36,x37,x38,x39,x310,x311,x41,x42,x43,x44,x45,x46,x47,x48,x49,x410,x411]

o31 = R

o31 : PolynomialRing

i32 : M = matrix{{x11,x12,x13,x14,x15,x16,x17,x18,x19,x110,x111},{x21,x22,x23,x24,x25,x26,x27,x28,x29,x210,x211},{x31,x32,x33,x34,x35,x36,x37,x38,x39,x310,x311},{x41,x42,x43,x44,x45,x46,x47,x48,x49,x410,x411}}

o32 = | x11 x12 x13 x14 x15 x16 x17 x18 x19 x110 x111 |
      | x21 x22 x23 x24 x25 x26 x27 x28 x29 x210 x211 |
      | x31 x32 x33 x34 x35 x36 x37 x38 x39 x310 x311 |
      | x41 x42 x43 x44 x45 x46 x47 x48 x49 x410 x411 |

              4       11
o32 : Matrix R  <--- R

i33 : I = minors(2,M) 

o33 = ...
o33 : Ideal of R

i34 : s = hilbertSeries (R/I)

o34 = ...
o34 : Expression of class Divide

i35 : denominator s

             44
o35 = (1 - T)

o35 : Expression of class Product

i36 : n = numerator s

o36 = ...
o36 : ZZ[T]

i37 : factor n

               30               2       3
o37 = (- 1 + T)  (1 + 30T + 135T  + 120T )

o37 : Expression of class Product

```




---

archive/issue_comments_273958.json:
```json
{
    "body": "by the way, here is what they mean by the 1st and by the 2nd Hilbert series.\nhttps://www.singular.uni-kl.de/DEMO_HTML/Examples/Hilbert/index.html\n\nIndeed, this alone seems enough for a bug report.\n(save the Singular code :-))",
    "created_at": "2016-03-02T11:58:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273958",
    "user": "dimpase"
}
```

by the way, here is what they mean by the 1st and by the 2nd Hilbert series.
https://www.singular.uni-kl.de/DEMO_HTML/Examples/Hilbert/index.html

Indeed, this alone seems enough for a bug report.
(save the Singular code :-))



---

archive/issue_comments_273959.json:
```json
{
    "body": "Okay, I am sending a bug report to Singular now...",
    "created_at": "2016-03-02T12:02:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273959",
    "user": "stumpc5"
}
```

Okay, I am sending a bug report to Singular now...



---

archive/issue_comments_273960.json:
```json
{
    "body": "any progress on this?",
    "created_at": "2016-05-23T14:39:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273960",
    "user": "dimpase"
}
```

any progress on this?



---

archive/issue_comments_273961.json:
```json
{
    "body": "You find the bug report from Feb at https://www.singular.uni-kl.de:8005/trac/ticket/750, but no one seems to have looked at it so far...",
    "created_at": "2016-05-23T14:47:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273961",
    "user": "stumpc5"
}
```

You find the bug report from Feb at https://www.singular.uni-kl.de:8005/trac/ticket/750, but no one seems to have looked at it so far...



---

archive/issue_comments_273962.json:
```json
{
    "body": "As rechecked at http://www.singular.uni-kl.de:8002/trac/ticket/750#comment:1, this appears to be an interface bug, and no bug directly in singular.",
    "created_at": "2017-12-14T16:17:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273962",
    "user": "stumpc5"
}
```

As rechecked at http://www.singular.uni-kl.de:8002/trac/ticket/750#comment:1, this appears to be an interface bug, and no bug directly in singular.



---

archive/issue_comments_273963.json:
```json
{
    "body": "Looks like an overflow error\n\n```\nsage: QQ['z'](hilb(I, 2))*(1-z)**30-QQ['z'](hilb(I, 1))\n// ** _ is no standard basis\n// ** _ is no standard basis\n-4294967296*z^22 + 4294967296*z^21 - 4294967296*z^20 + 4294967296*z^19 - 4294967296*z^18\nsage: factor(4294967296)\n2^32\n```\n",
    "created_at": "2017-12-19T12:51:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273963",
    "user": "chapoton"
}
```

Looks like an overflow error

```
sage: QQ['z'](hilb(I, 2))*(1-z)**30-QQ['z'](hilb(I, 1))
// ** _ is no standard basis
// ** _ is no standard basis
-4294967296*z^22 + 4294967296*z^21 - 4294967296*z^20 + 4294967296*z^19 - 4294967296*z^18
sage: factor(4294967296)
2^32
```




---

archive/issue_comments_273964.json:
```json
{
    "body": "On the singular ticket they observe that what is shown here as the 2nd Hilbert series is actually their 1st Hilbert series.",
    "created_at": "2017-12-19T15:32:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273964",
    "user": "stumpc5"
}
```

On the singular ticket they observe that what is shown here as the 2nd Hilbert series is actually their 1st Hilbert series.



---

archive/issue_comments_273965.json:
```json
{
    "body": "But the long singular answer should factorise with a factor `(1-t)^30`, no ? And it does not!",
    "created_at": "2017-12-19T17:01:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273965",
    "user": "chapoton"
}
```

But the long singular answer should factorise with a factor `(1-t)^30`, no ? And it does not!



---

archive/issue_comments_273966.json:
```json
{
    "body": "So (I double checked) this is a bug in singular indeed. Someone should reopen \u200bhttp://www.singular.uni-kl.de:8002/trac/ticket/750",
    "created_at": "2017-12-19T20:14:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273966",
    "user": "chapoton"
}
```

So (I double checked) this is a bug in singular indeed. Someone should reopen ​http://www.singular.uni-kl.de:8002/trac/ticket/750



---

archive/issue_comments_273967.json:
```json
{
    "body": "More precisely, the difference between the good result and the singular result is\n\n```\n(2^32) * t^18 * (t^4 - t^3 + t^2 - t + 1)\n```\n\nin singular 4.1.0 (which is the version used by sage and available online)",
    "created_at": "2017-12-19T20:21:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273967",
    "user": "chapoton"
}
```

More precisely, the difference between the good result and the singular result is

```
(2^32) * t^18 * (t^4 - t^3 + t^2 - t + 1)
```

in singular 4.1.0 (which is the version used by sage and available online)



---

archive/issue_comments_273968.json:
```json
{
    "body": "Okay, I can follow your computation. Is this problem now just a coincidence, or how should it be related to the bug I reported?\n\nThe bug I had was that the Sage Hilbert series is the singular second Hilbert series. This is given correctly by the computation 4x10, while the (as you say wrongly computed) first Hilbert series was given for the 4x11 example.",
    "created_at": "2017-12-19T20:34:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273968",
    "user": "stumpc5"
}
```

Okay, I can follow your computation. Is this problem now just a coincidence, or how should it be related to the bug I reported?

The bug I had was that the Sage Hilbert series is the singular second Hilbert series. This is given correctly by the computation 4x10, while the (as you say wrongly computed) first Hilbert series was given for the 4x11 example.



---

archive/issue_comments_273969.json:
```json
{
    "body": "Sage only ever calls the \"first Hilbert series\". If the result of singular for hilb(I, 1) was correct, the rational function in sage would simplify and its numerator would be the same result as the \"second Hilbert series\" of singular. ***The problem is a bug in Singular***.\n\nNow we could \"fix\" this bug by calling instead hilb(I, 2) and changing the sage code, but I would not call that a good solution.",
    "created_at": "2017-12-19T21:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273969",
    "user": "chapoton"
}
```

Sage only ever calls the "first Hilbert series". If the result of singular for hilb(I, 1) was correct, the rational function in sage would simplify and its numerator would be the same result as the "second Hilbert series" of singular. ***The problem is a bug in Singular***.

Now we could "fix" this bug by calling instead hilb(I, 2) and changing the sage code, but I would not call that a good solution.



---

archive/issue_comments_273970.json:
```json
{
    "body": "oh, I see, sorry for my ignorance.",
    "created_at": "2017-12-19T21:37:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273970",
    "user": "stumpc5"
}
```

oh, I see, sorry for my ignorance.



---

archive/issue_comments_273971.json:
```json
{
    "body": "https://www.singular.uni-kl.de:8005/trac/ticket/750 has been re-opened",
    "created_at": "2018-01-24T13:08:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273971",
    "user": "chapoton"
}
```

https://www.singular.uni-kl.de:8005/trac/ticket/750 has been re-opened



---

archive/issue_comments_273972.json:
```json
{
    "body": "Note that in the current version 4.1.1p2.p0 of Singular, there is not a wrong result due to integer overflow, but an honest \"int overflow error\" is raised.\n\nIn my computations of group cohomology, I suffered from these overflow errors as well, which is why I opened #26243 and provided an implementation of Hilbert series computations that goes beyond Singular's limitations.\n\nMy implementation is not much slower than Singular in the examples in which Singular works. However, in #26243, I do not propose to use my implementation as default way to compute Hilbert series (in particular, I didn't touch the `.hilbert_numerator()` method of multipolynomial ideals). However, if you consider to use it in the `.hilbert_*()` methods by default in order to fix *this* ticket: Go ahead!\n\nEDIT: The failing example from here became doctest for the code from #26243.",
    "created_at": "2018-09-11T15:03:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273972",
    "user": "SimonKing"
}
```

Note that in the current version 4.1.1p2.p0 of Singular, there is not a wrong result due to integer overflow, but an honest "int overflow error" is raised.

In my computations of group cohomology, I suffered from these overflow errors as well, which is why I opened #26243 and provided an implementation of Hilbert series computations that goes beyond Singular's limitations.

My implementation is not much slower than Singular in the examples in which Singular works. However, in #26243, I do not propose to use my implementation as default way to compute Hilbert series (in particular, I didn't touch the `.hilbert_numerator()` method of multipolynomial ideals). However, if you consider to use it in the `.hilbert_*()` methods by default in order to fix *this* ticket: Go ahead!

EDIT: The failing example from here became doctest for the code from #26243.



---

archive/issue_comments_273973.json:
```json
{
    "body": "The code in #25243 has improved, it now beats Singular also speedwise.\n\nSo, I suggest to use #25243 here.",
    "created_at": "2018-09-13T16:04:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273973",
    "user": "SimonKing"
}
```

The code in #25243 has improved, it now beats Singular also speedwise.

So, I suggest to use #25243 here.



---

archive/issue_comments_273974.json:
```json
{
    "body": "Replying to [comment:31 SimonKing]:\n> The code in #25243 has improved, it now beats Singular also speedwise.\n> \n> So, I suggest to use #25243 here.\n\nTypo: #26243 :P",
    "created_at": "2018-09-15T05:25:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273974",
    "user": "tscrim"
}
```

Replying to [comment:31 SimonKing]:
> The code in #25243 has improved, it now beats Singular also speedwise.
> 
> So, I suggest to use #25243 here.

Typo: #26243 :P



---

archive/issue_comments_273975.json:
```json
{
    "body": "Replying to [comment:30 SimonKing]:\n> However, in #26243, I do not propose to use my implementation as default way to compute Hilbert series (in particular, I didn't touch the `.hilbert_numerator()` method of multipolynomial ideals). However, if you consider to use it in the `.hilbert_*()` methods by default in order to fix *this* ticket: Go ahead!\n\n+1 to this. I may work on it this coming week if no one else volunteers, but be advised that various obligations mean I'm slow.",
    "created_at": "2018-09-16T03:10:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273975",
    "user": "john_perry"
}
```

Replying to [comment:30 SimonKing]:
> However, in #26243, I do not propose to use my implementation as default way to compute Hilbert series (in particular, I didn't touch the `.hilbert_numerator()` method of multipolynomial ideals). However, if you consider to use it in the `.hilbert_*()` methods by default in order to fix *this* ticket: Go ahead!

+1 to this. I may work on it this coming week if no one else volunteers, but be advised that various obligations mean I'm slow.



---

archive/issue_comments_273976.json:
```json
{
    "body": "If I see that correctly, the following functions need to be taken care of (all in sage.rings.polynomial.multi_polynomial_ideal):\n- `hilbert_series`: Here we can use what I called `hilbert_poincare_series` in sage.rings.hilbert (name according to both the book of Greuel and Pfister, and to the article of Bigatti).\n- `hilbert_numerator`: Here we can use what I called `first_hilbert_series` in sage.rings.hilbert (name according to the book of Greuel and Pfister).\n- `hilbert_polynomial`: This needs to be re-implemented.\n\nIf I understand correctly, one wouldn't provide degree weights for `hilbert_polynomial`, and I think it is easy enough to follow Definition 5.1.4 in the Greuel-Pfister book.",
    "created_at": "2018-09-16T17:06:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273976",
    "user": "SimonKing"
}
```

If I see that correctly, the following functions need to be taken care of (all in sage.rings.polynomial.multi_polynomial_ideal):
- `hilbert_series`: Here we can use what I called `hilbert_poincare_series` in sage.rings.hilbert (name according to both the book of Greuel and Pfister, and to the article of Bigatti).
- `hilbert_numerator`: Here we can use what I called `first_hilbert_series` in sage.rings.hilbert (name according to the book of Greuel and Pfister).
- `hilbert_polynomial`: This needs to be re-implemented.

If I understand correctly, one wouldn't provide degree weights for `hilbert_polynomial`, and I think it is easy enough to follow Definition 5.1.4 in the Greuel-Pfister book.



---

archive/issue_comments_273977.json:
```json
{
    "body": "Replying to [comment:35 SimonKing]:\n> If I see that correctly, the following functions need to be taken care of (all in sage.rings.polynomial.multi_polynomial_ideal):\n> - `hilbert_series`: Here we can use what I called `hilbert_poincare_series` in sage.rings.hilbert (name according to both the book of Greuel and Pfister, and to the article of Bigatti).\n> - `hilbert_numerator`: Here we can use what I called `first_hilbert_series` in sage.rings.hilbert (name according to the book of Greuel and Pfister).\n\nThanks. I'll aim for that.\n\n> - `hilbert_polynomial`: This needs to be re-implemented.\n\nI have done that before, so I should be able to do it for this. :-)\n\n> If I understand correctly, one wouldn't provide degree weights for `hilbert_polynomial`...\n\nYes, the Hilbert series is non-polynomial for non-standard weights, and I understand that finding formulas for this is an area of research that no one is actually involved in, unless someone extended the work of Massimo Caboara's Master's student about 4-5 years ago.",
    "created_at": "2018-09-16T17:45:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273977",
    "user": "john_perry"
}
```

Replying to [comment:35 SimonKing]:
> If I see that correctly, the following functions need to be taken care of (all in sage.rings.polynomial.multi_polynomial_ideal):
> - `hilbert_series`: Here we can use what I called `hilbert_poincare_series` in sage.rings.hilbert (name according to both the book of Greuel and Pfister, and to the article of Bigatti).
> - `hilbert_numerator`: Here we can use what I called `first_hilbert_series` in sage.rings.hilbert (name according to the book of Greuel and Pfister).

Thanks. I'll aim for that.

> - `hilbert_polynomial`: This needs to be re-implemented.

I have done that before, so I should be able to do it for this. :-)

> If I understand correctly, one wouldn't provide degree weights for `hilbert_polynomial`...

Yes, the Hilbert series is non-polynomial for non-standard weights, and I understand that finding formulas for this is an area of research that no one is actually involved in, unless someone extended the work of Massimo Caboara's Master's student about 4-5 years ago.



---

archive/issue_comments_273978.json:
```json
{
    "body": "Replying to [comment:36 john_perry]:\n> Replying to [comment:35 SimonKing]:\n> > If I see that correctly, the following functions need to be taken care of (all in sage.rings.polynomial.multi_polynomial_ideal):\n> > - `hilbert_series`: Here we can use what I called `hilbert_poincare_series` in sage.rings.hilbert (name according to both the book of Greuel and Pfister, and to the article of Bigatti).\n> > - `hilbert_numerator`: Here we can use what I called `first_hilbert_series` in sage.rings.hilbert (name according to the book of Greuel and Pfister).\n> \n> Thanks. I'll aim for that.\n> \n> > - `hilbert_polynomial`: This needs to be re-implemented.\n> \n> I have done that before, so I should be able to do it for this. :-)\n\nI'm almost done and will probably submit it later today. But of course I'd be glad about a review.",
    "created_at": "2018-09-16T18:02:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273978",
    "user": "SimonKing"
}
```

Replying to [comment:36 john_perry]:
> Replying to [comment:35 SimonKing]:
> > If I see that correctly, the following functions need to be taken care of (all in sage.rings.polynomial.multi_polynomial_ideal):
> > - `hilbert_series`: Here we can use what I called `hilbert_poincare_series` in sage.rings.hilbert (name according to both the book of Greuel and Pfister, and to the article of Bigatti).
> > - `hilbert_numerator`: Here we can use what I called `first_hilbert_series` in sage.rings.hilbert (name according to the book of Greuel and Pfister).
> 
> Thanks. I'll aim for that.
> 
> > - `hilbert_polynomial`: This needs to be re-implemented.
> 
> I have done that before, so I should be able to do it for this. :-)

I'm almost done and will probably submit it later today. But of course I'd be glad about a review.



---

archive/issue_comments_273979.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-09-16T19:48:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273979",
    "user": "SimonKing"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_273980.json:
```json
{
    "body": "With the new commit, the stuff from #26243 is used for all Hilbert series computations. The tests in sage/rings/polynomial pass, so, I guess it is \"needs review\" (I trust that the patchbot will run full tests).\n\nFor the record, here is a timing that comes out of some of my cohomology computations, in a size that Singular can manage:\n\n```\nsage: I\nIdeal (a_1_0^2, a_1_0*b_1_1, b_2_2*a_1_0, b_2_3*a_1_0, b_2_1*b_1_1, a_1_0*b_3_4, a_1_0*b_3_5, a_1_0*b_3_6, b_2_1*b_2_2, b_1_1*b_3_5, b_4_10*a_1_0, b_2_1*b_3_4, b_2_1*b_3_6, b_2_2*b_3_5, b_4_10*b_1_1 + b_2_3*b_3_4 + b_2_3^2*b_1_1 + b_2_2*b_3_6, a_1_0*b_5_17, b_2_1*b_4_10 + b_2_1*b_2_3^2, b_3_4^2 + b_1_1^3*b_3_6 + b_2_2*b_1_1*b_3_4 + b_2_2*b_2_3*b_1_1^2 + b_2_2^3, b_3_4*b_3_5, b_3_4*b_3_6 + b_1_1*b_5_17 + b_2_3*b_1_1*b_3_6 + b_2_3*b_1_1*b_3_4 + b_2_2^2*b_2_3, b_3_5^2 + b_2_1*b_2_3^2, b_3_5*b_3_6, b_3_6^2 + b_2_3*b_1_1*b_3_6 + b_2_2*b_2_3^2 + c_4_11*b_1_1^2, b_2_1*b_5_17, b_4_10*b_3_4 + b_2_3*b_1_1^2*b_3_6 + b_2_3^2*b_3_4 + b_2_2*b_5_17 + b_2_2*b_2_3*b_3_6 + b_2_2*b_2_3^2*b_1_1, b_4_10*b_3_5 + b_2_3^2*b_3_5, b_4_10*b_3_6 + b_2_3*b_5_17 + b_2_3^2*b_3_4 + b_2_2*b_2_3*b_3_6 + b_2_2*c_4_11*b_1_1, b_4_10^2 + b_2_3^2*b_1_1*b_3_6 + b_2_3^4 + b_2_2*b_2_3*b_4_10 + b_2_2^2*c_4_11, b_3_4*b_5_17 + b_2_3*b_1_1*b_5_17 + b_2_3^2*b_1_1*b_3_6 + b_2_3^2*b_1_1*b_3_4 + b_2_2*b_1_1*b_5_17 + b_2_2^2*b_4_10 + c_4_11*b_1_1^4, b_3_5*b_5_17, b_3_6*b_5_17 + b_2_3^2*b_1_1*b_3_6 + b_2_2*b_2_3*b_4_10 + c_4_11*b_1_1*b_3_4 + b_2_3*c_4_11*b_1_1^2, b_4_10*b_5_17 + b_2_3^3*b_3_6 + b_2_3^3*b_3_4 + b_2_2*b_2_3*b_5_17 + b_2_2*b_2_3^2*b_3_6 + b_2_3*c_4_11*b_1_1^3 + b_2_2*c_4_11*b_3_4 + b_2_2*b_2_3*c_4_11*b_1_1, b_5_17^2 + b_2_3^3*b_1_1*b_3_6 + b_2_2*b_2_3*b_1_1*b_5_17 + b_2_2*b_2_3^2*b_1_1*b_3_6 + b_2_2*b_2_3^4 + b_2_2^2*b_2_3*b_4_10 + c_4_11*b_1_1^3*b_3_6 + b_2_3*c_4_11*b_1_1^4 + b_2_3^2*c_4_11*b_1_1^2 + b_2_2*c_4_11*b_1_1*b_3_4 + b_2_2*b_2_3*c_4_11*b_1_1^2 + b_2_2^3*c_4_11) of Multivariate Polynomial Ring in b_2_1, b_2_2, b_2_3, b_4_10, c_4_11, a_1_0, b_1_1, b_3_4, b_3_5, b_3_6, b_5_17 over Finite Field of size 2\nsage: G = I.groebner_basis()    # caching the Gr\u00f6bner bases\n```\n\nNow, with the new commit:\n\n```\nsage: %timeit I.hilbert_polynomial()\nThe slowest run took 9.05 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000 loops, best of 3: 686 \u00b5s per loop\nsage: I.hilbert_polynomial()\n2/3*t^3 + 4*t^2 + 16/3*t + 1\n```\n\nWithout the new commit (i.e., based on using Singular):\n\n```\nsage: %timeit I.hilbert_polynomial()\nThe slowest run took 8.71 times longer than the fastest. This could mean that an intermediate result is being cached.\n100 loops, best of 3: 2.33 ms per loop\nsage: I.hilbert_polynomial()\n2/3*t^3 + 4*t^2 + 16/3*t + 1\n```\n\n----\nLast 10 new commits:",
    "created_at": "2018-09-16T19:48:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273980",
    "user": "SimonKing"
}
```

With the new commit, the stuff from #26243 is used for all Hilbert series computations. The tests in sage/rings/polynomial pass, so, I guess it is "needs review" (I trust that the patchbot will run full tests).

For the record, here is a timing that comes out of some of my cohomology computations, in a size that Singular can manage:

```
sage: I
Ideal (a_1_0^2, a_1_0*b_1_1, b_2_2*a_1_0, b_2_3*a_1_0, b_2_1*b_1_1, a_1_0*b_3_4, a_1_0*b_3_5, a_1_0*b_3_6, b_2_1*b_2_2, b_1_1*b_3_5, b_4_10*a_1_0, b_2_1*b_3_4, b_2_1*b_3_6, b_2_2*b_3_5, b_4_10*b_1_1 + b_2_3*b_3_4 + b_2_3^2*b_1_1 + b_2_2*b_3_6, a_1_0*b_5_17, b_2_1*b_4_10 + b_2_1*b_2_3^2, b_3_4^2 + b_1_1^3*b_3_6 + b_2_2*b_1_1*b_3_4 + b_2_2*b_2_3*b_1_1^2 + b_2_2^3, b_3_4*b_3_5, b_3_4*b_3_6 + b_1_1*b_5_17 + b_2_3*b_1_1*b_3_6 + b_2_3*b_1_1*b_3_4 + b_2_2^2*b_2_3, b_3_5^2 + b_2_1*b_2_3^2, b_3_5*b_3_6, b_3_6^2 + b_2_3*b_1_1*b_3_6 + b_2_2*b_2_3^2 + c_4_11*b_1_1^2, b_2_1*b_5_17, b_4_10*b_3_4 + b_2_3*b_1_1^2*b_3_6 + b_2_3^2*b_3_4 + b_2_2*b_5_17 + b_2_2*b_2_3*b_3_6 + b_2_2*b_2_3^2*b_1_1, b_4_10*b_3_5 + b_2_3^2*b_3_5, b_4_10*b_3_6 + b_2_3*b_5_17 + b_2_3^2*b_3_4 + b_2_2*b_2_3*b_3_6 + b_2_2*c_4_11*b_1_1, b_4_10^2 + b_2_3^2*b_1_1*b_3_6 + b_2_3^4 + b_2_2*b_2_3*b_4_10 + b_2_2^2*c_4_11, b_3_4*b_5_17 + b_2_3*b_1_1*b_5_17 + b_2_3^2*b_1_1*b_3_6 + b_2_3^2*b_1_1*b_3_4 + b_2_2*b_1_1*b_5_17 + b_2_2^2*b_4_10 + c_4_11*b_1_1^4, b_3_5*b_5_17, b_3_6*b_5_17 + b_2_3^2*b_1_1*b_3_6 + b_2_2*b_2_3*b_4_10 + c_4_11*b_1_1*b_3_4 + b_2_3*c_4_11*b_1_1^2, b_4_10*b_5_17 + b_2_3^3*b_3_6 + b_2_3^3*b_3_4 + b_2_2*b_2_3*b_5_17 + b_2_2*b_2_3^2*b_3_6 + b_2_3*c_4_11*b_1_1^3 + b_2_2*c_4_11*b_3_4 + b_2_2*b_2_3*c_4_11*b_1_1, b_5_17^2 + b_2_3^3*b_1_1*b_3_6 + b_2_2*b_2_3*b_1_1*b_5_17 + b_2_2*b_2_3^2*b_1_1*b_3_6 + b_2_2*b_2_3^4 + b_2_2^2*b_2_3*b_4_10 + c_4_11*b_1_1^3*b_3_6 + b_2_3*c_4_11*b_1_1^4 + b_2_3^2*c_4_11*b_1_1^2 + b_2_2*c_4_11*b_1_1*b_3_4 + b_2_2*b_2_3*c_4_11*b_1_1^2 + b_2_2^3*c_4_11) of Multivariate Polynomial Ring in b_2_1, b_2_2, b_2_3, b_4_10, c_4_11, a_1_0, b_1_1, b_3_4, b_3_5, b_3_6, b_5_17 over Finite Field of size 2
sage: G = I.groebner_basis()    # caching the Gröbner bases
```

Now, with the new commit:

```
sage: %timeit I.hilbert_polynomial()
The slowest run took 9.05 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 686 µs per loop
sage: I.hilbert_polynomial()
2/3*t^3 + 4*t^2 + 16/3*t + 1
```

Without the new commit (i.e., based on using Singular):

```
sage: %timeit I.hilbert_polynomial()
The slowest run took 8.71 times longer than the fastest. This could mean that an intermediate result is being cached.
100 loops, best of 3: 2.33 ms per loop
sage: I.hilbert_polynomial()
2/3*t^3 + 4*t^2 + 16/3*t + 1
```

----
Last 10 new commits:



---

archive/issue_comments_273981.json:
```json
{
    "body": "Impressive speedup! Where does it come from? A better algorithm?",
    "created_at": "2018-09-16T20:08:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273981",
    "user": "dimpase"
}
```

Impressive speedup! Where does it come from? A better algorithm?



---

archive/issue_comments_273982.json:
```json
{
    "body": "Replying to [comment:40 dimpase]:\n> Impressive speedup! Where does it come from? A better algorithm?\n\nI am not totally sure. We have to distinguish: `hilbert_numerator` and `hilbert_series` on the one hand, and `hilbert_polynomial` on the other hand.\n\nThe computation of \"first Hilbert series\" (also known as \"Hilbert numerator\") and \"Hilbert-Poincar\u00e9 series\" (also known as \"Hilbert series\") relies on a new implementation introduced at #26243. The original motivation was to allow for really big computations (>70 variables, >2000 ideal generators) that would fail in Singular because of its 32-bit integer limitation. But in the end, it was also about speed: The new implementation beats Singular in medium size examples.\n\nThe algorithm for the Hilbert-Poincar\u00e9 series isn't exactly new, but differs from what is done in Singular as follows. Let `I` be a monomial ideal in a multivariate polynomial Ring `R` and let `m` be a monomial of degree `d`. Then, I think all implementations for the computation of the Hilbert-Poincar\u00e9 series `HP(R/I)` rely on the equation `HP(R/I) = HP(R/(I+m))+t^d*HP(R/(I:(m)))`. The differences lie in the choice of m. Some systems choose m as one of the generators of I and read the above equation backwards: ` HP(R/(I+m)) = HP(R/I) - t^d*HP(R/(I:(m)))`. Singular chooses m to be a variable that appears in at least one generator of degree >1 of I. I think CoCoA uses the gcd of two randomly chosen generators. My implementation chooses m to be the variable that appears most frequently in the generators of I, to the power of the median of all exponents of that variable in the generators of I.\n\nI was told by John Perry that this choice is known in the literature, but I don't have a reference. Anyway, I think part of the speedup is due to good data structures and careful usage of Cython.\n\nHowever, all of the above doesn't apply here. With the example of the above timing for `hilbert_polynomial`, the timings for `hilbert_numerator` and `hilbert_series` have hardly changed. With Singular:\n\n```\nsage: %timeit I.hilbert_numerator()\nThe slowest run took 4.14 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000 loops, best of 3: 270 \u00b5s per loop\nsage: %timeit I.hilbert_series()\nThe slowest run took 5.27 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000 loops, best of 3: 375 \u00b5s per loop\n```\n\nWith the new implementation:\n\n```\nsage: %timeit I.hilbert_numerator()\n1000 loops, best of 3: 280 \u00b5s per loop\nsage: %timeit I.hilbert_series()\nThe slowest run took 5.73 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000 loops, best of 3: 367 \u00b5s per loop\n```\n\n\nSo, in *this* example, the change really is in the computation of `hilbert_polynomial`. Since my code is just straight forward, I really don't know why the old code was so much slower.",
    "created_at": "2018-09-16T20:54:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273982",
    "user": "SimonKing"
}
```

Replying to [comment:40 dimpase]:
> Impressive speedup! Where does it come from? A better algorithm?

I am not totally sure. We have to distinguish: `hilbert_numerator` and `hilbert_series` on the one hand, and `hilbert_polynomial` on the other hand.

The computation of "first Hilbert series" (also known as "Hilbert numerator") and "Hilbert-Poincaré series" (also known as "Hilbert series") relies on a new implementation introduced at #26243. The original motivation was to allow for really big computations (>70 variables, >2000 ideal generators) that would fail in Singular because of its 32-bit integer limitation. But in the end, it was also about speed: The new implementation beats Singular in medium size examples.

The algorithm for the Hilbert-Poincaré series isn't exactly new, but differs from what is done in Singular as follows. Let `I` be a monomial ideal in a multivariate polynomial Ring `R` and let `m` be a monomial of degree `d`. Then, I think all implementations for the computation of the Hilbert-Poincaré series `HP(R/I)` rely on the equation `HP(R/I) = HP(R/(I+m))+t^d*HP(R/(I:(m)))`. The differences lie in the choice of m. Some systems choose m as one of the generators of I and read the above equation backwards: ` HP(R/(I+m)) = HP(R/I) - t^d*HP(R/(I:(m)))`. Singular chooses m to be a variable that appears in at least one generator of degree >1 of I. I think CoCoA uses the gcd of two randomly chosen generators. My implementation chooses m to be the variable that appears most frequently in the generators of I, to the power of the median of all exponents of that variable in the generators of I.

I was told by John Perry that this choice is known in the literature, but I don't have a reference. Anyway, I think part of the speedup is due to good data structures and careful usage of Cython.

However, all of the above doesn't apply here. With the example of the above timing for `hilbert_polynomial`, the timings for `hilbert_numerator` and `hilbert_series` have hardly changed. With Singular:

```
sage: %timeit I.hilbert_numerator()
The slowest run took 4.14 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 270 µs per loop
sage: %timeit I.hilbert_series()
The slowest run took 5.27 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 375 µs per loop
```

With the new implementation:

```
sage: %timeit I.hilbert_numerator()
1000 loops, best of 3: 280 µs per loop
sage: %timeit I.hilbert_series()
The slowest run took 5.73 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 367 µs per loop
```


So, in *this* example, the change really is in the computation of `hilbert_polynomial`. Since my code is just straight forward, I really don't know why the old code was so much slower.



---

archive/issue_comments_273983.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-16T21:05:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273983",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_273984.json:
```json
{
    "body": "By playing with a bigger example (where `I` is the ideal defined in the attachment to #26243), I found that I got the sign wrong, meaning that depending on the example I got the correct polynomial or its negative. The new commit fixes it.\n\nWith the new commit and the example from #26243, I get consistent results (i.e., the Hilbert polynomial seems to return the coefficients of the Hilbert-Poincar\u00e9 series for all but finitely many degrees):\n\n```\nsage: P = PowerSeriesRing(QQ,'t',default_prec=50)\nsage: hp = I.hilbert_series()\nsage: hs = P(hp.numerator())/P(hp.denominator())\nsage: hs\n1 + 77*t + 436*t^2 + 1396*t^3 + 3446*t^4 + 7194*t^5 + 13376*t^6 + 22856*t^7 + 36626*t^8 + 55806*t^9 + 81644*t^10 + 115516*t^11 + 158926*t^12 + 213506*t^13 + 281016*t^14 + 363344*t^15 + 462506*t^16 + 580646*t^17 + 720036*t^18 + 883076*t^19 + 1072294*t^20 + 1290346*t^21 + 1540016*t^22 + 1824216*t^23 + 2145986*t^24 + 2508494*t^25 + 2915036*t^26 + 3369036*t^27 + 3874046*t^28 + 4433746*t^29 + 5051944*t^30 + 5732576*t^31 + 6479706*t^32 + 7297526*t^33 + 8190356*t^34 + 9162644*t^35 + 10218966*t^36 + 11364026*t^37 + 12602656*t^38 + 13939816*t^39 + 15380594*t^40 + 16930206*t^41 + 18593996*t^42 + 20377436*t^43 + 22286126*t^44 + 24325794*t^45 + 26502296*t^46 + 28821616*t^47 + 31289866*t^48 + 33913286*t^49 + O(t^50)\nsage: p = I.hilbert_polynomial()\nsage: p(t=1)  # the only exception\n86\nsage: p(t=2)\n436\nsage: p(t=3)\n1396\nsage: p(t=4)\n3446\nsage: p(t=5)\n7194\nsage: p(t=20)\n1072294\nsage: p(t=40)\n15380594\n```\n",
    "created_at": "2018-09-16T21:16:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273984",
    "user": "SimonKing"
}
```

By playing with a bigger example (where `I` is the ideal defined in the attachment to #26243), I found that I got the sign wrong, meaning that depending on the example I got the correct polynomial or its negative. The new commit fixes it.

With the new commit and the example from #26243, I get consistent results (i.e., the Hilbert polynomial seems to return the coefficients of the Hilbert-Poincaré series for all but finitely many degrees):

```
sage: P = PowerSeriesRing(QQ,'t',default_prec=50)
sage: hp = I.hilbert_series()
sage: hs = P(hp.numerator())/P(hp.denominator())
sage: hs
1 + 77*t + 436*t^2 + 1396*t^3 + 3446*t^4 + 7194*t^5 + 13376*t^6 + 22856*t^7 + 36626*t^8 + 55806*t^9 + 81644*t^10 + 115516*t^11 + 158926*t^12 + 213506*t^13 + 281016*t^14 + 363344*t^15 + 462506*t^16 + 580646*t^17 + 720036*t^18 + 883076*t^19 + 1072294*t^20 + 1290346*t^21 + 1540016*t^22 + 1824216*t^23 + 2145986*t^24 + 2508494*t^25 + 2915036*t^26 + 3369036*t^27 + 3874046*t^28 + 4433746*t^29 + 5051944*t^30 + 5732576*t^31 + 6479706*t^32 + 7297526*t^33 + 8190356*t^34 + 9162644*t^35 + 10218966*t^36 + 11364026*t^37 + 12602656*t^38 + 13939816*t^39 + 15380594*t^40 + 16930206*t^41 + 18593996*t^42 + 20377436*t^43 + 22286126*t^44 + 24325794*t^45 + 26502296*t^46 + 28821616*t^47 + 31289866*t^48 + 33913286*t^49 + O(t^50)
sage: p = I.hilbert_polynomial()
sage: p(t=1)  # the only exception
86
sage: p(t=2)
436
sage: p(t=3)
1396
sage: p(t=4)
3446
sage: p(t=5)
7194
sage: p(t=20)
1072294
sage: p(t=40)
15380594
```




---

archive/issue_comments_273985.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-17T06:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273985",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_273986.json:
```json
{
    "body": "It was needed to special-case zero-dimensional ideals. Problem was: In that case, the pole order of the Hilbert-Poincar\u00e9 series at t=1 is zero, which means one was dividing by the factorial of -1, which gave an error. In fact, if the Hilbert-Poincar\u00e9 series is a polynomial, then all but finitely many slices of R/I are of dimension zero, which means that the Hilbert polynomial is zero.\n\nWhile I was at it: In the first commit on this ticket, I thought I needed to amend the sign, but it turned out that I don't need. Just to be on the safe side, I am now asserting that the leading coefficient of the Hilbert polynomial is positive (it has to be, because if t is sufficiently large then the Hilbert polynomial is a natural number).",
    "created_at": "2018-09-17T06:32:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273986",
    "user": "SimonKing"
}
```

It was needed to special-case zero-dimensional ideals. Problem was: In that case, the pole order of the Hilbert-Poincaré series at t=1 is zero, which means one was dividing by the factorial of -1, which gave an error. In fact, if the Hilbert-Poincaré series is a polynomial, then all but finitely many slices of R/I are of dimension zero, which means that the Hilbert polynomial is zero.

While I was at it: In the first commit on this ticket, I thought I needed to amend the sign, but it turned out that I don't need. Just to be on the safe side, I am now asserting that the leading coefficient of the Hilbert polynomial is positive (it has to be, because if t is sufficiently large then the Hilbert polynomial is a natural number).



---

archive/issue_comments_273987.json:
```json
{
    "body": "Some micro-optimizations: `if len(denom):` -> `if denom:`, you could use `for n, coeff in enumerate(second_hilbert)`, and you do not need to pass a list to `sum` and `prod` (which is slower because it has to create and populate the list).\n\nSome stylistic things: PEP8 spaces are my friend and can be your friend too :P, and error messages in Python are causes (no initial capital letter and no period/full-stop).\n\nI think it would be good to still have a way to access the Singular implementation through an `algorithm` keyword (of course, defaulting to `'sage'`). (Is this there, and I missed it?) That way you can implement more robust tests by comparing the results and perhaps there are some cases where Singular does win that someone may need frequently.",
    "created_at": "2018-09-17T08:13:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273987",
    "user": "tscrim"
}
```

Some micro-optimizations: `if len(denom):` -> `if denom:`, you could use `for n, coeff in enumerate(second_hilbert)`, and you do not need to pass a list to `sum` and `prod` (which is slower because it has to create and populate the list).

Some stylistic things: PEP8 spaces are my friend and can be your friend too :P, and error messages in Python are causes (no initial capital letter and no period/full-stop).

I think it would be good to still have a way to access the Singular implementation through an `algorithm` keyword (of course, defaulting to `'sage'`). (Is this there, and I missed it?) That way you can implement more robust tests by comparing the results and perhaps there are some cases where Singular does win that someone may need frequently.



---

archive/issue_comments_273988.json:
```json
{
    "body": "Replying to [comment:46 tscrim]:\n> Some micro-optimizations: `if len(denom):` -> `if denom:`,\n\nOK. I was not sure if a factorisation object behaves the same as a list.\n\n> I think it would be good to still have a way to access the Singular implementation through an `algorithm` keyword (of course, defaulting to `'sage'`). (Is this there, and I missed it?) That way you can implement more robust tests by comparing the results and perhaps there are some cases where Singular does win that someone may need frequently.\n\nThat's a very good idea! So, I should merge in the old implementation.",
    "created_at": "2018-09-17T08:24:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273988",
    "user": "SimonKing"
}
```

Replying to [comment:46 tscrim]:
> Some micro-optimizations: `if len(denom):` -> `if denom:`,

OK. I was not sure if a factorisation object behaves the same as a list.

> I think it would be good to still have a way to access the Singular implementation through an `algorithm` keyword (of course, defaulting to `'sage'`). (Is this there, and I missed it?) That way you can implement more robust tests by comparing the results and perhaps there are some cases where Singular does win that someone may need frequently.

That's a very good idea! So, I should merge in the old implementation.



---

archive/issue_comments_273989.json:
```json
{
    "body": "Replying to [comment:47 SimonKing]:\n> Replying to [comment:46 tscrim]:\n> > Some micro-optimizations: `if len(denom):` -> `if denom:`,\n> \n> OK. I was not sure if a factorisation object behaves the same as a list.\n\nThis is true in basically every case I've come across:\n\n```\nsage: f = factor(123521321)\nsage: f\n7 * 11 * 997 * 1609\nsage: %timeit bool(len(f))\nThe slowest run took 35.73 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 334 ns per loop\nsage: %timeit bool(f)\nThe slowest run took 34.95 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 314 ns per loop\n```\n",
    "created_at": "2018-09-17T08:49:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273989",
    "user": "tscrim"
}
```

Replying to [comment:47 SimonKing]:
> Replying to [comment:46 tscrim]:
> > Some micro-optimizations: `if len(denom):` -> `if denom:`,
> 
> OK. I was not sure if a factorisation object behaves the same as a list.

This is true in basically every case I've come across:

```
sage: f = factor(123521321)
sage: f
7 * 11 * 997 * 1609
sage: %timeit bool(len(f))
The slowest run took 35.73 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 334 ns per loop
sage: %timeit bool(f)
The slowest run took 34.95 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 314 ns per loop
```




---

archive/issue_comments_273990.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-17T10:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273990",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_273991.json:
```json
{
    "body": "I changed the (old!) error message to lower case and removed the full-stop. And I hope the style is now enough \"spacey\"...\n\nMoreover, I added an optional parameter `algorithm`.\n\nHowever, one thing is very very strange now. A doctest that previously worked is now still giving the correct result, but also showing an odd comment; this does NOT happen when running the test interactively:\n\n```\nFile \"src/sage/rings/polynomial/multi_polynomial_ideal.py\", line 2506, in sage.rings.polynomial.multi_polynomial_ideal.?.hilbert_series\nFailed example:\n    I.hilbert_series()\nExpected:\n    (t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)\nGot:\n       skipping text from `parameter`\n    (t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)\n```\n\nWTH??\n----\nNew commits:",
    "created_at": "2018-09-17T10:30:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273991",
    "user": "SimonKing"
}
```

I changed the (old!) error message to lower case and removed the full-stop. And I hope the style is now enough "spacey"...

Moreover, I added an optional parameter `algorithm`.

However, one thing is very very strange now. A doctest that previously worked is now still giving the correct result, but also showing an odd comment; this does NOT happen when running the test interactively:

```
File "src/sage/rings/polynomial/multi_polynomial_ideal.py", line 2506, in sage.rings.polynomial.multi_polynomial_ideal.?.hilbert_series
Failed example:
    I.hilbert_series()
Expected:
    (t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)
Got:
       skipping text from `parameter`
    (t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)
```

WTH??
----
New commits:



---

archive/issue_comments_273992.json:
```json
{
    "body": "Apparently the comment is an artefact from a previous libsingular error:\n\n```\nsage: n = 4; m = 11; P = PolynomialRing(QQ, n * m, \"x\"); x = P.gens(); M = Matrix(n, x)\nsage: Minors = P.ideal(M.minors(2))\nsage: hp = Minors.hilbert_polynomial(); hp\n1/21772800*t^13 + 61/21772800*t^12 + 1661/21772800*t^11 + 26681/21772800*t^10 + 93841/7257600*t^9 + 685421/7257600*t^8 + 1524809/3110400*t^7 + 39780323/21772800*t^6 + 6638071/1360800*t^5 + 12509761/1360800*t^4 + 2689031/226800*t^3 + 1494509/151200*t^2 + 12001/2520*t + 1\nsage: Minors.hilbert_polynomial(algorithm = 'singular')\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\nRuntimeError: Error raised calling singular function\nException RuntimeError: RuntimeError('Error raised calling singular function',) in 'sage.libs.singular.function.LibraryCallHandler.handle_call' ignored\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\n<ipython-input-2-bfe31fe9a36b> in <module>()\n----> 1 Minors.hilbert_polynomial(algorithm = 'singular')\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_ideal.pyc in __call__(self, *args, **kwds)\n    295         if not R.base_ring().is_field():\n    296             raise ValueError(\"Coefficient ring must be a field for function '%s'.\"%(self.f.__name__))\n--> 297         return self.f(self._instance, *args, **kwds)\n    298 \n    299 require_field = RequireField\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_ideal.pyc in hilbert_polynomial(self, algorithm)\n   2466             hilbPoly = sage.libs.singular.function_factory.ff.poly__lib.hilbPoly\n   2467 \n-> 2468             hp = hilbPoly(self)\n   2469             t = ZZ['t'].gen()\n   2470             fp = ZZ(len(hp)-1).factorial()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/libs/singular/function.pyx in sage.libs.singular.function.SingularFunction.__call__ (build/cythonized/sage/libs/singular/function.cpp:15394)()\n   1328         if not (isinstance(ring, MPolynomialRing_libsingular) or isinstance(ring, NCPolynomialRing_plural)):\n   1329             raise TypeError(\"Cannot call Singular function '%s' with ring parameter of type '%s'\"%(self._name,type(ring)))\n-> 1330         return call_function(self, args, ring, interruptible, attributes)\n   1331 \n   1332     def _instancedoc_(self):\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/libs/singular/function.pyx in sage.libs.singular.function.call_function (build/cythonized/sage/libs/singular/function.cpp:17499)()\n   1526     if errorreported:\n   1527         errorreported = 0\n-> 1528         raise RuntimeError(\"error in Singular function call %r:\\n%s\" %\n   1529             (self._name, \"\\n\".join(error_messages)))\n   1530 \n\nRuntimeError: error in Singular function call 'hilbPoly':\nint overflow in hilb 1\nerror occurred in or before poly.lib::hilbPoly line 58: `   intvec v=hilb(I,2);`\nexpected intvec-expression. type 'help intvec;'\nsage: P.<x,y,z> = PolynomialRing(QQ)\nsage: I = Ideal([x^3*y^2 + 3*x^2*y^2*z + y^3*z^2 + z^5])\nsage: I.hilbert_series()\n   skipping text from `parameter`\n(t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)\nsage: P.<x,y,z> = PolynomialRing(QQ)\nsage: I = Ideal([x^3*y^2 + 3*x^2*y^2*z + y^3*z^2 + z^5])\nsage: I.hilbert_series()\n(t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)\n```\n\n\nWhat shall I do to fix it?",
    "created_at": "2018-09-17T10:41:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273992",
    "user": "SimonKing"
}
```

Apparently the comment is an artefact from a previous libsingular error:

```
sage: n = 4; m = 11; P = PolynomialRing(QQ, n * m, "x"); x = P.gens(); M = Matrix(n, x)
sage: Minors = P.ideal(M.minors(2))
sage: hp = Minors.hilbert_polynomial(); hp
1/21772800*t^13 + 61/21772800*t^12 + 1661/21772800*t^11 + 26681/21772800*t^10 + 93841/7257600*t^9 + 685421/7257600*t^8 + 1524809/3110400*t^7 + 39780323/21772800*t^6 + 6638071/1360800*t^5 + 12509761/1360800*t^4 + 2689031/226800*t^3 + 1494509/151200*t^2 + 12001/2520*t + 1
sage: Minors.hilbert_polynomial(algorithm = 'singular')
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
RuntimeError: Error raised calling singular function
Exception RuntimeError: RuntimeError('Error raised calling singular function',) in 'sage.libs.singular.function.LibraryCallHandler.handle_call' ignored
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-2-bfe31fe9a36b> in <module>()
----> 1 Minors.hilbert_polynomial(algorithm = 'singular')

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_ideal.pyc in __call__(self, *args, **kwds)
    295         if not R.base_ring().is_field():
    296             raise ValueError("Coefficient ring must be a field for function '%s'."%(self.f.__name__))
--> 297         return self.f(self._instance, *args, **kwds)
    298 
    299 require_field = RequireField

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_ideal.pyc in hilbert_polynomial(self, algorithm)
   2466             hilbPoly = sage.libs.singular.function_factory.ff.poly__lib.hilbPoly
   2467 
-> 2468             hp = hilbPoly(self)
   2469             t = ZZ['t'].gen()
   2470             fp = ZZ(len(hp)-1).factorial()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/libs/singular/function.pyx in sage.libs.singular.function.SingularFunction.__call__ (build/cythonized/sage/libs/singular/function.cpp:15394)()
   1328         if not (isinstance(ring, MPolynomialRing_libsingular) or isinstance(ring, NCPolynomialRing_plural)):
   1329             raise TypeError("Cannot call Singular function '%s' with ring parameter of type '%s'"%(self._name,type(ring)))
-> 1330         return call_function(self, args, ring, interruptible, attributes)
   1331 
   1332     def _instancedoc_(self):

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/libs/singular/function.pyx in sage.libs.singular.function.call_function (build/cythonized/sage/libs/singular/function.cpp:17499)()
   1526     if errorreported:
   1527         errorreported = 0
-> 1528         raise RuntimeError("error in Singular function call %r:\n%s" %
   1529             (self._name, "\n".join(error_messages)))
   1530 

RuntimeError: error in Singular function call 'hilbPoly':
int overflow in hilb 1
error occurred in or before poly.lib::hilbPoly line 58: `   intvec v=hilb(I,2);`
expected intvec-expression. type 'help intvec;'
sage: P.<x,y,z> = PolynomialRing(QQ)
sage: I = Ideal([x^3*y^2 + 3*x^2*y^2*z + y^3*z^2 + z^5])
sage: I.hilbert_series()
   skipping text from `parameter`
(t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)
sage: P.<x,y,z> = PolynomialRing(QQ)
sage: I = Ideal([x^3*y^2 + 3*x^2*y^2*z + y^3*z^2 + z^5])
sage: I.hilbert_series()
(t^4 + t^3 + t^2 + t + 1)/(t^2 - 2*t + 1)
```


What shall I do to fix it?



---

archive/issue_comments_273993.json:
```json
{
    "body": "The easiest solution would be to remove the test that demonstrates the shortcomings of Singular (maybe that would also be better for my karma). Do you agree it can be removed?",
    "created_at": "2018-09-17T11:51:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273993",
    "user": "SimonKing"
}
```

The easiest solution would be to remove the test that demonstrates the shortcomings of Singular (maybe that would also be better for my karma). Do you agree it can be removed?



---

archive/issue_comments_273994.json:
```json
{
    "body": "Rather than remove it, I would mark it as either `# known bug (20145)` or `# not tested` (with a quick explanation why it is not tested).",
    "created_at": "2018-09-17T12:07:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273994",
    "user": "tscrim"
}
```

Rather than remove it, I would mark it as either `# known bug (20145)` or `# not tested` (with a quick explanation why it is not tested).



---

archive/issue_comments_273995.json:
```json
{
    "body": "Replying to [comment:53 tscrim]:\n> Rather than remove it, I would mark it as either `# known bug (20145)` or `# not tested` (with a quick explanation why it is not tested).\n\n\"not tested\" might be an option. If I understand correctly, \"known bug\" would still mean that it is tested, right? That would be bad, because of the side-effect of the error.\n\nIn any case, I will open a new ticket so that the side-effect can be fixed. And I would prefer to remove the test for now and introduce it at the new ticket (showing that the side-effect is fixed).",
    "created_at": "2018-09-17T12:14:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273995",
    "user": "SimonKing"
}
```

Replying to [comment:53 tscrim]:
> Rather than remove it, I would mark it as either `# known bug (20145)` or `# not tested` (with a quick explanation why it is not tested).

"not tested" might be an option. If I understand correctly, "known bug" would still mean that it is tested, right? That would be bad, because of the side-effect of the error.

In any case, I will open a new ticket so that the side-effect can be fixed. And I would prefer to remove the test for now and introduce it at the new ticket (showing that the side-effect is fixed).



---

archive/issue_comments_273996.json:
```json
{
    "body": "Replying to [comment:54 SimonKing]:\n> Replying to [comment:53 tscrim]:\n> > Rather than remove it, I would mark it as either `# known bug (20145)` or `# not tested` (with a quick explanation why it is not tested).\n> \n> \"not tested\" might be an option. If I understand correctly, \"known bug\" would still mean that it is tested, right? That would be bad, because of the side-effect of the error.\n\nI don't remember off-hand. However, it is simple enough to test.\n\n> In any case, I will open a new ticket so that the side-effect can be fixed. And I would prefer to remove the test for now and introduce it at the new ticket (showing that the side-effect is fixed).\n\nI would prefer `# not tested` (unless that is what you meant by remove). At least that gives an example to the user where it doesn't work and the side effect is the only reason it would not be tested.",
    "created_at": "2018-09-17T12:18:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273996",
    "user": "tscrim"
}
```

Replying to [comment:54 SimonKing]:
> Replying to [comment:53 tscrim]:
> > Rather than remove it, I would mark it as either `# known bug (20145)` or `# not tested` (with a quick explanation why it is not tested).
> 
> "not tested" might be an option. If I understand correctly, "known bug" would still mean that it is tested, right? That would be bad, because of the side-effect of the error.

I don't remember off-hand. However, it is simple enough to test.

> In any case, I will open a new ticket so that the side-effect can be fixed. And I would prefer to remove the test for now and introduce it at the new ticket (showing that the side-effect is fixed).

I would prefer `# not tested` (unless that is what you meant by remove). At least that gives an example to the user where it doesn't work and the side effect is the only reason it would not be tested.



---

archive/issue_comments_273997.json:
```json
{
    "body": "See #26300. One possibility would be to wait and see if #26300 can easily be fixed (say, within one day). Then, #26300 can be a dependency for this ticket (when I created #26300, I did it the other way around).",
    "created_at": "2018-09-17T12:23:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273997",
    "user": "SimonKing"
}
```

See #26300. One possibility would be to wait and see if #26300 can easily be fixed (say, within one day). Then, #26300 can be a dependency for this ticket (when I created #26300, I did it the other way around).



---

archive/issue_comments_273998.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-17T17:57:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273998",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_273999.json:
```json
{
    "body": "I hope that the last commit complies with your suggestion: The test is still present, but marked `# not tested`, and it is commented that this is because of a side-effect that is investigated at #26300.",
    "created_at": "2018-09-17T17:59:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-273999",
    "user": "SimonKing"
}
```

I hope that the last commit complies with your suggestion: The test is still present, but marked `# not tested`, and it is commented that this is because of a side-effect that is investigated at #26300.



---

archive/issue_comments_274000.json:
```json
{
    "body": "Yes, that is good. I made a few other tweaks to match PEP8 and our coding/doc conventions in Sage. If my changes are good, then positive review.\n----\nNew commits:",
    "created_at": "2018-09-17T22:20:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274000",
    "user": "tscrim"
}
```

Yes, that is good. I made a few other tweaks to match PEP8 and our coding/doc conventions in Sage. If my changes are good, then positive review.
----
New commits:



---

archive/issue_comments_274001.json:
```json
{
    "body": "I trust that the tests still pass (didn't check myself). Your changes look good to me. However, although I did read PEP8, I don't understand why you added blank spaces around some operators and removed blank spaces around others. And where can I read about doc formatting conventions of Sage (in particular when it is about optional parameters)?",
    "created_at": "2018-09-18T06:37:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274001",
    "user": "SimonKing"
}
```

I trust that the tests still pass (didn't check myself). Your changes look good to me. However, although I did read PEP8, I don't understand why you added blank spaces around some operators and removed blank spaces around others. And where can I read about doc formatting conventions of Sage (in particular when it is about optional parameters)?



---

archive/issue_comments_274002.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-09-18T06:37:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274002",
    "user": "SimonKing"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_274003.json:
```json
{
    "body": "PEP8 allows you to not write spaces for higher priority operators. So like in the exponentiation, that is higher than the addition, and thus, I don't need the spaces around the `**`. Of course, that is my own stylistic preference showing. :) For this:\n\n```diff\n-    def hilbert_series(self, grading = None, algorithm = 'sage'):\n+    def hilbert_series(self, grading=None, algorithm='sage'):\n```\n\n\n```diff\n-                return self.hilbert_numerator(algorithm = 'singular') / (1 - t)**n\n+                return self.hilbert_numerator(algorithm='singular') / (1 - t)**n\n```\n\nPEP8 says arguments should not have space around the `=`.\n\nSome of these things are not directly specified in the Sage doc conventions, but done as a general accepted-ish convention. At least, an `optional` to me means it does not have a default value (in some appropriate sense of the term for a user).",
    "created_at": "2018-09-18T06:50:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274003",
    "user": "tscrim"
}
```

PEP8 allows you to not write spaces for higher priority operators. So like in the exponentiation, that is higher than the addition, and thus, I don't need the spaces around the `**`. Of course, that is my own stylistic preference showing. :) For this:

```diff
-    def hilbert_series(self, grading = None, algorithm = 'sage'):
+    def hilbert_series(self, grading=None, algorithm='sage'):
```


```diff
-                return self.hilbert_numerator(algorithm = 'singular') / (1 - t)**n
+                return self.hilbert_numerator(algorithm='singular') / (1 - t)**n
```

PEP8 says arguments should not have space around the `=`.

Some of these things are not directly specified in the Sage doc conventions, but done as a general accepted-ish convention. At least, an `optional` to me means it does not have a default value (in some appropriate sense of the term for a user).



---

archive/issue_comments_274004.json:
```json
{
    "body": "Replying to [comment:61 tscrim]:\n> PEP8 allows you to not write spaces for higher priority operators. So like in the exponentiation, that is higher than the addition, and thus, I don't need the spaces around the `**`. Of course, that is my own stylistic preference showing. :)\n\nMy intention (although I quite often do typos) is to put spaces around...\n- assignments of variables (but not of optional arguments): `bla = foo(bar)`\n- comparisons: `if bla <= foo:`\n- `+` and `-`\n- after (but not before) a comma or semicolon\nand to *not* put spaces around\n- `*`, `/` and `**`, because they have higher priority than `+` and `-`: `(2*x - 1)**4)`\n- assignments of optional arguments: `foo(bla, bar=4)`\n\nActually I dislike `(4 * x - 1) ** 3`, I find it difficult to read.\n\nWould the above comply to PEP8?",
    "created_at": "2018-09-18T09:12:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274004",
    "user": "SimonKing"
}
```

Replying to [comment:61 tscrim]:
> PEP8 allows you to not write spaces for higher priority operators. So like in the exponentiation, that is higher than the addition, and thus, I don't need the spaces around the `**`. Of course, that is my own stylistic preference showing. :)

My intention (although I quite often do typos) is to put spaces around...
- assignments of variables (but not of optional arguments): `bla = foo(bar)`
- comparisons: `if bla <= foo:`
- `+` and `-`
- after (but not before) a comma or semicolon
and to *not* put spaces around
- `*`, `/` and `**`, because they have higher priority than `+` and `-`: `(2*x - 1)**4)`
- assignments of optional arguments: `foo(bla, bar=4)`

Actually I dislike `(4 * x - 1) ** 3`, I find it difficult to read.

Would the above comply to PEP8?



---

archive/issue_comments_274005.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2018-09-18T22:33:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274005",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_274006.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2018-09-18T22:33:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274006",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_274007.json:
```json
{
    "body": "Replying to [comment:62 SimonKing]:\n> Replying to [comment:61 tscrim]:\n> > PEP8 allows you to not write spaces for higher priority operators. So like in the exponentiation, that is higher than the addition, and thus, I don't need the spaces around the `**`. Of course, that is my own stylistic preference showing. :)\n> \n> My intention (although I quite often do typos) is to put spaces around...\n> - assignments of variables (but not of optional arguments): `bla = foo(bar)`\n> - comparisons: `if bla <= foo:`\n> - `+` and `-`\n> - after (but not before) a comma or semicolon\n> and to *not* put spaces around\n> - `*`, `/` and `**`, because they have higher priority than `+` and `-`: `(2*x - 1)**4)`\n> - assignments of optional arguments: `foo(bla, bar=4)`\n> \n> Actually I dislike `(4 * x - 1) ** 3`, I find it difficult to read.\n> \n> Would the above comply to PEP8?\n\nBy my understanding, yes. Of course, I don't always follow it as PEP8 are more guidelines, but I do try to stay as close to it as I can.",
    "created_at": "2018-09-18T22:34:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274007",
    "user": "tscrim"
}
```

Replying to [comment:62 SimonKing]:
> Replying to [comment:61 tscrim]:
> > PEP8 allows you to not write spaces for higher priority operators. So like in the exponentiation, that is higher than the addition, and thus, I don't need the spaces around the `**`. Of course, that is my own stylistic preference showing. :)
> 
> My intention (although I quite often do typos) is to put spaces around...
> - assignments of variables (but not of optional arguments): `bla = foo(bar)`
> - comparisons: `if bla <= foo:`
> - `+` and `-`
> - after (but not before) a comma or semicolon
> and to *not* put spaces around
> - `*`, `/` and `**`, because they have higher priority than `+` and `-`: `(2*x - 1)**4)`
> - assignments of optional arguments: `foo(bla, bar=4)`
> 
> Actually I dislike `(4 * x - 1) ** 3`, I find it difficult to read.
> 
> Would the above comply to PEP8?

By my understanding, yes. Of course, I don't always follow it as PEP8 are more guidelines, but I do try to stay as close to it as I can.



---

archive/issue_comments_274008.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-09-18T22:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274008",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_274009.json:
```json
{
    "body": "Last commit was a trivial fix of a doctest and merging in a fix of a bad block from #26243. I'm allowing myself to reset to positive.",
    "created_at": "2018-09-18T22:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274009",
    "user": "tscrim"
}
```

Last commit was a trivial fix of a doctest and merging in a fix of a bad block from #26243. I'm allowing myself to reset to positive.



---

archive/issue_comments_274010.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-09-21T22:20:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19908#issuecomment-274010",
    "user": "vbraun"
}
```

Resolution: fixed
