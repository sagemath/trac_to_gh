# Issue 23561: Fractional Chromatic Index Infinite Loop fails with GLPK

Issue created by migration from https://trac.sagemath.org/ticket/23798

Original creator: jdemeyer

Original creation time: 2017-09-07 11:51:23

CC:  dcoudert

The test

```
            sage: g = graphs.PetersenGraph()
            sage: g.fractional_chromatic_index(solver='GLPK')
            3.0
```

added by #23658 fails with GLPK on 32-bit.


---

Comment by dcoudert created at 2017-09-07 13:31:06

I suspect that we need to change `if M.solve(log = verbose) <= 1:` to `if M.solve(log = verbose) <= 1 + tol:`, where `tol = 0 if solver=='PPL' else 1e-6`. I don't like this solution, but I don't know what else we can do. 

I don't have access to a 32-bit machine and so cannot test.


---

Comment by jdemeyer created at 2017-09-07 15:01:08

You could also forbid using a non-exact solver for this problem.


---

Comment by dcoudert created at 2017-09-07 17:09:36

Sure, we can force `PPL`, but it is way slower (can sometimes be faster on small graphs).

```
sage: G = graphs.Grid2dGraph(6,6)
sage: %time G.fractional_chromatic_index(solver='GLPK')
CPU times: user 43.4 ms, sys: 4.9 ms, total: 48.3 ms
Wall time: 52.1 ms
4.0
sage: %time G.fractional_chromatic_index(solver='PPL')
CPU times: user 1min 11s, sys: 256 ms, total: 1min 11s
Wall time: 1min 12s
4
```

I agree that using a tolerance gap is not a nice solution either.


---

Comment by dcoudert created at 2017-10-21 08:51:35

I don't see better solution than making `PPL` the default solver here.
----
New commits:


---

Comment by dcoudert created at 2017-10-21 08:51:35

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-10-22 20:05:52

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-10-22 20:05:52

"Be aware that this method may loop endlessly when using some non exact solvers on 32-bits". I doubt that this is problem specific to 32 bits. The wording seems to imply that it's safe to use non-exact solvers on 64-bit machines.


---

Comment by jdemeyer created at 2017-10-22 20:07:28

Also, this isn't quite correct:

```
Tickets :trac:`23658` and :trac:`23798` are fixed::
```

followed by a test with GLPK.


---

Comment by git created at 2017-10-22 21:23:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2017-10-22 21:24:39

Is this more appropriate ?


---

Comment by dcoudert created at 2017-10-22 21:24:39

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-10-23 07:19:54

Well, it depends. Do you consider the code here to be a fix or a workaround? I am asking because you need to decide what to do with

```
sage: g.fractional_chromatic_index(solver='GLPK') # known bug (#23798)
```

You cannot say that this ticket is a known bug while at the same time fixing this ticket.


---

Comment by jdemeyer created at 2017-10-23 08:03:12

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2017-10-23 20:05:43

The problem is not fixed. That's why I changed the text to `Issue reported in :trac:`23658` and :trac:`23798` with non exact solvers::`. What else can I write to be more correct/specific?


---

Comment by jdemeyer created at 2017-10-24 17:18:46

Replying to [comment:13 dcoudert]:
> The problem is not fixed.

Then I'm moving your branch to a new ticket: #24099.


---

Comment by dcoudert created at 2017-10-24 19:06:50

OK, thanks.


---

Comment by dcoudert created at 2020-08-30 11:45:30

Since #24824, we use GLPK 4.65.
Does anyone with access to a 32-bit machine still see the bug ?


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by @DaveWitteMorris created at 2021-07-12 04:26:49

Replying to [comment:17 dcoudert]:
> Since #24824, we use GLPK 4.65.
> Does anyone with access to a 32-bit machine still see the bug ?

I still see the bug (on a 32-bit debian virtual machine). The default solver seems instantaneous, but I let `solver='GLPK'` run for about 15 minutes and did not get an answer.


---

Comment by dcoudert created at 2021-07-12 22:36:55

This is unfortunate.

The only solutions I see are:
- Force to use `PPL`, but this is not nice for users with a 64 bits machine (most of the users I guess)
- Raise an error when the solver is `glpk` on a 32 bits machine
and none of them are satisfactory.


---

Comment by mkoeppe created at 2021-07-12 22:44:39

Replying to [comment:3 dcoudert]:
> I suspect that we need to change `if M.solve(log = verbose) <= 1:` to `if M.solve(log = verbose) <= 1 + tol:`, where `tol = 0 if solver=='PPL' else 1e-6`. I don't like this solution, but I don't know what else we can do. 

Using a tolerance is exactly the right solution. The test for exact `<= 1` and `== 1` is meaningless with a numerical LP solver. LP solvers use perturbations systematically. It is not a bug if the result is not an exact integer.


---

Comment by mkoeppe created at 2021-07-12 22:49:31

See also my explanations in #30635#comment:20 and following.


---

Comment by dimpase created at 2021-07-13 10:08:57

there are two LPs involved, one of them for a maximum weight matching, something that can be instead done by a combinatorial algorithm, see e.g. Blossom V in http://pub.ist.ac.at/~vnk/software.html


---

Comment by dimpase created at 2021-07-13 10:20:35

If I force PPL on the inner (matching) LP:

```diff
--- a/src/sage/graphs/graph_coloring.pyx
+++ b/src/sage/graphs/graph_coloring.pyx
@@ -825,7 +825,7 @@ def fractional_chromatic_index(G, solver="PPL", verbose_constraints=False, verbo
     frozen_edges = [frozenset(e) for e in G.edges(labels=False, sort=False)]
 
     # Initialize LP for maximum weight matching
-    M = MixedIntegerLinearProgram(solver=solver, constraint_generation=True)
+    M = MixedIntegerLinearProgram(solver="PPL", constraint_generation=True)
 
     # One variable per edge
     b = M.new_variable(binary=True, nonnegative=True)
```

then on a 32-bit system it's all fine (GLPK from the system, unpatched, so these extra messages)

```
sage: G=graphs.PetersenGraph()
sage: G.fractional_chromatic_index(solver="GLPK")
Long-step dual simplex will be used
Long-step dual simplex will be used
Long-step dual simplex will be used
Long-step dual simplex will be used
Long-step dual simplex will be used
Long-step dual simplex will be used
3.0
```



---

Comment by dcoudert created at 2021-07-13 14:39:47

Following above discussion, I added a tolerance gap for numerical LP solvers. 

Note that we can use the `networkx` implementation of the blossom algorithm via the `matching` method, but it does not solve the issue. Actually, it's slower and worse for the rounding as I observe the issue on a 64 bits machine...
----
New commits:


---

Comment by dcoudert created at 2021-07-13 14:39:47

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2021-07-13 22:15:01

I don’t  like this approach. Without explicit guarantees that these tolerances are correct, it is replacing correct algorithms with heuristics.


---

Comment by mkoeppe created at 2021-07-13 22:21:48


```
         matching = [fe for fe in frozen_edges if M.get_values(b[fe]) == 1]
```

This line also needs changing because the test "== 1" is not robust.


---

Comment by dimpase created at 2021-07-13 22:48:31

I don’t see how one can make the oracle (the inner LP) inexact, without potentially returning a very wrong answer. 

The oracle checks that there is no maximum weight matching of weight >1. Say, we let it error by epsilon, i.e we terminate with oracle returning 1+epsilon. Potentially, there could be K maximum matchings with this weight, if they are disjoint this means that the final error is K times epsilon, oops…


---

Comment by dimpase created at 2021-07-13 22:50:28

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2021-07-14 10:48:34

I don't like this solution either but I don't know what to do when a solver returns 0.99999... instead of 1 although we have set the variable type to binary. The solvers are aware of the type of the variable and so should return a value with the correct type and not a double. The solution might be in the backends.


---

Comment by dimpase created at 2021-07-14 21:48:02

Replying to [comment:32 dcoudert]:
> I don't like this solution either but I don't know what to do when a solver returns 0.99999... instead of 1 although we have set the variable type to binary. The solvers are aware of the type of the variable and so should return a value with the correct type and not a double. The solution might be in the backends. 

No, my point is that without a special analysis it's not possible to argue that solving the oracle problem  (with non-integer objective function) inexactly provides a correct result, even if you "correctly" round 0.9999... to 1. It's because a small oracle error may get amplified a lot in the main LP. 
Welcome to floating point hell :-)|


---

Comment by dimpase created at 2021-07-15 12:24:24

Replying to [comment:27 dcoudert]:
> Following above discussion, I added a tolerance gap for numerical LP solvers. 
> 
> Note that we can use the `networkx` implementation of the blossom algorithm via the `matching` method, but it does not solve the issue. Actually, it's slower and worse for the rounding as I observe the issue on a 64 bits machine...


The oracle implementation here is naive, and bound to get very slow; it's integer LP without Edmonds' constraints,
instead of a "normal" LP over the matching polytope with Edmonds' constraints (aka blossom inequalities).
So this would need yet another oracle (as there are too exponentially many inequalities there), but well, it's polynomial time then.
The generated constraints can stay, so this should be fast.

> ----
> New commits:
> ||[ebcde7c](https://git.sagemath.org/sage.git/commit?id=ebcde7c37ea3a8377fbcebe2246aae890e9df305)||`trac #23798: add tolerance gap for numerical LP solvers`||


---

Comment by mkoeppe created at 2021-07-19 14:24:43

I took a quick look at the function now. I would suggest the following changes:

1. Before adding a new constraint to the master problem, verify that `matching` is indeed a matching. In this way, the master problem will always be a correct relaxation, even if an inexact oracle is used.

2. When the numerical solver that is used for solving the separation problem does not find a matching of value greater than 1 + epsilon, you can switch to PPL - then, with a bit of luck, it can prove the bound <= 1.

3. It will make sense to have separate parameters for the solver used for the master problem and the one(s) used for the separation problem.


---

Comment by dimpase created at 2021-07-19 17:25:03

Actually, it seems that even with PPL, the code is just wrong, as PPL does not do MILP, it only does LP, right?


---

Comment by mkoeppe created at 2021-07-19 18:35:21

The PPL does have a (very limited) MIP solver.


---

Comment by git created at 2021-11-06 16:25:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2021-11-06 16:28:16

I tried the ideas from #comment:35. I have let some code for debugging as the code may loop forever when using `GLPK` for both master and separation problems. The patchbot will complain...

We should search for another method not relying on LP solvers, if any...
