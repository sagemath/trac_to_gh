# Issue 18247: Add test if a matroid is Ternary

Issue created by migration from Trac.

Original creator: Rudi

Original creation time: 2015-05-24 10:01:06

Assignee: Rudi

There is a straightforward test to see if a matroid is ternary: generate the ternary representation local to a basis, and check matroid isomorphism. Implement this algorithm. See Matroid.is_binary().


---

Comment by Rudi created at 2015-06-17 20:41:41

Last 10 new commits:


---

Comment by Rudi created at 2015-06-20 20:43:15

I seem to have messed up this one. I'll make a fresh start.


---

Comment by Rudi created at 2015-06-20 20:43:15

Remove assignee Rudi.


---

Comment by Rudi created at 2015-06-20 20:43:50

Changing component from matroid theory to PLEASE CHANGE.


---

Comment by tscrim created at 2015-06-20 21:16:36

Changing keywords from "" to "chord".


---

Comment by tscrim created at 2015-06-20 21:16:36

Changing component from PLEASE CHANGE to matroid theory.


---

Comment by tscrim created at 2015-06-20 21:16:36

It's better to not create a new ticket, but instead just push a new branch.

Anyways, I'm going to recycle this ticket for k-chordality of a matroid (code to follow shortly, probably tomorrow).


---

Comment by Rudi created at 2015-06-20 21:56:02

Replying to [comment:6 tscrim]:
> It's better to not create a new ticket, but instead just push a new branch.
> 
I tried, but apparently I was using the wrong command. Just `git trac push 18484` from my new branch was rejected. I did not see how to scrap the existing branch.

> Anyways, I'm going to recycle this ticket for k-chordality of a matroid (code to follow shortly, probably tomorrow).

Will your algorithm check that definition directly? If so, a matroid M of rank >k is k-chordal if and only if  it's rank-k truncation T is, since M and T will have the same collection of length `<= k` circuits:
 `T=BasisMatroid(groundset = M.groundset(), nonbases = M.dependent_r_sets(k), rank = k)`  

To get all the circuits of length at most k in that truncation T, you could use `T.nonspanning_circuits()`. If the rank is much higher than k, this will be faster than listing all the circuits of the original matroid by `M.circuits()` and scrapping the long ones. 

If that rank-k truncation T is k-chordal, then how far is T from being binary? Is there a binary matroid B, a matroid N and an element e so that N\e = T, N/e = B?


---

Comment by tscrim created at 2015-06-20 22:30:52

Replying to [comment:7 Rudi]:
> Replying to [comment:6 tscrim]:
> > It's better to not create a new ticket, but instead just push a new branch.
> > 
> I tried, but apparently I was using the wrong command. Just `git trac push 18484` from my new branch was rejected. I did not see how to scrap the existing branch.

I use git directly:

```
$ git push <remote> branch_name
```

where `<remote>` is likely either `origin` or `trac`.

> > Anyways, I'm going to recycle this ticket for k-chordality of a matroid (code to follow shortly, probably tomorrow).
> 
> Will your algorithm check that definition directly? If so, a matroid M of rank >k is k-chordal if and only if  it's rank-k truncation T is, since M and T will have the same collection of length `<= k` circuits:
>  `T=BasisMatroid(groundset = M.groundset(), nonbases = M.dependent_r_sets(k), rank = k)`  
> 
> To get all the circuits of length at most k in that truncation T, you could use `T.nonspanning_circuits()`. If the rank is much higher than k, this will be faster than listing all the circuits of the original matroid by `M.circuits()` and scrapping the long ones. 
> 
> If that rank-k truncation T is k-chordal, then how far is T from being binary? Is there a binary matroid B, a matroid N and an element e so that N\e = T, N/e = B?

To begin with, I got the sign backwards on the definition of chordality. Sorry about that, I was typing fast and didn't double-check. The terminology comes from graphic matroids, where a graph is called k-chordal if every cycle of length at least k has chord (a graph/matroid is called chordal if it is 4-chordal). My current code just checks the definition directly.

I'm not sure about the relation with binary matroids. Let me think on that.


---

Comment by Rudi created at 2015-06-20 23:13:18

Replying to [comment:8 tscrim]:

> I'm not sure about the relation with binary matroids. Let me think on that.

That relation is suggested by having the exact split in A+x and B+x; that is typical of binary matroids. A weaker property would be that each circuit (of length >=k) _spans_ an element x not in C: then there must be a proper subset A of C so that A+x is a circuit, and by circuit elimination a subset B of C so that B+x is a circuit and A union B = C. In a binary matroid such A and B are necessarily disjoint, in general matroids this is not necessary.

Binary matroids are chacterized by the fact that if C, C'are circuits, then the symmetric difference of C and C' is the disjoint union of circuits.


---

Comment by tscrim created at 2015-06-23 07:17:31

Hmm...I see why chordality could be a measurement of how close a matroid is to being binary, but it seems like it needs some extra information about the flats. From the symmetric difference property, would that imply that all binary matroids are (4-)chordal? I'm not well versed enough in matroid theory to answer your question about the existence of a binary matroid in comment:7. I'm also happy to talk more off-list about about my interests and learning more matroid theory.

Here's the code and ready for review (only 1 day later than I thought `^^;;` ).
----
New commits:


---

Comment by tscrim created at 2015-06-23 07:17:31

Changing status from new to needs_review.


---

Comment by Rudi created at 2015-06-23 07:48:39

Replying to [comment:10 tscrim]:
> Hmm...I see why chordality could be a measurement of how close a matroid is to being binary, but it seems like it needs some extra information about the flats. From the symmetric difference property, would that imply that all binary matroids are (4-)chordal?

No, just that if `M` is binary and `C` is a circuit of `M`, then `x\not\in C` is a chord of `C` if and only if `x` is spanned by `C`. So from that perspective, you could define weak chordality in terms of each `C` spanning an element outside `C`, and ordinary chordality as you did. The two notions coincide for binary matroids. 

I came across this paper by Joe Bonin in which he defines the same weaker notion of chordality, using slightly different words (def. 7): http://home.gwu.edu/~jbonin/wheelsweb.pdf


> I'm not well versed enough in matroid theory to answer your question about the existence of a binary matroid in comment:7. I'm also happy to talk more off-list about about my interests and learning more matroid theory.
> 
> Here's the code and ready for review (only 1 day later than I thought `^^;;` ).

I'll review it.


---

Comment by Rudi created at 2015-06-23 08:54:38

Changing status from needs_review to needs_info.


---

Comment by Rudi created at 2015-06-23 08:54:38

Hi Travis,

Code compiles, doctests run. No trailing whitespace anywhere :)

Your code looks mathematically correct to me, but I have not ran tests.

I asked for info because I think your _circuit_chordal works very hard to get an answer:

```
        for x in self.groundset():
            if x in C:
                continue
            for i in xrange(len(C)):
                for p in combinations(C, i): # p is a list
                    if (frozenset(p + (x,)) in circuits
                                and C.difference(p).union([x]) in circuits):
                        return True
```

The following will accomplish the same without testing all subsets of C:

```
        X = set(C)
        e  = X.pop() 
        for x in self._closure(X)-C: # cl(X)=cl(C), and to be a chord x must be spanned by C
            Ax = self._circuit(X.union([x])) 
            Bx = C.difference(Ax).union([x])
            if self._is_circuit(Bx):
                return True # if x is spanned by C, then A+x is the unique circuit in C-e+x; so x is a chord iff the complementary B is a circuit.
```

I expect that is_circuit will be faster than checking membership of circuits (since there are very many circuits in general) but that could perhaps be tested. Do you have a large chordal graph lying around?

Efficiency will not be a reason to not give that positive review. So let me know if you want to change your code. If not, I'll proceed to doing some tests.


---

Comment by Rudi created at 2015-06-23 09:13:21

Replying to [comment:12 Rudi]:

> {{{
>         X = set(C)
>         e  = X.pop() 
>         for x in self._closure(X)-C: # cl(X)=cl(C), and to be a chord x must be spanned by C
>             Ax = self._circuit(X.union([x])) 
>             Bx = C.difference(Ax).union([x])
>             if self._is_circuit(Bx):
>                 return True # if x is spanned by C, then A+x is the unique circuit in C-e+x; so x is a chord iff the complementary B is a circuit.
> }}}
> I expect that is_circuit will be faster than checking membership of circuits (since there are very many circuits in general) but that could perhaps be tested. 

Now that i think about it again, testing `not self._is_independent(Bx)` will do, since Bx cannot properly contain a circuit D. Otherwise, (D+Ax)-x would contain a circuit properly contained in C, contradiction. So you do not need the set `circuits` in there.


---

Comment by tscrim created at 2015-06-23 16:24:39

Here's how you can generate large chordal matroids:

```
sage: W = WeylGroup(['A',5])   # increase this integer
sage: w0 = W.long_element()
sage: mat = matrix([x.to_vector() for x in w0.inversions(inversion_type='roots')])
sage: M = Matroid(mat.transpose())
sage: M.chordality()
4
```

It's a theorem (I think due to Stanley, but I could be wrong) that all inversion arrangements of root systems of type A are chordal.

I have seen that Bonin paper, however his notion of k-chordal is opposite of what I'm interested in (and actually the original definition I gave) and does not (generally) recover the original notion of chordal. However if we add an upper bound parameter, we can support Bonin's definition as well. I will add this.

I'm not quite sure what you mean by this:

> Efficiency will not be a reason to not give that positive review.

I'd take the code which is more efficient. However I think checking for a frozenset being in the _frozenset_ `circuits` as containment is (amortized) O(1) and we have to generate all circuits anyways...well at least for `chordality`. I'm not sure that testing for closures would be faster as circuits are generally relatively small. Will you be running timings between the two codes or do you want me to?


---

Comment by Rudi created at 2015-06-23 18:31:47

Replying to [comment:14 tscrim]:

> I'm not quite sure what you mean by this:
> 
> > Efficiency will not be a reason to not give that positive review.
>
I just meant to say that I will not demand optimal efficiency as necessary for a positive review. Making code correct first and efficient later is a fine way to go. So I will accept code as long as it is correct. 
 
> I'd take the code which is more efficient. However I think checking for a frozenset being in the _frozenset_ `circuits` as containment is (amortized) O(1) and we have to generate all circuits anyways...well at least for `chordality`.
Generating all the circuits will be the most time-consuming part of chordality() and is_k_chordal(), I agree. From that perspective, tweaking _is_circuit_chordal() is not going to matter much for the efficiency. 

>I'm not sure that testing for closures would be faster as circuits are generally relatively small. Will you be running timings between the two codes or do you want me to?

You do get some improvement. Your code:

```
sage: from sage.matroids.advanced import *
sage: M = BinaryMatroid(graphs.CompleteGraph(8).incidence_matrix())
sage: %time M.is_k_chordal()
CPU times: user 806 ms, sys: 2.86 ms, total: 809 ms
Wall time: 809 ms
True
}}} 
With my tweaks:
{{{
sage: %time M.is_k_chordal()
CPU times: user 453 ms, sys: 3.82 ms, total: 457 ms
Wall time: 458 ms
True
sage: %time M.circuits()
CPU times: user 359 ms, sys: 1.3 ms, total: 360 ms
Wall time: 361 ms
Iterator over a system of subsets
}}}
So not counting the time spent on computing the circuits, the speedup is 4,5x on this example.

With the example you sent, computing circuits completely dominates the running time. The effect on the overall running time is essentially zero.

I leave it to you. I'm convinced by now of correctness, and you can set a positive review for this version if you want. If you want to make changes, I'll take another look later.


---

Comment by git created at 2015-06-23 19:52:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-23 19:55:07

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2015-06-23 19:56:41

That is quite a speedup (I guess iterating over the powersets is slow in comparison); so I've incorporated that into this ticket. I've also changed `is_k_chordal` to simply `is_chordal` with other options for specifying what type of chordality the user wants to check (including the `[k1, k2]` chordality of the Bonin paper).

Thanks for the testing and reviewing.


---

Comment by tscrim created at 2015-06-23 19:56:41

Changing status from needs_info to needs_review.


---

Comment by Rudi created at 2015-06-23 21:53:34

Looks good, just one thing.  In _is_circuit_chordal these two now unused variables are defined:

```
        cdef tuple p
        cdef int i
```

When they are gone, positive review.


---

Comment by git created at 2015-06-23 22:18:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-06-23 22:20:04

Thank you for doing the review!


---

Comment by tscrim created at 2015-06-23 22:20:04

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-06-24 20:11:17

Resolution: fixed
