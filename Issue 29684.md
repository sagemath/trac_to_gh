# Issue 29684: NumberField.reduced_basis() crashes when precision is too low

Issue created by migration from https://trac.sagemath.org/ticket/29921

Original creator: @fagu

Original creation time: 2020-06-20 21:05:34

CC:  slelievre

Keywords: reduced_basis

The function `reduced_basis` to compute LLL reduced bases of number fields sometimes throws an `IndexError`:


```
R.<t> = QQ[]
K.<z> = NumberField(-711989565*t^3 - 20673627*t^2 + 679597427*t - 691127351)
K.reduced_basis()
```


outputs


```
Traceback (most recent call last):
  File "blabla.sage.py", line 9, in <module>
    print(K.reduced_basis())
  File "/usr/lib/python3.8/site-packages/sage/rings/number_field/number_field.py", line 5951, in reduced_basis
    return [ sum([ ZZ(T[i][j]) * ZK[j] for j in range(d)])  for i in range(d)]
  File "/usr/lib/python3.8/site-packages/sage/rings/number_field/number_field.py", line 5951, in <listcomp>
    return [ sum([ ZZ(T[i][j]) * ZK[j] for j in range(d)])  for i in range(d)]
  File "/usr/lib/python3.8/site-packages/sage/rings/number_field/number_field.py", line 5951, in <listcomp>
    return [ sum([ ZZ(T[i][j]) * ZK[j] for j in range(d)])  for i in range(d)]
  File "cypari2/gen.pyx", line 1325, in cypari2.gen.Gen.__getitem__
IndexError: index out of range
```


This number field has signature (1,1), so pari's qflll function is used internally. I suppose what's happening here is that the precision is so low that the integral basis doesn't look linearly independent to qflll. It therefore returns just two "basis" vectors.

The code works when using `K.reduced_basis(prec=100)`. Perhaps the easiest thing would be to simply throw a more meaningful exception when this happens that recommends increasing the precision?

(I'm using Sage 9.1 and Pari 2.11.4 on Arch Linux.)


---

Comment by mkoeppe created at 2021-05-10 17:42:09

Moving to 9.4, as 9.3 has been released.
