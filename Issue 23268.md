# Issue 23268: Lattice precision for p-adics

Issue created by migration from https://trac.sagemath.org/ticket/23505

Original creator: caruso

Original creation time: 2017-07-21 05:39:49

CC:  roed tristanvaccon saraedum mmezzarobba swewers

Keywords: sd87

In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).

For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf

The aim of this ticket is to propose to implement these ideas in [SageMath](SageMath). 
More precisely, I propose to create a new parent `QpLP` (LP for "lattice precision") for which the precision is tracked using lattices. This leads to some difficulties:
- Since a lattice does not in general split properly, the precision datum is a global object which must be handled by the parent (and not by its elements). For this reason, the parent has to manage the precision itself for all its elements. In particular, he has to maintain an up-to-date list of all its elements (and should be then informed whenever one of its elements is collected by the garbage collector).
- If f is not surjective, df_x(H) is no longer a lattice. However, dealing with general Zp-submodules (and not only lattices) is more complicated for several reasons (the first one is that they are not exact objects whereas lattices are). For this reason, we introduce a `working_precision_cap` and feel free to add to our precision lattice any multiple of `p^working_precision_cap` if needed.

## About implementation

The pseudo-code below gives some hints about the implementation I have in mind. Comments are welcome! 


```

# The parent
############

class pAdicFieldLattice(pAdicRingBaseGeneric):
    # Internal variables:
    #  . self._working_precision_cap
    #    a cap for the working precision
    #    meaning that the precision lattice always contains p^(self._working_precision_cap)
    #  . self._elements
    #    list of weak references of elements in this parent
    #  . self._precision_lattice
    #    a matrix over ZZ representing the lattice of precision
    #    (its columns are indexed by self._elements)

    def __init__(self, p, working_precision_cap, print_mode):
        # Initialize variables here

    def _echelonize(self):
        # Echelonize the matrix giving the precision lattice

    def _add_element(self, elt, prec):
        # A new element in the parent has just been created
        # We should:
        #  . add a weak reference to it to the list self._elements
        #  . add a column to self._precision_lattice
        #    and update this matrix according to prec 
        #    (and possibly the working precision cap)
        # NOTE: prec be either an integer or a formal linear combinaison
        # of the precision on the other elements of this parent

    def _del_element(self, elt):
        # The element elt has just been garbage collected
        # We should:
        #  . remove it to the list self._elements
        #  . remove the corresponding column of self._precision_lattice

    def precision_absolute(self, elt):
        # Return the (optimal) absolute precision of the element elt
        # This precision can be read off on self._precision_lattice:
        # it is the smallest valuation of an entry of the column of
        # self._precision_lattice corresponding to the element elt

    def working_precision(self, elt):
        # Return the working precision of the element elt
        # This precision can be read off on the precision lattice:
        # it is the smallest integer n for which the precision
        # lattice contains p^n*[elt] where [elt] denotes the 
        # basis vector corresponding to elt

    def _element_constructor_(self, x, prec):
        # We ask for the creation of an element in this parent
        # We should:
        #  . create this element (called elt hereafter) from x
        #    Note: elt is an instance of the class pAdicLatticeElement below
        #  . call the method _new_element(elt, prec)
        #  . install a callback so that when elt will be collected
        #    by the garbage collector, the method _del_element will
        #    be called

QpLP = pAdicFieldLattice


# The elements
##############

class pAdicLatticeElement(Element):
    # Internal variable:
    #  . self._approximation
    #    an approximation of this p-adic number
    #    it is defined modulo p^(working_precision)

    def working_precision(self):
        return self.parent().working_precision(self)

    def approximation(self):
        # We should:
        #  . reduce self._approximation modulo p^(self.working_precision())
        #    (and update self._approximation accordingly)
        #  . return the result

    def precision_absolute(self):
        return self.parent().precision_absolute(self)

    def valuation(self, secure=False):
        # We should:
        #  . compute the valuation of self.approximation()
        #  . compare it to the self.precision_absolute()
        #  . if the former is less than the latter, we return the former
        #  . otherwise, if secure is False, we return the latter
        #               if secure is True, we raise an error

    def precision_relative(self, secure=False):
        return self.precision_absolute() - self.valuation(secure=secure)

    def _repr_(self):
        # Print like this:
        #   self.approximation() + O(p^self.precision_absolute())


    def _add_(self, other):
        # We should:
        #  . compute app = self.approximation() + other.approximation()
        #  . create a new element from app and the precision given by the differential:
        #    dapp = dself + dother

    def _mul_(self, other):
        # We should:
        #  . compute app = self.approximation() * other.approximation()
        #  . create a new element from app and the precision given by the differential:
        #    dapp = self*dother + other*dself

```



---

Comment by caruso created at 2017-07-22 04:09:02

New commits:


---

Comment by git created at 2017-07-22 04:09:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2017-08-01 23:54:33

I've worked more on my implementation and, at least, it seems now to be usable.

It still requires a lot of work (convert to Cython, write templates, write doctests, rewrite completely the class `pRational` which is a hack, etc). I however post it because I think that some people might have fun  playing with it and discovering what lattice precision can do. Enjoy :-)

`@`mmezzarobba: I add your name in Cc because I think that you could be interested. If you're not, feel free to remove it.


---

Comment by caruso created at 2017-08-01 23:54:33

Changing type from task to enhancement.


---

Comment by git created at 2017-08-01 23:54:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-02 09:04:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-02 09:14:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-21 04:49:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-22 18:36:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-30 03:09:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-12-19 19:36:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-12-20 17:24:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-12-23 06:42:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-06 10:28:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-07 17:13:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-17 14:46:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-18 16:44:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-21 08:49:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-05 06:43:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-05 06:44:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-06 16:45:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2018-02-06 16:54:46

I guess that this ticket is now more or less ready for a first review.


---

Comment by caruso created at 2018-02-06 16:54:46

Changing status from new to needs_review.


---

Comment by saraedum created at 2018-02-07 13:41:42

I would be happy to help with reviewing this. Since this is quite a lot of code, would you mind to push the code to github/gitlab where it is much easier to comment on lines of code? I can also push it to a repository there myself if you don't mind.


---

Comment by saraedum created at 2018-02-07 13:47:26

Do you document somewhere why this does not follow the usual linkage pattern used elsewhere in the p-adics code?


---

Comment by roed created at 2018-02-07 17:48:09

Replying to [comment:31 saraedum]:
> Do you document somewhere why this does not follow the usual linkage pattern used elsewhere in the p-adics code?

I think the main answer is that it just hasn't been switched to the linkage pattern, but it should be.  The pRational will take some work to make this happen.  I'll be busy in the next few weeks working on an ANTS paper, but we can talk about this in Rennes.  In the mean time, I think if you want to push the code to github/gitlab that should be fine.


---

Comment by saraedum created at 2018-02-09 19:34:35

I pushed Xavier's code to https://gitlab.com/saraedum/sage/merge_requests/1/diffs for easier review.
----
New commits:


---

Comment by chapoton created at 2018-02-12 12:55:15

see patchbot report for several issues (including important python3 compatibility)


---

Comment by roed created at 2018-02-20 05:40:29

I'm getting a maximum recursion depth exceeded:

```
sage: Q2 = QpLC(2,print_mode='digits')
sage: R.<x,y,z> = PolynomialRing(Q2, order = 'invlex')
sage: F = [ Q2(2,10)*x + Q2(1,10)*z,
....:      Q2(1,10)*x^2 + Q2(1,10)*y^2 - Q2(2,10)*z^2,
....:      Q2(4,10)*y^2 + Q2(1,10)*y*z + Q2(8,10)*z^2 ]
sage: from sage.rings.polynomial.toy_buchberger import buchberger_improved
sage: g = buchberger_improved(ideal(F));
sage: g.sort()
sage: L.number_of_diffused_digits([g[1].coefficient(x^2),
....:                              g[2].coefficient(x^2),g[3].coefficient(x)])
/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in number_of_diffused_digits(self, elements)
    563             17
    564         """
--> 565         M = self.precision_lattice(elements)
    566         n = M.nrows()
    567         if M.ncols() > n:
/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in precision_lattice(self, elements)
   1551             elements = self._elements
   1552         else:
-> 1553             elements = list_of_padics(elements)
   1554         n = len(self._elements)
   1555         rows = [ ]; val = 0
/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in list_of_padics(elements)
    234     ans = [ ]
    235     for x in elements:
--> 236         ans += list_of_padics(x)
    237     return ans
    238 
```



---

Comment by caruso created at 2018-02-21 19:57:37

Replying to [comment:36 roed]:
> I'm getting a maximum recursion depth exceeded:

The reason is that (1) `coefficient` returns a multivariate polynomial and (2) if P is a multivariate polynomial, `list(P)` contains some multivariate polynomials in it as well.

The last commit fixes the bug. But I'm not sure that it's the correct way to do this.


```
sage: Q2 = QpLC(2,print_mode='digits')
sage: L = Q2.precision()
sage: R.<x,y,z> = PolynomialRing(Q2, order = 'invlex')
sage: F = [ Q2(2,10)*x + Q2(1,10)*z,
....:       Q2(1,10)*x^2 + Q2(1,10)*y^2 - Q2(2,10)*z^2,
....:       Q2(4,10)*y^2 + Q2(1,10)*y*z + Q2(8,10)*z^2 ]
sage: from sage.rings.polynomial.toy_buchberger import buchberger_improved
sage: g = buchberger_improved(ideal(F));
sage: g.sort()
sage: L.number_of_diffused_digits([g[1].coefficient(x^2),
                                   g[2].coefficient(x^2),
                                   g[3].coefficient(x)])
0
```



---

Comment by chapoton created at 2018-02-23 20:22:06

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2018-02-23 20:22:06

You need to fix all the patchbot's warnings, including the incompatibilities with python3.


---

Comment by git created at 2018-02-26 03:32:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2018-02-26 07:59:41

`@`caruso: I merged your commits into the repository on gitlab. (I had sent you the instructions on how to push to gitlab several times on zulip but apparently zulip has silently not been working for quite a while…so, to push your changes there in the future: `git fetch git`@`gitlab.com:saraedum/sage.git t/23505/lattice_precision && git merge FETCH_HEAD && git push git`@`gitlab.com:saraedum/sage.git HEAD:t/23505/lattice_precision`. There are also more convenient commands for this, I can show you later.)


---

Comment by git created at 2018-02-27 00:15:43

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by chapoton created at 2018-02-27 09:27:16

IMHO, not a good idea at all to merge the "binder" branch with this ticket. The patchbots will not longer look at it, because it is now unsafe.


---

Comment by caruso created at 2018-02-27 09:33:15

I agree, I merged them accidentally.
I will remove them later. For now, the ticket is not quite ready for review; I just wanted to check whether the patchbot is happy with my changes.


---

Comment by caruso created at 2018-02-27 10:13:59

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2018-02-27 10:17:33

As I said, as long as the branch is messed up, patchbots will refuse to run..


---

Comment by saraedum created at 2018-02-27 10:31:27

`@`chapoton: Thanks for clarifying how the patchbots work here. We'll take the binder out at the end and squash the other commits. We use the CI integration because we are developing this on [GitLab](GitLab) and also because we wanted to see a sandbox environment to play with this.

`@`caruso: I'll run doctests on [GitLab](GitLab), they should be available in a couple of hours.


---

Comment by caruso created at 2018-02-27 10:46:51

Ok. Thanks to both of you!


---

Comment by saraedum created at 2018-03-06 00:18:53

New commits:


---

Comment by saraedum created at 2018-03-06 00:40:48

This has a positive review, once https://gitlab.com/saraedum/sage/-/jobs/55854321 has completed without errors.


---

Comment by roed created at 2018-03-06 00:44:28

Replying to [comment:56 saraedum]:
> This has a positive review, once https://gitlab.com/saraedum/sage/-/jobs/55854321 has completed without errors.

Job's log exceeded limit of 4194304 bytes.


---

Comment by caruso created at 2018-03-06 07:13:59


```
sage -t --long src/sage/interacts/test_jupyter.rst
**********************************************************************
File "src/sage/interacts/test_jupyter.rst", line 288, in sage.interacts.test_jupyter
Failed example:
    test(interacts.statistics.coin)
Expected:
    Interactive function <function coin at ...> with 2 widgets
      n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
      interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
    doctest:...: UserWarning: Attempting to set identical bottom==top results
    in singular transformations; automatically expanding.
    bottom=0.0, top=0.0
Got:
    doctest:... UserWarning: Attempting to set identical bottom==top results
    in singular transformations; automatically expanding.
    bottom=0.0, top=0.0
    Interactive function <function coin at 0x7fb48b00d7d0> with 2 widgets
      n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
      interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
```


Should we fix this?


---

Comment by chapoton created at 2018-03-06 07:22:36

patchbot here is still not 100% happy


---

Comment by caruso created at 2018-03-06 07:29:55

I fixed some failures but I think that this ticket is not responsible for the doctest failure in `interacts/test_jupyter.rst`. What should I do with it?
----
New commits:


---

Comment by saraedum created at 2018-03-06 08:53:26

I am not sure what this is about. I don't think that's a problem coming from the changes here, so we should not fix it here.

Replying to [comment:58 caruso]:
> {{{
> sage -t --long src/sage/interacts/test_jupyter.rst
> **********************************************************************
> File "src/sage/interacts/test_jupyter.rst", line 288, in sage.interacts.test_jupyter
> Failed example:
>     test(interacts.statistics.coin)
> Expected:
>     Interactive function <function coin at ...> with 2 widgets
>       n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
>       interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
>     doctest:...: UserWarning: Attempting to set identical bottom==top results
>     in singular transformations; automatically expanding.
>     bottom=0.0, top=0.0
> Got:
>     doctest:... UserWarning: Attempting to set identical bottom==top results
>     in singular transformations; automatically expanding.
>     bottom=0.0, top=0.0
>     Interactive function <function coin at 0x7fb48b00d7d0> with 2 widgets
>       n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
>       interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
> }}}
> 
> Should we fix this?


---

Comment by caruso created at 2018-03-06 10:43:35

So now, only the failure in `interacts/test_jupyter.rst` remains...


---

Comment by saraedum created at 2018-03-06 14:08:31

Changing status from needs_review to positive_review.


---

Comment by saraedum created at 2018-03-06 14:08:31

The PDF reference manual builds. The German "A Tour of Sage" fails to build but I can't imagine that this ticket is responsible for this:

```
[a_tour_of] loading translations [de]... done
[a_tour_of] Compiling the master document
[a_tour_of] building [mo]: targets for 0 po files that are out of date
[a_tour_of] building [latex]: all documents
[a_tour_of] Merging environment/index files...
[a_tour_of] ... done (0 todos, 1 index, 0 citations, 0 modules)
[a_tour_of] Saved pickle file: citations.pickle
[a_tour_of] processing a_tour_of_sage.tex...index
[a_tour_of] resolving references...
[a_tour_of] writing... done
[a_tour_of] copying images... [ 50%] sin_plot.png
[a_tour_of] copying images... [100%] eigen_plot.png
[a_tour_of] copying TeX support files...
[a_tour_of] done
[a_tour_of] build succeeded.
latexmk -pdf -dvi- -ps-  'a_tour_of_sage.tex'
Latexmk: applying rule 'pdflatex'...
This is pdfTeX, Version 3.14159265-2.6-1.40.16 (TeX Live 2015/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(./a_tour_of_sage.tex
LaTeX2e <2016/02/01>
Babel <3.9q> and hyphenation patterns for 3 language(s) loaded.
(./sphinxmanual.cls
Document Class: sphinxmanual 2017/03/26 v1.6 Document class (Sphinx manual)
(/usr/share/texlive/texmf-dist/tex/latex/base/report.cls
Document Class: report 2014/09/29 v1.4h Standard LaTeX document class
(/usr/share/texlive/texmf-dist/tex/latex/base/size10.clo)))
(/usr/share/texlive/texmf-dist/tex/latex/base/inputenc.sty
(/usr/share/texlive/texmf-dist/tex/latex/base/utf8.def
(/usr/share/texlive/texmf-dist/tex/latex/base/t1enc.dfu)
(/usr/share/texlive/texmf-dist/tex/latex/base/ot1enc.dfu)
(/usr/share/texlive/texmf-dist/tex/latex/base/omsenc.dfu)))
(/usr/share/texlive/texmf-dist/tex/latex/cmap/cmap.sty)
(/usr/share/texlive/texmf-dist/tex/latex/base/fontenc.sty
(/usr/share/texlive/texmf-dist/tex/latex/base/t1enc.def)<<t1.cmap>>)
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsmath.sty
For additional information on amsmath, use the `?' option.
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amstext.sty
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsgen.sty))
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsbsy.sty)
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsopn.sty))
(/usr/share/texlive/texmf-dist/tex/latex/amsfonts/amssymb.sty
(/usr/share/texlive/texmf-dist/tex/latex/amsfonts/amsfonts.sty))
(/usr/share/texlive/texmf-dist/tex/generic/babel/babel.sty

! Package babel Error: You haven't specified a language option.

See the babel package documentation for explanation.
Type  H <return>  for immediate help.
 ...

l.343 ...ry to proceed from here, type x to quit.}

?
! Emergency stop.
 ...

l.343 ...ry to proceed from here, type x to quit.}

!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on a_tour_of_sage.log.
Latexmk: Errors, so I did not complete making targets
Makefile:33: recipe for target 'a_tour_of_sage.pdf' failed
```



---

Comment by vbraun created at 2018-03-08 00:02:48

Resolution: fixed


---

Comment by chapoton created at 2018-04-30 09:06:53

There are issues with python3 division in lattice_precision:

```
source ./local/bin/sage-env
python -Qnew ./local/bin/sage-runtests src/sage/rings/padics
```

reports many failing doctests.
This can be seen also when adding

```
from __future__ import division
```

in the file.


---

Comment by chapoton created at 2018-05-02 09:33:16

and you also introduced some "has_key", so please review #25280


---

Comment by caruso created at 2018-05-02 21:27:43

Replying to [comment:66 chapoton]:
> There are issues with python3 division in lattice_precision:
> {{{
> source ./local/bin/sage-env
> python -Qnew ./local/bin/sage-runtests src/sage/rings/padics
> }}}
> reports many failing doctests.
> This can be seen also when adding
> {{{
> from __future__ import division
> }}}
> in the file.

Adding the line:

`__truediv__ = __div__`

in the defintion of the class `pRational` resolves this issue. Is it the right way to fix this or should I do something else?


---

Comment by chapoton created at 2018-05-12 07:14:45

code from this ticket seems to trigger `TimeOut` errors on several machines running sage 8.3.b0, please investigate !

https://patchbot.sagemath.org/log/0/Ubuntu/18.04/x86_64/4.15.0-20-generic/petitbonum/2018-05-11%2012:03:31?short


---

Comment by saraedum created at 2018-05-23 11:49:19

Thanks for pointing this out. I created a followup #25431.


---

Comment by chapoton created at 2018-10-27 16:34:10

The file `padic_lattice_element.py` is now one of the last 3 files (see #26212) having more than 100 failing doctests in python3:

```
sage -t --long src/sage/rings/padics/padic_lattice_element.py  # 167 doctests failed
```

It would be appreciated if the authors of this code could handle the task of making all this compatible with python3.


---

Comment by roed created at 2018-10-28 02:07:21

I'll take a look.  I've opened #26576.


---

Comment by caruso created at 2018-10-28 03:14:53

I'd be happy to contribute as well but I don't know so much about Python3 (which explains why this ticket has so many failures...)

In particular, what should I do if I want to run doctests with the python3 interpretor. Do I need to install a new copy of sage compiled with python3 or is there something more clever?


---

Comment by dimpase created at 2020-01-14 14:33:05

There are these doctests errors:

```
File "src/sage/rings/padics/padic_lattice_element.py", line 31, in sage.rings.padics.padic_lattice_element
Failed example:
    R = QpLF(2) # py3
Expected:
    doctest:...: FutureWarning: This class/method/function is marked as experimental. It, its functionality or its interface might change without a formal deprecation.
    See http://trac.sagemath.org/23505 for details.
Got:
    <BLANKLINE>
```


So it there anything "experimental" left almost 2 years since this ticket has been closed?
Can these tags or whatever be removed?
