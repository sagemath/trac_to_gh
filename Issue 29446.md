# Issue 29446: "look up" a face in the face lattice of a polyhedron

archive/issues_029446.json:
```json
{
    "body": "CC:  @jplab @laisrast @videlec @yuan-zhou\n\nKeywords: polyhedron, faces, meet, join\n\nWe implement two methods that look up a face in the face lattice of a polyhedron:\n\n- `meet_of_Vrep` -- the smallest face containing specified Vrepresentatives\n- `join_of_facets` -- the largest face contained specified facets\n\nThis allows an easy answer for \u200bhttps://ask.sagemath.org/question/34485/what-is-the-most-efficient-way-to-look-up-a-face-in-the-face-lattice-of-a-polyhedron/#50965\n\nIssue created by migration from https://trac.sagemath.org/ticket/29683\n\n",
    "created_at": "2020-05-13T12:28:52Z",
    "labels": [
        "geometry",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.4",
    "title": "\"look up\" a face in the face lattice of a polyhedron",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29446",
    "user": "@kliem"
}
```
CC:  @jplab @laisrast @videlec @yuan-zhou

Keywords: polyhedron, faces, meet, join

We implement two methods that look up a face in the face lattice of a polyhedron:

- `meet_of_Vrep` -- the smallest face containing specified Vrepresentatives
- `join_of_facets` -- the largest face contained specified facets

This allows an easy answer for â€‹https://ask.sagemath.org/question/34485/what-is-the-most-efficient-way-to-look-up-a-face-in-the-face-lattice-of-a-polyhedron/#50965

Issue created by migration from https://trac.sagemath.org/ticket/29683





---

archive/issue_comments_417853.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-05-13T12:29:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417853",
    "user": "@kliem"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_417854.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2020-05-13T12:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417854",
    "user": "@kliem"
}
```

Last 10 new commits:



---

archive/issue_comments_417855.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-06-17T09:52:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417855",
    "user": "@kliem"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_417856.json:
```json
{
    "body": "There are failing tests. I would wait until the dependices are taken care of to make things work again.",
    "created_at": "2020-06-17T09:52:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417856",
    "user": "@kliem"
}
```

There are failing tests. I would wait until the dependices are taken care of to make things work again.



---

archive/issue_comments_417857.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-09-07T13:36:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417857",
    "user": "@kliem"
}
```

New commits:



---

archive/issue_comments_417858.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-09-07T13:36:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417858",
    "user": "@kliem"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_417859.json:
```json
{
    "body": "I want to redesign some of the setup before making everything more complicated.\n\nMore precisely, creating strucutures `face_struct` and `faces_list_struct` that take care of the details. Then this overly long argument list of `get_next_level` will just reduce to three arguments or so. This would also make future changes easier including the transition to `bitsets.pxi`.",
    "created_at": "2020-09-07T17:30:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417859",
    "user": "@kliem"
}
```

I want to redesign some of the setup before making everything more complicated.

More precisely, creating strucutures `face_struct` and `faces_list_struct` that take care of the details. Then this overly long argument list of `get_next_level` will just reduce to three arguments or so. This would also make future changes easier including the transition to `bitsets.pxi`.



---

archive/issue_comments_417860.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-09-07T17:30:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417860",
    "user": "@kliem"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_417861.json:
```json
{
    "body": "New commits:",
    "created_at": "2021-01-06T13:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417861",
    "user": "@kliem"
}
```

New commits:



---

archive/issue_comments_417862.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-01-06T13:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417862",
    "user": "@kliem"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_417863.json:
```json
{
    "body": "Some quick comments:\n- \"The offset is taken correctly\" - what's that?\n- Change \"reseted\" to \"reset\"\n- \"In case of an unbounded polyhedron\" -> \"In the case ...\"",
    "created_at": "2021-01-16T18:57:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417863",
    "user": "@mkoeppe"
}
```

Some quick comments:
- "The offset is taken correctly" - what's that?
- Change "reseted" to "reset"
- "In case of an unbounded polyhedron" -> "In the case ..."



---

archive/issue_comments_417864.json:
```json
{
    "body": "I discovered a bug by accident:\n\n\n```\nsage: P = polytopes.permutahedron(3, backend='cdd')                                                                                                                                 \nsage: [x.ambient_Hrepresentation() for x in P.facets()]                                                                                                                             \n[(An inequality (1, 1, 0) x - 3 >= 0, An inequality (1, 0, 1) x - 3 >= 0),\n (An inequality (1, 1, 0) x - 3 >= 0, An inequality (1, 0, 0) x - 1 >= 0),\n (An inequality (1, 1, 0) x - 3 >= 0, An inequality (0, 1, 1) x - 3 >= 0),\n (An inequality (1, 1, 0) x - 3 >= 0, An inequality (0, 1, 0) x - 1 >= 0),\n (An inequality (1, 1, 0) x - 3 >= 0, An inequality (0, 0, 1) x - 1 >= 0),\n (An inequality (1, 1, 0) x - 3 >= 0, An equation (1, 1, 1) x - 6 == 0)]\n```\n\n\nThe problem is that the backend `cdd` doesn't put equations in a stable place, which my code assumed. It depends whether you initialize from Vrep or from Hrep I guess.",
    "created_at": "2021-01-16T20:30:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417864",
    "user": "@kliem"
}
```

I discovered a bug by accident:


```
sage: P = polytopes.permutahedron(3, backend='cdd')                                                                                                                                 
sage: [x.ambient_Hrepresentation() for x in P.facets()]                                                                                                                             
[(An inequality (1, 1, 0) x - 3 >= 0, An inequality (1, 0, 1) x - 3 >= 0),
 (An inequality (1, 1, 0) x - 3 >= 0, An inequality (1, 0, 0) x - 1 >= 0),
 (An inequality (1, 1, 0) x - 3 >= 0, An inequality (0, 1, 1) x - 3 >= 0),
 (An inequality (1, 1, 0) x - 3 >= 0, An inequality (0, 1, 0) x - 1 >= 0),
 (An inequality (1, 1, 0) x - 3 >= 0, An inequality (0, 0, 1) x - 1 >= 0),
 (An inequality (1, 1, 0) x - 3 >= 0, An equation (1, 1, 1) x - 6 == 0)]
```


The problem is that the backend `cdd` doesn't put equations in a stable place, which my code assumed. It depends whether you initialize from Vrep or from Hrep I guess.



---

archive/issue_comments_417865.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-16T20:33:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417865",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417866.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-15T22:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417866",
    "user": "@mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_417867.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-13T18:40:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417867",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417868.json:
```json
{
    "body": "rebased\n----\nNew commits:",
    "created_at": "2021-05-13T18:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417868",
    "user": "@kliem"
}
```

rebased
----
New commits:



---

archive/issue_comments_417869.json:
```json
{
    "body": "From #30469#comment:25\n\n> - `:meth:~sage.geometry.polyhedron.base.Polyhedron_base.meet_of_facets` | largest face contained specified facets` --> contained in the specified facets\n> - `Polyhedron_base.join_of_Vrep(self, *Vrepresentatives): ... in case of...` --> \"in the case of\" * 2\n> - `FaceIterator_base(SageObject).join_of_Vrep(self, *indices): .. NOTE:: ... may not te well defined.` --> \"be\"\n> - Why is it `meet_of_facets`, but not `meet_of_Hrep`? If rays/lines are allowed on the primal side, why doesn't it make sense to consider equations on the dual side?",
    "created_at": "2021-05-13T18:59:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417869",
    "user": "@kliem"
}
```

From #30469#comment:25

> - `:meth:~sage.geometry.polyhedron.base.Polyhedron_base.meet_of_facets` | largest face contained specified facets` --> contained in the specified facets
> - `Polyhedron_base.join_of_Vrep(self, *Vrepresentatives): ... in case of...` --> "in the case of" * 2
> - `FaceIterator_base(SageObject).join_of_Vrep(self, *indices): .. NOTE:: ... may not te well defined.` --> "be"
> - Why is it `meet_of_facets`, but not `meet_of_Hrep`? If rays/lines are allowed on the primal side, why doesn't it make sense to consider equations on the dual side?



---

archive/issue_comments_417870.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-13T19:06:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417870",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417871.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-13T19:08:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417871",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417872.json:
```json
{
    "body": "Replying to [comment:15 gh-kliem]:\n> From #30469#comment:25\n> \n> > - `:meth:~sage.geometry.polyhedron.base.Polyhedron_base.meet_of_facets` | largest face contained specified facets` --> contained in the specified facets\n> > - `Polyhedron_base.join_of_Vrep(self, *Vrepresentatives): ... in case of...` --> \"in the case of\" * 2\n> > - `FaceIterator_base(SageObject).join_of_Vrep(self, *indices): .. NOTE:: ... may not te well defined.` --> \"be\"\n\nAll fixed.\n\n\n> > - Why is it `meet_of_facets`, but not `meet_of_Hrep`? If rays/lines are allowed on the primal side, why doesn't it make sense to consider equations on the dual side? \n\nLines are basically ignored as are equations.\n\nHowever, rays do make a difference. This is how I came up with it 12 months ago. `join_of_Vrep` is just better than `join_of_vertices_and_rays`, isn't it?\n\nIn the end, I don't know what is best.",
    "created_at": "2021-05-13T19:11:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417872",
    "user": "@kliem"
}
```

Replying to [comment:15 gh-kliem]:
> From #30469#comment:25
> 
> > - `:meth:~sage.geometry.polyhedron.base.Polyhedron_base.meet_of_facets` | largest face contained specified facets` --> contained in the specified facets
> > - `Polyhedron_base.join_of_Vrep(self, *Vrepresentatives): ... in case of...` --> "in the case of" * 2
> > - `FaceIterator_base(SageObject).join_of_Vrep(self, *indices): .. NOTE:: ... may not te well defined.` --> "be"

All fixed.


> > - Why is it `meet_of_facets`, but not `meet_of_Hrep`? If rays/lines are allowed on the primal side, why doesn't it make sense to consider equations on the dual side? 

Lines are basically ignored as are equations.

However, rays do make a difference. This is how I came up with it 12 months ago. `join_of_Vrep` is just better than `join_of_vertices_and_rays`, isn't it?

In the end, I don't know what is best.



---

archive/issue_comments_417873.json:
```json
{
    "body": "I'm very new to the topic. I just started learning about combinatorial polyhedra today, and haven't read all the code changes on this ticket yet. But I'm wondering if it makes more sense to start by faces of the (possibly unbounded) polyhedron as input. Let\n\n```\nP = Polyhedron(vertices=[[1,0], [0,1]], rays=[[1,1]])\nsage: V = P.Vrepresentation()\nsage: V                                                                        \n(A vertex at (0, 1), A vertex at (1, 0), A ray in the direction (1, 1))\n```\n\nSince \"A ray in the direction (1, 1)\" is not a face of `P`, `V[2]` shouldn't be taken as input for the look-up. Instead, the input could be something like `[(1, 2), 0]`, where each element (= a single index or a tuple of indices) in the list must describe an actual face of the polyhedron.\n\nFor example, we can define the functions `join_of_faces` and `meet_of_faces` with input\n- `faces`: list (iterator) of faces (not necessarily Vrep or facets), each face is described by a tuple of indices. Here index can be more flexible, such as `P.Vrepresentation(4)`, etc.\n- an argument telling whether the indices are primal or dual ones.\n\nJust my two cents.",
    "created_at": "2021-05-13T20:38:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417873",
    "user": "@yuan-zhou"
}
```

I'm very new to the topic. I just started learning about combinatorial polyhedra today, and haven't read all the code changes on this ticket yet. But I'm wondering if it makes more sense to start by faces of the (possibly unbounded) polyhedron as input. Let

```
P = Polyhedron(vertices=[[1,0], [0,1]], rays=[[1,1]])
sage: V = P.Vrepresentation()
sage: V                                                                        
(A vertex at (0, 1), A vertex at (1, 0), A ray in the direction (1, 1))
```

Since "A ray in the direction (1, 1)" is not a face of `P`, `V[2]` shouldn't be taken as input for the look-up. Instead, the input could be something like `[(1, 2), 0]`, where each element (= a single index or a tuple of indices) in the list must describe an actual face of the polyhedron.

For example, we can define the functions `join_of_faces` and `meet_of_faces` with input
- `faces`: list (iterator) of faces (not necessarily Vrep or facets), each face is described by a tuple of indices. Here index can be more flexible, such as `P.Vrepresentation(4)`, etc.
- an argument telling whether the indices are primal or dual ones.

Just my two cents.



---

archive/issue_comments_417874.json:
```json
{
    "body": "As for the combinatorial polytope: It's just a coatom(ist)ic and atom(ist)ic lattice with some extra properties. Hence the name `join_of` and `meet_of`. As the lattice is coatom(ist)ic and atom(ist)ic the concept of `meet_of_faces` and `join_of_faces` is redundant. To compute the meet of faces it suffices to compute the meet of the coatoms/facets. As it is only one depth-first lookup the computation time of doing this is usually neglectable.\n\nThe unbounded polyhedron (no lines/linear subspaces assumed) is a bit different. It is basically a polytope with marked far face. The face lattice is given by `[0, 1] \\ [0, F]`. Where `[0,1]` denotes the lattice of the bounded polytope and `F` is the far face.\n\nThe rays are vertices of that bounded polytope and thus it makes sense to include them in the notion of a join. Computing the join is always well defined with the exception for the case where you only include elements of the far face, e.g. rays.\n\nHowever, I don't have a strong opinion on a name scheme. In the combinatorial polyhedron module it should be `join` and `meet` I think, but in `polyhedron/base.py` it might as well be `look_up_face` or `find_face`.",
    "created_at": "2021-05-14T19:40:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417874",
    "user": "@kliem"
}
```

As for the combinatorial polytope: It's just a coatom(ist)ic and atom(ist)ic lattice with some extra properties. Hence the name `join_of` and `meet_of`. As the lattice is coatom(ist)ic and atom(ist)ic the concept of `meet_of_faces` and `join_of_faces` is redundant. To compute the meet of faces it suffices to compute the meet of the coatoms/facets. As it is only one depth-first lookup the computation time of doing this is usually neglectable.

The unbounded polyhedron (no lines/linear subspaces assumed) is a bit different. It is basically a polytope with marked far face. The face lattice is given by `[0, 1] \ [0, F]`. Where `[0,1]` denotes the lattice of the bounded polytope and `F` is the far face.

The rays are vertices of that bounded polytope and thus it makes sense to include them in the notion of a join. Computing the join is always well defined with the exception for the case where you only include elements of the far face, e.g. rays.

However, I don't have a strong opinion on a name scheme. In the combinatorial polyhedron module it should be `join` and `meet` I think, but in `polyhedron/base.py` it might as well be `look_up_face` or `find_face`.



---

archive/issue_comments_417875.json:
```json
{
    "body": "Given two faces (as polyhedra), if I'm interested in finding the largest face (as polyhedron) that is contained in both faces, is it better to call intersection or to apply `join_of_facets`?",
    "created_at": "2021-05-17T06:03:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417875",
    "user": "@yuan-zhou"
}
```

Given two faces (as polyhedra), if I'm interested in finding the largest face (as polyhedron) that is contained in both faces, is it better to call intersection or to apply `join_of_facets`?



---

archive/issue_comments_417876.json:
```json
{
    "body": "If you want the largest face contained in both of them, you need to do the intersection, which translates to the meet operation in the face lattice.\n\nI would propose not defining the meet of the faces but instead the meet of the coatoms/facets.\nIf you give me the faces as polyhedron, I need to first determine how your facet-description of the facets corresponds to the facets of the original polyhedron.\n\nMeet should be much faster, because all the information is already encoded in the combinatorial polyhedron. It is just a simple depth first search in a lattice, doing a couple of intersections and subset checks of bitsets.\n\nBut it also depends on the kind of output you want.",
    "created_at": "2021-05-17T06:50:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417876",
    "user": "@kliem"
}
```

If you want the largest face contained in both of them, you need to do the intersection, which translates to the meet operation in the face lattice.

I would propose not defining the meet of the faces but instead the meet of the coatoms/facets.
If you give me the faces as polyhedron, I need to first determine how your facet-description of the facets corresponds to the facets of the original polyhedron.

Meet should be much faster, because all the information is already encoded in the combinatorial polyhedron. It is just a simple depth first search in a lattice, doing a couple of intersections and subset checks of bitsets.

But it also depends on the kind of output you want.



---

archive/issue_comments_417877.json:
```json
{
    "body": "Actually what you describe is really easy to do, but neither implemented nor intended for in this ticket:\n\nIn your case you know (at least in the bounded case) that the intersection of both polytopes is exactly the convex hull of the intersection of the vertices. That is of course by far not true in the general case.\n\nTo determine the equations is really easy. It's just computing the kernel of a matrix.\nThe possibly redundant inequalities are given by the union of the inequalities.\nSo the only thing left to do (at least with backend `field`) is to figure out, which of the inequalities is redundant.\n\nBut this is exactly the functionality that `face_as_combinatorial_polyhedron` tries to implement as well.",
    "created_at": "2021-05-17T07:01:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417877",
    "user": "@kliem"
}
```

Actually what you describe is really easy to do, but neither implemented nor intended for in this ticket:

In your case you know (at least in the bounded case) that the intersection of both polytopes is exactly the convex hull of the intersection of the vertices. That is of course by far not true in the general case.

To determine the equations is really easy. It's just computing the kernel of a matrix.
The possibly redundant inequalities are given by the union of the inequalities.
So the only thing left to do (at least with backend `field`) is to figure out, which of the inequalities is redundant.

But this is exactly the functionality that `face_as_combinatorial_polyhedron` tries to implement as well.



---

archive/issue_comments_417878.json:
```json
{
    "body": "Thanks!\n\nAnother possibly irrelevant question: for an empty face, does its `ambient_H_indices` or `ambient_Hrepresentation` mean anything?\n\n\n```\nP =  Polyhedron(rays=[(1,0),(0,1)])\nF = P.faces(-1)[0]\nF.ambient_H_indices()  #  returns  (0, 1)\nF.ambient_Hrepresentation() #  (An inequality (1, 0) x + 0 >= 0, An inequality (0, 1) x + 0 >= 0)\nP.faces(0)[0].ambient_Hrepresentation() # same output as above\n```\n",
    "created_at": "2021-05-17T07:22:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417878",
    "user": "@yuan-zhou"
}
```

Thanks!

Another possibly irrelevant question: for an empty face, does its `ambient_H_indices` or `ambient_Hrepresentation` mean anything?


```
P =  Polyhedron(rays=[(1,0),(0,1)])
F = P.faces(-1)[0]
F.ambient_H_indices()  #  returns  (0, 1)
F.ambient_Hrepresentation() #  (An inequality (1, 0) x + 0 >= 0, An inequality (0, 1) x + 0 >= 0)
P.faces(0)[0].ambient_Hrepresentation() # same output as above
```




---

archive/issue_comments_417879.json:
```json
{
    "body": "Stupid corner cases.\n\nYes, usually it `ambient_H_indices` or `ambient_Hrepresentation` does mean something for the empty face as well. But not in this case. There is at least two different definitions for faces:\n\n- An intersection of hyperplanes corresponding to non-redundant inequalities.\n- An intersection with a single hyperplane which corresponds to some inequality that the polyhedron satisfies (and maybe add the polyhedron as a face itself).\n\nUsually they agree. But not in some case. In your example, there are two inequalities that are not redundant. They define those two unbounded 1-dimension faces, the 2-dimensional face is the empty intersection and the vertex. The empty face cannot be represented by those inequalities.\n\nDifferent story for the second definition.\n\nIf you have at least two vertices, then things are fine. Sometimes cones are so much nicer...\n\nThat is why the `CombinatorialPolyhedron` itself just ignores the empty face and the full-dimensional face for the face iterator.",
    "created_at": "2021-05-17T08:19:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417879",
    "user": "@kliem"
}
```

Stupid corner cases.

Yes, usually it `ambient_H_indices` or `ambient_Hrepresentation` does mean something for the empty face as well. But not in this case. There is at least two different definitions for faces:

- An intersection of hyperplanes corresponding to non-redundant inequalities.
- An intersection with a single hyperplane which corresponds to some inequality that the polyhedron satisfies (and maybe add the polyhedron as a face itself).

Usually they agree. But not in some case. In your example, there are two inequalities that are not redundant. They define those two unbounded 1-dimension faces, the 2-dimensional face is the empty intersection and the vertex. The empty face cannot be represented by those inequalities.

Different story for the second definition.

If you have at least two vertices, then things are fine. Sometimes cones are so much nicer...

That is why the `CombinatorialPolyhedron` itself just ignores the empty face and the full-dimensional face for the face iterator.



---

archive/issue_comments_417880.json:
```json
{
    "body": "I'm reading `base.py` and find the following corner case:\n\n```\nsage: P = Polyhedron(vertices=[[1,0,0], [0,1,0]], rays=[[1,1,0]])               \nsage: Q = Polyhedron(vertices=[[0,0],[0,1],[1,1],[1,0]])\nsage: a, b, c = Q.Hrepresentation()[:3]\nsage: P.meet_of_facets(b, c)\nsage: P.meet_of_facets(a, b)\n```\n\nThat is, `join_of_Vrep` and `meet_of_facets` probably need to check if `v` and `facet` given as `PolyhedronFace` or `V/H-representation` actually correspond to `self`.\n\nSome typos:\n- Line 6960: empty line but `::`\n- Line 7025: maybe you meant that the index cannot correspond to an equation in the Hrepresentation.\n- Line 7030: `ValueError: 0 is not a facet` --> ` An equation (1, 1, 1, 1, 1) x - 15 == 0 is not a facet`?",
    "created_at": "2021-05-17T09:10:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417880",
    "user": "@yuan-zhou"
}
```

I'm reading `base.py` and find the following corner case:

```
sage: P = Polyhedron(vertices=[[1,0,0], [0,1,0]], rays=[[1,1,0]])               
sage: Q = Polyhedron(vertices=[[0,0],[0,1],[1,1],[1,0]])
sage: a, b, c = Q.Hrepresentation()[:3]
sage: P.meet_of_facets(b, c)
sage: P.meet_of_facets(a, b)
```

That is, `join_of_Vrep` and `meet_of_facets` probably need to check if `v` and `facet` given as `PolyhedronFace` or `V/H-representation` actually correspond to `self`.

Some typos:
- Line 6960: empty line but `::`
- Line 7025: maybe you meant that the index cannot correspond to an equation in the Hrepresentation.
- Line 7030: `ValueError: 0 is not a facet` --> ` An equation (1, 1, 1, 1, 1) x - 15 == 0 is not a facet`?



---

archive/issue_comments_417881.json:
```json
{
    "body": "In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? \n\nI guess it is the latter, but the documentation doesn't say. (And the name `.._Vrepr` somehow suggests the former?)\n\nI also got a SIGSEGV when trying the following\n\n```\nsage: Q = Polyhedron(lines=[[1,1]])                                             \nsage: CQ = CombinatorialPolyhedron(Q)\nsage: CQ.join_of_Vrep(0)\n```\n",
    "created_at": "2021-05-17T09:54:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417881",
    "user": "@yuan-zhou"
}
```

In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? 

I guess it is the latter, but the documentation doesn't say. (And the name `.._Vrepr` somehow suggests the former?)

I also got a SIGSEGV when trying the following

```
sage: Q = Polyhedron(lines=[[1,1]])                                             
sage: CQ = CombinatorialPolyhedron(Q)
sage: CQ.join_of_Vrep(0)
```




---

archive/issue_comments_417882.json:
```json
{
    "body": "Replying to [comment:27 yzh]:\n> In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? \n\nSame thing.\n> \n> I guess it is the latter, but the documentation doesn't say. (And the name `.._Vrepr` somehow suggests the former?)\n> \n> I also got a SIGSEGV when trying the following\n> {{{\n> sage: Q = Polyhedron(lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                             \n> sage: CQ = CombinatorialPolyhedron(Q)\n> sage: CQ.join_of_Vrep(0)\n> }}}\n\nBad.",
    "created_at": "2021-05-17T09:59:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417882",
    "user": "@kliem"
}
```

Replying to [comment:27 yzh]:
> In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? 

Same thing.
> 
> I guess it is the latter, but the documentation doesn't say. (And the name `.._Vrepr` somehow suggests the former?)
> 
> I also got a SIGSEGV when trying the following
> {{{
> sage: Q = Polyhedron(lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                             
> sage: CQ = CombinatorialPolyhedron(Q)
> sage: CQ.join_of_Vrep(0)
> }}}

Bad.



---

archive/issue_comments_417883.json:
```json
{
    "body": "Replying to [comment:26 yzh]:\n> I'm reading `base.py` and find the following corner case:\n> {{{\n> sage: P = Polyhedron(vertices=[[1,0,0], [0,1,0]], rays=[This is the Trac macro *1,1,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1,0-macro))               \n> sage: Q = Polyhedron(vertices=[[0,0],[0,1],[1,1],[1,0]])\n> sage: a, b, c = Q.Hrepresentation()[:3]\n> sage: P.meet_of_facets(b, c)\n> sage: P.meet_of_facets(a, b)\n> }}}\n> That is, `join_of_Vrep` and `meet_of_facets` probably need to check if `v` and `facet` given as `PolyhedronFace` or `V/H-representation` actually correspond to `self`.\n> \n> Some typos:\n> - Line 6960: empty line but `::`\nThis is common practice in sage. I don't know if it is good practice. It just means that this is another example explained by the previous comment.\n> - Line 7025: maybe you meant that the index cannot correspond to an equation in the Hrepresentation.\n> - Line 7030: `ValueError: 0 is not a facet` --> ` An equation (1, 1, 1, 1, 1) x - 15 == 0 is not a facet`?\n\nEverything else will be fixed with the next commit.",
    "created_at": "2021-05-17T10:05:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417883",
    "user": "@kliem"
}
```

Replying to [comment:26 yzh]:
> I'm reading `base.py` and find the following corner case:
> {{{
> sage: P = Polyhedron(vertices=[[1,0,0], [0,1,0]], rays=[This is the Trac macro *1,1,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1,0-macro))               
> sage: Q = Polyhedron(vertices=[[0,0],[0,1],[1,1],[1,0]])
> sage: a, b, c = Q.Hrepresentation()[:3]
> sage: P.meet_of_facets(b, c)
> sage: P.meet_of_facets(a, b)
> }}}
> That is, `join_of_Vrep` and `meet_of_facets` probably need to check if `v` and `facet` given as `PolyhedronFace` or `V/H-representation` actually correspond to `self`.
> 
> Some typos:
> - Line 6960: empty line but `::`
This is common practice in sage. I don't know if it is good practice. It just means that this is another example explained by the previous comment.
> - Line 7025: maybe you meant that the index cannot correspond to an equation in the Hrepresentation.
> - Line 7030: `ValueError: 0 is not a facet` --> ` An equation (1, 1, 1, 1, 1) x - 15 == 0 is not a facet`?

Everything else will be fixed with the next commit.



---

archive/issue_comments_417884.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-17T10:07:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417884",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417885.json:
```json
{
    "body": "Replying to [comment:28 gh-kliem]:\n> Replying to [comment:27 yzh]:\n> > In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? \n> \n> Same thing.\n\nThey are different in some cases, such as\n\n```\nsage: CQ.Hrepresentation()                                                      \n(An equation (1, -1) x + 0 == 0,)\nsage: CQ.facets()                                                               \n()\n```\n",
    "created_at": "2021-05-17T10:14:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417885",
    "user": "@yuan-zhou"
}
```

Replying to [comment:28 gh-kliem]:
> Replying to [comment:27 yzh]:
> > In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? 
> 
> Same thing.

They are different in some cases, such as

```
sage: CQ.Hrepresentation()                                                      
(An equation (1, -1) x + 0 == 0,)
sage: CQ.facets()                                                               
()
```




---

archive/issue_comments_417886.json:
```json
{
    "body": "Ok. Forgot that.",
    "created_at": "2021-05-17T10:54:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417886",
    "user": "@kliem"
}
```

Ok. Forgot that.



---

archive/issue_comments_417887.json:
```json
{
    "body": "This is certainly detail, but it bothers me that `Polyhedron.join_of_Vrep` can take a line as Vrep (it simply ignores the line) whereas `Polyhedron.meet_of_facets` would raise an error for equation or index corresponding to an equation. It is not symmetric. Also, I would give `facet.dim() + 1 == self.dim()` a separate error message.",
    "created_at": "2021-05-17T11:07:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417887",
    "user": "@yuan-zhou"
}
```

This is certainly detail, but it bothers me that `Polyhedron.join_of_Vrep` can take a line as Vrep (it simply ignores the line) whereas `Polyhedron.meet_of_facets` would raise an error for equation or index corresponding to an equation. It is not symmetric. Also, I would give `facet.dim() + 1 == self.dim()` a separate error message.



---

archive/issue_comments_417888.json:
```json
{
    "body": "Replying to [comment:31 yzh]:\n> Replying to [comment:28 gh-kliem]:\n> > Replying to [comment:27 yzh]:\n> > > In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? \n> > \n> > Same thing.\n> \n> They are different in some cases, such as\n> {{{\n> sage: CQ.Hrepresentation()                                                      \n> (An equation (1, -1) x + 0 == 0,)\n> sage: CQ.facets()                                                               \n> ()\n> }}}\n\nThe whole equation thing is so messed up, I don't even know where to start.\n\nIt was never a good decision to permit those in the first place.\n\nSometimes it's first the equations and then the inequalities, sometimes it's the other way around.\n\nMaybe have same consistently last throughout the module? What do you think.\n\nI have the feeling that there are some really bad design decisions that are haunting me.",
    "created_at": "2021-05-17T11:13:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417888",
    "user": "@kliem"
}
```

Replying to [comment:31 yzh]:
> Replying to [comment:28 gh-kliem]:
> > Replying to [comment:27 yzh]:
> > > In `/src/sage/geometry/polyhedron/combinatorial_polyhedron/base.pyx`, do the methods `join_of_Vrep` and `meet_of_facets` of `CombinatorialPolyhedron` have input `indices` corresponding to `Vrepresentation`/`Hrepresentation` or `.vertices()`/`.facets()`? 
> > 
> > Same thing.
> 
> They are different in some cases, such as
> {{{
> sage: CQ.Hrepresentation()                                                      
> (An equation (1, -1) x + 0 == 0,)
> sage: CQ.facets()                                                               
> ()
> }}}

The whole equation thing is so messed up, I don't even know where to start.

It was never a good decision to permit those in the first place.

Sometimes it's first the equations and then the inequalities, sometimes it's the other way around.

Maybe have same consistently last throughout the module? What do you think.

I have the feeling that there are some really bad design decisions that are haunting me.



---

archive/issue_comments_417889.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-17T11:13:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417889",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417890.json:
```json
{
    "body": "I mean the `ambient_H_indices` of faces are not matching up the `Hrepresentation`. That is one thing that is annoying.",
    "created_at": "2021-05-17T11:15:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417890",
    "user": "@kliem"
}
```

I mean the `ambient_H_indices` of faces are not matching up the `Hrepresentation`. That is one thing that is annoying.



---

archive/issue_comments_417891.json:
```json
{
    "body": "Replying to [comment:33 yzh]:\n> This is certainly detail, but it bothers me that `Polyhedron.join_of_Vrep` can take a line as Vrep (it simply ignores the line) whereas `Polyhedron.meet_of_facets` would raise an error for equation or index corresponding to an equation. It is not symmetric. Also, I would give `facet.dim() + 1 == self.dim()` a separate error message.\n\nAs stated above (at least I think I said this). It don't have a strong opinion on this. So you are proposing to just ignore equations? Or raise an error in both cases?",
    "created_at": "2021-05-17T12:21:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417891",
    "user": "@kliem"
}
```

Replying to [comment:33 yzh]:
> This is certainly detail, but it bothers me that `Polyhedron.join_of_Vrep` can take a line as Vrep (it simply ignores the line) whereas `Polyhedron.meet_of_facets` would raise an error for equation or index corresponding to an equation. It is not symmetric. Also, I would give `facet.dim() + 1 == self.dim()` a separate error message.

As stated above (at least I think I said this). It don't have a strong opinion on this. So you are proposing to just ignore equations? Or raise an error in both cases?



---

archive/issue_comments_417892.json:
```json
{
    "body": "Indeed, the indexing is very confusing, even when there is no equations. \n\n```\nsage: P = Polyhedron(vertices=[[1,0], [0,1]], rays=[[1,1]], backend='field')    \nsage: P.Hrepresentation()                                                       \n(An inequality (1/2, -1/2) x + 1/2 >= 0,\n An inequality (-1/2, 1/2) x + 1/2 >= 0,\n An inequality (1/2, 1/2) x - 1/2 >= 0)\nsage: P.facets()                                                                \n(A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 2 vertices,\n A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray,\n A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray)\nsage: CP = CombinatorialPolyhedron(P)                                           \nsage: CP.Hrepresentation()                                                      \n(An inequality (1/2, -1/2) x + 1/2 >= 0,\n An inequality (-1/2, 1/2) x + 1/2 >= 0,\n An inequality (1/2, 1/2) x - 1/2 >= 0)\nsage: CP.facets()                                                               \n((A vertex at (0, 1), A ray in the direction (1, 1)),\n (A vertex at (1, 0), A ray in the direction (1, 1)),\n (A vertex at (1, 0), A vertex at (0, 1)))\n```\n\n`P.Hrepresentation()` and `P.facets()` are not ordered in the same way. Neither do `P.facets()` and `CP.facets()`. (Please ignore the above code block. I think I understand it now.)\n\nLet's focus on the `CombinatorialPolyhedron` first. \n\nAs you mentioned, it is weird that a face of a combinatorial polyhedron has `ambient_H_indicies()` not matching `ambient_Hrepresentation()` in length.\nExample with equation:\n\n```\nsage: P = Polyhedron(vertices=[[1,0,0], [0,1,0]], rays=[[1,1,0]], backend='field')                                                                \u200b\nsage: P.Hrepresentation()                                                       \n(An inequality (1/2, -1/2, 0) x + 1/2 >= 0,\n\u200bAn inequality (-1/2, 1/2, 0) x + 1/2 >= 0,\n\u200bAn inequality (1/2, 1/2, 0) x - 1/2 >= 0,\n\u200bAn equation (0, 0, 1) x + 0 == 0)\nsage: P.facets()                                                                \n(A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 2 vertices,\n\u200bA 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray,\n\u200bA 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray)\nsage: CP = CombinatorialPolyhedron(P)                                           \nsage: CP.Hrepresentation()                                                      \n(An equation (0, 0, 1) x + 0 == 0,\n\u200bAn inequality (1/2, -1/2, 0) x + 1/2 >= 0,\n\u200bAn inequality (-1/2, 1/2, 0) x + 1/2 >= 0,\n\u200bAn inequality (1/2, 1/2, 0) x - 1/2 >= 0)\nsage: CP.facets()                                                               \n((A vertex at (0, 1, 0), A ray in the direction (1, 1, 0)),\n\u200b(A vertex at (1, 0, 0), A ray in the direction (1, 1, 0)),\n\u200b(A vertex at (1, 0, 0), A vertex at (0, 1, 0)))\nsage: list(P.face_generator())                                                  \n[A 2-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 2 vertices and 1 ray,\n\u200bA -1-dimensional face of a Polyhedron in QQ^3,\n\u200bA 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 2 vertices,\n\u200bA 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray,\n\u200bA 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray,\n\u200bA 0-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex,\n\u200bA 0-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex]\nsage: list(CP.face_iter())                                                      \n[A 1-dimensional face of a 2-dimensional combinatorial polyhedron,\n\u200bA 1-dimensional face of a 2-dimensional combinatorial polyhedron,\n\u200bA 1-dimensional face of a 2-dimensional combinatorial polyhedron,\n\u200bA 0-dimensional face of a 2-dimensional combinatorial polyhedron,\n\u200bA 0-dimensional face of a 2-dimensional combinatorial polyhedron]\nsage: f = list(P.face_generator())[2]\nsage: f.ambient_Hrepresentation()                                       \n(An equation (0, 0, 1) x + 0 == 0, An inequality (1/2, 1/2, 0) x - 1/2 >= 0)\nsage: f.ambient_H_indices()  # not sorted                                         \n(3, 2)\nsage: cf = next(CP.face_iter())\nsage: cf.ambient_Hrepresentation()                                      \n(An inequality (1/2, 1/2, 0) x - 1/2 >= 0, An equation (0, 0, 1) x + 0 == 0)\nsage: cf.n_ambient_Hrepresentation()     # discard equation                          \n1\nsage: cf.ambient_H_indices()             # discard equation\n(2,)\n```\n\nIn my opinion, even through the lines and the equations are not used in the computation of a Combinatorial Polyhedron, they should be included in the `ambient_V/Hrepresentaion` and `ambient_V/H_indices`. It would be hard to choose between equations+inequalities or inequalities+equations for `Polyhedron_base` since the order is not consistent throughout different backends. However, for `CombinatorialPolyhedron`, I think it would make sense to fix the order, say, to inequalities+equations. (Note that currently it is equations+inequalities, which seems bad to me.)\n\nUsing this order with inequalities first, there will be no strange offset treatment needed for `meet_of_facets`. We just require that the indices of `CP.meet_of_facets(*indices)` cannot exceed `CP.n_facets()`. Raise error otherwise.\n\nSimilarly, in `CP.Vrepresentation()`, the order is vertices+rays+lines (as in the code right now). Thus, for `CP.join_of_Vrep(*indices)`, we just require that indices cannot exceed `CP.n_vertices() + CP.n_rays()`. Raise error otherwise.\n\nPerhaps, it would be useful to have `CP.rays/lines/inequalities/equations` and `cf.vertices/rays/lines/inequalities/equations` just for output? Not sure about this, but at least `CP.n_rays()` seems needed.\n\nExpected returns\n\n```\nsage: f.ambient_Hrepresentation()                                       \n(An inequality (1/2, 1/2, 0) x - 1/2 >= 0, An equation (0, 0, 1) x + 0 == 0)\nsage: f.ambient_H_indices()                                    \n(2, 3)\nsage: cf.ambient_Hrepresentation()                                      \n(An inequality (1/2, 1/2, 0) x - 1/2 >= 0, An equation (0, 0, 1) x + 0 == 0)\nsage: cf.n_ambient_Hrepresentation()\nsage: cf.ambient_H_indices()\n(2, 3)\n```\n",
    "created_at": "2021-05-18T02:40:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417892",
    "user": "@yuan-zhou"
}
```

Indeed, the indexing is very confusing, even when there is no equations. 

```
sage: P = Polyhedron(vertices=[[1,0], [0,1]], rays=[[1,1]], backend='field')    
sage: P.Hrepresentation()                                                       
(An inequality (1/2, -1/2) x + 1/2 >= 0,
 An inequality (-1/2, 1/2) x + 1/2 >= 0,
 An inequality (1/2, 1/2) x - 1/2 >= 0)
sage: P.facets()                                                                
(A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 2 vertices,
 A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray,
 A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray)
sage: CP = CombinatorialPolyhedron(P)                                           
sage: CP.Hrepresentation()                                                      
(An inequality (1/2, -1/2) x + 1/2 >= 0,
 An inequality (-1/2, 1/2) x + 1/2 >= 0,
 An inequality (1/2, 1/2) x - 1/2 >= 0)
sage: CP.facets()                                                               
((A vertex at (0, 1), A ray in the direction (1, 1)),
 (A vertex at (1, 0), A ray in the direction (1, 1)),
 (A vertex at (1, 0), A vertex at (0, 1)))
```

`P.Hrepresentation()` and `P.facets()` are not ordered in the same way. Neither do `P.facets()` and `CP.facets()`. (Please ignore the above code block. I think I understand it now.)

Let's focus on the `CombinatorialPolyhedron` first. 

As you mentioned, it is weird that a face of a combinatorial polyhedron has `ambient_H_indicies()` not matching `ambient_Hrepresentation()` in length.
Example with equation:

```
sage: P = Polyhedron(vertices=[[1,0,0], [0,1,0]], rays=[[1,1,0]], backend='field')                                                                â€‹
sage: P.Hrepresentation()                                                       
(An inequality (1/2, -1/2, 0) x + 1/2 >= 0,
â€‹An inequality (-1/2, 1/2, 0) x + 1/2 >= 0,
â€‹An inequality (1/2, 1/2, 0) x - 1/2 >= 0,
â€‹An equation (0, 0, 1) x + 0 == 0)
sage: P.facets()                                                                
(A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 2 vertices,
â€‹A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray,
â€‹A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray)
sage: CP = CombinatorialPolyhedron(P)                                           
sage: CP.Hrepresentation()                                                      
(An equation (0, 0, 1) x + 0 == 0,
â€‹An inequality (1/2, -1/2, 0) x + 1/2 >= 0,
â€‹An inequality (-1/2, 1/2, 0) x + 1/2 >= 0,
â€‹An inequality (1/2, 1/2, 0) x - 1/2 >= 0)
sage: CP.facets()                                                               
((A vertex at (0, 1, 0), A ray in the direction (1, 1, 0)),
â€‹(A vertex at (1, 0, 0), A ray in the direction (1, 1, 0)),
â€‹(A vertex at (1, 0, 0), A vertex at (0, 1, 0)))
sage: list(P.face_generator())                                                  
[A 2-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 2 vertices and 1 ray,
â€‹A -1-dimensional face of a Polyhedron in QQ^3,
â€‹A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 2 vertices,
â€‹A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray,
â€‹A 1-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex and 1 ray,
â€‹A 0-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex,
â€‹A 0-dimensional face of a Polyhedron in QQ^3 defined as the convex hull of 1 vertex]
sage: list(CP.face_iter())                                                      
[A 1-dimensional face of a 2-dimensional combinatorial polyhedron,
â€‹A 1-dimensional face of a 2-dimensional combinatorial polyhedron,
â€‹A 1-dimensional face of a 2-dimensional combinatorial polyhedron,
â€‹A 0-dimensional face of a 2-dimensional combinatorial polyhedron,
â€‹A 0-dimensional face of a 2-dimensional combinatorial polyhedron]
sage: f = list(P.face_generator())[2]
sage: f.ambient_Hrepresentation()                                       
(An equation (0, 0, 1) x + 0 == 0, An inequality (1/2, 1/2, 0) x - 1/2 >= 0)
sage: f.ambient_H_indices()  # not sorted                                         
(3, 2)
sage: cf = next(CP.face_iter())
sage: cf.ambient_Hrepresentation()                                      
(An inequality (1/2, 1/2, 0) x - 1/2 >= 0, An equation (0, 0, 1) x + 0 == 0)
sage: cf.n_ambient_Hrepresentation()     # discard equation                          
1
sage: cf.ambient_H_indices()             # discard equation
(2,)
```

In my opinion, even through the lines and the equations are not used in the computation of a Combinatorial Polyhedron, they should be included in the `ambient_V/Hrepresentaion` and `ambient_V/H_indices`. It would be hard to choose between equations+inequalities or inequalities+equations for `Polyhedron_base` since the order is not consistent throughout different backends. However, for `CombinatorialPolyhedron`, I think it would make sense to fix the order, say, to inequalities+equations. (Note that currently it is equations+inequalities, which seems bad to me.)

Using this order with inequalities first, there will be no strange offset treatment needed for `meet_of_facets`. We just require that the indices of `CP.meet_of_facets(*indices)` cannot exceed `CP.n_facets()`. Raise error otherwise.

Similarly, in `CP.Vrepresentation()`, the order is vertices+rays+lines (as in the code right now). Thus, for `CP.join_of_Vrep(*indices)`, we just require that indices cannot exceed `CP.n_vertices() + CP.n_rays()`. Raise error otherwise.

Perhaps, it would be useful to have `CP.rays/lines/inequalities/equations` and `cf.vertices/rays/lines/inequalities/equations` just for output? Not sure about this, but at least `CP.n_rays()` seems needed.

Expected returns

```
sage: f.ambient_Hrepresentation()                                       
(An inequality (1/2, 1/2, 0) x - 1/2 >= 0, An equation (0, 0, 1) x + 0 == 0)
sage: f.ambient_H_indices()                                    
(2, 3)
sage: cf.ambient_Hrepresentation()                                      
(An inequality (1/2, 1/2, 0) x - 1/2 >= 0, An equation (0, 0, 1) x + 0 == 0)
sage: cf.n_ambient_Hrepresentation()
sage: cf.ambient_H_indices()
(2, 3)
```




---

archive/issue_comments_417893.json:
```json
{
    "body": "Now consider `Polyhedron_base`. \n\nTo be honest, I often forget what `join_of_..` and `meet_of_...` mean in this class. I propose to rename them. How do `def least_common_superface_of_Vrep(self, *Vrepresentatives)` and `def greatest_common_subface_of_Hrep(self, *Hrepresentatives)` sound? I would prefer that the two functions are sort of symmetric. Lines and equations are allowed, but are simply ignored when passing to `self.face_generator()`.\n\nIn the Hrepresentation, `ppl` backend puts equations first, and `field`, `cdd`, `normaliz` put inequalities first. (I was not able to install `polymake` backend.) Thus, the offset treatment seems needed.",
    "created_at": "2021-05-18T04:13:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417893",
    "user": "@yuan-zhou"
}
```

Now consider `Polyhedron_base`. 

To be honest, I often forget what `join_of_..` and `meet_of_...` mean in this class. I propose to rename them. How do `def least_common_superface_of_Vrep(self, *Vrepresentatives)` and `def greatest_common_subface_of_Hrep(self, *Hrepresentatives)` sound? I would prefer that the two functions are sort of symmetric. Lines and equations are allowed, but are simply ignored when passing to `self.face_generator()`.

In the Hrepresentation, `ppl` backend puts equations first, and `field`, `cdd`, `normaliz` put inequalities first. (I was not able to install `polymake` backend.) Thus, the offset treatment seems needed.



---

archive/issue_comments_417894.json:
```json
{
    "body": "Note that equations would be ignored explicitly and lines implicitly. But for the user it's the same, I guess.\n\nAs mentioned before, `CombinatorialPolyhedron` has some difficult design decisions. Equations are almost everywhere ignored. They are just added in the end to every face etc. Lines are not everywhere ignored. They really belong to the Vrepresentation of the `CombinatorialPolyhedron` and are part of the indices.\n\nA reason for this is that I wanted to have the dimensions of the faces match up with the original polyhedron. So lines are needed to push the dimension up. Is this a bad choice? I don't know exactly, however I would like to wait with this until someone really wants to work with polyhedra with lines.\n\nOne problem is the following: \n\nMaybe we could treat lines and equations more symmetric at some point. I don't know what would be best.\n\nI would prefer to keep `join_of_` etc. However, it does not hurt to add the aliases you suggested. They do make sense. Maybe `meet_of_Hrep` is really better for `Polyhedron_base`.\n\n`CombinatorialPolyhedron.facets` and `Polyhedron_base.facets` are really different things unfortunatly. `Polyhedron_base.facets` just gives you the facets as faces in the order given by the face iterator (reverse). `CombinatorialPolyhedron.facets` gives you the facets as Vrepresentation indices in the order of `Hrepresentation`. Maybe I should just document this.\n\nThe order of the `Vrepresentation` of `CombinatorialPolyhedron` is not fixed. This just happened because you use `Polyhedron_base` to initialize it. You can give it in any order you like and shuffle. Hence the strange method `vertices` that gives you all the elements of `Vrepresentation` that are not contained in the far face. (This is also historic. At some point I wanted to initialize `CombinatorialPolyhedron` just from the incidence matrix, which is not possible, because some unbounded polyhedra have the same incidence matrix, if you do not consider the far face).\n\n`CombinatorialPolyhedron` does not distinguish rays and lines currently. Those are just things that happen to be in the `Vrepresentation`. They are kept as indices and both contained in the far face. They also cannot really be distinguished in sage, because `Cone` does not know lines at all. It just keeps to opposite rays:\n\n\n```\nsage: C = Cone([[1,0], [0,1], [-1,0]])   \nsage: C.incidence_matrix()                                                                                                                                                          \n[0]\n[1]\n[1]\nsage: CP = CombinatorialPolyhedron(C)                                                                                                                                               \nsage: CP.Vrepresentation()                                                                                                                                                          \n(N(0, 1), N(1, 0), N(-1, 0), N(0, 0))\n```\n\nWhat's the number of rays in this case. Is it one or three?",
    "created_at": "2021-05-18T07:41:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417894",
    "user": "@kliem"
}
```

Note that equations would be ignored explicitly and lines implicitly. But for the user it's the same, I guess.

As mentioned before, `CombinatorialPolyhedron` has some difficult design decisions. Equations are almost everywhere ignored. They are just added in the end to every face etc. Lines are not everywhere ignored. They really belong to the Vrepresentation of the `CombinatorialPolyhedron` and are part of the indices.

A reason for this is that I wanted to have the dimensions of the faces match up with the original polyhedron. So lines are needed to push the dimension up. Is this a bad choice? I don't know exactly, however I would like to wait with this until someone really wants to work with polyhedra with lines.

One problem is the following: 

Maybe we could treat lines and equations more symmetric at some point. I don't know what would be best.

I would prefer to keep `join_of_` etc. However, it does not hurt to add the aliases you suggested. They do make sense. Maybe `meet_of_Hrep` is really better for `Polyhedron_base`.

`CombinatorialPolyhedron.facets` and `Polyhedron_base.facets` are really different things unfortunatly. `Polyhedron_base.facets` just gives you the facets as faces in the order given by the face iterator (reverse). `CombinatorialPolyhedron.facets` gives you the facets as Vrepresentation indices in the order of `Hrepresentation`. Maybe I should just document this.

The order of the `Vrepresentation` of `CombinatorialPolyhedron` is not fixed. This just happened because you use `Polyhedron_base` to initialize it. You can give it in any order you like and shuffle. Hence the strange method `vertices` that gives you all the elements of `Vrepresentation` that are not contained in the far face. (This is also historic. At some point I wanted to initialize `CombinatorialPolyhedron` just from the incidence matrix, which is not possible, because some unbounded polyhedra have the same incidence matrix, if you do not consider the far face).

`CombinatorialPolyhedron` does not distinguish rays and lines currently. Those are just things that happen to be in the `Vrepresentation`. They are kept as indices and both contained in the far face. They also cannot really be distinguished in sage, because `Cone` does not know lines at all. It just keeps to opposite rays:


```
sage: C = Cone([[1,0], [0,1], [-1,0]])   
sage: C.incidence_matrix()                                                                                                                                                          
[0]
[1]
[1]
sage: CP = CombinatorialPolyhedron(C)                                                                                                                                               
sage: CP.Vrepresentation()                                                                                                                                                          
(N(0, 1), N(1, 0), N(-1, 0), N(0, 0))
```

What's the number of rays in this case. Is it one or three?



---

archive/issue_comments_417895.json:
```json
{
    "body": "I created #31834.\n\nPlease have a look after I pushed the changes, whether this looks reasonable.",
    "created_at": "2021-05-18T07:45:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417895",
    "user": "@kliem"
}
```

I created #31834.

Please have a look after I pushed the changes, whether this looks reasonable.



---

archive/issue_comments_417896.json:
```json
{
    "body": "Replying to [comment:40 gh-kliem]:\n> Equations are almost everywhere ignored. They are just added in the end to every face etc. Lines are not everywhere ignored. They really belong to the Vrepresentation of the `CombinatorialPolyhedron` and are part of the indices.\nThat makes sense to me. I often need to deal with polyhedra with equations, so #31834 would be very helpful to me. \n\n> I would prefer to keep `join_of_` etc. However, it does not hurt to add the aliases you suggested. They do make sense. Maybe `meet_of_Hrep` is really better for `Polyhedron_base`.\nSounds good! Keep `join_of_Vrep` and `meet_of_Hrep` for the base class and make aliases.\n\n> `CombinatorialPolyhedron.facets` and `Polyhedron_base.facets` are really different things unfortunatly. \nYes, I got it after looking into the code closely. At first, I imagined that `CombinatorialPolyhedron.facets` returns `CombinatorialFace` objects. (The output format was described in the docstring but I was not careful in reading it.) What's the reason to use an unusual output format?  Can the conversion to Vrep indices be deferred to where that's needed (such as in `__reduce__`)?\n\n> The order of the `Vrepresentation` of `CombinatorialPolyhedron` is not fixed. \nI assumed that `CombinatorialPolyhedron` has `Vrepresentation` being \"[vertices, rays, lines]\" because this expression appears many times in combinatorial_polyhedron/base.pyx\nDoes it make sense to fix the order, or is it a waste of time?\nIn fact, `.../polyhedron/representation.py` defines   `INEQUALITY = 0, EQUATION = 1, VERTEX = 2, RAY = 3, LINE = 4`. It's also used in #31702.\nCurrently, `ppl` and `cdd` backends do not respect this order (creating a lot of trouble for my doctests), and the other backends `field` and `normaliz` respect this order.\n\n\n> `CombinatorialPolyhedron` does not distinguish rays and lines currently. Those are just things that happen to be in the `Vrepresentation`. They are kept as indices and both contained in the far face. \nOk. But don't we want a \"canonical\" representation (in terms of numbers at least) for `CombinatorialPolyhedron`? Note that the polyhedron base class has that. For instant, are the combinatorial polyhedron generated by two opposite rays and the other polyhedron generated by one line considered the same?\n\n> They also cannot really be distinguished in sage, because `Cone` does not know lines at all. It just keeps to opposite rays:\n> ...\n> What's the number of rays in this case. Is it one or three?\nAlthough `Cone` allows for non-pointed cones, I believe that `Cone` and in particular the `Fan` class mainly deal with pointed (i.e. strictly convex) cones. \n\n```\n    When the cone in question is not strictly convex, the standard form for\n    the \"generating rays\" of the linear subspace is \"basis vectors and their\n    negatives\", as in the following example::\n\n        sage: plane = Cone([(1,0), (0,1), (-1,-1)])\n        sage: plane.rays()\n        N( 0,  1),\n        N( 0, -1),\n        N( 1,  0),\n        N(-1,  0)\n        in 2-d lattice N\n```\n\nBecause `Cone` has its rays in a \"canonical\" form, it would be possible for a `CombinatorialPolyhedron` constructed from a `Cone` to combine opposite rays to lines.\n\nIn my opinion, `CP` in your example should have one vertex one ray and one line. I don't know how to express the line in terms of `N(?, ?)`, but writing the vertex as `N(0, 0)` looks weird to me too.",
    "created_at": "2021-05-18T08:57:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417896",
    "user": "@yuan-zhou"
}
```

Replying to [comment:40 gh-kliem]:
> Equations are almost everywhere ignored. They are just added in the end to every face etc. Lines are not everywhere ignored. They really belong to the Vrepresentation of the `CombinatorialPolyhedron` and are part of the indices.
That makes sense to me. I often need to deal with polyhedra with equations, so #31834 would be very helpful to me. 

> I would prefer to keep `join_of_` etc. However, it does not hurt to add the aliases you suggested. They do make sense. Maybe `meet_of_Hrep` is really better for `Polyhedron_base`.
Sounds good! Keep `join_of_Vrep` and `meet_of_Hrep` for the base class and make aliases.

> `CombinatorialPolyhedron.facets` and `Polyhedron_base.facets` are really different things unfortunatly. 
Yes, I got it after looking into the code closely. At first, I imagined that `CombinatorialPolyhedron.facets` returns `CombinatorialFace` objects. (The output format was described in the docstring but I was not careful in reading it.) What's the reason to use an unusual output format?  Can the conversion to Vrep indices be deferred to where that's needed (such as in `__reduce__`)?

> The order of the `Vrepresentation` of `CombinatorialPolyhedron` is not fixed. 
I assumed that `CombinatorialPolyhedron` has `Vrepresentation` being "[vertices, rays, lines]" because this expression appears many times in combinatorial_polyhedron/base.pyx
Does it make sense to fix the order, or is it a waste of time?
In fact, `.../polyhedron/representation.py` defines   `INEQUALITY = 0, EQUATION = 1, VERTEX = 2, RAY = 3, LINE = 4`. It's also used in #31702.
Currently, `ppl` and `cdd` backends do not respect this order (creating a lot of trouble for my doctests), and the other backends `field` and `normaliz` respect this order.


> `CombinatorialPolyhedron` does not distinguish rays and lines currently. Those are just things that happen to be in the `Vrepresentation`. They are kept as indices and both contained in the far face. 
Ok. But don't we want a "canonical" representation (in terms of numbers at least) for `CombinatorialPolyhedron`? Note that the polyhedron base class has that. For instant, are the combinatorial polyhedron generated by two opposite rays and the other polyhedron generated by one line considered the same?

> They also cannot really be distinguished in sage, because `Cone` does not know lines at all. It just keeps to opposite rays:
> ...
> What's the number of rays in this case. Is it one or three?
Although `Cone` allows for non-pointed cones, I believe that `Cone` and in particular the `Fan` class mainly deal with pointed (i.e. strictly convex) cones. 

```
    When the cone in question is not strictly convex, the standard form for
    the "generating rays" of the linear subspace is "basis vectors and their
    negatives", as in the following example::

        sage: plane = Cone([(1,0), (0,1), (-1,-1)])
        sage: plane.rays()
        N( 0,  1),
        N( 0, -1),
        N( 1,  0),
        N(-1,  0)
        in 2-d lattice N
```

Because `Cone` has its rays in a "canonical" form, it would be possible for a `CombinatorialPolyhedron` constructed from a `Cone` to combine opposite rays to lines.

In my opinion, `CP` in your example should have one vertex one ray and one line. I don't know how to express the line in terms of `N(?, ?)`, but writing the vertex as `N(0, 0)` looks weird to me too.



---

archive/issue_comments_417897.json:
```json
{
    "body": "Just as with cones, `Polyhedron_base` mainly deals with polytopes and strictly convex polyhedra.\n\nThings with lines should be correct, but I don't think it is a very important use case. So if things are a bit ugly in the backend, it is fine unless someone really works with that stuff and wants high speed performance (or unless working around the bad design is more work then creating a better design and working with it).",
    "created_at": "2021-05-18T09:13:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417897",
    "user": "@kliem"
}
```

Just as with cones, `Polyhedron_base` mainly deals with polytopes and strictly convex polyhedra.

Things with lines should be correct, but I don't think it is a very important use case. So if things are a bit ugly in the backend, it is fine unless someone really works with that stuff and wants high speed performance (or unless working around the bad design is more work then creating a better design and working with it).



---

archive/issue_comments_417898.json:
```json
{
    "body": "While I agree that #31834 should be a base for this ticket, I don't think we should make this ticket here dependent on the other fixes.",
    "created_at": "2021-05-18T10:06:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417898",
    "user": "@kliem"
}
```

While I agree that #31834 should be a base for this ticket, I don't think we should make this ticket here dependent on the other fixes.



---

archive/issue_comments_417899.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:",
    "created_at": "2021-05-18T20:06:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417899",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:



---

archive/issue_comments_417900.json:
```json
{
    "body": "Ok, I think I have your requests taken care of for now.",
    "created_at": "2021-05-18T20:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417900",
    "user": "@kliem"
}
```

Ok, I think I have your requests taken care of for now.



---

archive/issue_comments_417901.json:
```json
{
    "body": "`src/sage/geometry/polyhedron/base.py`\n- facets -> Hrepresentatives\n>\n\n```\ndef meet_of_Hrep(self, *Hrepresentatives):\n    r\"\"\"\n    Return the largest face that is contained in ``facets``.\n```\n\n- Equations at the end. Need to fix #31834. Without the fix, there could be a bug (`offset=0` but `ambient_H_indices` returns equations first) at `facet = H_indices[0] if H_indices[0] >= offset else H_indices[-1]`. After the fix, the expected return of the doctest is `(An inequality (0, 0, 1) x - 1 >= 0, An equation (1, 1, 1) x - 6 == 0)`.\n>\n\n```\ndef meet_of_Hrep(self, *Hrepresentatives):\n    TESTS:\n      sage: P = polytopes.permutahedron(3, backend='field'\n      sage: P.meet_of_Hrep(0).ambient_Hrepresentation()\n      (An equation (1, 1, 1) x - 6 == 0, An inequality (0, 0, 1) x - 1 >= 0)\n```\n\n- Error message `raise ValueError(\"{} is not a Hrepresentative\".format(facet))`\n>\n\n```\nelse:\n    raise ValueError(\"{} is the index of an equation and not of an inequality\".format(facet))\n```\n",
    "created_at": "2021-05-19T16:21:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417901",
    "user": "@yuan-zhou"
}
```

`src/sage/geometry/polyhedron/base.py`
- facets -> Hrepresentatives
>

```
def meet_of_Hrep(self, *Hrepresentatives):
    r"""
    Return the largest face that is contained in ``facets``.
```

- Equations at the end. Need to fix #31834. Without the fix, there could be a bug (`offset=0` but `ambient_H_indices` returns equations first) at `facet = H_indices[0] if H_indices[0] >= offset else H_indices[-1]`. After the fix, the expected return of the doctest is `(An inequality (0, 0, 1) x - 1 >= 0, An equation (1, 1, 1) x - 6 == 0)`.
>

```
def meet_of_Hrep(self, *Hrepresentatives):
    TESTS:
      sage: P = polytopes.permutahedron(3, backend='field'
      sage: P.meet_of_Hrep(0).ambient_Hrepresentation()
      (An equation (1, 1, 1) x - 6 == 0, An inequality (0, 0, 1) x - 1 >= 0)
```

- Error message `raise ValueError("{} is not a Hrepresentative".format(facet))`
>

```
else:
    raise ValueError("{} is the index of an equation and not of an inequality".format(facet))
```




---

archive/issue_comments_417902.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:",
    "created_at": "2021-05-19T20:00:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417902",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:



---

archive/issue_comments_417903.json:
```json
{
    "body": "Replying to [comment:47 yzh]:\n> `src/sage/geometry/polyhedron/base.py`\n> - facets -> Hrepresentatives\n> >\n> {{{\n> def meet_of_Hrep(self, *Hrepresentatives):\n>     r\"\"\"\n>     Return the largest face that is contained in ``facets``.\n> }}}\n> - Equations at the end. Need to fix #31834. Without the fix, there could be a bug (`offset=0` but `ambient_H_indices` returns equations first) at `facet = H_indices[0] if H_indices[0] >= offset else H_indices[-1]`. After the fix, the expected return of the doctest is `(An inequality (0, 0, 1) x - 1 >= 0, An equation (1, 1, 1) x - 6 == 0)`.\n> >\n> {{{\n> def meet_of_Hrep(self, *Hrepresentatives):\n>     TESTS:\n>       sage: P = polytopes.permutahedron(3, backend='field'\n>       sage: P.meet_of_Hrep(0).ambient_Hrepresentation()\n>       (An equation (1, 1, 1) x - 6 == 0, An inequality (0, 0, 1) x - 1 >= 0)\n> }}}\n> - Error message `raise ValueError(\"{} is not a Hrepresentative\".format(facet))`\n> >\n> {{{\n> else:\n>     raise ValueError(\"{} is the index of an equation and not of an inequality\".format(facet))\n> }}}\n\nThanks. Should be taken care of.",
    "created_at": "2021-05-19T20:00:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417903",
    "user": "@kliem"
}
```

Replying to [comment:47 yzh]:
> `src/sage/geometry/polyhedron/base.py`
> - facets -> Hrepresentatives
> >
> {{{
> def meet_of_Hrep(self, *Hrepresentatives):
>     r"""
>     Return the largest face that is contained in ``facets``.
> }}}
> - Equations at the end. Need to fix #31834. Without the fix, there could be a bug (`offset=0` but `ambient_H_indices` returns equations first) at `facet = H_indices[0] if H_indices[0] >= offset else H_indices[-1]`. After the fix, the expected return of the doctest is `(An inequality (0, 0, 1) x - 1 >= 0, An equation (1, 1, 1) x - 6 == 0)`.
> >
> {{{
> def meet_of_Hrep(self, *Hrepresentatives):
>     TESTS:
>       sage: P = polytopes.permutahedron(3, backend='field'
>       sage: P.meet_of_Hrep(0).ambient_Hrepresentation()
>       (An equation (1, 1, 1) x - 6 == 0, An inequality (0, 0, 1) x - 1 >= 0)
> }}}
> - Error message `raise ValueError("{} is not a Hrepresentative".format(facet))`
> >
> {{{
> else:
>     raise ValueError("{} is the index of an equation and not of an inequality".format(facet))
> }}}

Thanks. Should be taken care of.



---

archive/issue_comments_417904.json:
```json
{
    "body": "The segmentation fault persists\n\n```\nsage: P = Polyhedron(lines=[[1,1]])                                                                        \nsage: C = CombinatorialPolyhedron(P)                                                                       \nsage: C.Vrepresentation()                                                                                  \n(A line in the direction (1, 1), A vertex at (0, 0))\nsage: C.join_of_Vrep(0)   \n```\n",
    "created_at": "2021-05-19T20:20:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417904",
    "user": "@yuan-zhou"
}
```

The segmentation fault persists

```
sage: P = Polyhedron(lines=[[1,1]])                                                                        
sage: C = CombinatorialPolyhedron(P)                                                                       
sage: C.Vrepresentation()                                                                                  
(A line in the direction (1, 1), A vertex at (0, 0))
sage: C.join_of_Vrep(0)   
```




---

archive/issue_comments_417905.json:
```json
{
    "body": "\n```\nsage: P.join_of_Vrep(0) \n```\n\nalso causes a segmentation fault.",
    "created_at": "2021-05-19T20:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417905",
    "user": "@yuan-zhou"
}
```


```
sage: P.join_of_Vrep(0) 
```

also causes a segmentation fault.



---

archive/issue_comments_417906.json:
```json
{
    "body": "And `meet_of_Hrep` as well.\n\nI'm currently trying to figure out how to resolve this. The `FaceIterator` was never initialized in that case, which makes life a bit annoying.",
    "created_at": "2021-05-19T20:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417906",
    "user": "@kliem"
}
```

And `meet_of_Hrep` as well.

I'm currently trying to figure out how to resolve this. The `FaceIterator` was never initialized in that case, which makes life a bit annoying.



---

archive/issue_comments_417907.json:
```json
{
    "body": "Replying to [comment:52 gh-kliem]:\n> And `meet_of_Hrep` as well.\n> \n> I'm currently trying to figure out how to resolve this. The `FaceIterator` was never initialized in that case, which makes life a bit annoying.\n\nI guess it's only on the extreme corner case where both `C.vertices()` and `C.facets()` are empty.",
    "created_at": "2021-05-19T20:30:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417907",
    "user": "@yuan-zhou"
}
```

Replying to [comment:52 gh-kliem]:
> And `meet_of_Hrep` as well.
> 
> I'm currently trying to figure out how to resolve this. The `FaceIterator` was never initialized in that case, which makes life a bit annoying.

I guess it's only on the extreme corner case where both `C.vertices()` and `C.facets()` are empty.



---

archive/issue_comments_417908.json:
```json
{
    "body": "I'm actually surprised that `Polyhedron([This is the Trac macro *0,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#0,0-macro))` works well. I did not expect this.",
    "created_at": "2021-05-19T20:33:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417908",
    "user": "@kliem"
}
```

I'm actually surprised that `Polyhedron([This is the Trac macro *0,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#0,0-macro))` works well. I did not expect this.



---

archive/issue_comments_417909.json:
```json
{
    "body": "Replying to [comment:54 gh-kliem]:\n> I'm actually surprised that `Polyhedron([This is the Trac macro *0,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#0,0-macro))` works well. I did not expect this.\n`Polyhedron([This is the Trac macro *0,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#0,0-macro))` is not as special as `Polyhedron(lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))` because the former has a vertex in its combinatorial polyhedron.\nTo fix the segmentation fault, can we just raise error in `FaceIterator_base.meet_of_Hrep` etc when `i >= self._n_facets + self._n_equations`?",
    "created_at": "2021-05-19T20:40:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417909",
    "user": "@yuan-zhou"
}
```

Replying to [comment:54 gh-kliem]:
> I'm actually surprised that `Polyhedron([This is the Trac macro *0,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#0,0-macro))` works well. I did not expect this.
`Polyhedron([This is the Trac macro *0,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#0,0-macro))` is not as special as `Polyhedron(lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))` because the former has a vertex in its combinatorial polyhedron.
To fix the segmentation fault, can we just raise error in `FaceIterator_base.meet_of_Hrep` etc when `i >= self._n_facets + self._n_equations`?



---

archive/issue_comments_417910.json:
```json
{
    "body": "The special thing about it is that it has a far face. It tries to figure out, whether `face` is contained in the far face, before finding the face via the iterator.\n\nIt assumes that the first face of `visited_all` is the far face, which is not initalized, hence the segmentation fault.",
    "created_at": "2021-05-19T21:03:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417910",
    "user": "@kliem"
}
```

The special thing about it is that it has a far face. It tries to figure out, whether `face` is contained in the far face, before finding the face via the iterator.

It assumes that the first face of `visited_all` is the far face, which is not initalized, hence the segmentation fault.



---

archive/issue_comments_417911.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-19T21:03:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417911",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417912.json:
```json
{
    "body": "A weird question: why are the error messages different? There is nothing wrong, though\n\n```\n+            sage: it._meet_of_coatoms(-1)\n+            Traceback (most recent call last):\n+            ...\n+            OverflowError: can't convert negative value to size_t\n...\n+            sage: it._join_of_atoms(-1)\n+            Traceback (most recent call last):\n+            ...\n+            IndexError: atoms out of range\n```\n",
    "created_at": "2021-05-19T21:20:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417912",
    "user": "@yuan-zhou"
}
```

A weird question: why are the error messages different? There is nothing wrong, though

```
+            sage: it._meet_of_coatoms(-1)
+            Traceback (most recent call last):
+            ...
+            OverflowError: can't convert negative value to size_t
...
+            sage: it._join_of_atoms(-1)
+            Traceback (most recent call last):
+            ...
+            IndexError: atoms out of range
```




---

archive/issue_comments_417913.json:
```json
{
    "body": "Another question that might sound silly: Why does `if n_atoms == self.coatoms.n_atoms():` mean that the face is the universe?",
    "created_at": "2021-05-19T21:36:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417913",
    "user": "@yuan-zhou"
}
```

Another question that might sound silly: Why does `if n_atoms == self.coatoms.n_atoms():` mean that the face is the universe?



---

archive/issue_comments_417914.json:
```json
{
    "body": "I have trouble understanding the following code.\n\n```\n+        while self.structure.current_dimension != self.structure.dimension:\n+            if face_issubset(face, self.structure.face):\n+                if face_issubset(self.structure.face, face):\n+                    # Found our face.\n+                    return 0\n+            else:\n+                # The face is not a subface/supface of the current face.\n+                self.ignore_subsets()\n+\n+            d = self.next_dimension()\n```\n\nWhen `face_issubset(face, self.structure.face)` is `False`, after `self.ignore_subsets()`, why does it move to the next dimension directly? Does it skip all other faces of the current dimension?\n\nSorry for asking so many questions.",
    "created_at": "2021-05-19T22:03:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417914",
    "user": "@yuan-zhou"
}
```

I have trouble understanding the following code.

```
+        while self.structure.current_dimension != self.structure.dimension:
+            if face_issubset(face, self.structure.face):
+                if face_issubset(self.structure.face, face):
+                    # Found our face.
+                    return 0
+            else:
+                # The face is not a subface/supface of the current face.
+                self.ignore_subsets()
+
+            d = self.next_dimension()
```

When `face_issubset(face, self.structure.face)` is `False`, after `self.ignore_subsets()`, why does it move to the next dimension directly? Does it skip all other faces of the current dimension?

Sorry for asking so many questions.



---

archive/issue_comments_417915.json:
```json
{
    "body": "Replying to [comment:59 yzh]:\n> Another question that might sound silly: Why does `if n_atoms == self.coatoms.n_atoms():` mean that the face is the universe?\n\nIf you contain all the atoms there are, then you must be the universe. A face containing all of the Vrepresentation is the universe.",
    "created_at": "2021-05-19T22:25:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417915",
    "user": "@kliem"
}
```

Replying to [comment:59 yzh]:
> Another question that might sound silly: Why does `if n_atoms == self.coatoms.n_atoms():` mean that the face is the universe?

If you contain all the atoms there are, then you must be the universe. A face containing all of the Vrepresentation is the universe.



---

archive/issue_comments_417916.json:
```json
{
    "body": "Replying to [comment:60 yzh]:\n> I have trouble understanding the following code.\n> {{{\n> +        while self.structure.current_dimension != self.structure.dimension:\n> +            if face_issubset(face, self.structure.face):\n> +                if face_issubset(self.structure.face, face):\n> +                    # Found our face.\n> +                    return 0\n> +            else:\n> +                # The face is not a subface/supface of the current face.\n> +                self.ignore_subsets()\n> +\n> +            d = self.next_dimension()\n> }}}\n> When `face_issubset(face, self.structure.face)` is `False`, after `self.ignore_subsets()`, why does it move to the next dimension directly? Does it skip all other faces of the current dimension?\n> \n> Sorry for asking so many questions.\n\nMaybe `self.next_dimension()` is not the best name. It goes to the next face and returns it's dimension. Might not change.",
    "created_at": "2021-05-19T22:27:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417916",
    "user": "@kliem"
}
```

Replying to [comment:60 yzh]:
> I have trouble understanding the following code.
> {{{
> +        while self.structure.current_dimension != self.structure.dimension:
> +            if face_issubset(face, self.structure.face):
> +                if face_issubset(self.structure.face, face):
> +                    # Found our face.
> +                    return 0
> +            else:
> +                # The face is not a subface/supface of the current face.
> +                self.ignore_subsets()
> +
> +            d = self.next_dimension()
> }}}
> When `face_issubset(face, self.structure.face)` is `False`, after `self.ignore_subsets()`, why does it move to the next dimension directly? Does it skip all other faces of the current dimension?
> 
> Sorry for asking so many questions.

Maybe `self.next_dimension()` is not the best name. It goes to the next face and returns it's dimension. Might not change.



---

archive/issue_comments_417917.json:
```json
{
    "body": "Replying to [comment:58 yzh]:\n> A weird question: why are the error messages different? There is nothing wrong, though\n> {{{\n> +            sage: it._meet_of_coatoms(-1)\n> +            Traceback (most recent call last):\n> +            ...\n> +            OverflowError: can't convert negative value to size_t\n> ...\n> +            sage: it._join_of_atoms(-1)\n> +            Traceback (most recent call last):\n> +            ...\n> +            IndexError: atoms out of range\n> }}}\n\nBecause it tries to convert -1 to a non-negative integer (I think when assigning it to `i`, which is defined to be of `size_t`). It fails then already and not in the next step.",
    "created_at": "2021-05-19T22:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417917",
    "user": "@kliem"
}
```

Replying to [comment:58 yzh]:
> A weird question: why are the error messages different? There is nothing wrong, though
> {{{
> +            sage: it._meet_of_coatoms(-1)
> +            Traceback (most recent call last):
> +            ...
> +            OverflowError: can't convert negative value to size_t
> ...
> +            sage: it._join_of_atoms(-1)
> +            Traceback (most recent call last):
> +            ...
> +            IndexError: atoms out of range
> }}}

Because it tries to convert -1 to a non-negative integer (I think when assigning it to `i`, which is defined to be of `size_t`). It fails then already and not in the next step.



---

archive/issue_comments_417918.json:
```json
{
    "body": "Can `def _meet_of_coatoms` use\n\n```\nif not all(i in range(n_coatoms) for i in indices):\n           raise IndexError(\"coatoms out of range\")\n```\n\nat the beginning to make the error message more consistent?",
    "created_at": "2021-05-19T22:37:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417918",
    "user": "@yuan-zhou"
}
```

Can `def _meet_of_coatoms` use

```
if not all(i in range(n_coatoms) for i in indices):
           raise IndexError("coatoms out of range")
```

at the beginning to make the error message more consistent?



---

archive/issue_comments_417919.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-19T23:06:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417919",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417920.json:
```json
{
    "body": "ok, changed",
    "created_at": "2021-05-19T23:06:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417920",
    "user": "@kliem"
}
```

ok, changed



---

archive/issue_comments_417921.json:
```json
{
    "body": "It's true that face is contained in the far face, but why does this cause an error?\n\n```\n+        elif not self._bounded and not self.coatoms.n_faces():\n+            # Note: It is important to catch this and not to run ``face_issubset`` to prevent a segmentation fault.\n+            if face_len_atoms(face):\n+                # Contained in the far face, if it contains anything.\n+                raise ValueError(\"the join is not well-defined\")\n```\n\nLet `P = Polyhedron(lines=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro))`, I expected to get the line itself for `P.join_of_Vrep(0)`, `P.join_of_Vrep(1)` and `P.join_of_Vrep(0, 1)`.\nI thought that the smallest face containing (A line in the direction (1, 1) and/or A vertex at (0, 0)) is well defined in this example.\n\nOne can compare the above example to the following, which runs as expected.\n\n```\nsage: P = Polyhedron(lines=[[1, 1]], rays=[(-1,1)])                                                        \nsage: P.Vrepresentation()                                                                                  \n(A line in the direction (1, 1),\n A ray in the direction (-1, 0),\n A vertex at (0, 0))\nsage: P.join_of_Vrep(2)                                                                                    \nA 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line\nsage: P.join_of_Vrep(0)                                                                                    \nA 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line\nsage: P.join_of_Vrep(0, 2)                                                                                 \nA 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line\nsage: P.join_of_Vrep(1, 2)                                                                                 \nA 2-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex, 1 ray, 1 line\n```\n",
    "created_at": "2021-05-20T00:09:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417921",
    "user": "@yuan-zhou"
}
```

It's true that face is contained in the far face, but why does this cause an error?

```
+        elif not self._bounded and not self.coatoms.n_faces():
+            # Note: It is important to catch this and not to run ``face_issubset`` to prevent a segmentation fault.
+            if face_len_atoms(face):
+                # Contained in the far face, if it contains anything.
+                raise ValueError("the join is not well-defined")
```

Let `P = Polyhedron(lines=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro))`, I expected to get the line itself for `P.join_of_Vrep(0)`, `P.join_of_Vrep(1)` and `P.join_of_Vrep(0, 1)`.
I thought that the smallest face containing (A line in the direction (1, 1) and/or A vertex at (0, 0)) is well defined in this example.

One can compare the above example to the following, which runs as expected.

```
sage: P = Polyhedron(lines=[[1, 1]], rays=[(-1,1)])                                                        
sage: P.Vrepresentation()                                                                                  
(A line in the direction (1, 1),
 A ray in the direction (-1, 0),
 A vertex at (0, 0))
sage: P.join_of_Vrep(2)                                                                                    
A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line
sage: P.join_of_Vrep(0)                                                                                    
A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line
sage: P.join_of_Vrep(0, 2)                                                                                 
A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line
sage: P.join_of_Vrep(1, 2)                                                                                 
A 2-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex, 1 ray, 1 line
```




---

archive/issue_comments_417922.json:
```json
{
    "body": "Replying to [comment:67 yzh]:\n> It's true that face is contained in the far face, but why does this cause an error?\n> {{{\n> +        elif not self._bounded and not self.coatoms.n_faces():\n> +            # Note: It is important to catch this and not to run ``face_issubset`` to prevent a segmentation fault.\n> +            if face_len_atoms(face):\n> +                # Contained in the far face, if it contains anything.\n> +                raise ValueError(\"the join is not well-defined\")\n> }}}\n> Let `P = Polyhedron(lines=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro))`, I expected to get the line itself for `P.join_of_Vrep(0)`, `P.join_of_Vrep(1)` and `P.join_of_Vrep(0, 1)`.\n> I thought that the smallest face containing (A line in the direction (1, 1) and/or A vertex at (0, 0)) is well defined in this example.\n> \n> One can compare the above example to the following, which runs as expected.\n> {{{\n> sage: P = Polyhedron(lines=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro), rays=[(-1,1)])                                                        \n> sage: P.Vrepresentation()                                                                                  \n> (A line in the direction (1, 1),\n>  A ray in the direction (-1, 0),\n>  A vertex at (0, 0))\n> sage: P.join_of_Vrep(2)                                                                                    \n> A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line\n> sage: P.join_of_Vrep(0)                                                                                    \n> A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line\n> sage: P.join_of_Vrep(0, 2)                                                                                 \n> A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line\n> sage: P.join_of_Vrep(1, 2)                                                                                 \n> A 2-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex, 1 ray, 1 line\n> }}}\n\nJust copying `self._far_face` properly takes care of this and the segmentation fault as well.",
    "created_at": "2021-05-20T07:16:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417922",
    "user": "@kliem"
}
```

Replying to [comment:67 yzh]:
> It's true that face is contained in the far face, but why does this cause an error?
> {{{
> +        elif not self._bounded and not self.coatoms.n_faces():
> +            # Note: It is important to catch this and not to run ``face_issubset`` to prevent a segmentation fault.
> +            if face_len_atoms(face):
> +                # Contained in the far face, if it contains anything.
> +                raise ValueError("the join is not well-defined")
> }}}
> Let `P = Polyhedron(lines=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro))`, I expected to get the line itself for `P.join_of_Vrep(0)`, `P.join_of_Vrep(1)` and `P.join_of_Vrep(0, 1)`.
> I thought that the smallest face containing (A line in the direction (1, 1) and/or A vertex at (0, 0)) is well defined in this example.
> 
> One can compare the above example to the following, which runs as expected.
> {{{
> sage: P = Polyhedron(lines=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro), rays=[(-1,1)])                                                        
> sage: P.Vrepresentation()                                                                                  
> (A line in the direction (1, 1),
>  A ray in the direction (-1, 0),
>  A vertex at (0, 0))
> sage: P.join_of_Vrep(2)                                                                                    
> A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line
> sage: P.join_of_Vrep(0)                                                                                    
> A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line
> sage: P.join_of_Vrep(0, 2)                                                                                 
> A 1-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex and 1 line
> sage: P.join_of_Vrep(1, 2)                                                                                 
> A 2-dimensional face of a Polyhedron in ZZ^2 defined as the convex hull of 1 vertex, 1 ray, 1 line
> }}}

Just copying `self._far_face` properly takes care of this and the segmentation fault as well.



---

archive/issue_comments_417923.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-20T07:17:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417923",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417924.json:
```json
{
    "body": "It's still not all correct in the corner cases.\n\n```\nsage: P = Polyhedron(vertices=[[1,0]], lines=[[1,1]])                                                      \nsage: P.Vrepresentation()                                                                                  \n(A line in the direction (1, 1), A vertex at (1, 0))\nsage: P.join_of_Vrep(0)                                                                                    \nA 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 line\n```\n\nand\n\n```\nsage: R = Polyhedron(vertices=[[1,0]], rays=[[1,1]])                                                       \nsage: R.Vrepresentation()                                                                                  \n(A vertex at (1, 0), A ray in the direction (1, 1))\nsage: R.join_of_Vrep(1)                                                                                    \nA 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray\n```\n\nExpected to have `ValueError: the join is not well-defined` for both.\n\nWith one more vertex, it's correct though:\n\n```\nsage: Q = Polyhedron(vertices=[[1,0], [0,1]], lines=[[1,1]])                                               \nsage: Q.Vrepresentation()                                                                                  \n(A line in the direction (1, 1), A vertex at (-1, 0), A vertex at (1, 0))\nsage: Q.join_of_Vrep(0)\nValueError: the join is not well-defined\n```\n",
    "created_at": "2021-05-21T03:24:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417924",
    "user": "@yuan-zhou"
}
```

It's still not all correct in the corner cases.

```
sage: P = Polyhedron(vertices=[[1,0]], lines=[[1,1]])                                                      
sage: P.Vrepresentation()                                                                                  
(A line in the direction (1, 1), A vertex at (1, 0))
sage: P.join_of_Vrep(0)                                                                                    
A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 line
```

and

```
sage: R = Polyhedron(vertices=[[1,0]], rays=[[1,1]])                                                       
sage: R.Vrepresentation()                                                                                  
(A vertex at (1, 0), A ray in the direction (1, 1))
sage: R.join_of_Vrep(1)                                                                                    
A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
```

Expected to have `ValueError: the join is not well-defined` for both.

With one more vertex, it's correct though:

```
sage: Q = Polyhedron(vertices=[[1,0], [0,1]], lines=[[1,1]])                                               
sage: Q.Vrepresentation()                                                                                  
(A line in the direction (1, 1), A vertex at (-1, 0), A vertex at (1, 0))
sage: Q.join_of_Vrep(0)
ValueError: the join is not well-defined
```




---

archive/issue_comments_417925.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-05-21T03:28:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417925",
    "user": "@yuan-zhou"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_417926.json:
```json
{
    "body": "Replying to [comment:72 yzh]:\n> It's still not all correct in the corner cases.\n> {{{\n> sage: P = Polyhedron(vertices=[This is the Trac macro *1,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,0-macro), lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                                      \n> sage: P.Vrepresentation()                                                                                  \n> (A line in the direction (1, 1), A vertex at (1, 0))\n> sage: P.join_of_Vrep(0)                                                                                    \n> A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 line\n> }}}\n> and\n> {{{\n> sage: R = Polyhedron(vertices=[This is the Trac macro *1,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,0-macro), rays=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                                       \n> sage: R.Vrepresentation()                                                                                  \n> (A vertex at (1, 0), A ray in the direction (1, 1))\n> sage: R.join_of_Vrep(1)                                                                                    \n> A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray\n> }}}\n> Expected to have `ValueError: the join is not well-defined` for both.\n> \n> With one more vertex, it's correct though:\n> {{{\n> sage: Q = Polyhedron(vertices=[[1,0], [0,1]], lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                               \n> sage: Q.Vrepresentation()                                                                                  \n> (A line in the direction (1, 1), A vertex at (-1, 0), A vertex at (1, 0))\n> sage: Q.join_of_Vrep(0)\n> ValueError: the join is not well-defined\n> }}}\n\nIt's consistent. Still one can argue about whether it should be changed.\n\nWhat you are proposing is the following: Given a bunch of indices. If there are in the far face, throw an error.\n\nCurrent behavior is the following (and I also wasn't aware of this, after all the ticket has been sitting there for a year): Given no indices, return the empty face. Otherwise, intersect all facets that contain all given indices. If that is contained in the far face, throw an error.\n\nIn the first of your cases, there is no facet. In the second case, the only facet does not contain the index. In the third case, both facets contain the line and thus the join is really not defined.\n\nA different example where currently everything works out is the following:\n\n\n```\nsage: P = Polyhedron(vertices=[[0,1],[1,0]], rays=[[0,1],[1,0]])                                                                                                                    \nsage: P.Vrepresentation()                                                                                                                                                           \n(A ray in the direction (0, 1),\n A vertex at (0, 1),\n A ray in the direction (1, 0),\n A vertex at (1, 0))\nsage: for i in range(4): \n....:     P.join_of_Vrep(i) \n....:                                                                                                                                                                               \nA 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray\nA 0-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex\nA 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray\nA 0-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex\n```\n\n\nThere is always exactly one face containing each ray. It even makes sense when you consider the lattice of the cone (or add the far face). The ray is of course a face of it's own there. However, there is a unique smallest face in the original polyhedron that contains it.\n\nI think the current behavior makes sense. You could give me a bunch of rays of a large polyhedron and ask me, what's the smallest face containing them. As long as this is well-defined, you can except to get an answer and not an error. It's like computing `gcd` and `lcm`. It tries to find an answer for you and only fails if those two numbers do not have a unique meet or join.",
    "created_at": "2021-05-21T06:05:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417926",
    "user": "@kliem"
}
```

Replying to [comment:72 yzh]:
> It's still not all correct in the corner cases.
> {{{
> sage: P = Polyhedron(vertices=[This is the Trac macro *1,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,0-macro), lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                                      
> sage: P.Vrepresentation()                                                                                  
> (A line in the direction (1, 1), A vertex at (1, 0))
> sage: P.join_of_Vrep(0)                                                                                    
> A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 line
> }}}
> and
> {{{
> sage: R = Polyhedron(vertices=[This is the Trac macro *1,0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,0-macro), rays=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                                       
> sage: R.Vrepresentation()                                                                                  
> (A vertex at (1, 0), A ray in the direction (1, 1))
> sage: R.join_of_Vrep(1)                                                                                    
> A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
> }}}
> Expected to have `ValueError: the join is not well-defined` for both.
> 
> With one more vertex, it's correct though:
> {{{
> sage: Q = Polyhedron(vertices=[[1,0], [0,1]], lines=[This is the Trac macro *1,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1-macro))                                               
> sage: Q.Vrepresentation()                                                                                  
> (A line in the direction (1, 1), A vertex at (-1, 0), A vertex at (1, 0))
> sage: Q.join_of_Vrep(0)
> ValueError: the join is not well-defined
> }}}

It's consistent. Still one can argue about whether it should be changed.

What you are proposing is the following: Given a bunch of indices. If there are in the far face, throw an error.

Current behavior is the following (and I also wasn't aware of this, after all the ticket has been sitting there for a year): Given no indices, return the empty face. Otherwise, intersect all facets that contain all given indices. If that is contained in the far face, throw an error.

In the first of your cases, there is no facet. In the second case, the only facet does not contain the index. In the third case, both facets contain the line and thus the join is really not defined.

A different example where currently everything works out is the following:


```
sage: P = Polyhedron(vertices=[[0,1],[1,0]], rays=[[0,1],[1,0]])                                                                                                                    
sage: P.Vrepresentation()                                                                                                                                                           
(A ray in the direction (0, 1),
 A vertex at (0, 1),
 A ray in the direction (1, 0),
 A vertex at (1, 0))
sage: for i in range(4): 
....:     P.join_of_Vrep(i) 
....:                                                                                                                                                                               
A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
A 0-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex
A 1-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
A 0-dimensional face of a Polyhedron in QQ^2 defined as the convex hull of 1 vertex
```


There is always exactly one face containing each ray. It even makes sense when you consider the lattice of the cone (or add the far face). The ray is of course a face of it's own there. However, there is a unique smallest face in the original polyhedron that contains it.

I think the current behavior makes sense. You could give me a bunch of rays of a large polyhedron and ask me, what's the smallest face containing them. As long as this is well-defined, you can except to get an answer and not an error. It's like computing `gcd` and `lcm`. It tries to find an answer for you and only fails if those two numbers do not have a unique meet or join.



---

archive/issue_comments_417927.json:
```json
{
    "body": "Actually, I'm not considering combinatorial polyhedra, far face, etc. at all. Instead, I'm looking from a geometric point of view. \n\nIn the examples above, I see \"A line in the direction (1, 1)\" as `l = Polyhedron(lines=[(1,1)])`, and \"A ray in the direction (1, 1)\" as `r = Polyhedron(rays=[(1,1)])`. Recall that for a geometric polyhedron (of `Polyhedron_base` class), it is a face of itself, and the empty polyhedron is also a face. \n\nNone of the faces of `P` (including itself) contains `l`. Similarly, none of the faces of `Q` (including itself) contains `r`. Thus, I expect an error in the first two examples.\n\nNone of the faces of `Q` contains `l`. Therefore, the third example returns an error.",
    "created_at": "2021-05-21T07:00:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417927",
    "user": "@yuan-zhou"
}
```

Actually, I'm not considering combinatorial polyhedra, far face, etc. at all. Instead, I'm looking from a geometric point of view. 

In the examples above, I see "A line in the direction (1, 1)" as `l = Polyhedron(lines=[(1,1)])`, and "A ray in the direction (1, 1)" as `r = Polyhedron(rays=[(1,1)])`. Recall that for a geometric polyhedron (of `Polyhedron_base` class), it is a face of itself, and the empty polyhedron is also a face. 

None of the faces of `P` (including itself) contains `l`. Similarly, none of the faces of `Q` (including itself) contains `r`. Thus, I expect an error in the first two examples.

None of the faces of `Q` contains `l`. Therefore, the third example returns an error.



---

archive/issue_comments_417928.json:
```json
{
    "body": "I don't think one should see \"A line in the direction (1, 1)\" as `l = Polyhedron(lines=[(1,1)])`, because whenever you don't specify vertices, but rays or lines, then the vertex `(0,0)` is added. \n\n`P` contains the line and not `l`, because `l` is the line and the vertex `(0,0)`.\n\nNo, the third example returns an error, because both edges of `Q` contain the line, but not a vertex. So it is not well-defined.\n\nEdit: Maybe rather say 1-faces instead of edges. There are two 1-faces of `Q` that contain the lines, but no 0-face of `Q` contains the line.",
    "created_at": "2021-05-21T07:18:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417928",
    "user": "@kliem"
}
```

I don't think one should see "A line in the direction (1, 1)" as `l = Polyhedron(lines=[(1,1)])`, because whenever you don't specify vertices, but rays or lines, then the vertex `(0,0)` is added. 

`P` contains the line and not `l`, because `l` is the line and the vertex `(0,0)`.

No, the third example returns an error, because both edges of `Q` contain the line, but not a vertex. So it is not well-defined.

Edit: Maybe rather say 1-faces instead of edges. There are two 1-faces of `Q` that contain the lines, but no 0-face of `Q` contains the line.



---

archive/issue_comments_417929.json:
```json
{
    "body": "Replying to [comment:76 gh-kliem]:\n> I don't think one should see \"A line in the direction (1, 1)\" as `l = Polyhedron(lines=[(1,1)])`\n\nAha! That explains everything.",
    "created_at": "2021-05-21T07:30:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417929",
    "user": "@yuan-zhou"
}
```

Replying to [comment:76 gh-kliem]:
> I don't think one should see "A line in the direction (1, 1)" as `l = Polyhedron(lines=[(1,1)])`

Aha! That explains everything.



---

archive/issue_comments_417930.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2021-05-21T07:30:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417930",
    "user": "@yuan-zhou"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_417931.json:
```json
{
    "body": "Thank you.\n\nThat part with the implicit vertex is super confusing...",
    "created_at": "2021-05-21T07:31:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417931",
    "user": "@kliem"
}
```

Thank you.

That part with the implicit vertex is super confusing...



---

archive/issue_comments_417932.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2021-06-08T07:51:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417932",
    "user": "@kliem"
}
```

Last 10 new commits:



---

archive/issue_comments_417933.json:
```json
{
    "body": "Rebased on new version of #31834, which fixes trivial merge conflict because of whitespaces.",
    "created_at": "2021-06-08T07:52:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417933",
    "user": "@kliem"
}
```

Rebased on new version of #31834, which fixes trivial merge conflict because of whitespaces.



---

archive/issue_comments_417934.json:
```json
{
    "body": "Only merged and rebased on #31834.\n----\nLast 10 new commits:",
    "created_at": "2021-06-19T23:28:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417934",
    "user": "@kliem"
}
```

Only merged and rebased on #31834.
----
Last 10 new commits:



---

archive/issue_comments_417935.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2021-06-23T00:53:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417935",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_417936.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2021-06-23T00:53:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417936",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_417937.json:
```json
{
    "body": "easy merge of updated #31834",
    "created_at": "2021-06-23T00:53:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417937",
    "user": "@mkoeppe"
}
```

easy merge of updated #31834



---

archive/issue_comments_417938.json:
```json
{
    "body": "Back to positive review. LGTM too.",
    "created_at": "2021-06-23T01:18:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417938",
    "user": "@mkoeppe"
}
```

Back to positive review. LGTM too.



---

archive/issue_comments_417939.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-06-23T01:18:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417939",
    "user": "@mkoeppe"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_417940.json:
```json
{
    "body": "Thank you.",
    "created_at": "2021-06-23T11:35:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417940",
    "user": "@kliem"
}
```

Thank you.



---

archive/issue_comments_417941.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-07-01T20:45:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29446",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29446#issuecomment-417941",
    "user": "@vbraun"
}
```

Resolution: fixed
