# Issue 11860: Symbolics code passes ungrammatical expressions to maxima

Issue created by migration from Trac.

Original creator: nbruin

Original creation time: 2011-11-14 18:55:43

Assignee: burcin

Eviatar reports [sage-devel thread](http://groups.google.com/group/sage-devel/browse_thread/thread/cb0a45d48756bf71):

```
sage: find_maximum_on_interval(-x^2 + 9*x, 4.4, 8)
RuntimeError: ECL says: THROW: The catch MACSYMA-QUIT is undefined.
```

A little investigation with `pdb.pm()` shows that the error occurs in [sage.interfaces.maxima_lib line 420](http://hg.sagemath.org/sage-main/file/9e29a3d84c48/sage/interfaces/maxima_lib.py#l420)

```
if statement: result = ((result + '\n') if result else '') + max_to_string(maxima_eval("#$%s$"%statement))
```

where `statement` has the value

```
'is (-20.247454751128636=-20.249999999999996<=-20.199549540424666)'
```

which is not a valid Maxima expression. The real error is in the code that causes this to happen.

The function [maxima_eval](http://hg.sagemath.org/sage-main/file/9e29a3d84c48/sage/interfaces/maxima_lib.py#l160) is an ECL function, so its parameter gets converted by ECL-lib, outside maxima_lib's control. The string contains a `#$...$` reader-macro, which causes the maxima-parser to handle the string. It finds the syntax error and signals it by throwing an uncaught "catch".

Invoking maxima_eval this way isn't particularly wrong, but one should ensure that the expression passed in is at least syntactically correct. If an error condition arises when *evaluating* the expression using `maxima_eval`, errors are caught more gracefully.

Digging a little deeper shows that `find_maximum` should not be called with symbolic arguments, so this particular error could be caught earlier. However, I think the symptom shows that the symbolics code should vet its expression a little better before passing it to maxima: The expression isn't accepted by maxima as grammatical.


---

Comment by nbruin created at 2012-04-09 06:19:09

This bug was rediscovered in [this sage-devel thread](http://groups.google.com/group/sage-devel/browse_thread/thread/3247c3881c8db6f4?hl=en). A little further debugging uncovered some further details there:

```
Yes, that's a bug. Something goes wrong in what gets fed to the
function:

def f(z):
    v = sin(x)(x=z)
    print "evaluating sin(%s)=%s"%(z,v)
    return vsage: find_maximum_on_interval(f,0,2)
evaluating sin(0.7639320225)=0.691766183638
evaluating sin(1.2360679775)=0.944499585162
evaluating sin(1.527864045)=0.999078551136
evaluating sin(1.59062900282 == 1.58711797464)=sin(1.59062900282 ==
1.58711797464)

As you see, for some reason the evaluation point becomes an equality
relation. From that point it is of course just a question *which*
piece of code throws an error.

These routines use scipy.optimize.fminbound. This doesn't act too
nicely with the SymbolicRing. In the source, we find the following
lines:

...
                    si = numpy.sign(xm-xf) + ((xm-xf)==0)
...
        si = numpy.sign(rat) + (rat == 0)
        x = xf + si*max([abs(rat), tol1])
...

 What they need is:

....
        si = numpy.sign(xm-xf)
        if si == 0:
            si = 1
...
    si = numpy.sign(rat)
    if si == 0:
       si = 1
    x = xf + si*max([abs(rat), tol1])
...

Their assumption that numpy.sign(rat) == 0 iff (rat == 0) evaluates to
1 and that (rat == 0) evaluates to 0 otherwise is not unreasonable in
their world. The above code is of course a little more robust, but I
doubt scipy is willing to change it just because sage's SR acts funny.
So the fix: sage should interface a little more carefully with scipy
and take care no SR objects leak into it. 

The problem comes from the fact that the symbolic ring is
quite conservative in deciding whether floats are equal to zero and
has the habit of returning something that is not readily 0 or 1:

sage: 1.1 == 0
False
sage: SR(1.1) == 0
1.10000000000000 == 0

So at the least, the sage interface prepares input to scipy that
doesn't behave as scipy expects. It may also be that the scipy
implementation is suspect.

The nasty error comes from the fact that the syntactically invalid
expression sin(1.59062900282 == 1.58711797464) doesn't get rejected
upon construction.
```

