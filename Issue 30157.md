# Issue 30157: Graphs: added antipodal check and folding of graphs

Issue created by migration from https://trac.sagemath.org/ticket/30394

Original creator: @Ivo-Maffei

Original creation time: 2020-08-19 16:28:05

CC:  dimpase

Added a method to check whether an undirected graph is antipodal and a method to compute the antipodal folding of an undirected graph


---

Comment by @Ivo-Maffei created at 2020-08-19 16:28:57

New commits:


---

Comment by @Ivo-Maffei created at 2020-08-19 16:28:57

Changing status from new to needs_review.


---

Comment by dcoudert created at 2020-08-20 08:33:35

check simple cases: 0 or 1 vertex, not connected

in folded graphs, it would be nice to have a way to check if the input is antipodal, either calling `is_antipodal`, or using appropriate tests during the construction (if any).

Concerning the construction of the antipodal graph, I have an idea of a better/faster solution than what you propose. I will do some tests and come back to you.


---

Comment by dcoudert created at 2020-08-20 08:53:59

also, the current construction for antipodal graphs, `G = self.distance_graph(self.diameter())`, contains all the vertices of `G`. Is it correct according the definition of antipodal graphs ?


---

Comment by dcoudert created at 2020-08-20 09:21:28

The idea to build the antipodal graph is the following (adding only the vertices involved in an antipodal pair):

```
def antipodal_graph(G):
    """
    Return the antipodal graph of ``G``.
    """
    ecc = G.eccentricity(algorithm="DHV", with_labels=True)
    diam = max(ecc.values())
    # Get the list of antipodal vertices, i.e., with eccentricity = diameter
    V = [u for u, ecc_u in ecc.items() if ecc_u == diam]

    E = set()
    for u in V:
        for v, d in G.breadth_first_search(u, report_distance=True):
            if d == diam:
                E.add(frozenset((u, v)))

    name = f"antipodal graph of {G.name()}"
    return Graph([V, E], format='vertices_and_edges', name=name)
```

It is interesting for large graphs (e.g., >= 1000 nodes), and significant speed up can be obtained using Cython.
Also, the space complexity is in `O(n)`, while the current method has space complexity in `O(n^2)`.

The main idea is to:
- first compute the eccentricity of the vertices. The DHV algorithm is fast in practice and usually compute distances from a few vertices.
- Then, for each vertex with eccentricity = diameter, we search for the antipodal pairs.

It can be done quickly on large graphs. But of course it is not interesting for graphs like `JohnsonGraph(10, 5)`.

This can be done in another ticket. It requires some care to get a fast implementation.


---

Comment by @Ivo-Maffei created at 2020-08-20 10:11:53

Replying to [comment:4 dcoudert]:
> also, the current construction for antipodal graphs, `G = self.distance_graph(self.diameter())`, contains all the vertices of `G`. Is it correct according the definition of antipodal graphs ?
Probably depends on your definition of antipodal graph. The definition I believe to be the most common is:
Given a graph G, the antipodal graph of G, denoted by A(G), has the same vertex set of G and two vertices are adjacent if their distance in G is equal to the diameter of G. If G is disconnected we define its diameter to be (plus) infinity.

If you know any other definition that ends up being more useful in some scenarios, then let me know.

However, note that I never call `G = self.distance_graph(self.diameter())` the antipodal graph of `self`, but only the distance-d graph.

The current implementations are rather slow so if your proposal is actually faster is very appreciated. However, I don't think your proposal computes the same graph as the straightforward `self.distance_graph(self.diameter())` since some vertices can be left out.

I'll fix your review comments, try speed things up and get back to you.


---

Comment by dcoudert created at 2020-08-20 10:14:55

to get the same vertex set, it suffices to use `Graph([G, E], ...)`.


---

Comment by git created at 2020-08-20 12:04:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Ivo-Maffei created at 2020-08-20 12:11:51

A few things:

I can't think of any disconnected antipodal graph to check what `folded_graph` would do.
At the moment `folded_graph` and `is_antipodal` raise a `ValueError` when the graph is empty as "its diameter is undefined".
I personally don't like this, and I would set `is_antipodal` to True and the `folded_graph` would be empty, but this might be unnatural.

I tried your implementation of `antipodal_graph` in a cython file (sage\graphs\generators\distance_regular.pyx) and it seems very slow (not sure why). So I wrote another `antipodal_graph` method which is pretty straight-forward and tested them a bit on a large graph


```sage
sage: from sage.graphs.generators.distance_regular import antipodal_graph1, antipodal_graph2                                                                                                                                                  
sage: G = graphs.JohnsonGraph(14, 7)                                                                                                                                                                                                          
sage: G                                                                                                                                                                                                                                       
Johnson graph with parameters 14,7: Graph on 3432 vertices
sage: %timeit antipodal_graph1(G)                                                                                                                                                                                                             
29.3 s ± 814 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %time antipodal_graph2(G)
# don't know; stopped after > 3 min
```


I don't think the filtering `V = [u for u, ecc_u in ecc.items() if ecc_u == diam]` is any good in this scenario as all eccentricities are equal to the diameter 7.

Unless you spot some obvious mistake I did, I think I'll open another ticket to get a fast implementation of `antipodal_graph`.


---

Comment by dcoudert created at 2020-08-20 13:05:12

Your implementation of `antipodal_graph2` is less efficient than mine. Indeed, you compute BFS from all vertices, while my proposal is to compute BFS only from vertices with eccentricity the diameter.
Of course, in a graph like the `JohnsonGraph` where all vertices have for eccentricity the diameter, my method will be slower than the basic method. But if you try on a 2D grid graph, the proposed method should be way faster. In such graph, the DHV algorithm will compute all eccentricities with about 8 BFS, and then you have to compute BFS from only 4 vertices to get the result.
This is related to a research project I'm currently working on, and that can be used to enumerate (antipodal) pairs quickly and using few memory.


A separate ticket is much better. I don't have time yet to work on it and will ask Vipul Gupta to help.

Roughly, to be efficient, it must be implemented using `short_digraph` (see `distances_all_pairs.pyx`), and call low level methods. However, I realize that we have several improvement to do before in `distances_all_pairs.pyx` to avoid extra conversions from one format to the other (not difficult).


---

Comment by git created at 2020-08-20 13:30:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-20 14:05:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-08-22 08:22:28

let us limit this ticket to the distance regular case, and deal with a general case on another ticket.


---

Comment by git created at 2020-08-22 10:40:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-08-22 10:43:16

I pushed minor corrections. In particular, for the mapping int -> cliques, we can simply use a list.


---

Comment by dcoudert created at 2020-08-22 10:43:55

LGTM.


---

Comment by dcoudert created at 2020-08-22 10:43:55

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-08-23 22:23:55

Merge conflict


---

Comment by vbraun created at 2020-08-23 22:23:55

Changing status from positive_review to needs_work.


---

Comment by git created at 2020-08-24 09:42:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Ivo-Maffei created at 2020-08-24 09:44:08

Nothing major, just a conflict with #30355


---

Comment by @Ivo-Maffei created at 2020-08-24 09:44:08

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2020-08-30 08:38:50

Resolution: fixed
