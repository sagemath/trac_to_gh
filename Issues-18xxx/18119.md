# Issue 18119: New methods for WordMorphism

archive/issues_017882.json:
```json
{
    "body": "Assignee: @mrejmon\n\nCC:  @seblabbe @videlec tmonteil @staroste\n\nKeywords: sd66\n\nAdd the following methods to the `WordMorphism` class:\n\n- `is_injective()` - injectivity test\n- `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word\n- `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)\n- `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n- `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n- `simplify_alphabet_size()` - returns a simplification of the morphism\n- `simplify_until_injective()` - repeateadly calls simplify_alphabet_size() until the result is injective\n\nAlso adds the following method to the `FiniteWord_class`:\n\n- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word\n\nIssue created by migration from https://trac.sagemath.org/ticket/18119\n\n",
    "closed_at": "2021-06-29T17:39:47Z",
    "created_at": "2015-04-03T10:15:53Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.4",
    "title": "New methods for WordMorphism",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18119",
    "user": "https://github.com/staroste"
}
```
Assignee: @mrejmon

CC:  @seblabbe @videlec tmonteil @staroste

Keywords: sd66

Add the following methods to the `WordMorphism` class:

- `is_injective()` - injectivity test
- `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word
- `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)
- `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions
- `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism
- `simplify_alphabet_size()` - returns a simplification of the morphism
- `simplify_until_injective()` - repeateadly calls simplify_alphabet_size() until the result is injective

Also adds the following method to the `FiniteWord_class`:

- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word

Issue created by migration from https://trac.sagemath.org/ticket/18119





---

archive/issue_comments_239623.json:
```json
{
    "body": "Set assignee to @staroste.",
    "created_at": "2015-04-03T10:16:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239623",
    "user": "https://github.com/staroste"
}
```

Set assignee to @staroste.



---

archive/issue_comments_239624.json:
```json
{
    "body": "Changing assignee from @staroste to @mrejmon.",
    "created_at": "2021-03-15T21:39:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239624",
    "user": "https://github.com/staroste"
}
```

Changing assignee from @staroste to @mrejmon.



---

archive/issue_events_051340.json:
```json
{
    "actor": "https://github.com/mrejmon",
    "created_at": "2021-03-30T12:49:19Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18119#event-51340"
}
```



---

archive/issue_comments_239625.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-03-30T12:49:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239625",
    "user": "https://github.com/mrejmon"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_239626.json:
```json
{
    "body": "Hello,\n\nthe pushed branch contains an implementation of the algorithm from the following paper [An algorithm for enumerating all infinite repetitions in a D0L-system](https://www.sciencedirect.com/science/article/pii/S1570866715000490), using which it is easy to answer the `is_pushy` and `is_unboundedly_repetitive` queries. It also includes a version of the [Sardinas-Patterson algorithm](https://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm) to answer `is_injective`.\n\nWhile implementing the above I also added a method for simplifying non-injective morphisms and a method for finding the minimal conjugate of a finite word.\n\n---\nNew commits:",
    "created_at": "2021-03-30T12:49:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239626",
    "user": "https://github.com/mrejmon"
}
```

Hello,

the pushed branch contains an implementation of the algorithm from the following paper [An algorithm for enumerating all infinite repetitions in a D0L-system](https://www.sciencedirect.com/science/article/pii/S1570866715000490), using which it is easy to answer the `is_pushy` and `is_unboundedly_repetitive` queries. It also includes a version of the [Sardinas-Patterson algorithm](https://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm) to answer `is_injective`.

While implementing the above I also added a method for simplifying non-injective morphisms and a method for finding the minimal conjugate of a finite word.

---
New commits:



---

archive/issue_comments_239627.json:
```json
{
    "body": "I looked at the code. Here are few comments:\n\n1 - I would suggest to move the import of `chain`, `count` and `Counter` directly inside the method where they are used (except if they are imported in lots of distinct methods).\n\n```diff\n-from itertools import chain\n+from collections import Counter\n+from itertools import chain, count\n```\n\n2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\\{m^n(w) | n \\ge 0\\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?\n\nEvery method saying \"should be an endomorphism\" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.\n\nWhat is the typical case you have in mind?\n\n```diff\n+        Return whether the language `\\{m^n(w) | n \\ge 0\\}` is pushy,\n+        where `m` is this morphism and `w` is a word inputted as a parameter.\n+\n+        Requires this morphism to be an endomorphism.\n```",
    "created_at": "2021-04-02T07:39:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239627",
    "user": "https://github.com/seblabbe"
}
```

I looked at the code. Here are few comments:

1 - I would suggest to move the import of `chain`, `count` and `Counter` directly inside the method where they are used (except if they are imported in lots of distinct methods).

```diff
-from itertools import chain
+from collections import Counter
+from itertools import chain, count
```

2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\{m^n(w) | n \ge 0\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?

Every method saying "should be an endomorphism" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.

What is the typical case you have in mind?

```diff
+        Return whether the language `\{m^n(w) | n \ge 0\}` is pushy,
+        where `m` is this morphism and `w` is a word inputted as a parameter.
+
+        Requires this morphism to be an endomorphism.
```



---

archive/issue_comments_239628.json:
```json
{
    "body": "Replying to [comment:5 slabbe]:\n> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\\{m^n(w) | n \\ge 0\\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?\n> \n\n\n`\\{m^n(w) | n \\ge 0\\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.\nAs you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?\n\n\n> Every method saying \"should be an endomorphism\" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.\n\n\nI am unsure what would be the right object at this point. In the more general settings, all are properties of a D0L-system. Do we want to have a class for it?\n\nI think there are many general methods that require an endomorphism, and there is no special class for them, is there?\n\n> \n> What is the typical case you have in mind?\n> \n> \n> ```\n> #!diff\n> +        Return whether the language `\\{m^n(w) | n \\ge 0\\}` is pushy,\n> +        where `m` is this morphism and `w` is a word inputted as a parameter.\n> +\n> +        Requires this morphism to be an endomorphism.\n> ```\n\n\nI think there should be the factorial closure of `\\{m^n(w) | n \\ge 0\\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).\nTaking `w` a letter, it is a property of a morphic word, or more precisely, its language.\nWhat do you mean by typical usage? Knowing whether a system/morphism is pushy is an ingredient to decide whether it is circular.",
    "created_at": "2021-04-07T09:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239628",
    "user": "https://github.com/staroste"
}
```

Replying to [comment:5 slabbe]:
> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\{m^n(w) | n \ge 0\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?
> 


`\{m^n(w) | n \ge 0\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.
As you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?


> Every method saying "should be an endomorphism" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.


I am unsure what would be the right object at this point. In the more general settings, all are properties of a D0L-system. Do we want to have a class for it?

I think there are many general methods that require an endomorphism, and there is no special class for them, is there?

> 
> What is the typical case you have in mind?
> 
> 
> ```
> #!diff
> +        Return whether the language `\{m^n(w) | n \ge 0\}` is pushy,
> +        where `m` is this morphism and `w` is a word inputted as a parameter.
> +
> +        Requires this morphism to be an endomorphism.
> ```


I think there should be the factorial closure of `\{m^n(w) | n \ge 0\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).
Taking `w` a letter, it is a property of a morphic word, or more precisely, its language.
What do you mean by typical usage? Knowing whether a system/morphism is pushy is an ingredient to decide whether it is circular.



---

archive/issue_comments_239629.json:
```json
{
    "body": "I did a small commit to move the itertools import inside the method.\n\n(I did not touch the import of chain which would create a conflict with #31378)\n\n---\nNew commits:",
    "created_at": "2021-04-08T10:00:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239629",
    "user": "https://github.com/seblabbe"
}
```

I did a small commit to move the itertools import inside the method.

(I did not touch the import of chain which would create a conflict with #31378)

---
New commits:



---

archive/issue_comments_239630.json:
```json
{
    "body": "Replying to [comment:6 sstarosta]:\n> Replying to [comment:5 slabbe]:\n> > 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\\{m^n(w) | n \\ge 0\\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?\n> > \n\n> \n> `\\{m^n(w) | n \\ge 0\\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.\n> As you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?\n\n>\n\nNo, for these methods there isn't. I mostly only added the `w` argument since it seemed to make the docs cleaner to me, that is \"`w` is a word inputted as a parameter\" instead of \"`w` is an arbitrary word containing at least one of each letter from the alphabet of the domain of this morphism\" or similar.\n\n> ...\n> > ...\n\n> ...\n> > \n> > \n> > ```\n> > #!diff\n> > +        Return whether the language `\\{m^n(w) | n \\ge 0\\}` is pushy,\n> > +        where `m` is this morphism and `w` is a word inputted as a parameter.\n> > +\n> > +        Requires this morphism to be an endomorphism.\n> > ```\n\n> \n> I think there should be the factorial closure of `\\{m^n(w) | n \\ge 0\\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).\n\n>\n\nThe factors are mentioned in the paragraph right below that:\n\n```\n        A language created by iterating a morphism is pushy if its words\n        contain an infinite number of factors containing no growing letters. It\n        turns out that this is equivalent to having at least one infinite\n        repetition containing no growing letters.\n```\n\nWould you still prefer to mention them also in the first sentence in the docs?\n\nReplying to [comment:7 slabbe]:\n> I did a small commit to move the itertools import inside the method.\n> \n> (I did not touch the import of chain which would create a conflict with #31378)\n\n>\n\nThanks! Sorry for the long delay before answering, thankfully \u0160t\u011bp\u00e1n already responded to your second comment. I also added a commit adding a test and slightly refactoring one method.\n\n---\nNew commits:",
    "created_at": "2021-04-08T19:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239630",
    "user": "https://github.com/mrejmon"
}
```

Replying to [comment:6 sstarosta]:
> Replying to [comment:5 slabbe]:
> > 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\{m^n(w) | n \ge 0\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?
> > 

> 
> `\{m^n(w) | n \ge 0\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.
> As you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?

>

No, for these methods there isn't. I mostly only added the `w` argument since it seemed to make the docs cleaner to me, that is "`w` is a word inputted as a parameter" instead of "`w` is an arbitrary word containing at least one of each letter from the alphabet of the domain of this morphism" or similar.

> ...
> > ...

> ...
> > 
> > 
> > ```
> > #!diff
> > +        Return whether the language `\{m^n(w) | n \ge 0\}` is pushy,
> > +        where `m` is this morphism and `w` is a word inputted as a parameter.
> > +
> > +        Requires this morphism to be an endomorphism.
> > ```

> 
> I think there should be the factorial closure of `\{m^n(w) | n \ge 0\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).

>

The factors are mentioned in the paragraph right below that:

```
        A language created by iterating a morphism is pushy if its words
        contain an infinite number of factors containing no growing letters. It
        turns out that this is equivalent to having at least one infinite
        repetition containing no growing letters.
```

Would you still prefer to mention them also in the first sentence in the docs?

Replying to [comment:7 slabbe]:
> I did a small commit to move the itertools import inside the method.
> 
> (I did not touch the import of chain which would create a conflict with #31378)

>

Thanks! Sorry for the long delay before answering, thankfully Štěpán already responded to your second comment. I also added a commit adding a test and slightly refactoring one method.

---
New commits:



---

archive/issue_comments_239631.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-09T19:42:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239631",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239632.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-22T11:33:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239632",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239633.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-22T11:39:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239633",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239634.json:
```json
{
    "body": "Replying to [comment:5 slabbe]:\n> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class.\n\n\nI just wanted to reply to myself here. While I still think some of the methods added here could go in another class (LanguageMorphicWord for instance), I do not want to uphold this ticket. I am not contributing at a high frequency right now, so I prefer adding those methods in SageMath as proposed and, later, if we want to move them elsewhere, it is never too late. Continue your good work.",
    "created_at": "2021-04-22T11:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239634",
    "user": "https://github.com/seblabbe"
}
```

Replying to [comment:5 slabbe]:
> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class.


I just wanted to reply to myself here. While I still think some of the methods added here could go in another class (LanguageMorphicWord for instance), I do not want to uphold this ticket. I am not contributing at a high frequency right now, so I prefer adding those methods in SageMath as proposed and, later, if we want to move them elsewhere, it is never too late. Continue your good work.



---

archive/issue_comments_239635.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-04T19:38:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239635",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239636.json:
```json
{
    "body": "I see that few more methods are added in this ticket:\n\n```\n+    def is_injective(self):\n+    def is_pushy(self, w=None):\n+    def is_unboundedly_repetitive(self, w=None):\n+    def is_repetitive(self, w=None):\n+    def infinite_repetitions(self, w=None):\n+    def infinite_repetitions_bounded(self, w=None):\n+    def infinite_repetitions_growing(self, w=None):\n+    def reach(self, w):\n+    def simplify(self, Z=None):\n+    def simplify_injective(self):\n```\n\nWould it be possible to update the description of the ticket with this complete list?",
    "created_at": "2021-05-20T10:11:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239636",
    "user": "https://github.com/seblabbe"
}
```

I see that few more methods are added in this ticket:

```
+    def is_injective(self):
+    def is_pushy(self, w=None):
+    def is_unboundedly_repetitive(self, w=None):
+    def is_repetitive(self, w=None):
+    def infinite_repetitions(self, w=None):
+    def infinite_repetitions_bounded(self, w=None):
+    def infinite_repetitions_growing(self, w=None):
+    def reach(self, w):
+    def simplify(self, Z=None):
+    def simplify_injective(self):
```

Would it be possible to update the description of the ticket with this complete list?



---

archive/issue_comments_239637.json:
```json
{
    "body": "In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.",
    "created_at": "2021-05-20T10:13:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239637",
    "user": "https://github.com/seblabbe"
}
```

In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.



---

archive/issue_comments_239638.json:
```json
{
    "body": "Replying to [comment:16 slabbe]:\n> In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.\n\n\nThe term simplification is used by A. Ehrenfeucht and G. Rozenberg, and maybe earlier. I'd prefer to keep it unless we find a much better name (I can't think of anything simple).\nI don't know about reach, Martin?",
    "created_at": "2021-05-20T10:20:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239638",
    "user": "https://github.com/staroste"
}
```

Replying to [comment:16 slabbe]:
> In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.


The term simplification is used by A. Ehrenfeucht and G. Rozenberg, and maybe earlier. I'd prefer to keep it unless we find a much better name (I can't think of anything simple).
I don't know about reach, Martin?



---

archive/issue_comments_239639.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-21T09:23:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239639",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239640.json:
```json
{
    "body": "I \"solved\" the `reach` naming problem by replacing it with calls to `_language_naive`.",
    "created_at": "2021-05-21T09:25:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239640",
    "user": "https://github.com/mrejmon"
}
```

I "solved" the `reach` naming problem by replacing it with calls to `_language_naive`.



---

archive/issue_comments_239641.json:
```json
{
    "body": "Thank you, the updated description helps me to have an easier overview of what it added.\n\nI have few suggestions about the name of the methods. See below. It is important to choose them well, because they are harder to change once in sage because of backward compatibility.\n\nReplying to new description:\n> Add the following methods to the `WordMorphism` class:\n> \n> - `is_injective()` - injectivity test\n\n\nokay\n\n> - `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word\n\n\nokay\n\n> - `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)\n\n\nokay\n\n> - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n\n\nokay\n\n> - `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n\n\nI rather suggest `infinite_repetitions_primitive_roots()`. Explicit is better and implicit. See `import this` in Python:)\n\n> - `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters\n> - `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter\n\n\nI would suggest to rename those two methods as hidden methods `_infinite_repetitions_bounded()` and `_infinite_repetitions_growing()`. Then, I would suggest to access those methods from the method `infinite_repetitions()` as follows:\n\n- `infinite_repetitions(growing_letters=None)`, the default\n- `infinite_repetitions(growing_letters=True)`, only those words which contain at least one growing letter\n- `infinite_repetitions(growing_letters=False)`, only those words which contain no growing letters\n\nOf course, you will need to also add documentation about this new argument `growing_letters`.\n\n> - `simplify()` - returns a simplification of the morphism\n\n\nI would suggest to rename it to `simplify_alphabet_size()`, because this is really what this methods wants to do: reduce the size of the alphabet while doing essentially the same thing.\n\n> - `simplify_injective()` - repeateadly calls simplify() until the result is injective\n\n\nI suggest to rename it to `simplify_to_injective()` or even better `simplify_until_injective()` since the word `until` gives an hint about the procedure. Otherwise we don't know whether `injective` is a description of the input or the output. Here, it describes the output.\n\nReview done during the Sage Thursdays in Bordeaux at https://wiki.sagemath.org/thursdaysbdx.",
    "created_at": "2021-05-27T09:44:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239641",
    "user": "https://github.com/seblabbe"
}
```

Thank you, the updated description helps me to have an easier overview of what it added.

I have few suggestions about the name of the methods. See below. It is important to choose them well, because they are harder to change once in sage because of backward compatibility.

Replying to new description:
> Add the following methods to the `WordMorphism` class:
> 
> - `is_injective()` - injectivity test


okay

> - `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word


okay

> - `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)


okay

> - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions


okay

> - `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism


I rather suggest `infinite_repetitions_primitive_roots()`. Explicit is better and implicit. See `import this` in Python:)

> - `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters
> - `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter


I would suggest to rename those two methods as hidden methods `_infinite_repetitions_bounded()` and `_infinite_repetitions_growing()`. Then, I would suggest to access those methods from the method `infinite_repetitions()` as follows:

- `infinite_repetitions(growing_letters=None)`, the default
- `infinite_repetitions(growing_letters=True)`, only those words which contain at least one growing letter
- `infinite_repetitions(growing_letters=False)`, only those words which contain no growing letters

Of course, you will need to also add documentation about this new argument `growing_letters`.

> - `simplify()` - returns a simplification of the morphism


I would suggest to rename it to `simplify_alphabet_size()`, because this is really what this methods wants to do: reduce the size of the alphabet while doing essentially the same thing.

> - `simplify_injective()` - repeateadly calls simplify() until the result is injective


I suggest to rename it to `simplify_to_injective()` or even better `simplify_until_injective()` since the word `until` gives an hint about the procedure. Otherwise we don't know whether `injective` is a description of the input or the output. Here, it describes the output.

Review done during the Sage Thursdays in Bordeaux at https://wiki.sagemath.org/thursdaysbdx.



---

archive/issue_comments_239642.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-05-27T09:44:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239642",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_239643.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-29T10:51:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239643",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239644.json:
```json
{
    "body": "Thank you for the suggestions. I implemented all of them, except I named the parameter `allow_growing` instead of `growing_letters` and instead of hiding the `infinite_repetitions_*` methods I merged them into `infinite_repetitions_primitive_roots`, to remove some redundant code and docs.",
    "created_at": "2021-05-29T10:59:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239644",
    "user": "https://github.com/mrejmon"
}
```

Thank you for the suggestions. I implemented all of them, except I named the parameter `allow_growing` instead of `growing_letters` and instead of hiding the `infinite_repetitions_*` methods I merged them into `infinite_repetitions_primitive_roots`, to remove some redundant code and docs.



---

archive/issue_comments_239645.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-05-29T10:59:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239645",
    "user": "https://github.com/mrejmon"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_239646.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-06-24T08:25:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239646",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_239647.json:
```json
{
    "body": "Positive review! Thanks for your work on this. Sorry for the delay.",
    "created_at": "2021-06-24T08:25:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239647",
    "user": "https://github.com/seblabbe"
}
```

Positive review! Thanks for your work on this. Sorry for the delay.



---

archive/issue_events_051341.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-06-29T17:39:47Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18119#event-51341"
}
```



---

archive/issue_comments_239648.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-06-29T17:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18119#issuecomment-239648",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
