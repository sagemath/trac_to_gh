# Issue 18119: New methods for WordMorphism

archive/issues_017882.json:
```json
{
    "body": "Add the following methods to the `WordMorphism` class:\n\n- `is_injective()` - injectivity test\n- `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word\n- `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)\n- `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n- `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n- `simplify_alphabet_size()` - returns a simplification of the morphism\n- `simplify_until_injective()` - repeateadly calls simplify_alphabet_size() until the result is injective\n\nAlso adds the following method to the `FiniteWord_class`:\n\n- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word\n\n**Assignee:** @mrejmon\n\n**CC:**  @seblabbe @videlec tmonteil @staroste\n\n**Keywords:** sd66\n\n**Branch/Commit:** [0d5f94abffe1013c181dce6134c2058a72171402](https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402)\n\n**Reviewer:** S\u00e9bastien Labb\u00e9\n\n**Author:** Martin Rejmon\n\nIssue created by migration from https://trac.sagemath.org/ticket/18119\n\n",
    "closed_at": "2021-06-29T17:39:47Z",
    "created_at": "2015-04-03T10:15:53Z",
    "labels": [
        "component: combinatorics",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.4",
    "title": "New methods for WordMorphism",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/18119",
    "user": "https://github.com/staroste"
}
```
Add the following methods to the `WordMorphism` class:

- `is_injective()` - injectivity test
- `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word
- `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)
- `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions
- `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism
- `simplify_alphabet_size()` - returns a simplification of the morphism
- `simplify_until_injective()` - repeateadly calls simplify_alphabet_size() until the result is injective

Also adds the following method to the `FiniteWord_class`:

- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word

**Assignee:** @mrejmon

**CC:**  @seblabbe @videlec tmonteil @staroste

**Keywords:** sd66

**Branch/Commit:** [0d5f94abffe1013c181dce6134c2058a72171402](https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402)

**Reviewer:** Sébastien Labbé

**Author:** Martin Rejmon

Issue created by migration from https://trac.sagemath.org/ticket/18119





---

archive/issue_comments_249760.json:
```json
{
    "body": "**Assignee:** @staroste",
    "created_at": "2015-04-03T10:16:51Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249760",
    "user": "https://github.com/staroste"
}
```

**Assignee:** @staroste



---

archive/issue_events_162546.json:
```json
{
    "actor": "https://github.com/staroste",
    "created_at": "2015-04-03T10:30:01Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "rename": {
        "from": "New methods for WordMorhism",
        "to": "New methods for WordMorphism"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162546"
}
```



---

archive/issue_comments_249761.json:
```json
{
    "body": "**Changing assignee** from @staroste to @mrejmon.",
    "created_at": "2021-03-15T21:39:01Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249761",
    "user": "https://github.com/staroste"
}
```

**Changing assignee** from @staroste to @mrejmon.



---

archive/issue_events_162547.json:
```json
{
    "actor": "https://github.com/mrejmon",
    "created_at": "2021-03-30T12:49:19Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "milestone": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162547"
}
```



---

archive/issue_events_162548.json:
```json
{
    "actor": "https://github.com/mrejmon",
    "created_at": "2021-03-30T12:49:19Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162548"
}
```



---

archive/issue_comments_249762.json:
```json
{
    "body": "**Branch:** [u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)",
    "created_at": "2021-03-30T12:49:19Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249762",
    "user": "https://github.com/mrejmon"
}
```

**Branch:** [u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)



---

archive/issue_events_162549.json:
```json
{
    "actor": "https://github.com/mrejmon",
    "created_at": "2021-03-30T12:49:19Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162549"
}
```



---

archive/issue_comments_249763.json:
```json
{
    "body": "<a id='comment:4'></a>\nHello,\n\nthe pushed branch contains an implementation of the algorithm from the following paper [An algorithm for enumerating all infinite repetitions in a D0L-system](https://www.sciencedirect.com/science/article/pii/S1570866715000490), using which it is easy to answer the `is_pushy` and `is_unboundedly_repetitive` queries. It also includes a version of the [Sardinas-Patterson algorithm](https://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm) to answer `is_injective`.\n\nWhile implementing the above I also added a method for simplifying non-injective morphisms and a method for finding the minimal conjugate of a finite word.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be\">9d5b3c0</a></td><td><code>Add algorithm enumerating infinite repetitions</code></td></tr></table>\n",
    "created_at": "2021-03-30T12:49:19Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249763",
    "user": "https://github.com/mrejmon"
}
```

<a id='comment:4'></a>
Hello,

the pushed branch contains an implementation of the algorithm from the following paper [An algorithm for enumerating all infinite repetitions in a D0L-system](https://www.sciencedirect.com/science/article/pii/S1570866715000490), using which it is easy to answer the `is_pushy` and `is_unboundedly_repetitive` queries. It also includes a version of the [Sardinas-Patterson algorithm](https://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm) to answer `is_injective`.

While implementing the above I also added a method for simplifying non-injective morphisms and a method for finding the minimal conjugate of a finite word.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be">9d5b3c0</a></td><td><code>Add algorithm enumerating infinite repetitions</code></td></tr></table>




---

archive/issue_comments_249764.json:
```json
{
    "body": "**Commit:** [9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be](https://github.com/sagemath/sagetrac-mirror/commit/9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be)",
    "created_at": "2021-03-30T12:49:19Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249764",
    "user": "https://github.com/mrejmon"
}
```

**Commit:** [9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be](https://github.com/sagemath/sagetrac-mirror/commit/9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be)



---

archive/issue_comments_249765.json:
```json
{
    "body": "**Changing author** from \"\u0160t\u011bp\u00e1n Starosta\" to \"Martin Rejmon\".",
    "created_at": "2021-03-30T12:49:19Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249765",
    "user": "https://github.com/mrejmon"
}
```

**Changing author** from "Štěpán Starosta" to "Martin Rejmon".



---

archive/issue_comments_249766.json:
```json
{
    "body": "<a id='comment:5'></a>\nI looked at the code. Here are few comments:\n\n1 - I would suggest to move the import of `chain`, `count` and `Counter` directly inside the method where they are used (except if they are imported in lots of distinct methods).\n\n```diff\n-from itertools import chain\n+from collections import Counter\n+from itertools import chain, count\n```\n\n2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\\{m^n(w) | n \\ge 0\\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?\n\nEvery method saying \"should be an endomorphism\" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.\n\nWhat is the typical case you have in mind?\n\n```diff\n+        Return whether the language `\\{m^n(w) | n \\ge 0\\}` is pushy,\n+        where `m` is this morphism and `w` is a word inputted as a parameter.\n+\n+        Requires this morphism to be an endomorphism.\n```",
    "created_at": "2021-04-02T07:39:54Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249766",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:5'></a>
I looked at the code. Here are few comments:

1 - I would suggest to move the import of `chain`, `count` and `Counter` directly inside the method where they are used (except if they are imported in lots of distinct methods).

```diff
-from itertools import chain
+from collections import Counter
+from itertools import chain, count
```

2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\{m^n(w) | n \ge 0\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?

Every method saying "should be an endomorphism" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.

What is the typical case you have in mind?

```diff
+        Return whether the language `\{m^n(w) | n \ge 0\}` is pushy,
+        where `m` is this morphism and `w` is a word inputted as a parameter.
+
+        Requires this morphism to be an endomorphism.
```



---

archive/issue_comments_249767.json:
```json
{
    "body": "<a id='comment:6'></a>\nReplying to [slabbe](#comment%3A5):\n> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\\{m^n(w) | n \\ge 0\\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?\n> \n\n\n`\\{m^n(w) | n \\ge 0\\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.\nAs you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?\n\n\n> Every method saying \"should be an endomorphism\" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.\n\n\nI am unsure what would be the right object at this point. In the more general settings, all are properties of a D0L-system. Do we want to have a class for it?\n\nI think there are many general methods that require an endomorphism, and there is no special class for them, is there?\n\n> \n> What is the typical case you have in mind?\n> \n> ```diff\n> +        Return whether the language `\\{m^n(w) | n \\ge 0\\}` is pushy,\n> +        where `m` is this morphism and `w` is a word inputted as a parameter.\n> +\n> +        Requires this morphism to be an endomorphism.\n> ```\n\n\nI think there should be the factorial closure of `\\{m^n(w) | n \\ge 0\\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).\nTaking `w` a letter, it is a property of a morphic word, or more precisely, its language.\nWhat do you mean by typical usage? Knowing whether a system/morphism is pushy is an ingredient to decide whether it is circular.",
    "created_at": "2021-04-07T09:40:43Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249767",
    "user": "https://github.com/staroste"
}
```

<a id='comment:6'></a>
Replying to [slabbe](#comment%3A5):
> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\{m^n(w) | n \ge 0\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?
> 


`\{m^n(w) | n \ge 0\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.
As you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?


> Every method saying "should be an endomorphism" and taking `w` as input would go in a class representing this object. If this object is always a morphic word OR morphic language, then, we could create a class for that. If this object is more general, we could still create a class for that.


I am unsure what would be the right object at this point. In the more general settings, all are properties of a D0L-system. Do we want to have a class for it?

I think there are many general methods that require an endomorphism, and there is no special class for them, is there?

> 
> What is the typical case you have in mind?
> 
> ```diff
> +        Return whether the language `\{m^n(w) | n \ge 0\}` is pushy,
> +        where `m` is this morphism and `w` is a word inputted as a parameter.
> +
> +        Requires this morphism to be an endomorphism.
> ```


I think there should be the factorial closure of `\{m^n(w) | n \ge 0\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).
Taking `w` a letter, it is a property of a morphic word, or more precisely, its language.
What do you mean by typical usage? Knowing whether a system/morphism is pushy is an ingredient to decide whether it is circular.



---

archive/issue_comments_249768.json:
```json
{
    "body": "**Changing commit** from \"[9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be](https://github.com/sagemath/sagetrac-mirror/commit/9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be)\" to \"[6dcef989d9bf6549bb7e3015d087db88689afc78](https://github.com/sagemath/sagetrac-mirror/commit/6dcef989d9bf6549bb7e3015d087db88689afc78)\".",
    "created_at": "2021-04-08T10:00:55Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249768",
    "user": "https://github.com/seblabbe"
}
```

**Changing commit** from "[9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be](https://github.com/sagemath/sagetrac-mirror/commit/9d5b3c0fdcf0b7c5a5d61003e11c6cad313945be)" to "[6dcef989d9bf6549bb7e3015d087db88689afc78](https://github.com/sagemath/sagetrac-mirror/commit/6dcef989d9bf6549bb7e3015d087db88689afc78)".



---

archive/issue_comments_249769.json:
```json
{
    "body": "<a id='comment:7'></a>\nI did a small commit to move the itertools import inside the method.\n\n(I did not touch the import of chain which would create a conflict with #31378)\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6dcef989d9bf6549bb7e3015d087db88689afc78\">6dcef98</a></td><td><code>18119: moved itertools imports inside methods</code></td></tr></table>\n",
    "created_at": "2021-04-08T10:00:55Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249769",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:7'></a>
I did a small commit to move the itertools import inside the method.

(I did not touch the import of chain which would create a conflict with #31378)

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6dcef989d9bf6549bb7e3015d087db88689afc78">6dcef98</a></td><td><code>18119: moved itertools imports inside methods</code></td></tr></table>




---

archive/issue_comments_249770.json:
```json
{
    "body": "**Changing branch** from \"[u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)\" to \"[u/slabbe/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/18119)\".",
    "created_at": "2021-04-08T10:00:55Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249770",
    "user": "https://github.com/seblabbe"
}
```

**Changing branch** from "[u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)" to "[u/slabbe/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/18119)".



---

archive/issue_comments_249771.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [sstarosta](#comment%3A6):\n> Replying to [slabbe](#comment%3A5):\n> > 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\\{m^n(w) | n \\ge 0\\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?\n> > \n\n> \n> `\\{m^n(w) | n \\ge 0\\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.\n> As you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?\n\n>\n\nNo, for these methods there isn't. I mostly only added the `w` argument since it seemed to make the docs cleaner to me, that is \"`w` is a word inputted as a parameter\" instead of \"`w` is an arbitrary word containing at least one of each letter from the alphabet of the domain of this morphism\" or similar.\n\n> ...\n> > ...\n\n> ...\n> > \n> > ```diff\n> > +        Return whether the language `\\{m^n(w) | n \\ge 0\\}` is pushy,\n> > +        where `m` is this morphism and `w` is a word inputted as a parameter.\n> > +\n> > +        Requires this morphism to be an endomorphism.\n> > ```\n\n> \n> I think there should be the factorial closure of `\\{m^n(w) | n \\ge 0\\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).\n\n>\n\nThe factors are mentioned in the paragraph right below that:\n\n```\n        A language created by iterating a morphism is pushy if its words\n        contain an infinite number of factors containing no growing letters. It\n        turns out that this is equivalent to having at least one infinite\n        repetition containing no growing letters.\n```\n\nWould you still prefer to mention them also in the first sentence in the docs?\n\nReplying to [slabbe](#comment%3A7):\n> I did a small commit to move the itertools import inside the method.\n> \n> (I did not touch the import of chain which would create a conflict with #31378)\n\n>\n\nThanks! Sorry for the long delay before answering, thankfully \u0160t\u011bp\u00e1n already responded to your second comment. I also added a commit adding a test and slightly refactoring one method.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ba0845df00dc7c76582403b479ca1b02549a1251\">ba0845d</a></td><td><code>18119: Refactor inf_reps_bounded</code></td></tr></table>\n",
    "created_at": "2021-04-08T19:05:37Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249771",
    "user": "https://github.com/mrejmon"
}
```

<a id='comment:8'></a>
Replying to [sstarosta](#comment%3A6):
> Replying to [slabbe](#comment%3A5):
> > 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class. Or maybe you really want to consider `\{m^n(w) | n \ge 0\}` which may contain more factors than the morphic word if `w` is the whole alphabet and `m` is not primitive. Does such language corresponds to something, for which we could create a class as well?
> > 

> 
> `\{m^n(w) | n \ge 0\}` is the language of an L-system, `w` is its axiom. I am not sure if we want to create a class for this, we rather want to study its factor closure, i.e., language of an infinite word generated by the morphism of `w` being a letter.
> As you say, if `w` is not just a letter, we get something more, but in general we should no get anything really new than what we'd get by taking letter axioms one by one. Or is there, Martin?

>

No, for these methods there isn't. I mostly only added the `w` argument since it seemed to make the docs cleaner to me, that is "`w` is a word inputted as a parameter" instead of "`w` is an arbitrary word containing at least one of each letter from the alphabet of the domain of this morphism" or similar.

> ...
> > ...

> ...
> > 
> > ```diff
> > +        Return whether the language `\{m^n(w) | n \ge 0\}` is pushy,
> > +        where `m` is this morphism and `w` is a word inputted as a parameter.
> > +
> > +        Requires this morphism to be an endomorphism.
> > ```

> 
> I think there should be the factorial closure of `\{m^n(w) | n \ge 0\}` as is in the original definition [Repetition of subwords in DOL languages](https://www.sciencedirect.com/science/article/pii/S001999588380028X).

>

The factors are mentioned in the paragraph right below that:

```
        A language created by iterating a morphism is pushy if its words
        contain an infinite number of factors containing no growing letters. It
        turns out that this is equivalent to having at least one infinite
        repetition containing no growing letters.
```

Would you still prefer to mention them also in the first sentence in the docs?

Replying to [slabbe](#comment%3A7):
> I did a small commit to move the itertools import inside the method.
> 
> (I did not touch the import of chain which would create a conflict with #31378)

>

Thanks! Sorry for the long delay before answering, thankfully Štěpán already responded to your second comment. I also added a commit adding a test and slightly refactoring one method.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ba0845df00dc7c76582403b479ca1b02549a1251">ba0845d</a></td><td><code>18119: Refactor inf_reps_bounded</code></td></tr></table>




---

archive/issue_comments_249772.json:
```json
{
    "body": "**Changing branch** from \"[u/slabbe/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/18119)\" to \"[u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)\".",
    "created_at": "2021-04-08T19:05:37Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249772",
    "user": "https://github.com/mrejmon"
}
```

**Changing branch** from "[u/slabbe/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/18119)" to "[u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)".



---

archive/issue_comments_249773.json:
```json
{
    "body": "**Changing commit** from \"[6dcef989d9bf6549bb7e3015d087db88689afc78](https://github.com/sagemath/sagetrac-mirror/commit/6dcef989d9bf6549bb7e3015d087db88689afc78)\" to \"[ba0845df00dc7c76582403b479ca1b02549a1251](https://github.com/sagemath/sagetrac-mirror/commit/ba0845df00dc7c76582403b479ca1b02549a1251)\".",
    "created_at": "2021-04-08T19:05:37Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249773",
    "user": "https://github.com/mrejmon"
}
```

**Changing commit** from "[6dcef989d9bf6549bb7e3015d087db88689afc78](https://github.com/sagemath/sagetrac-mirror/commit/6dcef989d9bf6549bb7e3015d087db88689afc78)" to "[ba0845df00dc7c76582403b479ca1b02549a1251](https://github.com/sagemath/sagetrac-mirror/commit/ba0845df00dc7c76582403b479ca1b02549a1251)".



---

archive/issue_comments_249774.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/49e0baae95e87d843473b33245f81267e583c2ad\">49e0baa</a></td><td><code>18119: Refactor inf_reps_bounded (2)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0e6e552495e1b53d2e95ee83de9f76a803bef390\">0e6e552</a></td><td><code>18119: Refactor inf_reps_growing</code></td></tr></table>\n",
    "created_at": "2021-04-09T19:42:01Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249774",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/49e0baae95e87d843473b33245f81267e583c2ad">49e0baa</a></td><td><code>18119: Refactor inf_reps_bounded (2)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0e6e552495e1b53d2e95ee83de9f76a803bef390">0e6e552</a></td><td><code>18119: Refactor inf_reps_growing</code></td></tr></table>




---

archive/issue_comments_249775.json:
```json
{
    "body": "**Changing commit** from \"[ba0845df00dc7c76582403b479ca1b02549a1251](https://github.com/sagemath/sagetrac-mirror/commit/ba0845df00dc7c76582403b479ca1b02549a1251)\" to \"[0e6e552495e1b53d2e95ee83de9f76a803bef390](https://github.com/sagemath/sagetrac-mirror/commit/0e6e552495e1b53d2e95ee83de9f76a803bef390)\".",
    "created_at": "2021-04-09T19:42:01Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249775",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ba0845df00dc7c76582403b479ca1b02549a1251](https://github.com/sagemath/sagetrac-mirror/commit/ba0845df00dc7c76582403b479ca1b02549a1251)" to "[0e6e552495e1b53d2e95ee83de9f76a803bef390](https://github.com/sagemath/sagetrac-mirror/commit/0e6e552495e1b53d2e95ee83de9f76a803bef390)".



---

archive/issue_comments_249776.json:
```json
{
    "body": "**Changing commit** from \"[0e6e552495e1b53d2e95ee83de9f76a803bef390](https://github.com/sagemath/sagetrac-mirror/commit/0e6e552495e1b53d2e95ee83de9f76a803bef390)\" to \"[7a230ace15c4ee2d3df6e03d1700a13d75678061](https://github.com/sagemath/sagetrac-mirror/commit/7a230ace15c4ee2d3df6e03d1700a13d75678061)\".",
    "created_at": "2021-04-22T11:33:20Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249776",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[0e6e552495e1b53d2e95ee83de9f76a803bef390](https://github.com/sagemath/sagetrac-mirror/commit/0e6e552495e1b53d2e95ee83de9f76a803bef390)" to "[7a230ace15c4ee2d3df6e03d1700a13d75678061](https://github.com/sagemath/sagetrac-mirror/commit/7a230ace15c4ee2d3df6e03d1700a13d75678061)".



---

archive/issue_comments_249777.json:
```json
{
    "body": "<a id='comment:10'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ab5c0c9bc2d3504693c6fd82805baf71426d39ec\">ab5c0c9</a></td><td><code>18119: Refactor is_injective</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a230ace15c4ee2d3df6e03d1700a13d75678061\">7a230ac</a></td><td><code>18119: Refactor simplify</code></td></tr></table>\n",
    "created_at": "2021-04-22T11:33:20Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249777",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ab5c0c9bc2d3504693c6fd82805baf71426d39ec">ab5c0c9</a></td><td><code>18119: Refactor is_injective</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a230ace15c4ee2d3df6e03d1700a13d75678061">7a230ac</a></td><td><code>18119: Refactor simplify</code></td></tr></table>




---

archive/issue_comments_249778.json:
```json
{
    "body": "**Changing commit** from \"[7a230ace15c4ee2d3df6e03d1700a13d75678061](https://github.com/sagemath/sagetrac-mirror/commit/7a230ace15c4ee2d3df6e03d1700a13d75678061)\" to \"[e47204073b6b041c15430e215f267348229c3c99](https://github.com/sagemath/sagetrac-mirror/commit/e47204073b6b041c15430e215f267348229c3c99)\".",
    "created_at": "2021-04-22T11:39:15Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249778",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7a230ace15c4ee2d3df6e03d1700a13d75678061](https://github.com/sagemath/sagetrac-mirror/commit/7a230ace15c4ee2d3df6e03d1700a13d75678061)" to "[e47204073b6b041c15430e215f267348229c3c99](https://github.com/sagemath/sagetrac-mirror/commit/e47204073b6b041c15430e215f267348229c3c99)".



---

archive/issue_comments_249779.json:
```json
{
    "body": "<a id='comment:11'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e47204073b6b041c15430e215f267348229c3c99\">e472040</a></td><td><code>18119: Refactor is_injective (2)</code></td></tr></table>\n",
    "created_at": "2021-04-22T11:39:15Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249779",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e47204073b6b041c15430e215f267348229c3c99">e472040</a></td><td><code>18119: Refactor is_injective (2)</code></td></tr></table>




---

archive/issue_comments_249780.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [slabbe](#comment%3A5):\n> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class.\n\n\nI just wanted to reply to myself here. While I still think some of the methods added here could go in another class (LanguageMorphicWord for instance), I do not want to uphold this ticket. I am not contributing at a high frequency right now, so I prefer adding those methods in SageMath as proposed and, later, if we want to move them elsewhere, it is never too late. Continue your good work.",
    "created_at": "2021-04-22T11:41:51Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249780",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:12'></a>
Replying to [slabbe](#comment%3A5):
> 2 - I think we want to create a class for a morphic word (see ticket #31378 on which we are currently working on with Jana) or for the language of a morphic word. And then many of the methods implemented here would go in that class.


I just wanted to reply to myself here. While I still think some of the methods added here could go in another class (LanguageMorphicWord for instance), I do not want to uphold this ticket. I am not contributing at a high frequency right now, so I prefer adding those methods in SageMath as proposed and, later, if we want to move them elsewhere, it is never too late. Continue your good work.



---

archive/issue_comments_249781.json:
```json
{
    "body": "<a id='comment:13'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9c216e05102cfcb161c8f3b832b3af9c65a1371b\">9c216e0</a></td><td><code>18119: Work around some codomain issues</code></td></tr></table>\n",
    "created_at": "2021-05-04T19:38:43Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249781",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9c216e05102cfcb161c8f3b832b3af9c65a1371b">9c216e0</a></td><td><code>18119: Work around some codomain issues</code></td></tr></table>




---

archive/issue_comments_249782.json:
```json
{
    "body": "**Changing commit** from \"[e47204073b6b041c15430e215f267348229c3c99](https://github.com/sagemath/sagetrac-mirror/commit/e47204073b6b041c15430e215f267348229c3c99)\" to \"[9c216e05102cfcb161c8f3b832b3af9c65a1371b](https://github.com/sagemath/sagetrac-mirror/commit/9c216e05102cfcb161c8f3b832b3af9c65a1371b)\".",
    "created_at": "2021-05-04T19:38:43Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249782",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[e47204073b6b041c15430e215f267348229c3c99](https://github.com/sagemath/sagetrac-mirror/commit/e47204073b6b041c15430e215f267348229c3c99)" to "[9c216e05102cfcb161c8f3b832b3af9c65a1371b](https://github.com/sagemath/sagetrac-mirror/commit/9c216e05102cfcb161c8f3b832b3af9c65a1371b)".



---

archive/issue_comments_249783.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,7 +1,6 @@\n-Add the following methods to the WordMorphism class\n+Add the following methods to the `WordMorphism` class:\n \n-`is_injective()` - injectivity test\n+- `is_injective()` - injectivity test\n+- `_is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter\n+- `is_pushy()` - whether the morphism is pushy\n \n-`_is_unboundedly_repetive()` - return whether the morphism is unboundedly repetitive (= has a periodic periodic point containing an unbounded letter)\n-\n-`is_pushy()` - return whether if it the morphism is pushy\n``````\n",
    "created_at": "2021-05-04T21:30:28Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249783",
    "user": "https://github.com/slel"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,7 +1,6 @@
-Add the following methods to the WordMorphism class
+Add the following methods to the `WordMorphism` class:
 
-`is_injective()` - injectivity test
+- `is_injective()` - injectivity test
+- `_is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter
+- `is_pushy()` - whether the morphism is pushy
 
-`_is_unboundedly_repetive()` - return whether the morphism is unboundedly repetitive (= has a periodic periodic point containing an unbounded letter)
-
-`is_pushy()` - return whether if it the morphism is pushy
``````




---

archive/issue_comments_249784.json:
```json
{
    "body": "<a id='comment:15'></a>\nI see that few more methods are added in this ticket:\n\n```\n+    def is_injective(self):\n+    def is_pushy(self, w=None):\n+    def is_unboundedly_repetitive(self, w=None):\n+    def is_repetitive(self, w=None):\n+    def infinite_repetitions(self, w=None):\n+    def infinite_repetitions_bounded(self, w=None):\n+    def infinite_repetitions_growing(self, w=None):\n+    def reach(self, w):\n+    def simplify(self, Z=None):\n+    def simplify_injective(self):\n```\n\nWould it be possible to update the description of the ticket with this complete list?",
    "created_at": "2021-05-20T10:11:03Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249784",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:15'></a>
I see that few more methods are added in this ticket:

```
+    def is_injective(self):
+    def is_pushy(self, w=None):
+    def is_unboundedly_repetitive(self, w=None):
+    def is_repetitive(self, w=None):
+    def infinite_repetitions(self, w=None):
+    def infinite_repetitions_bounded(self, w=None):
+    def infinite_repetitions_growing(self, w=None):
+    def reach(self, w):
+    def simplify(self, Z=None):
+    def simplify_injective(self):
```

Would it be possible to update the description of the ticket with this complete list?



---

archive/issue_comments_249785.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -4,3 +4,4 @@\n - `_is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter\n - `is_pushy()` - whether the morphism is pushy\n \n+\n``````\n",
    "created_at": "2021-05-20T10:11:03Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249785",
    "user": "https://github.com/seblabbe"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -4,3 +4,4 @@
 - `_is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter
 - `is_pushy()` - whether the morphism is pushy
 
+
``````




---

archive/issue_comments_249786.json:
```json
{
    "body": "<a id='comment:16'></a>\nIn particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.",
    "created_at": "2021-05-20T10:13:20Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249786",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:16'></a>
In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.



---

archive/issue_comments_249787.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [slabbe](#comment%3A16):\n> In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.\n\n\nThe term simplification is used by A. Ehrenfeucht and G. Rozenberg, and maybe earlier. I'd prefer to keep it unless we find a much better name (I can't think of anything simple).\nI don't know about reach, Martin?",
    "created_at": "2021-05-20T10:20:04Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249787",
    "user": "https://github.com/staroste"
}
```

<a id='comment:17'></a>
Replying to [slabbe](#comment%3A16):
> In particular, I am unsure about the choice of `reach`, `simplify` and `simplify_injective`. These names do not make me think about what it is. Can we find more evoking names? Possibly also for `infinite_repetitions*`.


The term simplification is used by A. Ehrenfeucht and G. Rozenberg, and maybe earlier. I'd prefer to keep it unless we find a much better name (I can't think of anything simple).
I don't know about reach, Martin?



---

archive/issue_comments_249788.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,7 +1,12 @@\n Add the following methods to the `WordMorphism` class:\n \n - `is_injective()` - injectivity test\n-- `_is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter\n-- `is_pushy()` - whether the morphism is pushy\n+- `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word\n+- `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)\n+- `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n+- `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n+- `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters\n+- `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter\n+- `simplify()` - returns a simplification of the morphism\n+- `simplify_injective()` - repeateadly calls simplify() until the result is injective\n \n-\n``````\n",
    "created_at": "2021-05-21T09:07:37Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249788",
    "user": "https://github.com/mrejmon"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,7 +1,12 @@
 Add the following methods to the `WordMorphism` class:
 
 - `is_injective()` - injectivity test
-- `_is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter
-- `is_pushy()` - whether the morphism is pushy
+- `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word
+- `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)
+- `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions
+- `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism
+- `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters
+- `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter
+- `simplify()` - returns a simplification of the morphism
+- `simplify_injective()` - repeateadly calls simplify() until the result is injective
 
-
``````




---

archive/issue_comments_249789.json:
```json
{
    "body": "<a id='comment:19'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/da0536b759b98143a162aef6948a489b4c32aa25\">da0536b</a></td><td><code>Replace reach with _language_naive</code></td></tr></table>\n",
    "created_at": "2021-05-21T09:23:55Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249789",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/da0536b759b98143a162aef6948a489b4c32aa25">da0536b</a></td><td><code>Replace reach with _language_naive</code></td></tr></table>




---

archive/issue_comments_249790.json:
```json
{
    "body": "**Changing commit** from \"[9c216e05102cfcb161c8f3b832b3af9c65a1371b](https://github.com/sagemath/sagetrac-mirror/commit/9c216e05102cfcb161c8f3b832b3af9c65a1371b)\" to \"[da0536b759b98143a162aef6948a489b4c32aa25](https://github.com/sagemath/sagetrac-mirror/commit/da0536b759b98143a162aef6948a489b4c32aa25)\".",
    "created_at": "2021-05-21T09:23:55Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249790",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[9c216e05102cfcb161c8f3b832b3af9c65a1371b](https://github.com/sagemath/sagetrac-mirror/commit/9c216e05102cfcb161c8f3b832b3af9c65a1371b)" to "[da0536b759b98143a162aef6948a489b4c32aa25](https://github.com/sagemath/sagetrac-mirror/commit/da0536b759b98143a162aef6948a489b4c32aa25)".



---

archive/issue_comments_249791.json:
```json
{
    "body": "<a id='comment:20'></a>\nI \"solved\" the `reach` naming problem by replacing it with calls to `_language_naive`.",
    "created_at": "2021-05-21T09:25:00Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249791",
    "user": "https://github.com/mrejmon"
}
```

<a id='comment:20'></a>
I "solved" the `reach` naming problem by replacing it with calls to `_language_naive`.



---

archive/issue_comments_249792.json:
```json
{
    "body": "Thank you, the updated description helps me to have an easier overview of what it added.\n\nI have few suggestions about the name of the methods. See below. It is important to choose them well, because they are harder to change once in sage because of backward compatibility.\n\nReplying to new description:\n> Add the following methods to the `WordMorphism` class:\n> \n> - `is_injective()` - injectivity test\n\n\nokay\n\n> - `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word\n\n\nokay\n\n> - `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)\n\n\nokay\n\n> - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n\n\nokay\n\n> - `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n\n\nI rather suggest `infinite_repetitions_primitive_roots()`. Explicit is better and implicit. See `import this` in Python:)\n\n> - `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters\n> - `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter\n\n\nI would suggest to rename those two methods as hidden methods `_infinite_repetitions_bounded()` and `_infinite_repetitions_growing()`. Then, I would suggest to access those methods from the method `infinite_repetitions()` as follows:\n\n- `infinite_repetitions(growing_letters=None)`, the default\n- `infinite_repetitions(growing_letters=True)`, only those words which contain at least one growing letter\n- `infinite_repetitions(growing_letters=False)`, only those words which contain no growing letters\n\nOf course, you will need to also add documentation about this new argument `growing_letters`.\n\n> - `simplify()` - returns a simplification of the morphism\n\n\nI would suggest to rename it to `simplify_alphabet_size()`, because this is really what this methods wants to do: reduce the size of the alphabet while doing essentially the same thing.\n\n> - `simplify_injective()` - repeateadly calls simplify() until the result is injective\n\n\nI suggest to rename it to `simplify_to_injective()` or even better `simplify_until_injective()` since the word `until` gives an hint about the procedure. Otherwise we don't know whether `injective` is a description of the input or the output. Here, it describes the output.\n\nReview done during the Sage Thursdays in Bordeaux at https://wiki.sagemath.org/thursdaysbdx.",
    "created_at": "2021-05-27T09:44:58Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249792",
    "user": "https://github.com/seblabbe"
}
```

Thank you, the updated description helps me to have an easier overview of what it added.

I have few suggestions about the name of the methods. See below. It is important to choose them well, because they are harder to change once in sage because of backward compatibility.

Replying to new description:
> Add the following methods to the `WordMorphism` class:
> 
> - `is_injective()` - injectivity test


okay

> - `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word


okay

> - `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)


okay

> - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions


okay

> - `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism


I rather suggest `infinite_repetitions_primitive_roots()`. Explicit is better and implicit. See `import this` in Python:)

> - `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters
> - `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter


I would suggest to rename those two methods as hidden methods `_infinite_repetitions_bounded()` and `_infinite_repetitions_growing()`. Then, I would suggest to access those methods from the method `infinite_repetitions()` as follows:

- `infinite_repetitions(growing_letters=None)`, the default
- `infinite_repetitions(growing_letters=True)`, only those words which contain at least one growing letter
- `infinite_repetitions(growing_letters=False)`, only those words which contain no growing letters

Of course, you will need to also add documentation about this new argument `growing_letters`.

> - `simplify()` - returns a simplification of the morphism


I would suggest to rename it to `simplify_alphabet_size()`, because this is really what this methods wants to do: reduce the size of the alphabet while doing essentially the same thing.

> - `simplify_injective()` - repeateadly calls simplify() until the result is injective


I suggest to rename it to `simplify_to_injective()` or even better `simplify_until_injective()` since the word `until` gives an hint about the procedure. Otherwise we don't know whether `injective` is a description of the input or the output. Here, it describes the output.

Review done during the Sage Thursdays in Bordeaux at https://wiki.sagemath.org/thursdaysbdx.



---

archive/issue_events_162550.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2021-05-27T09:44:58Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162550"
}
```



---

archive/issue_events_162551.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2021-05-27T09:44:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162551"
}
```



---

archive/issue_comments_249793.json:
```json
{
    "body": "**Reviewer:** S\u00e9bastien Labb\u00e9",
    "created_at": "2021-05-27T09:48:34Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249793",
    "user": "https://github.com/seblabbe"
}
```

**Reviewer:** Sébastien Labbé



---

archive/issue_comments_249794.json:
```json
{
    "body": "**Changing commit** from \"[da0536b759b98143a162aef6948a489b4c32aa25](https://github.com/sagemath/sagetrac-mirror/commit/da0536b759b98143a162aef6948a489b4c32aa25)\" to \"[0d5f94abffe1013c181dce6134c2058a72171402](https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402)\".",
    "created_at": "2021-05-29T10:51:21Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249794",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[da0536b759b98143a162aef6948a489b4c32aa25](https://github.com/sagemath/sagetrac-mirror/commit/da0536b759b98143a162aef6948a489b4c32aa25)" to "[0d5f94abffe1013c181dce6134c2058a72171402](https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402)".



---

archive/issue_comments_249795.json:
```json
{
    "body": "<a id='comment:23'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/02aaa8ffd497212b6a42320c52ff5bd9b83f89c7\">02aaa8f</a></td><td><code>Rename simplify methods</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402\">0d5f94a</a></td><td><code>Merge infinite_repetitions* methods</code></td></tr></table>\n",
    "created_at": "2021-05-29T10:51:21Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249795",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/02aaa8ffd497212b6a42320c52ff5bd9b83f89c7">02aaa8f</a></td><td><code>Rename simplify methods</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402">0d5f94a</a></td><td><code>Merge infinite_repetitions* methods</code></td></tr></table>




---

archive/issue_comments_249796.json:
```json
{
    "body": "<a id='comment:24'></a>\nThank you for the suggestions. I implemented all of them, except I named the parameter `allow_growing` instead of `growing_letters` and instead of hiding the `infinite_repetitions_*` methods I merged them into `infinite_repetitions_primitive_roots`, to remove some redundant code and docs.",
    "created_at": "2021-05-29T10:59:24Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249796",
    "user": "https://github.com/mrejmon"
}
```

<a id='comment:24'></a>
Thank you for the suggestions. I implemented all of them, except I named the parameter `allow_growing` instead of `growing_letters` and instead of hiding the `infinite_repetitions_*` methods I merged them into `infinite_repetitions_primitive_roots`, to remove some redundant code and docs.



---

archive/issue_events_162552.json:
```json
{
    "actor": "https://github.com/mrejmon",
    "created_at": "2021-05-29T10:59:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162552"
}
```



---

archive/issue_events_162553.json:
```json
{
    "actor": "https://github.com/mrejmon",
    "created_at": "2021-05-29T10:59:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162553"
}
```



---

archive/issue_comments_249797.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -4,9 +4,10 @@\n - `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word\n - `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)\n - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n-- `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n-- `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters\n-- `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter\n-- `simplify()` - returns a simplification of the morphism\n-- `simplify_injective()` - repeateadly calls simplify() until the result is injective\n+- `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n+- `simplify_alphabet_size()` - returns a simplification of the morphism\n+- `simplify_until_injective()` - repeateadly calls simplify() until the result is injective\n \n+Also adds the following method to the `FiniteWord_class`:\n+\n+- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word.\n``````\n",
    "created_at": "2021-05-29T10:59:24Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249797",
    "user": "https://github.com/mrejmon"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -4,9 +4,10 @@
 - `is_unboundedly_repetitive()` - whether the morphism is unboundedly repetitive, i.e. has a periodic point containing an unbounded letter, that is also a periodic word
 - `is_pushy()` - whether the morphism is pushy (its language contains an infinite amount of words with no growing letters)
 - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions
-- `infinite_repetitions()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism
-- `infinite_repetitions_bounded()` - same as above, but only those words which contain no growing letters
-- `infinite_repetitions_growing()` - same as above, but only those words which contain at least one growing letter
-- `simplify()` - returns a simplification of the morphism
-- `simplify_injective()` - repeateadly calls simplify() until the result is injective
+- `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism
+- `simplify_alphabet_size()` - returns a simplification of the morphism
+- `simplify_until_injective()` - repeateadly calls simplify() until the result is injective
 
+Also adds the following method to the `FiniteWord_class`:
+
+- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word.
``````




---

archive/issue_comments_249798.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -6,8 +6,8 @@\n - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions\n - `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism\n - `simplify_alphabet_size()` - returns a simplification of the morphism\n-- `simplify_until_injective()` - repeateadly calls simplify() until the result is injective\n+- `simplify_until_injective()` - repeateadly calls simplify_alphabet_size() until the result is injective\n \n Also adds the following method to the `FiniteWord_class`:\n \n-- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word.\n+- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word\n``````\n",
    "created_at": "2021-05-29T11:01:53Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249798",
    "user": "https://github.com/mrejmon"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -6,8 +6,8 @@
 - `is_repetitive()` - whether the morphism (its language) contains arbitrarily large repetitions
 - `infinite_repetitions_primitive_roots()` - finds the set of all words which are primitive roots of arbitrarily large repetitions in the language of the morphism
 - `simplify_alphabet_size()` - returns a simplification of the morphism
-- `simplify_until_injective()` - repeateadly calls simplify() until the result is injective
+- `simplify_until_injective()` - repeateadly calls simplify_alphabet_size() until the result is injective
 
 Also adds the following method to the `FiniteWord_class`:
 
-- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word.
+- `minimal_conjugate()` - returns the lexicographically smallest conjugate of this word
``````




---

archive/issue_events_162554.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2021-06-24T08:25:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162554"
}
```



---

archive/issue_events_162555.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2021-06-24T08:25:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162555"
}
```



---

archive/issue_comments_249799.json:
```json
{
    "body": "<a id='comment:26'></a>\nPositive review! Thanks for your work on this. Sorry for the delay.",
    "created_at": "2021-06-24T08:25:13Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249799",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:26'></a>
Positive review! Thanks for your work on this. Sorry for the delay.



---

archive/issue_events_162556.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-06-29T17:39:47Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162556"
}
```



---

archive/issue_events_162557.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "0a8b42b265e880545754948606a42954c92fa823",
    "created_at": "2021-06-29T17:39:47Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18119#event-162557"
}
```



---

archive/issue_comments_249800.json:
```json
{
    "body": "**Changing branch** from \"[u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)\" to \"[0d5f94abffe1013c181dce6134c2058a72171402](https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402)\".",
    "created_at": "2021-06-29T17:39:47Z",
    "issue": "https://github.com/sagemath/sage/issues/18119",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18119#issuecomment-249800",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/gh-mrejmon/18119](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mrejmon/18119)" to "[0d5f94abffe1013c181dce6134c2058a72171402](https://github.com/sagemath/sagetrac-mirror/commit/0d5f94abffe1013c181dce6134c2058a72171402)".
