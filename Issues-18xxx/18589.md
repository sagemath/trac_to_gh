# Issue 18589: isogeny efficiency improvement

archive/issues_018352.json:
```json
{
    "body": "Computation of isogenies of prime degree p is expensive when the degree is neither a \"genus zero\" prime [2,3,5,7,13] or a \"hyperelliptic prime\" [11, 17, 19, 23, 29, 31, 41, 47, 59, 71] (for these there is special code written).  In one situation we can save time, after factoring the degree `(p^2-1)/2` division polynomial, if there is exactly one factor of degree (p-1)/2, or one subset of factors whose product has that degree, then the factor of degree (p-1)/2 must be a kernel polynomial.  Then we do not need to check consistency, which is very expensive.\n\nThe example which led me to this was with p=89 over a quadratic number field, where E.isogeny_class() was taking days.  After the change here that goes down to 3 hours.  (There are 4 curves in the isogeny class and the code requires factoring the 89-division polynomial of each!)  I used a less extreme example for a doctest: a 37-isogeny.\n\nCC:  @defeo\n\nKeywords: isogeny\n\nReviewer: Jeroen Demeyer\n\nAuthor: John Cremona\n\nBranch: 3d687e5225f67808eb6c5af5fbf4cb93f2000c62\n\nCommit: 3d687e5225f67808eb6c5af5fbf4cb93f2000c62\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/18589\n\n",
    "closed_at": "2015-06-06T12:47:44Z",
    "created_at": "2015-06-02T19:33:19Z",
    "labels": [
        "component: elliptic curves"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.8",
    "title": "isogeny efficiency improvement",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18589",
    "user": "https://github.com/JohnCremona"
}
```
Computation of isogenies of prime degree p is expensive when the degree is neither a "genus zero" prime [2,3,5,7,13] or a "hyperelliptic prime" [11, 17, 19, 23, 29, 31, 41, 47, 59, 71] (for these there is special code written).  In one situation we can save time, after factoring the degree `(p^2-1)/2` division polynomial, if there is exactly one factor of degree (p-1)/2, or one subset of factors whose product has that degree, then the factor of degree (p-1)/2 must be a kernel polynomial.  Then we do not need to check consistency, which is very expensive.

The example which led me to this was with p=89 over a quadratic number field, where E.isogeny_class() was taking days.  After the change here that goes down to 3 hours.  (There are 4 curves in the isogeny class and the code requires factoring the 89-division polynomial of each!)  I used a less extreme example for a doctest: a 37-isogeny.

CC:  @defeo

Keywords: isogeny

Reviewer: Jeroen Demeyer

Author: John Cremona

Branch: 3d687e5225f67808eb6c5af5fbf4cb93f2000c62

Commit: 3d687e5225f67808eb6c5af5fbf4cb93f2000c62

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/18589





---

archive/issue_comments_248793.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2015-06-02T19:51:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248793",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_248794.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-06-02T19:51:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248794",
    "user": "https://github.com/JohnCremona"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_248795.json:
```json
{
    "body": "<a id='comment:4'></a>Interesting, the hardest part of the computation is checking the consistency, not computing the actual result.\n\nI had a look at what PARI can do for isogenies: `ellisogeny` computes the isogeny, so it could be used to implement `E.isogeny()`, but I assume it does no checking.\n\nMinor comment: in the doctest, you don't need\n\n```\nfrom sage.schemes.elliptic_curves.isogeny_small_degree import isogenies_prime_degree_general\n```",
    "created_at": "2015-06-03T16:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248795",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>Interesting, the hardest part of the computation is checking the consistency, not computing the actual result.

I had a look at what PARI can do for isogenies: `ellisogeny` computes the isogeny, so it could be used to implement `E.isogeny()`, but I assume it does no checking.

Minor comment: in the doctest, you don't need

```
from sage.schemes.elliptic_curves.isogeny_small_degree import isogenies_prime_degree_general
```



---

archive/issue_comments_248796.json:
```json
{
    "body": "<a id='comment:5'></a>Thanks for the comments, I noticed you over at pari-dev and wondered what you were up to.\n\nI don't know how general the pari code is -- here we can handle arbitrary fields (but only separable isogenies).  Over number fields the really hard part is determining which prime degrees to test to get the whole class, and I put a lot of work into this (including CM and \"potential CM\" cases).\n\nSome checking is necessary:  I have an example where the 13-division poly factors as 14 degree 6 factors, but only 2 of them are kernel polys!  For the rest you need to make a quadratic extension which splits each into two cubics, and then you have to match the factors.  The Sage code does this!",
    "created_at": "2015-06-03T16:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248796",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:5'></a>Thanks for the comments, I noticed you over at pari-dev and wondered what you were up to.

I don't know how general the pari code is -- here we can handle arbitrary fields (but only separable isogenies).  Over number fields the really hard part is determining which prime degrees to test to get the whole class, and I put a lot of work into this (including CM and "potential CM" cases).

Some checking is necessary:  I have an example where the 13-division poly factors as 14 degree 6 factors, but only 2 of them are kernel polys!  For the rest you need to make a quadratic extension which splits each into two cubics, and then you have to match the factors.  The Sage code does this!



---

archive/issue_comments_248797.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:5 cremona]:\n> I have an example where the 13-division poly factors as 14 degree 6 factors, but only 2 of them are kernel polys!\n\nIs this example in Sage? It would be good to have (if it takes too long, just add `# not tested (10 minutes)` or whatever)",
    "created_at": "2015-06-04T08:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248797",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>Replying to [comment:5 cremona]:
> I have an example where the 13-division poly factors as 14 degree 6 factors, but only 2 of them are kernel polys!

Is this example in Sage? It would be good to have (if it takes too long, just add `# not tested (10 minutes)` or whatever)



---

archive/issue_comments_248798.json:
```json
{
    "body": "<a id='comment:7'></a>Replying to [comment:5 cremona]:\n> For the rest you need to make a quadratic extension which splits each into two cubics, and then you have to match the factors.\n\nI'm wondering if you could use resultants instead...",
    "created_at": "2015-06-04T08:01:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248798",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>Replying to [comment:5 cremona]:
> For the rest you need to make a quadratic extension which splits each into two cubics, and then you have to match the factors.

I'm wondering if you could use resultants instead...



---

archive/issue_comments_248799.json:
```json
{
    "body": "<a id='comment:8'></a>Replying to [comment:6 jdemeyer]:\n> Replying to [comment:5 cremona]:\n> > I have an example where the 13-division poly factors as 14 degree 6 factors, but only 2 of them are kernel polys!\n\n> Is this example in Sage? It would be good to have (if it takes too long, just add `# not tested (10 minutes)` or whatever)\n\nNo, but it is Example 3.1.1 on page 28 of [KT2013] which is here: http://wrap.warwick.ac.uk/57568/\nThe example is over F_3 so is not slow.",
    "created_at": "2015-06-04T08:09:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248799",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:8'></a>Replying to [comment:6 jdemeyer]:
> Replying to [comment:5 cremona]:
> > I have an example where the 13-division poly factors as 14 degree 6 factors, but only 2 of them are kernel polys!

> Is this example in Sage? It would be good to have (if it takes too long, just add `# not tested (10 minutes)` or whatever)

No, but it is Example 3.1.1 on page 28 of [KT2013] which is here: http://wrap.warwick.ac.uk/57568/
The example is over F_3 so is not slow.



---

archive/issue_comments_248800.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:7 jdemeyer]:\n> Replying to [comment:5 cremona]:\n> > For the rest you need to make a quadratic extension which splits each into two cubics, and then you have to match the factors.\n\n> I'm wondering if you could use resultants instead...\n\nI thought that we did use resultants... but looking again at Kimi's code, the relevant function is mult() on line 1960:  the effect of this function is to take the polynomial f and the rational function m, under the assumption that f is coprime to the denominator of m, and return the poly whose roots are m(alpha) as alpha runs over the roots of f.  If m were a polynomial that would be res_Y(X-m(Y),f(Y)).  I can see now that we could stil use that formula with m(Y) replaced by the polynomial p(Y) which satisfies p*d=n (mod f) where m=n/d which would amount to one extended gcd and one resultant.  This may be better than the current code since it does not use rational functions.\n\nCan we keep this idea for another ticket?",
    "created_at": "2015-06-04T08:15:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248800",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:9'></a>Replying to [comment:7 jdemeyer]:
> Replying to [comment:5 cremona]:
> > For the rest you need to make a quadratic extension which splits each into two cubics, and then you have to match the factors.

> I'm wondering if you could use resultants instead...

I thought that we did use resultants... but looking again at Kimi's code, the relevant function is mult() on line 1960:  the effect of this function is to take the polynomial f and the rational function m, under the assumption that f is coprime to the denominator of m, and return the poly whose roots are m(alpha) as alpha runs over the roots of f.  If m were a polynomial that would be res_Y(X-m(Y),f(Y)).  I can see now that we could stil use that formula with m(Y) replaced by the polynomial p(Y) which satisfies p*d=n (mod f) where m=n/d which would amount to one extended gcd and one resultant.  This may be better than the current code since it does not use rational functions.

Can we keep this idea for another ticket?



---

archive/issue_comments_248801.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:9 cremona]:\n> Can we keep this idea for another ticket?\n\nSure...",
    "created_at": "2015-06-04T08:19:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248801",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:10'></a>Replying to [comment:9 cremona]:
> Can we keep this idea for another ticket?

Sure...



---

archive/issue_comments_248802.json:
```json
{
    "body": "<a id='comment:11'></a>In your code, \"special case 1\" is really a special case of \"special case 2\". For simplicity, I would therefore keep only special case 2.",
    "created_at": "2015-06-04T09:39:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248802",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:11'></a>In your code, "special case 1" is really a special case of "special case 2". For simplicity, I would therefore keep only special case 2.



---

archive/issue_comments_248803.json:
```json
{
    "body": "<a id='comment:12'></a>There is a pre-existing typo: `otain` instead of `obtain`.",
    "created_at": "2015-06-04T09:40:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248803",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:12'></a>There is a pre-existing typo: `otain` instead of `obtain`.



---

archive/issue_comments_248804.json:
```json
{
    "body": "<a id='comment:13'></a>There is a redundant\n\n```\nfrom sage.misc.all import prod\n```",
    "created_at": "2015-06-04T09:42:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248804",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:13'></a>There is a redundant

```
from sage.misc.all import prod
```



---

archive/issue_comments_248805.json:
```json
{
    "body": "<a id='comment:14'></a>OK, I will fix the redundant imports;  I agree that Case 1 is a special case of Case 2.  And I am working on the resultant improvement -- so setting to \"needs work\" is fine.  (Without the patch though I would not have been able to compute this:  http://beta.lmfdb.org/EllipticCurve/2.2.89.1/81.1/a/ !!",
    "created_at": "2015-06-04T09:46:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248805",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:14'></a>OK, I will fix the redundant imports;  I agree that Case 1 is a special case of Case 2.  And I am working on the resultant improvement -- so setting to "needs work" is fine.  (Without the patch though I would not have been able to compute this:  http://beta.lmfdb.org/EllipticCurve/2.2.89.1/81.1/a/ !!



---

archive/issue_comments_248806.json:
```json
{
    "body": "<a id='comment:15'></a>Since the constant `(l-1)//2` appears in several places in the algorithm, I would prefer to see a variable assigned to it (let's call it `D` or whatever).",
    "created_at": "2015-06-04T09:48:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248806",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:15'></a>Since the constant `(l-1)//2` appears in several places in the algorithm, I would prefer to see a variable assigned to it (let's call it `D` or whatever).



---

archive/issue_comments_248807.json:
```json
{
    "body": "<a id='comment:16'></a>Also, can't you avoid some conversions? In\n\n```\nF(f(m(x)).numerator())\n```\nthe call `m(x)` is really a conversion which should be done just once, probably best as `F(m)`. Then, I don't think the `F()` is needed and neither do you need `x`.",
    "created_at": "2015-06-04T09:58:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248807",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:16'></a>Also, can't you avoid some conversions? In

```
F(f(m(x)).numerator())
```
the call `m(x)` is really a conversion which should be done just once, probably best as `F(m)`. Then, I don't think the `F()` is needed and neither do you need `x`.



---

archive/issue_comments_248808.json:
```json
{
    "body": "<a id='comment:17'></a>In this loop,\n\n```\n        for i in range((l-1)/(2*d)-1):\n            g = mult(S[i])\n            S.append(g)\n            if g in factors:\n                factors.remove(g)\n```\nwhen can it happen that `g` is not in `factors`?",
    "created_at": "2015-06-04T10:04:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248808",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:17'></a>In this loop,

```
        for i in range((l-1)/(2*d)-1):
            g = mult(S[i])
            S.append(g)
            if g in factors:
                factors.remove(g)
```
when can it happen that `g` is not in `factors`?



---

archive/issue_comments_248809.json:
```json
{
    "body": "<a id='comment:18'></a>Replying to [comment:9 cremona]:\n> I thought that we did use resultants... but looking again at Kimi's code, the relevant function is mult() on line 1960:  the effect of this function is to take the polynomial f and the rational function m, under the assumption that f is coprime to the denominator of m, and return the poly whose roots are m(alpha) as alpha runs over the roots of f.  If m were a polynomial that would be res_Y(X-m(Y),f(Y)).  I can see now that we could stil use that formula with m(Y) replaced by the polynomial p(Y) which satisfies p*d=n (mod f) where m=n/d which would amount to one extended gcd and one resultant.  This may be better than the current code since it does not use rational functions.\n\n\nI don't quite get what you're saying here. I think I said \"resultants\" too quickly before looking at the actual code.\n\nMathematically, we need to compute\n\n```\ngcd( numerator( f(a/b) ), psi)\n```\nwhere `f`, `a`, `b`, `psi` are univariate polynomials and only `f` changes. I guess we know that the denominator of `f(a/b)` is `b^d` with `d` the degree of `f`. So we need\n\n```\ngcd( b^d f(a/b), psi)\n```\nNow suppose `c` is such that `a/b = c mod psi`, then we really need\n\n```\ngcd( b^d f(c), psi)\n```\nwhich equals\n\n```\ngcd(f(c), psi)\n```\nNow compute this in `R[x]/psi(x)` and this should be the most efficient way.\n\n(this was written up quickly, I haven't really checked that it's correct)",
    "created_at": "2015-06-04T10:13:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248809",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:18'></a>Replying to [comment:9 cremona]:
> I thought that we did use resultants... but looking again at Kimi's code, the relevant function is mult() on line 1960:  the effect of this function is to take the polynomial f and the rational function m, under the assumption that f is coprime to the denominator of m, and return the poly whose roots are m(alpha) as alpha runs over the roots of f.  If m were a polynomial that would be res_Y(X-m(Y),f(Y)).  I can see now that we could stil use that formula with m(Y) replaced by the polynomial p(Y) which satisfies p*d=n (mod f) where m=n/d which would amount to one extended gcd and one resultant.  This may be better than the current code since it does not use rational functions.


I don't quite get what you're saying here. I think I said "resultants" too quickly before looking at the actual code.

Mathematically, we need to compute

```
gcd( numerator( f(a/b) ), psi)
```
where `f`, `a`, `b`, `psi` are univariate polynomials and only `f` changes. I guess we know that the denominator of `f(a/b)` is `b^d` with `d` the degree of `f`. So we need

```
gcd( b^d f(a/b), psi)
```
Now suppose `c` is such that `a/b = c mod psi`, then we really need

```
gcd( b^d f(c), psi)
```
which equals

```
gcd(f(c), psi)
```
Now compute this in `R[x]/psi(x)` and this should be the most efficient way.

(this was written up quickly, I haven't really checked that it's correct)



---

archive/issue_comments_248810.json:
```json
{
    "body": "<a id='comment:19'></a>Actually, my idea works, but it's not so efficient since you're working mod `psi` which is huge.",
    "created_at": "2015-06-04T10:25:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248810",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:19'></a>Actually, my idea works, but it's not so efficient since you're working mod `psi` which is huge.



---

archive/issue_comments_248811.json:
```json
{
    "body": "<a id='comment:20'></a>I'm going to set this ticket to needs_work such that you can address the several minor points I mentioned (and answer [comment:17], which I need to understand the algorithm better). Never mind the computation of `mult()`.",
    "created_at": "2015-06-04T10:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248811",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:20'></a>I'm going to set this ticket to needs_work such that you can address the several minor points I mentioned (and answer [comment:17], which I need to understand the algorithm better). Never mind the computation of `mult()`.



---

archive/issue_comments_248812.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-06-04T10:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248812",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_248813.json:
```json
{
    "body": "<a id='comment:21'></a>Replying to [comment:8 cremona]:\n> No, but it is Example 3.1.1 on page 28 of [KT2013] which is here: http://wrap.warwick.ac.uk/57568/\n> The example is over F_3 so is not slow.\n\n\nWouldn't it be a good testcase for the current code (both over F_3 and F_9)?",
    "created_at": "2015-06-04T10:35:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248813",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:21'></a>Replying to [comment:8 cremona]:
> No, but it is Example 3.1.1 on page 28 of [KT2013] which is here: http://wrap.warwick.ac.uk/57568/
> The example is over F_3 so is not slow.


Wouldn't it be a good testcase for the current code (both over F_3 and F_9)?



---

archive/issue_comments_248814.json:
```json
{
    "body": "<a id='comment:22'></a>Since you write `Every kernel polynomial is a product of irreducible factors of the division polynomial of the same degree`, could special case 2 apply by just considering the polynomials of a given degree?",
    "created_at": "2015-06-04T11:58:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248814",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:22'></a>Since you write `Every kernel polynomial is a product of irreducible factors of the division polynomial of the same degree`, could special case 2 apply by just considering the polynomials of a given degree?



---

archive/issue_comments_248815.json:
```json
{
    "body": "<a id='comment:23'></a>Thanks for all the comments -- I was busy with other things so have not replied to them indiviually yet, but perhaps it would be clearer if I now did so!",
    "created_at": "2015-06-04T12:13:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248815",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:23'></a>Thanks for all the comments -- I was busy with other things so have not replied to them indiviually yet, but perhaps it would be clearer if I now did so!



---

archive/issue_comments_248816.json:
```json
{
    "body": "<a id='comment:24'></a>Replying to [comment:11 jdemeyer]:\n> In your code, \"special case 1\" is really a special case of \"special case 2\". For simplicity, I would therefore keep only special case 2.\n\n\nAgreed -- done.",
    "created_at": "2015-06-04T12:13:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248816",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:24'></a>Replying to [comment:11 jdemeyer]:
> In your code, "special case 1" is really a special case of "special case 2". For simplicity, I would therefore keep only special case 2.


Agreed -- done.



---

archive/issue_comments_248817.json:
```json
{
    "body": "<a id='comment:25'></a>Replying to [comment:12 jdemeyer]:\n> There is a pre-existing typo: `otain` instead of `obtain`.\n\nDone.",
    "created_at": "2015-06-04T12:14:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248817",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:25'></a>Replying to [comment:12 jdemeyer]:
> There is a pre-existing typo: `otain` instead of `obtain`.

Done.



---

archive/issue_comments_248818.json:
```json
{
    "body": "<a id='comment:26'></a>Replying to [comment:13 jdemeyer]:\n> There is a redundant\n> \n> ```\n> from sage.misc.all import prod\n> ```\n\nDone.",
    "created_at": "2015-06-04T12:14:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248818",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:26'></a>Replying to [comment:13 jdemeyer]:
> There is a redundant
> 
> ```
> from sage.misc.all import prod
> ```

Done.



---

archive/issue_comments_248819.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:15 jdemeyer]:\n> Since the constant `(l-1)//2` appears in several places in the algorithm, I would prefer to see a variable assigned to it (let's call it `D` or whatever).\n\nDone -- I called it l2.",
    "created_at": "2015-06-04T12:16:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248819",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:27'></a>Replying to [comment:15 jdemeyer]:
> Since the constant `(l-1)//2` appears in several places in the algorithm, I would prefer to see a variable assigned to it (let's call it `D` or whatever).

Done -- I called it l2.



---

archive/issue_comments_248820.json:
```json
{
    "body": "<a id='comment:28'></a>Replying to [comment:17 jdemeyer]:\n> In this loop,\n> \n> ```\n>         for i in range((l-1)/(2*d)-1):\n>             g = mult(S[i])\n>             S.append(g)\n>             if g in factors:\n>                 factors.remove(g)\n> ```\n> when can it happen that `g` is not in `factors`?\n\n\nVery good question!  I think it always happens, since the operation f --> mult(f) applies the multiplication-by-a map to the roots, so must take f to another irreducible factor of the same degree;  the fact being checked is that the resulting cycle has the correct length, which is (l-1)/2 divided by deg(f), so that the product of the f's in the cycle gives the kernel polynomial. [I will delete the check.]  I tried removing the check and got run-time errors, so my mathematics must be wrong...",
    "created_at": "2015-06-04T12:36:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248820",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:28'></a>Replying to [comment:17 jdemeyer]:
> In this loop,
> 
> ```
>         for i in range((l-1)/(2*d)-1):
>             g = mult(S[i])
>             S.append(g)
>             if g in factors:
>                 factors.remove(g)
> ```
> when can it happen that `g` is not in `factors`?


Very good question!  I think it always happens, since the operation f --> mult(f) applies the multiplication-by-a map to the roots, so must take f to another irreducible factor of the same degree;  the fact being checked is that the resulting cycle has the correct length, which is (l-1)/2 divided by deg(f), so that the product of the f's in the cycle gives the kernel polynomial. [I will delete the check.]  I tried removing the check and got run-time errors, so my mathematics must be wrong...



---

archive/issue_comments_248821.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:22 jdemeyer]:\n> Since you write `Every kernel polynomial is a product of irreducible factors of the division polynomial of the same degree`, could special case 2 apply by just considering the polynomials of a given degree?\n\n\nYes:  if for some degree d dividing l2=(l-1)/2 there are exactly (l-1)/2d factors then their product must be a kernel poly.\n\nSome more theory:  each subgroup has l2 x-coordinates and the rational function m(x) permutes these in a single cycle (by definition of \"semi-primitive root\" as a class mod l which generates the multiplcative group modulo <-1>).  A kernel poly is a poly of degree l2 whose set of roots is invariant under this map.  Since the map is defined over the ground field, each of the x-coordinates in any subgroup has the same degree d over the base, so d is a divisor of l2 and the kernel poly is a product of l2/d polys of degree d.   On the other hand, an irreducible factor f of degree d (where d didvides l2) need not be a factor of a kernel poly, as the F_3 example with l=13 shows.  If that is the case then the orbit of f under mult() will be longer than l2/d and we will detect that after l2/d steps we have not returned to the start.  In this circumstance we will have removed l2/d factors from the list but this is only *part of* an orbit, so later on when we start with one of the remaining factors in that orbit, we may well iterate onto a factor which is already removed.\n\nThere, I have proved that g need not be in factors!  And more -- if we find a g which is not in factors then we have hit a part-orbit already seen so can break.",
    "created_at": "2015-06-04T13:02:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248821",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:29'></a>Replying to [comment:22 jdemeyer]:
> Since you write `Every kernel polynomial is a product of irreducible factors of the division polynomial of the same degree`, could special case 2 apply by just considering the polynomials of a given degree?


Yes:  if for some degree d dividing l2=(l-1)/2 there are exactly (l-1)/2d factors then their product must be a kernel poly.

Some more theory:  each subgroup has l2 x-coordinates and the rational function m(x) permutes these in a single cycle (by definition of "semi-primitive root" as a class mod l which generates the multiplcative group modulo <-1>).  A kernel poly is a poly of degree l2 whose set of roots is invariant under this map.  Since the map is defined over the ground field, each of the x-coordinates in any subgroup has the same degree d over the base, so d is a divisor of l2 and the kernel poly is a product of l2/d polys of degree d.   On the other hand, an irreducible factor f of degree d (where d didvides l2) need not be a factor of a kernel poly, as the F_3 example with l=13 shows.  If that is the case then the orbit of f under mult() will be longer than l2/d and we will detect that after l2/d steps we have not returned to the start.  In this circumstance we will have removed l2/d factors from the list but this is only *part of* an orbit, so later on when we start with one of the remaining factors in that orbit, we may well iterate onto a factor which is already removed.

There, I have proved that g need not be in factors!  And more -- if we find a g which is not in factors then we have hit a part-orbit already seen so can break.



---

archive/issue_comments_248822.json:
```json
{
    "body": "<a id='comment:30'></a>Replying to [comment:28 cremona]:\n> Very good question!  I think it always happens, since the operation f --> mult(f) applies the multiplication-by-a map to the roots, so must take f to another irreducible factor of the same degree;  the fact being checked is that the resulting cycle has the correct length, which is (l-1)/2 divided by deg(f), so that the product of the f's in the cycle gives the kernel polynomial. [I will delete the check.]  I tried removing the check and got run-time errors, so my mathematics must be wrong...\n\n\nI also used the same thinking as you, and I also don't understand the problem...",
    "created_at": "2015-06-04T13:07:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248822",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:30'></a>Replying to [comment:28 cremona]:
> Very good question!  I think it always happens, since the operation f --> mult(f) applies the multiplication-by-a map to the roots, so must take f to another irreducible factor of the same degree;  the fact being checked is that the resulting cycle has the correct length, which is (l-1)/2 divided by deg(f), so that the product of the f's in the cycle gives the kernel polynomial. [I will delete the check.]  I tried removing the check and got run-time errors, so my mathematics must be wrong...


I also used the same thinking as you, and I also don't understand the problem...



---

archive/issue_comments_248823.json:
```json
{
    "body": "<a id='comment:31'></a>Replying to [comment:30 jdemeyer]:\n> Replying to [comment:28 cremona]:\n> > Very good question!  I think it always happens, since the operation f --> mult(f) applies the multiplication-by-a map to the roots, so must take f to another irreducible factor of the same degree;  the fact being checked is that the resulting cycle has the correct length, which is (l-1)/2 divided by deg(f), so that the product of the f's in the cycle gives the kernel polynomial. [I will delete the check.]  I tried removing the check and got run-time errors, so my mathematics must be wrong...\n\n> \n> I also used the same thinking as you, and I also don't understand the problem...\n\n\nSee comment 29!",
    "created_at": "2015-06-04T13:24:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248823",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:31'></a>Replying to [comment:30 jdemeyer]:
> Replying to [comment:28 cremona]:
> > Very good question!  I think it always happens, since the operation f --> mult(f) applies the multiplication-by-a map to the roots, so must take f to another irreducible factor of the same degree;  the fact being checked is that the resulting cycle has the correct length, which is (l-1)/2 divided by deg(f), so that the product of the f's in the cycle gives the kernel polynomial. [I will delete the check.]  I tried removing the check and got run-time errors, so my mathematics must be wrong...

> 
> I also used the same thinking as you, and I also don't understand the problem...


See comment 29!



---

archive/issue_comments_248824.json:
```json
{
    "body": "<a id='comment:32'></a>OK, I have done quite a rewrite which makes the logic much clearer (I think) and also treats all the special cases together.  New commit soon...",
    "created_at": "2015-06-04T13:36:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248824",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:32'></a>OK, I have done quite a rewrite which makes the logic much clearer (I think) and also treats all the special cases together.  New commit soon...



---

archive/issue_comments_248825.json:
```json
{
    "body": "<a id='comment:33'></a>Replying to [comment:14 cremona]:\n> Without the patch though I would not have been able to compute this:  http://beta.lmfdb.org/EllipticCurve/2.2.89.1/81.1/a/ !!\n\n\nI'm actually curious why you get a huge speed-up here. I can see that the patch here improves things, but to go from \"not being able to compute\" to \"being able to compute\" surprises me. Doesn't the computation and factoring of the division polynomial dominate the whole computation anyway?",
    "created_at": "2015-06-04T13:38:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248825",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:33'></a>Replying to [comment:14 cremona]:
> Without the patch though I would not have been able to compute this:  http://beta.lmfdb.org/EllipticCurve/2.2.89.1/81.1/a/ !!


I'm actually curious why you get a huge speed-up here. I can see that the patch here improves things, but to go from "not being able to compute" to "being able to compute" surprises me. Doesn't the computation and factoring of the division polynomial dominate the whole computation anyway?



---

archive/issue_comments_248826.json:
```json
{
    "body": "<a id='comment:34'></a>Replying to [comment:33 jdemeyer]:\n> Replying to [comment:14 cremona]:\n> > Without the patch though I would not have been able to compute this:  http://beta.lmfdb.org/EllipticCurve/2.2.89.1/81.1/a/ !!\n\n> \n> I'm actually curious why you get a huge speed-up here. I can see that the patch here improves things, but to go from \"not being able to compute\" to \"being able to compute\" surprises me. Doesn't the computation and factoring of the division polynomial dominate the whole computation anyway?\n\n\nIts computation is short, and its factoring takes < 1 hour.  In the code I had, computing the complete isogeny class of 4 curves, I had to do that 4 times.  (I am working on not having to recompute the kernel polys for other curves in the isogeny class, but that will definitely be another ticket).  I also had some lines like E1.is_isogenous(E2,proof=True) which triggered computation of the whole isogeny class of E1.  (With proof=False it just checks traces of Frobenius but I also had curves which were not isogenous but whose traces agreed at a lot of primes, so was playing safe).",
    "created_at": "2015-06-04T14:04:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248826",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:34'></a>Replying to [comment:33 jdemeyer]:
> Replying to [comment:14 cremona]:
> > Without the patch though I would not have been able to compute this:  http://beta.lmfdb.org/EllipticCurve/2.2.89.1/81.1/a/ !!

> 
> I'm actually curious why you get a huge speed-up here. I can see that the patch here improves things, but to go from "not being able to compute" to "being able to compute" surprises me. Doesn't the computation and factoring of the division polynomial dominate the whole computation anyway?


Its computation is short, and its factoring takes < 1 hour.  In the code I had, computing the complete isogeny class of 4 curves, I had to do that 4 times.  (I am working on not having to recompute the kernel polys for other curves in the isogeny class, but that will definitely be another ticket).  I also had some lines like E1.is_isogenous(E2,proof=True) which triggered computation of the whole isogeny class of E1.  (With proof=False it just checks traces of Frobenius but I also had curves which were not isogenous but whose traces agreed at a lot of primes, so was playing safe).



---

archive/issue_comments_248827.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-04T14:36:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248827",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_248828.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-06-04T14:38:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248828",
    "user": "https://github.com/JohnCremona"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_248829.json:
```json
{
    "body": "<a id='comment:36'></a>Please take a look at this.  the code is (I hope) simpler to understand, deals with factors of each degree separately, and has more explanatory comments.  I experimented with a couple of other version of mult(), one of which is there but commented out, but they were no faster.  I also added a new example as discussed above.",
    "created_at": "2015-06-04T14:38:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248829",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:36'></a>Please take a look at this.  the code is (I hope) simpler to understand, deals with factors of each degree separately, and has more explanatory comments.  I experimented with a couple of other version of mult(), one of which is there but commented out, but they were no faster.  I also added a new example as discussed above.



---

archive/issue_comments_248830.json:
```json
{
    "body": "<a id='comment:37'></a>Replying to [comment:34 cremona]:\n> Its computation is short, and its factoring takes < 1 hour.\n\nThen why did the computation of the isogenies without this patch take days? What was the bottleneck? I find it hard to believe that the calls to `mult()` can take so much time.",
    "created_at": "2015-06-04T14:42:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248830",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:37'></a>Replying to [comment:34 cremona]:
> Its computation is short, and its factoring takes < 1 hour.

Then why did the computation of the isogenies without this patch take days? What was the bottleneck? I find it hard to believe that the calls to `mult()` can take so much time.



---

archive/issue_comments_248831.json:
```json
{
    "body": "<a id='comment:38'></a>In the current implementation, you are computing\n\n```\n    from sage.rings.arith import gcd\n    a = _least_semi_primitive(l)\n    m = E.multiplication_by_m(a, x_only=True)\n    F = psi_l.parent()\n    x = F.gen()\n    d = F(m.denominator())\n    n = F(m.numerator())\n```\neven when `factors_by_degree` is empty.\n\nAn easy optimization would be\n\n```\nif all(factors == [] for factors in factors_by_degree):\n    return ...\n```\njust before that block.",
    "created_at": "2015-06-04T14:51:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248831",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:38'></a>In the current implementation, you are computing

```
    from sage.rings.arith import gcd
    a = _least_semi_primitive(l)
    m = E.multiplication_by_m(a, x_only=True)
    F = psi_l.parent()
    x = F.gen()
    d = F(m.denominator())
    n = F(m.numerator())
```
even when `factors_by_degree` is empty.

An easy optimization would be

```
if all(factors == [] for factors in factors_by_degree):
    return ...
```
just before that block.



---

archive/issue_comments_248832.json:
```json
{
    "body": "<a id='comment:39'></a>I think you can simplify\n\n```\nfactors = [h for h,e in psi_l.factor() if l2 % h.degree() == 0]\n```\nto\n\n```\nfactors = [h for h,e in psi_l.factor()]\n```\n(in the line below, you are only selecting the degrees you care about anyway)",
    "created_at": "2015-06-04T14:53:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248832",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:39'></a>I think you can simplify

```
factors = [h for h,e in psi_l.factor() if l2 % h.degree() == 0]
```
to

```
factors = [h for h,e in psi_l.factor()]
```
(in the line below, you are only selecting the degrees you care about anyway)



---

archive/issue_comments_248833.json:
```json
{
    "body": "<a id='comment:40'></a>Replying to [comment:37 jdemeyer]:\n> Replying to [comment:34 cremona]:\n> > Its computation is short, and its factoring takes < 1 hour.\n\n> Then why did the computation of the isogenies without this patch take days? What was the bottleneck? I find it hard to believe that the calls to `mult()` can take so much time.\n\nMe too, but as I tried to explain the script I was running was computing the isogeny class many times.  I am rerunning just E.isogeny_class() under 6.7 now and will report back (but this ticket need not wait).",
    "created_at": "2015-06-04T15:25:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248833",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:40'></a>Replying to [comment:37 jdemeyer]:
> Replying to [comment:34 cremona]:
> > Its computation is short, and its factoring takes < 1 hour.

> Then why did the computation of the isogenies without this patch take days? What was the bottleneck? I find it hard to believe that the calls to `mult()` can take so much time.

Me too, but as I tried to explain the script I was running was computing the isogeny class many times.  I am rerunning just E.isogeny_class() under 6.7 now and will report back (but this ticket need not wait).



---

archive/issue_comments_248834.json:
```json
{
    "body": "<a id='comment:41'></a>Replying to [comment:39 jdemeyer]:\n> I think you can simplify\n> \n> ```\n> factors = [h for h,e in psi_l.factor() if l2 % h.degree() == 0]\n> ```\n> to\n> \n> ```\n> factors = [h for h,e in psi_l.factor()]\n> ```\n> (in the line below, you are only selecting the degrees you care about anyway)\n\n\nFine, I will make these simplifications!",
    "created_at": "2015-06-04T15:26:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248834",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:41'></a>Replying to [comment:39 jdemeyer]:
> I think you can simplify
> 
> ```
> factors = [h for h,e in psi_l.factor() if l2 % h.degree() == 0]
> ```
> to
> 
> ```
> factors = [h for h,e in psi_l.factor()]
> ```
> (in the line below, you are only selecting the degrees you care about anyway)


Fine, I will make these simplifications!



---

archive/issue_comments_248835.json:
```json
{
    "body": "<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-04T15:39:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248835",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_248836.json:
```json
{
    "body": "<a id='comment:43'></a>Replying to [comment:40 cremona]:\n> Me too, but as I tried to explain the script I was running was computing the isogeny class many times.  I am rerunning just E.isogeny_class() under 6.7 now and will report back (but this ticket need not wait).\n\n\nI agree that this ticket makes sense by itself. It's just that it only does some easy optimizations, it doesn't fundamentally improve the algorithm.\n\nI have been thinking a bit about the computation of `mult()` this afternoon and I might have an idea to compute `mult^-1(f)` (that is, find `g` such that `mult(g) == f`) much faster than the current `mult()`. Of course, theoretically, `mult()` and `mult^-1()` play the same role.\n\nI'm wondering if it's worth pursuing further and for that I need to know if `mult()` is ever the bottleneck of the algorithm. (this is of course for a hypothetical follow-up ticket)",
    "created_at": "2015-06-04T15:41:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248836",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:43'></a>Replying to [comment:40 cremona]:
> Me too, but as I tried to explain the script I was running was computing the isogeny class many times.  I am rerunning just E.isogeny_class() under 6.7 now and will report back (but this ticket need not wait).


I agree that this ticket makes sense by itself. It's just that it only does some easy optimizations, it doesn't fundamentally improve the algorithm.

I have been thinking a bit about the computation of `mult()` this afternoon and I might have an idea to compute `mult^-1(f)` (that is, find `g` such that `mult(g) == f`) much faster than the current `mult()`. Of course, theoretically, `mult()` and `mult^-1()` play the same role.

I'm wondering if it's worth pursuing further and for that I need to know if `mult()` is ever the bottleneck of the algorithm. (this is of course for a hypothetical follow-up ticket)



---

archive/issue_comments_248837.json:
```json
{
    "body": "<a id='comment:44'></a>Replying to [comment:42 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> |                                                                                                                                          |                                            |\n> |------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n> |[2f83c20](http://git.sagemath.org/sage.git/commit/?id=2f83c20a3753b9141c635ab26ed88015a9fed499)|`#18589: 2 simplifications following review`|\n\n\nThe check `not factors_by_degree` only checks that the dict has no keys, but you really need to check that all values are empty lists:\n\n```\nall(factors == [] for factors in factors_by_degree.values())\n```",
    "created_at": "2015-06-04T15:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248837",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:44'></a>Replying to [comment:42 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> |                                                                                                                                          |                                            |
> |------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
> |[2f83c20](http://git.sagemath.org/sage.git/commit/?id=2f83c20a3753b9141c635ab26ed88015a9fed499)|`#18589: 2 simplifications following review`|


The check `not factors_by_degree` only checks that the dict has no keys, but you really need to check that all values are empty lists:

```
all(factors == [] for factors in factors_by_degree.values())
```



---

archive/issue_comments_248838.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-06-04T15:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248838",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_248839.json:
```json
{
    "body": "<a id='comment:45'></a>Replying to [comment:43 jdemeyer]:\n> Replying to [comment:40 cremona]:\n> > Me too, but as I tried to explain the script I was running was computing the isogeny class many times.  I am rerunning just E.isogeny_class() under 6.7 now and will report back (but this ticket need not wait).\n\n> \n> I agree that this ticket makes sense by itself. It's just that it only does some easy optimizations, it doesn't fundamentally improve the algorithm.\n\n\nAgreed.\n\n> \n> I have been thinking a bit about the computation of `mult()` this afternoon and I might have an idea to compute `mult^-1(f)` (that is, find `g` such that `mult(g) == f`) much faster than the current `mult()`. Of course, theoretically, `mult()` and `mult^-1()` play the same role.\n\n\nThat is true -- you can use either.  You can see in Prop 3.3.1 of the thesis that both are natural!  It would be good to improve this.\n\n> \n> I'm wondering if it's worth pursuing further and for that I need to know if `mult()` is ever the bottleneck of the algorithm. (this is of course for a hypothetical follow-up ticket)",
    "created_at": "2015-06-04T15:45:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248839",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:45'></a>Replying to [comment:43 jdemeyer]:
> Replying to [comment:40 cremona]:
> > Me too, but as I tried to explain the script I was running was computing the isogeny class many times.  I am rerunning just E.isogeny_class() under 6.7 now and will report back (but this ticket need not wait).

> 
> I agree that this ticket makes sense by itself. It's just that it only does some easy optimizations, it doesn't fundamentally improve the algorithm.


Agreed.

> 
> I have been thinking a bit about the computation of `mult()` this afternoon and I might have an idea to compute `mult^-1(f)` (that is, find `g` such that `mult(g) == f`) much faster than the current `mult()`. Of course, theoretically, `mult()` and `mult^-1()` play the same role.


That is true -- you can use either.  You can see in Prop 3.3.1 of the thesis that both are natural!  It would be good to improve this.

> 
> I'm wondering if it's worth pursuing further and for that I need to know if `mult()` is ever the bottleneck of the algorithm. (this is of course for a hypothetical follow-up ticket)



---

archive/issue_comments_248840.json:
```json
{
    "body": "<a id='comment:46'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-04T15:50:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248840",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:46'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_248841.json:
```json
{
    "body": "<a id='comment:47'></a>Replying to [comment:44 jdemeyer]:\n> Replying to [comment:42 git]:\n> > Branch pushed to git repo; I updated commit sha1. New commits:\n> > |                                                                                                                                          |                                            |\n> > |------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n> > |[2f83c20](http://git.sagemath.org/sage.git/commit/?id=2f83c20a3753b9141c635ab26ed88015a9fed499)|`#18589: 2 simplifications following review`|\n\n> \n> The check `not factors_by_degree` only checks that the dict has no keys, but you really need to check that all values are empty lists:\n> \n> ```\n> all(factors == [] for factors in factors_by_degree.values())\n> ```\n\n\nYou are right, I had forgotten that in creating the dict it might have had some empty lists.  I should have known better than to do more simplifaction than you recommended!\n\n---\nNew commits:\n|                                                                                                                                          |                          |\n|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------|\n|[3d687e5](http://git.sagemath.org/sage.git/commit/?id=3d687e5225f67808eb6c5af5fbf4cb93f2000c62)|`#18589 further one-liner`|\n---\nNew commits:",
    "created_at": "2015-06-04T15:50:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248841",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:47'></a>Replying to [comment:44 jdemeyer]:
> Replying to [comment:42 git]:
> > Branch pushed to git repo; I updated commit sha1. New commits:
> > |                                                                                                                                          |                                            |
> > |------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
> > |[2f83c20](http://git.sagemath.org/sage.git/commit/?id=2f83c20a3753b9141c635ab26ed88015a9fed499)|`#18589: 2 simplifications following review`|

> 
> The check `not factors_by_degree` only checks that the dict has no keys, but you really need to check that all values are empty lists:
> 
> ```
> all(factors == [] for factors in factors_by_degree.values())
> ```


You are right, I had forgotten that in creating the dict it might have had some empty lists.  I should have known better than to do more simplifaction than you recommended!

---
New commits:
|                                                                                                                                          |                          |
|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------|
|[3d687e5](http://git.sagemath.org/sage.git/commit/?id=3d687e5225f67808eb6c5af5fbf4cb93f2000c62)|`#18589 further one-liner`|
---
New commits:



---

archive/issue_comments_248842.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-06-04T15:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248842",
    "user": "https://github.com/JohnCremona"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_248843.json:
```json
{
    "body": "<a id='comment:48'></a>Any further changes will have to wait until tomorrow....",
    "created_at": "2015-06-04T15:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248843",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:48'></a>Any further changes will have to wait until tomorrow....



---

archive/issue_comments_248844.json:
```json
{
    "body": "<a id='comment:49'></a>Further work: #18611",
    "created_at": "2015-06-04T19:45:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248844",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:49'></a>Further work: #18611



---

archive/issue_comments_248845.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-06-04T19:45:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248845",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_248846.json:
```json
{
    "body": "<a id='comment:50'></a>Many thanks for a fantastic job reviewing this ( excelletn in both mathematical and coding aspects).  I will continue the discussion over at #18611.\n\nI suspect that there have been other changes since 6.7 which have sped up my l=89 example, to do with factoring the 89-division polynomial over a quadratic field.  As you say, one computation of mult() could not take such a long time even before this patch, yet a single run of E.isogenies_prime_degree(89) is stil running after 14 hours, and all that has to do is run isogenies_prime_degree_general once with l=89.",
    "created_at": "2015-06-05T08:10:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248846",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:50'></a>Many thanks for a fantastic job reviewing this ( excelletn in both mathematical and coding aspects).  I will continue the discussion over at #18611.

I suspect that there have been other changes since 6.7 which have sped up my l=89 example, to do with factoring the 89-division polynomial over a quadratic field.  As you say, one computation of mult() could not take such a long time even before this patch, yet a single run of E.isogenies_prime_degree(89) is stil running after 14 hours, and all that has to do is run isogenies_prime_degree_general once with l=89.



---

archive/issue_comments_248847.json:
```json
{
    "body": "<a id='comment:51'></a>Replying to [comment:50 cremona]:\n> yet a single run of E.isogenies_prime_degree(89) is stil running after 14 hours\n\n\nCan you interrupt (CTRL-C) it and look at the traceback to see what it's doing?",
    "created_at": "2015-06-05T08:28:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248847",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:51'></a>Replying to [comment:50 cremona]:
> yet a single run of E.isogenies_prime_degree(89) is stil running after 14 hours


Can you interrupt (CTRL-C) it and look at the traceback to see what it's doing?



---

archive/issue_comments_248848.json:
```json
{
    "body": "<a id='comment:52'></a>Replying to [comment:51 jdemeyer]:\n> Replying to [comment:50 cremona]:\n> > yet a single run of E.isogenies_prime_degree(89) is stil running after 14 hours\n\n> \n> Can you interrupt (CTRL-C) it and look at the traceback to see what it's doing?\n\n\nAs expected:  it is in the lines \n\n```\n-> 1939         if mult(S[-1]) == f:\n```\nand \n\n```\n-> 1928         return gcd(F(f(m(x)).numerator()),psi_l).monic()\n```\nand\n\n```\n-> 1588             return a.gcd(b, **kwargs)\n```\nand below that\n\n```\n/usr/local/sage/sage-2/src/sage/rings/polynomial/polynomial_number_field.pyx in sage.rings.poly\nnomial.polynomial_number_field.Polynomial_absolute_number_field_dense.gcd (build/cythonized/sag\ne/rings/polynomial/polynomial_number_field.c:1761)()\n    203         h1 = self._pari_with_name('x')\n    204         h2 = other._pari_with_name('x')\n--> 205         g = h1.gcd(h2)\n```\nand at the bottom, pari/gen.pyx",
    "created_at": "2015-06-05T08:36:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248848",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:52'></a>Replying to [comment:51 jdemeyer]:
> Replying to [comment:50 cremona]:
> > yet a single run of E.isogenies_prime_degree(89) is stil running after 14 hours

> 
> Can you interrupt (CTRL-C) it and look at the traceback to see what it's doing?


As expected:  it is in the lines 

```
-> 1939         if mult(S[-1]) == f:
```
and 

```
-> 1928         return gcd(F(f(m(x)).numerator()),psi_l).monic()
```
and

```
-> 1588             return a.gcd(b, **kwargs)
```
and below that

```
/usr/local/sage/sage-2/src/sage/rings/polynomial/polynomial_number_field.pyx in sage.rings.poly
nomial.polynomial_number_field.Polynomial_absolute_number_field_dense.gcd (build/cythonized/sag
e/rings/polynomial/polynomial_number_field.c:1761)()
    203         h1 = self._pari_with_name('x')
    204         h2 = other._pari_with_name('x')
--> 205         g = h1.gcd(h2)
```
and at the bottom, pari/gen.pyx



---

archive/issue_comments_248849.json:
```json
{
    "body": "<a id='comment:53'></a>Thanks for the info.\n\nInteresting, it looks like the `gcd()` computation in `mult()` takes so much time. I would assume that some kind of coefficient explosion occurs.",
    "created_at": "2015-06-05T08:51:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248849",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:53'></a>Thanks for the info.

Interesting, it looks like the `gcd()` computation in `mult()` takes so much time. I would assume that some kind of coefficient explosion occurs.



---

archive/issue_comments_248850.json:
```json
{
    "body": "<a id='comment:54'></a>Replying to [comment:53 jdemeyer]:\n> Thanks for the info.\n> \n> Interesting, it looks like the `gcd()` computation in `mult()` takes so much time. I would assume that some kind of coefficient explosion occurs.\n\nI think that the real point here is http://trac.sagemath.org/ticket/18461 which re-implemented univariate polynomial gcd!  So it is possible that without any of the changes on this ticket or #18611 we would have seen anoticeable improvement.  Anyway, between these two tickets we certainly have more efficient code so the exercise was worth carrying out.  Thanks!",
    "created_at": "2015-06-05T08:57:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248850",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:54'></a>Replying to [comment:53 jdemeyer]:
> Thanks for the info.
> 
> Interesting, it looks like the `gcd()` computation in `mult()` takes so much time. I would assume that some kind of coefficient explosion occurs.

I think that the real point here is http://trac.sagemath.org/ticket/18461 which re-implemented univariate polynomial gcd!  So it is possible that without any of the changes on this ticket or #18611 we would have seen anoticeable improvement.  Anyway, between these two tickets we certainly have more efficient code so the exercise was worth carrying out.  Thanks!



---

archive/issue_comments_248851.json:
```json
{
    "body": "<a id='comment:55'></a>Replying to [comment:54 cremona]:\n> Replying to [comment:53 jdemeyer]:\n> > Thanks for the info.\n> > \n> > Interesting, it looks like the `gcd()` computation in `mult()` takes so much time. I would assume that some kind of coefficient explosion occurs.\n\n> I think that the real point here is http://trac.sagemath.org/ticket/18461 which re-implemented univariate polynomial gcd!\nFrom the traceback, you see that PARI is used to compute this gcd, so the generic Sage code doesn't matter.",
    "created_at": "2015-06-05T09:11:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248851",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:55'></a>Replying to [comment:54 cremona]:
> Replying to [comment:53 jdemeyer]:
> > Thanks for the info.
> > 
> > Interesting, it looks like the `gcd()` computation in `mult()` takes so much time. I would assume that some kind of coefficient explosion occurs.

> I think that the real point here is http://trac.sagemath.org/ticket/18461 which re-implemented univariate polynomial gcd!
From the traceback, you see that PARI is used to compute this gcd, so the generic Sage code doesn't matter.



---

archive/issue_comments_248852.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-06-06T12:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18589#issuecomment-248852",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_052196.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-06-06T12:47:44Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18589",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18589#event-52196"
}
```
