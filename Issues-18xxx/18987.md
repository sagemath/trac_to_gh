# Issue 18987: Parallel computation of number of solutions in dancing links

archive/issues_018750.json:
```json
{
    "body": "The following computation takes a lot of time:\n\n```\nsage: from sage.games.quantumino import QuantuminoSolver\nsage: QuantuminoSolver(0).number_of_solutions()  # long time (several days)\n```\n\nbut we can make it faster by doing the computation in parallel... This ticket does this (directly in the dancing links code).\n\nIssue created by migration from https://trac.sagemath.org/ticket/18987\n\n",
    "closed_at": "2015-09-08T14:41:15Z",
    "created_at": "2015-08-04T13:19:14Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "Parallel computation of number of solutions in dancing links",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18987",
    "user": "https://github.com/seblabbe"
}
```
The following computation takes a lot of time:

```
sage: from sage.games.quantumino import QuantuminoSolver
sage: QuantuminoSolver(0).number_of_solutions()  # long time (several days)
```

but we can make it faster by doing the computation in parallel... This ticket does this (directly in the dancing links code).

Issue created by migration from https://trac.sagemath.org/ticket/18987





---

archive/issue_comments_255691.json:
```json
{
    "body": "Preliminary version. Not ready for review.\n\n---\nNew commits:",
    "created_at": "2015-08-04T13:23:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255691",
    "user": "https://github.com/seblabbe"
}
```

Preliminary version. Not ready for review.

---
New commits:



---

archive/issue_comments_255692.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-04T13:31:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255692",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255693.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-04T19:41:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255693",
    "user": "https://github.com/seblabbe"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_255694.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-08-04T19:41:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255694",
    "user": "https://github.com/seblabbe"
}
```

New commits:



---

archive/issue_comments_255695.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-04T19:48:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255695",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_255696.json:
```json
{
    "body": "Still other stuff to improve...",
    "created_at": "2015-08-04T19:48:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255696",
    "user": "https://github.com/seblabbe"
}
```

Still other stuff to improve...



---

archive/issue_comments_255697.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-04T21:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255697",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255698.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-04T21:10:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255698",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_255699.json:
```json
{
    "body": "Ok, now needs reviews. I won't rebase my branch anymore.",
    "created_at": "2015-08-04T21:10:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255699",
    "user": "https://github.com/seblabbe"
}
```

Ok, now needs reviews. I won't rebase my branch anymore.



---

archive/issue_comments_255700.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-09T18:09:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255700",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_255701.json:
```json
{
    "body": "Salut Sebastien,\n\nDo you mind if I rebase over 6.9.beta1? Note that I also have a waiting commit that does some tiny optimization to `dancing_links.pyx`.\n\nI am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling \"parallelization dancing links\" already gives a lot of things.\n\nLess importantly:\n- I do not understand the name of the function `orthogonal_transformation`. Are these the orthogonal transformations of `R^3` with integer coordinates? If so, please write more precise specifications.\n\n- As far as I see, you do not test all cases of the function `orthogonal_transformation`.\n\n- What is the `modpi` arguments. What is a rotation of angle `pi` for you? Is it a linear transformation that is a pi-rotation restricted on a plane and leaves invariant the orthogonal complement? (I guess it should also have integer coordinates) If this is, then it is of course not a group... but of course you might consider the group generated by these.\n\nVincent",
    "created_at": "2015-08-09T18:09:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255701",
    "user": "https://github.com/videlec"
}
```

Salut Sebastien,

Do you mind if I rebase over 6.9.beta1? Note that I also have a waiting commit that does some tiny optimization to `dancing_links.pyx`.

I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling "parallelization dancing links" already gives a lot of things.

Less importantly:
- I do not understand the name of the function `orthogonal_transformation`. Are these the orthogonal transformations of `R^3` with integer coordinates? If so, please write more precise specifications.

- As far as I see, you do not test all cases of the function `orthogonal_transformation`.

- What is the `modpi` arguments. What is a rotation of angle `pi` for you? Is it a linear transformation that is a pi-rotation restricted on a plane and leaves invariant the orthogonal complement? (I guess it should also have integer coordinates) If this is, then it is of course not a group... but of course you might consider the group generated by these.

Vincent



---

archive/issue_comments_255702.json:
```json
{
    "body": "Replying to [comment:9 vdelecroix]:\n> Salut Sebastien,\n> \n> Do you mind if I rebase over 6.9.beta1? \n\n\nMerge or rebase? I prefer if you merge. Or I can rebase on 6.9.beta1 to keep the authorship (right?).\n\n> Note that I also have a waiting commit that does some tiny optimization to `dancing_links.pyx`.\n\n\nWhere?\n\n> I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling \"parallelization dancing links\" already gives a lot of things.\n\n\nIndeed, I am using a parallelization strategy that applies to a tiling problem where each piece is used only once. This strategy obviously does not apply to the general problem that is the Exact cover problem.\n\nAlso, I prefered to cut the (tiling) problem into subproblems that takes at most 2-3 hours each so that I can more easily follow the process of the computation and stop and restart the computation more easily. Even with a parallel implementation of dancing links, the computation would take days to finish.",
    "created_at": "2015-08-09T20:07:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255702",
    "user": "https://github.com/seblabbe"
}
```

Replying to [comment:9 vdelecroix]:
> Salut Sebastien,
> 
> Do you mind if I rebase over 6.9.beta1? 


Merge or rebase? I prefer if you merge. Or I can rebase on 6.9.beta1 to keep the authorship (right?).

> Note that I also have a waiting commit that does some tiny optimization to `dancing_links.pyx`.


Where?

> I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling "parallelization dancing links" already gives a lot of things.


Indeed, I am using a parallelization strategy that applies to a tiling problem where each piece is used only once. This strategy obviously does not apply to the general problem that is the Exact cover problem.

Also, I prefered to cut the (tiling) problem into subproblems that takes at most 2-3 hours each so that I can more easily follow the process of the computation and stop and restart the computation more easily. Even with a parallel implementation of dancing links, the computation would take days to finish.



---

archive/issue_comments_255703.json:
```json
{
    "body": "Replying to [comment:10 slabbe]:\n> Replying to [comment:9 vdelecroix]:\n> > Salut Sebastien,\n> > \n> > Do you mind if I rebase over 6.9.beta1? \n\n> \n> Merge or rebase? I prefer if you merge. Or I can rebase on 6.9.beta1 to keep the authorship (right?).\n\n\nThe autorship of what? If I do a rebase, you keep the autorship of commits. But of course it will be my branch (or a public one).\n\nI do prefer rebase over merge because:\n- history is much cleaner afterwards (fewer commits that follow each other)\n- you can hide whatever you want in a merge commit\n\n> > Note that I also have a waiting commit that does some tiny optimization to `dancing_links.pyx`.\n\n> \n> Where?\n\n\nOn my computer ;-) It is waiting for the rebase or merge.\n\n> > I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling \"parallelization dancing links\" already gives a lot of things.\n\n> \n> Indeed, I am using a parallelization strategy that applies to a tiling problem where each piece is used only once. This strategy obviously does not apply to the general problem that is the Exact cover problem.\n\n\nIn the exact cover problem, each subset is used at most once. In your tiling formulation a piece count for several subsets. You can naively apply the same thing for dancing links: look at one position `i0` and consider the set `S0` of subsets that cover it. For each subset in `S0`, launch a thread where you only run through the subproblem that consists of having fixed this subset.\n\nBut I guess that there exists less naive parallelization.\n\n> Also, I prefered to cut the (tiling) problem into subproblems that takes at most 2-3 hours each so that I can more easily follow the process of the computation and stop and restart the computation more easily. Even with a parallel implementation of dancing links, the computation would take days to finish.\n\n\nWhy? If your parallization ends with a time better than `total_time / nb_cpus` then you should parallelize more often ;-)\n\nVincent",
    "created_at": "2015-08-09T20:18:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255703",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:10 slabbe]:
> Replying to [comment:9 vdelecroix]:
> > Salut Sebastien,
> > 
> > Do you mind if I rebase over 6.9.beta1? 

> 
> Merge or rebase? I prefer if you merge. Or I can rebase on 6.9.beta1 to keep the authorship (right?).


The autorship of what? If I do a rebase, you keep the autorship of commits. But of course it will be my branch (or a public one).

I do prefer rebase over merge because:
- history is much cleaner afterwards (fewer commits that follow each other)
- you can hide whatever you want in a merge commit

> > Note that I also have a waiting commit that does some tiny optimization to `dancing_links.pyx`.

> 
> Where?


On my computer ;-) It is waiting for the rebase or merge.

> > I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling "parallelization dancing links" already gives a lot of things.

> 
> Indeed, I am using a parallelization strategy that applies to a tiling problem where each piece is used only once. This strategy obviously does not apply to the general problem that is the Exact cover problem.


In the exact cover problem, each subset is used at most once. In your tiling formulation a piece count for several subsets. You can naively apply the same thing for dancing links: look at one position `i0` and consider the set `S0` of subsets that cover it. For each subset in `S0`, launch a thread where you only run through the subproblem that consists of having fixed this subset.

But I guess that there exists less naive parallelization.

> Also, I prefered to cut the (tiling) problem into subproblems that takes at most 2-3 hours each so that I can more easily follow the process of the computation and stop and restart the computation more easily. Even with a parallel implementation of dancing links, the computation would take days to finish.


Why? If your parallization ends with a time better than `total_time / nb_cpus` then you should parallelize more often ;-)

Vincent



---

archive/issue_comments_255704.json:
```json
{
    "body": "> Less importantly:\n> - I do not understand the name of the function `orthogonal_transformation`.\n\n\nI chose that name 3 years ago. I agree it was not the best function name.\n\nYour comments are very good. The reason that things are not clearly written is that it is not clear enough in my head. Let me sleep this night and I will come back on this tomorrow or later this week.\n\nWhen `modpi=True`, I (think! I) want to quotient the result by the group generated by the diagonal matrices of 1's and -1's with exactly two -1 on the diagonal. Only, when the dimension is 3, I was able to generate representative of the classes easily.",
    "created_at": "2015-08-09T20:20:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255704",
    "user": "https://github.com/seblabbe"
}
```

> Less importantly:
> - I do not understand the name of the function `orthogonal_transformation`.


I chose that name 3 years ago. I agree it was not the best function name.

Your comments are very good. The reason that things are not clearly written is that it is not clear enough in my head. Let me sleep this night and I will come back on this tomorrow or later this week.

When `modpi=True`, I (think! I) want to quotient the result by the group generated by the diagonal matrices of 1's and -1's with exactly two -1 on the diagonal. Only, when the dimension is 3, I was able to generate representative of the classes easily.



---

archive/issue_comments_255705.json:
```json
{
    "body": "> Why? If your parallization ends with a time better than `total_time / nb_cpus` then you should parallelize more often ;-)\n\n\nI have 240 subproblems each of them taking between 20 minutes and 10 hours of computation. But my machine at work only have 4 cores. So one way or the other, the computation takes days to finish since I do not have access to a super machine.",
    "created_at": "2015-08-09T20:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255705",
    "user": "https://github.com/seblabbe"
}
```

> Why? If your parallization ends with a time better than `total_time / nb_cpus` then you should parallelize more often ;-)


I have 240 subproblems each of them taking between 20 minutes and 10 hours of computation. But my machine at work only have 4 cores. So one way or the other, the computation takes days to finish since I do not have access to a super machine.



---

archive/issue_comments_255706.json:
```json
{
    "body": "> I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling \"parallelization dancing links\" already gives a lot of things.\n\n\nIf you agree, I suggest to move the discussion of \"parallelization dancing links\" in another ticket for which I am willing to be a reviewer.",
    "created_at": "2015-08-09T20:31:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255706",
    "user": "https://github.com/seblabbe"
}
```

> I am not sure the overall strategy is the good one. If parallelization is needed I guess that it should better be implemented at the level of dancing links. Googling "parallelization dancing links" already gives a lot of things.


If you agree, I suggest to move the discussion of "parallelization dancing links" in another ticket for which I am willing to be a reviewer.



---

archive/issue_comments_255707.json:
```json
{
    "body": "Replying to [comment:13 slabbe]:\n> > Why? If your parallization ends with a time better than `total_time / nb_cpus` then you should parallelize more often ;-)\n\n> \n> I have 240 subproblems each of them taking between 20 minutes and 10 hours of computation. But my machine at work only have 4 cores. So one way or the other, the computation takes days to finish since I do not have access to a super machine.\n\n\nThis looks very bad. At the end, you might end up with only one core working on the biggest subinstance. And it can lasts several days even with 200 cores. Ideally, you should slice the problem in such way that each subinstance will not take longer than 1 hour (let say). This is why adopting a less naive strategy at the level of dancing links seems to me the best option since people already worked on it.\n\nThere is no super computer in Liege? I can set an invitation to use the very powerful [Plafrim](https://plafrim.bordeaux.inria.fr/doku.php) in Bordeaux. But it is some work to learn how to use it (e.g. you need to tell in advance for how long you request the processors).\n\nVincent",
    "created_at": "2015-08-09T20:36:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255707",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:13 slabbe]:
> > Why? If your parallization ends with a time better than `total_time / nb_cpus` then you should parallelize more often ;-)

> 
> I have 240 subproblems each of them taking between 20 minutes and 10 hours of computation. But my machine at work only have 4 cores. So one way or the other, the computation takes days to finish since I do not have access to a super machine.


This looks very bad. At the end, you might end up with only one core working on the biggest subinstance. And it can lasts several days even with 200 cores. Ideally, you should slice the problem in such way that each subinstance will not take longer than 1 hour (let say). This is why adopting a less naive strategy at the level of dancing links seems to me the best option since people already worked on it.

There is no super computer in Liege? I can set an invitation to use the very powerful [Plafrim](https://plafrim.bordeaux.inria.fr/doku.php) in Bordeaux. But it is some work to learn how to use it (e.g. you need to tell in advance for how long you request the processors).

Vincent



---

archive/issue_comments_255708.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-09T20:45:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255708",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255709.json:
```json
{
    "body": "Quickly reading [1] (which looks serious but not very deep) it seems that it is hard to find subinstance of the problems that are well scaled for a given cluster.\n\n  [1] S. M. Ashraful Kadir, \"A Parallel Programming Approach to Solve the Exact Cover Problem\"",
    "created_at": "2015-08-09T20:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255709",
    "user": "https://github.com/videlec"
}
```

Quickly reading [1] (which looks serious but not very deep) it seems that it is hard to find subinstance of the problems that are well scaled for a given cluster.

  [1] S. M. Ashraful Kadir, "A Parallel Programming Approach to Solve the Exact Cover Problem"



---

archive/issue_comments_255710.json:
```json
{
    "body": "> This looks very bad. At the end, you might end up with only one core working on the biggest subinstance. And it can lasts several days even with 200 cores. Ideally, you should slice the problem in such way that each subinstance will not take longer than 1 hour (let say).\n\n\nIt is not very bad as most of the 240 computations takes the same amount of time (about 2 to 3 hours). Maybe 5 of time takes more (10 hours). So I am using the four cores at least 95% of the time. In my case, I have very good subinstances to reuse your term.\n\n> \n> There is no super computer in Liege? \n\n\nWell maybe there is something. It is the first time in Li\u00e8ge that I need computation power, but it is the vacation now.\n\n> I can set an invitation to use the very powerful [Plafrim](https://plafrim.bordeaux.inria.fr/doku.php) in Bordeaux. But it is some work to learn how to use it (e.g. you need to tell in advance for how long you request the processors).\n\n\nThat would be nice!",
    "created_at": "2015-08-09T20:55:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255710",
    "user": "https://github.com/seblabbe"
}
```

> This looks very bad. At the end, you might end up with only one core working on the biggest subinstance. And it can lasts several days even with 200 cores. Ideally, you should slice the problem in such way that each subinstance will not take longer than 1 hour (let say).


It is not very bad as most of the 240 computations takes the same amount of time (about 2 to 3 hours). Maybe 5 of time takes more (10 hours). So I am using the four cores at least 95% of the time. In my case, I have very good subinstances to reuse your term.

> 
> There is no super computer in Liege? 


Well maybe there is something. It is the first time in Liège that I need computation power, but it is the vacation now.

> I can set an invitation to use the very powerful [Plafrim](https://plafrim.bordeaux.inria.fr/doku.php) in Bordeaux. But it is some work to learn how to use it (e.g. you need to tell in advance for how long you request the processors).


That would be nice!



---

archive/issue_comments_255711.json:
```json
{
    "body": "> Do you mind if I rebase over 6.9.beta1? \n\n\nI just did that (in case you did not notice).",
    "created_at": "2015-08-09T21:02:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255711",
    "user": "https://github.com/seblabbe"
}
```

> Do you mind if I rebase over 6.9.beta1? 


I just did that (in case you did not notice).



---

archive/issue_comments_255712.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-08-09T21:14:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255712",
    "user": "https://github.com/videlec"
}
```

New commits:



---

archive/issue_comments_255713.json:
```json
{
    "body": "I found the organization of the dancing links code very confusing. Do you know why there are both a file `dancing_links.pyx` (that wraps the C++ class as a Cython class) and a file `dlxcpp.py` (that uses the Cython class in a functional style)? And there is also a `combinat/dlx.py`!! I guess this is mostly historical but it needs a serious cleanup.",
    "created_at": "2015-08-09T21:19:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255713",
    "user": "https://github.com/videlec"
}
```

I found the organization of the dancing links code very confusing. Do you know why there are both a file `dancing_links.pyx` (that wraps the C++ class as a Cython class) and a file `dlxcpp.py` (that uses the Cython class in a functional style)? And there is also a `combinat/dlx.py`!! I guess this is mostly historical but it needs a serious cleanup.



---

archive/issue_comments_255714.json:
```json
{
    "body": "Even just inside `dancing_links.pyx`, the class is called a Wrapper for the C++ code and `dlx_solver` is a function that calls the constructor of the wrapper...\n\nAlso I would not put this in `combnat/matrices` just because the exact cover problem can be represented as a 0-1 matrix...",
    "created_at": "2015-08-09T21:25:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255714",
    "user": "https://github.com/seblabbe"
}
```

Even just inside `dancing_links.pyx`, the class is called a Wrapper for the C++ code and `dlx_solver` is a function that calls the constructor of the wrapper...

Also I would not put this in `combnat/matrices` just because the exact cover problem can be represented as a 0-1 matrix...



---

archive/issue_comments_255715.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-10T07:31:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255715",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255716.json:
```json
{
    "body": "Is there a way to quotient two groups in Sage, maybe using gap or something ?\n\n```\nsage: L = [w.matrix() for w in WeylGroup(['B',3]) if w.matrix().det()==1]\nsage: G = MatrixGroup(L)\nsage: H = MatrixGroup(L[:4])\nsage: len(G)\n24\nsage: len(H)\n4\nsage: H\nMatrix group over Rational Field with 4 generators (\n[1 0 0]  [ 1  0  0]  [-1  0  0]  [-1  0  0]\n[0 1 0]  [ 0 -1  0]  [ 0  1  0]  [ 0 -1  0]\n[0 0 1], [ 0  0 -1], [ 0  0 -1], [ 0  0  1]\n)\nsage: G.quotient(H)\nTraceback (most recent call last):\n...\nNotImplementedError:\n```",
    "created_at": "2015-08-10T08:11:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255716",
    "user": "https://github.com/seblabbe"
}
```

Is there a way to quotient two groups in Sage, maybe using gap or something ?

```
sage: L = [w.matrix() for w in WeylGroup(['B',3]) if w.matrix().det()==1]
sage: G = MatrixGroup(L)
sage: H = MatrixGroup(L[:4])
sage: len(G)
24
sage: len(H)
4
sage: H
Matrix group over Rational Field with 4 generators (
[1 0 0]  [ 1  0  0]  [-1  0  0]  [-1  0  0]
[0 1 0]  [ 0 -1  0]  [ 0  1  0]  [ 0 -1  0]
[0 0 1], [ 0  0 -1], [ 0  0 -1], [ 0  0  1]
)
sage: G.quotient(H)
Traceback (most recent call last):
...
NotImplementedError:
```



---

archive/issue_comments_255717.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-10T09:07:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255717",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255718.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-10T09:08:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255718",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_255719.json:
```json
{
    "body": "> - What is the `modpi` arguments. What is a rotation of angle `pi` for you? Is it a linear transformation that is a pi-rotation restricted on a plane and leaves invariant the orthogonal complement? (I guess it should also have integer coordinates) If this is, then it is of course not a group... but of course you might consider the group generated by these.\n\n\nOk, so tell me if it is better now.",
    "created_at": "2015-08-10T09:08:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255719",
    "user": "https://github.com/seblabbe"
}
```

> - What is the `modpi` arguments. What is a rotation of angle `pi` for you? Is it a linear transformation that is a pi-rotation restricted on a plane and leaves invariant the orthogonal complement? (I guess it should also have integer coordinates) If this is, then it is of course not a group... but of course you might consider the group generated by these.


Ok, so tell me if it is better now.



---

archive/issue_comments_255720.json:
```json
{
    "body": "Replying to [comment:26 slabbe]:\n> > - What is the `modpi` arguments. What is a rotation of angle `pi` for you? Is it a linear transformation that is a pi-rotation restricted on a plane and leaves invariant the orthogonal complement? (I guess it should also have integer coordinates) If this is, then it is of course not a group... but of course you might consider the group generated by these.\n \n> \n> Ok, so tell me if it is better now.\n\n\nA bit. What do you mean by `the rectangular parallelepiped`? There is only one? As far as I understand it is the isometry group that preserves **any** rectangular parallelepiped. You can also say differently: the group of orientable isometry that preserve (globally) each axis. Is that right?\n\nAnd as before, this is the group *generated* by these rotation and not only thes rotations themselves (except in dim 2 and 3).\n\nIsn't this group exactly the subgroup of matrices with an even number of `-1` on the diagonal? So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?\n\nWhen `orientation_preserving` is `False` I guess this group is the subgroup of matrices with any number of `-1` on the diagonal. In that case, the quotient would just be the permutation matrices. No?",
    "created_at": "2015-08-10T09:24:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255720",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:26 slabbe]:
> > - What is the `modpi` arguments. What is a rotation of angle `pi` for you? Is it a linear transformation that is a pi-rotation restricted on a plane and leaves invariant the orthogonal complement? (I guess it should also have integer coordinates) If this is, then it is of course not a group... but of course you might consider the group generated by these.
 
> 
> Ok, so tell me if it is better now.


A bit. What do you mean by `the rectangular parallelepiped`? There is only one? As far as I understand it is the isometry group that preserves **any** rectangular parallelepiped. You can also say differently: the group of orientable isometry that preserve (globally) each axis. Is that right?

And as before, this is the group *generated* by these rotation and not only thes rotations themselves (except in dim 2 and 3).

Isn't this group exactly the subgroup of matrices with an even number of `-1` on the diagonal? So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?

When `orientation_preserving` is `False` I guess this group is the subgroup of matrices with any number of `-1` on the diagonal. In that case, the quotient would just be the permutation matrices. No?



---

archive/issue_comments_255721.json:
```json
{
    "body": "And when you say `that is by rotations of angle pi` this is confusing since there are infinitely many of them. You can say `by rotations of angle pi on the plane generated by two axes`.",
    "created_at": "2015-08-10T09:25:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255721",
    "user": "https://github.com/videlec"
}
```

And when you say `that is by rotations of angle pi` this is confusing since there are infinitely many of them. You can say `by rotations of angle pi on the plane generated by two axes`.



---

archive/issue_comments_255722.json:
```json
{
    "body": "> A bit. What do you mean by `the rectangular parallelepiped`? There is only one? \n\n\nOf course the length of the side can change, so there is more than one. But, of course, I consider the case where the length of the sides are all distinct.\n\n> As far as I understand it is the isometry group that preserves **any** rectangular parallelepiped. \n\n\nYou understand well.\n\n> You can also say differently: the group of orientable isometry that preserve (globally) each axis. Is that right?\n\n\nYes.\n\n> And as before, this is the group *generated* by these rotation and not only thes rotations themselves (except in dim 2 and 3).\n\n\nOf course. \"modpi\" is in the sense of modulo a group.\n\n> Isn't this group exactly the subgroup of matrices with an even number of `-1` on the diagonal? \n\n\nYes.\n\n> So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?\n\n\nMaybe. When the dimension is odd, the quotient is the signed permutation matrices where the signs is either all positive or all negative with determinant 1. That is the formula that I was using.\n\n> When `orientation_preserving` is `False` I guess this group is the subgroup of matrices with any number of `-1` on the diagonal. In that case, the quotient would just be the permutation matrices. No?\n\n\nYes! You are right.",
    "created_at": "2015-08-10T09:38:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255722",
    "user": "https://github.com/seblabbe"
}
```

> A bit. What do you mean by `the rectangular parallelepiped`? There is only one? 


Of course the length of the side can change, so there is more than one. But, of course, I consider the case where the length of the sides are all distinct.

> As far as I understand it is the isometry group that preserves **any** rectangular parallelepiped. 


You understand well.

> You can also say differently: the group of orientable isometry that preserve (globally) each axis. Is that right?


Yes.

> And as before, this is the group *generated* by these rotation and not only thes rotations themselves (except in dim 2 and 3).


Of course. "modpi" is in the sense of modulo a group.

> Isn't this group exactly the subgroup of matrices with an even number of `-1` on the diagonal? 


Yes.

> So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?


Maybe. When the dimension is odd, the quotient is the signed permutation matrices where the signs is either all positive or all negative with determinant 1. That is the formula that I was using.

> When `orientation_preserving` is `False` I guess this group is the subgroup of matrices with any number of `-1` on the diagonal. In that case, the quotient would just be the permutation matrices. No?


Yes! You are right.



---

archive/issue_comments_255723.json:
```json
{
    "body": "> So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?\n\n\nWhen `orientation_preserving=True`, the determinant of every returned matrix must be one. Therefore, I believe the quotient is the positive permutation matrices of determinant one + the other permutation matrices where one 1 is replaced by -1.",
    "created_at": "2015-08-10T09:59:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255723",
    "user": "https://github.com/seblabbe"
}
```

> So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?


When `orientation_preserving=True`, the determinant of every returned matrix must be one. Therefore, I believe the quotient is the positive permutation matrices of determinant one + the other permutation matrices where one 1 is replaced by -1.



---

archive/issue_comments_255724.json:
```json
{
    "body": "> > So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?\n\n> \n> Maybe. When the dimension is odd, the quotient is the signed permutation matrices where the signs is either all positive or all negative with determinant 1. That is the formula that I was using.\n\n\nOk, now I understand why I needed it that way. I need well-chosen representatives for the quotient. By this, I mean that the chosen representatives of the cosets form a group itself.\n\nFor example, these representatives do not form a group:\n\n```\nsage: n = 3\nsage: c = identity_matrix(n)\nsage: c[0,0] = -1\nsage: L = [w.matrix() for w in WeylGroup(['A', n-1])]\nsage: L = [(w if w.det() == 1 else c*w) for w in L]\n[\n[1 0 0]  [ 0  0 -1]  [0 0 1]  [ 0 -1  0]  [0 1 0]  [-1  0  0]\n[0 1 0]  [ 0  1  0]  [1 0 0]  [ 1  0  0]  [0 0 1]  [ 0  0  1]\n[0 0 1], [ 1  0  0], [0 1 0], [ 0  0  1], [1 0 0], [ 0  1  0]\n]\nsage: MatrixGroup(L).cardinality()\n24\n```\n\nBut these representatives forms a group:\n\n```\nsage: L = [w.matrix() for w in WeylGroup(['A', n-1])]\nsage: L = [m.det() * m for m in L]\nsage: L\n[\n[1 0 0]  [ 0  0 -1]  [0 0 1]  [ 0 -1  0]  [0 1 0]  [-1  0  0]\n[0 1 0]  [ 0 -1  0]  [1 0 0]  [-1  0  0]  [0 0 1]  [ 0  0 -1]\n[0 0 1], [-1  0  0], [0 1 0], [ 0  0 -1], [1 0 0], [ 0 -1  0]\n]\nsage: MatrixGroup(L).cardinality()\n6\n```\n\nAnd I still don't know how to construct the quotient when n is even.",
    "created_at": "2015-08-10T12:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255724",
    "user": "https://github.com/seblabbe"
}
```

> > So the quotient is just the signed permutation matrices with either `0` or `1` coefficient `-1` (all others being `1`). Isn't it?

> 
> Maybe. When the dimension is odd, the quotient is the signed permutation matrices where the signs is either all positive or all negative with determinant 1. That is the formula that I was using.


Ok, now I understand why I needed it that way. I need well-chosen representatives for the quotient. By this, I mean that the chosen representatives of the cosets form a group itself.

For example, these representatives do not form a group:

```
sage: n = 3
sage: c = identity_matrix(n)
sage: c[0,0] = -1
sage: L = [w.matrix() for w in WeylGroup(['A', n-1])]
sage: L = [(w if w.det() == 1 else c*w) for w in L]
[
[1 0 0]  [ 0  0 -1]  [0 0 1]  [ 0 -1  0]  [0 1 0]  [-1  0  0]
[0 1 0]  [ 0  1  0]  [1 0 0]  [ 1  0  0]  [0 0 1]  [ 0  0  1]
[0 0 1], [ 1  0  0], [0 1 0], [ 0  0  1], [1 0 0], [ 0  1  0]
]
sage: MatrixGroup(L).cardinality()
24
```

But these representatives forms a group:

```
sage: L = [w.matrix() for w in WeylGroup(['A', n-1])]
sage: L = [m.det() * m for m in L]
sage: L
[
[1 0 0]  [ 0  0 -1]  [0 0 1]  [ 0 -1  0]  [0 1 0]  [-1  0  0]
[0 1 0]  [ 0 -1  0]  [1 0 0]  [-1  0  0]  [0 0 1]  [ 0  0 -1]
[0 0 1], [-1  0  0], [0 1 0], [ 0  0 -1], [1 0 0], [ 0 -1  0]
]
sage: MatrixGroup(L).cardinality()
6
```

And I still don't know how to construct the quotient when n is even.



---

archive/issue_comments_255725.json:
```json
{
    "body": "Okay, so it is a chance that it works for when n is odd because in general:\n\nhttp://groupprops.subwiki.org/wiki/Quotient_group_need_not_be_isomorphic_to_any_subgroup",
    "created_at": "2015-08-10T12:46:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255725",
    "user": "https://github.com/seblabbe"
}
```

Okay, so it is a chance that it works for when n is odd because in general:

http://groupprops.subwiki.org/wiki/Quotient_group_need_not_be_isomorphic_to_any_subgroup



---

archive/issue_comments_255726.json:
```json
{
    "body": "> Ok, now I understand why I needed it that way.\n\n\nWait. I really need the quotient itself finally. I was just lucky that the transformation keeping some the pentamino invariant was in the group.\n\n```\n\n    sage: from sage.combinat.tiling import ncube_isometry_group\n    sage: from sage.games.quantumino import pentaminos\n    sage: L = ncube_isometry_group(3)\n    sage: f = lambda p : [m for m in L[1:] if (m*p).canonical() == p.canonical()]\n    sage: [(i, f(p)) for i,p in enumerate(pentaminos) if f(p)]\n    [(6, [\n    [ 0  0 -1]\n    [ 0 -1  0]\n    [-1  0  0]\n    ]),\n     (7, [\n    [ 0  0  1]\n    [ 0 -1  0]\n    [ 1  0  0]\n    ]),\n     (12, [\n    [-1  0  0]\n    [ 0  0 -1]\n    [ 0 -1  0]\n    ]),\n     (13, [\n    [ 0  0 -1]\n    [ 0 -1  0]\n    [-1  0  0]\n    ]),\n     (16, [\n    [ 0  0 -1]\n    [ 0 -1  0]\n    [-1  0  0]\n    ])]\n```\n\nAbove, I get a problem with pentamino number 7 because it is invariant under a transformation that is not in the subgroup isomorphic to the quotient. So I really need to consider the quotient with all of the elements in each coset. Chosing a representative won't work even if it is well chosen.\n\nGive me more time. I'll update my branch.",
    "created_at": "2015-08-10T13:45:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255726",
    "user": "https://github.com/seblabbe"
}
```

> Ok, now I understand why I needed it that way.


Wait. I really need the quotient itself finally. I was just lucky that the transformation keeping some the pentamino invariant was in the group.

```

    sage: from sage.combinat.tiling import ncube_isometry_group
    sage: from sage.games.quantumino import pentaminos
    sage: L = ncube_isometry_group(3)
    sage: f = lambda p : [m for m in L[1:] if (m*p).canonical() == p.canonical()]
    sage: [(i, f(p)) for i,p in enumerate(pentaminos) if f(p)]
    [(6, [
    [ 0  0 -1]
    [ 0 -1  0]
    [-1  0  0]
    ]),
     (7, [
    [ 0  0  1]
    [ 0 -1  0]
    [ 1  0  0]
    ]),
     (12, [
    [-1  0  0]
    [ 0  0 -1]
    [ 0 -1  0]
    ]),
     (13, [
    [ 0  0 -1]
    [ 0 -1  0]
    [-1  0  0]
    ]),
     (16, [
    [ 0  0 -1]
    [ 0 -1  0]
    [-1  0  0]
    ])]
```

Above, I get a problem with pentamino number 7 because it is invariant under a transformation that is not in the subgroup isomorphic to the quotient. So I really need to consider the quotient with all of the elements in each coset. Chosing a representative won't work even if it is well chosen.

Give me more time. I'll update my branch.



---

archive/issue_comments_255727.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-10T19:45:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255727",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255728.json:
```json
{
    "body": "Re-needs review.",
    "created_at": "2015-08-10T19:46:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255728",
    "user": "https://github.com/seblabbe"
}
```

Re-needs review.



---

archive/issue_comments_255729.json:
```json
{
    "body": "Note that the patchbot was not able to build the doc.",
    "created_at": "2015-08-10T21:58:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255729",
    "user": "https://github.com/videlec"
}
```

Note that the patchbot was not able to build the doc.



---

archive/issue_comments_255730.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-11T06:02:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255730",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255731.json:
```json
{
    "body": "There was a `TESTS::` with text following. Fixed that (and squashed it the the last commit). Also added the prefix `Trac #18987: ` to all commit messages.",
    "created_at": "2015-08-11T06:05:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255731",
    "user": "https://github.com/seblabbe"
}
```

There was a `TESTS::` with text following. Fixed that (and squashed it the the last commit). Also added the prefix `Trac #18987: ` to all commit messages.



---

archive/issue_comments_255732.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-11T08:54:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255732",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_255733.json:
```json
{
    "body": "There is one failing doctest on the patchbot that is not failing on my machine...",
    "created_at": "2015-08-11T08:54:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255733",
    "user": "https://github.com/seblabbe"
}
```

There is one failing doctest on the patchbot that is not failing on my machine...



---

archive/issue_comments_255734.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-11T08:55:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255734",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255735.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-11T08:55:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255735",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_255736.json:
```json
{
    "body": "Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?\n\nIn `ncube_isometry_group_modpi` why are you building `MatrixGroup`?\n\nIn\n\n```\nP_coset = set(frozenset((m.matrix() * self).canonical() for m in coset) for coset in L)\nreturn set(next(iter(s)) for s in P_coset)\n```\nYou are building a lot of images to consider `matrix x polyomino` to use just one at the end. Why not\n\n```\nreturn set((L[0].matrix() * self).canonical() for coset in L)\n```\nAnd if you were not using matrix groups you can even do\n\n```\nreturn set((L[0] * self).canonical() for coset in L)\n```",
    "created_at": "2015-08-11T10:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255736",
    "user": "https://github.com/videlec"
}
```

Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?

In `ncube_isometry_group_modpi` why are you building `MatrixGroup`?

In

```
P_coset = set(frozenset((m.matrix() * self).canonical() for m in coset) for coset in L)
return set(next(iter(s)) for s in P_coset)
```
You are building a lot of images to consider `matrix x polyomino` to use just one at the end. Why not

```
return set((L[0].matrix() * self).canonical() for coset in L)
```
And if you were not using matrix groups you can even do

```
return set((L[0] * self).canonical() for coset in L)
```



---

archive/issue_comments_255737.json:
```json
{
    "body": "You are using `L` instead of `coset` I think. Can you edit your previous comment to make sure I understand what you mean?",
    "created_at": "2015-08-11T11:43:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255737",
    "user": "https://github.com/seblabbe"
}
```

You are using `L` instead of `coset` I think. Can you edit your previous comment to make sure I understand what you mean?



---

archive/issue_comments_255738.json:
```json
{
    "body": "Replying to [comment:42 vdelecroix]:\n> Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?\n\n\nCalling this function takes 2.8s on my machine. And it is called once for each polyomino. That is 16 times for the Quantumino puzzle. With the cache, I gain about 40s to construct the rows to give to the dlx solver.\n\n> In `ncube_isometry_group_modpi` why are you building `MatrixGroup`?\n\n\nBecause otherwise, this\n\n```\nG = ncube_isometry_group(n, orientation_preserving)\nH = [h for h in G if all(i==j for (i,j) in h.nonzero_positions())]\nleft_cosets = set(tuple(sorted(h*g for h in H)) for g in G)\n```\n\nthrows a `TypeError: mutable matrices are unhashable` and I find it more fun to read like this instead of the `.set_immutable()` on every matrices.",
    "created_at": "2015-08-11T11:48:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255738",
    "user": "https://github.com/seblabbe"
}
```

Replying to [comment:42 vdelecroix]:
> Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?


Calling this function takes 2.8s on my machine. And it is called once for each polyomino. That is 16 times for the Quantumino puzzle. With the cache, I gain about 40s to construct the rows to give to the dlx solver.

> In `ncube_isometry_group_modpi` why are you building `MatrixGroup`?


Because otherwise, this

```
G = ncube_isometry_group(n, orientation_preserving)
H = [h for h in G if all(i==j for (i,j) in h.nonzero_positions())]
left_cosets = set(tuple(sorted(h*g for h in H)) for g in G)
```

throws a `TypeError: mutable matrices are unhashable` and I find it more fun to read like this instead of the `.set_immutable()` on every matrices.



---

archive/issue_comments_255739.json:
```json
{
    "body": "> You are building a lot of images to consider `matrix x polyomino` to use just one at the end. Why not\n\n\nI know but I need all of them. That is what I understood yesterday. Let me try to explain. In general it is okay to take only one matrix in the coset. The problem comes when the polyomino is invariant under some of the 24 orientation preserving isometries of the cube. For example, consider:\n\n```\nsage: from sage.games.quantumino import pentaminos                                  \nsage: from sage.combinat.tiling import ncube_isometry_group                         \nsage: p = pentaminos[7]                                                             \nsage: m = ncube_isometry_group(3)[-3]                                               \nsage: p                                                                             \nPolyomino: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 2, 1), (1, 0, 0)], Color: orange   \nsage: m                                                                             \n[ 0  0  1]                                                                          \n[ 0 -1  0]                                                                          \n[ 1  0  0]                                                                          \nsage: (m*p).canonical() == p                                                        \nTrue                                                                                \n```\n\nThe polyomino `p` has 12 distinct rotation images instead of 24. And among the 12 ways of placing that polyomino into a box, there are 3 distinct ways up to rotation of the box keeping the box invariant. To compute this, we need to consider the whole coset:\n\n```\nsage: cosets = ncube_isometry_group_modpi(3)\nsage: P_coset = set(frozenset((m.matrix() * p).canonical() for m in coset) for coset in cosets)\nsage: len(P_coset)                         \n3   \nsage: len(set(next(iter(s)) for s in P_coset))\n3                                                                                          \n```\n\nOtherwise, you obtain too many polyominos (see below).\n\n```\nsage: set((coset[0].matrix() * p).canonical() for coset in cosets)                 \n{Polyomino: [(0, 0, 1), (1, 0, 1), (1, 1, 1), (1, 2, 0), (1, 2, 1)], Color: orange,\n Polyomino: [(0, 1, 2), (1, 0, 0), (1, 1, 0), (1, 1, 1), (1, 1, 2)], Color: orange,\n Polyomino: [(0, 0, 0), (0, 1, 0), (1, 1, 0), (2, 1, 0), (2, 1, 1)], Color: orange,\n Polyomino: [(0, 1, 0), (0, 1, 1), (1, 1, 1), (2, 0, 1), (2, 1, 1)], Color: orange,\n Polyomino: [(0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 2, 0)], Color: orange}\n```",
    "created_at": "2015-08-11T12:16:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255739",
    "user": "https://github.com/seblabbe"
}
```

> You are building a lot of images to consider `matrix x polyomino` to use just one at the end. Why not


I know but I need all of them. That is what I understood yesterday. Let me try to explain. In general it is okay to take only one matrix in the coset. The problem comes when the polyomino is invariant under some of the 24 orientation preserving isometries of the cube. For example, consider:

```
sage: from sage.games.quantumino import pentaminos                                  
sage: from sage.combinat.tiling import ncube_isometry_group                         
sage: p = pentaminos[7]                                                             
sage: m = ncube_isometry_group(3)[-3]                                               
sage: p                                                                             
Polyomino: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 2, 1), (1, 0, 0)], Color: orange   
sage: m                                                                             
[ 0  0  1]                                                                          
[ 0 -1  0]                                                                          
[ 1  0  0]                                                                          
sage: (m*p).canonical() == p                                                        
True                                                                                
```

The polyomino `p` has 12 distinct rotation images instead of 24. And among the 12 ways of placing that polyomino into a box, there are 3 distinct ways up to rotation of the box keeping the box invariant. To compute this, we need to consider the whole coset:

```
sage: cosets = ncube_isometry_group_modpi(3)
sage: P_coset = set(frozenset((m.matrix() * p).canonical() for m in coset) for coset in cosets)
sage: len(P_coset)                         
3   
sage: len(set(next(iter(s)) for s in P_coset))
3                                                                                          
```

Otherwise, you obtain too many polyominos (see below).

```
sage: set((coset[0].matrix() * p).canonical() for coset in cosets)                 
{Polyomino: [(0, 0, 1), (1, 0, 1), (1, 1, 1), (1, 2, 0), (1, 2, 1)], Color: orange,
 Polyomino: [(0, 1, 2), (1, 0, 0), (1, 1, 0), (1, 1, 1), (1, 1, 2)], Color: orange,
 Polyomino: [(0, 0, 0), (0, 1, 0), (1, 1, 0), (2, 1, 0), (2, 1, 1)], Color: orange,
 Polyomino: [(0, 1, 0), (0, 1, 1), (1, 1, 1), (2, 0, 1), (2, 1, 1)], Color: orange,
 Polyomino: [(0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 2, 0)], Color: orange}
```



---

archive/issue_comments_255740.json:
```json
{
    "body": "Replying to [comment:44 slabbe]:\n> Replying to [comment:42 vdelecroix]:\n> > Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?\n\n> \n> Calling this function takes 2.8s on my machine. And it is called once for each polyomino. That is 16 times for the Quantumino puzzle. With the cache, I gain about 40s to construct the rows to give to the dlx solver.\n\n\nPerhaps the way it is implemented is wrong. For example\n\n```\nsage: %timeit P = [s.matrix() for s in SymmetricGroup(4)]\n1 loops, best of 3: 1.27 ms per loop\n```\nand with the signs\n\n```\nsage: from itertools import product\nsage: %timeit M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\n1 loops, best of 3: 2.9 ms per loop\nsage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\nsage: %timeit S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\n100 loops, best of 3: 18.3 ms per loop\n```\nSo it is likely to be `~20ms`.",
    "created_at": "2015-08-11T16:20:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255740",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:44 slabbe]:
> Replying to [comment:42 vdelecroix]:
> > Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?

> 
> Calling this function takes 2.8s on my machine. And it is called once for each polyomino. That is 16 times for the Quantumino puzzle. With the cache, I gain about 40s to construct the rows to give to the dlx solver.


Perhaps the way it is implemented is wrong. For example

```
sage: %timeit P = [s.matrix() for s in SymmetricGroup(4)]
1 loops, best of 3: 1.27 ms per loop
```
and with the signs

```
sage: from itertools import product
sage: %timeit M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
1 loops, best of 3: 2.9 ms per loop
sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
sage: %timeit S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
100 loops, best of 3: 18.3 ms per loop
```
So it is likely to be `~20ms`.



---

archive/issue_comments_255741.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-12T08:53:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255741",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255742.json:
```json
{
    "body": "> > Replying to [comment:42 vdelecroix]:\n> > > Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?\n\n\nIn fact, you make me realize that there is already caching involved in WeylGroup. Therefore caching that function is not so necessary. Without caching, I get:\n\n```\nsage: from sage.combinat.tiling import ncube_isometry_group\nsage: time L = ncube_isometry_group(4)             \nCPU times: user 1.14 s, sys: 19.7 ms, total: 1.16 s\nWall time: 1.3 s                                   \nsage: time L = ncube_isometry_group(4)             \nCPU times: user 358 ms, sys: 4.01 ms, total: 362 ms\nWall time: 448 ms                                      \n```\n\n> {{{\n> sage: from itertools import product\n> sage: %timeit M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\n> 1 loops, best of 3: 2.9 ms per loop\n> sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\n> sage: %timeit S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\n> 100 loops, best of 3: 18.3 ms per loop\n> }}}\n> So it is likely to be `~20ms`.\n\n\nNote that you can't use timeit above since there is caching involved in SymmetricGroup.\n\nFor comparison, your solution on my machine gives the following timings:\n\n```python\nsage: from itertools import product   \nsage: # first call                                 \nsage: time M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)] \nCPU times: user 11.4 ms, sys: 92 \u00b5s, total: 11.5 ms                    \nWall time: 11.9 ms                                                     \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]    \nCPU times: user 191 ms, sys: 25.2 ms, total: 216 ms                    \nWall time: 667 ms                                                      \nsage: # second call\nsage: time M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\nCPU times: user 11.7 ms, sys: 1.34 ms, total: 13 ms                   \nWall time: 16.6 ms                                                    \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]   \nCPU times: user 108 ms, sys: 1.92 ms, total: 110 ms                   \nWall time: 114 ms                                                     \n```\n\nSo it seems using `WeylGroup(['B',4])` is about 4 times slower than your solution. But I don't know if I will change it. I mean that improvement could be done directly in `WeylGroup` code...",
    "created_at": "2015-08-12T09:08:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255742",
    "user": "https://github.com/seblabbe"
}
```

> > Replying to [comment:42 vdelecroix]:
> > > Are you sure `ncube_isometry_group` is worth a ``@`cached_function`?


In fact, you make me realize that there is already caching involved in WeylGroup. Therefore caching that function is not so necessary. Without caching, I get:

```
sage: from sage.combinat.tiling import ncube_isometry_group
sage: time L = ncube_isometry_group(4)             
CPU times: user 1.14 s, sys: 19.7 ms, total: 1.16 s
Wall time: 1.3 s                                   
sage: time L = ncube_isometry_group(4)             
CPU times: user 358 ms, sys: 4.01 ms, total: 362 ms
Wall time: 448 ms                                      
```

> {{{
> sage: from itertools import product
> sage: %timeit M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
> 1 loops, best of 3: 2.9 ms per loop
> sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
> sage: %timeit S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
> 100 loops, best of 3: 18.3 ms per loop
> }}}
> So it is likely to be `~20ms`.


Note that you can't use timeit above since there is caching involved in SymmetricGroup.

For comparison, your solution on my machine gives the following timings:

```python
sage: from itertools import product   
sage: # first call                                 
sage: time M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)] 
CPU times: user 11.4 ms, sys: 92 µs, total: 11.5 ms                    
Wall time: 11.9 ms                                                     
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]    
CPU times: user 191 ms, sys: 25.2 ms, total: 216 ms                    
Wall time: 667 ms                                                      
sage: # second call
sage: time M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
CPU times: user 11.7 ms, sys: 1.34 ms, total: 13 ms                   
Wall time: 16.6 ms                                                    
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]   
CPU times: user 108 ms, sys: 1.92 ms, total: 110 ms                   
Wall time: 114 ms                                                     
```

So it seems using `WeylGroup(['B',4])` is about 4 times slower than your solution. But I don't know if I will change it. I mean that improvement could be done directly in `WeylGroup` code...



---

archive/issue_comments_255743.json:
```json
{
    "body": "Replying to [comment:48 slabbe]:\n> > {{{\n> > sage: from itertools import product\n> > sage: %timeit M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\n> > 1 loops, best of 3: 2.9 ms per loop\n> > sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\n> > sage: %timeit S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\n> > 100 loops, best of 3: 18.3 ms per loop\n> > }}}\n> > So it is likely to be `~20ms`.\n\n> \n> Note that you can't use timeit above since there is caching involved in SymmetricGroup.\n\n\nWhere?! Beyond the construction of the group (`SymmetricGroup(4) is SymmetricGroup(4)` gives `True`) nothing is cached.",
    "created_at": "2015-08-12T13:19:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255743",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:48 slabbe]:
> > {{{
> > sage: from itertools import product
> > sage: %timeit M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
> > 1 loops, best of 3: 2.9 ms per loop
> > sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
> > sage: %timeit S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
> > 100 loops, best of 3: 18.3 ms per loop
> > }}}
> > So it is likely to be `~20ms`.

> 
> Note that you can't use timeit above since there is caching involved in SymmetricGroup.


Where?! Beyond the construction of the group (`SymmetricGroup(4) is SymmetricGroup(4)` gives `True`) nothing is cached.



---

archive/issue_comments_255744.json:
```json
{
    "body": "> Where?! Beyond the construction of the group (`SymmetricGroup(4) is SymmetricGroup(4)` gives `True`) nothing is cached.\n\n\nDon't you get that the first execution of\n\n```\nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\n```\nis slower than the second? And that the second takes about the same time than the third, the fourth, etc. ? Like me:\n\n```\nsage: from itertools import product                                \nsage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]  \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 184 ms, sys: 18 ms, total: 202 ms                  \nWall time: 710 ms                                                  \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 109 ms, sys: 2.05 ms, total: 111 ms                \nWall time: 166 ms                                                  \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 109 ms, sys: 2.6 ms, total: 111 ms                 \nWall time: 113 ms                                                  \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 110 ms, sys: 2.12 ms, total: 112 ms                \nWall time: 169 ms                                                  \nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 108 ms, sys: 2.44 ms, total: 111 ms                \nWall time: 114 ms                                                  \n```",
    "created_at": "2015-08-12T13:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255744",
    "user": "https://github.com/seblabbe"
}
```

> Where?! Beyond the construction of the group (`SymmetricGroup(4) is SymmetricGroup(4)` gives `True`) nothing is cached.


Don't you get that the first execution of

```
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
```
is slower than the second? And that the second takes about the same time than the third, the fourth, etc. ? Like me:

```
sage: from itertools import product                                
sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]  
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 184 ms, sys: 18 ms, total: 202 ms                  
Wall time: 710 ms                                                  
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 109 ms, sys: 2.05 ms, total: 111 ms                
Wall time: 166 ms                                                  
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 109 ms, sys: 2.6 ms, total: 111 ms                 
Wall time: 113 ms                                                  
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 110 ms, sys: 2.12 ms, total: 112 ms                
Wall time: 169 ms                                                  
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 108 ms, sys: 2.44 ms, total: 111 ms                
Wall time: 114 ms                                                  
```



---

archive/issue_comments_255745.json:
```json
{
    "body": "Yes for the timing. But this does **not** implies that something is cached. Actually, the reason is because gap is launched (I do not know why)\n\n```\nsage: S = SymmetricGroup(4)\nsage: time gap(3)\nCPU times: user 16 ms, sys: 12 ms, total: 28 ms\nWall time: 295 ms\n3\nsage: from itertools import product\nsage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]\nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 56 ms, sys: 0 ns, total: 56 ms\nWall time: 56.9 ms\nsage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]\nCPU times: user 56 ms, sys: 0 ns, total: 56 ms\nWall time: 53 ms\n```",
    "created_at": "2015-08-12T14:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255745",
    "user": "https://github.com/videlec"
}
```

Yes for the timing. But this does **not** implies that something is cached. Actually, the reason is because gap is launched (I do not know why)

```
sage: S = SymmetricGroup(4)
sage: time gap(3)
CPU times: user 16 ms, sys: 12 ms, total: 28 ms
Wall time: 295 ms
3
sage: from itertools import product
sage: M = [diagonal_matrix(p) for p in product([1,-1], repeat=4)]
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 56 ms, sys: 0 ns, total: 56 ms
Wall time: 56.9 ms
sage: time S = [m*s.matrix() for m in M for s in SymmetricGroup(4)]
CPU times: user 56 ms, sys: 0 ns, total: 56 ms
Wall time: 53 ms
```



---

archive/issue_comments_255746.json:
```json
{
    "body": "caching `ncube_isometry_group` gives:\n\n```\nsage: from sage.games.quantumino import QuantuminoSolver \nsage: q = QuantuminoSolver(0)                            \nsage: t = q.tiling_solver()                              \nsage: time rows = t.rows()                               \nCPU times: user 18.8 s, sys: 168 ms, total: 19 s         \nWall time: 19 s                                          \n```\n\nnot caching `ncube_isometry_group` gives:\n\n```\nsage: from sage.games.quantumino import QuantuminoSolver  \nsage: q = QuantuminoSolver(0)                             \nsage: t = q.tiling_solver()                               \nsage: time rows = t.rows()                                \nCPU times: user 19.4 s, sys: 288 ms, total: 19.7 s        \nWall time: 20 s                                                                      \n```\n\nSo I confirm that I don't lose relatively much time by not caching.",
    "created_at": "2015-08-12T14:20:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255746",
    "user": "https://github.com/seblabbe"
}
```

caching `ncube_isometry_group` gives:

```
sage: from sage.games.quantumino import QuantuminoSolver 
sage: q = QuantuminoSolver(0)                            
sage: t = q.tiling_solver()                              
sage: time rows = t.rows()                               
CPU times: user 18.8 s, sys: 168 ms, total: 19 s         
Wall time: 19 s                                          
```

not caching `ncube_isometry_group` gives:

```
sage: from sage.games.quantumino import QuantuminoSolver  
sage: q = QuantuminoSolver(0)                             
sage: t = q.tiling_solver()                               
sage: time rows = t.rows()                                
CPU times: user 19.4 s, sys: 288 ms, total: 19.7 s        
Wall time: 20 s                                                                      
```

So I confirm that I don't lose relatively much time by not caching.



---

archive/issue_comments_255747.json:
```json
{
    "body": "Replying to [comment:46 vdelecroix]:\n> Perhaps the way it is implemented is wrong. For example\n> \n> ```\n> sage: %timeit P = [s.matrix() for s in SymmetricGroup(4)]\n> 1 loops, best of 3: 1.27 ms per loop\n> ```\n\n\nI removed the `cached_method`. Do you want me to replace the code based on `WeylGroup(['B',n])` by the `SymmetricGroup` + `diagonal_matrix of signs` code you propose? I think that this improvement should be done in `WeylGroup` in another ticket.\n\nAlso, for timing improvements in that file `tiling.py`, there is a another more important thing to spend time on because a lot of time is spent creating vectors from tuple (because coordinates are stored as tuple). This should be done in another ticket.\n\nNeeds review!",
    "created_at": "2015-08-13T12:03:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255747",
    "user": "https://github.com/seblabbe"
}
```

Replying to [comment:46 vdelecroix]:
> Perhaps the way it is implemented is wrong. For example
> 
> ```
> sage: %timeit P = [s.matrix() for s in SymmetricGroup(4)]
> 1 loops, best of 3: 1.27 ms per loop
> ```


I removed the `cached_method`. Do you want me to replace the code based on `WeylGroup(['B',n])` by the `SymmetricGroup` + `diagonal_matrix of signs` code you propose? I think that this improvement should be done in `WeylGroup` in another ticket.

Also, for timing improvements in that file `tiling.py`, there is a another more important thing to spend time on because a lot of time is spent creating vectors from tuple (because coordinates are stored as tuple). This should be done in another ticket.

Needs review!



---

archive/issue_comments_255748.json:
```json
{
    "body": "Replying to [comment:53 slabbe]:\n> Replying to [comment:46 vdelecroix]:\n> > Perhaps the way it is implemented is wrong. For example\n> > \n> > ```\n> > sage: %timeit P = [s.matrix() for s in SymmetricGroup(4)]\n> > 1 loops, best of 3: 1.27 ms per loop\n> > ```\n\n> \n> I removed the `cached_method`. Do you want me to replace the code based on `WeylGroup(['B',n])` by the `SymmetricGroup` + `diagonal_matrix of signs` code you propose? I think that this improvement should be done in `WeylGroup` in another ticket.\n\n\nNope. I also the think that the `WeylGroup` code has to be improved.\n\n> Also, for timing improvements in that file `tiling.py`, there is a another more important thing to spend time on because a lot of time is spent creating vectors from tuple (because coordinates are stored as tuple). This should be done in another ticket.\n\n\nDid you notice that\n\n```\nsage: t = map(vector, t)\n```\nis much slower than\n\n```\nsage: V = FreeModule(ZZ,12)\nsage: t = map(V,t)\n```\n(I measure a factor x8 in `__sub__` and `__add__` for example)\n\nMoreover, everything would be faster if you would store integer vectors instead of tuples (and an attribute `self._free_module`). Why aren't you doing that?",
    "created_at": "2015-08-13T12:56:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255748",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:53 slabbe]:
> Replying to [comment:46 vdelecroix]:
> > Perhaps the way it is implemented is wrong. For example
> > 
> > ```
> > sage: %timeit P = [s.matrix() for s in SymmetricGroup(4)]
> > 1 loops, best of 3: 1.27 ms per loop
> > ```

> 
> I removed the `cached_method`. Do you want me to replace the code based on `WeylGroup(['B',n])` by the `SymmetricGroup` + `diagonal_matrix of signs` code you propose? I think that this improvement should be done in `WeylGroup` in another ticket.


Nope. I also the think that the `WeylGroup` code has to be improved.

> Also, for timing improvements in that file `tiling.py`, there is a another more important thing to spend time on because a lot of time is spent creating vectors from tuple (because coordinates are stored as tuple). This should be done in another ticket.


Did you notice that

```
sage: t = map(vector, t)
```
is much slower than

```
sage: V = FreeModule(ZZ,12)
sage: t = map(V,t)
```
(I measure a factor x8 in `__sub__` and `__add__` for example)

Moreover, everything would be faster if you would store integer vectors instead of tuples (and an attribute `self._free_module`). Why aren't you doing that?



---

archive/issue_comments_255749.json:
```json
{
    "body": "I still do not understand why you are parallelizing the polyomino solver code and not the DLX one. Isn't your strategy exactly equivalent to this one: pick a column, for each row that does have a 1 in this column remove all the columns occuppied by the piece and launch an independent process?",
    "created_at": "2015-08-13T13:02:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255749",
    "user": "https://github.com/videlec"
}
```

I still do not understand why you are parallelizing the polyomino solver code and not the DLX one. Isn't your strategy exactly equivalent to this one: pick a column, for each row that does have a 1 in this column remove all the columns occuppied by the piece and launch an independent process?



---

archive/issue_comments_255750.json:
```json
{
    "body": "> Moreover, everything would be faster if you would store integer vectors instead of tuples (and an attribute `self._free_module`). Why aren't you doing that?\n\n\n1. Because I think I wanted to use the most basic hashable container (tuple) for the need. I realized only recently that it was slow because there are many matrix operations and additions involved. So indeed, storing vectors would be better.\n\n2. Because it is not the purpose of this ticket.",
    "created_at": "2015-08-15T12:27:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255750",
    "user": "https://github.com/seblabbe"
}
```

> Moreover, everything would be faster if you would store integer vectors instead of tuples (and an attribute `self._free_module`). Why aren't you doing that?


1. Because I think I wanted to use the most basic hashable container (tuple) for the need. I realized only recently that it was slow because there are many matrix operations and additions involved. So indeed, storing vectors would be better.

2. Because it is not the purpose of this ticket.



---

archive/issue_comments_255751.json:
```json
{
    "body": "Replying to [comment:55 vdelecroix]:\n> I still do not understand why you are parallelizing the polyomino solver code and not the DLX one. Isn't your strategy exactly equivalent to this one: pick a column, for each row that does have a 1 in this column remove all the columns occuppied by the piece and launch an independent process?\n\n\nOkay, I will work on a new commit for that.",
    "created_at": "2015-08-15T12:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255751",
    "user": "https://github.com/seblabbe"
}
```

Replying to [comment:55 vdelecroix]:
> I still do not understand why you are parallelizing the polyomino solver code and not the DLX one. Isn't your strategy exactly equivalent to this one: pick a column, for each row that does have a 1 in this column remove all the columns occuppied by the piece and launch an independent process?


Okay, I will work on a new commit for that.



---

archive/issue_comments_255752.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-15T12:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255752",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_255753.json:
```json
{
    "body": "Replying to [comment:56 slabbe]:\n> > Moreover, everything would be faster if you would store integer vectors instead of tuples (and an attribute `self._free_module`). Why aren't you doing that?\n\n> \n> 1. Because I think I wanted to use the most basic hashable container (tuple) for the need. I realized only recently that it was slow because there are many matrix operations and additions involved. So indeed, storing vectors would be better.\n> \n> 2. Because it is not the purpose of this ticket.\n\n\nI opened #19036",
    "created_at": "2015-08-15T12:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255753",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:56 slabbe]:
> > Moreover, everything would be faster if you would store integer vectors instead of tuples (and an attribute `self._free_module`). Why aren't you doing that?

> 
> 1. Because I think I wanted to use the most basic hashable container (tuple) for the need. I realized only recently that it was slow because there are many matrix operations and additions involved. So indeed, storing vectors would be better.
> 
> 2. Because it is not the purpose of this ticket.


I opened #19036



---

archive/issue_comments_255754.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-17T21:50:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255754",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255755.json:
```json
{
    "body": "(I will not have access to a machine with Sage for the next 7 days).",
    "created_at": "2015-08-17T21:52:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255755",
    "user": "https://github.com/seblabbe"
}
```

(I will not have access to a machine with Sage for the next 7 days).



---

archive/issue_comments_255756.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-17T21:52:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255756",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_255757.json:
```json
{
    "body": "Ok, Vincent. I am now back and available to do the follow up on this ticket.\n\nWith the new proposal you made, this ticket now consist of two independant things. Do you prefer me to split the code into two tickets (easier to review) or is it ok like this?\n\nS\u00e9bastien",
    "created_at": "2015-08-24T09:05:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255757",
    "user": "https://github.com/seblabbe"
}
```

Ok, Vincent. I am now back and available to do the follow up on this ticket.

With the new proposal you made, this ticket now consist of two independant things. Do you prefer me to split the code into two tickets (easier to review) or is it ok like this?

Sébastien



---

archive/issue_comments_255758.json:
```json
{
    "body": "I finally decided to split this ticket into two to ease the review. The second part is now available at #19107.",
    "created_at": "2015-08-27T19:25:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255758",
    "user": "https://github.com/seblabbe"
}
```

I finally decided to split this ticket into two to ease the review. The second part is now available at #19107.



---

archive/issue_comments_255759.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-27T19:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255759",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255760.json:
```json
{
    "body": "- `(solving) independant (cases)` -> `independent`\n- I do not understand this comment\n\n```\nIf possible, a good choice of column gives a partition\nof solutions where each part has about the same number\nof solutions.\n```\n- could you make a complete sentence for the `OUTPUT` section instead of `dict, row number -> list of rows`\n- this is not quite accurate\n\n```\nAfter the split each subproblem has the same number of columns and\nrows and the same solutions as above::\n```\n  it is the union of solutions of the subproblems that form the solution of the initial one.\n- I do not see the point of having `number_of_solutions_iterator` and `number_of_solutions`. You should just get rid of the first one and allow parallelization in the second.\n- Why not also make available parallelization for getting the list of solutions?",
    "created_at": "2015-09-04T00:04:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255760",
    "user": "https://github.com/videlec"
}
```

- `(solving) independant (cases)` -> `independent`
- I do not understand this comment

```
If possible, a good choice of column gives a partition
of solutions where each part has about the same number
of solutions.
```
- could you make a complete sentence for the `OUTPUT` section instead of `dict, row number -> list of rows`
- this is not quite accurate

```
After the split each subproblem has the same number of columns and
rows and the same solutions as above::
```
  it is the union of solutions of the subproblems that form the solution of the initial one.
- I do not see the point of having `number_of_solutions_iterator` and `number_of_solutions`. You should just get rid of the first one and allow parallelization in the second.
- Why not also make available parallelization for getting the list of solutions?



---

archive/issue_comments_255761.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-04T00:04:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255761",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_255762.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-05T15:36:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255762",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_255763.json:
```json
{
    "body": "Thanks for your review! I fixed the first comments.\n\n> - I do not see the point of having `number_of_solutions_iterator` and `number_of_solutions`. You should just get rid of the first one and allow parallelization in the second.\n\n\n  - `number_of_solutions_iterator` is now `_number_of_solutions_iterator`\n  - `number_of_solutions` now allows parallel computation\n  - I kept `_number_of_solutions_iterator` because for the problem I am currently looking at, `number_of_solutions` takes days while `_number_of_solutions_iterator`  yield something once every hours. So it allows me to follow the computation, making sure it is not stuck and evaluate the duration left to do. I prefer this way rather than removing method `_number_of_solutions_iterator` and adding some verbose thing in `number_of_solutions`.\n\n> - Why not also make available parallelization for getting the list of solutions?\n\n\nBecause I don't know how or if it is possible to use the parallel decorator to merge iterators.",
    "created_at": "2015-09-05T15:45:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255763",
    "user": "https://github.com/seblabbe"
}
```

Thanks for your review! I fixed the first comments.

> - I do not see the point of having `number_of_solutions_iterator` and `number_of_solutions`. You should just get rid of the first one and allow parallelization in the second.


  - `number_of_solutions_iterator` is now `_number_of_solutions_iterator`
  - `number_of_solutions` now allows parallel computation
  - I kept `_number_of_solutions_iterator` because for the problem I am currently looking at, `number_of_solutions` takes days while `_number_of_solutions_iterator`  yield something once every hours. So it allows me to follow the computation, making sure it is not stuck and evaluate the duration left to do. I prefer this way rather than removing method `_number_of_solutions_iterator` and adding some verbose thing in `number_of_solutions`.

> - Why not also make available parallelization for getting the list of solutions?


Because I don't know how or if it is possible to use the parallel decorator to merge iterators.



---

archive/issue_comments_255764.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-05T15:45:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255764",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_255765.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-09-07T17:33:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255765",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_255766.json:
```json
{
    "body": "Salut Sebastien,\n\nThanks for your patience. I am sure that the choice of splitting is suboptimal but at least the design is much cleaner than in the first version.\n\nVincent",
    "created_at": "2015-09-07T17:33:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255766",
    "user": "https://github.com/videlec"
}
```

Salut Sebastien,

Thanks for your patience. I am sure that the choice of splitting is suboptimal but at least the design is much cleaner than in the first version.

Vincent



---

archive/issue_events_052900.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-09-08T14:41:15Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18987#event-52900"
}
```



---

archive/issue_comments_255767.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-09-08T14:41:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18987",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18987#issuecomment-255767",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
