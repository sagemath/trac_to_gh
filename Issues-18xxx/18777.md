# Issue 18777: Tarjan Strongly Connected Components Algorithm

archive/issues_018777.json:
```json
{
    "body": "CC:  @nathanncohen @dcoudert\n\nKeywords: Strongly connected components, Tarjan\n\nImplement Tarjan's Strongly Connected Components algorithm. For more information, see !https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19014\n\n",
    "closed_at": "2015-08-21T01:56:19Z",
    "created_at": "2015-08-12T09:17:16Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "Tarjan Strongly Connected Components Algorithm",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18777",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```
CC:  @nathanncohen @dcoudert

Keywords: Strongly connected components, Tarjan

Implement Tarjan's Strongly Connected Components algorithm. For more information, see !https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.

Issue created by migration from https://trac.sagemath.org/ticket/19014





---

archive/issue_comments_256189.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to graph theory.",
    "created_at": "2015-08-12T09:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256189",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing component from PLEASE CHANGE to graph theory.



---

archive/issue_comments_256190.json:
```json
{
    "body": "Changing keywords from \"\" to \"Strongly connected components, Tarjan\".",
    "created_at": "2015-08-12T09:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256190",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing keywords from "" to "Strongly connected components, Tarjan".



---

archive/issue_comments_256191.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2015-08-12T09:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256191",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_256192.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-13T13:39:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256192",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256193.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-13T13:49:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256193",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_256194.json:
```json
{
    "body": "Hi!\n\nI think Sage was really missing a linear-time algorithm for strongly connected components (in particular, I implemented it because I need it for other algorithms). It improves a lot the old algorithm when the graph has many components, but it is a bit slower when the graph is connected, as shown by the following examples. In any case, I removed the old algorithm: I know that it might have been faster in some rare cases, but the difference is small, and the time spent to input the graph is usually bigger than the time needed to run this algorithm.\n\nDo you like it?\n\nMichele\n\n```\nOld algorithm\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n100 loops, best of 3: 18.3 ms per loop\nNew algorithm\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 5.61 s per loop\n\nOld algorithm\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 98.4 ms per loop\nNew algorithm\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 183 ms per loop\n```",
    "created_at": "2015-08-13T13:49:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256194",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Hi!

I think Sage was really missing a linear-time algorithm for strongly connected components (in particular, I implemented it because I need it for other algorithms). It improves a lot the old algorithm when the graph has many components, but it is a bit slower when the graph is connected, as shown by the following examples. In any case, I removed the old algorithm: I know that it might have been faster in some rare cases, but the difference is small, and the time spent to input the graph is usually bigger than the time needed to run this algorithm.

Do you like it?

Michele

```
Old algorithm
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 18.3 ms per loop
New algorithm
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 5.61 s per loop

Old algorithm
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 98.4 ms per loop
New algorithm
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 183 ms per loop
```



---

archive/issue_comments_256195.json:
```json
{
    "body": "Hello,\n\nYou have inverted the timing for GNM. I got\n\n```\nOLD algorithm\nsage: set_random_seed(0)\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 7.87 s per loop\nsage: g.add_cycle(g.vertices())\nsage: %timeit g.strongly_connected_components()\n100 loops, best of 3: 21 ms per loop\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 142 ms per loop\n\nNEW algorithm\nsage: set_random_seed(0)\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n100 loops, best of 3: 21.5 ms per loop\nsage: g.add_cycle(g.vertices())\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 22.1 ms per loop\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 260 ms per loop\n```\n\nI agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.\n\nI have some remarks:\n- Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n- What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?\n- You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?\n- Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n- In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.\n- I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n\n```\nd = {i:list() for i in range(nscc)}\nfor u,i in scc.iteritems():\n    d[i].append(u)\noutput = [d[i] for i in range(nscc)]\n```\n\nDavid.",
    "created_at": "2015-08-13T16:40:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256195",
    "user": "https://github.com/dcoudert"
}
```

Hello,

You have inverted the timing for GNM. I got

```
OLD algorithm
sage: set_random_seed(0)
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 7.87 s per loop
sage: g.add_cycle(g.vertices())
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 21 ms per loop
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 142 ms per loop

NEW algorithm
sage: set_random_seed(0)
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 21.5 ms per loop
sage: g.add_cycle(g.vertices())
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 22.1 ms per loop
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 260 ms per loop
```

I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

I have some remarks:
- Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
- What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?
- You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?
- Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
- In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.
- I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like

```
d = {i:list() for i in range(nscc)}
for u,i in scc.iteritems():
    d[i].append(u)
output = [d[i] for i in range(nscc)]
```

David.



---

archive/issue_comments_256196.json:
```json
{
    "body": "> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.\n\n\nIs there any slowdown for `is_strongly_connected`?\n\nNathann",
    "created_at": "2015-08-13T17:07:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256196",
    "user": "https://github.com/nathanncohen"
}
```

> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.


Is there any slowdown for `is_strongly_connected`?

Nathann



---

archive/issue_comments_256197.json:
```json
{
    "body": "I don't see any slowdown, But there is room for improvements...\n- Without this patch\n\n```\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(10000,50000)\nsage: %timeit D.is_strongly_connected()\n100 loops, best of 3: 10.2 ms per loop\nsage: D.add_cycle(D.vertices())\nsage: %timeit D.is_strongly_connected()\n10 loops, best of 3: 20.9 ms per loop\n```\n- With this patch\n\n```\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(10000,50000)\nsage: %timeit D.is_strongly_connected()\n100 loops, best of 3: 9.98 ms per loop\nsage: D.add_cycle(D.vertices())\nsage: %timeit D.is_strongly_connected()\n10 loops, best of 3: 22 ms per loop\n```\n\nDavid.",
    "created_at": "2015-08-13T17:25:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256197",
    "user": "https://github.com/dcoudert"
}
```

I don't see any slowdown, But there is room for improvements...
- Without this patch

```
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(10000,50000)
sage: %timeit D.is_strongly_connected()
100 loops, best of 3: 10.2 ms per loop
sage: D.add_cycle(D.vertices())
sage: %timeit D.is_strongly_connected()
10 loops, best of 3: 20.9 ms per loop
```
- With this patch

```
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(10000,50000)
sage: %timeit D.is_strongly_connected()
100 loops, best of 3: 9.98 ms per loop
sage: D.add_cycle(D.vertices())
sage: %timeit D.is_strongly_connected()
10 loops, best of 3: 22 ms per loop
```

David.



---

archive/issue_comments_256198.json:
```json
{
    "body": "Okayokay, it seems orthogonal. Thanks!",
    "created_at": "2015-08-13T17:28:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256198",
    "user": "https://github.com/nathanncohen"
}
```

Okayokay, it seems orthogonal. Thanks!



---

archive/issue_comments_256199.json:
```json
{
    "body": "Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.\nWe need a backward BFS/DFS to get ride of this dependency.",
    "created_at": "2015-08-13T17:36:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256199",
    "user": "https://github.com/dcoudert"
}
```

Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.
We need a backward BFS/DFS to get ride of this dependency.



---

archive/issue_comments_256200.json:
```json
{
    "body": "Hello!\n\nI think that the method `is_strongly_connected` does not depend on this patch, and what you are proposing is already implemented in routine `is_strongly_connected` in `c_graph` (which also saves some time since it does not copy the whole graph). \n\nIndeed, this method is much simpler than computing SCCs: it performs a forward and backward visit from any node, and sees if we reach all vertices. Hence, I think it should be left as it is. For completeness, I attach the code of this routine.\n\nSoon I will correct all the issues you raised in comment 5!\n\nSee you,\n\nMichele\n\n```\n\u00a0\u00a0\u00a0 def is_strongly_connected(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cdef int v_int = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cdef CGraph cg = self._cg\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # Pick one vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 v_int = bitset_first(cg.active_vertices)\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if v_int == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return True\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 v = self.vertex_label(v_int)\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cdef int n = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for _ in self.depth_first_search(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if cg.num_verts != n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for _ in self.depth_first_search(v, reverse=True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return cg.num_verts == n\n```\nReplying to [comment:9 dcoudert]:\n\n> Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.\n> We need a backward BFS/DFS to get ride of this dependency.",
    "created_at": "2015-08-14T08:09:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256200",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Hello!

I think that the method `is_strongly_connected` does not depend on this patch, and what you are proposing is already implemented in routine `is_strongly_connected` in `c_graph` (which also saves some time since it does not copy the whole graph). 

Indeed, this method is much simpler than computing SCCs: it performs a forward and backward visit from any node, and sees if we reach all vertices. Hence, I think it should be left as it is. For completeness, I attach the code of this routine.

Soon I will correct all the issues you raised in comment 5!

See you,

Michele

```
    def is_strongly_connected(self):
        cdef int v_int = 0
        cdef CGraph cg = self._cg

        # Pick one vertex
        v_int = bitset_first(cg.active_vertices)

        if v_int == -1:
            return True

        v = self.vertex_label(v_int)

        cdef int n = 0
        for _ in self.depth_first_search(v):
            n += 1
        if cg.num_verts != n:
            return False
        n = 0
        for _ in self.depth_first_search(v, reverse=True):
            n += 1
        return cg.num_verts == n
```
Replying to [comment:9 dcoudert]:

> Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.
> We need a backward BFS/DFS to get ride of this dependency.



---

archive/issue_comments_256201.json:
```json
{
    "body": "Replying to [comment:5 dcoudert]:\n\n> Hello,\n> \n> You have inverted the timing for GNM. I got\n> \n> ```\n> OLD algorithm\n> sage: set_random_seed(0)\n> sage: g = digraphs.RandomDirectedGNM(10000,30000)\n> sage: %timeit g.strongly_connected_components()\n> 1 loops, best of 3: 7.87 s per loop\n> sage: g.add_cycle(g.vertices())\n> sage: %timeit g.strongly_connected_components()\n> 100 loops, best of 3: 21 ms per loop\n> sage: g = digraphs.Circuit(100000)\n> sage: %timeit g.strongly_connected_components()\n> 10 loops, best of 3: 142 ms per loop\n> \n> NEW algorithm\n> sage: set_random_seed(0)\n> sage: g = digraphs.RandomDirectedGNM(10000,30000)\n> sage: %timeit g.strongly_connected_components()\n> 100 loops, best of 3: 21.5 ms per loop\n> sage: g.add_cycle(g.vertices())\n> sage: %timeit g.strongly_connected_components()\n> 10 loops, best of 3: 22.1 ms per loop\n> sage: g = digraphs.Circuit(100000)\n> sage: %timeit g.strongly_connected_components()\n> 10 loops, best of 3: 260 ms per loop\n> ```\n> \n> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.\n\n\nUps, sorry! Clearly, the fastest method was the new one.\n\n> I have some remarks:\n> - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n\n\nYes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?\n\n> - What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?\n\n\nYou are right: I have moved all the code in `static_sparse_graph.pyx`, and I removed the dictionary. In order to import the method to DiGraph, I used types.methodtype.\n\n> - You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?\n\n\nYou are right, it is an old remnant of old routines, used only in a test. I removed everything.\n\n> - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n\n\nHmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.\n\n> - In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.\n\n\nSince I removed the bitsets, now I use `MemoryAllocator`.\n\n> - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n> \n> ```\n> d = {i:list() for i in range(nscc)}\n> for u,i in scc.iteritems():\n> d[i].append(u)\n> output = [d[i] for i in range(nscc)]\n> ```\n\n\nWell, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.\n\n```\nWITH NUMPY\nsage: g = DiGraph(10000000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 9.44 s per loop\n\nWITH DICTIONARIES\nsage: g = DiGraph(10000000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 9.87 s per loop\n```\n> David.\n\n\n[1] !http://arxiv.org/abs/1507.01490",
    "created_at": "2015-08-14T09:09:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256201",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Replying to [comment:5 dcoudert]:

> Hello,
> 
> You have inverted the timing for GNM. I got
> 
> ```
> OLD algorithm
> sage: set_random_seed(0)
> sage: g = digraphs.RandomDirectedGNM(10000,30000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 7.87 s per loop
> sage: g.add_cycle(g.vertices())
> sage: %timeit g.strongly_connected_components()
> 100 loops, best of 3: 21 ms per loop
> sage: g = digraphs.Circuit(100000)
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 142 ms per loop
> 
> NEW algorithm
> sage: set_random_seed(0)
> sage: g = digraphs.RandomDirectedGNM(10000,30000)
> sage: %timeit g.strongly_connected_components()
> 100 loops, best of 3: 21.5 ms per loop
> sage: g.add_cycle(g.vertices())
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 22.1 ms per loop
> sage: g = digraphs.Circuit(100000)
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 260 ms per loop
> ```
> 
> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.


Ups, sorry! Clearly, the fastest method was the new one.

> I have some remarks:
> - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?


Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?

> - What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?


You are right: I have moved all the code in `static_sparse_graph.pyx`, and I removed the dictionary. In order to import the method to DiGraph, I used types.methodtype.

> - You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?


You are right, it is an old remnant of old routines, used only in a test. I removed everything.

> - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`


Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.

> - In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.


Since I removed the bitsets, now I use `MemoryAllocator`.

> - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> 
> ```
> d = {i:list() for i in range(nscc)}
> for u,i in scc.iteritems():
> d[i].append(u)
> output = [d[i] for i in range(nscc)]
> ```


Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.

```
WITH NUMPY
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 9.44 s per loop

WITH DICTIONARIES
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 9.87 s per loop
```
> David.


[1] !http://arxiv.org/abs/1507.01490



---

archive/issue_comments_256202.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-14T09:17:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256202",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256203.json:
```json
{
    "body": "> > I have some remarks:\n> > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n \n> \n> Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?\n\n\nIf you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.\nWith Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.\n \n> > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n \n> \n> Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.\n\n\nWell, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.\n \n> > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n> > \n> > ```\n> > d = {i:list() for i in range(nscc)}\n> > for u,i in scc.iteritems():\n> > d[i].append(u)\n> > output = [d[i] for i in range(nscc)]\n> > ```\n\n> \n> Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.\n> \n> \n> ```\n> WITH NUMPY\n> sage: g = DiGraph(10000000)\n> sage: %timeit g.strongly_connected_components()\n> 1 loops, best of 3: 9.44 s per loop\n> \n> WITH DICTIONARIES\n> sage: g = DiGraph(10000000)\n> sage: %timeit g.strongly_connected_components()\n> 1 loops, best of 3: 9.87 s per loop\n> ```\n\n\nanother option (don't know if it is faster or not)\n\n```\ncdef int i\ncdef list output = list(list() for i in range(nscc))  # We cannot use [] here\nfor i,v in enumerate(G.vertex_iterator()):\n    output[scc[i]].append(v)\n```\n\nMethod `strongly_connected_components_digraph`:\n- is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be\n- seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.\n\n\n\nGeneral comments:\n- `if visited[u] == 0:` -> `if not visited[u]`\n- `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list\n- you have broken doctests caused by this ticket. I have not tracked the dependencies.\n\n```\nsage -t --long src/sage/monoids/automatic_semigroup.py\n**********************************************************************\nFile \"src/sage/monoids/automatic_semigroup.py\", line 135, in sage.monoids.automatic_semigroup.AutomaticSemigroup\nFailed example:\n    map(sorted, M.j_classes())\nExpected:\n    [[[], [2]], [[1, 1], [1]]]\nGot:\n    [[[1], [1, 1]], [[], [2]]]\n**********************************************************************\nFile \"src/sage/monoids/automatic_semigroup.py\", line 137, in sage.monoids.automatic_semigroup.AutomaticSemigroup\nFailed example:\n    M.j_classes_of_idempotents()\nExpected:\n    [[[]], [[1, 1]]]\nGot:\n    [[[1, 1]], [[]]]\n**********************************************************************\nFile \"src/sage/monoids/automatic_semigroup.py\", line 139, in sage.monoids.automatic_semigroup.AutomaticSemigroup\nFailed example:\n    M.j_transversal_of_idempotents()\nExpected:\n    [[], [1, 1]]\nGot:\n    [[1, 1], []]\n**********************************************************************\n1 item had failures:\n   3 of  80 in sage.monoids.automatic_semigroup.AutomaticSemigroup\n    [264 tests, 3 failures, 1.94 s]\nsage -t --long src/sage/categories/finite_semigroups.py\n**********************************************************************\nFile \"src/sage/categories/finite_semigroups.py\", line 119, in sage.categories.finite_semigroups.FiniteSemigroups.ParentMethods.j_transversal_of_idempotents\nFailed example:\n    sorted(S.j_transversal_of_idempotents())\nExpected:\n    ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']\nGot:\n    ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']\n```",
    "created_at": "2015-08-14T14:24:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256203",
    "user": "https://github.com/dcoudert"
}
```

> > I have some remarks:
> > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
 
> 
> Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?


If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.
With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.
 
> > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
 
> 
> Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.


Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.
 
> > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> > 
> > ```
> > d = {i:list() for i in range(nscc)}
> > for u,i in scc.iteritems():
> > d[i].append(u)
> > output = [d[i] for i in range(nscc)]
> > ```

> 
> Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.
> 
> 
> ```
> WITH NUMPY
> sage: g = DiGraph(10000000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 9.44 s per loop
> 
> WITH DICTIONARIES
> sage: g = DiGraph(10000000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 9.87 s per loop
> ```


another option (don't know if it is faster or not)

```
cdef int i
cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
for i,v in enumerate(G.vertex_iterator()):
    output[scc[i]].append(v)
```

Method `strongly_connected_components_digraph`:
- is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be
- seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.



General comments:
- `if visited[u] == 0:` -> `if not visited[u]`
- `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list
- you have broken doctests caused by this ticket. I have not tracked the dependencies.

```
sage -t --long src/sage/monoids/automatic_semigroup.py
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 135, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    map(sorted, M.j_classes())
Expected:
    [[[], [2]], [[1, 1], [1]]]
Got:
    [[[1], [1, 1]], [[], [2]]]
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 137, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    M.j_classes_of_idempotents()
Expected:
    [[[]], [[1, 1]]]
Got:
    [[[1, 1]], [[]]]
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 139, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    M.j_transversal_of_idempotents()
Expected:
    [[], [1, 1]]
Got:
    [[1, 1], []]
**********************************************************************
1 item had failures:
   3 of  80 in sage.monoids.automatic_semigroup.AutomaticSemigroup
    [264 tests, 3 failures, 1.94 s]
sage -t --long src/sage/categories/finite_semigroups.py
**********************************************************************
File "src/sage/categories/finite_semigroups.py", line 119, in sage.categories.finite_semigroups.FiniteSemigroups.ParentMethods.j_transversal_of_idempotents
Failed example:
    sorted(S.j_transversal_of_idempotents())
Expected:
    ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
Got:
    ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
```



---

archive/issue_comments_256204.json:
```json
{
    "body": "Hello!\nLet me try to address these problems!\nThank you very much,\nMichele\n\nReplying to [comment:13 dcoudert]:\n\n> > > I have some remarks:\n> > > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n> > > \n> > > \n> > > \n> > > \n \n> > \n> > Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?\n> > \n> > \n> > \n> > \n\n> \n> If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.\n> With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.\n\n\nDone!\n\n> > > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n> > > \n> > > \n> > > \n> > > \n \n> > \n> > Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.\n> > \n> > \n> > \n> > \n\n> \n> Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.\n\n\nOk, let's leave it as it is!\n\n> > > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n> > > \n> > > ```\n> > > d = {i:list() for i in range(nscc)}\n> > > for u,i in scc.iteritems():\n> > > d[i].append(u)\n> > > output = [d[i] for i in range(nscc)]\n> > > ```\n> > > \n> > > \n> > > \n> > > \n\n> > \n> > Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.\n> > \n> > \n> > ```\n> > WITH NUMPY\n> > sage: g = DiGraph(10000000)\n> > sage: %timeit g.strongly_connected_components()\n> > 1 loops, best of 3: 9.44 s per loop\n> > \n> > WITH DICTIONARIES\n> > sage: g = DiGraph(10000000)\n> > sage: %timeit g.strongly_connected_components()\n> > 1 loops, best of 3: 9.87 s per loop\n> > ```\n> > \n> > \n> > \n> > \n\n> \n> another option (don't know if it is faster or not)\n> \n> ```\n> cdef int i\n> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here\n> for i,v in enumerate(G.vertex_iterator()):\n> output[scc[i]].append(v)\n> ```\n\n\nCool! Not only it is simpler, it is also faster!\n\n```\nsage: g = DiGraph(10000000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 7.89 s per loop\n```\n> Method `strongly_connected_components_digraph`:\n> - is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be\n> - seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.\n\n\nHmmm, this is the hard part of my answer...\n\nThe problem is that I will need a C algorithm working on `static_sparse_graphs` to compute the digraph of strongly connected components in linear time, with no parallel edge. I think this is the only way to do it: I know it is complicated, but I do not know any other way. Do you think I should use n dictionaries, to check for parallel edges?\n\n> General comments:\n> - `if visited[u] == 0:` -> `if not visited[u]`\n\n\nDone!\n\n> - `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list\n\n\nDone!\n\n> - you have broken doctests caused by this ticket. I have not tracked the dependencies.\n\n\nThe problem is the order in which strongly connected components are outputted in the list: we can change the results without any problem. In the following, I try to explain why.\n\n> {{{\n> sage -t --long src/sage/monoids/automatic_semigroup.py\n> **********************************************************************\n> File \"src/sage/monoids/automatic_semigroup.py\", line 135, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> Failed example:\n> map(sorted, M.j_classes())\n> Expected:\n> [[[], [2]], [[1, 1], [1]]]\n> Got:\n> [[[1], [1, 1]], [[], [2]]]\n\n\nThe J-classes are sets of elements in a semigroups satisfying a specific property (for more information, see http://www.liafa.jussieu.fr/~jep/PDF/HandBook.pdf). The difference amont the results is the order in which the elements are listed, but since in sets the order does not count, both results are correct.\n\n> **********************************************************************\n> File \"src/sage/monoids/automatic_semigroup.py\", line 137, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> Failed example:\n> M.j_classes_of_idempotents()\n> Expected:\n> [This is the Trac macro *[* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-macro), [This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro)]\n> Got:\n> [This is the Trac macro *[1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[1, 1-macro), [[]]]\n\n\nHere, the difference is the order in which the two classes of idempotents are outputted. Since method j_classes_of_idempotents does not set a specific order, both results are correct.\n\n> **********************************************************************\n> File \"src/sage/monoids/automatic_semigroup.py\", line 139, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> Failed example:\n> M.j_transversal_of_idempotents()\n> Expected:\n> [[], [1, 1]]\n> Got:\n> [[1, 1], []]\n\n\nHere, we simply get one element from the classes found in the previous example: the order is maintained. Hence, both results are again correct.\n\n> **********************************************************************\n> 1 item had failures:\n> 3 of  80 in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> [264 tests, 3 failures, 1.94 s]\n> sage -t --long src/sage/categories/finite_semigroups.py\n> **********************************************************************\n> File \"src/sage/categories/finite_semigroups.py\", line 119, in sage.categories.finite_semigroups.[This is the Trac macro *FiniteSemigroups* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#FiniteSemigroups-macro).[This is the Trac macro *ParentMethods* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#ParentMethods-macro).j_transversal_of_idempotents\n> Failed example:\n> sorted(S.j_transversal_of_idempotents())\n> Expected:\n> ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']\n> Got:\n> ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']\n> }}}\n\n\nHere, 'abc' is in the same class of idempotents as 'acb', and 'bc' is in the same class of idempotents as 'cb', as shown by the example before this one. Since this routine should output one idempotent per class, we are fine!",
    "created_at": "2015-08-16T17:42:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256204",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Hello!
Let me try to address these problems!
Thank you very much,
Michele

Replying to [comment:13 dcoudert]:

> > > I have some remarks:
> > > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
> > > 
> > > 
> > > 
> > > 
 
> > 
> > Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?
> > 
> > 
> > 
> > 

> 
> If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.
> With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.


Done!

> > > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
> > > 
> > > 
> > > 
> > > 
 
> > 
> > Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.
> > 
> > 
> > 
> > 

> 
> Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.


Ok, let's leave it as it is!

> > > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> > > 
> > > ```
> > > d = {i:list() for i in range(nscc)}
> > > for u,i in scc.iteritems():
> > > d[i].append(u)
> > > output = [d[i] for i in range(nscc)]
> > > ```
> > > 
> > > 
> > > 
> > > 

> > 
> > Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.
> > 
> > 
> > ```
> > WITH NUMPY
> > sage: g = DiGraph(10000000)
> > sage: %timeit g.strongly_connected_components()
> > 1 loops, best of 3: 9.44 s per loop
> > 
> > WITH DICTIONARIES
> > sage: g = DiGraph(10000000)
> > sage: %timeit g.strongly_connected_components()
> > 1 loops, best of 3: 9.87 s per loop
> > ```
> > 
> > 
> > 
> > 

> 
> another option (don't know if it is faster or not)
> 
> ```
> cdef int i
> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
> for i,v in enumerate(G.vertex_iterator()):
> output[scc[i]].append(v)
> ```


Cool! Not only it is simpler, it is also faster!

```
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 7.89 s per loop
```
> Method `strongly_connected_components_digraph`:
> - is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be
> - seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.


Hmmm, this is the hard part of my answer...

The problem is that I will need a C algorithm working on `static_sparse_graphs` to compute the digraph of strongly connected components in linear time, with no parallel edge. I think this is the only way to do it: I know it is complicated, but I do not know any other way. Do you think I should use n dictionaries, to check for parallel edges?

> General comments:
> - `if visited[u] == 0:` -> `if not visited[u]`


Done!

> - `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list


Done!

> - you have broken doctests caused by this ticket. I have not tracked the dependencies.


The problem is the order in which strongly connected components are outputted in the list: we can change the results without any problem. In the following, I try to explain why.

> {{{
> sage -t --long src/sage/monoids/automatic_semigroup.py
> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 135, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> map(sorted, M.j_classes())
> Expected:
> [[[], [2]], [[1, 1], [1]]]
> Got:
> [[[1], [1, 1]], [[], [2]]]


The J-classes are sets of elements in a semigroups satisfying a specific property (for more information, see http://www.liafa.jussieu.fr/~jep/PDF/HandBook.pdf). The difference amont the results is the order in which the elements are listed, but since in sets the order does not count, both results are correct.

> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 137, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> M.j_classes_of_idempotents()
> Expected:
> [This is the Trac macro *[* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-macro), [This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro)]
> Got:
> [This is the Trac macro *[1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[1, 1-macro), [[]]]


Here, the difference is the order in which the two classes of idempotents are outputted. Since method j_classes_of_idempotents does not set a specific order, both results are correct.

> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 139, in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> M.j_transversal_of_idempotents()
> Expected:
> [[], [1, 1]]
> Got:
> [[1, 1], []]


Here, we simply get one element from the classes found in the previous example: the order is maintained. Hence, both results are again correct.

> **********************************************************************
> 1 item had failures:
> 3 of  80 in sage.monoids.automatic_semigroup.[This is the Trac macro *AutomaticSemigroup* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> [264 tests, 3 failures, 1.94 s]
> sage -t --long src/sage/categories/finite_semigroups.py
> **********************************************************************
> File "src/sage/categories/finite_semigroups.py", line 119, in sage.categories.finite_semigroups.[This is the Trac macro *FiniteSemigroups* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#FiniteSemigroups-macro).[This is the Trac macro *ParentMethods* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#ParentMethods-macro).j_transversal_of_idempotents
> Failed example:
> sorted(S.j_transversal_of_idempotents())
> Expected:
> ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
> Got:
> ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
> }}}


Here, 'abc' is in the same class of idempotents as 'acb', and 'bc' is in the same class of idempotents as 'cb', as shown by the example before this one. Since this routine should output one idempotent per class, we are fine!



---

archive/issue_comments_256205.json:
```json
{
    "body": "Just a detail, for future references:\n\n```\ncdef int i\ncdef list output = list(list() for i in range(nscc))  # We cannot use [] here\nfor i,v in enumerate(G.vertex_iterator()):\noutput[scc[i]].append(v)\n\n```\nIf we use `G.vertex_iterator()`, the vertex labels are not correct (I also added an example with labels, that shows the problem). With `G.vertices()`, everything works fine.\n\nWhy?",
    "created_at": "2015-08-16T21:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256205",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Just a detail, for future references:

```
cdef int i
cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
for i,v in enumerate(G.vertex_iterator()):
output[scc[i]].append(v)

```
If we use `G.vertex_iterator()`, the vertex labels are not correct (I also added an example with labels, that shows the problem). With `G.vertices()`, everything works fine.

Why?



---

archive/issue_comments_256206.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-16T21:24:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256206",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256207.json:
```json
{
    "body": "because `G.vertices()` sorts the output (I know, I know...). I fixed something similar recently in an igraph ticket: the output of `.edge_iterator` is not the same as `.edges`.\n\nNathann",
    "created_at": "2015-08-16T21:25:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256207",
    "user": "https://github.com/nathanncohen"
}
```

because `G.vertices()` sorts the output (I know, I know...). I fixed something similar recently in an igraph ticket: the output of `.edge_iterator` is not the same as `.edges`.

Nathann



---

archive/issue_comments_256208.json:
```json
{
    "body": "In method `tarjan_strongly_connected_components_C`, you could do the following:\n\n```\nif visited[v]:\n   continue\n```\nand then remove one level of indentation.\n\nIn method `strongly_connected_components_digraph_C`.\n\n```\n   output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n   if output.edges == NULL and output.m != 0:\n       raise ValueError(\"Problem while allocating memory (edges)\")\n   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n   if output.neighbors == NULL and output.m != 0:\n       raise ValueError(\"Problem while allocating memory (neighbors)\")\n```\nmust be replaced by something link\n\n```\n   if output.m==0:\n      << DO APPROPRIATE OPERATIONS FOR THIS CASE >>\n      << RETURN >>\n\n   output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n   if output.edges == NULL or output.neighbors == NULL:\n       raise MemoryError(\"Problem while allocating memory (edges or neighbors).\")\n```\nThis is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.\n\n\nOtherwise, the method is working very well\n\n```\nBefore\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(100000,500000)\nsage: D.is_strongly_connected()\nFalse\nsage: %time res = D.strongly_connected_components()\nlen(res)\nCPU times: user 3min 50s, sys: 4.28 s, total: 3min 55s\nWall time: 3min 56s\nsage: len(res)\n1413\n\nWith this patch\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(100000,500000)\nsage: D.is_strongly_connected()\nFalse\nsage: %time res = D.strongly_connected_components()\nCPU times: user 481 ms, sys: 16.2 ms, total: 497 ms\nWall time: 499 ms\nsage: len(res)\n1413\nsage: D.allow_multiple_edges(True)\nsage: D\nMulti-digraph on 100000 vertices\nsage: D.add_edges(D.edges())\nsage: D.size()\n1000000\nsage: %time res = D.strongly_connected_components()\nCPU times: user 566 ms, sys: 20.4 ms, total: 587 ms\nWall time: 594 ms\nsage: len(res)\n1413\n```\nand as you can see, I also tried with a multi-digraph and its working as expected.\n\nDavid.",
    "created_at": "2015-08-17T11:45:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256208",
    "user": "https://github.com/dcoudert"
}
```

In method `tarjan_strongly_connected_components_C`, you could do the following:

```
if visited[v]:
   continue
```
and then remove one level of indentation.

In method `strongly_connected_components_digraph_C`.

```
   output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
   if output.edges == NULL and output.m != 0:
       raise ValueError("Problem while allocating memory (edges)")
   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
   if output.neighbors == NULL and output.m != 0:
       raise ValueError("Problem while allocating memory (neighbors)")
```
must be replaced by something link

```
   if output.m==0:
      << DO APPROPRIATE OPERATIONS FOR THIS CASE >>
      << RETURN >>

   output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
   if output.edges == NULL or output.neighbors == NULL:
       raise MemoryError("Problem while allocating memory (edges or neighbors).")
```
This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.


Otherwise, the method is working very well

```
Before
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(100000,500000)
sage: D.is_strongly_connected()
False
sage: %time res = D.strongly_connected_components()
len(res)
CPU times: user 3min 50s, sys: 4.28 s, total: 3min 55s
Wall time: 3min 56s
sage: len(res)
1413

With this patch
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(100000,500000)
sage: D.is_strongly_connected()
False
sage: %time res = D.strongly_connected_components()
CPU times: user 481 ms, sys: 16.2 ms, total: 497 ms
Wall time: 499 ms
sage: len(res)
1413
sage: D.allow_multiple_edges(True)
sage: D
Multi-digraph on 100000 vertices
sage: D.add_edges(D.edges())
sage: D.size()
1000000
sage: %time res = D.strongly_connected_components()
CPU times: user 566 ms, sys: 20.4 ms, total: 587 ms
Wall time: 594 ms
sage: len(res)
1413
```
and as you can see, I also tried with a multi-digraph and its working as expected.

David.



---

archive/issue_comments_256209.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-17T11:45:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256209",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_256210.json:
```json
{
    "body": "Done!\n\n> \n> In method `tarjan_strongly_connected_components_C`, you could do the following:\n> \n> ```\n> if visited[v]:\n> continue\n> ```\n> and then remove one level of indentation.\n\n\nProbably, you meant\n\n```\nif visited[u]:\n    continue\n```\nbecause the line `if visited[v]:` is followed by an else. Correct?\n\n> In method `strongly_connected_components_digraph_C`.\n> \n> ```\n> output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n> if output.edges == NULL and output.m != 0:\n> raise ValueError(\"Problem while allocating memory (edges)\")\n> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n> if output.neighbors == NULL and output.m != 0:\n> raise ValueError(\"Problem while allocating memory (neighbors)\")\n> ```\n> must be replaced by something link\n> \n> ```\n> if output.m==0:\n> << DO APPROPRIATE OPERATIONS FOR THIS CASE >>\n> << RETURN >>\n> \n> output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n> if output.edges == NULL or output.neighbors == NULL:\n> raise MemoryError(\"Problem while allocating memory (edges or neighbors).\")\n> ```\n> This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.\n\n\nHmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?\n\n[1] !http://stackoverflow.com/questions/1073157/zero-size-malloc",
    "created_at": "2015-08-17T14:56:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256210",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Done!

> 
> In method `tarjan_strongly_connected_components_C`, you could do the following:
> 
> ```
> if visited[v]:
> continue
> ```
> and then remove one level of indentation.


Probably, you meant

```
if visited[u]:
    continue
```
because the line `if visited[v]:` is followed by an else. Correct?

> In method `strongly_connected_components_digraph_C`.
> 
> ```
> output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
> if output.edges == NULL and output.m != 0:
> raise ValueError("Problem while allocating memory (edges)")
> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
> if output.neighbors == NULL and output.m != 0:
> raise ValueError("Problem while allocating memory (neighbors)")
> ```
> must be replaced by something link
> 
> ```
> if output.m==0:
> << DO APPROPRIATE OPERATIONS FOR THIS CASE >>
> << RETURN >>
> 
> output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
> if output.edges == NULL or output.neighbors == NULL:
> raise MemoryError("Problem while allocating memory (edges or neighbors).")
> ```
> This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.


Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?

[1] !http://stackoverflow.com/questions/1073157/zero-size-malloc



---

archive/issue_comments_256211.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-17T15:10:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256211",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256212.json:
```json
{
    "body": "> because the line `if visited[v]:` is followed by an else. Correct?\n\n\nyou did the correct modification.\n \n> > In method `strongly_connected_components_digraph_C`.\n\n> ...\n> \n> Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?\n> \n> [1] !http://stackoverflow.com/questions/1073157/zero-size-malloc\n\n\nI have checked in files `sage/ext/memory_allocator.pyx`. It uses methods like `check_allocarray` which can be found in `memory.pxd`. These methods ensure that if `n==0` then the returned pointer is `NULL`, and this is compiler independent. Furthermore, these methods raise an error if something goes wrong with malloc. So no need for opening a ticket, it's already done ;)\nSo if you want to be on the safe side and to ease your life, use the memory allocator and/or the `check_alloc` methods, depending on the context.\nIn your code, it means that you can call\n\n```\noutput.edges = <uint32_t *> check_allocarray(m, sizeof(uint32_t))\n```\nand then remove the NULL test.\n\nOf course, what you did for the case `m==0` is also important. \n\nDavid.",
    "created_at": "2015-08-17T16:17:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256212",
    "user": "https://github.com/dcoudert"
}
```

> because the line `if visited[v]:` is followed by an else. Correct?


you did the correct modification.
 
> > In method `strongly_connected_components_digraph_C`.

> ...
> 
> Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?
> 
> [1] !http://stackoverflow.com/questions/1073157/zero-size-malloc


I have checked in files `sage/ext/memory_allocator.pyx`. It uses methods like `check_allocarray` which can be found in `memory.pxd`. These methods ensure that if `n==0` then the returned pointer is `NULL`, and this is compiler independent. Furthermore, these methods raise an error if something goes wrong with malloc. So no need for opening a ticket, it's already done ;)
So if you want to be on the safe side and to ease your life, use the memory allocator and/or the `check_alloc` methods, depending on the context.
In your code, it means that you can call

```
output.edges = <uint32_t *> check_allocarray(m, sizeof(uint32_t))
```
and then remove the NULL test.

Of course, what you did for the case `m==0` is also important. 

David.



---

archive/issue_comments_256213.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-17T17:02:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256213",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256214.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-17T17:02:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256214",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_256215.json:
```json
{
    "body": "Done!",
    "created_at": "2015-08-17T17:02:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256215",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Done!



---

archive/issue_comments_256216.json:
```json
{
    "body": "Good.\nDavid.",
    "created_at": "2015-08-17T18:43:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256216",
    "user": "https://github.com/dcoudert"
}
```

Good.
David.



---

archive/issue_comments_256217.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-08-17T18:43:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256217",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_256218.json:
```json
{
    "body": "I'll take it this is caused by this ticket:\n\nhttp://build.sagemath.org/release/builders/%20%20slow%20AIMS%20%20%28Debian%207%2064%20bit%29%20incremental/builds/40/steps/compile/logs/stdio",
    "created_at": "2015-08-18T21:33:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256218",
    "user": "https://github.com/vbraun"
}
```

I'll take it this is caused by this ticket:

http://build.sagemath.org/release/builders/%20%20slow%20AIMS%20%20%28Debian%207%2064%20bit%29%20incremental/builds/40/steps/compile/logs/stdio



---

archive/issue_comments_256219.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2015-08-18T21:33:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256219",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_256220.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-18T22:12:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256220",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256221.json:
```json
{
    "body": "Yes, I think the problem is caused by this ticket, because I changed the language of `static_sparse_graph` from C to C++ (I needed vectors). In particular, I think the problem was the use of `stdint` library, as explained in [1]. I replaced this library with `limits`, and now it should work.\n\n[1] !http://stackoverflow.com/questions/3233054/error-int32-max-was-not-declared-in-this-scope",
    "created_at": "2015-08-18T22:16:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256221",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Yes, I think the problem is caused by this ticket, because I changed the language of `static_sparse_graph` from C to C++ (I needed vectors). In particular, I think the problem was the use of `stdint` library, as explained in [1]. I replaced this library with `limits`, and now it should work.

[1] !http://stackoverflow.com/questions/3233054/error-int32-max-was-not-declared-in-this-scope



---

archive/issue_comments_256222.json:
```json
{
    "body": "Hello,\n\ncould you change in the doctest of `tarjan_strongly_connected_components`\n\n```\n       sage: for i in range(100):                                     # long\n       ...        g = digraphs.RandomDirectedGNP(100,.05)\n```\nwith\n\n```\n       sage: for i in range(100):                                     # long\n       ....:      g = digraphs.RandomDirectedGNP(100,.05)\n```\nso use `...` with `....:` for continuation.\nSorry to miss it before.\nAnd also you can now change `for i in range(100)` with something small in all test.\n\nDavid.",
    "created_at": "2015-08-19T06:49:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256222",
    "user": "https://github.com/dcoudert"
}
```

Hello,

could you change in the doctest of `tarjan_strongly_connected_components`

```
       sage: for i in range(100):                                     # long
       ...        g = digraphs.RandomDirectedGNP(100,.05)
```
with

```
       sage: for i in range(100):                                     # long
       ....:      g = digraphs.RandomDirectedGNP(100,.05)
```
so use `...` with `....:` for continuation.
Sorry to miss it before.
And also you can now change `for i in range(100)` with something small in all test.

David.



---

archive/issue_comments_256223.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-19T08:08:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256223",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256224.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-19T08:13:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256224",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_256225.json:
```json
{
    "body": "Done!",
    "created_at": "2015-08-19T08:13:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256225",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Done!



---

archive/issue_comments_256226.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-08-19T09:59:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256226",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_256227.json:
```json
{
    "body": "This patch passes all tests/docbuild/etc. on my mac.\n\nDavid.",
    "created_at": "2015-08-19T09:59:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256227",
    "user": "https://github.com/dcoudert"
}
```

This patch passes all tests/docbuild/etc. on my mac.

David.



---

archive/issue_comments_256228.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-08-21T01:56:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256228",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_052928.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-08-21T01:56:19Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18777#event-52928"
}
```



---

archive/issue_comments_256229.json:
```json
{
    "body": "Replying to [comment:13 dcoudert]:\n> {{{\n> cdef int i\n> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here\n> for i,v in enumerate(G.vertex_iterator()):\n>     output[scc[i]].append(v)\n> }}}\n\n\nWhy the `# We cannot use [] here`??? I am changing this in #23123 to use `[]`.",
    "created_at": "2017-06-02T09:38:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256229",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:13 dcoudert]:
> {{{
> cdef int i
> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
> for i,v in enumerate(G.vertex_iterator()):
>     output[scc[i]].append(v)
> }}}


Why the `# We cannot use [] here`??? I am changing this in #23123 to use `[]`.



---

archive/issue_comments_256230.json:
```json
{
    "body": "If I remember well (but it was 2 years ago), at the time Michele implemented the method,  the `output` list was containing `nscc` pointers to the same (empty) list when using `[]`.",
    "created_at": "2017-06-03T10:36:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18777",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18777#issuecomment-256230",
    "user": "https://github.com/dcoudert"
}
```

If I remember well (but it was 2 years ago), at the time Michele implemented the method,  the `output` list was containing `nscc` pointers to the same (empty) list when using `[]`.
