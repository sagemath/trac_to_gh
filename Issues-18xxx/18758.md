# Issue 18758: Allow actions of a parent on itself

archive/issues_018521.json:
```json
{
    "body": "Currently, `ModuleElement.__mul__` raises an error when both elements have the same parent. Hence, in order to define a ring structure, one must not start with `ModuleElement`, which is bad, since sometimes the concrete structure only depends on the category (see CombinatorialFreeModule).\n\nThe approach to be implemented here: `ModuleElement.__mul__` and `RingElement.__mul__` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of `ModuleElement.__mul__`) to complain if the two elements come from the same parent without an action being defined.\n\nHence, it should be possible to start with `ModuleElement` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:\n\n```\nsage: from sage.categories.action import Action\nsage: class RingStructure(Action):\n....:     def __init__(self, R):\n....:         Action.__init__(self, R, R, True, operator.mul)\n....:     def _call_(self, g, a):\n....:         return g._mul_(a)\n....:     \nsage: from sage.structure.element import ModuleElement\nsage: class MyElement(ModuleElement):\n....:     def __init__(self, P, L):\n....:         ModuleElement.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\n....:     \nsage: class MyParent(Parent):\n....:     Element = MyElement\n....:     def _get_action_(self, S, op, self_on_left):\n....:         if S is self and op == operator.mul and self_on_left:\n....:             return RingStructure(self)\n....:         \nsage: P = MyParent(category=Rings())\nsage: l1 = P([1,2])\nsage: l2 = P([3,4])\nsage: l1+l2\n<[(1, 3), (2, 4)]>\nsage: l1*l2\n<[1, 2, 3, 4]>\n```\n\nMoreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., `_get_action_` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.\n\nMore precisely: The above `RingStructure` (perhaps with some sanity test similar to `sage.structure.coerce_action.ModuleAction`) should be defined in sage.structure.coerce_actions and used by `Rings.ParentMethods._get_action_`.\n\n__Summary__\n\n- multiplication can still be defined by category initialisation in `Magmas()`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.\n- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines `_mul_` and initialises in `Magmas()`. Overriding `__mul__` (which in some situations was still needed) should in future be even more useless.\n- Similar statements hold for `_add_`.\n\nCC:  @nthiery combinat\n\nKeywords: actions on itself\n\nAuthor: Simon King\n\nBranch: u/SimonKing/allow_actions_of_parent_on_itself\n\nStatus: needs_work\n\nDependencies: #18756\n\nCommit: d71a456dbd312980490f17d39ed97d3df6ccdcb9\n\nIssue created by migration from https://trac.sagemath.org/ticket/18758\n\n",
    "created_at": "2015-06-22T10:37:40Z",
    "labels": [
        "component: coercion"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.8",
    "title": "Allow actions of a parent on itself",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18758",
    "user": "https://github.com/simon-king-jena"
}
```
Currently, `ModuleElement.__mul__` raises an error when both elements have the same parent. Hence, in order to define a ring structure, one must not start with `ModuleElement`, which is bad, since sometimes the concrete structure only depends on the category (see CombinatorialFreeModule).

The approach to be implemented here: `ModuleElement.__mul__` and `RingElement.__mul__` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of `ModuleElement.__mul__`) to complain if the two elements come from the same parent without an action being defined.

Hence, it should be possible to start with `ModuleElement` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:

```
sage: from sage.categories.action import Action
sage: class RingStructure(Action):
....:     def __init__(self, R):
....:         Action.__init__(self, R, R, True, operator.mul)
....:     def _call_(self, g, a):
....:         return g._mul_(a)
....:     
sage: from sage.structure.element import ModuleElement
sage: class MyElement(ModuleElement):
....:     def __init__(self, P, L):
....:         ModuleElement.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
....:     
sage: class MyParent(Parent):
....:     Element = MyElement
....:     def _get_action_(self, S, op, self_on_left):
....:         if S is self and op == operator.mul and self_on_left:
....:             return RingStructure(self)
....:         
sage: P = MyParent(category=Rings())
sage: l1 = P([1,2])
sage: l2 = P([3,4])
sage: l1+l2
<[(1, 3), (2, 4)]>
sage: l1*l2
<[1, 2, 3, 4]>
```

Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., `_get_action_` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.

More precisely: The above `RingStructure` (perhaps with some sanity test similar to `sage.structure.coerce_action.ModuleAction`) should be defined in sage.structure.coerce_actions and used by `Rings.ParentMethods._get_action_`.

__Summary__

- multiplication can still be defined by category initialisation in `Magmas()`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.
- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines `_mul_` and initialises in `Magmas()`. Overriding `__mul__` (which in some situations was still needed) should in future be even more useless.
- Similar statements hold for `_add_`.

CC:  @nthiery combinat

Keywords: actions on itself

Author: Simon King

Branch: u/SimonKing/allow_actions_of_parent_on_itself

Status: needs_work

Dependencies: #18756

Commit: d71a456dbd312980490f17d39ed97d3df6ccdcb9

Issue created by migration from https://trac.sagemath.org/ticket/18758





---

archive/issue_comments_268073.json:
```json
{
    "body": "<a id='comment:1'></a>See comment 24 at #18756 for why I think we should have a dependency.",
    "created_at": "2015-06-22T20:58:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268073",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>See comment 24 at #18756 for why I think we should have a dependency.



---

archive/issue_comments_268074.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -2,11 +2,46 @@\n \n The approach to be implemented here: \\`ModuleElement.__mul__\\` and \\`RingElement.__mul__\\` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of \\`ModuleElement.__mul__\\`) to complain if the two elements come from the same parent without an action being defined.\n \n-Hence, it should be possible to start with \\`ModuleElement\\` and get a ring structure on top of it by an appropriate action of the parent on itself.\n+Hence, it should be possible to start with \\`ModuleElement\\` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:\n \n-Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \\`_get_action_\\` should be moved from Parent to Sets.ParentMethods.\n+\\`\\`\\`\n+sage: from sage.categories.action import Action\n+sage: class RingStructure(Action):\n+....:     def __init__(self, R):\n+....:         Action.__init__(self, R, R, True, operator.mul)\n+....:     def _call_(self, g, a):\n+....:         return g._mul_(a)\n+....:     \n+sage: from sage.structure.element import ModuleElement\n+sage: class MyElement(ModuleElement):\n+....:     def __init__(self, P, L):\n+....:         ModuleElement.__init__(self, P)\n+....:         self.l = L\n+....:     def _repr_(self):\n+....:         return \"<{}>\".format(self.l)\n+....:     def _add_(self, other):\n+....:         return self.parent()(zip(self.l, other.l))\n+....:     def _mul_(self, other):\n+....:         return self.parent()(self.l+other.l)\n+....:     \n+sage: class MyParent(Parent):\n+....:     Element = MyElement\n+....:     def _get_action_(self, S, op, self_on_left):\n+....:         if S is self and op == operator.mul and self_on_left:\n+....:             return RingStructure(self)\n+....:         \n+sage: P = MyParent(category=Rings())\n+sage: l1 = P([1,2])\n+sage: l2 = P([3,4])\n+sage: l1+l2\n+<[(1, 3), (2, 4)]>\n+sage: l1*l2\n+<[1, 2, 3, 4]>\n+\\`\\`\\`\n \n-This is motivated by the discussion on #18756\n+Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \\`_get_action_\\` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.\n+\n+More precisely: The above \\`RingStructure\\` (perhaps with some sanity test similar to \\`sage.structure.coerce_action.ModuleAction\\`) should be defined in sage.structure.coerce_actions\\` and used by \\`Rings.ParentMethods._get_action_\\`.\n \n Comment: 1\n \n```\n",
    "created_at": "2015-06-24T22:57:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268074",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
```diff
--- 
+++ 
@@ -2,11 +2,46 @@
 
 The approach to be implemented here: \`ModuleElement.__mul__\` and \`RingElement.__mul__\` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of \`ModuleElement.__mul__\`) to complain if the two elements come from the same parent without an action being defined.
 
-Hence, it should be possible to start with \`ModuleElement\` and get a ring structure on top of it by an appropriate action of the parent on itself.
+Hence, it should be possible to start with \`ModuleElement\` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:
 
-Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \`_get_action_\` should be moved from Parent to Sets.ParentMethods.
+\`\`\`
+sage: from sage.categories.action import Action
+sage: class RingStructure(Action):
+....:     def __init__(self, R):
+....:         Action.__init__(self, R, R, True, operator.mul)
+....:     def _call_(self, g, a):
+....:         return g._mul_(a)
+....:     
+sage: from sage.structure.element import ModuleElement
+sage: class MyElement(ModuleElement):
+....:     def __init__(self, P, L):
+....:         ModuleElement.__init__(self, P)
+....:         self.l = L
+....:     def _repr_(self):
+....:         return "<{}>".format(self.l)
+....:     def _add_(self, other):
+....:         return self.parent()(zip(self.l, other.l))
+....:     def _mul_(self, other):
+....:         return self.parent()(self.l+other.l)
+....:     
+sage: class MyParent(Parent):
+....:     Element = MyElement
+....:     def _get_action_(self, S, op, self_on_left):
+....:         if S is self and op == operator.mul and self_on_left:
+....:             return RingStructure(self)
+....:         
+sage: P = MyParent(category=Rings())
+sage: l1 = P([1,2])
+sage: l2 = P([3,4])
+sage: l1+l2
+<[(1, 3), (2, 4)]>
+sage: l1*l2
+<[1, 2, 3, 4]>
+\`\`\`
 
-This is motivated by the discussion on #18756
+Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \`_get_action_\` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.
+
+More precisely: The above \`RingStructure\` (perhaps with some sanity test similar to \`sage.structure.coerce_action.ModuleAction\`) should be defined in sage.structure.coerce_actions\` and used by \`Rings.ParentMethods._get_action_\`.
 
 Comment: 1
 
```




---

archive/issue_comments_268075.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,4 +1,47 @@\n+Currently, \\`ModuleElement.__mul__\\` raises an error when both elements have the same parent. Hence, in order to define a ring structure, one must not start with \\`ModuleElement\\`, which is bad, since sometimes the concrete structure only depends on the category (see CombinatorialFreeModule).\n \n+The approach to be implemented here: \\`ModuleElement.__mul__\\` and \\`RingElement.__mul__\\` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of \\`ModuleElement.__mul__\\`) to complain if the two elements come from the same parent without an action being defined.\n+\n+Hence, it should be possible to start with \\`ModuleElement\\` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:\n+\n+\\`\\`\\`\n+sage: from sage.categories.action import Action\n+sage: class RingStructure(Action):\n+....:     def __init__(self, R):\n+....:         Action.__init__(self, R, R, True, operator.mul)\n+....:     def _call_(self, g, a):\n+....:         return g._mul_(a)\n+....:     \n+sage: from sage.structure.element import ModuleElement\n+sage: class MyElement(ModuleElement):\n+....:     def __init__(self, P, L):\n+....:         ModuleElement.__init__(self, P)\n+....:         self.l = L\n+....:     def _repr_(self):\n+....:         return \"<{}>\".format(self.l)\n+....:     def _add_(self, other):\n+....:         return self.parent()(zip(self.l, other.l))\n+....:     def _mul_(self, other):\n+....:         return self.parent()(self.l+other.l)\n+....:     \n+sage: class MyParent(Parent):\n+....:     Element = MyElement\n+....:     def _get_action_(self, S, op, self_on_left):\n+....:         if S is self and op == operator.mul and self_on_left:\n+....:             return RingStructure(self)\n+....:         \n+sage: P = MyParent(category=Rings())\n+sage: l1 = P([1,2])\n+sage: l2 = P([3,4])\n+sage: l1+l2\n+<[(1, 3), (2, 4)]>\n+sage: l1*l2\n+<[1, 2, 3, 4]>\n+\\`\\`\\`\n+\n+Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \\`_get_action_\\` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.\n+\n+More precisely: The above \\`RingStructure\\` (perhaps with some sanity test similar to \\`sage.structure.coerce_action.ModuleAction\\`) should be defined in sage.structure.coerce_actions and used by \\`Rings.ParentMethods._get_action_\\`.\n \n Comment: 1\n \n```\n",
    "created_at": "2015-06-24T22:58:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268075",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,4 +1,47 @@
+Currently, \`ModuleElement.__mul__\` raises an error when both elements have the same parent. Hence, in order to define a ring structure, one must not start with \`ModuleElement\`, which is bad, since sometimes the concrete structure only depends on the category (see CombinatorialFreeModule).
 
+The approach to be implemented here: \`ModuleElement.__mul__\` and \`RingElement.__mul__\` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of \`ModuleElement.__mul__\`) to complain if the two elements come from the same parent without an action being defined.
+
+Hence, it should be possible to start with \`ModuleElement\` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:
+
+\`\`\`
+sage: from sage.categories.action import Action
+sage: class RingStructure(Action):
+....:     def __init__(self, R):
+....:         Action.__init__(self, R, R, True, operator.mul)
+....:     def _call_(self, g, a):
+....:         return g._mul_(a)
+....:     
+sage: from sage.structure.element import ModuleElement
+sage: class MyElement(ModuleElement):
+....:     def __init__(self, P, L):
+....:         ModuleElement.__init__(self, P)
+....:         self.l = L
+....:     def _repr_(self):
+....:         return "<{}>".format(self.l)
+....:     def _add_(self, other):
+....:         return self.parent()(zip(self.l, other.l))
+....:     def _mul_(self, other):
+....:         return self.parent()(self.l+other.l)
+....:     
+sage: class MyParent(Parent):
+....:     Element = MyElement
+....:     def _get_action_(self, S, op, self_on_left):
+....:         if S is self and op == operator.mul and self_on_left:
+....:             return RingStructure(self)
+....:         
+sage: P = MyParent(category=Rings())
+sage: l1 = P([1,2])
+sage: l2 = P([3,4])
+sage: l1+l2
+<[(1, 3), (2, 4)]>
+sage: l1*l2
+<[1, 2, 3, 4]>
+\`\`\`
+
+Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \`_get_action_\` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.
+
+More precisely: The above \`RingStructure\` (perhaps with some sanity test similar to \`sage.structure.coerce_action.ModuleAction\`) should be defined in sage.structure.coerce_actions and used by \`Rings.ParentMethods._get_action_\`.
 
 Comment: 1
 
```




---

archive/issue_comments_268076.json:
```json
{
    "body": "<a id='comment:4'></a>More precisely: The example from the ticket description shouldn't be called RingStructure but MagmaStructure, it should be defined in `Magmas.ParentMethods._get_action_`, and it should have an additive counterpart.",
    "created_at": "2015-06-24T23:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268076",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>More precisely: The example from the ticket description shouldn't be called RingStructure but MagmaStructure, it should be defined in `Magmas.ParentMethods._get_action_`, and it should have an additive counterpart.



---

archive/issue_comments_268077.json:
```json
{
    "body": "<a id='comment:5'></a>Remark: `Magmas.ElementMethods` does provide a generic multiplication using `_mul_` (when present) and using coercion otherwise.\n\nTwo problems: There is an import statement in the multiplication method, which, if I recall correctly, is not for free. And it first checks the presence of a `_mul_` attribute, which also slows things down.\n\nSo, it would be interesting to see if the following approach yields faster code:\n- ALL element classes should have generic `__mul__` and `__add__` methods. Those of `sage.structure.elements.Element` will just rely on coercion, whereas `ModuleElement` and `RingElement` first try a short-cut via `_mul_` resp. `_add_`. So, the hierarchy of algebraic base classes would be reflected in the usage of shortcuts.\n- The proposed actions `MagmaStructure` and `AdditiveMagmaStructure` should test the presence of the attributes `_mul_` resp. `_add_` during initialisation, ONCE. Henceforth, the presence of the attribute does not need to be tested any longer.\n\nSo, rather than providing a `__mul__` methods, `Magmas()` would provide an action, and there should be a `__mul__` method for Element instead. Really, we need to test and get timings.",
    "created_at": "2015-06-25T09:28:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268077",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>Remark: `Magmas.ElementMethods` does provide a generic multiplication using `_mul_` (when present) and using coercion otherwise.

Two problems: There is an import statement in the multiplication method, which, if I recall correctly, is not for free. And it first checks the presence of a `_mul_` attribute, which also slows things down.

So, it would be interesting to see if the following approach yields faster code:
- ALL element classes should have generic `__mul__` and `__add__` methods. Those of `sage.structure.elements.Element` will just rely on coercion, whereas `ModuleElement` and `RingElement` first try a short-cut via `_mul_` resp. `_add_`. So, the hierarchy of algebraic base classes would be reflected in the usage of shortcuts.
- The proposed actions `MagmaStructure` and `AdditiveMagmaStructure` should test the presence of the attributes `_mul_` resp. `_add_` during initialisation, ONCE. Henceforth, the presence of the attribute does not need to be tested any longer.

So, rather than providing a `__mul__` methods, `Magmas()` would provide an action, and there should be a `__mul__` method for Element instead. Really, we need to test and get timings.



---

archive/issue_comments_268078.json:
```json
{
    "body": "<a id='comment:6'></a>I haven't pushed my branch yet. Anyway, what I can do is the following:\n\n```\nsage: class MyElement(Element):\n....:     def __init__(self, P, L):\n....:         Element.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\nsage: class MyMElement(ModuleElement):\n....:     def __init__(self, P, L):\n....:         ModuleElement.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\nsage: class MyRElement(RingElement):\n....:     def __init__(self, P, L):\n....:         RingElement.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\nsage: class MyParent(Parent):\n....:     Element = MyElement\nsage: class MyMParent(Parent):\n....:     Element = MyMElement\nsage: class MyRParent(Parent):\n....:     Element = MyRElement\nsage: P = MyParent(category=Rings())\nsage: l = P([1,2])\nsage: l*l\n<[1, 2, 1, 2]>\nsage: PM = MyMParent(category=Rings())\nsage: lM = PM([1,2])\nsage: lM*lM\n<[1, 2, 1, 2]>\nsage: PR = MyRParent(category=Rings())\nsage: lR = PR([1,2])\nsage: lR*lR\n<[1, 2, 1, 2]>\nsage: %timeit l*l\nThe slowest run took 4.68 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 8.77 \u00b5s per loop\nsage: %timeit lM*lM\nThe slowest run took 6.35 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.89 \u00b5s per loop\nsage: %timeit lR*lR\nThe slowest run took 7.06 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.22 \u00b5s per loop\n```\n\nExplanation:\n1. In P, we use Element as starting point. It has no `__mul__`, hence, `__mul__` is obtained from some element method of the category of rings.\n2. In PM, we use ModuleElement as starting point.\n    - It has a `__mul__` method that in vanilla Sage would refuse to carry a ring structure. Hence, the above wouldn't work in vanilla Sage. I have changed the coercion framework so that it does not complain about a ring structure.\n    - Since it has a `__mul__` method, it cannot inherit a ring multiplication from the category element methods. Instead, the parent inherits `_get_action_` from category parent methods, as per #18756.\n3. This would be the \"classical\" way to define a ring structure.\n\nAs you can see, of course a specialised cythoned `__mul__` method for rings is fastest. The first approach is taken in `CombinatorialFreeModule`, if I understand correctly, and is slowest (not by much, but it is). The new approach to use an action of self on itself somehow is in the middle, speed-wise.\n\nBefore I push my branch, I'll see what happens if I provide `Element` with a default `__mul__` method that simply calls the coercion model. It will of course make the first approach impossible, but I guess it would speed-up the second (i.e., new) approach.",
    "created_at": "2015-06-25T17:42:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268078",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>I haven't pushed my branch yet. Anyway, what I can do is the following:

```
sage: class MyElement(Element):
....:     def __init__(self, P, L):
....:         Element.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
sage: class MyMElement(ModuleElement):
....:     def __init__(self, P, L):
....:         ModuleElement.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
sage: class MyRElement(RingElement):
....:     def __init__(self, P, L):
....:         RingElement.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
sage: class MyParent(Parent):
....:     Element = MyElement
sage: class MyMParent(Parent):
....:     Element = MyMElement
sage: class MyRParent(Parent):
....:     Element = MyRElement
sage: P = MyParent(category=Rings())
sage: l = P([1,2])
sage: l*l
<[1, 2, 1, 2]>
sage: PM = MyMParent(category=Rings())
sage: lM = PM([1,2])
sage: lM*lM
<[1, 2, 1, 2]>
sage: PR = MyRParent(category=Rings())
sage: lR = PR([1,2])
sage: lR*lR
<[1, 2, 1, 2]>
sage: %timeit l*l
The slowest run took 4.68 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 8.77 µs per loop
sage: %timeit lM*lM
The slowest run took 6.35 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.89 µs per loop
sage: %timeit lR*lR
The slowest run took 7.06 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.22 µs per loop
```

Explanation:
1. In P, we use Element as starting point. It has no `__mul__`, hence, `__mul__` is obtained from some element method of the category of rings.
2. In PM, we use ModuleElement as starting point.
    - It has a `__mul__` method that in vanilla Sage would refuse to carry a ring structure. Hence, the above wouldn't work in vanilla Sage. I have changed the coercion framework so that it does not complain about a ring structure.
    - Since it has a `__mul__` method, it cannot inherit a ring multiplication from the category element methods. Instead, the parent inherits `_get_action_` from category parent methods, as per #18756.
3. This would be the "classical" way to define a ring structure.

As you can see, of course a specialised cythoned `__mul__` method for rings is fastest. The first approach is taken in `CombinatorialFreeModule`, if I understand correctly, and is slowest (not by much, but it is). The new approach to use an action of self on itself somehow is in the middle, speed-wise.

Before I push my branch, I'll see what happens if I provide `Element` with a default `__mul__` method that simply calls the coercion model. It will of course make the first approach impossible, but I guess it would speed-up the second (i.e., new) approach.



---

archive/issue_comments_268079.json:
```json
{
    "body": "<a id='comment:7'></a>Replying to [comment:6 SimonKing]:\n> Before I push my branch, I'll see what happens if I provide `Element` with a default `__mul__` method that simply calls the coercion model. It will of course make the first approach impossible, but I guess it would speed-up the second (i.e., new) approach.\n\n\nTo be clear: It would still be the case that `CombinatorialFreeModuleElement` would be based on `Element`, and it would still be the case that it obtains `_mul_` (single underscore) from the category, and it would still be the case that it obtains multiplication from the category. The difference is that it does not obtain the multiplication by inheriting a `__mul__` (double underscore) method from the category, but by using a coerce action obtained from the category.\n\nIn particular, the existing user code will not change.",
    "created_at": "2015-06-25T17:50:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268079",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>Replying to [comment:6 SimonKing]:
> Before I push my branch, I'll see what happens if I provide `Element` with a default `__mul__` method that simply calls the coercion model. It will of course make the first approach impossible, but I guess it would speed-up the second (i.e., new) approach.


To be clear: It would still be the case that `CombinatorialFreeModuleElement` would be based on `Element`, and it would still be the case that it obtains `_mul_` (single underscore) from the category, and it would still be the case that it obtains multiplication from the category. The difference is that it does not obtain the multiplication by inheriting a `__mul__` (double underscore) method from the category, but by using a coerce action obtained from the category.

In particular, the existing user code will not change.



---

archive/issue_comments_268080.json:
```json
{
    "body": "<a id='comment:8'></a>Replying to [comment:6 SimonKing]:\n> Before I push my branch, I'll see what happens if I provide `Element` with a default `__mul__` method that simply calls the coercion model. It will of course make the first approach impossible, but I guess it would speed-up the second (i.e., new) approach.\n\n\nThis is what happens:\n\n```\nsage: %timeit l*l\nThe slowest run took 6.49 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.71 \u00b5s per loop\nsage: %timeit lM*lM\nThe slowest run took 5.82 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.91 \u00b5s per loop\nsage: %timeit lR*lR\nThe slowest run took 4.27 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.03 \u00b5s per loop\n```\n\nIn other words, using `Element` becomes faster when defining a ring structure than `ModuleElement`. Probable reason: The default `Element.__mul__` that I am suggesting will immediately use coercion, whereas `ModuleElement.__mul__` first tries some shortcut that is not available in my example.\n\nOf course, `RingElement.__mul__` is still fastest, as it uses the right shortcut.\n\nBefore pushing my branch, I plan to add tests and documentation. The documentation will go to `sage.structure.element` and `sage.structure.parent`. However, it is my experience that people using `sage.combinat` have a tendency to work around coercion (see for example `sage.combinat.permutation.Permutation.__mul__`).\n\nCan you suggest a place to put documentation on coercion so that it is actually found by sage.combinat users?",
    "created_at": "2015-06-25T20:58:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268080",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>Replying to [comment:6 SimonKing]:
> Before I push my branch, I'll see what happens if I provide `Element` with a default `__mul__` method that simply calls the coercion model. It will of course make the first approach impossible, but I guess it would speed-up the second (i.e., new) approach.


This is what happens:

```
sage: %timeit l*l
The slowest run took 6.49 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.71 µs per loop
sage: %timeit lM*lM
The slowest run took 5.82 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.91 µs per loop
sage: %timeit lR*lR
The slowest run took 4.27 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.03 µs per loop
```

In other words, using `Element` becomes faster when defining a ring structure than `ModuleElement`. Probable reason: The default `Element.__mul__` that I am suggesting will immediately use coercion, whereas `ModuleElement.__mul__` first tries some shortcut that is not available in my example.

Of course, `RingElement.__mul__` is still fastest, as it uses the right shortcut.

Before pushing my branch, I plan to add tests and documentation. The documentation will go to `sage.structure.element` and `sage.structure.parent`. However, it is my experience that people using `sage.combinat` have a tendency to work around coercion (see for example `sage.combinat.permutation.Permutation.__mul__`).

Can you suggest a place to put documentation on coercion so that it is actually found by sage.combinat users?



---

archive/issue_comments_268081.json:
```json
{
    "body": "<a id='comment:9'></a>I had a look at sage.combinat, and it turns out that the situation is not sooooo bad as I thought.\n1. `Permutation` needs to be sanitised. It inherits from `Element`. Since here I plan to introduce a default `Element.__mul__` using coercion model, `Permutation.__mul__` needs to be removed, and instead we need an action. It would be easy to implement, and I bet it is faster.\n2. `Word` does not even inherit from `Element`, but it mimics the element-parent scheme (by providing a cdef `_parent` attribute and a `parent()` method). It should be possible to determine the result of multiplication by looking at the involved parents. Hence:\n   - It would be a good idea to implement something like pushouts for families of words. Thus:\n   - It would make sense to have a `WordFunctor` construction functor from `Sets()` to an appropriate category. The appropriate category could be `Monoids()` in the case of finite or infinite words, but could be `Sets()` in the case of \"words avoiding 12\" and those things (i.e., the product of two pattern avoiding words is not necessarily pattern avoiding).\n\n   Then, one could finally take advantage of Sage's coercion framework for words.\n\nI suggest to sanitise Permutation here, but keep Word for a later ticket.",
    "created_at": "2015-06-25T23:39:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268081",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>I had a look at sage.combinat, and it turns out that the situation is not sooooo bad as I thought.
1. `Permutation` needs to be sanitised. It inherits from `Element`. Since here I plan to introduce a default `Element.__mul__` using coercion model, `Permutation.__mul__` needs to be removed, and instead we need an action. It would be easy to implement, and I bet it is faster.
2. `Word` does not even inherit from `Element`, but it mimics the element-parent scheme (by providing a cdef `_parent` attribute and a `parent()` method). It should be possible to determine the result of multiplication by looking at the involved parents. Hence:
   - It would be a good idea to implement something like pushouts for families of words. Thus:
   - It would make sense to have a `WordFunctor` construction functor from `Sets()` to an appropriate category. The appropriate category could be `Monoids()` in the case of finite or infinite words, but could be `Sets()` in the case of "words avoiding 12" and those things (i.e., the product of two pattern avoiding words is not necessarily pattern avoiding).

   Then, one could finally take advantage of Sage's coercion framework for words.

I suggest to sanitise Permutation here, but keep Word for a later ticket.



---

archive/issue_comments_268082.json:
```json
{
    "body": "<a id='comment:10'></a>PS: Having a pushout construction for permutations would also be nice. Again, it would be for a later ticket.",
    "created_at": "2015-06-25T23:54:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268082",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>PS: Having a pushout construction for permutations would also be nice. Again, it would be for a later ticket.



---

archive/issue_comments_268083.json:
```json
{
    "body": "<a id='comment:11'></a>PPS: Is it actually `Monoids()` in the case of infinite words? I guess one cannot multiply an infinite word with a finite or infinite word. One can only multiply a finite with a finite or infinite word. So, it is \"Monoidoids()\" (i.e., we have a partial multiplication that is associative when defined and has a unit).",
    "created_at": "2015-06-25T23:59:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268083",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>PPS: Is it actually `Monoids()` in the case of infinite words? I guess one cannot multiply an infinite word with a finite or infinite word. One can only multiply a finite with a finite or infinite word. So, it is "Monoidoids()" (i.e., we have a partial multiplication that is associative when defined and has a unit).



---

archive/issue_comments_268084.json:
```json
{
    "body": "<a id='comment:12'></a>It will not be easy to make my proposed changes work throughout the sage library. There are zillions of errors in sage.modular (I am sure this is because it was previously worked around coercion...). Well, we will see.",
    "created_at": "2015-06-26T00:22:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268084",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>It will not be easy to make my proposed changes work throughout the sage library. There are zillions of errors in sage.modular (I am sure this is because it was previously worked around coercion...). Well, we will see.



---

archive/issue_comments_268085.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,4 +1,53 @@\n+Currently, \\`ModuleElement.__mul__\\` raises an error when both elements have the same parent. Hence, in order to define a ring structure, one must not start with \\`ModuleElement\\`, which is bad, since sometimes the concrete structure only depends on the category (see CombinatorialFreeModule).\n \n+The approach to be implemented here: \\`ModuleElement.__mul__\\` and \\`RingElement.__mul__\\` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of \\`ModuleElement.__mul__\\`) to complain if the two elements come from the same parent without an action being defined.\n+\n+Hence, it should be possible to start with \\`ModuleElement\\` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:\n+\n+\\`\\`\\`\n+sage: from sage.categories.action import Action\n+sage: class RingStructure(Action):\n+....:     def __init__(self, R):\n+....:         Action.__init__(self, R, R, True, operator.mul)\n+....:     def _call_(self, g, a):\n+....:         return g._mul_(a)\n+....:     \n+sage: from sage.structure.element import ModuleElement\n+sage: class MyElement(ModuleElement):\n+....:     def __init__(self, P, L):\n+....:         ModuleElement.__init__(self, P)\n+....:         self.l = L\n+....:     def _repr_(self):\n+....:         return \"<{}>\".format(self.l)\n+....:     def _add_(self, other):\n+....:         return self.parent()(zip(self.l, other.l))\n+....:     def _mul_(self, other):\n+....:         return self.parent()(self.l+other.l)\n+....:     \n+sage: class MyParent(Parent):\n+....:     Element = MyElement\n+....:     def _get_action_(self, S, op, self_on_left):\n+....:         if S is self and op == operator.mul and self_on_left:\n+....:             return RingStructure(self)\n+....:         \n+sage: P = MyParent(category=Rings())\n+sage: l1 = P([1,2])\n+sage: l2 = P([3,4])\n+sage: l1+l2\n+<[(1, 3), (2, 4)]>\n+sage: l1*l2\n+<[1, 2, 3, 4]>\n+\\`\\`\\`\n+\n+Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \\`_get_action_\\` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.\n+\n+More precisely: The above \\`RingStructure\\` (perhaps with some sanity test similar to \\`sage.structure.coerce_action.ModuleAction\\`) should be defined in sage.structure.coerce_actions and used by \\`Rings.ParentMethods._get_action_\\`.\n+\n+__Summary__\n+\n+- multiplication can still be defined by category initialisation in \\`Magmas()\\`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.\n+- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines \\`_mul_\\` and initialises in \\`Magmas()\\`. Overriding \\`__mul__\\` (which in some situations was still needed) should in future be even more useless.\n+- Similar statements hold for \\`_add_\\`.\n \n Comment: 1\n \n```\n",
    "created_at": "2015-06-26T22:10:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268085",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,4 +1,53 @@
+Currently, \`ModuleElement.__mul__\` raises an error when both elements have the same parent. Hence, in order to define a ring structure, one must not start with \`ModuleElement\`, which is bad, since sometimes the concrete structure only depends on the category (see CombinatorialFreeModule).
 
+The approach to be implemented here: \`ModuleElement.__mul__\` and \`RingElement.__mul__\` should provide short-cuts in cases where there is an obvious way to be faster than calling the coercion model, and otherwise it is the job of the coercion model (NOT of \`ModuleElement.__mul__\`) to complain if the two elements come from the same parent without an action being defined.
+
+Hence, it should be possible to start with \`ModuleElement\` and get a ring structure on top of it by an appropriate action of the parent on itself. Here is an example that should be made work:
+
+\`\`\`
+sage: from sage.categories.action import Action
+sage: class RingStructure(Action):
+....:     def __init__(self, R):
+....:         Action.__init__(self, R, R, True, operator.mul)
+....:     def _call_(self, g, a):
+....:         return g._mul_(a)
+....:     
+sage: from sage.structure.element import ModuleElement
+sage: class MyElement(ModuleElement):
+....:     def __init__(self, P, L):
+....:         ModuleElement.__init__(self, P)
+....:         self.l = L
+....:     def _repr_(self):
+....:         return "<{}>".format(self.l)
+....:     def _add_(self, other):
+....:         return self.parent()(zip(self.l, other.l))
+....:     def _mul_(self, other):
+....:         return self.parent()(self.l+other.l)
+....:     
+sage: class MyParent(Parent):
+....:     Element = MyElement
+....:     def _get_action_(self, S, op, self_on_left):
+....:         if S is self and op == operator.mul and self_on_left:
+....:             return RingStructure(self)
+....:         
+sage: P = MyParent(category=Rings())
+sage: l1 = P([1,2])
+sage: l2 = P([3,4])
+sage: l1+l2
+<[(1, 3), (2, 4)]>
+sage: l1*l2
+<[1, 2, 3, 4]>
+\`\`\`
+
+Moreover, it should be possible to define the actions using ParentMethods in the category framework. I.e., \`_get_action_\` should be moved from Parent to Sets.ParentMethods. This is why #18756 (where the whole idea started) is a dependency.
+
+More precisely: The above \`RingStructure\` (perhaps with some sanity test similar to \`sage.structure.coerce_action.ModuleAction\`) should be defined in sage.structure.coerce_actions and used by \`Rings.ParentMethods._get_action_\`.
+
+__Summary__
+
+- multiplication can still be defined by category initialisation in \`Magmas()\`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.
+- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines \`_mul_\` and initialises in \`Magmas()\`. Overriding \`__mul__\` (which in some situations was still needed) should in future be even more useless.
+- Similar statements hold for \`_add_\`.
 
 Comment: 1
 
```




---

archive/issue_comments_268086.json:
```json
{
    "body": "<a id='comment:14'></a>With the branch, that I have still not pushed, I get\n\n```\nsage -t src/sage/monoids/free_abelian_monoid.py  # 1 doctest failed\nsage -t src/sage/categories/primer.py  # 1 doctest failed\nsage -t src/sage/categories/rings.py  # 1 doctest failed\nsage -t src/sage/tests/gap_packages.py  # 1 doctest failed\nsage -t src/sage/tests/book_schilling_zabrocki_kschur_primer.py  # 2 doctests failed\nsage -t src/sage/groups/matrix_gps/group_element.py  # 1 doctest failed\nsage -t src/sage/groups/semimonomial_transformations/semimonomial_transformation.pyx  # 1 doctest failed\nsage -t src/sage/groups/perm_gps/permgroup_named.py  # 2 doctests failed\nsage -t src/sage/sets/finite_set_maps.py  # 3 doctests failed\nsage -t src/sage/dev/sagedev.py  # 2 doctests failed\nsage -t src/sage/combinat/posets/posets.py  # 1 doctest failed\nsage -t src/sage/combinat/sf/sf.py  # 3 doctests failed\nsage -t src/sage/combinat/sf/new_kschur.py  # 10 doctests failed\nsage -t src/sage/schemes/toric/morphism.py  # 3 doctests failed\nsage -t src/sage/geometry/fan_morphism.py  # 6 doctests failed\nsage -t src/sage/geometry/hyperplane_arrangement/hyperplane.py  # 1 doctest failed\n```\nNot so bad, actually...",
    "created_at": "2015-06-26T22:11:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268086",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>With the branch, that I have still not pushed, I get

```
sage -t src/sage/monoids/free_abelian_monoid.py  # 1 doctest failed
sage -t src/sage/categories/primer.py  # 1 doctest failed
sage -t src/sage/categories/rings.py  # 1 doctest failed
sage -t src/sage/tests/gap_packages.py  # 1 doctest failed
sage -t src/sage/tests/book_schilling_zabrocki_kschur_primer.py  # 2 doctests failed
sage -t src/sage/groups/matrix_gps/group_element.py  # 1 doctest failed
sage -t src/sage/groups/semimonomial_transformations/semimonomial_transformation.pyx  # 1 doctest failed
sage -t src/sage/groups/perm_gps/permgroup_named.py  # 2 doctests failed
sage -t src/sage/sets/finite_set_maps.py  # 3 doctests failed
sage -t src/sage/dev/sagedev.py  # 2 doctests failed
sage -t src/sage/combinat/posets/posets.py  # 1 doctest failed
sage -t src/sage/combinat/sf/sf.py  # 3 doctests failed
sage -t src/sage/combinat/sf/new_kschur.py  # 10 doctests failed
sage -t src/sage/schemes/toric/morphism.py  # 3 doctests failed
sage -t src/sage/geometry/fan_morphism.py  # 6 doctests failed
sage -t src/sage/geometry/hyperplane_arrangement/hyperplane.py  # 1 doctest failed
```
Not so bad, actually...



---

archive/issue_comments_268087.json:
```json
{
    "body": "<a id='comment:16'></a>I have changed the logic in the `bin_op()` method of the coercion model, so that it is safer against infinite recursion. The error messages in most cases do not just say that the operation \"+\" is unsupported, but say that a common parent has not been found. Changing the expected error messages is the hardest part of the latest commit.\n\nMost important change: The coercion model now makes actual use of single underscore methods!\n\nYou may be surprised by the implied statement that previously the coercion model did *not* use them. In fact, it didn't. Up to now, the single underscore methods have only been used as short-cuts in `RingElement.__mul__` and friends. I have changed it, so that the short-cut still works, but additionally the coercion model explicitly calls the single underscore methods (when available) if both operands belong to the same parent.",
    "created_at": "2015-06-28T08:30:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268087",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>I have changed the logic in the `bin_op()` method of the coercion model, so that it is safer against infinite recursion. The error messages in most cases do not just say that the operation "+" is unsupported, but say that a common parent has not been found. Changing the expected error messages is the hardest part of the latest commit.

Most important change: The coercion model now makes actual use of single underscore methods!

You may be surprised by the implied statement that previously the coercion model did *not* use them. In fact, it didn't. Up to now, the single underscore methods have only been used as short-cuts in `RingElement.__mul__` and friends. I have changed it, so that the short-cut still works, but additionally the coercion model explicitly calls the single underscore methods (when available) if both operands belong to the same parent.



---

archive/issue_comments_268088.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-06-28T08:30:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268088",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_268089.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-28T08:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268089",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268090.json:
```json
{
    "body": "<a id='comment:18'></a>Here are some timings. The code used:\n\n```\nsage: from sage.structure.element import Element, ModuleElement, RingElement\nsage: class MyElement(Element):\n....:     def __init__(self, P, L):\n....:         Element.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\nsage: class MyMElement(ModuleElement):\n....:     def __init__(self, P, L):\n....:         ModuleElement.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\nsage: class MyRElement(RingElement):\n....:     def __init__(self, P, L):\n....:         RingElement.__init__(self, P)\n....:         self.l = L\n....:     def _repr_(self):\n....:         return \"<{}>\".format(self.l)\n....:     def _add_(self, other):\n....:         return self.parent()(zip(self.l, other.l))\n....:     def _mul_(self, other):\n....:         return self.parent()(self.l+other.l)\nsage: class MyParent(Parent):\n....:     Element = MyElement\nsage: class MyMParent(Parent):\n....:     Element = MyMElement\nsage: class MyRParent(Parent):\n....:     Element = MyRElement\n```\n\nHere are different settings, where in each case I also compare with vanilla sage-6.8.beta5.\n1. Action obtained from the category:\n\n```\nsage: P = MyParent(category=Rings())\nsage: l = P([1,2])\nsage: %timeit l*l\nThe slowest run took 64.43 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.82 \u00b5s per loop  # 8.87 \u00b5s in beta5\nsage: %timeit l+l\nThe slowest run took 24.53 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 8.44 \u00b5s per loop # 9.49 \u00b5s in beta5\n```\n\n2. The coercion model using single underscore methods. Both examples won't work in beta5\n\n```\nsage: P = MyParent(category=Sets())\nsage: l = P([1,2])\nsage: %timeit l*l\nThe slowest run took 15.44 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 10.3 \u00b5s per loop\nsage: %timeit l+l\nThe slowest run took 11.54 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 10.7 \u00b5s per loop\n```\n\n3. ModuleElement using a short-cut for \"+\" and not complaining about a multiplication action obtained from the category:\n\n```\nsage: P = MyMParent(category=Rings())\nsage: l = P([1,2])\nsage: %timeit l*l\nThe slowest run took 108.72 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.88 \u00b5s per loop  # won't work in beta5\nsage: %timeit l+l\nThe slowest run took 5.98 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 8.05 \u00b5s per loop  # 8.01 \u00b5s in beta5 (of course no significant change)\n```\n\n4. ModuleElement using a shortcut for \"+\" and allowing the coercion model to use single underscore methods for \"*\":\n\n```\nsage: P = MyMParent(category=Sets())\nsage: l = P([1,2])\nsage: %timeit l*l\nThe slowest run took 14.45 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 10.7 \u00b5s per loop  # won't work in beta5\nsage: %timeit l+l\nThe slowest run took 4.25 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 8.69 \u00b5s per loop  # 8.02 \u00b5s in beta5. Should actually be the same time! This branch hasn't changed!\n```\n\n5. RingElement using short-cuts for \"+\" and for \"*\". Of course there are no significant changes wrt. beta5, as the short-cut didn't change.\n\n```\nsage: P = MyRParent(category=Sets())\nsage: l = P([1,2])\nsage: %timeit l*l\nThe slowest run took 4.75 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 7.12 \u00b5s per loop  # 7.02 \u00b5s with beta5\nsage: %timeit l+l\nThe slowest run took 4.58 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 8.07 \u00b5s per loop  # 7.98 \u00b5s with beta5\n```",
    "created_at": "2015-06-28T09:09:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268090",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>Here are some timings. The code used:

```
sage: from sage.structure.element import Element, ModuleElement, RingElement
sage: class MyElement(Element):
....:     def __init__(self, P, L):
....:         Element.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
sage: class MyMElement(ModuleElement):
....:     def __init__(self, P, L):
....:         ModuleElement.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
sage: class MyRElement(RingElement):
....:     def __init__(self, P, L):
....:         RingElement.__init__(self, P)
....:         self.l = L
....:     def _repr_(self):
....:         return "<{}>".format(self.l)
....:     def _add_(self, other):
....:         return self.parent()(zip(self.l, other.l))
....:     def _mul_(self, other):
....:         return self.parent()(self.l+other.l)
sage: class MyParent(Parent):
....:     Element = MyElement
sage: class MyMParent(Parent):
....:     Element = MyMElement
sage: class MyRParent(Parent):
....:     Element = MyRElement
```

Here are different settings, where in each case I also compare with vanilla sage-6.8.beta5.
1. Action obtained from the category:

```
sage: P = MyParent(category=Rings())
sage: l = P([1,2])
sage: %timeit l*l
The slowest run took 64.43 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.82 µs per loop  # 8.87 µs in beta5
sage: %timeit l+l
The slowest run took 24.53 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 8.44 µs per loop # 9.49 µs in beta5
```

2. The coercion model using single underscore methods. Both examples won't work in beta5

```
sage: P = MyParent(category=Sets())
sage: l = P([1,2])
sage: %timeit l*l
The slowest run took 15.44 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 10.3 µs per loop
sage: %timeit l+l
The slowest run took 11.54 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 10.7 µs per loop
```

3. ModuleElement using a short-cut for "+" and not complaining about a multiplication action obtained from the category:

```
sage: P = MyMParent(category=Rings())
sage: l = P([1,2])
sage: %timeit l*l
The slowest run took 108.72 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.88 µs per loop  # won't work in beta5
sage: %timeit l+l
The slowest run took 5.98 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 8.05 µs per loop  # 8.01 µs in beta5 (of course no significant change)
```

4. ModuleElement using a shortcut for "+" and allowing the coercion model to use single underscore methods for "*":

```
sage: P = MyMParent(category=Sets())
sage: l = P([1,2])
sage: %timeit l*l
The slowest run took 14.45 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 10.7 µs per loop  # won't work in beta5
sage: %timeit l+l
The slowest run took 4.25 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 8.69 µs per loop  # 8.02 µs in beta5. Should actually be the same time! This branch hasn't changed!
```

5. RingElement using short-cuts for "+" and for "*". Of course there are no significant changes wrt. beta5, as the short-cut didn't change.

```
sage: P = MyRParent(category=Sets())
sage: l = P([1,2])
sage: %timeit l*l
The slowest run took 4.75 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 7.12 µs per loop  # 7.02 µs with beta5
sage: %timeit l+l
The slowest run took 4.58 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 8.07 µs per loop  # 7.98 µs with beta5
```



---

archive/issue_comments_268091.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-03T16:22:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268091",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_268092.json:
```json
{
    "body": "<a id='comment:19'></a>Hello,\n\nThere are some clear troubles with the patchbot... some elements do not know how to multiply anymore.\n\nVincent",
    "created_at": "2015-08-03T16:22:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268092",
    "user": "https://github.com/videlec"
}
```

<a id='comment:19'></a>Hello,

There are some clear troubles with the patchbot... some elements do not know how to multiply anymore.

Vincent



---

archive/issue_comments_268093.json:
```json
{
    "body": "<a id='comment:20'></a>Also, the doctest coverage is not 100%.",
    "created_at": "2015-08-04T08:03:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268093",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>Also, the doctest coverage is not 100%.



---

archive/issue_comments_268094.json:
```json
{
    "body": "<a id='comment:21'></a>Replying to [comment:19 vdelecroix]:\n> There are some clear troubles with the patchbot... some elements do not know how to multiply anymore.\n\n\nIn two of the failing tests, it is just the error message that has changed. In the third, it could be that something needs to be done.",
    "created_at": "2015-08-04T08:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268094",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>Replying to [comment:19 vdelecroix]:
> There are some clear troubles with the patchbot... some elements do not know how to multiply anymore.


In two of the failing tests, it is just the error message that has changed. In the third, it could be that something needs to be done.



---

archive/issue_comments_268095.json:
```json
{
    "body": "<a id='comment:22'></a>If I recall correctly, some people have worked on similar issues. But I am not sure about the ticket numbers. Hence, is what I propose here done already?",
    "created_at": "2017-01-09T12:36:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18758",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18758#issuecomment-268095",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>If I recall correctly, some people have worked on similar issues. But I am not sure about the ticket numbers. Hence, is what I propose here done already?
