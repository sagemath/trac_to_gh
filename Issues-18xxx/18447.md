# Issue 18447: Implement dual-quasi-Schur basis in NCSF

archive/issues_018210.json:
```json
{
    "body": "One of the TODOs that remains in the documentation for ncsf_qsym is to implement a short list of bases from the literature.  One of those bases is the dual basis to the quasi-Schur basis of QSym.  We should be able to use the transition coefficients that are implemented in qsym.py to compute the dual quasi-Schur basis.  This may mean factoring out the methods from qsym.py to combinatorics.py or perhaps just accessing those methods where they are.\n\nThe quasi-Schur basis will be realized through the monomial basis (instead of the fundamental basis) because there are more efficient ways to compute the change of basis coefficients than were in the original implementation.\n\nCC:  sage-combinat @tscrim @darijgr\n\nKeywords: ncsf, qsym, quasiSchur, quasisymmetric\n\nReviewer: Travis Scrimshaw\n\nAuthor: Mike Zabrocki\n\nBranch: 05e4ab78c3027b9533f49f8dd0ae2b70f443d350\n\nDependencies: #18415\n\nCommit: 05e4ab78c3027b9533f49f8dd0ae2b70f443d350\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/18447\n\n",
    "closed_at": "2015-06-08T20:28:37Z",
    "created_at": "2015-05-19T02:26:50Z",
    "labels": [
        "component: combinatorics",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.7",
    "title": "Implement dual-quasi-Schur basis in NCSF",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18447",
    "user": "https://github.com/zabrocki"
}
```
One of the TODOs that remains in the documentation for ncsf_qsym is to implement a short list of bases from the literature.  One of those bases is the dual basis to the quasi-Schur basis of QSym.  We should be able to use the transition coefficients that are implemented in qsym.py to compute the dual quasi-Schur basis.  This may mean factoring out the methods from qsym.py to combinatorics.py or perhaps just accessing those methods where they are.

The quasi-Schur basis will be realized through the monomial basis (instead of the fundamental basis) because there are more efficient ways to compute the change of basis coefficients than were in the original implementation.

CC:  sage-combinat @tscrim @darijgr

Keywords: ncsf, qsym, quasiSchur, quasisymmetric

Reviewer: Travis Scrimshaw

Author: Mike Zabrocki

Branch: 05e4ab78c3027b9533f49f8dd0ae2b70f443d350

Dependencies: #18415

Commit: 05e4ab78c3027b9533f49f8dd0ae2b70f443d350

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/18447





---

archive/issue_comments_245542.json:
```json
{
    "body": "<a id='comment:1'></a>I am looking at how the quasisymmetric Schur basis was implemented and I think that there is work that should be done.  I would suggest that it is better implemented through the monomial basis (right now it is implemented in the fundamental basis).\n\nIt also seems that the notion of `CompositionTableau(x)` is too restrictive since it doesn't allow for general fillings of composition diagrams (which would be quite useful for the definitions of immaculate tableaux).  There is no documentation that indicates that the definition of `CompositionTableau` comes from [QSCHUR] Haglund, Luoto, Mason, van Willigenburg, *Quasisymmetric Schur functions*, J. Comb. Theory Ser. A 118 (2011), 463-490.\n\nI think that the original implementation in #13505 was made with the intention that one day it would be improved.\n\nHere is a down and dirty implementation of the dual basis.\n\n---\nLast 10 new commits:",
    "created_at": "2015-05-19T12:35:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245542",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:1'></a>I am looking at how the quasisymmetric Schur basis was implemented and I think that there is work that should be done.  I would suggest that it is better implemented through the monomial basis (right now it is implemented in the fundamental basis).

It also seems that the notion of `CompositionTableau(x)` is too restrictive since it doesn't allow for general fillings of composition diagrams (which would be quite useful for the definitions of immaculate tableaux).  There is no documentation that indicates that the definition of `CompositionTableau` comes from [QSCHUR] Haglund, Luoto, Mason, van Willigenburg, *Quasisymmetric Schur functions*, J. Comb. Theory Ser. A 118 (2011), 463-490.

I think that the original implementation in #13505 was made with the intention that one day it would be improved.

Here is a down and dirty implementation of the dual basis.

---
Last 10 new commits:



---

archive/issue_comments_245543.json:
```json
{
    "body": "<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-20T11:07:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245543",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245544.json:
```json
{
    "body": "<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-22T01:46:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245544",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245545.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-22T02:34:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245545",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245546.json:
```json
{
    "body": "<a id='comment:6'></a>This last commit makes the basis change from the complete basis rather than the ribbon basis using the new `number_of_SSRCT` method.  My speed test for this change was `timeit('dQS[1,2,1]*dQS[2,2]',number=1,repeat=1)`\nOn commit 8cbcc9b it takes about 45 seconds and on commit f72162f it takes a little more than 1 second.\n\nI think that what this means is that the Quasisymmetric_Schur basis should use a similar expansion using the monomial basis rather than the fundamental basis.",
    "created_at": "2015-05-22T02:42:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245546",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:6'></a>This last commit makes the basis change from the complete basis rather than the ribbon basis using the new `number_of_SSRCT` method.  My speed test for this change was `timeit('dQS[1,2,1]*dQS[2,2]',number=1,repeat=1)`
On commit 8cbcc9b it takes about 45 seconds and on commit f72162f it takes a little more than 1 second.

I think that what this means is that the Quasisymmetric_Schur basis should use a similar expansion using the monomial basis rather than the fundamental basis.



---

archive/issue_comments_245547.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-22T03:17:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245547",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245548.json:
```json
{
    "body": "<a id='comment:8'></a>I did another timing test on that shows that the improvement is less impressive if we need to compute a large example from the `dQS` basis to another basis.  I computed `timeit('dQS[2,2,2,2].coproduct()',number=1,repeat=1)` and on branch 8cbcc9b it took 53 seconds but on the current branch it takes 52 seconds.  I also checked on f7162f and it took 51 seconds.  It might be that we want to continue to use the to ribbon basis from the QS transition matrices.  I'll see if I can continue to improve the current branch.",
    "created_at": "2015-05-22T04:09:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245548",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:8'></a>I did another timing test on that shows that the improvement is less impressive if we need to compute a large example from the `dQS` basis to another basis.  I computed `timeit('dQS[2,2,2,2].coproduct()',number=1,repeat=1)` and on branch 8cbcc9b it took 53 seconds but on the current branch it takes 52 seconds.  I also checked on f7162f and it took 51 seconds.  It might be that we want to continue to use the to ribbon basis from the QS transition matrices.  I'll see if I can continue to improve the current branch.



---

archive/issue_comments_245549.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-22T12:28:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245549",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245550.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-22T20:42:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245550",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245551.json:
```json
{
    "body": "<a id='comment:11'></a>I am slightly concerned that what we call `CompositionTableaux` in Sage are 'semi-standard reverse composition tableaux' in the literature on quasisymmetric Schur functions. Moreover, the documentation for `CompositionTableaux` does not mention the origin of the mathematics of these objects.  As a class in Sage I think that we should have a definition of a class of objects that one would call composition tableaux (which would consist of all weakly increasing or decreasing fillings of composition diagrams) and that SSRCTs are a subclass of this set.\n\nMy modification in commit 0ba7a67 makes the change of basis done by inverting the `_from_complete_on_basis` morphism by triangularity.  It isn't lightening fast, but my test `timeit('dQS[2,2,2,2].coproduct()',number=1,repeat=1)` that was running at 50 some odd seconds now runs in about 19 seconds.\n\nThere is still work to be done to speed up the `Quasisymmetric_Schur` basis by using `number_of_SSRCT` for the `_to_monomial_on_basis` method and the inversion method by triangularity that I used for the dual to implement `_from_monomial_by_triangularity`.",
    "created_at": "2015-05-22T20:57:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245551",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:11'></a>I am slightly concerned that what we call `CompositionTableaux` in Sage are 'semi-standard reverse composition tableaux' in the literature on quasisymmetric Schur functions. Moreover, the documentation for `CompositionTableaux` does not mention the origin of the mathematics of these objects.  As a class in Sage I think that we should have a definition of a class of objects that one would call composition tableaux (which would consist of all weakly increasing or decreasing fillings of composition diagrams) and that SSRCTs are a subclass of this set.

My modification in commit 0ba7a67 makes the change of basis done by inverting the `_from_complete_on_basis` morphism by triangularity.  It isn't lightening fast, but my test `timeit('dQS[2,2,2,2].coproduct()',number=1,repeat=1)` that was running at 50 some odd seconds now runs in about 19 seconds.

There is still work to be done to speed up the `Quasisymmetric_Schur` basis by using `number_of_SSRCT` for the `_to_monomial_on_basis` method and the inversion method by triangularity that I used for the dual to implement `_from_monomial_by_triangularity`.



---

archive/issue_comments_245552.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-23T11:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245552",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245553.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-23T12:22:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245553",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245554.json:
```json
{
    "body": "<a id='comment:14'></a>Time tests on branch 943f817\n\n```\nsage: timeit('QS[2,2,2,1].coproduct()',number=1,repeat=1)\n1 loops, best of 1: 6.69 s per loop\nsage: timeit('QS[2,2,2,2].coproduct()',number=1,repeat=1)\n1 loops, best of 1: 56.2 s per loop\nsage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)\n1 loops, best of 1: 23.5 s per loop\nsage: timeit('QS[2,2,2].internal_coproduct()',number=1,repeat=1)\n1 loops, best of 1: 5.23 s per loop\n```\nTime tests on current branch\n\n```\nsage: timeit('QS[2,2,2,1].coproduct()',number=1,repeat=1)\n1 loops, best of 1: 5.33 s per loop\nsage: timeit('QS[2,2,2,2].coproduct()',number=1,repeat=1)\n1 loops, best of 1: 27.8 s per loop\nsage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)\n1 loops, best of 1: 18.1 s per loop\nsage: timeit('QS[2,2,2].internal_coproduct()',number=1,repeat=1)\n1 loops, best of 1: 42.5 s per loop\n```\nThe last example is perhaps telling.  It takes advantage of the cache more than the other calculations and in the new branch the conversion from the monomial basis is not cached.  On branch 943f817, the whole transition matrix at a given degree is calculated at the same time (in this case n=6) and this is used as many times as needed in order to convert to the QS basis.",
    "created_at": "2015-05-23T12:42:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245554",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:14'></a>Time tests on branch 943f817

```
sage: timeit('QS[2,2,2,1].coproduct()',number=1,repeat=1)
1 loops, best of 1: 6.69 s per loop
sage: timeit('QS[2,2,2,2].coproduct()',number=1,repeat=1)
1 loops, best of 1: 56.2 s per loop
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 23.5 s per loop
sage: timeit('QS[2,2,2].internal_coproduct()',number=1,repeat=1)
1 loops, best of 1: 5.23 s per loop
```
Time tests on current branch

```
sage: timeit('QS[2,2,2,1].coproduct()',number=1,repeat=1)
1 loops, best of 1: 5.33 s per loop
sage: timeit('QS[2,2,2,2].coproduct()',number=1,repeat=1)
1 loops, best of 1: 27.8 s per loop
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 18.1 s per loop
sage: timeit('QS[2,2,2].internal_coproduct()',number=1,repeat=1)
1 loops, best of 1: 42.5 s per loop
```
The last example is perhaps telling.  It takes advantage of the cache more than the other calculations and in the new branch the conversion from the monomial basis is not cached.  On branch 943f817, the whole transition matrix at a given degree is calculated at the same time (in this case n=6) and this is used as many times as needed in order to convert to the QS basis.



---

archive/issue_comments_245555.json:
```json
{
    "body": "<a id='comment:15'></a>It occurs to me that in a typical session that one is likely to be doing many calculations with a basis at a given degree.  For this reason branch b8cefb8 works better with these tests doing many loops (NB: with a `@`cached_method before the _to_monomial_on_basis) .  The change in branch 1091d7a is faster for a single change of basis calculation from monomial to QS but normally we do many in one session.\n\nIt is possible that I want to undo the edits in commit 0ba7a67 for the same reason.  That will make a single change of basis calculation from the dQS to the complete basis run faster (as my timing tests indicated in comment 11), but many calculations from dQS to complete/ribbon might run faster with the previous code because the change of basis matrix is calculated once for a given degree.",
    "created_at": "2015-05-23T13:36:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245555",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:15'></a>It occurs to me that in a typical session that one is likely to be doing many calculations with a basis at a given degree.  For this reason branch b8cefb8 works better with these tests doing many loops (NB: with a `@`cached_method before the _to_monomial_on_basis) .  The change in branch 1091d7a is faster for a single change of basis calculation from monomial to QS but normally we do many in one session.

It is possible that I want to undo the edits in commit 0ba7a67 for the same reason.  That will make a single change of basis calculation from the dQS to the complete basis run faster (as my timing tests indicated in comment 11), but many calculations from dQS to complete/ribbon might run faster with the previous code because the change of basis matrix is calculated once for a given degree.



---

archive/issue_comments_245556.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-23T17:26:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245556",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245557.json:
```json
{
    "body": "<a id='comment:17'></a>I have restored the coercions `_on_basis` (rather than `_by_triangularity`) using transition matrices.  The main difference in the `QS` basis is that the coercion is to/from the monomial basis instead of the fundamental basis and the `_from_monomial_transition_matrix` calls `number_of_SSRCT`.  This is significantly faster than creating the `_from_fundmental_transition_matrix` using `CompositionTableaux`.\n\nComparing to branch \u200bb8cefb8 (with a `@`cached_method in from of `_to_monomial_on_basis`)\n\n```\nsage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)\n1 loops, best of 1: 46.3 s per loop\nsage: timeit('QS[1,2,1]*QS[2,3]',number=1,repeat=1)\n1 loops, best of 1: 421 s per loop\n```\n\nSame calculation on current branch\n\n```\nsage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)\n1 loops, best of 1: 18.7 s per loop\nsage: timeit('QS[1,2,1]*QS[2,3]',number=1,repeat=1)\n1 loops, best of 1: 90.7 s per loop\n```\n\nI've optimized here the single calculation, but subsequent calculations are all cached and will be faster (and faster than my `_to/from_*_by_triangularity` methods).",
    "created_at": "2015-05-23T17:53:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245557",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:17'></a>I have restored the coercions `_on_basis` (rather than `_by_triangularity`) using transition matrices.  The main difference in the `QS` basis is that the coercion is to/from the monomial basis instead of the fundamental basis and the `_from_monomial_transition_matrix` calls `number_of_SSRCT`.  This is significantly faster than creating the `_from_fundmental_transition_matrix` using `CompositionTableaux`.

Comparing to branch ​b8cefb8 (with a `@`cached_method in from of `_to_monomial_on_basis`)

```
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 46.3 s per loop
sage: timeit('QS[1,2,1]*QS[2,3]',number=1,repeat=1)
1 loops, best of 1: 421 s per loop
```

Same calculation on current branch

```
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 18.7 s per loop
sage: timeit('QS[1,2,1]*QS[2,3]',number=1,repeat=1)
1 loops, best of 1: 90.7 s per loop
```

I've optimized here the single calculation, but subsequent calculations are all cached and will be faster (and faster than my `_to/from_*_by_triangularity` methods).



---

archive/issue_comments_245558.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-24T10:55:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245558",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245559.json:
```json
{
    "body": "Changing keywords from \"ncsf, qsym, quasiSchur\" to \"ncsf, qsym, quasiSchur, quasisymmetric\".",
    "created_at": "2015-05-24T11:24:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245559",
    "user": "https://github.com/zabrocki"
}
```

Changing keywords from "ncsf, qsym, quasiSchur" to "ncsf, qsym, quasiSchur, quasisymmetric".



---

archive/issue_comments_245560.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-05-24T11:24:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245560",
    "user": "https://github.com/zabrocki"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_245561.json:
```json
{
    "body": "<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-02T07:12:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245561",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245562.json:
```json
{
    "body": "<a id='comment:21'></a>Those are some nice timing improvements Mike.\n\nI made a couple of changes which should result in a speedup to the multiplication. I cached the output of `composition_order` in the matrix function so that it doesn't get recomputed every time a multiplication is done. I also did some other optimizations where I got a good speed reduction in some of my testings.\n\nDid you test to see what the change in timings going from the Quasisymmetric-Schur to the Fundamental basis is? Mainly I'm wondering if we should leave that in as a direct coercion (instead of going through the Monomial basis) and implement an iterator over standard composition tableaux.",
    "created_at": "2015-06-02T07:26:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245562",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:21'></a>Those are some nice timing improvements Mike.

I made a couple of changes which should result in a speedup to the multiplication. I cached the output of `composition_order` in the matrix function so that it doesn't get recomputed every time a multiplication is done. I also did some other optimizations where I got a good speed reduction in some of my testings.

Did you test to see what the change in timings going from the Quasisymmetric-Schur to the Fundamental basis is? Mainly I'm wondering if we should leave that in as a direct coercion (instead of going through the Monomial basis) and implement an iterator over standard composition tableaux.



---

archive/issue_comments_245563.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-02T12:20:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245563",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245564.json:
```json
{
    "body": "<a id='comment:23'></a>I'll work on the timing.  6.8.beta1 doesn't compile for me but 6.8.beta2 does.  I should be that QS -> M -> F is faster than QS -> F but I'll try to get evidence.",
    "created_at": "2015-06-02T12:24:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245564",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:23'></a>I'll work on the timing.  6.8.beta1 doesn't compile for me but 6.8.beta2 does.  I should be that QS -> M -> F is faster than QS -> F but I'll try to get evidence.



---

archive/issue_comments_245565.json:
```json
{
    "body": "<a id='comment:24'></a>The old path of QS to and from the fundamental basis is significantly slower than the current branch which passes through the monomial basis and then to the fundamental basis.\n\nCurrent branch:\n\n```\nF(QS[3,2,1]) - once : 53.8 ms / many : 5.34 ms\nF(QS[4,2,1]) - once : 72.2 ms / many : 16.9 ms\nF(QS[4,3,1]) - once : 226 ms / many : 60.4 ms\nF(QS[4,3,1,1]) - once : 705 ms / many : 68.9 ms\nF(QS[4,3,2,1]) - once : 2.09 s / many : 314 ms\nF(QS[4,3,2,1,1]) - once : 5.85 s / many : 358 ms\n\nQS(F[3,2,1]) - once : 798 ms / many : 958 \u00b5s\nQS(F[4,2,1]) - once : 3.05 s / many : 1.81 ms\nQS(F[4,3,1]) - once : 14.3 s / many : 3.61 ms\nQS(F[4,3,1,1]) - once : 63.8 s / many : 4.91 ms\nQS(F[4,3,2,1]) - once : 309 s / many : 8.74 ms\nQS(F[4,3,2,1,1]) - once : too long!\n```\n\nOn master:\n\n```\nF(QS[3,2,1]) - once : 28.6 ms / many : 25.1 ms\nF(QS[4,2,1]) - once : 124 ms / many : 116 ms\nF(QS[4,3,1]) - once : 741 ms / many : 722 ms\nF(QS[4,3,1,1]) - once : 2.14 s / many : 2.1 s\nF(QS[4,3,2,1]) - once : 15.4 s / many : 16 s\nF(QS[4,3,2,1,1]) - once : 50.1 s / many : too long!\n\nQS(F[3,2,1]) - once : 748 ms / many : 1.14 ms\nQS(F[4,2,1]) - once : 5.66 s / many : 2.38 ms\nQS(F[4,3,1]) - once : 47.5 s / many : 4.65 ms\nQS(F[4,3,1,1]) - once : 433 s / many : 10 ms\nQS(F[4,3,2,1]) & QS(F[4,3,2,1,1]) - too long!\n```",
    "created_at": "2015-06-02T14:38:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245565",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:24'></a>The old path of QS to and from the fundamental basis is significantly slower than the current branch which passes through the monomial basis and then to the fundamental basis.

Current branch:

```
F(QS[3,2,1]) - once : 53.8 ms / many : 5.34 ms
F(QS[4,2,1]) - once : 72.2 ms / many : 16.9 ms
F(QS[4,3,1]) - once : 226 ms / many : 60.4 ms
F(QS[4,3,1,1]) - once : 705 ms / many : 68.9 ms
F(QS[4,3,2,1]) - once : 2.09 s / many : 314 ms
F(QS[4,3,2,1,1]) - once : 5.85 s / many : 358 ms

QS(F[3,2,1]) - once : 798 ms / many : 958 µs
QS(F[4,2,1]) - once : 3.05 s / many : 1.81 ms
QS(F[4,3,1]) - once : 14.3 s / many : 3.61 ms
QS(F[4,3,1,1]) - once : 63.8 s / many : 4.91 ms
QS(F[4,3,2,1]) - once : 309 s / many : 8.74 ms
QS(F[4,3,2,1,1]) - once : too long!
```

On master:

```
F(QS[3,2,1]) - once : 28.6 ms / many : 25.1 ms
F(QS[4,2,1]) - once : 124 ms / many : 116 ms
F(QS[4,3,1]) - once : 741 ms / many : 722 ms
F(QS[4,3,1,1]) - once : 2.14 s / many : 2.1 s
F(QS[4,3,2,1]) - once : 15.4 s / many : 16 s
F(QS[4,3,2,1,1]) - once : 50.1 s / many : too long!

QS(F[3,2,1]) - once : 748 ms / many : 1.14 ms
QS(F[4,2,1]) - once : 5.66 s / many : 2.38 ms
QS(F[4,3,1]) - once : 47.5 s / many : 4.65 ms
QS(F[4,3,1,1]) - once : 433 s / many : 10 ms
QS(F[4,3,2,1]) & QS(F[4,3,2,1,1]) - too long!
```



---

archive/issue_comments_245566.json:
```json
{
    "body": "<a id='comment:25'></a>That's quite a difference. Thanks for checking.\n\nIf you could add a `# long time` to line 4770 (the test `s(dQS([2,1,3,1]).to_symmetric_function())`), and once you've done and are okay with my changes, then you can set this to a positive review.",
    "created_at": "2015-06-02T16:34:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245566",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:25'></a>That's quite a difference. Thanks for checking.

If you could add a `# long time` to line 4770 (the test `s(dQS([2,1,3,1]).to_symmetric_function())`), and once you've done and are okay with my changes, then you can set this to a positive review.



---

archive/issue_comments_245567.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-02T18:41:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245567",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245568.json:
```json
{
    "body": "<a id='comment:27'></a>Please recheck.  I noticed that Elementary, Psi, Phi all do not have `to_symmetric_function_on_basis` implemented and probably should.  Maybe the default implementation of `to_symmetric_function` should be \"check if `_on_basis` is implemented, if so, figure `_on_basis` by linearity, otherwise coerce to complete and do the `to_symmetric_function` there\"  Would you agree?  If so, I can implement that.",
    "created_at": "2015-06-02T18:51:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245568",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:27'></a>Please recheck.  I noticed that Elementary, Psi, Phi all do not have `to_symmetric_function_on_basis` implemented and probably should.  Maybe the default implementation of `to_symmetric_function` should be "check if `_on_basis` is implemented, if so, figure `_on_basis` by linearity, otherwise coerce to complete and do the `to_symmetric_function` there"  Would you agree?  If so, I can implement that.



---

archive/issue_comments_245569.json:
```json
{
    "body": "<a id='comment:28'></a>I think we should also do the multiplication in the homogeneous symmetric functions (so do the conversion to the the Complete basis, an then immediately convert that to Sym before doing the multiplication, this will likely be a small lambda function for the coercion map). Otherwise I agree.",
    "created_at": "2015-06-02T23:18:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245569",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:28'></a>I think we should also do the multiplication in the homogeneous symmetric functions (so do the conversion to the the Complete basis, an then immediately convert that to Sym before doing the multiplication, this will likely be a small lambda function for the coercion map). Otherwise I agree.



---

archive/issue_comments_245570.json:
```json
{
    "body": "<a id='comment:29'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-03T15:05:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245570",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:29'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245571.json:
```json
{
    "body": "<a id='comment:30'></a>I am not entirely sure I understood your comment, but I think that I implemented it by adding `to_symmetric_function_on_generators` and an algebra morphism in `to_symmetric_function` in `MultiplicativeBases`.\n\nOne thing that I am a bit confused about that I would like you to check carefully.  I had to re-implement `to_symmetric_function` in the ribbon basis.  Why?  It should be inherited from Bases, but for some reason if I remove it, there is no method.  Why just the ribbon basis?  It works fine in `dQS` or any of the other bases.\n\nAlso I am still trying to track down a slow-down in the immaculate basis `to_symmetric_function`.  They are implemented exactly the same way in `\u200b02d585f` and the current branch and yet that basis (and only that one) is slower to compute this map.",
    "created_at": "2015-06-03T15:14:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245571",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:30'></a>I am not entirely sure I understood your comment, but I think that I implemented it by adding `to_symmetric_function_on_generators` and an algebra morphism in `to_symmetric_function` in `MultiplicativeBases`.

One thing that I am a bit confused about that I would like you to check carefully.  I had to re-implement `to_symmetric_function` in the ribbon basis.  Why?  It should be inherited from Bases, but for some reason if I remove it, there is no method.  Why just the ribbon basis?  It works fine in `dQS` or any of the other bases.

Also I am still trying to track down a slow-down in the immaculate basis `to_symmetric_function`.  They are implemented exactly the same way in `​02d585f` and the current branch and yet that basis (and only that one) is slower to compute this map.



---

archive/issue_comments_245572.json:
```json
{
    "body": "<a id='comment:31'></a>It looks like you did what my comment was, where we did as much multiplication in Sym as possible (which is essentially what algebra morphisms are doing).\n\nSo the reason why it might be returning an `AttributeError` is that when a ``@`lazy_attribute` gets called and an error occurs, it generally (i.e., not all errors) catches that error and instead sends the `AttributeError` along. I'll take a look at this.",
    "created_at": "2015-06-06T19:34:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245572",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:31'></a>It looks like you did what my comment was, where we did as much multiplication in Sym as possible (which is essentially what algebra morphisms are doing).

So the reason why it might be returning an `AttributeError` is that when a ``@`lazy_attribute` gets called and an error occurs, it generally (i.e., not all errors) catches that error and instead sends the `AttributeError` along. I'll take a look at this.



---

archive/issue_comments_245573.json:
```json
{
    "body": "<a id='comment:32'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-07T12:26:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245573",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:32'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245574.json:
```json
{
    "body": "<a id='comment:33'></a>Your hint helped me find the issue.  That was frustrating me to no end.",
    "created_at": "2015-06-07T12:32:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245574",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:33'></a>Your hint helped me find the issue.  That was frustrating me to no end.



---

archive/issue_comments_245575.json:
```json
{
    "body": "<a id='comment:34'></a>The slowdown is not from the Immaculate basis, but from the Complete basis to symmetric functions.\n\n```\nsage: NCSF = NonCommutativeSymmetricFunctions(QQ)\nsage: I = NCSF.Immaculate()\nsage: C = NCSF.Complete()\nsage: x = C(I[4,1,4,6,3,8])\nsage: %prun x.to_symmetric_function()\n```\nCurrent branch\n\n```\n         352005 function calls (351848 primitive calls) in 1.726 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     3340    0.218    0.000    0.854    0.000 algebras_with_basis.py:128(_product_from_combinatorial_algebra_multiply)\n     3341    0.154    0.000    0.595    0.000 classical.py:94(_element_constructor_)\n    10024    0.134    0.000    0.268    0.000 partition.py:5064(__contains__)\n     6683    0.115    0.000    0.311    0.000 partition.py:604(__init__)\n     6681    0.103    0.000    0.693    0.000 partition.py:548(__classcall_private__)\n    56381    0.084    0.000    0.084    0.000 {isinstance}\n    28447    0.083    0.000    0.083    0.000 non_negative_integers.py:94(__contains__)\n     3341    0.079    0.000    0.748    0.000 ncsf.py:2876(to_symmetric_function_on_generators)\n     3340    0.073    0.000    0.508    0.000 multiplicative.py:39(_multiply_basis)\n     6683    0.067    0.000    0.100    0.000 combinat.py:1251(__init__)\n     3349    0.065    0.000    0.089    0.000 free_module.py:2030(_from_dict)\n     6683    0.064    0.000    0.574    0.000 partition.py:5045(_element_constructor_)\n    15894    0.035    0.000    0.050    0.000 partition.py:5096(<genexpr>)\n    12553    0.032    0.000    0.047    0.000 partition.py:627(<genexpr>)\n     6683    0.032    0.000    0.032    0.000 partition.py:638(__hash__)\n     6683    0.031    0.000    0.031    0.000 combinat.py:822(__init__)\n    16727    0.027    0.000    0.125    0.000 {all}\n     6690    0.025    0.000    0.025    0.000 free_module.py:36(__init__)\n     3361    0.024    0.000    0.026    0.000 partition.py:4914(__classcall_private__)\n      596    0.024    0.000    1.613    0.003 {sage.misc.misc_c.prod}\n     3340    0.022    0.000    0.877    0.000 magmas.py:927(_mul_parent)\n    50388    0.021    0.000    0.021    0.000 {len}\n        2    0.018    0.009    1.655    0.827 {sage.combinat.dict_addition.dict_linear_combination}\n     3340    0.015    0.000    0.015    0.000 {method 'sort' of 'list' objects}\n     3349    0.015    0.000    0.017    0.000 sf.py:883(complete)\n     7276    0.014    0.000    0.014    0.000 combinat.py:1172(__iter__)\n     3340    0.014    0.000    0.901    0.000 magmas.py:875(__mul__)\n6781/6780    0.013    0.000    0.016    0.000 {hasattr}\n       30    0.012    0.000    0.012    0.000 dynamic_class.py:324(dynamic_class_internal)\n     3936    0.010    0.000    0.688    0.000 generic_basis_code.py:1110(<genexpr>)\n     6680    0.010    0.000    0.010    0.000 combinat.py:1146(__len__)\n    13361    0.008    0.000    0.008    0.000 {method 'iteritems' of 'dict' objects}\n     6680    0.008    0.000    0.008    0.000 free_module.py:2084(<genexpr>)\n```\nWith 02d585f:\n\n```\n         55438 function calls (55282 primitive calls) in 0.461 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n      597    0.087    0.000    0.127    0.000 family.py:852(__init__)\n  698/697    0.027    0.000    0.031    0.000 {hasattr}\n      597    0.024    0.000    0.422    0.001 ncsf.py:2815(to_symmetric_function_on_basis)\n     6680    0.022    0.000    0.022    0.000 non_negative_integers.py:94(__contains__)\n      598    0.021    0.000    0.032    0.000 free_module.py:1895(_monomial)\n        2    0.021    0.010    0.394    0.197 {sage.combinat.dict_addition.dict_linear_combination}\n     3340    0.016    0.000    0.024    0.000 partition.py:5096(<genexpr>)\n     9531    0.015    0.000    0.015    0.000 {isinstance}\n     3340    0.015    0.000    0.023    0.000 partition.py:627(<genexpr>)\n      611    0.012    0.000    0.016    0.000 {sorted}\n       31    0.012    0.000    0.012    0.000 dynamic_class.py:324(dynamic_class_internal)\n      598    0.012    0.000    0.051    0.000 partition.py:604(__init__)\n      598    0.012    0.000    0.050    0.000 partition.py:5064(__contains__)\n      597    0.011    0.000    0.147    0.000 graded_modules_with_basis.py:42(basis)\n      597    0.011    0.000    0.122    0.000 partition.py:548(__classcall_private__)\n      597    0.011    0.000    0.193    0.000 sfa.py:1459(__getitem__)\n      718    0.008    0.000    0.021    0.000 dynamic_class.py:122(dynamic_class)\n     1323    0.008    0.000    0.010    0.000 combinat.py:961(__eq__)\n      598    0.007    0.000    0.010    0.000 combinat.py:1251(__init__)\n      598    0.007    0.000    0.109    0.000 partition.py:5045(_element_constructor_)\n      597    0.006    0.000    0.136    0.000 family.py:44(Family)\n      597    0.005    0.000    0.006    0.000 copy.py:66(copy)\n       28    0.005    0.000    0.007    0.000 homset.py:546(__init__)\n     1217    0.004    0.000    0.052    0.000 {all}\n      597    0.004    0.000    0.361    0.001 morphism.py:384(<genexpr>)\n      605    0.004    0.000    0.007    0.000 free_module.py:2030(_from_dict)\n      598    0.004    0.000    0.004    0.000 partition.py:638(__hash__)\n      605    0.004    0.000    0.006    0.000 sf.py:883(complete)\n      598    0.003    0.000    0.003    0.000 combinat.py:822(__init__)\n       28    0.003    0.000    0.019    0.001 homset.py:86(Hom)\n      605    0.003    0.000    0.003    0.000 free_module.py:36(__init__)\n      597    0.003    0.000    0.364    0.001 free_module.py:1870(<genexpr>)\n       21    0.002    0.000    0.026    0.001 morphism.py:159(__init__)\n```\nIt seems that going from the Complete basis is faster to be a module morphism rather than an algebra morphism (which for this, makes sense because we are just sorting the composition and we don't need to multiply non-monomial elements). More specifically, you can look at the number of calls to `Partition.__init__`, and it's all of these additional small function calls that adds up.",
    "created_at": "2015-06-07T16:54:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245575",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:34'></a>The slowdown is not from the Immaculate basis, but from the Complete basis to symmetric functions.

```
sage: NCSF = NonCommutativeSymmetricFunctions(QQ)
sage: I = NCSF.Immaculate()
sage: C = NCSF.Complete()
sage: x = C(I[4,1,4,6,3,8])
sage: %prun x.to_symmetric_function()
```
Current branch

```
         352005 function calls (351848 primitive calls) in 1.726 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     3340    0.218    0.000    0.854    0.000 algebras_with_basis.py:128(_product_from_combinatorial_algebra_multiply)
     3341    0.154    0.000    0.595    0.000 classical.py:94(_element_constructor_)
    10024    0.134    0.000    0.268    0.000 partition.py:5064(__contains__)
     6683    0.115    0.000    0.311    0.000 partition.py:604(__init__)
     6681    0.103    0.000    0.693    0.000 partition.py:548(__classcall_private__)
    56381    0.084    0.000    0.084    0.000 {isinstance}
    28447    0.083    0.000    0.083    0.000 non_negative_integers.py:94(__contains__)
     3341    0.079    0.000    0.748    0.000 ncsf.py:2876(to_symmetric_function_on_generators)
     3340    0.073    0.000    0.508    0.000 multiplicative.py:39(_multiply_basis)
     6683    0.067    0.000    0.100    0.000 combinat.py:1251(__init__)
     3349    0.065    0.000    0.089    0.000 free_module.py:2030(_from_dict)
     6683    0.064    0.000    0.574    0.000 partition.py:5045(_element_constructor_)
    15894    0.035    0.000    0.050    0.000 partition.py:5096(<genexpr>)
    12553    0.032    0.000    0.047    0.000 partition.py:627(<genexpr>)
     6683    0.032    0.000    0.032    0.000 partition.py:638(__hash__)
     6683    0.031    0.000    0.031    0.000 combinat.py:822(__init__)
    16727    0.027    0.000    0.125    0.000 {all}
     6690    0.025    0.000    0.025    0.000 free_module.py:36(__init__)
     3361    0.024    0.000    0.026    0.000 partition.py:4914(__classcall_private__)
      596    0.024    0.000    1.613    0.003 {sage.misc.misc_c.prod}
     3340    0.022    0.000    0.877    0.000 magmas.py:927(_mul_parent)
    50388    0.021    0.000    0.021    0.000 {len}
        2    0.018    0.009    1.655    0.827 {sage.combinat.dict_addition.dict_linear_combination}
     3340    0.015    0.000    0.015    0.000 {method 'sort' of 'list' objects}
     3349    0.015    0.000    0.017    0.000 sf.py:883(complete)
     7276    0.014    0.000    0.014    0.000 combinat.py:1172(__iter__)
     3340    0.014    0.000    0.901    0.000 magmas.py:875(__mul__)
6781/6780    0.013    0.000    0.016    0.000 {hasattr}
       30    0.012    0.000    0.012    0.000 dynamic_class.py:324(dynamic_class_internal)
     3936    0.010    0.000    0.688    0.000 generic_basis_code.py:1110(<genexpr>)
     6680    0.010    0.000    0.010    0.000 combinat.py:1146(__len__)
    13361    0.008    0.000    0.008    0.000 {method 'iteritems' of 'dict' objects}
     6680    0.008    0.000    0.008    0.000 free_module.py:2084(<genexpr>)
```
With 02d585f:

```
         55438 function calls (55282 primitive calls) in 0.461 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      597    0.087    0.000    0.127    0.000 family.py:852(__init__)
  698/697    0.027    0.000    0.031    0.000 {hasattr}
      597    0.024    0.000    0.422    0.001 ncsf.py:2815(to_symmetric_function_on_basis)
     6680    0.022    0.000    0.022    0.000 non_negative_integers.py:94(__contains__)
      598    0.021    0.000    0.032    0.000 free_module.py:1895(_monomial)
        2    0.021    0.010    0.394    0.197 {sage.combinat.dict_addition.dict_linear_combination}
     3340    0.016    0.000    0.024    0.000 partition.py:5096(<genexpr>)
     9531    0.015    0.000    0.015    0.000 {isinstance}
     3340    0.015    0.000    0.023    0.000 partition.py:627(<genexpr>)
      611    0.012    0.000    0.016    0.000 {sorted}
       31    0.012    0.000    0.012    0.000 dynamic_class.py:324(dynamic_class_internal)
      598    0.012    0.000    0.051    0.000 partition.py:604(__init__)
      598    0.012    0.000    0.050    0.000 partition.py:5064(__contains__)
      597    0.011    0.000    0.147    0.000 graded_modules_with_basis.py:42(basis)
      597    0.011    0.000    0.122    0.000 partition.py:548(__classcall_private__)
      597    0.011    0.000    0.193    0.000 sfa.py:1459(__getitem__)
      718    0.008    0.000    0.021    0.000 dynamic_class.py:122(dynamic_class)
     1323    0.008    0.000    0.010    0.000 combinat.py:961(__eq__)
      598    0.007    0.000    0.010    0.000 combinat.py:1251(__init__)
      598    0.007    0.000    0.109    0.000 partition.py:5045(_element_constructor_)
      597    0.006    0.000    0.136    0.000 family.py:44(Family)
      597    0.005    0.000    0.006    0.000 copy.py:66(copy)
       28    0.005    0.000    0.007    0.000 homset.py:546(__init__)
     1217    0.004    0.000    0.052    0.000 {all}
      597    0.004    0.000    0.361    0.001 morphism.py:384(<genexpr>)
      605    0.004    0.000    0.007    0.000 free_module.py:2030(_from_dict)
      598    0.004    0.000    0.004    0.000 partition.py:638(__hash__)
      605    0.004    0.000    0.006    0.000 sf.py:883(complete)
      598    0.003    0.000    0.003    0.000 combinat.py:822(__init__)
       28    0.003    0.000    0.019    0.001 homset.py:86(Hom)
      605    0.003    0.000    0.003    0.000 free_module.py:36(__init__)
      597    0.003    0.000    0.364    0.001 free_module.py:1870(<genexpr>)
       21    0.002    0.000    0.026    0.001 morphism.py:159(__init__)
```
It seems that going from the Complete basis is faster to be a module morphism rather than an algebra morphism (which for this, makes sense because we are just sorting the composition and we don't need to multiply non-monomial elements). More specifically, you can look at the number of calls to `Partition.__init__`, and it's all of these additional small function calls that adds up.



---

archive/issue_comments_245576.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-07T18:02:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245576",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_245577.json:
```json
{
    "body": "<a id='comment:36'></a>That fixes the slow-down.  Thanks.  I'm now seeing better speeds on all bases with significant speedups on the multiplicative bases.",
    "created_at": "2015-06-07T18:06:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245577",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:36'></a>That fixes the slow-down.  Thanks.  I'm now seeing better speeds on all bases with significant speedups on the multiplicative bases.



---

archive/issue_comments_245578.json:
```json
{
    "body": "<a id='comment:37'></a>Then I believe we are at a positive review, right?",
    "created_at": "2015-06-07T18:29:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245578",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:37'></a>Then I believe we are at a positive review, right?



---

archive/issue_comments_245579.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-06-07T18:42:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245579",
    "user": "https://github.com/zabrocki"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_245580.json:
```json
{
    "body": "<a id='comment:38'></a>I think it looks good at this point.  There are speedups on a number of features from this ticket.  Thanks for the review.",
    "created_at": "2015-06-07T18:42:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245580",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:38'></a>I think it looks good at this point.  There are speedups on a number of features from this ticket.  Thanks for the review.



---

archive/issue_comments_245581.json:
```json
{
    "body": "<a id='comment:39'></a>Thanks for your work.",
    "created_at": "2015-06-07T18:55:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245581",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:39'></a>Thanks for your work.



---

archive/issue_comments_245582.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-06-08T20:28:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18447#issuecomment-245582",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_051937.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-06-08T20:28:37Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18447",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18447#event-51937"
}
```
