# Issue 18905: fix more leaks found in #18897

archive/issues_018668.json:
```json
{
    "assignees": [],
    "body": "In #18897 one leak is fixed, but there are more left, see comments 27 and later:\n\n```\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: def test(L, dim):\n....:     import gc\n....:     from collections import Counter\n....:     gc.collect()\n....:     pre={id(c) for c in gc.get_objects()}\n....:     m = matrix(dim, L)\n....:     for p in range(2,102):\n....:         m.change_ring(GF(nth_prime(p))).eigenvalues()\n....:     gc.collect()\n....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n....:     return [(k,v) for (k,v) in post.iteritems() if v>10]\n....: \nsage: test(L, 5)\n[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>,\n  100),\n...\n (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),\n...\n (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),\n (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),\n...\n (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),\n...]\n```\n\nCC:  @jm58660\n\nBranch/Commit: **[public/18905](https://github.com/sagemath/sagetrac-mirror/tree/public/18905) @ [`e952388`](https://github.com/sagemath/sagetrac-mirror/commit/e952388409f97f3e40b9e4d56ab3e42b6cb13b88)**\n\nAuthor: **Simon King**\n\nComponent: **memleak**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/18905_\n\n",
    "created_at": "2015-07-15T10:48:57Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/memleak",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "fix more leaks found in #18897",
    "type": "issue",
    "updated_at": "2022-12-29T01:39:18Z",
    "url": "https://github.com/sagemath/sage/issues/18905",
    "user": "https://github.com/dimpase"
}
```
In #18897 one leak is fixed, but there are more left, see comments 27 and later:

```
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: def test(L, dim):
....:     import gc
....:     from collections import Counter
....:     gc.collect()
....:     pre={id(c) for c in gc.get_objects()}
....:     m = matrix(dim, L)
....:     for p in range(2,102):
....:         m.change_ring(GF(nth_prime(p))).eigenvalues()
....:     gc.collect()
....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
....:     return [(k,v) for (k,v) in post.iteritems() if v>10]
....: 
sage: test(L, 5)
[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>,
  100),
...
 (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),
...
 (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),
 (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),
...
 (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),
...]
```

CC:  @jm58660

Branch/Commit: **[public/18905](https://github.com/sagemath/sagetrac-mirror/tree/public/18905) @ [`e952388`](https://github.com/sagemath/sagetrac-mirror/commit/e952388409f97f3e40b9e4d56ab3e42b6cb13b88)**

Author: **Simon King**

Component: **memleak**

_Issue created by migration from https://trac.sagemath.org/ticket/18905_





---

archive/issue_events_265965.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2015-07-15T10:48:57Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "milestone_number": null,
    "milestone_title": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265965"
}
```



---

archive/issue_events_265966.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2015-07-15T10:48:57Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "label": "https://github.com/sagemath/sage/labels/memleak",
    "label_color": "d73a4a",
    "label_name": "memleak",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265966"
}
```



---

archive/issue_events_265967.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2015-07-15T10:48:57Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265967"
}
```



---

archive/issue_events_265968.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2015-07-15T10:48:57Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265968"
}
```



---

archive/issue_comments_264766.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1,28 @@\n-In #18897 one leak is fixed, but there are more left, see comments 27 and later.\n+In #18897 one leak is fixed, but there are more left, see comments 27 and later:\n+\n+```\n+sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\n+sage: def test(L, dim):\n+....:     import gc\n+....:     from collections import Counter\n+....:     gc.collect()\n+....:     pre={id(c) for c in gc.get_objects()}\n+....:     m = matrix(dim, L)\n+....:     for p in range(2,102):\n+....:         m.change_ring(GF(nth_prime(p))).eigenvalues()\n+....:     gc.collect()\n+....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n+....:     return [(k,v) for (k,v) in post.iteritems() if v>10]\n+....: \n+sage: test(L, 5)\n+[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>,\n+  100),\n+...\n+ (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),\n+...\n+ (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),\n+ (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),\n+...\n+ (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),\n+...]\n+```\n``````\n",
    "created_at": "2015-07-15T11:05:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264766",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1,28 @@
-In #18897 one leak is fixed, but there are more left, see comments 27 and later.
+In #18897 one leak is fixed, but there are more left, see comments 27 and later:
+
+```
+sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
+sage: def test(L, dim):
+....:     import gc
+....:     from collections import Counter
+....:     gc.collect()
+....:     pre={id(c) for c in gc.get_objects()}
+....:     m = matrix(dim, L)
+....:     for p in range(2,102):
+....:         m.change_ring(GF(nth_prime(p))).eigenvalues()
+....:     gc.collect()
+....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
+....:     return [(k,v) for (k,v) in post.iteritems() if v>10]
+....: 
+sage: test(L, 5)
+[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>,
+  100),
+...
+ (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),
+...
+ (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),
+ (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),
+...
+ (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),
+...]
+```
``````




---

archive/issue_comments_264767.json:
```json
{
    "body": "Dependencies: **#18897**",
    "created_at": "2015-07-15T11:05:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264767",
    "user": "https://github.com/simon-king-jena"
}
```

Dependencies: **#18897**



---

archive/issue_comments_264768.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nThis is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:\n\n```python\nimport gc                                                                                   \nfrom collections import Counter\ngc.collect()\npre = {id(c) for c in gc.get_objects()}\nfor p in prime_range(100):\n    GF(p).algebraic_closure()\ngc.collect()\npost = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\nprint([(k,v) for (k,v) in post.iteritems() if v>10])\n```",
    "created_at": "2015-07-15T11:35:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264768",
    "user": "https://github.com/pjbruin"
}
```

<div id="comment:2" align="right">comment:2</div>

This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:

```python
import gc                                                                                   
from collections import Counter
gc.collect()
pre = {id(c) for c in gc.get_objects()}
for p in prime_range(100):
    GF(p).algebraic_closure()
gc.collect()
post = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
print([(k,v) for (k,v) in post.iteritems() if v>10])
```



---

archive/issue_comments_264769.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nReplying to [@pjbruin](#comment%3A2):\n> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.\n\nCircular references shouldn't be problematic, unless one of the objects involved has a `__del__` method. However:\n\n```\nsage: K = GF(5)\nsage: hasattr(K, '__del__')\nFalse\nsage: hasattr(K.algebraic_closure(), '__del__')\nFalse\n```\n\nAnd indeed:\n\n```\nsage: while 1:\n....:     print get_memory_usage()\n....:     for p in range(2, 102):\n....:         A = GF(nth_prime(p)).algebraic_closure()\n....:         \n<constant amount of memory>\n```",
    "created_at": "2015-07-15T12:14:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264769",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Replying to [@pjbruin](#comment%3A2):
> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.

Circular references shouldn't be problematic, unless one of the objects involved has a `__del__` method. However:

```
sage: K = GF(5)
sage: hasattr(K, '__del__')
False
sage: hasattr(K.algebraic_closure(), '__del__')
False
```

And indeed:

```
sage: while 1:
....:     print get_memory_usage()
....:     for p in range(2, 102):
....:         A = GF(nth_prime(p)).algebraic_closure()
....:         
<constant amount of memory>
```



---

archive/issue_comments_264770.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nOops, that's a bad test. Of course it had a constant memory consumption even if memory could not be freed. Sorry.\n\n```\nsage: import gc\nsage: _ = gc.collect()\nsage: while 1:                                  \n....:     print gc.collect()\n....:     for p in range(2, 102):\n....:         A = GF(nth_prime(p)).algebraic_closure()\n....:         \n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n```\nThat's a leak.",
    "created_at": "2015-07-15T12:17:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264770",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

Oops, that's a bad test. Of course it had a constant memory consumption even if memory could not be freed. Sorry.

```
sage: import gc
sage: _ = gc.collect()
sage: while 1:                                  
....:     print gc.collect()
....:     for p in range(2, 102):
....:         A = GF(nth_prime(p)).algebraic_closure()
....:         
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
```
That's a leak.



---

archive/issue_comments_264771.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nReplying to [@pjbruin](#comment%3A2):\n> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:\n> \n> ```python\n> import gc                                                                                   \n> from collections import Counter\n> gc.collect()\n> pre = {id(c) for c in gc.get_objects()}\n> for p in prime_range(100):\n>     GF(p).algebraic_closure()\n> gc.collect()\n> post = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n> print([(k,v) for (k,v) in post.iteritems() if v>10])\n> ```\n\nLike noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.",
    "created_at": "2015-07-15T12:19:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264771",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:5" align="right">comment:5</div>

Replying to [@pjbruin](#comment%3A2):
> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:
> 
> ```python
> import gc                                                                                   
> from collections import Counter
> gc.collect()
> pre = {id(c) for c in gc.get_objects()}
> for p in prime_range(100):
>     GF(p).algebraic_closure()
> gc.collect()
> post = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
> print([(k,v) for (k,v) in post.iteritems() if v>10])
> ```

Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.



---

archive/issue_comments_264772.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nAnd the leak indeed only occurs if we store the algebraic closure. In a freshly started session (the previous result has also been in a freshly started session):\n\n```\nsage: _ = gc.collect()\nsage: while 1:                                  \n....:     print gc.collect()\n....:     for p in range(2, 102):\n....:         A = GF(nth_prime(p))\n....:         \n0\n8396\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n```",
    "created_at": "2015-07-15T12:19:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264772",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

And the leak indeed only occurs if we store the algebraic closure. In a freshly started session (the previous result has also been in a freshly started session):

```
sage: _ = gc.collect()
sage: while 1:                                  
....:     print gc.collect()
....:     for p in range(2, 102):
....:         A = GF(nth_prime(p))
....:         
0
8396
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
```



---

archive/issue_comments_264773.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\n> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.\n\n...ok, but that's the same thing for the bug presented in the description of the ticket. Sorry.",
    "created_at": "2015-07-15T12:21:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264773",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:7" align="right">comment:7</div>

> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.

...ok, but that's the same thing for the bug presented in the description of the ticket. Sorry.



---

archive/issue_comments_264774.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@seblabbe](#comment%3A5):\n> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.\n\nThat's just because there is only one base ring. Do the same while iterating over `GF(p)`, and you'll see how things accumulate.\n\nAt #18897, a binary tree was duely deallocated, however it was forgotten to dereference the root node. But here, we have objects that could be deallocated, but aren't. It is a totally different kind of leak.",
    "created_at": "2015-07-15T12:23:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264774",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@seblabbe](#comment%3A5):
> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.

That's just because there is only one base ring. Do the same while iterating over `GF(p)`, and you'll see how things accumulate.

At #18897, a binary tree was duely deallocated, however it was forgotten to dereference the root node. But here, we have objects that could be deallocated, but aren't. It is a totally different kind of leak.



---

archive/issue_comments_264775.json:
```json
{
    "body": "Attachment: **[test.png](https://github.com/sagemath/sage/files/ticket18905/test.png)**\n\nReference chain to finite field after creating its algebraic closure",
    "created_at": "2015-07-15T12:39:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264775",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment: **[test.png](https://github.com/sagemath/sage/files/ticket18905/test.png)**

Reference chain to finite field after creating its algebraic closure



---

archive/issue_comments_264776.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\n[attachment: test.png](https://github.com/sagemath/sage/files/ticket18905/test.png) results from the following code:\n\n```\nsage: import objgraph, gc\nsage: K = GF(31)\nsage: n = id(K)\nsage: A = K.algebraic_closure()\nsage: del A,K\nsage: gc.collect()\n0\nsage: L = [c for c in gc.get_objects() if id(c)==n]\nsage: objgraph.show_backrefs(L[0],filename=\"/home/king/Sage/work/memleak/test.png\")\nGraph written to /tmp/objgraph-r5RhSM.dot (21 nodes)\nImage generated as /home/king/Sage/work/memleak/test.png\n```\n\nApparently (since all other references are weak or circular), the references that prevent deallocation come from `sage.rings.finite_rings.integer_mod.NativeIntStruct`.",
    "created_at": "2015-07-15T12:42:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264776",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

[attachment: test.png](https://github.com/sagemath/sage/files/ticket18905/test.png) results from the following code:

```
sage: import objgraph, gc
sage: K = GF(31)
sage: n = id(K)
sage: A = K.algebraic_closure()
sage: del A,K
sage: gc.collect()
0
sage: L = [c for c in gc.get_objects() if id(c)==n]
sage: objgraph.show_backrefs(L[0],filename="/home/king/Sage/work/memleak/test.png")
Graph written to /tmp/objgraph-r5RhSM.dot (21 nodes)
Image generated as /home/king/Sage/work/memleak/test.png
```

Apparently (since all other references are weak or circular), the references that prevent deallocation come from `sage.rings.finite_rings.integer_mod.NativeIntStruct`.



---

archive/issue_comments_264777.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nIt seems that there is a NativeIntStruct created for each finite field. If the NativeIntStruct is small enough, then it has a (multiplication?) table, which holds references to all elements of the finite field. And they have, of course, references to their parent. But what is referencing the NativeIntStruct?",
    "created_at": "2015-07-15T12:51:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264777",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:10" align="right">comment:10</div>

It seems that there is a NativeIntStruct created for each finite field. If the NativeIntStruct is small enough, then it has a (multiplication?) table, which holds references to all elements of the finite field. And they have, of course, references to their parent. But what is referencing the NativeIntStruct?



---

archive/issue_comments_264778.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nIt seems that the reference somehow comes from constructing the algebraic closure, as we have\n\n```\nsage: K = GF(31)\nsage: del K\nsage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]\nsage: len(L)\n0\n```\nSo, the NativeIntStruct can be garbage collected when we do not construct the algebraic closure.\n\nHow can one find a reference chain from the algebraic closure to the NativeIntStruct?",
    "created_at": "2015-07-15T13:03:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264778",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:11" align="right">comment:11</div>

It seems that the reference somehow comes from constructing the algebraic closure, as we have

```
sage: K = GF(31)
sage: del K
sage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]
sage: len(L)
0
```
So, the NativeIntStruct can be garbage collected when we do not construct the algebraic closure.

How can one find a reference chain from the algebraic closure to the NativeIntStruct?



---

archive/issue_comments_264779.json:
```json
{
    "body": "Attachment: **[test2.png](https://github.com/sagemath/sage/files/ticket18905/test2.png)**\n\nAnother reference chain, towards NativeIntStruct",
    "created_at": "2015-07-15T13:04:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264779",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment: **[test2.png](https://github.com/sagemath/sage/files/ticket18905/test2.png)**

Another reference chain, towards NativeIntStruct



---

archive/issue_comments_264780.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\n[attachment: test2.png](https://github.com/sagemath/sage/files/ticket18905/test2.png) shows the result of\n\n```\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: del A,K\nsage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]\nsage: filter = lambda x: (x is not L) and (not isinstance(x, sage.rings.finite_rings.integer_mod.IntegerMod_int))\nsage: objgraph.show_backrefs(L[0],filter=filter,filename=\"/home/king/Sage/work/memleak/test2.png\")\nGraph written to /tmp/objgraph-4qP1R3.dot (16 nodes)\nImage generated as /home/king/Sage/work/memleak/test2.png\n```\n\nThe picture somehow looks familiar: There is a coerce map involved, namely !Int_to_IntegerMod. Coerce maps are supposed to have a weak reference to the domain and a strong reference to the codomain. Since the domain of !Int_to_IntegerMod presumably is the ring of integers and can't be deallocated anyway, a strong reference to the codomain means trouble...",
    "created_at": "2015-07-15T13:10:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264780",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:12" align="right">comment:12</div>

[attachment: test2.png](https://github.com/sagemath/sage/files/ticket18905/test2.png) shows the result of

```
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: del A,K
sage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]
sage: filter = lambda x: (x is not L) and (not isinstance(x, sage.rings.finite_rings.integer_mod.IntegerMod_int))
sage: objgraph.show_backrefs(L[0],filter=filter,filename="/home/king/Sage/work/memleak/test2.png")
Graph written to /tmp/objgraph-4qP1R3.dot (16 nodes)
Image generated as /home/king/Sage/work/memleak/test2.png
```

The picture somehow looks familiar: There is a coerce map involved, namely !Int_to_IntegerMod. Coerce maps are supposed to have a weak reference to the domain and a strong reference to the codomain. Since the domain of !Int_to_IntegerMod presumably is the ring of integers and can't be deallocated anyway, a strong reference to the codomain means trouble...



---

archive/issue_comments_264781.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nI was also playing with objgraph...\n\n```python\ndef test(L, dim):\n    import objgraph\n    import gc\n    from collections import Counter\n    gc.collect()\n    pre={id(c) for c in gc.get_objects()}\n    m = matrix(dim, L)\n    for p in range(2,102):\n        m.change_ring(GF(nth_prime(p))).eigenvalues()\n    gc.collect()\n    O = gc.get_objects()\n    post=Counter(type(o) for o in O if id(o) not in pre)\n    T = [k for (k,v) in post.iteritems() if v==100]\n    D = dict((type(o),o) for o in O if type(o) in T)\n    for i,v in enumerate(sorted(D.values())):\n        print v\n        objgraph.show_backrefs(v,filename=\"test_{}.png\".format(i))\n        print \"--\"\n```\nI get :\n\n```\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: test(L, 5)\nPrincipal ideal (547) of Integer Ring\nGraph written to /tmp/objgraph-e803N8.dot (20 nodes)\nImage generated as test_0.png\n--\nSet of Homomorphisms from Integer Ring to Finite Field of size 181\nGraph written to /tmp/objgraph-I_uL5V.dot (12 nodes)\nImage generated as test_1.png\n--\n<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>\nGraph written to /tmp/objgraph-oMuwMY.dot (13 nodes)\nImage generated as test_2.png\n--\nAlgebraic closure of Finite Field of size 181\nGraph written to /tmp/objgraph-M_9gmt.dot (14 nodes)\nImage generated as test_3.png\n--\nFinite Field of size 547\nGraph written to /tmp/objgraph-ZostIO.dot (25 nodes)\nImage generated as test_4.png\n--\nSet of Homomorphisms from Finite Field of size 181 to Univariate Polynomial Ring in x over Finite Field of size 181\nGraph written to /tmp/objgraph-diDGKn.dot (12 nodes)\nImage generated as test_5.png\n--\n<sage.rings.finite_rings.integer_mod.NativeIntStruct object at 0x7f366d1e3590>\nGraph written to /tmp/objgraph-JxmEbJ.dot (30 nodes)\nImage generated as test_6.png\n--\n```\nI will attach test_3.png for the algebraic closure right now.",
    "created_at": "2015-07-15T13:58:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264781",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:13" align="right">comment:13</div>

I was also playing with objgraph...

```python
def test(L, dim):
    import objgraph
    import gc
    from collections import Counter
    gc.collect()
    pre={id(c) for c in gc.get_objects()}
    m = matrix(dim, L)
    for p in range(2,102):
        m.change_ring(GF(nth_prime(p))).eigenvalues()
    gc.collect()
    O = gc.get_objects()
    post=Counter(type(o) for o in O if id(o) not in pre)
    T = [k for (k,v) in post.iteritems() if v==100]
    D = dict((type(o),o) for o in O if type(o) in T)
    for i,v in enumerate(sorted(D.values())):
        print v
        objgraph.show_backrefs(v,filename="test_{}.png".format(i))
        print "--"
```
I get :

```
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: test(L, 5)
Principal ideal (547) of Integer Ring
Graph written to /tmp/objgraph-e803N8.dot (20 nodes)
Image generated as test_0.png
--
Set of Homomorphisms from Integer Ring to Finite Field of size 181
Graph written to /tmp/objgraph-I_uL5V.dot (12 nodes)
Image generated as test_1.png
--
<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>
Graph written to /tmp/objgraph-oMuwMY.dot (13 nodes)
Image generated as test_2.png
--
Algebraic closure of Finite Field of size 181
Graph written to /tmp/objgraph-M_9gmt.dot (14 nodes)
Image generated as test_3.png
--
Finite Field of size 547
Graph written to /tmp/objgraph-ZostIO.dot (25 nodes)
Image generated as test_4.png
--
Set of Homomorphisms from Finite Field of size 181 to Univariate Polynomial Ring in x over Finite Field of size 181
Graph written to /tmp/objgraph-diDGKn.dot (12 nodes)
Image generated as test_5.png
--
<sage.rings.finite_rings.integer_mod.NativeIntStruct object at 0x7f366d1e3590>
Graph written to /tmp/objgraph-JxmEbJ.dot (30 nodes)
Image generated as test_6.png
--
```
I will attach test_3.png for the algebraic closure right now.



---

archive/issue_comments_264782.json:
```json
{
    "body": "Ref graph for Algebraic closure of Finite Field of size 181",
    "created_at": "2015-07-15T14:00:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264782",
    "user": "https://github.com/seblabbe"
}
```

Ref graph for Algebraic closure of Finite Field of size 181



---

archive/issue_comments_264783.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nAttachment: **[test_3.png](https://github.com/sagemath/sage/files/ticket18905/test_3.png)**\n\nLet me try to recall why the current \"weak-referencing coerce maps\" are made as they are, to understand why we have a strong reference chain to `Int_to_IntegerMod`.\n\n- We have a backtracking algorithm to find coerce maps by transitivity of \"registered\" coerce maps. Hence, registered coerce maps need to be stored in the codomain.\n- Since the maps are stored in a container that is stored as an attribute of the codomain, there is a strong reference chain from the codomain to the coerce map.\n- A strong reference to the codomain should not prevent the domain from garbage collection. Hence, IN COERCION, we use a weak reference from the map to the domain, and we cut the reference from the map to its parent.\n- A strong reference to the domain should not prevent the codomain from garbage collection. That's what seems to fail in the current example.\n\nWhat I do not understand: Why is that more than a strong reference CYCLE (which would not prevent garbage collection) from the codomain to the map and back?",
    "created_at": "2015-07-15T20:52:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264783",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:14" align="right">comment:14</div>

Attachment: **[test_3.png](https://github.com/sagemath/sage/files/ticket18905/test_3.png)**

Let me try to recall why the current "weak-referencing coerce maps" are made as they are, to understand why we have a strong reference chain to `Int_to_IntegerMod`.

- We have a backtracking algorithm to find coerce maps by transitivity of "registered" coerce maps. Hence, registered coerce maps need to be stored in the codomain.
- Since the maps are stored in a container that is stored as an attribute of the codomain, there is a strong reference chain from the codomain to the coerce map.
- A strong reference to the codomain should not prevent the domain from garbage collection. Hence, IN COERCION, we use a weak reference from the map to the domain, and we cut the reference from the map to its parent.
- A strong reference to the domain should not prevent the codomain from garbage collection. That's what seems to fail in the current example.

What I do not understand: Why is that more than a strong reference CYCLE (which would not prevent garbage collection) from the codomain to the map and back?



---

archive/issue_comments_264784.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nAha. The coercion model caches the coerce maps, too. So, it isn't the codomain only that holds a cache.\n\nThe coercion model is of course a permanent object. It references a `TripleDict` to store the coercion maps. The coercion map references the codomain. Hence, if the domain is strongly referenced from somewhere, then the coerce map and thus the codomain can not be garbage collected.\n\nCan we perhaps make it so that the cache in the coercion model only keeps a WEAK reference to the coerce map? I worry about performance, though, since getting the referenced object from a weak reference is a bit costly.\n\nDo we need to worry about premature collection of coerce map? If I understand correctly, the cache in the coercion model is mainly for performance, as the map is cached as an attribute of the codomain anyway. And the codomain of any map is a parent. Hence, the cache of the coercion model actually is redundant.\n\nSo, perhaps a better idea is to completely get rid of the coercion model cache, as the coercion model can use the codomain's cache. I'll try that.",
    "created_at": "2015-07-15T21:14:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264784",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:15" align="right">comment:15</div>

Aha. The coercion model caches the coerce maps, too. So, it isn't the codomain only that holds a cache.

The coercion model is of course a permanent object. It references a `TripleDict` to store the coercion maps. The coercion map references the codomain. Hence, if the domain is strongly referenced from somewhere, then the coerce map and thus the codomain can not be garbage collected.

Can we perhaps make it so that the cache in the coercion model only keeps a WEAK reference to the coerce map? I worry about performance, though, since getting the referenced object from a weak reference is a bit costly.

Do we need to worry about premature collection of coerce map? If I understand correctly, the cache in the coercion model is mainly for performance, as the map is cached as an attribute of the codomain anyway. And the codomain of any map is a parent. Hence, the cache of the coercion model actually is redundant.

So, perhaps a better idea is to completely get rid of the coercion model cache, as the coercion model can use the codomain's cache. I'll try that.



---

archive/issue_comments_264785.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nNo, the coercion model's cache is needed. It is relevant for pushouts. There, we have no codomain, as it first needs to be constructed.",
    "created_at": "2015-07-15T21:17:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264785",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:16" align="right">comment:16</div>

No, the coercion model's cache is needed. It is relevant for pushouts. There, we have no codomain, as it first needs to be constructed.



---

archive/issue_comments_264786.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nPerhaps my diagnosis was wrong: It is not relevant for pushouts, but we want to cache the ABSENCE of a coercion from a parent to, say, `int`. So, if the codomain happens to be a parent then we can use its cache; otherwise there is no problem to use the coercion model's cache since `int` and friends will never be garbage collected anyway.\n\nSo, better not use weak references to coercion maps...",
    "created_at": "2015-07-15T21:54:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264786",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:17" align="right">comment:17</div>

Perhaps my diagnosis was wrong: It is not relevant for pushouts, but we want to cache the ABSENCE of a coercion from a parent to, say, `int`. So, if the codomain happens to be a parent then we can use its cache; otherwise there is no problem to use the coercion model's cache since `int` and friends will never be garbage collected anyway.

So, better not use weak references to coercion maps...



---

archive/issue_comments_264787.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nIt seems that #14058 is relevant -- and perhaps it fixes our problem (except that it has no branch).",
    "created_at": "2015-07-16T19:44:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264787",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:18" align="right">comment:18</div>

It seems that #14058 is relevant -- and perhaps it fixes our problem (except that it has no branch).



---

archive/issue_comments_264788.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nI am afraid that #14058 (which now has a branch) does not suffice to fix the problem: GF(31) still can't be collected after creating its algebraic closure. However, the coercion model is not mentioned any longer. Instead, the reference goes via a weak value dictionary, which seems to be the polynomial ring cache.\n\nMy guess:\n- There is some polynomial ring P over the base ring GF(31) that was constructed when creating the algebraic closure of GF(31).\n- There is only a weak reference to P from the polynomial ring cache (it is weak value dictionary). However, for a different reason there is a strong reference to P.\n- Hence, the entry for P in the weak value dictionary can not be freed. By consequence, the reference to the KEY of this entry, which is a STRONG reference to GF(31), can not be freed.\n- Thus, GF(31) can not be deallocated.\n\nThe question is: How is there a strong reference to P? Perhaps there is a strong reference from GF(31) to P? Maybe via caching the algebraic closure, which references an element of P? This would be enough to keep P alive.",
    "created_at": "2015-07-16T23:05:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264788",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:19" align="right">comment:19</div>

I am afraid that #14058 (which now has a branch) does not suffice to fix the problem: GF(31) still can't be collected after creating its algebraic closure. However, the coercion model is not mentioned any longer. Instead, the reference goes via a weak value dictionary, which seems to be the polynomial ring cache.

My guess:
- There is some polynomial ring P over the base ring GF(31) that was constructed when creating the algebraic closure of GF(31).
- There is only a weak reference to P from the polynomial ring cache (it is weak value dictionary). However, for a different reason there is a strong reference to P.
- Hence, the entry for P in the weak value dictionary can not be freed. By consequence, the reference to the KEY of this entry, which is a STRONG reference to GF(31), can not be freed.
- Thus, GF(31) can not be deallocated.

The question is: How is there a strong reference to P? Perhaps there is a strong reference from GF(31) to P? Maybe via caching the algebraic closure, which references an element of P? This would be enough to keep P alive.



---

archive/issue_comments_264789.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nI tried to find a backref chain as follows:\n\n```\nsage: import objgraph, gc, __main__\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: nK = id(K)\nsage: del A,K\nsage: L = [c for c in gc.get_objects() if id(c) == nK]\nsage: objgraph.find_backref_chain(L[0], lambda x: x in __main__.__dict__.values(), extra_ignore=(id(L),))\n```\nbut it crashes with a segfault. Any idea why it fails?",
    "created_at": "2015-07-18T20:28:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264789",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:21" align="right">comment:21</div>

I tried to find a backref chain as follows:

```
sage: import objgraph, gc, __main__
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: nK = id(K)
sage: del A,K
sage: L = [c for c in gc.get_objects() if id(c) == nK]
sage: objgraph.find_backref_chain(L[0], lambda x: x in __main__.__dict__.values(), extra_ignore=(id(L),))
```
but it crashes with a segfault. Any idea why it fails?



---

archive/issue_comments_264790.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nAnd this one\n\n```\nsage: import objgraph, gc\nsage: cm = sage.structure.element.get_coercion_model()\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: nK = id(K)\nsage: del A,K\nsage: gc.collect()\n0\nsage: L = [c for c in gc.get_objects() if id(c) == nK]\nsage: objgraph.find_backref_chain(L[0], lambda x: x is cm, extra_ignore=(id(L),))\n```\ndoesn't finish after several minutes.",
    "created_at": "2015-07-18T20:35:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264790",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:22" align="right">comment:22</div>

And this one

```
sage: import objgraph, gc
sage: cm = sage.structure.element.get_coercion_model()
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: nK = id(K)
sage: del A,K
sage: gc.collect()
0
sage: L = [c for c in gc.get_objects() if id(c) == nK]
sage: objgraph.find_backref_chain(L[0], lambda x: x is cm, extra_ignore=(id(L),))
```
doesn't finish after several minutes.



---

archive/issue_comments_264791.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nI get pretty good plots from\n\n```\nobjgraph.show_backrefs(L,filename='plot.png',max_depth=5)\n```\nIt seems a global link exists here:\n\n```\nsage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]\n[(Finite Field of size 31, ('x',), False, None),\n (Finite Field of size 31, ('x',), False, 'FLINT')]\n```",
    "created_at": "2015-07-18T21:00:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264791",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:23" align="right">comment:23</div>

I get pretty good plots from

```
objgraph.show_backrefs(L,filename='plot.png',max_depth=5)
```
It seems a global link exists here:

```
sage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]
[(Finite Field of size 31, ('x',), False, None),
 (Finite Field of size 31, ('x',), False, 'FLINT')]
```



---

archive/issue_comments_264792.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nReplying to [@nbruin](#comment%3A23):\n> I get pretty good plots from\n> \n> ```\n> objgraph.show_backrefs(L,filename='plot.png',max_depth=5)\n> ```\n\nAhm, L?? That's a list.\n\n> It seems a global link exists here:\n> \n> ```\n> sage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]\n> [(Finite Field of size 31, ('x',), False, None),\n>  (Finite Field of size 31, ('x',), False, 'FLINT')]\n> ```\n\nOf course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.",
    "created_at": "2015-07-18T21:27:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264792",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:24" align="right">comment:24</div>

Replying to [@nbruin](#comment%3A23):
> I get pretty good plots from
> 
> ```
> objgraph.show_backrefs(L,filename='plot.png',max_depth=5)
> ```

Ahm, L?? That's a list.

> It seems a global link exists here:
> 
> ```
> sage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]
> [(Finite Field of size 31, ('x',), False, None),
>  (Finite Field of size 31, ('x',), False, 'FLINT')]
> ```

Of course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.



---

archive/issue_comments_264793.json:
```json
{
    "body": "Attachment: **[test_P_14058.png](https://github.com/sagemath/sage/files/ticket18905/test_P_14058.png)**\n\nBackref graph for a polynomial ring over finite field",
    "created_at": "2015-07-18T21:37:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264793",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment: **[test_P_14058.png](https://github.com/sagemath/sage/files/ticket18905/test_P_14058.png)**

Backref graph for a polynomial ring over finite field



---

archive/issue_comments_264794.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\n[attachment: test_P_14058.png](https://github.com/sagemath/sage/files/ticket18905/test_P_14058.png) is interesting. It seems that the reference chain to the polynomial ring is via TRACEBACKS! The question then arises: Why are the tracebacks not garbage collected?",
    "created_at": "2015-07-18T21:38:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264794",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:25" align="right">comment:25</div>

[attachment: test_P_14058.png](https://github.com/sagemath/sage/files/ticket18905/test_P_14058.png) is interesting. It seems that the reference chain to the polynomial ring is via TRACEBACKS! The question then arises: Why are the tracebacks not garbage collected?



---

archive/issue_comments_264795.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nReplying to [@simon-king-jena](#comment%3A24):\n> Of course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.\n\nOK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated.",
    "created_at": "2015-07-18T21:38:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264795",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:26" align="right">comment:26</div>

Replying to [@simon-king-jena](#comment%3A24):
> Of course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.

OK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated.



---

archive/issue_comments_264796.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nOops. I see that the chain goes via objgraph. So, I guess the new attachment is worthless.",
    "created_at": "2015-07-18T21:39:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264796",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:27" align="right">comment:27</div>

Oops. I see that the chain goes via objgraph. So, I guess the new attachment is worthless.



---

archive/issue_comments_264797.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nReplying to [@nbruin](#comment%3A26):\n> OK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated. \n\nAnd, by [comment:19](#comment%3A19), it prevents the base ring from collection, because it is not simply a cyclic reference, but a strong reference from a weak value dictionary to one of its keys.",
    "created_at": "2015-07-18T21:44:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264797",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:28" align="right">comment:28</div>

Replying to [@nbruin](#comment%3A26):
> OK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated. 

And, by [comment:19](#comment%3A19), it prevents the base ring from collection, because it is not simply a cyclic reference, but a strong reference from a weak value dictionary to one of its keys.



---

archive/issue_comments_264798.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">comment:29</div>\n\nWhy does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it \"only\" reference the return value?",
    "created_at": "2015-07-18T21:52:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264798",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:29" align="right">comment:29</div>

Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it "only" reference the return value?



---

archive/issue_comments_264799.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nReplying to [@simon-king-jena](#comment%3A29):\n> Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it \"only\" reference the return value?\n\nI see. The algebraic closure itself references the PseudoConwayLattice.\n\nHm. At some point we should use a weak reference. Maybe right here.",
    "created_at": "2015-07-18T21:55:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264799",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:30" align="right">comment:30</div>

Replying to [@simon-king-jena](#comment%3A29):
> Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it "only" reference the return value?

I see. The algebraic closure itself references the PseudoConwayLattice.

Hm. At some point we should use a weak reference. Maybe right here.



---

archive/issue_comments_264800.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nThe lattice that is stored in the algebraic closure is either passed as an argument to the init method, or is constructed during init:\n\n```python\n    def __init__(self, base_ring, name, category=None, lattice=None, use_database=True):\n        if not (is_FiniteField(base_ring) and base_ring.is_prime_field()):\n            raise NotImplementedError('algebraic closures of finite fields are only implemented for prime fields')\n        from sage.rings.finite_rings.conway_polynomials import PseudoConwayLattice\n        p = base_ring.characteristic()\n        if lattice is None:\n            lattice = PseudoConwayLattice(p, use_database)\n        elif not isinstance(lattice, PseudoConwayLattice) or lattice.p != p:\n            raise TypeError('lattice must be a pseudo-Conway lattice with characteristic %s' % p)\n        self._pseudo_conway_lattice = lattice\n        AlgebraicClosureFiniteField_generic.__init__(self, base_ring, name, category)\n```\n\nThat's a dilemma. If \"lattice\" is not passed as an argument, it is no problem to weakly reference it, as it can be reconstructed, should it be garbage collected. But otherwise? Hm.",
    "created_at": "2015-07-18T22:05:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264800",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:31" align="right">comment:31</div>

The lattice that is stored in the algebraic closure is either passed as an argument to the init method, or is constructed during init:

```python
    def __init__(self, base_ring, name, category=None, lattice=None, use_database=True):
        if not (is_FiniteField(base_ring) and base_ring.is_prime_field()):
            raise NotImplementedError('algebraic closures of finite fields are only implemented for prime fields')
        from sage.rings.finite_rings.conway_polynomials import PseudoConwayLattice
        p = base_ring.characteristic()
        if lattice is None:
            lattice = PseudoConwayLattice(p, use_database)
        elif not isinstance(lattice, PseudoConwayLattice) or lattice.p != p:
            raise TypeError('lattice must be a pseudo-Conway lattice with characteristic %s' % p)
        self._pseudo_conway_lattice = lattice
        AlgebraicClosureFiniteField_generic.__init__(self, base_ring, name, category)
```

That's a dilemma. If "lattice" is not passed as an argument, it is no problem to weakly reference it, as it can be reconstructed, should it be garbage collected. But otherwise? Hm.



---

archive/issue_comments_264801.json:
```json
{
    "body": "<div id=\"comment:32\" align=\"right\">comment:32</div>\n\nI think I know a potential solution.\n\nThe problem, by the above analysis: The polynomial ring cache is a weak value dictionary. Generally, a strong reference chain from key to value will prevent garbage collection of the key-value pair.\n\nI suggest to remove the \"global\" polynomial ring cache. Instead, I suggest that the polynomial ring constructor uses a weak value dictionary that is stored as an attribute of the base ring (e.g., in `self.__cached_methods`, which is available for all parents).\n\nThe weakly referenced values are polynomial rings. The keys are the list of variable names and information on term order and implementation---so, strong references to them shouldn't be problematic.\n\nIn that model, a strong reference chain from the base ring to the polynomial ring would NOT prevent garbage collection, since in the worst case it is a reference cycle (base ring <-> polynomial ring).",
    "created_at": "2015-07-18T22:43:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264801",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:32" align="right">comment:32</div>

I think I know a potential solution.

The problem, by the above analysis: The polynomial ring cache is a weak value dictionary. Generally, a strong reference chain from key to value will prevent garbage collection of the key-value pair.

I suggest to remove the "global" polynomial ring cache. Instead, I suggest that the polynomial ring constructor uses a weak value dictionary that is stored as an attribute of the base ring (e.g., in `self.__cached_methods`, which is available for all parents).

The weakly referenced values are polynomial rings. The keys are the list of variable names and information on term order and implementation---so, strong references to them shouldn't be problematic.

In that model, a strong reference chain from the base ring to the polynomial ring would NOT prevent garbage collection, since in the worst case it is a reference cycle (base ring <-> polynomial ring).



---

archive/issue_comments_264802.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\nHooray! With that change, I get\n\n```\nsage: import objgraph, gc\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: n = id(K)\nsage: del A,K\nsage: gc.collect()\n186\nsage: L = [c for c in gc.get_objects() if id(c) == n]\nsage: L\n[]\n```",
    "created_at": "2015-07-18T22:58:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264802",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:33" align="right">comment:33</div>

Hooray! With that change, I get

```
sage: import objgraph, gc
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: n = id(K)
sage: del A,K
sage: gc.collect()
186
sage: L = [c for c in gc.get_objects() if id(c) == n]
sage: L
[]
```



---

archive/issue_comments_264803.json:
```json
{
    "body": "Branch: **[u/SimonKing/memleak_for_integer_mod_rel_14058](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/memleak_for_integer_mod_rel_14058)**",
    "created_at": "2015-07-19T06:28:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264803",
    "user": "https://github.com/simon-king-jena"
}
```

Branch: **[u/SimonKing/memleak_for_integer_mod_rel_14058](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/memleak_for_integer_mod_rel_14058)**



---

archive/issue_comments_264804.json:
```json
{
    "body": "<div id=\"comment:35\" align=\"right\">comment:35</div>\n\nLast 10 new commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6d340771137df00b0da8a24485a95383f111d533\"><code>6d34077</code></a></td><td><code>Simplify code for deallocation of binary trees</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/80ce8765811c7ac18b921467e113630169b6aaaf\"><code>80ce876</code></a></td><td><code>Further simplification</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ac68d9b2d7624d32dc885f42bbd83d372fa8da5f\"><code>ac68d9b</code></a></td><td><code>Remove strong references to parents used in binary operations in the coercion model.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e153d0813221d3681030fbf24bbbc283d3717162\"><code>e153d08</code></a></td><td><code>#14058: Add doctest</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b9141eef1042c8b8fb1179b30844d5bdb737b96e\"><code>b9141ee</code></a></td><td><code>Merge branch 'ticket/14058' into develop</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/90ed181ae9df152e99a652636a7e9dc29b466916\"><code>90ed181</code></a></td><td><code>Trivial fix for a coercion doctest</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/64b572ccf6403be0c617d0e39de4b1e6cd5dbc58\"><code>64b572c</code></a></td><td><code>refcount libsingular rings used in plural</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9793dbc9bc64bfdce43ff1e626453816c302696d\"><code>9793dbc</code></a></td><td><code>Make one test more stable</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/219fbf49dded825f69dfe48ccf023f6b04b86273\"><code>219fbf4</code></a></td><td><code>Merge branch 't/14058/weakly_reference_binary_operation_codomains' into t/18905/memleak_for_integer_mod_rel_14058</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3ada19d1acf58d1d085c1908b3058de8377901a4\"><code>3ada19d</code></a></td><td><code>Replace the global polynomial ring cache by a cache in the base ring</code></td></tr></table>\n",
    "created_at": "2015-07-19T06:31:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264804",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:35" align="right">comment:35</div>

Last 10 new commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6d340771137df00b0da8a24485a95383f111d533"><code>6d34077</code></a></td><td><code>Simplify code for deallocation of binary trees</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/80ce8765811c7ac18b921467e113630169b6aaaf"><code>80ce876</code></a></td><td><code>Further simplification</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ac68d9b2d7624d32dc885f42bbd83d372fa8da5f"><code>ac68d9b</code></a></td><td><code>Remove strong references to parents used in binary operations in the coercion model.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e153d0813221d3681030fbf24bbbc283d3717162"><code>e153d08</code></a></td><td><code>#14058: Add doctest</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b9141eef1042c8b8fb1179b30844d5bdb737b96e"><code>b9141ee</code></a></td><td><code>Merge branch 'ticket/14058' into develop</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/90ed181ae9df152e99a652636a7e9dc29b466916"><code>90ed181</code></a></td><td><code>Trivial fix for a coercion doctest</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/64b572ccf6403be0c617d0e39de4b1e6cd5dbc58"><code>64b572c</code></a></td><td><code>refcount libsingular rings used in plural</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9793dbc9bc64bfdce43ff1e626453816c302696d"><code>9793dbc</code></a></td><td><code>Make one test more stable</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/219fbf49dded825f69dfe48ccf023f6b04b86273"><code>219fbf4</code></a></td><td><code>Merge branch 't/14058/weakly_reference_binary_operation_codomains' into t/18905/memleak_for_integer_mod_rel_14058</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3ada19d1acf58d1d085c1908b3058de8377901a4"><code>3ada19d</code></a></td><td><code>Replace the global polynomial ring cache by a cache in the base ring</code></td></tr></table>




---

archive/issue_comments_264805.json:
```json
{
    "body": "Changed dependencies from **#18897** to **#18897, #14058**",
    "created_at": "2015-07-19T06:31:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264805",
    "user": "https://github.com/simon-king-jena"
}
```

Changed dependencies from **#18897** to **#18897, #14058**



---

archive/issue_comments_264806.json:
```json
{
    "body": "Author: **Simon King**",
    "created_at": "2015-07-19T06:31:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264806",
    "user": "https://github.com/simon-king-jena"
}
```

Author: **Simon King**



---

archive/issue_events_265969.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-07-19T06:31:46Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265969"
}
```



---

archive/issue_comments_264807.json:
```json
{
    "body": "Commit: **[`3ada19d`](https://github.com/sagemath/sagetrac-mirror/commit/3ada19d1acf58d1d085c1908b3058de8377901a4)**",
    "created_at": "2015-07-19T06:31:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264807",
    "user": "https://github.com/simon-king-jena"
}
```

Commit: **[`3ada19d`](https://github.com/sagemath/sagetrac-mirror/commit/3ada19d1acf58d1d085c1908b3058de8377901a4)**



---

archive/issue_comments_264808.json:
```json
{
    "body": "<div id=\"comment:36\" align=\"right\">comment:36</div>\n\nTo my slight surprise, replacing the global polynomial ring cache by a local cache did not only solve the issue tracked here, but it did not introduce a new problem: With the attached branch, all tests should pass.\n\nI have reviewed most part of #14058, but I think someone should have a look at my additions (review patch) there and finish the review.",
    "created_at": "2015-07-19T06:35:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264808",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:36" align="right">comment:36</div>

To my slight surprise, replacing the global polynomial ring cache by a local cache did not only solve the issue tracked here, but it did not introduce a new problem: With the attached branch, all tests should pass.

I have reviewed most part of #14058, but I think someone should have a look at my additions (review patch) there and finish the review.



---

archive/issue_events_265970.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2015-08-10T09:58:31Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265970"
}
```



---

archive/issue_events_265971.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2015-08-10T09:58:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265971"
}
```



---

archive/issue_comments_264809.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nFrom the patchbot\n\n```\nsage -t --long src/sage/structure/coerce.pyx\n**********************************************************************\nFile \"src/sage/structure/coerce.pyx\", line 1307, in sage.structure.coerce.CoercionModel_cache_maps.coercion_maps\nFailed example:\n    print N2-N0\nExpected:\n    0\nGot:\n    -1\n```\nIs it what we should get?",
    "created_at": "2015-08-10T09:58:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264809",
    "user": "https://github.com/videlec"
}
```

<div id="comment:37" align="right">comment:37</div>

From the patchbot

```
sage -t --long src/sage/structure/coerce.pyx
**********************************************************************
File "src/sage/structure/coerce.pyx", line 1307, in sage.structure.coerce.CoercionModel_cache_maps.coercion_maps
Failed example:
    print N2-N0
Expected:
    0
Got:
    -1
```
Is it what we should get?



---

archive/issue_comments_264810.json:
```json
{
    "body": "<div id=\"comment:38\" align=\"right\">comment:38</div>\n\nReplying to [@videlec](#comment%3A37):\n> From the patchbot\n> ...\n> Is it what we should get?\n\nNote that the same error appears at #14058, even though the commits from here are not part of #14058, if I see that correctly.\n\nCould someone verify if it is really the case that tests pass with \"develop\", but fail with the branch from here (merged in \"develop\" of course)? I currently do not have the bandwidth.",
    "created_at": "2015-08-10T11:56:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264810",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:38" align="right">comment:38</div>

Replying to [@videlec](#comment%3A37):
> From the patchbot
> ...
> Is it what we should get?

Note that the same error appears at #14058, even though the commits from here are not part of #14058, if I see that correctly.

Could someone verify if it is really the case that tests pass with "develop", but fail with the branch from here (merged in "develop" of course)? I currently do not have the bandwidth.



---

archive/issue_comments_264811.json:
```json
{
    "body": "<div id=\"comment:39\" align=\"right\">comment:39</div>\n\nReplying to [@simon-king-jena](#comment%3A38):\n> Replying to [@videlec](#comment%3A37):\n> Could someone verify if it is really the case that tests pass with \"develop\", but fail with the branch from here (merged in \"develop\" of course)? I currently do not have the bandwidth.\n\nIt does fail, see [#14058 comment 62](https://github.com/sagemath/sage/issues/14058#comment:62).",
    "created_at": "2015-08-10T12:09:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264811",
    "user": "https://github.com/videlec"
}
```

<div id="comment:39" align="right">comment:39</div>

Replying to [@simon-king-jena](#comment%3A38):
> Replying to [@videlec](#comment%3A37):
> Could someone verify if it is really the case that tests pass with "develop", but fail with the branch from here (merged in "develop" of course)? I currently do not have the bandwidth.

It does fail, see [#14058 comment 62](https://github.com/sagemath/sage/issues/14058#comment:62).



---

archive/issue_comments_264812.json:
```json
{
    "body": "<div id=\"comment:40\" align=\"right\">comment:40</div>\n\nReplying to [@videlec](#comment%3A39):\n> Replying to [@simon-king-jena](#comment%3A38):\n> > Replying to [@videlec](#comment%3A37):\n> > Could someone verify if it is really the case that tests pass with \"develop\", but fail with the branch from here (merged in \"develop\" of course)? I currently do not have the bandwidth.\n\n> \n> It does fail, see [#14058 comment 62](https://github.com/sagemath/sage/issues/14058#comment:62).\n\nPlease be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?\n\nIf it fails both here and at #14058, but not with develop, then I reckon both branches trigger a memory leak that was introduced elsewhere.",
    "created_at": "2015-08-10T12:25:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264812",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:40" align="right">comment:40</div>

Replying to [@videlec](#comment%3A39):
> Replying to [@simon-king-jena](#comment%3A38):
> > Replying to [@videlec](#comment%3A37):
> > Could someone verify if it is really the case that tests pass with "develop", but fail with the branch from here (merged in "develop" of course)? I currently do not have the bandwidth.

> 
> It does fail, see [#14058 comment 62](https://github.com/sagemath/sage/issues/14058#comment:62).

Please be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?

If it fails both here and at #14058, but not with develop, then I reckon both branches trigger a memory leak that was introduced elsewhere.



---

archive/issue_comments_264813.json:
```json
{
    "body": "<div id=\"comment:41\" align=\"right\">comment:41</div>\n\nReplying to [@simon-king-jena](#comment%3A40):\n> Please be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?\n\nSorry for the noise. I just notice that #14058 is a dependency for the ticket here. So, we should focus on #14058.",
    "created_at": "2015-08-10T12:25:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264813",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:41" align="right">comment:41</div>

Replying to [@simon-king-jena](#comment%3A40):
> Please be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?

Sorry for the noise. I just notice that #14058 is a dependency for the ticket here. So, we should focus on #14058.



---

archive/issue_comments_264814.json:
```json
{
    "body": "<div id=\"comment:42\" align=\"right\">comment:42</div>\n\nbump...",
    "created_at": "2015-09-23T15:41:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264814",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:42" align="right">comment:42</div>

bump...



---

archive/issue_comments_264815.json:
```json
{
    "body": "<div id=\"comment:43\" align=\"right\">comment:43</div>\n\nI think the description of the ticket should be updated because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0. (Exactly what leaks are fixed in this ticket?)\n\nIs the following line needed?\n\n```\n+from sage.structure.parent import Parent\n```\n\nOther than that, I verified that the branches indeed fixes the problem mentioned at comment 33. When the two thing above are fixed, to me, it will be a positive review.",
    "created_at": "2015-09-28T14:55:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264815",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:43" align="right">comment:43</div>

I think the description of the ticket should be updated because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0. (Exactly what leaks are fixed in this ticket?)

Is the following line needed?

```
+from sage.structure.parent import Parent
```

Other than that, I verified that the branches indeed fixes the problem mentioned at comment 33. When the two thing above are fixed, to me, it will be a positive review.



---

archive/issue_comments_264816.json:
```json
{
    "body": "<div id=\"comment:44\" align=\"right\">comment:44</div>\n\nReplying to [@seblabbe](#comment%3A43):\n>  because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0.\n\nSorry, I am retracting here as I do see them on sage-6.9.rc0:\n\n```python\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: %cpaste\nPasting code; enter '--' alone on the line to stop or use Ctrl-D.\n:sage: def test_mod_100(L, dim):\n:....:     import gc\n:....:     from collections import Counter\n:....:     gc.collect()\n:....:     pre={id(c) for c in gc.get_objects()}\n:....:     m = matrix(dim, L)\n:....:     for p in range(2,102):\n:....:         m.change_ring(GF(nth_prime(p))).eigenvalues()\n:....:     gc.collect()\n:....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n:....:     return [(k,v) for (k,v) in post.iteritems() if v%100==0]\n:--\nsage: test_mod_100(L, 5)\n[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>, 100),\n (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),\n (<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>, 100),\n (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),\n (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),\n (<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>, 100),\n (<type 'sage.categories.map.FormalCompositeMap'>, 200),\n (<type 'sage.rings.polynomial.polynomial_element.PolynomialBaseringInjection'>, 200),\n (<class 'sage.rings.ideal.Ideal_pid'>, 100),\n (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100)]\n```\n\nand they do disappear with this ticket on top on sage-6.9.rc0:\n\n```python\nsage: test_mod_100(L, 5)\n[]\n```\n\nThat being said, I do see some stuff on the second, third, fourth execution of `test(L, 5)`:\n\n```python\nsage: test(L, 5)\n[(<type 'tuple'>, 5198),\n (<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category.element_class'>,  101),\n (<type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>,  194),\n (<type 'sage.rings.finite_rings.element_pari_ffelt.FiniteFieldElement_pari_ffelt'>,  1104),\n (<type 'dict'>, 102)]\n```\n\nIs this problematic?",
    "created_at": "2015-09-30T08:51:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264816",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:44" align="right">comment:44</div>

Replying to [@seblabbe](#comment%3A43):
>  because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0.

Sorry, I am retracting here as I do see them on sage-6.9.rc0:

```python
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: %cpaste
Pasting code; enter '--' alone on the line to stop or use Ctrl-D.
:sage: def test_mod_100(L, dim):
:....:     import gc
:....:     from collections import Counter
:....:     gc.collect()
:....:     pre={id(c) for c in gc.get_objects()}
:....:     m = matrix(dim, L)
:....:     for p in range(2,102):
:....:         m.change_ring(GF(nth_prime(p))).eigenvalues()
:....:     gc.collect()
:....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
:....:     return [(k,v) for (k,v) in post.iteritems() if v%100==0]
:--
sage: test_mod_100(L, 5)
[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>, 100),
 (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),
 (<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>, 100),
 (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),
 (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),
 (<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>, 100),
 (<type 'sage.categories.map.FormalCompositeMap'>, 200),
 (<type 'sage.rings.polynomial.polynomial_element.PolynomialBaseringInjection'>, 200),
 (<class 'sage.rings.ideal.Ideal_pid'>, 100),
 (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100)]
```

and they do disappear with this ticket on top on sage-6.9.rc0:

```python
sage: test_mod_100(L, 5)
[]
```

That being said, I do see some stuff on the second, third, fourth execution of `test(L, 5)`:

```python
sage: test(L, 5)
[(<type 'tuple'>, 5198),
 (<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category.element_class'>,  101),
 (<type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>,  194),
 (<type 'sage.rings.finite_rings.element_pari_ffelt.FiniteFieldElement_pari_ffelt'>,  1104),
 (<type 'dict'>, 102)]
```

Is this problematic?



---

archive/issue_comments_264817.json:
```json
{
    "body": "Changed dependencies from **#18897, #14058** to none",
    "created_at": "2017-05-27T20:03:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264817",
    "user": "https://github.com/fchapoton"
}
```

Changed dependencies from **#18897, #14058** to none



---

archive/issue_events_265972.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2017-05-27T20:03:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "milestone_number": null,
    "milestone_title": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265972"
}
```



---

archive/issue_events_265973.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2017-05-27T20:03:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "milestone_number": null,
    "milestone_title": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265973"
}
```



---

archive/issue_comments_264818.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/memleak_for_integer_mod_rel_14058](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/memleak_for_integer_mod_rel_14058)** to **[public/18905](https://github.com/sagemath/sagetrac-mirror/tree/public/18905)**",
    "created_at": "2017-05-27T20:03:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264818",
    "user": "https://github.com/fchapoton"
}
```

Changed branch from **[u/SimonKing/memleak_for_integer_mod_rel_14058](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/memleak_for_integer_mod_rel_14058)** to **[public/18905](https://github.com/sagemath/sagetrac-mirror/tree/public/18905)**



---

archive/issue_comments_264819.json:
```json
{
    "body": "Changed commit from **[`3ada19d`](https://github.com/sagemath/sagetrac-mirror/commit/3ada19d1acf58d1d085c1908b3058de8377901a4)** to **[`e952388`](https://github.com/sagemath/sagetrac-mirror/commit/e952388409f97f3e40b9e4d56ab3e42b6cb13b88)**",
    "created_at": "2017-05-27T20:03:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264819",
    "user": "https://github.com/fchapoton"
}
```

Changed commit from **[`3ada19d`](https://github.com/sagemath/sagetrac-mirror/commit/3ada19d1acf58d1d085c1908b3058de8377901a4)** to **[`e952388`](https://github.com/sagemath/sagetrac-mirror/commit/e952388409f97f3e40b9e4d56ab3e42b6cb13b88)**



---

archive/issue_comments_264820.json:
```json
{
    "body": "<div id=\"comment:45\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e952388409f97f3e40b9e4d56ab3e42b6cb13b88\"><code>e952388</code></a></td><td><code>Merge branch 'u/SimonKing/memleak_for_integer_mod_rel_14058' in 8.0.b8</code></td></tr></table>\n",
    "created_at": "2017-05-27T20:03:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18905#issuecomment-264820",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:45"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e952388409f97f3e40b9e4d56ab3e42b6cb13b88"><code>e952388</code></a></td><td><code>Merge branch 'u/SimonKing/memleak_for_integer_mod_rel_14058' in 8.0.b8</code></td></tr></table>




---

archive/issue_events_265974.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:39:18Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/18905",
    "milestone_number": null,
    "milestone_title": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18905#event-265974"
}
```
