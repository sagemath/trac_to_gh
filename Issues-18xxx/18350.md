# Issue 18350: Adams operator

archive/issues_018113.json:
```json
{
    "body": "Hello every one,\n\nI offer to append a generic operator on Hopf algebra: the coproduct and the product iterate k times. (I assume that operation is called the Adams operation but... it seems to be totally something else in the sage Sym... so... I'm not sure about the name of this operation)\n\n```\nsage: h = SymmetricFunctions(QQ).h()\nsage: h[5].adams_operator(2)\n2*h[3, 2] + 2*h[4, 1] + 2*h[5]\nsage: tensor([h,h]).module_morphism(on_basis=lambda c: h(c[0])*h(c[1]), codomain=h)(h[5].coproduct())\n2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n```\n\nCheers,\nJean-Baptiste\n\n\nCC:  @nthiery @avirmaux @jhpalmieri nborie mshimo @tscrim amypang @alauve\n\nAuthor: Jean-Baptiste Priez\n\nBranch: u/elixyre/ticket/18350\n\nCommit: fc8726a50725479d84aa9a07f55e28e1f879880a\n\nResolution: duplicate\n\nIssue created by migration from https://trac.sagemath.org/ticket/18350\n\n",
    "closed_at": "2015-08-14T07:34:53Z",
    "created_at": "2015-05-01T17:23:56Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Adams operator",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18350",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```
Hello every one,

I offer to append a generic operator on Hopf algebra: the coproduct and the product iterate k times. (I assume that operation is called the Adams operation but... it seems to be totally something else in the sage Sym... so... I'm not sure about the name of this operation)

```
sage: h = SymmetricFunctions(QQ).h()
sage: h[5].adams_operator(2)
2*h[3, 2] + 2*h[4, 1] + 2*h[5]
sage: tensor([h,h]).module_morphism(on_basis=lambda c: h(c[0])*h(c[1]), codomain=h)(h[5].coproduct())
2*h[3, 2] + 2*h[4, 1] + 2*h[5]
```

Cheers,
Jean-Baptiste


CC:  @nthiery @avirmaux @jhpalmieri nborie mshimo @tscrim amypang @alauve

Author: Jean-Baptiste Priez

Branch: u/elixyre/ticket/18350

Commit: fc8726a50725479d84aa9a07f55e28e1f879880a

Resolution: duplicate

Issue created by migration from https://trac.sagemath.org/ticket/18350





---

archive/issue_comments_319215.json:
```json
{
    "body": "<a id='comment:1'></a>New commits:",
    "created_at": "2015-05-01T17:25:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319215",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

<a id='comment:1'></a>New commits:



---

archive/issue_comments_319216.json:
```json
{
    "body": "Changing commit from \"\" to \"a685ad1c5acbb5dc1451e06809ce74955d54d53c\"",
    "created_at": "2015-05-01T17:25:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319216",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

Changing commit from "" to "a685ad1c5acbb5dc1451e06809ce74955d54d53c"



---

archive/issue_comments_319217.json:
```json
{
    "body": "Changing branch from \"\" to \"u/elixyre/ticket/18350\"",
    "created_at": "2015-05-01T17:25:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319217",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

Changing branch from "" to "u/elixyre/ticket/18350"



---

archive/issue_comments_319218.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-05-01T17:26:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319218",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_319219.json:
```json
{
    "body": "<a id='comment:4'></a>I don't know how standard the name is -- I'd never heard it -- so you might provide references: I found http://www.math.cornell.edu/~maguiar/adams.pdf and http://preprints.ihes.fr/2006/M/M-06-40.pdf, for example. By the way, I object to the notation `\\Delta^1 = Id`: I think most people would expect `\\Delta^1 = \\Delta` and `\\Delta^0 = Id`. Same for `\\mu`, of course.",
    "created_at": "2015-05-01T21:46:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319219",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:4'></a>I don't know how standard the name is -- I'd never heard it -- so you might provide references: I found http://www.math.cornell.edu/~maguiar/adams.pdf and http://preprints.ihes.fr/2006/M/M-06-40.pdf, for example. By the way, I object to the notation `\Delta^1 = Id`: I think most people would expect `\Delta^1 = \Delta` and `\Delta^0 = Id`. Same for `\mu`, of course.



---

archive/issue_comments_319220.json:
```json
{
    "body": "Changing commit from \"a685ad1c5acbb5dc1451e06809ce74955d54d53c\" to \"fc8726a50725479d84aa9a07f55e28e1f879880a\"",
    "created_at": "2015-05-01T22:50:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319220",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "a685ad1c5acbb5dc1451e06809ce74955d54d53c" to "fc8726a50725479d84aa9a07f55e28e1f879880a"



---

archive/issue_comments_319221.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-01T22:50:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319221",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319222.json:
```json
{
    "body": "<a id='comment:6'></a>Salut Jean-Baptiste,\n\nThanks for the proof of concept!\n\nComputing `n`-fold products and coproducts is a generally useful\nfeature, so I would abstract it away. Probably with an API such as:\n\n```\n    sage: H = MyFavoriteHopfAlgebra()\n\n    sage: coprodk = H.nfold_coproduct(n); phi\n    A morphism from H to H # ... # H\n\n    sage: muk = H.mu(n); muk\n    A morphism from H # ... # H to H\n\n    sage: mu = H.mu(); mu         # default value\n    A morphism from H # H to H\n\n    sage: adams = H.adams_operator(n); adams\n    A morphism from H to H\n```\n\nI don't have a strong opinion for what `n` should stand for. At first\nsight it feels natural to have `H.nfold_coproduct(n)` go from `H` the\n`n`-fold tensor product of `H`, and reciprocally for `H.mu`. But this\ndoes not match with Dima's suggestion since `H.coproduct` would be\n`H.nfold_coproduct(2)`.\n\nPossibly with shorthands to call those from the elements:\n\n```\n    sage: h = H().an_element()\n    sage: h.nfold_coproduct(n)   # in Coalgebras.TensorProducts.ElementMethods\n    sage: h.adams(n)             # in HopfAlgebras.TensorProducts.ElementMethods?\n    sage: tensor([h,h,h]).mu()   # in Algebras.TensorProducts.ElementMethods?\n```\n\nThis approach also has the advantage of constructing the morphisms\nonly once.\n\n`H.adams_operator` can be simply defined as `H.mu(n) *\nH.nfold_coproduct(n)`.  `H.mu` can be defined straightforwardly on the\nbasis.  `H.nfold_coproduct` indeed has to be defined recursively as\nyou did. We might as well use binary exponentiation. For example,\n`H.nfold_coproduct(2*n)` can be defined as:\n\n```\n    tensor([H.coproduct(n), H.coproduct(n)]) * H.coproduct\n```\n\nSo altogether this should require no more code (possibly less) than\nwhat you have already.\n\nOne small feature we are missing in Sage 6.6: constructing tensor\nproducts of morphisms. Luckily we do have code for this: #15832\n(Nicolas Borie also has code for this somewhere; Nicolas: could you\nprovide us with a pointer? Thanks). It's a small feature that we\nreally want to have anyway, so that can be a good occasion to get it\nmerged in.\n\nCheers,\n                                  Nicolas",
    "created_at": "2015-05-02T16:24:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319222",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>Salut Jean-Baptiste,

Thanks for the proof of concept!

Computing `n`-fold products and coproducts is a generally useful
feature, so I would abstract it away. Probably with an API such as:

```
    sage: H = MyFavoriteHopfAlgebra()

    sage: coprodk = H.nfold_coproduct(n); phi
    A morphism from H to H # ... # H

    sage: muk = H.mu(n); muk
    A morphism from H # ... # H to H

    sage: mu = H.mu(); mu         # default value
    A morphism from H # H to H

    sage: adams = H.adams_operator(n); adams
    A morphism from H to H
```

I don't have a strong opinion for what `n` should stand for. At first
sight it feels natural to have `H.nfold_coproduct(n)` go from `H` the
`n`-fold tensor product of `H`, and reciprocally for `H.mu`. But this
does not match with Dima's suggestion since `H.coproduct` would be
`H.nfold_coproduct(2)`.

Possibly with shorthands to call those from the elements:

```
    sage: h = H().an_element()
    sage: h.nfold_coproduct(n)   # in Coalgebras.TensorProducts.ElementMethods
    sage: h.adams(n)             # in HopfAlgebras.TensorProducts.ElementMethods?
    sage: tensor([h,h,h]).mu()   # in Algebras.TensorProducts.ElementMethods?
```

This approach also has the advantage of constructing the morphisms
only once.

`H.adams_operator` can be simply defined as `H.mu(n) *
H.nfold_coproduct(n)`.  `H.mu` can be defined straightforwardly on the
basis.  `H.nfold_coproduct` indeed has to be defined recursively as
you did. We might as well use binary exponentiation. For example,
`H.nfold_coproduct(2*n)` can be defined as:

```
    tensor([H.coproduct(n), H.coproduct(n)]) * H.coproduct
```

So altogether this should require no more code (possibly less) than
what you have already.

One small feature we are missing in Sage 6.6: constructing tensor
products of morphisms. Luckily we do have code for this: #15832
(Nicolas Borie also has code for this somewhere; Nicolas: could you
provide us with a pointer? Thanks). It's a small feature that we
really want to have anyway, so that can be a good occasion to get it
merged in.

Cheers,
                                  Nicolas



---

archive/issue_comments_319223.json:
```json
{
    "body": "<a id='comment:8'></a>Hi,\n\nThat is easy to implement an ugly `nfold_coproduct` (as I did) but I don't know how to implement an `nfold_product`. Where implements it?\n\nFurthermore, if you want to go in this way it seems to be great to be able to do that:\n\n```\nsage: h = MyFavoriteHopfAlgebras(QQ)\nsage: id = h.identity_map\nsage: mu = h.product\nsage: op = tensor([mu, id])\nsage: a,b,c = h.some_three_elements()\nsage: op(tensor([a,b,c]))\na*b # c\n```\n\nThis feature exists? If this exists I'm agree to implement those `nfold_coproduct` and `nfold_product` operators but otherwise I assume this feature should be implemented before.",
    "created_at": "2015-05-03T09:05:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319223",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

<a id='comment:8'></a>Hi,

That is easy to implement an ugly `nfold_coproduct` (as I did) but I don't know how to implement an `nfold_product`. Where implements it?

Furthermore, if you want to go in this way it seems to be great to be able to do that:

```
sage: h = MyFavoriteHopfAlgebras(QQ)
sage: id = h.identity_map
sage: mu = h.product
sage: op = tensor([mu, id])
sage: a,b,c = h.some_three_elements()
sage: op(tensor([a,b,c]))
a*b # c
```

This feature exists? If this exists I'm agree to implement those `nfold_coproduct` and `nfold_product` operators but otherwise I assume this feature should be implemented before.



---

archive/issue_comments_319224.json:
```json
{
    "body": "<a id='comment:9'></a>Sorry... I'm a bad reader... You already answer to my last question... #15832.\n\nThanks. I will look at it",
    "created_at": "2015-05-03T09:27:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319224",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

<a id='comment:9'></a>Sorry... I'm a bad reader... You already answer to my last question... #15832.

Thanks. I will look at it



---

archive/issue_comments_319225.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [elixyre](#comment%3A8):\n> That is easy to implement an ugly `nfold_coproduct` (as I did) but I don't know how to implement an `nfold_product`. Where implements it?\n\n\nTypically a method in Algebras.ParentMethods whose code would be along\nthe following lines (not tested!):\n\n```\n    T = tensor([self]*n)\n    T.module_morphism(lambda t: self.product(self.monomial(i) for i in t), codomain=self)\n```\n\nBtw: I looked at the code of #15832: there are many other things in\nthe branch attached to the ticket; I'll try to extract a branch with\njust the ticket-relevant feature tomorrow.\n\nCheers,\n                        Nicolas",
    "created_at": "2015-05-03T09:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319225",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:10'></a>Replying to [elixyre](#comment%3A8):
> That is easy to implement an ugly `nfold_coproduct` (as I did) but I don't know how to implement an `nfold_product`. Where implements it?


Typically a method in Algebras.ParentMethods whose code would be along
the following lines (not tested!):

```
    T = tensor([self]*n)
    T.module_morphism(lambda t: self.product(self.monomial(i) for i in t), codomain=self)
```

Btw: I looked at the code of #15832: there are many other things in
the branch attached to the ticket; I'll try to extract a branch with
just the ticket-relevant feature tomorrow.

Cheers,
                        Nicolas



---

archive/issue_comments_319226.json:
```json
{
    "body": "<a id='comment:11'></a>I'm not too fond of the name `nfold_coproduct` as I think it will be hard to discover. How about instead `coproduct_power`?",
    "created_at": "2015-05-03T15:47:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319226",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>I'm not too fond of the name `nfold_coproduct` as I think it will be hard to discover. How about instead `coproduct_power`?



---

archive/issue_comments_319227.json:
```json
{
    "body": "<a id='comment:12'></a>Or `iterated_coproduct`? I guess you're thinking about tab-completion, which won't help for my suggestion...",
    "created_at": "2015-05-03T16:19:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319227",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:12'></a>Or `iterated_coproduct`? I guess you're thinking about tab-completion, which won't help for my suggestion...



---

archive/issue_comments_319228.json:
```json
{
    "body": "<a id='comment:13'></a>Yeah, I see your point. I am not super keen on \"coproduct power\"\neither, as it's really the analogue (in fact essentially the dual) of\nn-ary products (which of course are computed iteratively from binary\nproducts), and less so of powering (for\ncomposition/multiplication). In particular, `n` is more related to the\nnumber of factors in the tensor than to the number of times the\ncoproduct needs to be iterated.\n\nI agree that tab-completion-wise it would be nice to have a name such\nas `coproduct_...`. I could live with `coproduct_nfold`. But any\nbetter suggestion is welcome!\n\nCheers,\n                          Nicolas",
    "created_at": "2015-05-03T20:51:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319228",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:13'></a>Yeah, I see your point. I am not super keen on "coproduct power"
either, as it's really the analogue (in fact essentially the dual) of
n-ary products (which of course are computed iteratively from binary
products), and less so of powering (for
composition/multiplication). In particular, `n` is more related to the
number of factors in the tensor than to the number of times the
coproduct needs to be iterated.

I agree that tab-completion-wise it would be nice to have a name such
as `coproduct_...`. I could live with `coproduct_nfold`. But any
better suggestion is welcome!

Cheers,
                          Nicolas



---

archive/issue_comments_319229.json:
```json
{
    "body": "<a id='comment:14'></a>Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.",
    "created_at": "2015-05-04T01:16:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319229",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:14'></a>Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.



---

archive/issue_comments_319230.json:
```json
{
    "body": "<a id='comment:15'></a>Replying to [jhpalmieri](#comment%3A14):\n> Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.\n\n\nI think this would be a good solution. For the most part, we don't implement a `coproduct()`, but use the general one with a `coproduct_on_basis` (in fact, I don't know of a place where we have a custom `coproduct`). So it will be discoverable using code inspection.\n\nI thought of `coproduct_power` by thinking of it as a module morphism which was repeatedly applied, but I see your point. Although for that we'd only have the ambiguity for bialgebras, right? Anyways `coproduct_nfold` would be acceptable to me, and I think `iterated_coproduct` is also something somewhat natural and is acceptable.",
    "created_at": "2015-05-04T05:36:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319230",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:15'></a>Replying to [jhpalmieri](#comment%3A14):
> Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.


I think this would be a good solution. For the most part, we don't implement a `coproduct()`, but use the general one with a `coproduct_on_basis` (in fact, I don't know of a place where we have a custom `coproduct`). So it will be discoverable using code inspection.

I thought of `coproduct_power` by thinking of it as a module morphism which was repeatedly applied, but I see your point. Although for that we'd only have the ambiguity for bialgebras, right? Anyways `coproduct_nfold` would be acceptable to me, and I think `iterated_coproduct` is also something somewhat natural and is acceptable.



---

archive/issue_comments_319231.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [jhpalmieri](#comment%3A14):\n> Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.\n\n\nI think this comfortable to have some alias but it is also important to have a real name method (alias are syntactic sugar). I am agree with  the alias `coproduct(n)`.\n\nReplying to [tscrim](#comment%3A15):\n> I thought of `coproduct_power` by thinking of it as a module morphism which was repeatedly applied, but I see your point. Although for that we'd only have the ambiguity for bialgebras, right? Anyways `coproduct_nfold` would be acceptable to me, and I think `iterated_coproduct` is also something somewhat natural and is acceptable.\n\n\nI think `iterated_coproduct` is hard to discover. Is this totally non-sense to have `coproduct_iterated`? I let you choose a good name... My english is to bad to find relevant names.",
    "created_at": "2015-05-04T06:32:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319231",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

<a id='comment:16'></a>Replying to [jhpalmieri](#comment%3A14):
> Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.


I think this comfortable to have some alias but it is also important to have a real name method (alias are syntactic sugar). I am agree with  the alias `coproduct(n)`.

Replying to [tscrim](#comment%3A15):
> I thought of `coproduct_power` by thinking of it as a module morphism which was repeatedly applied, but I see your point. Although for that we'd only have the ambiguity for bialgebras, right? Anyways `coproduct_nfold` would be acceptable to me, and I think `iterated_coproduct` is also something somewhat natural and is acceptable.


I think `iterated_coproduct` is hard to discover. Is this totally non-sense to have `coproduct_iterated`? I let you choose a good name... My english is to bad to find relevant names.



---

archive/issue_comments_319232.json:
```json
{
    "body": "<a id='comment:17'></a>Replying to [jhpalmieri](#comment%3A14):\n> Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.\n\n\nYou mean for `a` an element, right? (at the level of the parent, the syntax is `h.coproduct(x)` so this would require something like `h.coproduct(x,n)`.\n\nThe logic for the standard coproduct and the iterated coproduct is\nquite different. Keeping the methods separate makes it easier to\noverride just one or the other. That being said, if we decide that the\ncoproduct and iterated coproduct should always be implemented in the\nparent (but I am not sure about it), then that would be fine to have a\nsingle method `a.coproduct(...)` on the element side that just acts as\nan alias.\n\nCheers,\n                                    Nicolas",
    "created_at": "2015-05-04T07:32:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319232",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:17'></a>Replying to [jhpalmieri](#comment%3A14):
> Another non-discoverable-via-tab-completion way: have `coproduct` take an optional argument `n` (default 1) and then `a.coproduct(n)` will return the n-fold coproduct.


You mean for `a` an element, right? (at the level of the parent, the syntax is `h.coproduct(x)` so this would require something like `h.coproduct(x,n)`.

The logic for the standard coproduct and the iterated coproduct is
quite different. Keeping the methods separate makes it easier to
override just one or the other. That being said, if we decide that the
coproduct and iterated coproduct should always be implemented in the
parent (but I am not sure about it), then that would be fine to have a
single method `a.coproduct(...)` on the element side that just acts as
an alias.

Cheers,
                                    Nicolas



---

archive/issue_comments_319233.json:
```json
{
    "body": "<a id='comment:18'></a>So it seems like the solution we are all unhappy with, but can live with (which makes a good compromise :P) is `coproduct_nfold`. Any objections to this?",
    "created_at": "2015-05-09T23:54:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319233",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:18'></a>So it seems like the solution we are all unhappy with, but can live with (which makes a good compromise :P) is `coproduct_nfold`. Any objections to this?



---

archive/issue_comments_319234.json:
```json
{
    "body": "<a id='comment:19'></a>I vote for `iterated_coproduct`.",
    "created_at": "2015-06-11T20:26:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319234",
    "user": "https://github.com/saliola"
}
```

<a id='comment:19'></a>I vote for `iterated_coproduct`.



---

archive/issue_comments_319235.json:
```json
{
    "body": "<a id='comment:20'></a>Aaron and I vote for `coproduct_iterated`.\n\nAlso, about n: there are two conventions (number of factors in the codomain, or one less than this). We prefer n being the number of factors in the codomain (so the usual coproduct is n=2), and mu<sup>n</sup> Delta<sup>n</sup> goes from H to H.\n\nWe understand there is overlap with ticket #18678.",
    "created_at": "2015-06-11T21:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319235",
    "user": "https://trac.sagemath.org/admin/accounts/users/amypang"
}
```

<a id='comment:20'></a>Aaron and I vote for `coproduct_iterated`.

Also, about n: there are two conventions (number of factors in the codomain, or one less than this). We prefer n being the number of factors in the codomain (so the usual coproduct is n=2), and mu<sup>n</sup> Delta<sup>n</sup> goes from H to H.

We understand there is overlap with ticket #18678.



---

archive/issue_comments_319236.json:
```json
{
    "body": "<a id='comment:22'></a>I will be merging with ticket #18678 over the next few days. In the meantime, some comments for people in-the-know to weigh-in on (will repeat in #18678 when updates appear)...\n\n1. `.adams_operator()` should be moved to `bialgebras.py`, then in `hopf_algebras.py` one should overwrite the bialgebras version, allowing for negative integer powers. (E.g., the (-2)nd convolution power of the identity is none other than the 2nd power of the antipode.)\n\n2. In fact, while adams operators naturally belong in `bialgebras.py`, the present code---in ticket #18678 and #18350---actually belongs in `bialgebras_with_basis.py`---as it uses `.module_morphism()` and `.apply_multilinear_morphism()`---but this would require more rewriting than I feel qualified to handle.\n\n3. More tickets needed! When poking around for an algebra without basis---on which to test my code---I noticed that Sage doesn't know that `QQ[x]` is a module over `QQ` (and hence, one cannot build ``QQ[x].tensor(QQ[x])`. Crazy.\n\n4. Similarly, even though `B = FreeAlgebra(QQ,a,b)` is robust enough that `B.tensor(B)` doesn't throw errors, quotients are out-of-bounds again. Putting `C = B.quotient_ring((a*b-b^2,))`, I get an AttributeError when asking for `C.tensor(C)`.\n\n5. One could also add the following functionality: given linear morphisms R,S,T for a bialgebra B, create their convolution product, a new morphism, via `RST = B.convolution_product(R,S,T)` or perhaps, defined only at the level of a distinguished basis m for B, `RST = m.convolution_product(R,S,T)`. However, it seems ticket #15832 will have a lot of overlap with such code, so I'll hold off on implementing it unless somebody suggests otherwise.\n\n\nP.S. Any final votes regarding Amy Pang's recent comment?",
    "created_at": "2015-06-29T04:17:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319236",
    "user": "https://github.com/alauve"
}
```

<a id='comment:22'></a>I will be merging with ticket #18678 over the next few days. In the meantime, some comments for people in-the-know to weigh-in on (will repeat in #18678 when updates appear)...

1. `.adams_operator()` should be moved to `bialgebras.py`, then in `hopf_algebras.py` one should overwrite the bialgebras version, allowing for negative integer powers. (E.g., the (-2)nd convolution power of the identity is none other than the 2nd power of the antipode.)

2. In fact, while adams operators naturally belong in `bialgebras.py`, the present code---in ticket #18678 and #18350---actually belongs in `bialgebras_with_basis.py`---as it uses `.module_morphism()` and `.apply_multilinear_morphism()`---but this would require more rewriting than I feel qualified to handle.

3. More tickets needed! When poking around for an algebra without basis---on which to test my code---I noticed that Sage doesn't know that `QQ[x]` is a module over `QQ` (and hence, one cannot build ``QQ[x].tensor(QQ[x])`. Crazy.

4. Similarly, even though `B = FreeAlgebra(QQ,a,b)` is robust enough that `B.tensor(B)` doesn't throw errors, quotients are out-of-bounds again. Putting `C = B.quotient_ring((a*b-b^2,))`, I get an AttributeError when asking for `C.tensor(C)`.

5. One could also add the following functionality: given linear morphisms R,S,T for a bialgebra B, create their convolution product, a new morphism, via `RST = B.convolution_product(R,S,T)` or perhaps, defined only at the level of a distinguished basis m for B, `RST = m.convolution_product(R,S,T)`. However, it seems ticket #15832 will have a lot of overlap with such code, so I'll hold off on implementing it unless somebody suggests otherwise.


P.S. Any final votes regarding Amy Pang's recent comment?



---

archive/issue_comments_319237.json:
```json
{
    "body": "<a id='comment:24'></a>This ticket should be marked as duplicate and closed in light of #18678.",
    "created_at": "2015-07-18T01:01:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319237",
    "user": "https://github.com/saliola"
}
```

<a id='comment:24'></a>This ticket should be marked as duplicate and closed in light of #18678.



---

archive/issue_events_051772.json:
```json
{
    "actor": "https://github.com/saliola",
    "created_at": "2015-07-18T01:01:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18350#event-51772"
}
```



---

archive/issue_comments_319238.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-08-02T18:48:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319238",
    "user": "https://github.com/a-andre"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_051773.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-08-14T07:34:53Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18350#event-51773"
}
```



---

archive/issue_comments_319239.json:
```json
{
    "body": "Resolution: duplicate",
    "created_at": "2015-08-14T07:34:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18350",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18350#issuecomment-319239",
    "user": "https://github.com/vbraun"
}
```

Resolution: duplicate
