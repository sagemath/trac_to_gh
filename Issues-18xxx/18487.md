# Issue 18487: float and CombinatorialFreeModule

archive/issues_018250.json:
```json
{
    "assignees": [],
    "body": "a bug in CombinatorialFreeModule ?\n\n```\nsage: C = CombinatorialFreeModule(QQ,['a','b','c'])\nsage: B = C.basis()\nsage: th = B['a']\nsage: th*float(pi)\n3.14159265359*B['a']\nsage: _.parent()\nFree module generated by {'a', 'b', 'c'} over Rational Field\n```\n\n**CC:**  @tscrim\n\n**Keywords:** float free module\n\nIssue created by migration from https://trac.sagemath.org/ticket/18487\n\n",
    "created_at": "2015-05-24T13:40:44Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20algebra",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.10",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "float and CombinatorialFreeModule",
    "type": "issue",
    "updated_at": "2016-02-05T19:36:13Z",
    "url": "https://github.com/sagemath/sage/issues/18487",
    "user": "https://github.com/fchapoton"
}
```
a bug in CombinatorialFreeModule ?

```
sage: C = CombinatorialFreeModule(QQ,['a','b','c'])
sage: B = C.basis()
sage: th = B['a']
sage: th*float(pi)
3.14159265359*B['a']
sage: _.parent()
Free module generated by {'a', 'b', 'c'} over Rational Field
```

**CC:**  @tscrim

**Keywords:** float free module

Issue created by migration from https://trac.sagemath.org/ticket/18487





---

archive/issue_events_225954.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-24T13:40:44Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "milestone_number": null,
    "milestone_title": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18487#event-225954"
}
```



---

archive/issue_events_225955.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-24T13:40:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20algebra",
    "label_color": "08517b",
    "label_name": "component: algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18487#event-225955"
}
```



---

archive/issue_events_225956.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-24T13:40:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "008080",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18487#event-225956"
}
```



---

archive/issue_comments_257666.json:
```json
{
    "body": "<a id='comment:1'></a>\nAny idea of what happens there ?",
    "created_at": "2015-10-07T18:50:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18487#issuecomment-257666",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:1'></a>
Any idea of what happens there ?



---

archive/issue_comments_257667.json:
```json
{
    "body": "<a id='comment:2'></a>\nMy guess is that the coercion framework is not working correctly with this (from the `_acted_upon_` method of the CFM element):\n\n```python\n        # With the current design, the coercion model does not have\n        # enough information to detect a priori that this method only\n        # accepts scalars; so it tries on some elements(), and we need\n        # to make sure to report an error.\n        if isinstance(scalar, Element) and scalar.parent() is not self.base_ring():\n            # Temporary needed by coercion (see Polynomial/FractionField tests).\n            if self.base_ring().has_coerce_map_from(scalar.parent()):\n                scalar = self.base_ring()( scalar )\n            else:\n                return None\n```\nand not doing the (correct) pushout construction. Thus it is not constructing the correct parent. I also get this:\n\n```\nsage: C = CombinatorialFreeModule(ZZ,['a','b','c'])\nsage: C.basis()['a'] * (2/3)\n...\nTypeError: unsupported operand parent(s) for '*': 'Free module generated by {'a', 'b', 'c'} over Integer Ring' and 'Rational Field'\n```\nI don't think the cause is the above snippet, but I suspect it is further down with the construction functor for CFM's (or really lack thereof). Compare with:\n\n```\nsage: C.construction()\nsage: M = ZZ^3\nsage: 3.12 * M([1,0,0])\n(3.12000000000000, 0.000000000000000, 0.000000000000000)\nsage: _.parent()\nVector space of dimension 3 over Real Field with 53 bits of precision\nsage: M.construction()\n(VectorFunctor, Integer Ring)\n```",
    "created_at": "2015-10-07T19:10:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18487#issuecomment-257667",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
My guess is that the coercion framework is not working correctly with this (from the `_acted_upon_` method of the CFM element):

```python
        # With the current design, the coercion model does not have
        # enough information to detect a priori that this method only
        # accepts scalars; so it tries on some elements(), and we need
        # to make sure to report an error.
        if isinstance(scalar, Element) and scalar.parent() is not self.base_ring():
            # Temporary needed by coercion (see Polynomial/FractionField tests).
            if self.base_ring().has_coerce_map_from(scalar.parent()):
                scalar = self.base_ring()( scalar )
            else:
                return None
```
and not doing the (correct) pushout construction. Thus it is not constructing the correct parent. I also get this:

```
sage: C = CombinatorialFreeModule(ZZ,['a','b','c'])
sage: C.basis()['a'] * (2/3)
...
TypeError: unsupported operand parent(s) for '*': 'Free module generated by {'a', 'b', 'c'} over Integer Ring' and 'Rational Field'
```
I don't think the cause is the above snippet, but I suspect it is further down with the construction functor for CFM's (or really lack thereof). Compare with:

```
sage: C.construction()
sage: M = ZZ^3
sage: 3.12 * M([1,0,0])
(3.12000000000000, 0.000000000000000, 0.000000000000000)
sage: _.parent()
Vector space of dimension 3 over Real Field with 53 bits of precision
sage: M.construction()
(VectorFunctor, Integer Ring)
```



---

archive/issue_events_225957.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2015-10-07T19:10:20Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "milestone_number": null,
    "milestone_title": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18487#event-225957"
}
```



---

archive/issue_events_225958.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2015-10-07T19:10:20Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "milestone_number": null,
    "milestone_title": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18487#event-225958"
}
```



---

archive/issue_comments_257668.json:
```json
{
    "body": "<a id='comment:3'></a>\nJust a remark: CFMs will probably not work well with floats even when this is fixed. A lot of CFM code is based on the idea that the base ring is exact.",
    "created_at": "2016-02-05T19:36:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18487",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18487#issuecomment-257668",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
Just a remark: CFMs will probably not work well with floats even when this is fixed. A lot of CFM code is based on the idea that the base ring is exact.
