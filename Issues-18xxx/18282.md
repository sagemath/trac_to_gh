# Issue 18282: Fixes, cleanup and improvements to the default evaluation method for univariate polynomials

archive/issues_018045.json:
```json
{
    "body": "Simplify `Polynomial.__call__()`, fix the following issues (note that in calls of the form `p(x,y,...)`, `x` is the *outermost* variable), and add a few tests.\n\n```\nsage: Pol_x.<x> = QQ[]\nsage: Pol_xy.<y> = Pol_x[]\nsage: pol = 1000*x^2*y^2 + 100*y + 10*x + 1\nsage: pol(y, 0)\n1000*x^2*y^2 + 100*y + 10*x + 1\n```\n\n```\nsage: pol(y, 0)\n1000*x^2*y^2 + 100*y + 10*x + 1\n```\n\n```\nsage: pol(~y, 0) # not the same bug as above\n((10*x + 1)*y^2 + 100*y + 1000*x^2)/y^2\n```\n\n```\nsage: pol(x, y, x=1)\n1000*y^2 + 10*y + 101\n```\n\n```\nsage: zero = Pol_xy(0)\nsage: zero(1).parent()\nInteger Ring\n```\n\n```\nsage: zero = QQ['x'](0)\nsage: a = matrix(ZZ, [[1]])\nsage: zero(a).parent() # should be over QQ\nFull MatrixSpace of 1 by 1 dense matrices over Integer Ring\n```\n\n```\nsage: zero = GF(2)['x'](0)\nsage: zero(1.).parent() # should raise an error\nReal Field with 53 bits of precision\n```\n\n```\nsage: pol(y=x, x=1)\n1111\n```\n\n```\nsage: pol = QQ['x'](range(10))\nsage: pol(x) # technically not a bug, but should be expanded\n((((((((9*x + 8)*x + 7)*x + 6)*x + 5)*x + 4)*x + 3)*x + 2)*x + 1)*x\n```\n\nAlso implement a method to compute the Horner form of a polynomial expression, in order not to lose the \u201cfeature\u201d illustrated in the last example.\n\nCC:  @rwst jpflori\n\nReviewer: Ralf Stephan\n\nAuthor: Marc Mezzarobba\n\nBranch: 8ed19674f4788e97c9f3697fdb67a06c2ef2c781\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/18282\n\n",
    "closed_at": "2015-07-31T17:52:27Z",
    "created_at": "2015-04-22T16:01:55Z",
    "labels": [
        "component: commutative algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "Fixes, cleanup and improvements to the default evaluation method for univariate polynomials",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18282",
    "user": "https://github.com/mezzarobba"
}
```
Simplify `Polynomial.__call__()`, fix the following issues (note that in calls of the form `p(x,y,...)`, `x` is the *outermost* variable), and add a few tests.

```
sage: Pol_x.<x> = QQ[]
sage: Pol_xy.<y> = Pol_x[]
sage: pol = 1000*x^2*y^2 + 100*y + 10*x + 1
sage: pol(y, 0)
1000*x^2*y^2 + 100*y + 10*x + 1
```

```
sage: pol(y, 0)
1000*x^2*y^2 + 100*y + 10*x + 1
```

```
sage: pol(~y, 0) # not the same bug as above
((10*x + 1)*y^2 + 100*y + 1000*x^2)/y^2
```

```
sage: pol(x, y, x=1)
1000*y^2 + 10*y + 101
```

```
sage: zero = Pol_xy(0)
sage: zero(1).parent()
Integer Ring
```

```
sage: zero = QQ['x'](0)
sage: a = matrix(ZZ, [[1]])
sage: zero(a).parent() # should be over QQ
Full MatrixSpace of 1 by 1 dense matrices over Integer Ring
```

```
sage: zero = GF(2)['x'](0)
sage: zero(1.).parent() # should raise an error
Real Field with 53 bits of precision
```

```
sage: pol(y=x, x=1)
1111
```

```
sage: pol = QQ['x'](range(10))
sage: pol(x) # technically not a bug, but should be expanded
((((((((9*x + 8)*x + 7)*x + 6)*x + 5)*x + 4)*x + 3)*x + 2)*x + 1)*x
```

Also implement a method to compute the Horner form of a polynomial expression, in order not to lose the “feature” illustrated in the last example.

CC:  @rwst jpflori

Reviewer: Ralf Stephan

Author: Marc Mezzarobba

Branch: 8ed19674f4788e97c9f3697fdb67a06c2ef2c781

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/18282





---

archive/issue_comments_242603.json:
```json
{
    "body": "<a id='comment:1'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-23T11:03:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242603",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_242604.json:
```json
{
    "body": "Changing component from symbolics to commutative algebra.",
    "created_at": "2015-04-24T12:30:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242604",
    "user": "https://github.com/rwst"
}
```

Changing component from symbolics to commutative algebra.



---

archive/issue_comments_242605.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-24T16:46:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242605",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_242606.json:
```json
{
    "body": "<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-25T06:55:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242606",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_242607.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-04-25T06:56:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242607",
    "user": "https://github.com/mezzarobba"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_242608.json:
```json
{
    "body": "<a id='comment:8'></a>\n```\nsage: pol(y, 0)\n1000*x^2*y^2 + 100*y + 10*x + 1\n```\nIf I understand correctly, you now make this evaluate to `100*y+1`? In which ring? You've evaluated `x`, so the answer should lie in QQ['y'], which is not a ring that exists at this moment. What about `pol(y,I)`? should that return an answer in `QuadraticField(-1,name=\"I\")['y']`?\n\n-1 on this: The method you're calling is evaluating a univariate polynomial over an arbitrary ring. You don't know what \"evaluation\" of the coefficient would mean and, more importantly, whether it's supported at all. Furthermore, the rings in which the answer is supposed to lie likely don't exist yet. Letting sage choose which rings should be constructed likely leads to difficult to predict behaviour (you'd basically be relying on the common parents the coercion framework cooks up, and then I think it's better to let the user rely on it him/herself).\n\nI think that `pol(y,0)` should be an error because there's an unhandled coefficient `0` present. It's not clear at all that the *second* argument should be used for the variable that gets mentioned *first* in `QQ['x']['y']`. One might think that `pol(y0,x0)==pol(y0)(x0)`, but that's not the case either. Error really is safer.",
    "created_at": "2015-04-25T19:08:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242608",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:8'></a>
```
sage: pol(y, 0)
1000*x^2*y^2 + 100*y + 10*x + 1
```
If I understand correctly, you now make this evaluate to `100*y+1`? In which ring? You've evaluated `x`, so the answer should lie in QQ['y'], which is not a ring that exists at this moment. What about `pol(y,I)`? should that return an answer in `QuadraticField(-1,name="I")['y']`?

-1 on this: The method you're calling is evaluating a univariate polynomial over an arbitrary ring. You don't know what "evaluation" of the coefficient would mean and, more importantly, whether it's supported at all. Furthermore, the rings in which the answer is supposed to lie likely don't exist yet. Letting sage choose which rings should be constructed likely leads to difficult to predict behaviour (you'd basically be relying on the common parents the coercion framework cooks up, and then I think it's better to let the user rely on it him/herself).

I think that `pol(y,0)` should be an error because there's an unhandled coefficient `0` present. It's not clear at all that the *second* argument should be used for the variable that gets mentioned *first* in `QQ['x']['y']`. One might think that `pol(y0,x0)==pol(y0)(x0)`, but that's not the case either. Error really is safer.



---

archive/issue_comments_242609.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:8 nbruin]:\n> {{{\n> sage: pol(y, 0)\n> 1000*x<sup>2*y</sup>2 + 100*y + 10*x + 1\n> }}}\n> If I understand correctly, you now make this evaluate to `100*y+1`?\n\n\nYes:\n\n```\nsage: pol(y, 0) # with patch\n100*y + 1\n```\n\nNote that the previous implementation wouldn't work in the case of `pol(y, 0)`, but would happily compute\n\n```\nsage: sage: pol(y+1, 0) # without patch\n100*y + 101\n```\n\n> In which ring? You've evaluated `x`, so the answer should lie in QQ['y'], which is not a ring that exists at this moment.\n\n\nNot exactly:\n\n```\nsage: pol(y, 0).parent() # with patch\nUnivariate Polynomial Ring in y over Univariate Polynomial Ring in x over Rational Field\n```\nThe logic here is that yes, I have evaluated x, so the evaluated coefficients lie in \u211a, *but* then I'm evaluating the resulting element of \u211a[Y] on y \u2208 \u211a[x][y], not y \u2208 \u211a[y]. So the answer should lie in \u211a[x][y].\n\nIn contrast,\n\n```\nsage: pol(0, x).parent() # with patch\nUnivariate Polynomial Ring in x over Rational Field\n```\nsince `x.parent()` is `QQ[x]`, not `QQ[x][y]`.\n\n> What about `pol(y,I)`? should that return an answer in `QuadraticField(-1,name=\"I\")['y']`?\n\n\n```\nsage: pol(y, I).parent() # with patch - TBI, see #18036\nSymbolic Ring\nsage: pol(y, I.pyobject()).parent() # with patch\nUnivariate Polynomial Ring in y over Univariate Polynomial Ring in x over Number Field in I with defining polynomial x^2 + 1\n```\n\n> Furthermore, the rings in which the answer is supposed to lie likely don't exist yet. Letting sage choose which rings should be constructed likely leads to difficult to predict behaviour (you'd basically be relying on the common parents the coercion framework cooks up,\n\n\nWell, yes, but that's already the case when you just do `a + b`! Would you really want the evaluation of elements of \u2124[x][y] on y = y0 \u2208 \u211a to raise an error?\n\n> I think that `pol(y,0)` should be an error because there's an unhandled coefficient `0` present. It's not clear at all that the *second* argument should be used for the variable that gets mentioned *first* in `QQ['x']['y']`. One might think that `pol(y0,x0)==pol(y0)(x0)`, but that's not the case either. Error really is safer.\n\n\nPerhaps, yes, but I didn't invent this feature. It has been present for years, and people use it! There are even examples in the sage library that rely on `pol(y,x)` working when pol \u2208 R[y] where R is *not* a polynomial ring (but another ring with callable elements). So really this ticket is only about making the implementation understandable, and fixing lots of corner cases such as those mentioned above.",
    "created_at": "2015-04-26T07:09:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242609",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:9'></a>Replying to [comment:8 nbruin]:
> {{{
> sage: pol(y, 0)
> 1000*x<sup>2*y</sup>2 + 100*y + 10*x + 1
> }}}
> If I understand correctly, you now make this evaluate to `100*y+1`?


Yes:

```
sage: pol(y, 0) # with patch
100*y + 1
```

Note that the previous implementation wouldn't work in the case of `pol(y, 0)`, but would happily compute

```
sage: sage: pol(y+1, 0) # without patch
100*y + 101
```

> In which ring? You've evaluated `x`, so the answer should lie in QQ['y'], which is not a ring that exists at this moment.


Not exactly:

```
sage: pol(y, 0).parent() # with patch
Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Rational Field
```
The logic here is that yes, I have evaluated x, so the evaluated coefficients lie in ℚ, *but* then I'm evaluating the resulting element of ℚ[Y] on y ∈ ℚ[x][y], not y ∈ ℚ[y]. So the answer should lie in ℚ[x][y].

In contrast,

```
sage: pol(0, x).parent() # with patch
Univariate Polynomial Ring in x over Rational Field
```
since `x.parent()` is `QQ[x]`, not `QQ[x][y]`.

> What about `pol(y,I)`? should that return an answer in `QuadraticField(-1,name="I")['y']`?


```
sage: pol(y, I).parent() # with patch - TBI, see #18036
Symbolic Ring
sage: pol(y, I.pyobject()).parent() # with patch
Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Number Field in I with defining polynomial x^2 + 1
```

> Furthermore, the rings in which the answer is supposed to lie likely don't exist yet. Letting sage choose which rings should be constructed likely leads to difficult to predict behaviour (you'd basically be relying on the common parents the coercion framework cooks up,


Well, yes, but that's already the case when you just do `a + b`! Would you really want the evaluation of elements of ℤ[x][y] on y = y0 ∈ ℚ to raise an error?

> I think that `pol(y,0)` should be an error because there's an unhandled coefficient `0` present. It's not clear at all that the *second* argument should be used for the variable that gets mentioned *first* in `QQ['x']['y']`. One might think that `pol(y0,x0)==pol(y0)(x0)`, but that's not the case either. Error really is safer.


Perhaps, yes, but I didn't invent this feature. It has been present for years, and people use it! There are even examples in the sage library that rely on `pol(y,x)` working when pol ∈ R[y] where R is *not* a polynomial ring (but another ring with callable elements). So really this ticket is only about making the implementation understandable, and fixing lots of corner cases such as those mentioned above.



---

archive/issue_comments_242610.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:9 mmezzarobba]:\n> Perhaps, yes, but I didn't invent this feature. It has been present for years, and people use it! There are even examples in the sage library that rely on `pol(y,x)` working when pol \u2208 R[y] where R is *not* a polynomial ring (but another ring with callable elements). So really this ticket is only about making the implementation understandable, and fixing lots of corner cases such as those mentioned above.\n\n\nOK, that seems to be the case indeed. Thanks for cleaning things up a bit.",
    "created_at": "2015-04-26T17:18:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242610",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:10'></a>Replying to [comment:9 mmezzarobba]:
> Perhaps, yes, but I didn't invent this feature. It has been present for years, and people use it! There are even examples in the sage library that rely on `pol(y,x)` working when pol ∈ R[y] where R is *not* a polynomial ring (but another ring with callable elements). So really this ticket is only about making the implementation understandable, and fixing lots of corner cases such as those mentioned above.


OK, that seems to be the case indeed. Thanks for cleaning things up a bit.



---

archive/issue_events_051611.json:
```json
{
    "actor": "https://github.com/mezzarobba",
    "created_at": "2015-05-24T08:11:32Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "milestone": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18282#event-51611"
}
```



---

archive/issue_comments_242611.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-05-30T09:56:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242611",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_242612.json:
```json
{
    "body": "<a id='comment:14'></a>Rebased.",
    "created_at": "2015-05-30T09:58:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242612",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:14'></a>Rebased.



---

archive/issue_comments_242613.json:
```json
{
    "body": "<a id='comment:15'></a>In view of #18600 (and older sisters #18518 and #18585), I think `__call__` may be at the same time improved and adapted to high degree sparse polynomials: Basically, when a univariate polynomial `p` is evaluated on a value `v` (other than a symbolic variable), it uses a Horner scheme that ranges over all the coefficients of `p`, including the zeroes. One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials. And as a side benefit, one would be able to evaluate polynomials such as `x<sup>2</sup>500`, at least on \"easy\" values such as `1` or `-1` or on finite fields.\n\nWhat do you think of my proposal?",
    "created_at": "2015-06-03T15:11:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242613",
    "user": "https://github.com/bgrenet"
}
```

<a id='comment:15'></a>In view of #18600 (and older sisters #18518 and #18585), I think `__call__` may be at the same time improved and adapted to high degree sparse polynomials: Basically, when a univariate polynomial `p` is evaluated on a value `v` (other than a symbolic variable), it uses a Horner scheme that ranges over all the coefficients of `p`, including the zeroes. One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials. And as a side benefit, one would be able to evaluate polynomials such as `x<sup>2</sup>500`, at least on "easy" values such as `1` or `-1` or on finite fields.

What do you think of my proposal?



---

archive/issue_comments_242614.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [comment:15 bruno]:\n> One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials.\n\n\nSounds reasonable\u2014or perhaps one should override `__call__` in `Polynomial_generic_sparse`, I don't know. In any case I have no time to spend on this ticket now, but please feel free to add improvements if you want!",
    "created_at": "2015-06-04T07:40:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242614",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:16'></a>Replying to [comment:15 bruno]:
> One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials.


Sounds reasonable—or perhaps one should override `__call__` in `Polynomial_generic_sparse`, I don't know. In any case I have no time to spend on this ticket now, but please feel free to add improvements if you want!



---

archive/issue_comments_242615.json:
```json
{
    "body": "<a id='comment:17'></a>Replying to [comment:16 mmezzarobba]:\n> Replying to [comment:15 bruno]:\n> > One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials.\n\n> \n> Sounds reasonable\u2014or perhaps one should override `__call__` in `Polynomial_generic_sparse`, I don't know. In any case I have no time to spend on this ticket now, but please feel free to add improvements if you want!\n\n\nActually, I did some tests. It appears that it should be better to implement a `__call__` method in `Polynomial_generic_sparse` to avoid hindering performances. The other solution would be to have tests inside the current `__call__` method to check whether the `parent` is sparse or not. One advantage is to avoid code duplication (for `*args` and `*kwds`), though I guess it is not the right solution.\n\nI'd better let this ticket as it is (and actually try to review it...) and open a new ticket for sparse polynomials.",
    "created_at": "2015-06-04T08:07:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242615",
    "user": "https://github.com/bgrenet"
}
```

<a id='comment:17'></a>Replying to [comment:16 mmezzarobba]:
> Replying to [comment:15 bruno]:
> > One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials.

> 
> Sounds reasonable—or perhaps one should override `__call__` in `Polynomial_generic_sparse`, I don't know. In any case I have no time to spend on this ticket now, but please feel free to add improvements if you want!


Actually, I did some tests. It appears that it should be better to implement a `__call__` method in `Polynomial_generic_sparse` to avoid hindering performances. The other solution would be to have tests inside the current `__call__` method to check whether the `parent` is sparse or not. One advantage is to avoid code duplication (for `*args` and `*kwds`), though I guess it is not the right solution.

I'd better let this ticket as it is (and actually try to review it...) and open a new ticket for sparse polynomials.



---

archive/issue_comments_242616.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-07-29T15:45:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242616",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_242617.json:
```json
{
    "body": "<a id='comment:19'></a>In Pynac-0.4.3 (maybe 0.3.9.3) `sin(pi/5)` expands immediately to `1/4*sqrt(-2*sqrt(5) + 10)` (actually every `sin`/`cos`/`tan` value expressible with `sqrt`s of depth 3), so I'll change the doctest to `sin(pi/7)`.\n\nAs I trust Nils on the general purpose, and I can see nothing missing in the code, also the patchbot is happy and my patch is only a doctest change I'll take the liberty to set positive.\n\n---\nNew commits:",
    "created_at": "2015-07-29T15:45:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242617",
    "user": "https://github.com/rwst"
}
```

<a id='comment:19'></a>In Pynac-0.4.3 (maybe 0.3.9.3) `sin(pi/5)` expands immediately to `1/4*sqrt(-2*sqrt(5) + 10)` (actually every `sin`/`cos`/`tan` value expressible with `sqrt`s of depth 3), so I'll change the doctest to `sin(pi/7)`.

As I trust Nils on the general purpose, and I can see nothing missing in the code, also the patchbot is happy and my patch is only a doctest change I'll take the liberty to set positive.

---
New commits:



---

archive/issue_events_051612.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-07-29T15:45:08Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "milestone": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18282#event-51612"
}
```



---

archive/issue_events_051613.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-07-29T15:45:08Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "milestone": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18282#event-51613"
}
```



---

archive/issue_events_051614.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-07-31T17:52:27Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18282#event-51614"
}
```



---

archive/issue_comments_242618.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-07-31T17:52:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242618",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_242619.json:
```json
{
    "body": "<a id='comment:21'></a>Thanks!",
    "created_at": "2015-08-01T08:35:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18282",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18282#issuecomment-242619",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:21'></a>Thanks!
