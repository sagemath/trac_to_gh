# Issue 18756: Use coerce actions in the category framework

archive/issues_018519.json:
```json
{
    "assignees": [],
    "body": "The starting point of this ticket was:\n\n`CombinatorialFreeModule`\n- is written in Python (hence, is too slow at least for my applications),\n- its elements just inherit from `Element` and not from a more appropriate base class (`ModuleElement` or even better `RingElement`, since the former for some reason raises an error on an inner multiplication), and\n- it is not conforming to Sage's coercion model, which really is bad, since I have seen many people who would start with `CombinatorialFreeModule` when implementing new algebraic stuff.\n\nEarly in the discussion, it was found that using `RingElement` isn't really a solution. Instead, the aim of this ticket was broadened:\n\n- It should be possible to define a multiplication action of a parent on itself; this require changing `ModuleElement.__mul__`.\n- Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.\n- These actions can be implemented in Cython---while the categories stay in Python!\n\n\nCC:  @nthiery sage-combinat\n\nKeywords: **cython, coercion, actions, categories**\n\nBranch/Commit: **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion) @ [a5bdbf6](https://github.com/sagemath/sagetrac-mirror/commit/a5bdbf6f85ea0d732a13ebc7d8e91dbd28c92ef0)**\n\nReviewer: **Travis Scrimshaw**\n\nAuthor: **Simon King**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/18756_\n\n",
    "created_at": "2015-06-21T21:23:09Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20coercion",
        "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.10",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Use coerce actions in the category framework",
    "type": "issue",
    "updated_at": "2023-01-13T13:41:38Z",
    "url": "https://github.com/sagemath/sage/issues/18756",
    "user": "https://github.com/simon-king-jena"
}
```
The starting point of this ticket was:

`CombinatorialFreeModule`
- is written in Python (hence, is too slow at least for my applications),
- its elements just inherit from `Element` and not from a more appropriate base class (`ModuleElement` or even better `RingElement`, since the former for some reason raises an error on an inner multiplication), and
- it is not conforming to Sage's coercion model, which really is bad, since I have seen many people who would start with `CombinatorialFreeModule` when implementing new algebraic stuff.

Early in the discussion, it was found that using `RingElement` isn't really a solution. Instead, the aim of this ticket was broadened:

- It should be possible to define a multiplication action of a parent on itself; this require changing `ModuleElement.__mul__`.
- Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.
- These actions can be implemented in Cython---while the categories stay in Python!


CC:  @nthiery sage-combinat

Keywords: **cython, coercion, actions, categories**

Branch/Commit: **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion) @ [a5bdbf6](https://github.com/sagemath/sagetrac-mirror/commit/a5bdbf6f85ea0d732a13ebc7d8e91dbd28c92ef0)**

Reviewer: **Travis Scrimshaw**

Author: **Simon King**

_Issue created by migration from https://trac.sagemath.org/ticket/18756_





---

archive/issue_events_239698.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-21T21:23:09Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "milestone_number": null,
    "milestone_title": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239698"
}
```



---

archive/issue_events_239699.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-21T21:23:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20algebra",
    "label_color": "0000ff",
    "label_name": "component: algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239699"
}
```



---

archive/issue_events_239700.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-21T21:23:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239700"
}
```



---

archive/issue_events_239701.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-21T21:23:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239701"
}
```



---

archive/issue_comments_264421.json:
```json
{
    "body": "<a id='comment:1'>Comment 1:</a>\nHere is how `CombinatorialFreeModuleElement` fails to use the coercion framework properly.\n\nIt uses the method `_acted_upon_` to implement multiplication by scalars, and then does\n\n```\n    # For backward compatibility\n    _lmul_ = _acted_upon_\n    _rmul_ = _acted_upon_\n```\n\nHowever, it is clearly the job of `_lmul_/_rmul_` to implement a scalar multiplication---not just for backward compatibility! Moreover, in `_lmul_/_rmul_` one can assume that the second argument comes from the base ring---in the current implementation, this has to be explicitly tested, simply since there is no such assumption for `_acted_upon_`.\n\nAnd what is worst: Using `_acted_upon_` is one way to implement a general action that goes BEYOND the action of the base ring. If one wants to implement an action of, say, a path algebra on a free module over a path algebra, then one would \"of course\" use `_acted_upon_`---but by the current design, it would break scalar multiplication.",
    "created_at": "2015-06-21T21:29:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264421",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'>Comment 1:</a>
Here is how `CombinatorialFreeModuleElement` fails to use the coercion framework properly.

It uses the method `_acted_upon_` to implement multiplication by scalars, and then does

```
    # For backward compatibility
    _lmul_ = _acted_upon_
    _rmul_ = _acted_upon_
```

However, it is clearly the job of `_lmul_/_rmul_` to implement a scalar multiplication---not just for backward compatibility! Moreover, in `_lmul_/_rmul_` one can assume that the second argument comes from the base ring---in the current implementation, this has to be explicitly tested, simply since there is no such assumption for `_acted_upon_`.

And what is worst: Using `_acted_upon_` is one way to implement a general action that goes BEYOND the action of the base ring. If one wants to implement an action of, say, a path algebra on a free module over a path algebra, then one would "of course" use `_acted_upon_`---but by the current design, it would break scalar multiplication.



---

archive/issue_comments_264422.json:
```json
{
    "body": "<a id='comment:2'>Comment 2:</a>\nDear Simon,\n\n+1 on cythonizing CombinatorialFreeModuleElement (but not CombinatorialFreeModule unless there is a compelling reason)\n\nok on inheriting from ModuleElement.\n\n-1 on inheriting from RingElement. It's too much of an abuse.\n\n\nCan you elaborate on the speed issue?",
    "created_at": "2015-06-21T21:30:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264422",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:2'>Comment 2:</a>
Dear Simon,

+1 on cythonizing CombinatorialFreeModuleElement (but not CombinatorialFreeModule unless there is a compelling reason)

ok on inheriting from ModuleElement.

-1 on inheriting from RingElement. It's too much of an abuse.


Can you elaborate on the speed issue?



---

archive/issue_comments_264423.json:
```json
{
    "body": "<a id='comment:3'>Comment 3:</a>\nReplying to [@simon-king-jena](#comment%3A1):\n> Here is how `CombinatorialFreeModuleElement` fails to use the coercion framework properly.\n> \n> It uses the method `_acted_upon_` to implement multiplication by scalars, and then does\n> \n> ```\n>     # For backward compatibility\n>     _lmul_ = _acted_upon_\n>     _rmul_ = _acted_upon_\n> ```\n> \n> However, it is clearly the job of `_lmul_/_rmul_` to implement a scalar multiplication---not just for backward compatibility! Moreover, in `_lmul_/_rmul_` one can assume that the second argument comes from the base ring---in the current implementation, this has to be explicitly tested, simply since there is no such assumption for `_acted_upon_`.\n> \n> And what is worst: Using `_acted_upon_` is one way to implement a general action that goes BEYOND the action of the base ring. If one wants to implement an action of, say, a path algebra on a free module over a path algebra, then one would \"of course\" use `_acted_upon_`---but by the current design, it would break scalar multiplication.\n\nI don't remember exactly the rationale behind this comment. It could well be that it was the fact of implementing `_acted_upon_` rather than `_lmul_` / `_rmul_` which was for backward compatibility. Feel free to clean this up.",
    "created_at": "2015-06-21T21:32:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264423",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'>Comment 3:</a>
Replying to [@simon-king-jena](#comment%3A1):
> Here is how `CombinatorialFreeModuleElement` fails to use the coercion framework properly.
> 
> It uses the method `_acted_upon_` to implement multiplication by scalars, and then does
> 
> ```
>     # For backward compatibility
>     _lmul_ = _acted_upon_
>     _rmul_ = _acted_upon_
> ```
> 
> However, it is clearly the job of `_lmul_/_rmul_` to implement a scalar multiplication---not just for backward compatibility! Moreover, in `_lmul_/_rmul_` one can assume that the second argument comes from the base ring---in the current implementation, this has to be explicitly tested, simply since there is no such assumption for `_acted_upon_`.
> 
> And what is worst: Using `_acted_upon_` is one way to implement a general action that goes BEYOND the action of the base ring. If one wants to implement an action of, say, a path algebra on a free module over a path algebra, then one would "of course" use `_acted_upon_`---but by the current design, it would break scalar multiplication.

I don't remember exactly the rationale behind this comment. It could well be that it was the fact of implementing `_acted_upon_` rather than `_lmul_` / `_rmul_` which was for backward compatibility. Feel free to clean this up.



---

archive/issue_comments_264424.json:
```json
{
    "body": "<a id='comment:4'>Comment 4:</a>\nReplying to [@nthiery](#comment%3A2):\n> +1 on cythonizing CombinatorialFreeModuleElement (but not CombinatorialFreeModule unless there is a compelling reason)\n\nI was talking about cythoning the elements and the helper functions. I plan to turn `CombinatorialFreeModule` into a Python class in a cython file (i.e., keeping parent and element in one file), which means that some generic code in the methods of `CombinatorialFreeModule` would become faster. But the class would NOT be cdef.\n\n> ok on inheriting from ModuleElement.\n> \n> -1 on inheriting from RingElement. It's too much of an abuse.\n\nI disagree. Actually I believe the current structure is an abuse.\n\n- `ELement` uses `_acted_on_/_acted_upon_` to implement actions. It has no `_lmul_`, which means that the comment \"for backward compatibility\" fails entirely.\n- `ModuleElement` provides the infrastructure for both general actions (inherited from `Element`) and a special path for scalar multiplication (`_lmul_/_rmul_`). Problem: You can not implement a ring multiplication when you just inherit from `ModuleElement`, since `ModuleElement.__mul__` raises an error if both arguments belong to the same parent.\n- `RingElement` provides the infrastructure for general actions, scalar multiplication, and ring multiplication (via `_mul_`).\n\nI have seen that people use `CombinatorialFreeModule` as a starting points for implementing algebras. That's an abuse, since it works around the existing infrastructure.\n\n> Can you elaborate on the speed issue?\n\nThe old implementation of path algebras used `CombinatorialFreeModule` (by the way: For ALGEBRAS, hence, one needs ring multiplication!). Granted, in this case the actual spee-up comes from using special data types.\n\nIt is of course not ideal when one uses `RingElement` to implement elements of a module. However, we must not forget that `CombinatorialFreeModule` is applied in a wider range, not just to implement modules but also rings.\n\nAlternatively, one could create two base classes for elements: One inherits from `ModuleElement`, the other from `RingElement`, and then the `CombinatorialFreeModule.Element` attribute is assigned during initialisation, according to whether the category is a sub-category of `Rings()` or not.",
    "created_at": "2015-06-21T21:45:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264424",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'>Comment 4:</a>
Replying to [@nthiery](#comment%3A2):
> +1 on cythonizing CombinatorialFreeModuleElement (but not CombinatorialFreeModule unless there is a compelling reason)

I was talking about cythoning the elements and the helper functions. I plan to turn `CombinatorialFreeModule` into a Python class in a cython file (i.e., keeping parent and element in one file), which means that some generic code in the methods of `CombinatorialFreeModule` would become faster. But the class would NOT be cdef.

> ok on inheriting from ModuleElement.
> 
> -1 on inheriting from RingElement. It's too much of an abuse.

I disagree. Actually I believe the current structure is an abuse.

- `ELement` uses `_acted_on_/_acted_upon_` to implement actions. It has no `_lmul_`, which means that the comment "for backward compatibility" fails entirely.
- `ModuleElement` provides the infrastructure for both general actions (inherited from `Element`) and a special path for scalar multiplication (`_lmul_/_rmul_`). Problem: You can not implement a ring multiplication when you just inherit from `ModuleElement`, since `ModuleElement.__mul__` raises an error if both arguments belong to the same parent.
- `RingElement` provides the infrastructure for general actions, scalar multiplication, and ring multiplication (via `_mul_`).

I have seen that people use `CombinatorialFreeModule` as a starting points for implementing algebras. That's an abuse, since it works around the existing infrastructure.

> Can you elaborate on the speed issue?

The old implementation of path algebras used `CombinatorialFreeModule` (by the way: For ALGEBRAS, hence, one needs ring multiplication!). Granted, in this case the actual spee-up comes from using special data types.

It is of course not ideal when one uses `RingElement` to implement elements of a module. However, we must not forget that `CombinatorialFreeModule` is applied in a wider range, not just to implement modules but also rings.

Alternatively, one could create two base classes for elements: One inherits from `ModuleElement`, the other from `RingElement`, and then the `CombinatorialFreeModule.Element` attribute is assigned during initialisation, according to whether the category is a sub-category of `Rings()` or not.



---

archive/issue_comments_264425.json:
```json
{
    "body": "<a id='comment:5'>Comment 5:</a>\nAnother question: What is the reason for having `CombinatorialFreeModule` in `sage.combinat`? Is it just since the author is a \"combinat guy\"? I actually never understood the adjective \"combinatorial\" in `CombinatorialFreeModule`---what is it, in contrast to just any `FreeModule`, and is there a compelling reason for not having it in `sage.modules`?",
    "created_at": "2015-06-21T21:53:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264425",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'>Comment 5:</a>
Another question: What is the reason for having `CombinatorialFreeModule` in `sage.combinat`? Is it just since the author is a "combinat guy"? I actually never understood the adjective "combinatorial" in `CombinatorialFreeModule`---what is it, in contrast to just any `FreeModule`, and is there a compelling reason for not having it in `sage.modules`?



---

archive/issue_comments_264426.json:
```json
{
    "body": "<a id='comment:6'>Comment 6:</a>\nReplying to [@simon-king-jena](#comment%3A4):\n> I was talking about cythoning the elements and the helper\n> functions.\n\nGood.\n\n> I plan to turn `CombinatorialFreeModule` into a Python class in a\n> cython file (i.e., keeping parent and element in one file), which\n> means that some generic code in the methods of\n> `CombinatorialFreeModule` would become faster. But the class would\n> NOT be cdef.\n\nPutting `CombinatorialFreeModule` in a Cython file would mean that we\ncould not use the Python debugger on it and that any change would\nrequire a recompilation. That's not necessarily a show stopper, but\nthis has to be weighted against the expected gains.\n\n> I have seen that people use `CombinatorialFreeModule` as a starting\n> points for implementing algebras. That's an abuse, since it works\n> around the existing infrastructure.\n\nIt's possible that the technical implementation of the multiplication\nby scalars is incorrect, and I'd be happy if you fixed that.\n\nBut CombinatorialFreeModule is -- by original design -- meant to be\nused to implement both modules and algebras. And it has been used\nintensively both ways. No abuse here.\n\n> - `ELement` uses `_acted_on_/_acted_upon_` to implement actions. It has no `_lmul_`, which means that the comment \"for backward compatibility\" fails entirely.\n> - `ModuleElement` provides the infrastructure for both general actions (inherited from `Element`) and a special path for scalar multiplication (`_lmul_/_rmul_`). Problem: You can not implement a ring multiplication when you just inherit from `ModuleElement`, since `ModuleElement.__mul__` raises an error if both arguments belong to the same parent.\n> - `RingElement` provides the infrastructure for general actions, scalar multiplication, and ring multiplication (via `_mul_`).\n\nYup, the single inheritance of Cython is a very strong constraint. It\npushes us to do crap.\n\n\nNow assume that we consider acceptable to inherit from `RingElement`\nfor non rings, why do we need `RingElement` in the first place? Could\nnot we just merge its features into `ModuleElement`?\n\n> Alternatively, one could create two base classes for elements: One inherits from `ModuleElement`, the other from `RingElement`, and then the `CombinatorialFreeModule.Element` attribute is assigned during initialisation, according to whether the category is a sub-category of `Rings()` or not.\n\nThis would make things complicated for subclasses of\n`CombinatorialModule` that have an Element class that inherits from\n`CombinatorialFreeModuleElement`.\n\nNow a question: what are the speed critical things that we really need\nto be Cythonized? If it's just the `__mul__` methods and friends, it\nwould be worth experimenting with replacing their Python\nimplementations in the Modules/Rings/Algebras categories by Cythonized\nmethods (with recent versions of Cython, this is possible). Maybe this\nwould be sufficient.\n\nCheers,\n                                Nicolas",
    "created_at": "2015-06-21T22:20:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264426",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'>Comment 6:</a>
Replying to [@simon-king-jena](#comment%3A4):
> I was talking about cythoning the elements and the helper
> functions.

Good.

> I plan to turn `CombinatorialFreeModule` into a Python class in a
> cython file (i.e., keeping parent and element in one file), which
> means that some generic code in the methods of
> `CombinatorialFreeModule` would become faster. But the class would
> NOT be cdef.

Putting `CombinatorialFreeModule` in a Cython file would mean that we
could not use the Python debugger on it and that any change would
require a recompilation. That's not necessarily a show stopper, but
this has to be weighted against the expected gains.

> I have seen that people use `CombinatorialFreeModule` as a starting
> points for implementing algebras. That's an abuse, since it works
> around the existing infrastructure.

It's possible that the technical implementation of the multiplication
by scalars is incorrect, and I'd be happy if you fixed that.

But CombinatorialFreeModule is -- by original design -- meant to be
used to implement both modules and algebras. And it has been used
intensively both ways. No abuse here.

> - `ELement` uses `_acted_on_/_acted_upon_` to implement actions. It has no `_lmul_`, which means that the comment "for backward compatibility" fails entirely.
> - `ModuleElement` provides the infrastructure for both general actions (inherited from `Element`) and a special path for scalar multiplication (`_lmul_/_rmul_`). Problem: You can not implement a ring multiplication when you just inherit from `ModuleElement`, since `ModuleElement.__mul__` raises an error if both arguments belong to the same parent.
> - `RingElement` provides the infrastructure for general actions, scalar multiplication, and ring multiplication (via `_mul_`).

Yup, the single inheritance of Cython is a very strong constraint. It
pushes us to do crap.


Now assume that we consider acceptable to inherit from `RingElement`
for non rings, why do we need `RingElement` in the first place? Could
not we just merge its features into `ModuleElement`?

> Alternatively, one could create two base classes for elements: One inherits from `ModuleElement`, the other from `RingElement`, and then the `CombinatorialFreeModule.Element` attribute is assigned during initialisation, according to whether the category is a sub-category of `Rings()` or not.

This would make things complicated for subclasses of
`CombinatorialModule` that have an Element class that inherits from
`CombinatorialFreeModuleElement`.

Now a question: what are the speed critical things that we really need
to be Cythonized? If it's just the `__mul__` methods and friends, it
would be worth experimenting with replacing their Python
implementations in the Modules/Rings/Algebras categories by Cythonized
methods (with recent versions of Cython, this is possible). Maybe this
would be sufficient.

Cheers,
                                Nicolas



---

archive/issue_comments_264427.json:
```json
{
    "body": "<a id='comment:7'>Comment 7:</a>\nReplying to [@simon-king-jena](#comment%3A5):\n> Another question: What is the reason for having `CombinatorialFreeModule` in `sage.combinat`? Is it just since the author is a \"combinat guy\"? I actually never understood the adjective \"combinatorial\" in `CombinatorialFreeModule`---what is it, in contrast to just any `FreeModule`, and is there a compelling reason for not having it in `sage.modules`?\n\nIt's just how Mike Hansen named it back in 2008. It definitely should be in `sage.modules` (typically in `sage.modules.with_basis`) and be called `FreeModule(QQ, I)`. See #10673.",
    "created_at": "2015-06-21T22:25:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264427",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:7'>Comment 7:</a>
Replying to [@simon-king-jena](#comment%3A5):
> Another question: What is the reason for having `CombinatorialFreeModule` in `sage.combinat`? Is it just since the author is a "combinat guy"? I actually never understood the adjective "combinatorial" in `CombinatorialFreeModule`---what is it, in contrast to just any `FreeModule`, and is there a compelling reason for not having it in `sage.modules`?

It's just how Mike Hansen named it back in 2008. It definitely should be in `sage.modules` (typically in `sage.modules.with_basis`) and be called `FreeModule(QQ, I)`. See #10673.



---

archive/issue_comments_264428.json:
```json
{
    "body": "<a id='comment:8'>Comment 8:</a>\nReplying to [@nthiery](#comment%3A6):\n> > - `ELement` uses `_acted_on_/_acted_upon_` to implement actions. It has no `_lmul_`, which means that the comment \"for backward compatibility\" fails entirely.\n> > - `ModuleElement` provides the infrastructure for both general actions (inherited from `Element`) and a special path for scalar multiplication (`_lmul_/_rmul_`). Problem: You can not implement a ring multiplication when you just inherit from `ModuleElement`, since `ModuleElement.__mul__` raises an error if both arguments belong to the same parent.\n> > - `RingElement` provides the infrastructure for general actions, scalar multiplication, and ring multiplication (via `_mul_`).\n\n> \n> Yup, the single inheritance of Cython is a very strong constraint. It\n> pushes us to do crap.\n\nPerhaps it would really be better to change `ModuleElement.__mul__`? The fact that it raises an error if both parents are equal is not good. It may haVe been motivated by an attempt to break an infinite recursion (namely: To test existence of an action, you would try to multiply elements, but to multiply elements, you need to know of there is an action). Perhaps that cycle should be broken in a different way?\n\n> This would make things complicated for subclasses of\n> `CombinatorialModule` that have an Element class that inherits from\n> `CombinatorialFreeModuleElement`.\n\nRight. In contrast to the category framework, where the element class of a super-category is mixed in, the `.Element` attribute of a super-class is not mixed in `:-/`. Perhaps this could be implemented? Perhaps the `.element_class` lazy attribute could also have a look at `super(self,type(self)).Element` or so?\n\n> Now a question: what are the speed critical things that we really need\n> to be Cythonized? If it's just the `__mul__` methods and friends, it\n> would be worth experimenting with replacing their Python\n> implementations in the Modules/Rings/Algebras categories by Cythonized\n> methods (with recent versions of Cython, this is possible). Maybe this\n> would be sufficient.\n\nIf I understand the general pattern: To implement an algebraic structure using `CombinatorialFreeModule`, one implements methods such as `product_on_basis` or `degree_on_basis`.\n\nI must admit that by searching the code for the past 30 minutes, I did not really succeed to find out at what place \"product_on_basis\" is actually turned into a `__mul__` method for `FreeModuleElement`s. But after searching 60 minutes, I found:\n\n- `Magmas().element_class` provides a `__mul__` method that mimics the `__mul__` method of ring elements. Fine, but Python.\n- `Magmas().parent_class.__init_extra__` assigns a `_mul_` method for the element class by setting it to `_mul_parent`\n- `_mul_parent` calls `self.parent().product`\n- `.product` calls `product_on_basis`.\n\nThese are many indirections---too many python calls for a single multiplication in high performance code, I'd say.\n\nOne detail: Apparently, setting `_mul_` to an attribute of the class results in slower access than what is possible when providing a method during **creation** of the class (such as `_mul_parent`):\n\n```\nsage: A = DiGraph({1:{2:['a']}, 2:{3:['b']}, 3:{1:['c'], 4:['m']}, 4:{5:['n']}, 5:{6:['x'],7:['y']}, 6:{7:['z']}}).path_semigroup().algebra\n(QQ)\nsage: A.inject_variables()\nDefining e_1, e_2, e_3, e_4, e_5, e_6, e_7, a, b, c, m, n, x, y, z\nsage: %timeit x.__mul__\nThe slowest run took 122.24 times longer than the fastest. This could mean that an intermediate result is being cached\n10000000 loops, best of 3: 50.7 ns per loop\nsage: %timeit x._mul_parent\nThe slowest run took 100.65 times longer than the fastest. This could mean that an intermediate result is being cached\n10000000 loops, best of 3: 61.6 ns per loop\nsage: %timeit x._mul_\nThe slowest run took 41.40 times longer than the fastest. This could mean that an intermediate result is being cached\n10000000 loops, best of 3: 121 ns per loop\n```\n\nHence, we would already gain a tiny bit by providing `_mul_` during creation of the element class, not afterwards.\n\nBy the way, why is all this in `Magmas()`? It uses \"product_on_basis\", hence, it uses the notion of a basis, which isn't defined for magmas, right? In fact, I first searched in `AlgebrasWithBasis` to find the definition of multiplication with `product_on_basis`.",
    "created_at": "2015-06-21T23:46:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264428",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'>Comment 8:</a>
Replying to [@nthiery](#comment%3A6):
> > - `ELement` uses `_acted_on_/_acted_upon_` to implement actions. It has no `_lmul_`, which means that the comment "for backward compatibility" fails entirely.
> > - `ModuleElement` provides the infrastructure for both general actions (inherited from `Element`) and a special path for scalar multiplication (`_lmul_/_rmul_`). Problem: You can not implement a ring multiplication when you just inherit from `ModuleElement`, since `ModuleElement.__mul__` raises an error if both arguments belong to the same parent.
> > - `RingElement` provides the infrastructure for general actions, scalar multiplication, and ring multiplication (via `_mul_`).

> 
> Yup, the single inheritance of Cython is a very strong constraint. It
> pushes us to do crap.

Perhaps it would really be better to change `ModuleElement.__mul__`? The fact that it raises an error if both parents are equal is not good. It may haVe been motivated by an attempt to break an infinite recursion (namely: To test existence of an action, you would try to multiply elements, but to multiply elements, you need to know of there is an action). Perhaps that cycle should be broken in a different way?

> This would make things complicated for subclasses of
> `CombinatorialModule` that have an Element class that inherits from
> `CombinatorialFreeModuleElement`.

Right. In contrast to the category framework, where the element class of a super-category is mixed in, the `.Element` attribute of a super-class is not mixed in `:-/`. Perhaps this could be implemented? Perhaps the `.element_class` lazy attribute could also have a look at `super(self,type(self)).Element` or so?

> Now a question: what are the speed critical things that we really need
> to be Cythonized? If it's just the `__mul__` methods and friends, it
> would be worth experimenting with replacing their Python
> implementations in the Modules/Rings/Algebras categories by Cythonized
> methods (with recent versions of Cython, this is possible). Maybe this
> would be sufficient.

If I understand the general pattern: To implement an algebraic structure using `CombinatorialFreeModule`, one implements methods such as `product_on_basis` or `degree_on_basis`.

I must admit that by searching the code for the past 30 minutes, I did not really succeed to find out at what place "product_on_basis" is actually turned into a `__mul__` method for `FreeModuleElement`s. But after searching 60 minutes, I found:

- `Magmas().element_class` provides a `__mul__` method that mimics the `__mul__` method of ring elements. Fine, but Python.
- `Magmas().parent_class.__init_extra__` assigns a `_mul_` method for the element class by setting it to `_mul_parent`
- `_mul_parent` calls `self.parent().product`
- `.product` calls `product_on_basis`.

These are many indirections---too many python calls for a single multiplication in high performance code, I'd say.

One detail: Apparently, setting `_mul_` to an attribute of the class results in slower access than what is possible when providing a method during **creation** of the class (such as `_mul_parent`):

```
sage: A = DiGraph({1:{2:['a']}, 2:{3:['b']}, 3:{1:['c'], 4:['m']}, 4:{5:['n']}, 5:{6:['x'],7:['y']}, 6:{7:['z']}}).path_semigroup().algebra
(QQ)
sage: A.inject_variables()
Defining e_1, e_2, e_3, e_4, e_5, e_6, e_7, a, b, c, m, n, x, y, z
sage: %timeit x.__mul__
The slowest run took 122.24 times longer than the fastest. This could mean that an intermediate result is being cached
10000000 loops, best of 3: 50.7 ns per loop
sage: %timeit x._mul_parent
The slowest run took 100.65 times longer than the fastest. This could mean that an intermediate result is being cached
10000000 loops, best of 3: 61.6 ns per loop
sage: %timeit x._mul_
The slowest run took 41.40 times longer than the fastest. This could mean that an intermediate result is being cached
10000000 loops, best of 3: 121 ns per loop
```

Hence, we would already gain a tiny bit by providing `_mul_` during creation of the element class, not afterwards.

By the way, why is all this in `Magmas()`? It uses "product_on_basis", hence, it uses the notion of a basis, which isn't defined for magmas, right? In fact, I first searched in `AlgebrasWithBasis` to find the definition of multiplication with `product_on_basis`.



---

archive/issue_comments_264429.json:
```json
{
    "body": "<a id='comment:9'>Comment 9:</a>\nSage provides the possibility to define arbitrary actions. See sage.structure.coerce_actions.\n\nAs much as I can see, the only action that currently can not be defined is an action of a parent on itself. I suggest to change it, as follows.\n\n- `RingElement.__mul__` should stay as it is. Since we have a ring element, we can assume that there is a multiplication among elements of the same parent, which is to be implemented with `_mul_`.\n- `ModuleElement.__mul__` currently does the following:\n\n  ```python\n    def __mul__(left, right):\n        if PyInt_CheckExact(right):\n            return (<ModuleElement>left)._mul_long(PyInt_AS_LONG(right))\n        if PyInt_CheckExact(left):\n            return (<ModuleElement>right)._mul_long(PyInt_AS_LONG(left))\n        if have_same_parent_c(left, right):\n            raise TypeError(arith_error_message(left, right, mul))\n        return coercion_model.bin_op(left, right, mul)\n  ```\n  Apparently, the line \"if have_same_parent_c...\" is to break a recursion. Instead, I suggest that `coercion_model.bin_op` should be changed, so that the parent has the possibility to define an action ON ITSELF (using `Parent._get_action_`).\n\nThe first point is that it would be easy to implement `_get_action_` as a parent method of a category:\n- The parent method could first test if it inherits an action (e.g. an `sage.structure.coerce_action.LeftModuleAction` in the case of a module), and if not then it should see if an action of the parent on itself may be implemented using product_on_basis and friends.\n\nThe second point is:\n- The action could be implemented in Cython, which is already the case for `sage.structure.coerce_action.LeftModuleAction`.\n\nThe third point is:\n- The approach is very flexible. `_get_action_` can return an action that relies on product_on_basis or that relies on `_mul_` or on `_lmul_` or on _my_fancy_multiplication_. Hence, there would be no need to override `_mul_` just to make things work. There are other paths to achieve the same aim.",
    "created_at": "2015-06-22T00:12:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264429",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'>Comment 9:</a>
Sage provides the possibility to define arbitrary actions. See sage.structure.coerce_actions.

As much as I can see, the only action that currently can not be defined is an action of a parent on itself. I suggest to change it, as follows.

- `RingElement.__mul__` should stay as it is. Since we have a ring element, we can assume that there is a multiplication among elements of the same parent, which is to be implemented with `_mul_`.
- `ModuleElement.__mul__` currently does the following:

  ```python
    def __mul__(left, right):
        if PyInt_CheckExact(right):
            return (<ModuleElement>left)._mul_long(PyInt_AS_LONG(right))
        if PyInt_CheckExact(left):
            return (<ModuleElement>right)._mul_long(PyInt_AS_LONG(left))
        if have_same_parent_c(left, right):
            raise TypeError(arith_error_message(left, right, mul))
        return coercion_model.bin_op(left, right, mul)
  ```
  Apparently, the line "if have_same_parent_c..." is to break a recursion. Instead, I suggest that `coercion_model.bin_op` should be changed, so that the parent has the possibility to define an action ON ITSELF (using `Parent._get_action_`).

The first point is that it would be easy to implement `_get_action_` as a parent method of a category:
- The parent method could first test if it inherits an action (e.g. an `sage.structure.coerce_action.LeftModuleAction` in the case of a module), and if not then it should see if an action of the parent on itself may be implemented using product_on_basis and friends.

The second point is:
- The action could be implemented in Cython, which is already the case for `sage.structure.coerce_action.LeftModuleAction`.

The third point is:
- The approach is very flexible. `_get_action_` can return an action that relies on product_on_basis or that relies on `_mul_` or on `_lmul_` or on _my_fancy_multiplication_. Hence, there would be no need to override `_mul_` just to make things work. There are other paths to achieve the same aim.



---

archive/issue_events_239702.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-22T00:20:48Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "title_is": "Use coerce actions in the category framework",
    "title_was": "Use cython and coercion for CombinatorialFreeModule",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239702"
}
```



---

archive/issue_comments_264430.json:
```json
{
    "body": "Changed keywords from **CombinatorialFreeModule, cython, coercion** to **cython, coercion, actions, categories**",
    "created_at": "2015-06-22T00:20:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264430",
    "user": "https://github.com/simon-king-jena"
}
```

Changed keywords from **CombinatorialFreeModule, cython, coercion** to **cython, coercion, actions, categories**



---

archive/issue_comments_264431.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,12 @@\n+The starting point of this ticket was:\n+\n `CombinatorialFreeModule`\n - is written in Python (hence, is too slow at least for my applications),\n - its elements just inherit from `Element` and not from a more appropriate base class (`ModuleElement` or even better `RingElement`, since the former for some reason raises an error on an inner multiplication), and\n - it is not conforming to Sage's coercion model, which really is bad, since I have seen many people who would start with `CombinatorialFreeModule` when implementing new algebraic stuff.\n \n-The aim of this ticket is to fix these issues.\n+Early in the discussion, it was found that using `RingElement` isn't really a solution. Instead, the aim of this ticket was broadened:\n+\n+- It should be possible to define a multiplication action of a parent on itself; this require changing `ModuleElement.__mul__`.\n+- Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.\n+- These actions can be implemented in Cython---while the categories stay in Python!\n``````\n",
    "created_at": "2015-06-22T00:20:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264431",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,12 @@
+The starting point of this ticket was:
+
 `CombinatorialFreeModule`
 - is written in Python (hence, is too slow at least for my applications),
 - its elements just inherit from `Element` and not from a more appropriate base class (`ModuleElement` or even better `RingElement`, since the former for some reason raises an error on an inner multiplication), and
 - it is not conforming to Sage's coercion model, which really is bad, since I have seen many people who would start with `CombinatorialFreeModule` when implementing new algebraic stuff.
 
-The aim of this ticket is to fix these issues.
+Early in the discussion, it was found that using `RingElement` isn't really a solution. Instead, the aim of this ticket was broadened:
+
+- It should be possible to define a multiplication action of a parent on itself; this require changing `ModuleElement.__mul__`.
+- Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.
+- These actions can be implemented in Cython---while the categories stay in Python!
``````




---

archive/issue_comments_264432.json:
```json
{
    "body": "<a id='comment:11'>Comment 11:</a>\nBased on the above discussion, I changed the aim of the ticket.",
    "created_at": "2015-06-22T00:21:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264432",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'>Comment 11:</a>
Based on the above discussion, I changed the aim of the ticket.



---

archive/issue_comments_264433.json:
```json
{
    "body": "Branch: **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion)**",
    "created_at": "2015-06-22T07:41:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264433",
    "user": "https://github.com/simon-king-jena"
}
```

Branch: **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion)**



---

archive/issue_events_239703.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-22T07:59:18Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20algebra",
    "label_color": "0000ff",
    "label_name": "component: algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239703"
}
```



---

archive/issue_events_239704.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-22T07:59:18Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20coercion",
    "label_color": "0000ff",
    "label_name": "component: coercion",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239704"
}
```



---

archive/issue_comments_264434.json:
```json
{
    "body": "<a id='comment:13'>Comment 13:</a>\nThe commit that I just pushed moves `CombinatorialFreeModule` to Cython and lets it use `RingElement` and `_l/rmul_` instead of the current approach to work around the coercion framework.\n\nNote that an action only depends on the parents involved and is cached. Hence, it is better faster to invoke the category framework to use the action to do a multiplication, than to let `__mul__` decide on the implementation of multiplication in each single instance. Hence, we should NOT do\n\n```python\nclass Modules:\n    class ElementMethods:\n        def __mul__(self, other):\n            if self.base_ring().has_coerce_map_from(parent(other)):\n                # Bad case-by-case behaviour\n                return self._mul_(other)\n            return coercion_model.bin_op(self, other, operator.mul)\n```\nand its counterpart in `Magmas.ElementMethods`. Instead, one should have a `ParentMethod` returning an action.\n\nHowever, my plan is to first sanitise the code of `[Ring/Module]Element`:\n1. A parent should be able to provide an action on ANY parent, including itself.\n2. The possibility to use any action should be implemented on the level of `Element.__mul__` (similarly `Element.__add__` etc).\n3. The only thing that `ModuleElement.__mul__` and `RingElement.__mul__` should contribute is a short-cut. That's basically what is already done: `ModuleElement.__mul__` treats python int in a special way, since I guess the typecheck involved is faster than calling the `coercion_model`; and `RingElement.__mul__` deals with the special case that the two elements have identical parents, which again is faster than calling the `coercion_model`.",
    "created_at": "2015-06-22T07:59:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264434",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'>Comment 13:</a>
The commit that I just pushed moves `CombinatorialFreeModule` to Cython and lets it use `RingElement` and `_l/rmul_` instead of the current approach to work around the coercion framework.

Note that an action only depends on the parents involved and is cached. Hence, it is better faster to invoke the category framework to use the action to do a multiplication, than to let `__mul__` decide on the implementation of multiplication in each single instance. Hence, we should NOT do

```python
class Modules:
    class ElementMethods:
        def __mul__(self, other):
            if self.base_ring().has_coerce_map_from(parent(other)):
                # Bad case-by-case behaviour
                return self._mul_(other)
            return coercion_model.bin_op(self, other, operator.mul)
```
and its counterpart in `Magmas.ElementMethods`. Instead, one should have a `ParentMethod` returning an action.

However, my plan is to first sanitise the code of `[Ring/Module]Element`:
1. A parent should be able to provide an action on ANY parent, including itself.
2. The possibility to use any action should be implemented on the level of `Element.__mul__` (similarly `Element.__add__` etc).
3. The only thing that `ModuleElement.__mul__` and `RingElement.__mul__` should contribute is a short-cut. That's basically what is already done: `ModuleElement.__mul__` treats python int in a special way, since I guess the typecheck involved is faster than calling the `coercion_model`; and `RingElement.__mul__` deals with the special case that the two elements have identical parents, which again is faster than calling the `coercion_model`.



---

archive/issue_comments_264435.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion)** to none",
    "created_at": "2015-06-22T07:59:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264435",
    "user": "https://github.com/simon-king-jena"
}
```

Changed branch from **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion)** to none



---

archive/issue_comments_264436.json:
```json
{
    "body": "<a id='comment:14'>Comment 14:</a>\nWTF?? Why has the branch been automatically deleted?",
    "created_at": "2015-06-22T08:00:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264436",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'>Comment 14:</a>
WTF?? Why has the branch been automatically deleted?



---

archive/issue_comments_264437.json:
```json
{
    "body": "Branch: **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion)**",
    "created_at": "2015-06-22T08:00:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264437",
    "user": "https://github.com/simon-king-jena"
}
```

Branch: **[u/SimonKing/combinatorial_free_module_cython_coercion](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/combinatorial_free_module_cython_coercion)**



---

archive/issue_comments_264438.json:
```json
{
    "body": "Commit: **[e1111c3](https://github.com/sagemath/sagetrac-mirror/commit/e1111c346a82639bb41161469754d45008117801)**",
    "created_at": "2015-06-22T08:00:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264438",
    "user": "https://github.com/simon-king-jena"
}
```

Commit: **[e1111c3](https://github.com/sagemath/sagetrac-mirror/commit/e1111c346a82639bb41161469754d45008117801)**



---

archive/issue_comments_264439.json:
```json
{
    "body": "<a id='comment:15'>Comment 15:</a>\nReplying to [@simon-king-jena](#comment%3A13):\n> The commit that I just pushed moves `CombinatorialFreeModule` to Cython and lets it use `RingElement` and `_l/rmul_` instead of the current approach to work around the coercion framework.\n\nTo be clear: The aim is to make it `ModuleElement`, not `RingElement`, after sanitising the `__mul__` methods in `sage.structure.element`.",
    "created_at": "2015-06-22T08:02:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264439",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'>Comment 15:</a>
Replying to [@simon-king-jena](#comment%3A13):
> The commit that I just pushed moves `CombinatorialFreeModule` to Cython and lets it use `RingElement` and `_l/rmul_` instead of the current approach to work around the coercion framework.

To be clear: The aim is to make it `ModuleElement`, not `RingElement`, after sanitising the `__mul__` methods in `sage.structure.element`.



---

archive/issue_comments_264440.json:
```json
{
    "body": "<a id='comment:16'>Comment 16:</a>\nI very much like the declarative approach.\n\nJust wondering:\n\n- Should there be two separate tickets: one for better support for coercions in categories, and the other for the Cythonizing of CFM (the two are relatively independent of each other)?\n\n- Since there is some file moving anyway, what about using the occasion to move the .pyx file directly in `sage.modules.with_basis.free_module` (with just a link `sage.combinat.free_module.CombinatorialFreeModule` -> `sage.modules.with_basis.free_module.FreeModule` for backward compatibility)?\n\nThanks!",
    "created_at": "2015-06-22T08:20:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264440",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:16'>Comment 16:</a>
I very much like the declarative approach.

Just wondering:

- Should there be two separate tickets: one for better support for coercions in categories, and the other for the Cythonizing of CFM (the two are relatively independent of each other)?

- Since there is some file moving anyway, what about using the occasion to move the .pyx file directly in `sage.modules.with_basis.free_module` (with just a link `sage.combinat.free_module.CombinatorialFreeModule` -> `sage.modules.with_basis.free_module.FreeModule` for backward compatibility)?

Thanks!



---

archive/issue_comments_264441.json:
```json
{
    "body": "<a id='comment:17'>Comment 17:</a>\nReplying to [@nthiery](#comment%3A6):\n> Yup, the single inheritance of Cython is a very strong constraint.\n\nJust a comment on this: one thing which is possible is inheriting from an extension type (a.k.a. `cdef class`) and a Python class, the result being a Python class. For example, in `src/sage/rings/number_field/number_field_ideal.py`, there is\n\n```\nclass NumberFieldFractionalIdeal(MultiplicativeGroupElement, NumberFieldIdeal):\n```\nwhere `MultiplicativeGroupElement` is an extension type and `NumberFieldIdeal` is a Python class (the extension type must be first in the MRO). Of course, you lose the advantage of a fast Cython `_mul_` call.\n\nI also agree with SimonKing that inheriting from `RingElement` is not really a problem and that the current design of having a huge number of `...Element` types might not have been the best design.",
    "created_at": "2015-06-22T08:59:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264441",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:17'>Comment 17:</a>
Replying to [@nthiery](#comment%3A6):
> Yup, the single inheritance of Cython is a very strong constraint.

Just a comment on this: one thing which is possible is inheriting from an extension type (a.k.a. `cdef class`) and a Python class, the result being a Python class. For example, in `src/sage/rings/number_field/number_field_ideal.py`, there is

```
class NumberFieldFractionalIdeal(MultiplicativeGroupElement, NumberFieldIdeal):
```
where `MultiplicativeGroupElement` is an extension type and `NumberFieldIdeal` is a Python class (the extension type must be first in the MRO). Of course, you lose the advantage of a fast Cython `_mul_` call.

I also agree with SimonKing that inheriting from `RingElement` is not really a problem and that the current design of having a huge number of `...Element` types might not have been the best design.



---

archive/issue_comments_264442.json:
```json
{
    "body": "<a id='comment:18'>Comment 18:</a>\nToday I had a discussion with Nicolas, and the plan now is to connect category and action framework more tightly.\n\nTo define an action of G on S, either `S._get_action_(G, op, self_on_left=...)` should return an action (which is not an action in the mathematical sense; it is just something that is callable on a pair of elements) or `G._get_action_(S,op,self_on_left=...)` should return something.\n\nIt would be good to make it easier for the category framework to override that method. But methods inherited from Parent have precedence over ParentMethods. Hence, `Parent._get_action_` (which just returns None) should be moved to `Sets.ParentMethods._get_action_`. Concrete parents can still override `_get_action_`, and sub-categories could override it as well.\n\nIn addition to that, `Magmas.ParentMethods.__init_extra__` could use `Parent.register_action` to register actions.\n\nHowever, all that would require that actions of a parent on ITSELF are possible. I guess technically they are possible. However, `ModuleElement.__mul__` would refuse to use them: It raises an error, if both elements have the same parents, which means that a ring structure can really only be implemented by either inheriting from Element and providing a custom `__mul__`, or by inheriting from RingElement.\n\nThe framework for \"actions on self\" should be provided on a new ticket.",
    "created_at": "2015-06-22T10:30:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264442",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'>Comment 18:</a>
Today I had a discussion with Nicolas, and the plan now is to connect category and action framework more tightly.

To define an action of G on S, either `S._get_action_(G, op, self_on_left=...)` should return an action (which is not an action in the mathematical sense; it is just something that is callable on a pair of elements) or `G._get_action_(S,op,self_on_left=...)` should return something.

It would be good to make it easier for the category framework to override that method. But methods inherited from Parent have precedence over ParentMethods. Hence, `Parent._get_action_` (which just returns None) should be moved to `Sets.ParentMethods._get_action_`. Concrete parents can still override `_get_action_`, and sub-categories could override it as well.

In addition to that, `Magmas.ParentMethods.__init_extra__` could use `Parent.register_action` to register actions.

However, all that would require that actions of a parent on ITSELF are possible. I guess technically they are possible. However, `ModuleElement.__mul__` would refuse to use them: It raises an error, if both elements have the same parents, which means that a ring structure can really only be implemented by either inheriting from Element and providing a custom `__mul__`, or by inheriting from RingElement.

The framework for "actions on self" should be provided on a new ticket.



---

archive/issue_comments_264443.json:
```json
{
    "body": "<a id='comment:19'>Comment 19:</a>\nSee #18758.\n\nNicolas, can you announce the new ticket on sage-combinat-devel? I really have to leave now...",
    "created_at": "2015-06-22T10:38:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264443",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'>Comment 19:</a>
See #18758.

Nicolas, can you announce the new ticket on sage-combinat-devel? I really have to leave now...



---

archive/issue_comments_264444.json:
```json
{
    "body": "<a id='comment:20'>Comment 20:</a>\nHello,\n\nI don't know if the following point is partially/not/completely related with this ticket. But you will be my heroes for three or four years if you solve that :\n\nMatrix and MatrixSpace over ALL rings (not using RingElement...) #15160\n\nsorry for the noise, to precise that, I would add a quote from an old topic from sage-devel : What we are unable to do right now ?\n\n********************************************\nHello,\n\nComputing the inverse of the identity matrix is not possible. Ok, it\nworks for rings using RingElement class for the elements (like ZZ, QQ,\nRR, CC, ...).\n\n    ```\n    sage: SF = SymmetricFunctions(QQ).schur(); SF\n    Symmetric Functions over Rational Field in the Schur basis\n    sage: one = SF.one()\n    sage: zero = SF.zero()\n    sage: M = Matrix([[one, zero], [zero, one]])\n    sage: M\n    [s[]   0]\n    [  0 s[]]\n    sage: M.det()\n    s[]\n    sage: M.is_invertible()\n    True\n    sage: M.inverse()\n    ...\n    AttributeError: 'SymmetricFunctionAlgebra_schur_with_category' object\n    has no attribute 'fraction_field'\n    sage: M = Matrix([[one]])\n    ...\n    AttributeError: 'tuple' object has no attribute 'parent'\n    sage: M*M\n    [s[]   0]\n    [  0 s[]]\n    sage: SteenrodAlgebra(7)\n    mod 7 Steenrod algebra, milnor basis\n    sage: A = SteenrodAlgebra(7)\n    sage: M = Matrix([[A.one(), A.zero()], [A.zero(), A.one()]])\n    sage: M^2\n    [1 0]\n    [0 1]\n    sage: M.inverse()\n    AttributeError: 'SteenrodAlgebra_generic_with_category' object has no\n    attribute 'fraction_field'\n    ```\n\nFor the curious, defining a fraction_field for these rings is not\nenought. The good fix should be more serious than that. \n********************************************\n\nFixing the scalar multiplication will perhaps fix linear algebra... Its works when I defined my own action of the coefficients on linear combination but It did break the rest of Sage (all parts of Sage using the RingElement class).\n\nCurrently I manage linear algebra on Combinatorial Free Modules just with horrible hacks.\n\nGood chance since It goes further than my current skills with Sage core features...",
    "created_at": "2015-06-22T11:47:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264444",
    "user": "https://github.com/sagetrac-nborie"
}
```

<a id='comment:20'>Comment 20:</a>
Hello,

I don't know if the following point is partially/not/completely related with this ticket. But you will be my heroes for three or four years if you solve that :

Matrix and MatrixSpace over ALL rings (not using RingElement...) #15160

sorry for the noise, to precise that, I would add a quote from an old topic from sage-devel : What we are unable to do right now ?

********************************************
Hello,

Computing the inverse of the identity matrix is not possible. Ok, it
works for rings using RingElement class for the elements (like ZZ, QQ,
RR, CC, ...).

    ```
    sage: SF = SymmetricFunctions(QQ).schur(); SF
    Symmetric Functions over Rational Field in the Schur basis
    sage: one = SF.one()
    sage: zero = SF.zero()
    sage: M = Matrix([[one, zero], [zero, one]])
    sage: M
    [s[]   0]
    [  0 s[]]
    sage: M.det()
    s[]
    sage: M.is_invertible()
    True
    sage: M.inverse()
    ...
    AttributeError: 'SymmetricFunctionAlgebra_schur_with_category' object
    has no attribute 'fraction_field'
    sage: M = Matrix([[one]])
    ...
    AttributeError: 'tuple' object has no attribute 'parent'
    sage: M*M
    [s[]   0]
    [  0 s[]]
    sage: SteenrodAlgebra(7)
    mod 7 Steenrod algebra, milnor basis
    sage: A = SteenrodAlgebra(7)
    sage: M = Matrix([[A.one(), A.zero()], [A.zero(), A.one()]])
    sage: M^2
    [1 0]
    [0 1]
    sage: M.inverse()
    AttributeError: 'SteenrodAlgebra_generic_with_category' object has no
    attribute 'fraction_field'
    ```

For the curious, defining a fraction_field for these rings is not
enought. The good fix should be more serious than that. 
********************************************

Fixing the scalar multiplication will perhaps fix linear algebra... Its works when I defined my own action of the coefficients on linear combination but It did break the rest of Sage (all parts of Sage using the RingElement class).

Currently I manage linear algebra on Combinatorial Free Modules just with horrible hacks.

Good chance since It goes further than my current skills with Sage core features...



---

archive/issue_comments_264445.json:
```json
{
    "body": "<a id='comment:21'>Comment 21:</a>\nThis also seems like it might solve #15947. Although perhaps we could use the idea that we can specify a class in the category that all elements of that category inherit from?\n\nHowever I'm not sure about the initial post about overriding `_acted_upon_` would break scalar multiplication. Couldn't we just require that the user makes a super call at the end if they still want the scalar multiplication (such as for `_get_action_` or `_coerce_map_from_`)? IMO, this would hardly an extraordinary requirement, and currently seems like a requirement for `_get_action_` in the current proposal.",
    "created_at": "2015-06-22T15:58:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264445",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:21'>Comment 21:</a>
This also seems like it might solve #15947. Although perhaps we could use the idea that we can specify a class in the category that all elements of that category inherit from?

However I'm not sure about the initial post about overriding `_acted_upon_` would break scalar multiplication. Couldn't we just require that the user makes a super call at the end if they still want the scalar multiplication (such as for `_get_action_` or `_coerce_map_from_`)? IMO, this would hardly an extraordinary requirement, and currently seems like a requirement for `_get_action_` in the current proposal.



---

archive/issue_comments_264446.json:
```json
{
    "body": "<a id='comment:22'>Comment 22:</a>\nI can confirm that in the mercurial patch attached to #15160 , I defined a `_get_action_` method for MatrixSpace that did break all Sage linear algebra using RingElement since it did break the scalar multiplication between vector and matrix. I do not think this very old patch still apply but the very ugly code can still be read from the trac. I did not keep the error messages, I just remember it did go very far from my knowledge about coercion and like...\n\nAnyway, with this old patch which break a large part of Sage, I did manage to invert bases change matrices of symmetric functions (matrix whose element live in a CombinatorialFreeModule).",
    "created_at": "2015-06-22T16:19:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264446",
    "user": "https://github.com/sagetrac-nborie"
}
```

<a id='comment:22'>Comment 22:</a>
I can confirm that in the mercurial patch attached to #15160 , I defined a `_get_action_` method for MatrixSpace that did break all Sage linear algebra using RingElement since it did break the scalar multiplication between vector and matrix. I do not think this very old patch still apply but the very ugly code can still be read from the trac. I did not keep the error messages, I just remember it did go very far from my knowledge about coercion and like...

Anyway, with this old patch which break a large part of Sage, I did manage to invert bases change matrices of symmetric functions (matrix whose element live in a CombinatorialFreeModule).



---

archive/issue_comments_264447.json:
```json
{
    "body": "<a id='comment:23'>Comment 23:</a>\nOn my way to the next conference, I thought that a \"minimally invasive\" approach would perhaps be best.\n\nBy that, I mean:\n\nI plan to NOT MOVE the current `_get_action_` method from sage.structure.parent to sage.categories. After all, it is a cpdef function, probably for a reason.\n\nConsequence of that approach is that the category framework will not be able to provide `_get_action_` as a method of the parents. I want to point out that this is actually an advantage.\n\nI plan to change `Parent.get_action` (without underscore), so that\n1. the output of `self._get_action_(...)` is taken into account; this agrees with the general idea that methods specially written for a parent have precedence over the categorical general nonsense. If it returns something not None, then it is used.\n2. if None was obtained in the first step, `super(Parent, self)._get_action_` is taken into account. THIS can be obtained from the category framework. If it returns something not None, then it is used.\n3. discover_action is called.\n\nOnly the second step is new. The advantages of my approach are:\n- The category framework CAN provide an action via `ParentMethods._get_action_`. So, it is not needed to learn something new. One simply does for ParentMethods what one has previously done for Parent.\n- It is conceivable that we have a parent P such that `P._get_action_(S, ...)` returns None for a specific parent S. but the category framework actually knows an action. In that situation, the category framework can provide that action, even though a method defined for the parent has precedence in the method resolution order over a method obtained from the category.\n- There is no need to change existing implementations of `_get_action_` (this is what I mean by \"minimally invasive\")\n\nLet's see if that works!",
    "created_at": "2015-06-22T20:25:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264447",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'>Comment 23:</a>
On my way to the next conference, I thought that a "minimally invasive" approach would perhaps be best.

By that, I mean:

I plan to NOT MOVE the current `_get_action_` method from sage.structure.parent to sage.categories. After all, it is a cpdef function, probably for a reason.

Consequence of that approach is that the category framework will not be able to provide `_get_action_` as a method of the parents. I want to point out that this is actually an advantage.

I plan to change `Parent.get_action` (without underscore), so that
1. the output of `self._get_action_(...)` is taken into account; this agrees with the general idea that methods specially written for a parent have precedence over the categorical general nonsense. If it returns something not None, then it is used.
2. if None was obtained in the first step, `super(Parent, self)._get_action_` is taken into account. THIS can be obtained from the category framework. If it returns something not None, then it is used.
3. discover_action is called.

Only the second step is new. The advantages of my approach are:
- The category framework CAN provide an action via `ParentMethods._get_action_`. So, it is not needed to learn something new. One simply does for ParentMethods what one has previously done for Parent.
- It is conceivable that we have a parent P such that `P._get_action_(S, ...)` returns None for a specific parent S. but the category framework actually knows an action. In that situation, the category framework can provide that action, even though a method defined for the parent has precedence in the method resolution order over a method obtained from the category.
- There is no need to change existing implementations of `_get_action_` (this is what I mean by "minimally invasive")

Let's see if that works!



---

archive/issue_comments_264448.json:
```json
{
    "body": "<a id='comment:24'>Comment 24:</a>\nPS: I think the above should be done first, and then comes #18758. In that order, since the ticket here will make it possible to define actions via the category framework, while #18758 would provide a nice application of that possibility.",
    "created_at": "2015-06-22T20:57:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264448",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'>Comment 24:</a>
PS: I think the above should be done first, and then comes #18758. In that order, since the ticket here will make it possible to define actions via the category framework, while #18758 would provide a nice application of that possibility.



---

archive/issue_comments_264449.json:
```json
{
    "body": "<a id='comment:25'>Comment 25:</a>\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6c3e7830a14a2467258faabce767367cfe4b4acc\">6c3e783</a></td><td><code>Allow definition of coerce actions via Category.ParentMethods</code></td></tr></table>\n",
    "created_at": "2015-06-23T00:59:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264449",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:25'>Comment 25:</a>
Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6c3e7830a14a2467258faabce767367cfe4b4acc">6c3e783</a></td><td><code>Allow definition of coerce actions via Category.ParentMethods</code></td></tr></table>




---

archive/issue_comments_264450.json:
```json
{
    "body": "Changed commit from **[e1111c3](https://github.com/sagemath/sagetrac-mirror/commit/e1111c346a82639bb41161469754d45008117801)** to **[6c3e783](https://github.com/sagemath/sagetrac-mirror/commit/6c3e7830a14a2467258faabce767367cfe4b4acc)**",
    "created_at": "2015-06-23T00:59:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264450",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[e1111c3](https://github.com/sagemath/sagetrac-mirror/commit/e1111c346a82639bb41161469754d45008117801)** to **[6c3e783](https://github.com/sagemath/sagetrac-mirror/commit/6c3e7830a14a2467258faabce767367cfe4b4acc)**



---

archive/issue_events_239705.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-23T01:01:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239705"
}
```



---

archive/issue_comments_264451.json:
```json
{
    "body": "<a id='comment:26'>Comment 26:</a>\nThe old branch on the cython version of CombinatorialFreeModule became obsolete. Hence, I force-pushed a new branch.\n\nIt allows to define actions via a ParentMethods `_get_action_`, which is also demonstrated by a new doctest. What do you think?",
    "created_at": "2015-06-23T01:01:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264451",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'>Comment 26:</a>
The old branch on the cython version of CombinatorialFreeModule became obsolete. Hence, I force-pushed a new branch.

It allows to define actions via a ParentMethods `_get_action_`, which is also demonstrated by a new doctest. What do you think?



---

archive/issue_comments_264452.json:
```json
{
    "body": "Author: **Simon King**",
    "created_at": "2015-06-23T01:01:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264452",
    "user": "https://github.com/simon-king-jena"
}
```

Author: **Simon King**



---

archive/issue_comments_264453.json:
```json
{
    "body": "Changed commit from **[6c3e783](https://github.com/sagemath/sagetrac-mirror/commit/6c3e7830a14a2467258faabce767367cfe4b4acc)** to **[dfba8b8](https://github.com/sagemath/sagetrac-mirror/commit/dfba8b8dfcaf23f76d4f62f575b862aba48b0be8)**",
    "created_at": "2015-06-23T01:19:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264453",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[6c3e783](https://github.com/sagemath/sagetrac-mirror/commit/6c3e7830a14a2467258faabce767367cfe4b4acc)** to **[dfba8b8](https://github.com/sagemath/sagetrac-mirror/commit/dfba8b8dfcaf23f76d4f62f575b862aba48b0be8)**



---

archive/issue_comments_264454.json:
```json
{
    "body": "<a id='comment:27'>Comment 27:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dfba8b8dfcaf23f76d4f62f575b862aba48b0be8\">dfba8b8</a></td><td><code>correcting a typo</code></td></tr></table>\n",
    "created_at": "2015-06-23T01:19:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264454",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:27'>Comment 27:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dfba8b8dfcaf23f76d4f62f575b862aba48b0be8">dfba8b8</a></td><td><code>correcting a typo</code></td></tr></table>




---

archive/issue_comments_264455.json:
```json
{
    "body": "<a id='comment:28'>Comment 28:</a>\n+1 to including category support for actions. So I'm happy with this patch modulo this change:\n\n```diff\n-        NOTE:\n-\n-        If a parent implements :meth:`_get_action_` then it has precedence\n-        over an implementation obtained from the category framework.\n-        However, if :meth:`_get_action_` returns None, then\n-        ``self.category().parent_class._get_action_`` has a chance to give\n-        a better answer.\n+        .. NOTE::\n+\n+            If a parent implements :meth:`_get_action_` then it has precedence\n+            over an implementation obtained from the category framework.\n+            However, if :meth:`_get_action_` returns ``None``, then\n+            ``self.category().parent_class._get_action_`` has a chance to give\n+            a better answer.\n```\n\nAlso +1 to cythonizing (key components of) `CombinatorialFreeModule(Element)`.",
    "created_at": "2015-06-23T05:19:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264455",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:28'>Comment 28:</a>
+1 to including category support for actions. So I'm happy with this patch modulo this change:

```diff
-        NOTE:
-
-        If a parent implements :meth:`_get_action_` then it has precedence
-        over an implementation obtained from the category framework.
-        However, if :meth:`_get_action_` returns None, then
-        ``self.category().parent_class._get_action_`` has a chance to give
-        a better answer.
+        .. NOTE::
+
+            If a parent implements :meth:`_get_action_` then it has precedence
+            over an implementation obtained from the category framework.
+            However, if :meth:`_get_action_` returns ``None``, then
+            ``self.category().parent_class._get_action_`` has a chance to give
+            a better answer.
```

Also +1 to cythonizing (key components of) `CombinatorialFreeModule(Element)`.



---

archive/issue_comments_264456.json:
```json
{
    "body": "Reviewer: **Travis Scrimshaw**",
    "created_at": "2015-06-23T05:19:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264456",
    "user": "https://github.com/tscrim"
}
```

Reviewer: **Travis Scrimshaw**



---

archive/issue_comments_264457.json:
```json
{
    "body": "<a id='comment:29'>Comment 29:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c\">fe7226d</a></td><td><code>Use proper format for a NOTE section</code></td></tr></table>\n",
    "created_at": "2015-06-23T07:41:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264457",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:29'>Comment 29:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c">fe7226d</a></td><td><code>Use proper format for a NOTE section</code></td></tr></table>




---

archive/issue_comments_264458.json:
```json
{
    "body": "Changed commit from **[dfba8b8](https://github.com/sagemath/sagetrac-mirror/commit/dfba8b8dfcaf23f76d4f62f575b862aba48b0be8)** to **[fe7226d](https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c)**",
    "created_at": "2015-06-23T07:41:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264458",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[dfba8b8](https://github.com/sagemath/sagetrac-mirror/commit/dfba8b8dfcaf23f76d4f62f575b862aba48b0be8)** to **[fe7226d](https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c)**



---

archive/issue_comments_264459.json:
```json
{
    "body": "<a id='comment:30'>Comment 30:</a>\nReplying to [@tscrim](#comment%3A28):\n> +1 to including category support for actions. So I'm happy with this patch modulo this change:\n\nDone.\n\n> Also +1 to cythonizing (key components of) `CombinatorialFreeModule(Element)`.\n\nThat has been the original purpose of the ticket. Shall we do that here or on a different ticket?\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c\">fe7226d</a></td><td><code>Use proper format for a NOTE section</code></td></tr></table>\n",
    "created_at": "2015-06-23T07:42:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264459",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:30'>Comment 30:</a>
Replying to [@tscrim](#comment%3A28):
> +1 to including category support for actions. So I'm happy with this patch modulo this change:

Done.

> Also +1 to cythonizing (key components of) `CombinatorialFreeModule(Element)`.

That has been the original purpose of the ticket. Shall we do that here or on a different ticket?

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c">fe7226d</a></td><td><code>Use proper format for a NOTE section</code></td></tr></table>




---

archive/issue_comments_264460.json:
```json
{
    "body": "<a id='comment:31'>Comment 31:</a>\nHi Simon!\n\nReplying to [@simon-king-jena](#comment%3A23):\n> On my way to the next conference, I thought that a \"minimally invasive\" approach would perhaps be best.\n> \n> By that, I mean:\n> \n> I plan to NOT MOVE the current `_get_action_` method from sage.structure.parent to sage.categories. After all, it is a cpdef function, probably for a reason.\n> \n> Consequence of that approach is that the category framework will not be able to provide `_get_action_` as a method of the parents. I want to point out that this is actually an advantage.\n> \n> I plan to change `Parent.get_action` (without underscore), so that\n> 1. the output of `self._get_action_(...)` is taken into account; this agrees with the general idea that methods specially written for a parent have precedence over the categorical general nonsense. If it returns something not None, then it is used.\n> 2. if None was obtained in the first step, `super(Parent, self)._get_action_` is taken into account. THIS can be obtained from the category framework. If it returns something not None, then it is used.\n> 3. discover_action is called.\n> \n> Only the second step is new. The advantages of my approach are:\n> - The category framework CAN provide an action via `ParentMethods._get_action_`. So, it is not needed to learn something new. One simply does for ParentMethods what one has previously done for Parent.\n> - It is conceivable that we have a parent P such that `P._get_action_(S, ...)` returns None for a specific parent S. but the category framework actually knows an action. In that situation, the category framework can provide that action, even though a method defined for the parent has precedence in the method resolution order over a method obtained from the category.\n> - There is no need to change existing implementations of `_get_action_` (this is what I mean by \"minimally invasive\")\n> \n> Let's see if that works!\n\nThanks for investigating!\n\nI definitely see the point of having a protocol allowing for a\n`_get_action_` method to state in certain cases \"oh, never mind; I\nactually have nothing to say in this case, just do the usual stuff\nfrom super\".\n\nHowever the above implementation is not uniform: we could imagine use\ncases where a category may want to implement such a `_get_action_`\nthat occasionally returns `None`.  Or a class `B` inheriting from `A`\nitself inheriting from `Parent`, where `B._get_action_` may want to\nreturn `None` to specify: use `A._get_action_`.\n\nSo, to weight the pros and cons my questions are:\n\n- How invasive would it really be to move `Parent._get_action_` to\n  `Sets.ParentMethods`? Does it actually requires to update anything\n  else in the Sage code?\n\n- super calls would be the natural thing to do here. Alas super and\n  categories don't work so well together. Still, could we find a\n  reasonable enough syntax for this that we could advertise in the\n  documentation of `_get_action_`.\n\n- Shall we investigate for a more uniform protocol where `get_action`\n  would try each `_get_action_` method along the MRO until one returns\n  something else than `None`?\n\nCheers,\n                     Nicolas",
    "created_at": "2015-06-23T10:00:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264460",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:31'>Comment 31:</a>
Hi Simon!

Replying to [@simon-king-jena](#comment%3A23):
> On my way to the next conference, I thought that a "minimally invasive" approach would perhaps be best.
> 
> By that, I mean:
> 
> I plan to NOT MOVE the current `_get_action_` method from sage.structure.parent to sage.categories. After all, it is a cpdef function, probably for a reason.
> 
> Consequence of that approach is that the category framework will not be able to provide `_get_action_` as a method of the parents. I want to point out that this is actually an advantage.
> 
> I plan to change `Parent.get_action` (without underscore), so that
> 1. the output of `self._get_action_(...)` is taken into account; this agrees with the general idea that methods specially written for a parent have precedence over the categorical general nonsense. If it returns something not None, then it is used.
> 2. if None was obtained in the first step, `super(Parent, self)._get_action_` is taken into account. THIS can be obtained from the category framework. If it returns something not None, then it is used.
> 3. discover_action is called.
> 
> Only the second step is new. The advantages of my approach are:
> - The category framework CAN provide an action via `ParentMethods._get_action_`. So, it is not needed to learn something new. One simply does for ParentMethods what one has previously done for Parent.
> - It is conceivable that we have a parent P such that `P._get_action_(S, ...)` returns None for a specific parent S. but the category framework actually knows an action. In that situation, the category framework can provide that action, even though a method defined for the parent has precedence in the method resolution order over a method obtained from the category.
> - There is no need to change existing implementations of `_get_action_` (this is what I mean by "minimally invasive")
> 
> Let's see if that works!

Thanks for investigating!

I definitely see the point of having a protocol allowing for a
`_get_action_` method to state in certain cases "oh, never mind; I
actually have nothing to say in this case, just do the usual stuff
from super".

However the above implementation is not uniform: we could imagine use
cases where a category may want to implement such a `_get_action_`
that occasionally returns `None`.  Or a class `B` inheriting from `A`
itself inheriting from `Parent`, where `B._get_action_` may want to
return `None` to specify: use `A._get_action_`.

So, to weight the pros and cons my questions are:

- How invasive would it really be to move `Parent._get_action_` to
  `Sets.ParentMethods`? Does it actually requires to update anything
  else in the Sage code?

- super calls would be the natural thing to do here. Alas super and
  categories don't work so well together. Still, could we find a
  reasonable enough syntax for this that we could advertise in the
  documentation of `_get_action_`.

- Shall we investigate for a more uniform protocol where `get_action`
  would try each `_get_action_` method along the MRO until one returns
  something else than `None`?

Cheers,
                     Nicolas



---

archive/issue_comments_264461.json:
```json
{
    "body": "<a id='comment:32'>Comment 32:</a>\nReplying to [@nthiery](#comment%3A31):\n> However the above implementation is not uniform: we could imagine use\n> cases where a category may want to implement such a `_get_action_`\n> that occasionally returns `None`.  Or a class `B` inheriting from `A`\n> itself inheriting from `Parent`, where `B._get_action_` may want to\n> return `None` to specify: use `A._get_action_`.\n\nOK. But in the past, it has *never* been implemented to do this automatically. It has never been the case that `Parent.get_action` went up the MRO to test several `._get_action_` outputs until one of them returns something interesting.\n\n> So, to weight the pros and cons my questions are:\n> \n> - How invasive would it really be to move `Parent._get_action_` to\n>   `Sets.ParentMethods`? Does it actually requires to update anything\n>   else in the Sage code?\n\nYes. Everything that uses it in its cpdef form.\n\n> - super calls would be the natural thing to do here. Alas super and\n>   categories don't work so well together. Still, could we find a\n>   reasonable enough syntax for this that we could advertise in the\n>   documentation of `_get_action_`.\n\nWhy \"syntax\"? If we would really want to go up the MRO/category hierarchy, then we could in principle do so in `Parent.get_action`. I just don't know if that makes much sense, but assume we have\n\n```\nclass MyFirstParent(Parent):\n    def _get_action_(self, S,...):\n        return something when S is a ring\nclass MySecondParent(MyFirstParent):\n    def _get_action_(self, S,...):\n        return something when S is a field\n```\n\nWe COULD make it so that `MySecondParent().get_action(S)` would automatically first test the output of `MySecondParent._get_action_` and then on `MyFirstParent._get_action_` --- there would be no special syntax involved.\n\nI only wonder if we WANT that to happen automatically.\n\n> - Shall we investigate for a more uniform protocol where `get_action`\n>   would try each `_get_action_` method along the MRO until one returns\n>   something else than `None`?\n\nI am not so sure. But it would be easy to implement (as I have explained above).",
    "created_at": "2015-06-23T12:54:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264461",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:32'>Comment 32:</a>
Replying to [@nthiery](#comment%3A31):
> However the above implementation is not uniform: we could imagine use
> cases where a category may want to implement such a `_get_action_`
> that occasionally returns `None`.  Or a class `B` inheriting from `A`
> itself inheriting from `Parent`, where `B._get_action_` may want to
> return `None` to specify: use `A._get_action_`.

OK. But in the past, it has *never* been implemented to do this automatically. It has never been the case that `Parent.get_action` went up the MRO to test several `._get_action_` outputs until one of them returns something interesting.

> So, to weight the pros and cons my questions are:
> 
> - How invasive would it really be to move `Parent._get_action_` to
>   `Sets.ParentMethods`? Does it actually requires to update anything
>   else in the Sage code?

Yes. Everything that uses it in its cpdef form.

> - super calls would be the natural thing to do here. Alas super and
>   categories don't work so well together. Still, could we find a
>   reasonable enough syntax for this that we could advertise in the
>   documentation of `_get_action_`.

Why "syntax"? If we would really want to go up the MRO/category hierarchy, then we could in principle do so in `Parent.get_action`. I just don't know if that makes much sense, but assume we have

```
class MyFirstParent(Parent):
    def _get_action_(self, S,...):
        return something when S is a ring
class MySecondParent(MyFirstParent):
    def _get_action_(self, S,...):
        return something when S is a field
```

We COULD make it so that `MySecondParent().get_action(S)` would automatically first test the output of `MySecondParent._get_action_` and then on `MyFirstParent._get_action_` --- there would be no special syntax involved.

I only wonder if we WANT that to happen automatically.

> - Shall we investigate for a more uniform protocol where `get_action`
>   would try each `_get_action_` method along the MRO until one returns
>   something else than `None`?

I am not so sure. But it would be easy to implement (as I have explained above).



---

archive/issue_comments_264462.json:
```json
{
    "body": "<a id='comment:33'>Comment 33:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c855ebce6eabb7e0189a585ed1849a68ba98f041\">c855ebc</a></td><td><code>Detect definition of actions along MRO and category hierarchy</code></td></tr></table>\n",
    "created_at": "2015-06-23T13:36:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264462",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:33'>Comment 33:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c855ebce6eabb7e0189a585ed1849a68ba98f041">c855ebc</a></td><td><code>Detect definition of actions along MRO and category hierarchy</code></td></tr></table>




---

archive/issue_comments_264463.json:
```json
{
    "body": "Changed commit from **[fe7226d](https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c)** to **[c855ebc](https://github.com/sagemath/sagetrac-mirror/commit/c855ebce6eabb7e0189a585ed1849a68ba98f041)**",
    "created_at": "2015-06-23T13:36:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264463",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[fe7226d](https://github.com/sagemath/sagetrac-mirror/commit/fe7226d9e28d1dbf4130e8b57fb09885bd76226c)** to **[c855ebc](https://github.com/sagemath/sagetrac-mirror/commit/c855ebce6eabb7e0189a585ed1849a68ba98f041)**



---

archive/issue_comments_264464.json:
```json
{
    "body": "<a id='comment:34'>Comment 34:</a>\nThe new commit implements what I have proposed above. I am not convinced whether it is a good thing to have. Walking along the class AND the category hierarchy can be costly, I suppose, although it will happen only once for each S (the result is cached).",
    "created_at": "2015-06-23T13:38:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264464",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'>Comment 34:</a>
The new commit implements what I have proposed above. I am not convinced whether it is a good thing to have. Walking along the class AND the category hierarchy can be costly, I suppose, although it will happen only once for each S (the result is cached).



---

archive/issue_comments_264465.json:
```json
{
    "body": "<a id='comment:35'>Comment 35:</a>\nI don't necessarily like walking along the MRO as there might be times when we don't want to walk up (relatively expensive tests).",
    "created_at": "2015-06-23T16:47:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264465",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:35'>Comment 35:</a>
I don't necessarily like walking along the MRO as there might be times when we don't want to walk up (relatively expensive tests).



---

archive/issue_comments_264466.json:
```json
{
    "body": "<a id='comment:36'>Comment 36:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/42cb88a3b55547931ec037a44fec5857f8f5e58f\">42cb88a</a></td><td><code>Fixing another typo</code></td></tr></table>\n",
    "created_at": "2015-06-23T18:33:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264466",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:36'>Comment 36:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/42cb88a3b55547931ec037a44fec5857f8f5e58f">42cb88a</a></td><td><code>Fixing another typo</code></td></tr></table>




---

archive/issue_comments_264467.json:
```json
{
    "body": "Changed commit from **[c855ebc](https://github.com/sagemath/sagetrac-mirror/commit/c855ebce6eabb7e0189a585ed1849a68ba98f041)** to **[42cb88a](https://github.com/sagemath/sagetrac-mirror/commit/42cb88a3b55547931ec037a44fec5857f8f5e58f)**",
    "created_at": "2015-06-23T18:33:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264467",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[c855ebc](https://github.com/sagemath/sagetrac-mirror/commit/c855ebce6eabb7e0189a585ed1849a68ba98f041)** to **[42cb88a](https://github.com/sagemath/sagetrac-mirror/commit/42cb88a3b55547931ec037a44fec5857f8f5e58f)**



---

archive/issue_comments_264468.json:
```json
{
    "body": "<a id='comment:37'>Comment 37:</a>\nReplying to [@tscrim](#comment%3A35):\n> I don't necessarily like walking along the MRO as there might be times when we don't want to walk up (relatively expensive tests).\n\nI agree. I do believe that having two sources for `_get_action_` (the parent and the category parent class) is a good thing. But I am less convinced about commit c855ebc.",
    "created_at": "2015-06-23T18:36:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264468",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:37'>Comment 37:</a>
Replying to [@tscrim](#comment%3A35):
> I don't necessarily like walking along the MRO as there might be times when we don't want to walk up (relatively expensive tests).

I agree. I do believe that having two sources for `_get_action_` (the parent and the category parent class) is a good thing. But I am less convinced about commit c855ebc.



---

archive/issue_events_239706.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-26T07:51:48Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239706"
}
```



---

archive/issue_events_239707.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-26T07:51:48Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239707"
}
```



---

archive/issue_comments_264469.json:
```json
{
    "body": "<a id='comment:38'>Comment 38:</a>\nThere is a trivial doctest error that needs to be fixed.\n\nOther than that, it seems that somewhere in `sage.modular`, a Q-vector space is created whose class is an instance of `Modules.parent_class` but not of `VectorSpaces.parent_class`. That's what is creating problems in #18758. I need to find out where that is happening.",
    "created_at": "2015-06-26T07:51:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264469",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'>Comment 38:</a>
There is a trivial doctest error that needs to be fixed.

Other than that, it seems that somewhere in `sage.modular`, a Q-vector space is created whose class is an instance of `Modules.parent_class` but not of `VectorSpaces.parent_class`. That's what is creating problems in #18758. I need to find out where that is happening.



---

archive/issue_comments_264470.json:
```json
{
    "body": "Changed commit from **[42cb88a](https://github.com/sagemath/sagetrac-mirror/commit/42cb88a3b55547931ec037a44fec5857f8f5e58f)** to **[a5bdbf6](https://github.com/sagemath/sagetrac-mirror/commit/a5bdbf6f85ea0d732a13ebc7d8e91dbd28c92ef0)**",
    "created_at": "2015-06-26T10:37:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264470",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[42cb88a](https://github.com/sagemath/sagetrac-mirror/commit/42cb88a3b55547931ec037a44fec5857f8f5e58f)** to **[a5bdbf6](https://github.com/sagemath/sagetrac-mirror/commit/a5bdbf6f85ea0d732a13ebc7d8e91dbd28c92ef0)**



---

archive/issue_comments_264471.json:
```json
{
    "body": "<a id='comment:39'>Comment 39:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a5bdbf6f85ea0d732a13ebc7d8e91dbd28c92ef0\">a5bdbf6</a></td><td><code>Fix a doctest</code></td></tr></table>\n",
    "created_at": "2015-06-26T10:37:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264471",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:39'>Comment 39:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a5bdbf6f85ea0d732a13ebc7d8e91dbd28c92ef0">a5bdbf6</a></td><td><code>Fix a doctest</code></td></tr></table>




---

archive/issue_comments_264472.json:
```json
{
    "body": "<a id='comment:40'>Comment 40:</a>\nMeanwhile I think it is essential to ascend the MRO resp. the category hierarchy.\n\nRationale: The plan for #18758 is to let `Magmas().parent_class` provide a `_get_action_` method returning a multiplicative action of self on self, while `AdditiveMagmas().parent_class._get_action_` yields an additive action of self on self. Hence, in order to get a ring structure, it is essential that `Parent.get_action` has access to both categorical `_get_action_` methods.\n\nTo be fixed (here or in #18758?) is the issue with wrongly initialised parents. By this, I mean `isinstance(P, C.parent_class) and not isinstance(P, P.category().parent_class)` for a proper super-category C of `P.category()`.\n\nOne could easily work around, but this would involve a little slow-down. So, better fix the issue rather than working around!",
    "created_at": "2015-06-26T13:19:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264472",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:40'>Comment 40:</a>
Meanwhile I think it is essential to ascend the MRO resp. the category hierarchy.

Rationale: The plan for #18758 is to let `Magmas().parent_class` provide a `_get_action_` method returning a multiplicative action of self on self, while `AdditiveMagmas().parent_class._get_action_` yields an additive action of self on self. Hence, in order to get a ring structure, it is essential that `Parent.get_action` has access to both categorical `_get_action_` methods.

To be fixed (here or in #18758?) is the issue with wrongly initialised parents. By this, I mean `isinstance(P, C.parent_class) and not isinstance(P, P.category().parent_class)` for a proper super-category C of `P.category()`.

One could easily work around, but this would involve a little slow-down. So, better fix the issue rather than working around!



---

archive/issue_comments_264473.json:
```json
{
    "body": "<a id='comment:41'>Comment 41:</a>\nGot it: `FormalSums(ZZ).base_extend(GF(7))` returns a wrongly initialised parent.",
    "created_at": "2015-06-26T14:33:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264473",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:41'>Comment 41:</a>
Got it: `FormalSums(ZZ).base_extend(GF(7))` returns a wrongly initialised parent.



---

archive/issue_comments_264474.json:
```json
{
    "body": "Dependencies: **#18795**",
    "created_at": "2015-06-26T14:39:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264474",
    "user": "https://github.com/simon-king-jena"
}
```

Dependencies: **#18795**



---

archive/issue_comments_264475.json:
```json
{
    "body": "<a id='comment:43'>Comment 43:</a>\nI believe this is ready for review now. The dependency #18795 is ready, too, but isn't merged here, which I believe is the correct thing to do, or should I merge it?\n\nConcerning the question on whether or not we should go up the mro and the categories: I think it makes sense to do it. Different algebraic structure / categories have different stories to tell about different actions. Hence, either it is requested to explicitly call \"`super(...)._get_action_`\" resp. hardcode all specific situations when implementing `_get_action_`, or we do the super call automatically.\nAnd I believe automatically is the more stable solution.\n\nThere remains the question if it slows down one or another computation. Do you have ideas for suitable benchmarks? They would involve lots of *different* parents engaged in actions, since `Parent.get_action` is cached and thus won't slow down when repeatedly requesting an action for always the same parents.",
    "created_at": "2015-06-26T16:51:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264475",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:43'>Comment 43:</a>
I believe this is ready for review now. The dependency #18795 is ready, too, but isn't merged here, which I believe is the correct thing to do, or should I merge it?

Concerning the question on whether or not we should go up the mro and the categories: I think it makes sense to do it. Different algebraic structure / categories have different stories to tell about different actions. Hence, either it is requested to explicitly call "`super(...)._get_action_`" resp. hardcode all specific situations when implementing `_get_action_`, or we do the super call automatically.
And I believe automatically is the more stable solution.

There remains the question if it slows down one or another computation. Do you have ideas for suitable benchmarks? They would involve lots of *different* parents engaged in actions, since `Parent.get_action` is cached and thus won't slow down when repeatedly requesting an action for always the same parents.



---

archive/issue_events_239708.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-26T16:51:21Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239708"
}
```



---

archive/issue_events_239709.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-06-26T16:51:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239709"
}
```



---

archive/issue_comments_264476.json:
```json
{
    "body": "<a id='comment:44'>Comment 44:</a>\n<the previous text was posted on the wrong ticket>",
    "created_at": "2015-06-26T22:02:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264476",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:44'>Comment 44:</a>
<the previous text was posted on the wrong ticket>



---

archive/issue_comments_264477.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -10,3 +10,8 @@\n - It should be possible to define a multiplication action of a parent on itself; this require changing `ModuleElement.__mul__`.\n - Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.\n - These actions can be implemented in Cython---while the categories stay in Python!\n+\n+As a consequence (and that's the real aim of the ticket)\n+- multiplication can still be defined by category initialisation in `Magmas()`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.\n+- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines `_mul_` and initialises in `Magmas()`. Overriding `__mul__` (which in some situations was still needed) should in future be even more useless.\n+- Similar statements hold for `_add_`.\n``````\n",
    "created_at": "2015-06-26T22:07:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264477",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -10,3 +10,8 @@
 - It should be possible to define a multiplication action of a parent on itself; this require changing `ModuleElement.__mul__`.
 - Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.
 - These actions can be implemented in Cython---while the categories stay in Python!
+
+As a consequence (and that's the real aim of the ticket)
+- multiplication can still be defined by category initialisation in `Magmas()`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.
+- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines `_mul_` and initialises in `Magmas()`. Overriding `__mul__` (which in some situations was still needed) should in future be even more useless.
+- Similar statements hold for `_add_`.
``````




---

archive/issue_comments_264478.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -11,7 +11,3 @@\n - Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.\n - These actions can be implemented in Cython---while the categories stay in Python!\n \n-As a consequence (and that's the real aim of the ticket)\n-- multiplication can still be defined by category initialisation in `Magmas()`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.\n-- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines `_mul_` and initialises in `Magmas()`. Overriding `__mul__` (which in some situations was still needed) should in future be even more useless.\n-- Similar statements hold for `_add_`.\n``````\n",
    "created_at": "2015-06-26T22:09:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264478",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -11,7 +11,3 @@
 - Instead of overriding `__mul__` and `_mul_` for element classes, the category framework should instead return `sage.structure.coerce_actions....` to provide multiplication.
 - These actions can be implemented in Cython---while the categories stay in Python!
 
-As a consequence (and that's the real aim of the ticket)
-- multiplication can still be defined by category initialisation in `Magmas()`. However, it should become faster and it should in future be easier to import the multiplication from a fast cython module.
-- The way to define an internal multiplication should be more uniform throughout Sage: One simply defines `_mul_` and initialises in `Magmas()`. Overriding `__mul__` (which in some situations was still needed) should in future be even more useless.
-- Similar statements hold for `_add_`.
``````




---

archive/issue_comments_264479.json:
```json
{
    "body": "<a id='comment:46'>Comment 46:</a>\nArgh! I was posting on the wrong ticket. What I wrote should go to #18758...",
    "created_at": "2015-06-26T22:09:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264479",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:46'>Comment 46:</a>
Argh! I was posting on the wrong ticket. What I wrote should go to #18758...



---

archive/issue_comments_264480.json:
```json
{
    "body": "Changed dependencies from **#18795** to none",
    "created_at": "2015-11-23T10:56:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264480",
    "user": "https://github.com/jdemeyer"
}
```

Changed dependencies from **#18795** to none



---

archive/issue_events_239710.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-11-23T10:56:10Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "milestone_number": null,
    "milestone_title": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239710"
}
```



---

archive/issue_events_239711.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-11-23T10:56:10Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "milestone_number": null,
    "milestone_title": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239711"
}
```



---

archive/issue_comments_264481.json:
```json
{
    "body": "<a id='comment:48'>Comment 48:</a>\nIt is hard for me to understand what this ticket is really about and how #20767 would affect it.",
    "created_at": "2016-08-09T07:39:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264481",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:48'>Comment 48:</a>
It is hard for me to understand what this ticket is really about and how #20767 would affect it.



---

archive/issue_events_239712.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2016-09-14T09:42:10Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239712"
}
```



---

archive/issue_events_239713.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2016-09-14T09:42:10Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/18756#event-239713"
}
```



---

archive/issue_comments_264482.json:
```json
{
    "body": "<a id='comment:49'>Comment 49:</a>\nDoes not build anymore due to #20686.",
    "created_at": "2016-09-14T09:42:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264482",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:49'>Comment 49:</a>
Does not build anymore due to #20686.



---

archive/issue_comments_264483.json:
```json
{
    "body": "<a id='comment:50'>Comment 50:</a>\nReplying to [@simon-king-jena](#comment%3A40):\n> Meanwhile I think it is essential to ascend the MRO resp. the category hierarchy.\n> \n> Rationale: The plan for #18758 is to let `Magmas().parent_class` provide a `_get_action_` method returning a multiplicative action of self on self, while `AdditiveMagmas().parent_class._get_action_` yields an additive action of self on self. Hence, in order to get a ring structure, it is essential that `Parent.get_action` has access to both categorical `_get_action_` methods.\n\nI don't quite get why you need to manually play with the MRO. Why not use `super()` calls in the `_get_action_` implementations (instead of returning `None`) for that?",
    "created_at": "2016-09-14T09:55:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264483",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:50'>Comment 50:</a>
Replying to [@simon-king-jena](#comment%3A40):
> Meanwhile I think it is essential to ascend the MRO resp. the category hierarchy.
> 
> Rationale: The plan for #18758 is to let `Magmas().parent_class` provide a `_get_action_` method returning a multiplicative action of self on self, while `AdditiveMagmas().parent_class._get_action_` yields an additive action of self on self. Hence, in order to get a ring structure, it is essential that `Parent.get_action` has access to both categorical `_get_action_` methods.

I don't quite get why you need to manually play with the MRO. Why not use `super()` calls in the `_get_action_` implementations (instead of returning `None`) for that?



---

archive/issue_comments_264484.json:
```json
{
    "body": "<a id='comment:51'>Comment 51:</a>\nIn the meantime, a lot of things have changed in sage.structure.element. Thus, it might be worthwhile to see what points raised in the ticket description are still valid, and then start from scratch addressing these points.",
    "created_at": "2018-03-03T09:51:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264484",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:51'>Comment 51:</a>
In the meantime, a lot of things have changed in sage.structure.element. Thus, it might be worthwhile to see what points raised in the ticket description are still valid, and then start from scratch addressing these points.



---

archive/issue_comments_264485.json:
```json
{
    "body": "<a id='comment:52'>Comment 52:</a>\nIndeed. Now there is much less difference between `Element` and the derived classes like `ModuleElement`.",
    "created_at": "2018-03-03T13:16:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/18756",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/18756#issuecomment-264485",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:52'>Comment 52:</a>
Indeed. Now there is much less difference between `Element` and the derived classes like `ModuleElement`.
