# Issue 18383: Coercion and comparison for alternating sign matrices

archive/issues_018146.json:
```json
{
    "body": "With this this ticket we declare an embedding from the set of alternating sign matrices (`sage.combinat.alternating_sign_matrix.AlternatingSignMatrices`) to the set of matrices. We also implement comparisons using `_cmp_` that will take care of coercions.\n\nIssue created by migration from https://trac.sagemath.org/ticket/18383\n\n",
    "created_at": "2015-05-08T16:12:33Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.7",
    "title": "Coercion and comparison for alternating sign matrices",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18383",
    "user": "https://github.com/videlec"
}
```
With this this ticket we declare an embedding from the set of alternating sign matrices (`sage.combinat.alternating_sign_matrix.AlternatingSignMatrices`) to the set of matrices. We also implement comparisons using `_cmp_` that will take care of coercions.

Issue created by migration from https://trac.sagemath.org/ticket/18383





---

archive/issue_comments_244398.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-05-08T16:18:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244398",
    "user": "https://github.com/videlec"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_244399.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-05-08T16:18:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244399",
    "user": "https://github.com/videlec"
}
```

New commits:



---

archive/issue_comments_244400.json:
```json
{
    "body": "We should not remove the rich comparisons as this makes us less python3 compatible. If you want to deal with the comparisons via coercion, then it should be done without using `_cmp_`/`__cmp__`.",
    "created_at": "2015-05-09T18:13:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244400",
    "user": "https://github.com/tscrim"
}
```

We should not remove the rich comparisons as this makes us less python3 compatible. If you want to deal with the comparisons via coercion, then it should be done without using `_cmp_`/`__cmp__`.



---

archive/issue_comments_244401.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-09T18:13:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244401",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_244402.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-05-09T18:16:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244402",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_244403.json:
```json
{
    "body": "Replying to [comment:2 tscrim]:\n> We should not remove the rich comparisons as this makes us less python3 compatible. If you want to deal with the comparisons via coercion, then it should be done without using `_cmp_`/`__cmp__`.\n\n\n`__richcmp__` does call `_cmp_`?! Could you explain the problem? No doctest has been removed.",
    "created_at": "2015-05-09T18:16:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244403",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:2 tscrim]:
> We should not remove the rich comparisons as this makes us less python3 compatible. If you want to deal with the comparisons via coercion, then it should be done without using `_cmp_`/`__cmp__`.


`__richcmp__` does call `_cmp_`?! Could you explain the problem? No doctest has been removed.



---

archive/issue_comments_244404.json:
```json
{
    "body": "Because it assumes the existence of a *total* order (which may not be reasonable for matrices in the future as, IIRC, when they were first implemented, we only had `__cmp__` in Python). Also `cmp` is going away in Python3 and `__richcmp__` only calls `_cmp_` as a generic fallback. Plus the current implementation already acts as how you're intending it to (which might change as the ASM people might want the comparisons to be the natural lattice and they would need to revert your changes).",
    "created_at": "2015-05-09T18:48:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244404",
    "user": "https://github.com/tscrim"
}
```

Because it assumes the existence of a *total* order (which may not be reasonable for matrices in the future as, IIRC, when they were first implemented, we only had `__cmp__` in Python). Also `cmp` is going away in Python3 and `__richcmp__` only calls `_cmp_` as a generic fallback. Plus the current implementation already acts as how you're intending it to (which might change as the ASM people might want the comparisons to be the natural lattice and they would need to revert your changes).



---

archive/issue_comments_244405.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n> Because it assumes the existence of a *total* order (which may not be reasonable for matrices in the future as, IIRC, when they were first implemented, we only had `__cmp__` in Python). Also `cmp` is going away in Python3 and `__richcmp__` only calls `_cmp_` as a generic fallback. Plus the current implementation already acts as how you're intending it to (which might change as the ASM people might want the comparisons to be the natural lattice and they would need to revert your changes).\n\n\nI assumed that there is a total order on `-1,0,1`. Right. The **only** things that change with this ticket are:\n\n1. the embedding `ASM -> MatrixSpace`\n2. the fact that coercion takes place in comparisons\n3. the fact that `cmp(a1,a2)` answers something when `a1` and `a2` are both `ASM` instead of raising a `NotImplementedError`.\n\nI will not do anything more complicated as I do not know anything about `ASM`. If you think that the previous implementation was wrong then open a follow up ticket (and I might possibly close this one as duplicate). If you think that some of the three points above are wrong then please be clearer.\n\nVincent",
    "created_at": "2015-05-09T19:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244405",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:4 tscrim]:
> Because it assumes the existence of a *total* order (which may not be reasonable for matrices in the future as, IIRC, when they were first implemented, we only had `__cmp__` in Python). Also `cmp` is going away in Python3 and `__richcmp__` only calls `_cmp_` as a generic fallback. Plus the current implementation already acts as how you're intending it to (which might change as the ASM people might want the comparisons to be the natural lattice and they would need to revert your changes).


I assumed that there is a total order on `-1,0,1`. Right. The **only** things that change with this ticket are:

1. the embedding `ASM -> MatrixSpace`
2. the fact that coercion takes place in comparisons
3. the fact that `cmp(a1,a2)` answers something when `a1` and `a2` are both `ASM` instead of raising a `NotImplementedError`.

I will not do anything more complicated as I do not know anything about `ASM`. If you think that the previous implementation was wrong then open a follow up ticket (and I might possibly close this one as duplicate). If you think that some of the three points above are wrong then please be clearer.

Vincent



---

archive/issue_comments_244406.json:
```json
{
    "body": "Replying to [comment:5 vdelecroix]:\n> I assumed that there is a total order on `-1,0,1`. Right.\n\n\nHowever that doesn't make a good ordering on ASM's.\n\n>The **only** things that change with this ticket are:\n> \n>1. the embedding `ASM -> MatrixSpace`\n\n\nGood.\n\n> 2. the fact that coercion takes place in comparisons\n\n\nThis was already done (at least up to comparing the matrices).\n\n> 3. the fact that `cmp(a1,a2)` answers something when `a1` and `a2` are both `ASM` instead of raising a `NotImplementedError`.\n\n\nThis is an indicator of something which we are doing wrong further up the chain, in the sense of being both 2&3 compatible, as rich comparisons should override the behavior of `__cmp__` (see the rich comparisons part of http://docs.python.org/2/reference/datamodel.html). Again, `cmp` and related methods are *gone* in Python3, so let's not step backwards by removing the rich comparisons. \n\n> I will not do anything more complicated as I do not know anything about `ASM`. If you think that the previous implementation was wrong then open a follow up ticket (and I might possibly close this one as duplicate). If you think that some of the three points above are wrong then please be clearer.\n\n\nI'm not saying its wrong per-say, but it might carry more meaning than it currently does. I can ask the ASM people what they want, but it's tangential to my main objection that it is removing Python3 compatibility.",
    "created_at": "2015-05-09T22:59:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244406",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:5 vdelecroix]:
> I assumed that there is a total order on `-1,0,1`. Right.


However that doesn't make a good ordering on ASM's.

>The **only** things that change with this ticket are:
> 
>1. the embedding `ASM -> MatrixSpace`


Good.

> 2. the fact that coercion takes place in comparisons


This was already done (at least up to comparing the matrices).

> 3. the fact that `cmp(a1,a2)` answers something when `a1` and `a2` are both `ASM` instead of raising a `NotImplementedError`.


This is an indicator of something which we are doing wrong further up the chain, in the sense of being both 2&3 compatible, as rich comparisons should override the behavior of `__cmp__` (see the rich comparisons part of http://docs.python.org/2/reference/datamodel.html). Again, `cmp` and related methods are *gone* in Python3, so let's not step backwards by removing the rich comparisons. 

> I will not do anything more complicated as I do not know anything about `ASM`. If you think that the previous implementation was wrong then open a follow up ticket (and I might possibly close this one as duplicate). If you think that some of the three points above are wrong then please be clearer.


I'm not saying its wrong per-say, but it might carry more meaning than it currently does. I can ask the ASM people what they want, but it's tangential to my main objection that it is removing Python3 compatibility.



---

archive/issue_comments_244407.json:
```json
{
    "body": "Also #18322 looks like it will fix point 3 without having to use `_cmp_`.",
    "created_at": "2015-05-09T23:05:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244407",
    "user": "https://github.com/tscrim"
}
```

Also #18322 looks like it will fix point 3 without having to use `_cmp_`.



---

archive/issue_comments_244408.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-09T23:40:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244408",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_244409.json:
```json
{
    "body": "Replying to [comment:7 tscrim]:\n> Also #18322 looks like it will fix point 3 without having to use `_cmp_`.\n\n\nNope. To fit into the new infrastructure of comparison, you need to either implement `_cmp_` or `_richcmp_`. The methods `__eq__`, `__ne__`, `__lt__`, ... will never be called.",
    "created_at": "2015-05-10T09:04:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244409",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:7 tscrim]:
> Also #18322 looks like it will fix point 3 without having to use `_cmp_`.


Nope. To fit into the new infrastructure of comparison, you need to either implement `_cmp_` or `_richcmp_`. The methods `__eq__`, `__ne__`, `__lt__`, ... will never be called.



---

archive/issue_comments_244410.json:
```json
{
    "body": "Surely we aren't forcing everything to have a total ordering via a `_cmp_` (and are telling people to use `cmp` to do comparisons)? If so, then we'll never be able to switch to Python3.",
    "created_at": "2015-05-10T16:45:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244410",
    "user": "https://github.com/tscrim"
}
```

Surely we aren't forcing everything to have a total ordering via a `_cmp_` (and are telling people to use `cmp` to do comparisons)? If so, then we'll never be able to switch to Python3.



---

archive/issue_comments_244411.json:
```json
{
    "body": "Replying to [comment:10 tscrim]:\n> Surely we aren't forcing everything to have a total ordering via a `_cmp_` (and are telling people to use `cmp` to do comparisons)? If so, then we'll never be able to switch to Python3.\n\n\nPlease, stop talking about Python 3 since Cython is very different from Python from that point of view. To handle comparisons of elements in Sage and if you want the coercion to be involved then you should either implement:\n- `_cmp_(self, other)` (the simplest option)\n- `_richcmp_(self, other, op)`\nThis is a choice for the programmer and he/she can even implement both. I am not forcing anybody to use one or the other, but the first one is by far easier. This is independent of whatever Python version.\n\nThe subtle difference that you seem to care about between rich comparisons and cmp does not exists even in Python 2\n\n```\nclass A:\n    def __init__(self, value):\n        self.x = value\n    def __lt__(self, other):\n        print \"LT\"\n        return self.x < other.x\n    def __le__(self, other):\n        print \"LE\"\n        return self.x <= other.x\n    def __eq__(self, other):\n        print \"EQ\"\n        return self.x == other.x\n    def __ne__(self, other):\n        print \"NE\"\n        return self.x != other.x\n    def __ge__(self, other):\n        print \"GE\"\n        return self.x >= other.x\n    def __gt__(self, other):\n        print \"GT\"\n        return self.x > other.x\n```\nThen\n\n```\nsage: a = A(1)\nsage: b = A(2)\nsage: cmp(a,b)\nEQ\nLT\n-1\n```\nThis difference is just a Cython feature that we are not using much.",
    "created_at": "2015-05-10T16:58:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244411",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:10 tscrim]:
> Surely we aren't forcing everything to have a total ordering via a `_cmp_` (and are telling people to use `cmp` to do comparisons)? If so, then we'll never be able to switch to Python3.


Please, stop talking about Python 3 since Cython is very different from Python from that point of view. To handle comparisons of elements in Sage and if you want the coercion to be involved then you should either implement:
- `_cmp_(self, other)` (the simplest option)
- `_richcmp_(self, other, op)`
This is a choice for the programmer and he/she can even implement both. I am not forcing anybody to use one or the other, but the first one is by far easier. This is independent of whatever Python version.

The subtle difference that you seem to care about between rich comparisons and cmp does not exists even in Python 2

```
class A:
    def __init__(self, value):
        self.x = value
    def __lt__(self, other):
        print "LT"
        return self.x < other.x
    def __le__(self, other):
        print "LE"
        return self.x <= other.x
    def __eq__(self, other):
        print "EQ"
        return self.x == other.x
    def __ne__(self, other):
        print "NE"
        return self.x != other.x
    def __ge__(self, other):
        print "GE"
        return self.x >= other.x
    def __gt__(self, other):
        print "GT"
        return self.x > other.x
```
Then

```
sage: a = A(1)
sage: b = A(2)
sage: cmp(a,b)
EQ
LT
-1
```
This difference is just a Cython feature that we are not using much.



---

archive/issue_comments_244412.json:
```json
{
    "body": "But `_cmp_` does necessarily provide a total order... this is true.",
    "created_at": "2015-05-10T16:59:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244412",
    "user": "https://github.com/videlec"
}
```

But `_cmp_` does necessarily provide a total order... this is true.



---

archive/issue_comments_244413.json:
```json
{
    "body": "We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).",
    "created_at": "2015-05-10T17:18:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244413",
    "user": "https://github.com/tscrim"
}
```

We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).



---

archive/issue_comments_244414.json:
```json
{
    "body": "Replying to [comment:13 tscrim]:\n> We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).\n\n\nThis is not that simple because at the level of the C API `__eq__`, `__lt__` etc does not exist. So there will be a huge difference between extension classes (ie Cython) and Python classes (ie Python). The uniform way that is proposed is precisely to use `_cmp_` or `_richcmp_` and avoid `__eq__`, etc.\n\nThe fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.\n\nVincent",
    "created_at": "2015-05-10T17:25:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244414",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:13 tscrim]:
> We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).


This is not that simple because at the level of the C API `__eq__`, `__lt__` etc does not exist. So there will be a huge difference between extension classes (ie Cython) and Python classes (ie Python). The uniform way that is proposed is precisely to use `_cmp_` or `_richcmp_` and avoid `__eq__`, etc.

The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.

Vincent



---

archive/issue_comments_244415.json:
```json
{
    "body": "Replying to [comment:14 vdelecroix]:\n> Replying to [comment:13 tscrim]:\n> > We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).\n\n> \n> This is not that simple because at the level of the C API `__eq__`, `__lt__` etc does not exist. So there will be a huge difference between extension classes (ie Cython) and Python classes (ie Python). The uniform way that is proposed is precisely to use `_cmp_` or `_richcmp_` and avoid `__eq__`, etc.\n\n\nThe uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.\n\n> The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.\n\n\nIt's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).",
    "created_at": "2015-05-10T17:52:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244415",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:14 vdelecroix]:
> Replying to [comment:13 tscrim]:
> > We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).

> 
> This is not that simple because at the level of the C API `__eq__`, `__lt__` etc does not exist. So there will be a huge difference between extension classes (ie Cython) and Python classes (ie Python). The uniform way that is proposed is precisely to use `_cmp_` or `_richcmp_` and avoid `__eq__`, etc.


The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.

> The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.


It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).



---

archive/issue_comments_244416.json:
```json
{
    "body": "Replying to [comment:15 tscrim]:\n> Replying to [comment:14 vdelecroix]:\n> > Replying to [comment:13 tscrim]:\n> > > We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).\n\n> > \n> > This is not that simple because at the level of the C API `__eq__`, `__lt__` etc does not exist. So there will be a huge difference between extension classes (ie Cython) and Python classes (ie Python). The uniform way that is proposed is precisely to use `_cmp_` or `_richcmp_` and avoid `__eq__`, etc.\n\n> \n> The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.\n\n\nWe can not do that. The method `__richcmp__` (and hence `_richcmp_`) is not used at all if `__eq__`, `__lt__`, etc are implemented in a Python class.\n\n> > The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.\n\n> \n> It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).\n\n\nDo you have an example involving rich comparisons that differ?\n\nVincent",
    "created_at": "2015-05-10T18:09:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244416",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:15 tscrim]:
> Replying to [comment:14 vdelecroix]:
> > Replying to [comment:13 tscrim]:
> > > We have to care about Python3 because it is the way going forward. The subtlety has come from us implementing a `__cmp__` at the general `Element` level, which gets called by the `cmp` first, and then instead of the default Python implementation of checking `__eq__` and `__lt__`, it tries to call `_cmp_` and then `_richcmp_`. This is a subtly caused by the current machinery in Sage. We need a mechanism which falls back to the usual Python rich comparisons for compatibility (although perhaps we need to make a single underscored version to work with coercion, but that is a question for sage-devel and I think there's already discussions about this).

> > 
> > This is not that simple because at the level of the C API `__eq__`, `__lt__` etc does not exist. So there will be a huge difference between extension classes (ie Cython) and Python classes (ie Python). The uniform way that is proposed is precisely to use `_cmp_` or `_richcmp_` and avoid `__eq__`, etc.

> 
> The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.


We can not do that. The method `__richcmp__` (and hence `_richcmp_`) is not used at all if `__eq__`, `__lt__`, etc are implemented in a Python class.

> > The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.

> 
> It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).


Do you have an example involving rich comparisons that differ?

Vincent



---

archive/issue_comments_244417.json:
```json
{
    "body": "Replying to [comment:16 vdelecroix]:\n> Replying to [comment:15 tscrim]:\n> > The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.\n\n> \n> We can not do that. The method `__richcmp__` (and hence `_richcmp_`) is not used at all if `__eq__`, `__lt__`, etc are implemented in a Python class.\n\n\nFor rich comparisons, yes. However for `cmp`, the code path currently completely bypasses the rich comparisons because it calls `__cmp__` (which calls `_cmp` which calls `_cmp_` and errors out).\n\n> > > The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.\n\n> > \n> > It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).\n\n> \n> Do you have an example involving rich comparisons that differ?\n\n\nI'm not sure what you're asking for. If you do an equality comparison between an ASM and a regular matrix, then the comparison lifts the ASM to a matrix and then does the comparison.\n\n```\nsage: ASM = AlternatingSignMatrices(3)\nsage: x = ASM[3]\nsage: x == x._matrix\nTrue\n```\nOtherwise it returns `False`, which is a fair thing to do since these are combinatorial objects, not honest matrices (or 2D arrays). (I think I misread the code when I first looked.) I'm actually becoming more convinced that the inequality comparisons should be done in the corresponding lattices. Is this perhaps what you're asking about?\n\n```\nsage: ASM[1] < ASM[3]   # Is True in the latice\nFalse\n```",
    "created_at": "2015-05-10T19:06:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244417",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:16 vdelecroix]:
> Replying to [comment:15 tscrim]:
> > The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.

> 
> We can not do that. The method `__richcmp__` (and hence `_richcmp_`) is not used at all if `__eq__`, `__lt__`, etc are implemented in a Python class.


For rich comparisons, yes. However for `cmp`, the code path currently completely bypasses the rich comparisons because it calls `__cmp__` (which calls `_cmp` which calls `_cmp_` and errors out).

> > > The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.

> > 
> > It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).

> 
> Do you have an example involving rich comparisons that differ?


I'm not sure what you're asking for. If you do an equality comparison between an ASM and a regular matrix, then the comparison lifts the ASM to a matrix and then does the comparison.

```
sage: ASM = AlternatingSignMatrices(3)
sage: x = ASM[3]
sage: x == x._matrix
True
```
Otherwise it returns `False`, which is a fair thing to do since these are combinatorial objects, not honest matrices (or 2D arrays). (I think I misread the code when I first looked.) I'm actually becoming more convinced that the inequality comparisons should be done in the corresponding lattices. Is this perhaps what you're asking about?

```
sage: ASM[1] < ASM[3]   # Is True in the latice
False
```



---

archive/issue_comments_244418.json:
```json
{
    "body": "Replying to [comment:17 tscrim]:\n> Replying to [comment:16 vdelecroix]:\n> > Replying to [comment:15 tscrim]:\n> > > The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.\n\n> > \n> > We can not do that. The method `__richcmp__` (and hence `_richcmp_`) is not used at all if `__eq__`, `__lt__`, etc are implemented in a Python class.\n\n> \n> For rich comparisons, yes. However for `cmp`, the code path currently completely bypasses the rich comparisons because it calls `__cmp__` (which calls `_cmp` which calls `_cmp_` and errors out).\n\n\nThis has been fixed in #18322.\n\n> > > > The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.\n\n> > > \n> > > It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).\n\n> > \n> > Do you have an example involving rich comparisons that differ?\n\n\n> I'm not sure what you're asking for.\n\n\nI wanted an example of a comparison that is different before and after my branch.",
    "created_at": "2015-05-10T19:27:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244418",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:17 tscrim]:
> Replying to [comment:16 vdelecroix]:
> > Replying to [comment:15 tscrim]:
> > > The uniform way would be to have the generic `_richcmp_` default back to using the python `__eq__`, etc. It may not be simple to implement, but it is the IMO correct way to do things as we should not be making ourselves less Python3 compliant. Plus I thought by having `_richcmp_` being a Python method, we could then call the `__lt__`, or at least use `getattr`. Moreover, this is only a problem for doing comparisons with `cmp`, which will be moot once we do switch.

> > 
> > We can not do that. The method `__richcmp__` (and hence `_richcmp_`) is not used at all if `__eq__`, `__lt__`, etc are implemented in a Python class.

> 
> For rich comparisons, yes. However for `cmp`, the code path currently completely bypasses the rich comparisons because it calls `__cmp__` (which calls `_cmp` which calls `_cmp_` and errors out).


This has been fixed in #18322.

> > > > The fact that there is a global `__cmp__` in `Element` might be a problem but this is rather disjoint from the present ticket: for ASM we want coercion to be involved.

> > > 
> > > It's quite relevant because it is part of your proposal. In the current version of Sage, if the other element is not an ASM, then it lifts itself to the matrix space and does the comparison there (in that it compares against its defining matrix).

> > 
> > Do you have an example involving rich comparisons that differ?


> I'm not sure what you're asking for.


I wanted an example of a comparison that is different before and after my branch.



---

archive/issue_comments_244419.json:
```json
{
    "body": "Replying to [comment:18 vdelecroix]:\n> Replying to [comment:17 tscrim]:\n> > For rich comparisons, yes. However for `cmp`, the code path currently completely bypasses the rich comparisons because it calls `__cmp__` (which calls `_cmp` which calls `_cmp_` and errors out).\n\n> \n> This has been fixed in #18322.\n\n\nIf that does have the rich comparisons in the code path, then it should fix the issue without having to define a `_cmp_`.\n\n> > > Do you have an example involving rich comparisons that differ?\n\n> \n> > I'm not sure what you're asking for.\n\n> \n> I wanted an example of a comparison that is different before and after my branch.\n\n\nHere is one:\n\n```\nsage: ASM = AlternatingSignMatrices(3)\nsage: x = ASM[3]\nsage: x\n[ 0  1  0]\n[ 1 -1  1]\n[ 0  1  0]\nsage: x < matrix.identity(3)   # True with this branch\nFalse\n```\nand it is because the coercion framework gets involved. Although ASM's only have the inequality comparisons for plotting due to the digraph calling `sorted` in `vertices()` which fails (#15372, which was a quick hack around the problem IMO) rather than just choosing some order. So the inequality comparisons are not mathematically defined as-is (even for matrices IMO, where they are just considered as 2-dim arrays). So now I'm completely convinced they should be rewritten to use the lattice.",
    "created_at": "2015-05-11T17:35:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244419",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:18 vdelecroix]:
> Replying to [comment:17 tscrim]:
> > For rich comparisons, yes. However for `cmp`, the code path currently completely bypasses the rich comparisons because it calls `__cmp__` (which calls `_cmp` which calls `_cmp_` and errors out).

> 
> This has been fixed in #18322.


If that does have the rich comparisons in the code path, then it should fix the issue without having to define a `_cmp_`.

> > > Do you have an example involving rich comparisons that differ?

> 
> > I'm not sure what you're asking for.

> 
> I wanted an example of a comparison that is different before and after my branch.


Here is one:

```
sage: ASM = AlternatingSignMatrices(3)
sage: x = ASM[3]
sage: x
[ 0  1  0]
[ 1 -1  1]
[ 0  1  0]
sage: x < matrix.identity(3)   # True with this branch
False
```
and it is because the coercion framework gets involved. Although ASM's only have the inequality comparisons for plotting due to the digraph calling `sorted` in `vertices()` which fails (#15372, which was a quick hack around the problem IMO) rather than just choosing some order. So the inequality comparisons are not mathematically defined as-is (even for matrices IMO, where they are just considered as 2-dim arrays). So now I'm completely convinced they should be rewritten to use the lattice.



---

archive/issue_comments_244420.json:
```json
{
    "body": "Replying to [comment:19 tscrim]:\n\nI understand your objections but I will not do anything like that. So I propose to close this ticket as a won't fix.\n\nVincent",
    "created_at": "2015-05-11T17:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244420",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:19 tscrim]:

I understand your objections but I will not do anything like that. So I propose to close this ticket as a won't fix.

Vincent



---

archive/issue_comments_244421.json:
```json
{
    "body": "I would like to include your changes adding the coercion and the `_matrix_` method though. I can separate this out if you want.",
    "created_at": "2015-05-11T17:51:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244421",
    "user": "https://github.com/tscrim"
}
```

I would like to include your changes adding the coercion and the `_matrix_` method though. I can separate this out if you want.



---

archive/issue_comments_244422.json:
```json
{
    "body": "Replying to [comment:21 tscrim]:\n> I would like to include your changes adding the coercion and the `_matrix_` method though. I can separate this out if you want.\n\n\nNo no no. Let us do it here. I can provide a commit where I do not modify the comparisons. Just provide the coercion. Is that ok?",
    "created_at": "2015-05-11T19:20:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244422",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:21 tscrim]:
> I would like to include your changes adding the coercion and the `_matrix_` method though. I can separate this out if you want.


No no no. Let us do it here. I can provide a commit where I do not modify the comparisons. Just provide the coercion. Is that ok?



---

archive/issue_comments_244423.json:
```json
{
    "body": "I think we had a miscommunication, by separate out I meant of your previous commit and do it here, not a separate ticket. I was asking if you wanted me to do such a commit (on a new branch).",
    "created_at": "2015-05-11T21:38:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244423",
    "user": "https://github.com/tscrim"
}
```

I think we had a miscommunication, by separate out I meant of your previous commit and do it here, not a separate ticket. I was asking if you wanted me to do such a commit (on a new branch).



---

archive/issue_comments_244424.json:
```json
{
    "body": "Replying to [comment:23 tscrim]:\n> I think we had a miscommunication, by separate out I meant of your previous commit and do it here, not a separate ticket. I was asking if you wanted me to do such a commit (on a new branch).\n\n\nI thought you want me to replace my commit by another one. What you propose is even simpler for me, so it is even better...\n\nVincent",
    "created_at": "2015-05-11T21:43:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244424",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:23 tscrim]:
> I think we had a miscommunication, by separate out I meant of your previous commit and do it here, not a separate ticket. I was asking if you wanted me to do such a commit (on a new branch).


I thought you want me to replace my commit by another one. What you propose is even simpler for me, so it is even better...

Vincent



---

archive/issue_comments_244425.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-05-11T22:34:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244425",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_244426.json:
```json
{
    "body": "If you could just double check that I pulled out everything correctly, then we can set this to positive review. I'll also do followup tickets for the change for the plotting issue and ordering of the ASM's.\n\n---\nNew commits:",
    "created_at": "2015-05-11T22:34:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244426",
    "user": "https://github.com/tscrim"
}
```

If you could just double check that I pulled out everything correctly, then we can set this to positive review. I'll also do followup tickets for the change for the plotting issue and ordering of the ASM's.

---
New commits:



---

archive/issue_comments_244427.json:
```json
{
    "body": "I really don't like this solution because whether or not coercion is used depends on the order of the arguments (`A < B` does something completely different than `B > A`). You cannot say that you want coercion and then *not* use coercion for comparisons.\n\n```\nsage: A = AlternatingSignMatrices(3)[1]\nsage: A < B\nFalse\nsage: B > A\nTrue\n```\n\nI actually think that you don't want coercion for ASM's. You don't want to consider them as matrices with extra structure, you want to consider them as mathematical objects which happen to be written as a matrix.",
    "created_at": "2015-05-12T07:33:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244427",
    "user": "https://github.com/jdemeyer"
}
```

I really don't like this solution because whether or not coercion is used depends on the order of the arguments (`A < B` does something completely different than `B > A`). You cannot say that you want coercion and then *not* use coercion for comparisons.

```
sage: A = AlternatingSignMatrices(3)[1]
sage: A < B
False
sage: B > A
True
```

I actually think that you don't want coercion for ASM's. You don't want to consider them as matrices with extra structure, you want to consider them as mathematical objects which happen to be written as a matrix.



---

archive/issue_comments_244428.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-12T07:33:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18383",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18383#issuecomment-244428",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.
