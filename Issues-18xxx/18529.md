# Issue 18529: Topological manifolds: basics

archive/issues_018292.json:
```json
{
    "body": "This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\nBy *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. \n\nThis tickets implements the following Python classes:\n\n- `ManifoldSubset`: generic subset of a topological manifold (the open subsets being implemented by the subsclass `TopologicalManifold`)\n  - `TopologicalManifold`: topological manifold over a topological field *K*\n- `ManifoldPoint`: point in a topological manifold\n- `Chart`: chart of a topological manifold\n  - `RealChart`: chart of a topological manifold over the real field\n- `CoordChange`: transition map between two charts of a topological manifold\n\nas well as the singleton classes`TopologicalStructure` and `RealTopologicalStructure`. \n\n`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.\n\n**Documentation**:\nThe reference manual is produced by\n`sage -docbuild reference/manifolds html`\nIt can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/\nMore documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).\n\n\nAssignee: @egourgoulhon\n\nCC:  @man74cio\n\nKeywords: topological manifolds\n\nBranch/Commit: 00d265cf2855121dba914868264da6ea3a9c42af\n\nReviewer: Travis Scrimshaw, Eric Gourgoulhon\n\nAuthor: Eric Gourgoulhon, Travis Scrimshaw\n\nDependencies: #18175\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/18529\n\n",
    "closed_at": "2016-01-28T17:14:31Z",
    "created_at": "2015-05-27T16:12:55Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.1",
    "title": "Topological manifolds: basics",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18529",
    "user": "https://github.com/egourgoulhon"
}
```
This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. 

This tickets implements the following Python classes:

- `ManifoldSubset`: generic subset of a topological manifold (the open subsets being implemented by the subsclass `TopologicalManifold`)
  - `TopologicalManifold`: topological manifold over a topological field *K*
- `ManifoldPoint`: point in a topological manifold
- `Chart`: chart of a topological manifold
  - `RealChart`: chart of a topological manifold over the real field
- `CoordChange`: transition map between two charts of a topological manifold

as well as the singleton classes`TopologicalStructure` and `RealTopologicalStructure`. 

`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.

**Documentation**:
The reference manual is produced by
`sage -docbuild reference/manifolds html`
It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/
More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).


Assignee: @egourgoulhon

CC:  @man74cio

Keywords: topological manifolds

Branch/Commit: 00d265cf2855121dba914868264da6ea3a9c42af

Reviewer: Travis Scrimshaw, Eric Gourgoulhon

Author: Eric Gourgoulhon, Travis Scrimshaw

Dependencies: #18175

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/18529





---

archive/issue_comments_324536.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,14 @@\n-This is the implementation of topological manifolds over some field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+This is the implementation of topological manifolds over a field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+\n+This tickets implements the following Python classes:\n+\n+- `TopManifold`: topological manifold over a field K\n+- `TopManifoldPoint`: point in a topological manifold\n+- `TopManifoldSubset`: generic subset of a topological manifold\n+  - `TopManifoldOpenSubset`: open subset of a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n \n Author: Eric Gourgoulhon\n \n``````\n",
    "created_at": "2015-05-27T16:23:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324536",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,14 @@
-This is the implementation of topological manifolds over some field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+This is the implementation of topological manifolds over a field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+
+This tickets implements the following Python classes:
+
+- `TopManifold`: topological manifold over a field K
+- `TopManifoldPoint`: point in a topological manifold
+- `TopManifoldSubset`: generic subset of a topological manifold
+  - `TopManifoldOpenSubset`: open subset of a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
 
 Author: Eric Gourgoulhon
 
``````




---

archive/issue_comments_324537.json:
```json
{
    "body": "<a id='comment:2'></a>The phrase \"manifold over a field K\" sounds odd to me. Is it used in the literature? What if K is a finite field? It seems that if X is a finite discrete space, for every finite field F and for every non-negative integer n, then X is a manifold over F of dimension n: F and n play no role. (I'm assuming that finite fields have been given the discrete topology.)\n\nI think you might say \"topological manifold over a topological field K\", since obviously the topology on K is critical. Or you could omit \"over a field K\", and mention in the documentation that users can specify a topological field (like \\CC, rather than the default \\RR) if they want.",
    "created_at": "2015-05-27T21:55:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324537",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:2'></a>The phrase "manifold over a field K" sounds odd to me. Is it used in the literature? What if K is a finite field? It seems that if X is a finite discrete space, for every finite field F and for every non-negative integer n, then X is a manifold over F of dimension n: F and n play no role. (I'm assuming that finite fields have been given the discrete topology.)

I think you might say "topological manifold over a topological field K", since obviously the topology on K is critical. Or you could omit "over a field K", and mention in the documentation that users can specify a topological field (like \CC, rather than the default \RR) if they want.



---

archive/issue_comments_324538.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,17 @@\n+This is the implementation of topological manifolds over a topological field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space M such that every point in M has a neighborhood homeomorphic to K<sup>n</sup>, with the same non-negative integer n for all points. \n \n+This tickets implements the following Python classes:\n+\n+- `TopManifold`: topological manifold over a topological field K\n+- `TopManifoldPoint`: point in a topological manifold\n+- `TopManifoldSubset`: generic subset of a topological manifold\n+  - `TopManifoldOpenSubset`: open subset of a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+`TopManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (K=**R**) and complex manifolds (K=**C**). \n \n Author: Eric Gourgoulhon\n \n``````\n",
    "created_at": "2015-05-27T22:27:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324538",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,17 @@
+This is the implementation of topological manifolds over a topological field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space M such that every point in M has a neighborhood homeomorphic to K<sup>n</sup>, with the same non-negative integer n for all points. 
 
+This tickets implements the following Python classes:
+
+- `TopManifold`: topological manifold over a topological field K
+- `TopManifoldPoint`: point in a topological manifold
+- `TopManifoldSubset`: generic subset of a topological manifold
+  - `TopManifoldOpenSubset`: open subset of a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+`TopManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (K=**R**) and complex manifolds (K=**C**). 
 
 Author: Eric Gourgoulhon
 
``````




---

archive/issue_comments_324539.json:
```json
{
    "body": "<a id='comment:4'></a>Replying to [comment:2 jhpalmieri]:\n> The phrase \"manifold over a field K\" sounds odd to me. Is it used in the literature? \n\n\nThanks for your comment. You are right: this is an abusive generalization of \"manifold over R\" and \"manifold over C\", which are used in the literature. \n\n>What if K is a finite field? It seems that if X is a finite discrete space, for every finite field F and for every non-negative integer n, then X is a manifold over F of dimension n: F and n play no role. (I'm assuming that finite fields have been given the discrete topology.)\n\n\n> \n> I think you might say \"topological manifold over a topological field K\", since obviously the topology on K is critical. Or you could omit \"over a field K\", and mention in the documentation that users can specify a topological field (like \\CC, rather than the default \\RR) if they want.\n\n\nThanks for your suggestion; I've modified the ticket description accordingly. I've also added what is meant by \"topological manifold over a topological field K\".\n\nPS: note that the code in the associated branch is still in a very crude draft state, but should be ready for review within a few days.",
    "created_at": "2015-05-27T22:32:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324539",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:4'></a>Replying to [comment:2 jhpalmieri]:
> The phrase "manifold over a field K" sounds odd to me. Is it used in the literature? 


Thanks for your comment. You are right: this is an abusive generalization of "manifold over R" and "manifold over C", which are used in the literature. 

>What if K is a finite field? It seems that if X is a finite discrete space, for every finite field F and for every non-negative integer n, then X is a manifold over F of dimension n: F and n play no role. (I'm assuming that finite fields have been given the discrete topology.)


> 
> I think you might say "topological manifold over a topological field K", since obviously the topology on K is critical. Or you could omit "over a field K", and mention in the documentation that users can specify a topological field (like \CC, rather than the default \RR) if they want.


Thanks for your suggestion; I've modified the ticket description accordingly. I've also added what is meant by "topological manifold over a topological field K".

PS: note that the code in the associated branch is still in a very crude draft state, but should be ready for review within a few days.



---

archive/issue_comments_324540.json:
```json
{
    "body": "Changing commit from \"89c063c7119f19497e3d21b2a5a9dcb0752122b0\" to \"5a5722b4a0ef33d8624fdd127bbb1964232ced96\"",
    "created_at": "2015-05-27T22:41:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324540",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "89c063c7119f19497e3d21b2a5a9dcb0752122b0" to "5a5722b4a0ef33d8624fdd127bbb1964232ced96"



---

archive/issue_comments_324541.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-27T22:41:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324541",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324542.json:
```json
{
    "body": "<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-28T14:21:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324542",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324543.json:
```json
{
    "body": "Changing commit from \"5a5722b4a0ef33d8624fdd127bbb1964232ced96\" to \"4f490af5fedeb0a28dd8ddab70efdab1cc64bf93\"",
    "created_at": "2015-05-28T14:21:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324543",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "5a5722b4a0ef33d8624fdd127bbb1964232ced96" to "4f490af5fedeb0a28dd8ddab70efdab1cc64bf93"



---

archive/issue_comments_324544.json:
```json
{
    "body": "Changing commit from \"4f490af5fedeb0a28dd8ddab70efdab1cc64bf93\" to \"d8df59f286da79e1e103b56064fdffb702e034ce\"",
    "created_at": "2015-05-28T22:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324544",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "4f490af5fedeb0a28dd8ddab70efdab1cc64bf93" to "d8df59f286da79e1e103b56064fdffb702e034ce"



---

archive/issue_comments_324545.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-28T22:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324545",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324546.json:
```json
{
    "body": "<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-29T16:07:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324546",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324547.json:
```json
{
    "body": "Changing commit from \"d8df59f286da79e1e103b56064fdffb702e034ce\" to \"fb96562c1e7d4ffc76ca87efcc15d133c6c15190\"",
    "created_at": "2015-05-29T16:07:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324547",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "d8df59f286da79e1e103b56064fdffb702e034ce" to "fb96562c1e7d4ffc76ca87efcc15d133c6c15190"



---

archive/issue_comments_324548.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,16 @@\n+This is the implementation of topological manifolds over a topological field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space M such that every point in M has a neighborhood homeomorphic to K<sup>n</sup>, with the same non-negative integer n for all points. \n \n+This tickets implements the following Python classes:\n+\n+- `TopManifold`: topological manifold over a topological field K\n+- `TopManifoldPoint`: point in a topological manifold\n+- `TopManifoldSubset`: generic subset of a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+`TopManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (K=**R**) and complex manifolds (K=**C**).\n \n Author: Eric Gourgoulhon\n \n``````\n",
    "created_at": "2015-05-29T16:12:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324548",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,16 @@
+This is the implementation of topological manifolds over a topological field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space M such that every point in M has a neighborhood homeomorphic to K<sup>n</sup>, with the same non-negative integer n for all points. 
 
+This tickets implements the following Python classes:
+
+- `TopManifold`: topological manifold over a topological field K
+- `TopManifoldPoint`: point in a topological manifold
+- `TopManifoldSubset`: generic subset of a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+`TopManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (K=**R**) and complex manifolds (K=**C**).
 
 Author: Eric Gourgoulhon
 
``````




---

archive/issue_comments_324549.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-30T14:10:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324549",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324550.json:
```json
{
    "body": "Changing commit from \"fb96562c1e7d4ffc76ca87efcc15d133c6c15190\" to \"38c3c12cb1d9b4d52a35ad6f7a1a8d0ee666d532\"",
    "created_at": "2015-05-30T14:10:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324550",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "fb96562c1e7d4ffc76ca87efcc15d133c6c15190" to "38c3c12cb1d9b4d52a35ad6f7a1a8d0ee666d532"



---

archive/issue_comments_324551.json:
```json
{
    "body": "Changing commit from \"38c3c12cb1d9b4d52a35ad6f7a1a8d0ee666d532\" to \"7809ebf468f80143e33830e0df75046bf191ce24\"",
    "created_at": "2015-06-04T13:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324551",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "38c3c12cb1d9b4d52a35ad6f7a1a8d0ee666d532" to "7809ebf468f80143e33830e0df75046bf191ce24"



---

archive/issue_comments_324552.json:
```json
{
    "body": "<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-04T13:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324552",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324553.json:
```json
{
    "body": "Changing commit from \"7809ebf468f80143e33830e0df75046bf191ce24\" to \"99cc8c1c94197b1648966eaa7b2a6d04ddab1efc\"",
    "created_at": "2015-06-18T16:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324553",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "7809ebf468f80143e33830e0df75046bf191ce24" to "99cc8c1c94197b1648966eaa7b2a6d04ddab1efc"



---

archive/issue_comments_324554.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-18T16:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324554",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324555.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-23T15:39:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324555",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324556.json:
```json
{
    "body": "Changing commit from \"99cc8c1c94197b1648966eaa7b2a6d04ddab1efc\" to \"26fc318bbacfc9a27049a9397d43402975525820\"",
    "created_at": "2015-06-23T15:39:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324556",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "99cc8c1c94197b1648966eaa7b2a6d04ddab1efc" to "26fc318bbacfc9a27049a9397d43402975525820"



---

archive/issue_comments_324557.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-26T16:11:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324557",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324558.json:
```json
{
    "body": "Changing commit from \"26fc318bbacfc9a27049a9397d43402975525820\" to \"a74c2e0519c166657b858be5b4b3dc4fd0145d09\"",
    "created_at": "2015-06-26T16:11:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324558",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "26fc318bbacfc9a27049a9397d43402975525820" to "a74c2e0519c166657b858be5b4b3dc4fd0145d09"



---

archive/issue_comments_324559.json:
```json
{
    "body": "Changing commit from \"a74c2e0519c166657b858be5b4b3dc4fd0145d09\" to \"542b82a9ed134759fe498cd34b682b2d565061c1\"",
    "created_at": "2015-08-24T14:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324559",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "a74c2e0519c166657b858be5b4b3dc4fd0145d09" to "542b82a9ed134759fe498cd34b682b2d565061c1"



---

archive/issue_comments_324560.json:
```json
{
    "body": "<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-24T14:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324560",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324561.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-01T15:33:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324561",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324562.json:
```json
{
    "body": "Changing commit from \"542b82a9ed134759fe498cd34b682b2d565061c1\" to \"26c489001c4ee64a95ee70da72210e361180eeb0\"",
    "created_at": "2015-10-01T15:33:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324562",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "542b82a9ed134759fe498cd34b682b2d565061c1" to "26c489001c4ee64a95ee70da72210e361180eeb0"



---

archive/issue_comments_324563.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-13T21:32:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324563",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324564.json:
```json
{
    "body": "Changing commit from \"26c489001c4ee64a95ee70da72210e361180eeb0\" to \"be3ff7424963450c1c2dfa7ca9fbe85eaeab1162\"",
    "created_at": "2015-10-13T21:32:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324564",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "26c489001c4ee64a95ee70da72210e361180eeb0" to "be3ff7424963450c1c2dfa7ca9fbe85eaeab1162"



---

archive/issue_comments_324565.json:
```json
{
    "body": "Changing commit from \"be3ff7424963450c1c2dfa7ca9fbe85eaeab1162\" to \"4de19a74c83ac6d4d0c4da74e1d1f2afce5c3045\"",
    "created_at": "2015-10-15T12:37:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324565",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "be3ff7424963450c1c2dfa7ca9fbe85eaeab1162" to "4de19a74c83ac6d4d0c4da74e1d1f2afce5c3045"



---

archive/issue_comments_324566.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-15T12:37:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324566",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_052103.json:
```json
{
    "actor": "https://github.com/egourgoulhon",
    "created_at": "2015-10-15T20:40:46Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "milestone": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18529#event-52103"
}
```



---

archive/issue_comments_324567.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-10-15T20:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324567",
    "user": "https://github.com/egourgoulhon"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_324568.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,22 @@\n+This is the implementation of topological manifolds over a topological field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space M such that every point in M has a neighborhood homeomorphic to K<sup>n</sup>, with the same non-negative integer n for all points. \n+\n+This tickets implements the following Python classes:\n+\n+- `TopManifold`: topological manifold over a topological field K\n+- `TopManifoldPoint`: point in a topological manifold\n+- `TopManifoldSubset`: generic subset of a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+`TopManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (K=**R**) and complex manifolds (K=**C**).\n+\n+**Documentation**:\n+The reference manual is produced by\n+`sage -docbuild reference/manifolds html`\n+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/\n+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).\n \n \n Author: Eric Gourgoulhon\n``````\n",
    "created_at": "2015-10-15T20:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324568",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,22 @@
+This is the implementation of topological manifolds over a topological field K resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space M such that every point in M has a neighborhood homeomorphic to K<sup>n</sup>, with the same non-negative integer n for all points. 
+
+This tickets implements the following Python classes:
+
+- `TopManifold`: topological manifold over a topological field K
+- `TopManifoldPoint`: point in a topological manifold
+- `TopManifoldSubset`: generic subset of a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+`TopManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (K=**R**) and complex manifolds (K=**C**).
+
+**Documentation**:
+The reference manual is produced by
+`sage -docbuild reference/manifolds html`
+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/
+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).
 
 
 Author: Eric Gourgoulhon
``````




---

archive/issue_comments_324569.json:
```json
{
    "body": "<a id='comment:20'></a>Why did you abreviate `TopologicalManifold`? Everywhere in Sage classes have plain names like `PolynomialRing` and not `PolRing`.",
    "created_at": "2015-10-17T13:44:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324569",
    "user": "https://github.com/videlec"
}
```

<a id='comment:20'></a>Why did you abreviate `TopologicalManifold`? Everywhere in Sage classes have plain names like `PolynomialRing` and not `PolRing`.



---

archive/issue_comments_324570.json:
```json
{
    "body": "<a id='comment:21'></a>Replying to [comment:20 vdelecroix]:\n> Why did you abreviate `TopologicalManifold`?\n\n\nNo strong argument, except that this is shorter to write (well, thanks to the tab key this is a pretty weak argument) and it is a reminder of Top, which is the standard name for the category of topological manifolds. Similarly, we use`DiffManifold` for differentiable manifold, Diff being the standard name of the category of differentiable manifolds. \n\n> Everywhere in Sage classes have plain names like `PolynomialRing` and not `PolRing`.\n\n\nThis is indeed a strong point: naming conventions should be homogeneous all across Sage. So I am considering to change everywhere `TopManifold` to `TopologicalManifold` and `DiffManifold` to `DifferentiableManifold`.",
    "created_at": "2015-10-17T14:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324570",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:21'></a>Replying to [comment:20 vdelecroix]:
> Why did you abreviate `TopologicalManifold`?


No strong argument, except that this is shorter to write (well, thanks to the tab key this is a pretty weak argument) and it is a reminder of Top, which is the standard name for the category of topological manifolds. Similarly, we use`DiffManifold` for differentiable manifold, Diff being the standard name of the category of differentiable manifolds. 

> Everywhere in Sage classes have plain names like `PolynomialRing` and not `PolRing`.


This is indeed a strong point: naming conventions should be homogeneous all across Sage. So I am considering to change everywhere `TopManifold` to `TopologicalManifold` and `DiffManifold` to `DifferentiableManifold`.



---

archive/issue_comments_324571.json:
```json
{
    "body": "Changing commit from \"4de19a74c83ac6d4d0c4da74e1d1f2afce5c3045\" to \"6dec6d592a09e56921b9a761827309dd31ae2533\"",
    "created_at": "2015-10-19T09:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324571",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "4de19a74c83ac6d4d0c4da74e1d1f2afce5c3045" to "6dec6d592a09e56921b9a761827309dd31ae2533"



---

archive/issue_comments_324572.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2015-10-19T09:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324572",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_324573.json:
```json
{
    "body": "<a id='comment:23'></a>I agree with Vincent here; we should be explicit in our names.\n\nAlthough is there a reason why you just did not have a single `Manifold` function/class as a global entry point, which then could delegate out to `*Manifold` depending on some boolean input arguments? I feel that this would make the user interface easier and have a single collective point for general documentation. Another option I see would be to have a `manifolds` catalog which then would have things like `Topological`, `Differentiable`, etc.",
    "created_at": "2015-10-22T17:18:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324573",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:23'></a>I agree with Vincent here; we should be explicit in our names.

Although is there a reason why you just did not have a single `Manifold` function/class as a global entry point, which then could delegate out to `*Manifold` depending on some boolean input arguments? I feel that this would make the user interface easier and have a single collective point for general documentation. Another option I see would be to have a `manifolds` catalog which then would have things like `Topological`, `Differentiable`, etc.



---

archive/issue_comments_324574.json:
```json
{
    "body": "<a id='comment:24'></a>Yes, it is pretty clear that we should have the following renaming of *classes*:\n- `TopManifold` --> `TopologicalManifold`\n- `DiffManifold` --> `DifferentiableManifold`\n\nRegarding the user interface, we could indeed have a *function* `Manifold` that looks like \n\n```\nManifold(dim, symbol, type='smooth', ...) \n```\nwith `'topological'`, `'differentiable'`, `'smooth'` as possible values for the parameter `type` (as well as `'analytic'`, etc. in the future). A question: should `'smooth'` be the default value?\n\nBesides, I remember someone was complaining that `Manifold` was already used in SnapPy, cf. [this page](http://www.math.uic.edu/t3m/SnapPy/manifold.html), but is there any danger of name clash? i.e. is SnapPy used (or could be used in the future) from Sage?",
    "created_at": "2015-10-22T20:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324574",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:24'></a>Yes, it is pretty clear that we should have the following renaming of *classes*:
- `TopManifold` --> `TopologicalManifold`
- `DiffManifold` --> `DifferentiableManifold`

Regarding the user interface, we could indeed have a *function* `Manifold` that looks like 

```
Manifold(dim, symbol, type='smooth', ...) 
```
with `'topological'`, `'differentiable'`, `'smooth'` as possible values for the parameter `type` (as well as `'analytic'`, etc. in the future). A question: should `'smooth'` be the default value?

Besides, I remember someone was complaining that `Manifold` was already used in SnapPy, cf. [this page](http://www.math.uic.edu/t3m/SnapPy/manifold.html), but is there any danger of name clash? i.e. is SnapPy used (or could be used in the future) from Sage?



---

archive/issue_comments_324575.json:
```json
{
    "body": "<a id='comment:25'></a>Replying to [comment:24 egourgoulhon]:\n> Regarding the user interface, we could indeed have a *function* `Manifold` that looks like \n> \n> ```\n> Manifold(dim, symbol, type='smooth', ...) \n> ```\n> with `'topological'`, `'differentiable'`, `'smooth'` as possible values for the parameter `type` (as well as `'analytic'`, etc. in the future). A question: should `'smooth'` be the default value?\n\n\nI don't know how easy it would be to make this a check on the atlas used to construct the manifold. I would make it select it automatically if possible, and then default to the most general setting of `'topological'`.\n\n> Besides, I remember someone was complaining that `Manifold` was already used in SnapPy, cf. [this page](http://www.math.uic.edu/t3m/SnapPy/manifold.html), but is there any danger of name clash? i.e. is SnapPy used (or could be used in the future) from Sage?\n\n\nI would then add an additional argument of `implementation`, which would default to the native Sage implementation, if there does become a name clash and have the constructor delegate out to the SnapPy version when it exists in Sage (IDK if it is Sage now or not).",
    "created_at": "2015-10-23T17:01:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324575",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:25'></a>Replying to [comment:24 egourgoulhon]:
> Regarding the user interface, we could indeed have a *function* `Manifold` that looks like 
> 
> ```
> Manifold(dim, symbol, type='smooth', ...) 
> ```
> with `'topological'`, `'differentiable'`, `'smooth'` as possible values for the parameter `type` (as well as `'analytic'`, etc. in the future). A question: should `'smooth'` be the default value?


I don't know how easy it would be to make this a check on the atlas used to construct the manifold. I would make it select it automatically if possible, and then default to the most general setting of `'topological'`.

> Besides, I remember someone was complaining that `Manifold` was already used in SnapPy, cf. [this page](http://www.math.uic.edu/t3m/SnapPy/manifold.html), but is there any danger of name clash? i.e. is SnapPy used (or could be used in the future) from Sage?


I would then add an additional argument of `implementation`, which would default to the native Sage implementation, if there does become a name clash and have the constructor delegate out to the SnapPy version when it exists in Sage (IDK if it is Sage now or not).



---

archive/issue_comments_324576.json:
```json
{
    "body": "<a id='comment:26'></a>Replying to [comment:25 tscrim]:\n> \n> I don't know how easy it would be to make this a check on the atlas used to construct the manifold. I would make it select it automatically if possible, and then default to the most general setting of `'topological'`.\n\n\nActually in the current setting, the atlas is not specified at the construction of the manifold: charts and transition maps are introduced on the fly, at any step in the user workflow. Therefore the type of manifold has to be declared explicitly by the user. It is my impression (but I may be biased) that one speaks about a \"manifold\" without any qualifier, one implicitely means a \"real smooth manifold\". Therefore I would set the default arguments of the `Manifold` function to `field='real'` and `type='smooth'`.  \n\n> \n> I would then add an additional argument of `implementation`, which would default to the native Sage implementation, if there does become a name clash and have the constructor delegate out to the SnapPy version when it exists in Sage (IDK if it is Sage now or not).\n\n\nGood idea!",
    "created_at": "2015-10-24T13:35:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324576",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:26'></a>Replying to [comment:25 tscrim]:
> 
> I don't know how easy it would be to make this a check on the atlas used to construct the manifold. I would make it select it automatically if possible, and then default to the most general setting of `'topological'`.


Actually in the current setting, the atlas is not specified at the construction of the manifold: charts and transition maps are introduced on the fly, at any step in the user workflow. Therefore the type of manifold has to be declared explicitly by the user. It is my impression (but I may be biased) that one speaks about a "manifold" without any qualifier, one implicitely means a "real smooth manifold". Therefore I would set the default arguments of the `Manifold` function to `field='real'` and `type='smooth'`.  

> 
> I would then add an additional argument of `implementation`, which would default to the native Sage implementation, if there does become a name clash and have the constructor delegate out to the SnapPy version when it exists in Sage (IDK if it is Sage now or not).


Good idea!



---

archive/issue_comments_324577.json:
```json
{
    "body": "<a id='comment:27'></a>Some things from looking over the current structure:\n\n- I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.\n\n- Maybe put the subsets into the `Subobjects` class and maybe consider not making it a facade?\n\n- Should manifolds and their subsets be `UniqueRepresentation`? I understand that the name as the only input means they are essentially treated as variables, but it means you have to do things like `TopManifold._clear_cache_()` (which may be needed not just necessarily in doctests if one does this before the gc comes around).\n\n- Related to the above, we want parents to be hashable and have a good equality. I know that by making it a `UniqueRepresentation`, many of these issues are solved. However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.\n\n- In the tests for `_element_constructor_`, you shouldn't call it explicitly but via `X(...)`, which also checks that it is working correctly with the coercion framework.\n\n- I don't quite agree with checking `self._field == RR` for real charts as the precision should not matter. I would check `isinstance(self._field, RealField)` instead. Granted, we probably should have a function that checks against all known real field implementations...\n\n- In a similar vein, I don't like the input of `'real'` to `RR` (and `'complex'` to `CC`). I would make the user be explicit about what they want unless you are doing to do some special handling to make this pass special arguments to an underlying `SR` implementation.",
    "created_at": "2015-10-25T22:26:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324577",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:27'></a>Some things from looking over the current structure:

- I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.

- Maybe put the subsets into the `Subobjects` class and maybe consider not making it a facade?

- Should manifolds and their subsets be `UniqueRepresentation`? I understand that the name as the only input means they are essentially treated as variables, but it means you have to do things like `TopManifold._clear_cache_()` (which may be needed not just necessarily in doctests if one does this before the gc comes around).

- Related to the above, we want parents to be hashable and have a good equality. I know that by making it a `UniqueRepresentation`, many of these issues are solved. However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.

- In the tests for `_element_constructor_`, you shouldn't call it explicitly but via `X(...)`, which also checks that it is working correctly with the coercion framework.

- I don't quite agree with checking `self._field == RR` for real charts as the precision should not matter. I would check `isinstance(self._field, RealField)` instead. Granted, we probably should have a function that checks against all known real field implementations...

- In a similar vein, I don't like the input of `'real'` to `RR` (and `'complex'` to `CC`). I would make the user be explicit about what they want unless you are doing to do some special handling to make this pass special arguments to an underlying `SR` implementation.



---

archive/issue_comments_324578.json:
```json
{
    "body": "<a id='comment:28'></a>Replying to [comment:27 tscrim]:\n\nThanks for your comments/suggestions.\n\n> Some things from looking over the current structure:\n> \n> - I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.\n> \n\n\nI am not sure an ABC would help here: this would make a clear distinction between the manifold and strict subsets of it (thus avoiding the very few tests `self is self._manifold`), but on the other hand, we need open strict subsets to be in the class `TopologicalManifolds`. \n> - Maybe put the subsets into the `Subobjects` class and maybe consider not making it a facade?\n> \n\n\nI had the impression that the facade feature is exactly what we need, since we can have the same point created from different facade parents by means of different charts: if `U` and `V` are two overelapping open subsets of manifold `M`, it may happen that the same point of `M` is declared in two different ways:\n\n```\n   p = U((x,y), chart=C1)\n   q = V((u,v), chart=C2)\n```\nThanks to the facade mecanism, `p` and `q` will have the same parent: `M` and then it is possible to check whether `p == q`; this will hold if the coordinates `(x,y)` in chart `C1` correspond to coordinates `(u,v)` in chart `C2`. Is there something bad in using facade parents?\n\n> - Should manifolds and their subsets be `UniqueRepresentation`? I understand that the name as the only input means they are essentially treated as variables, but it means you have to do things like `TopManifold._clear_cache_()` (which may be needed not just necessarily in doctests if one does this before the gc comes around).\n\n\nActually, I don't see any use case (except for confusing the reader!) where one would define two different manifolds with the same name and same dimension over the same topological field. So `UniqueRepresentation` seems quite appropriate here. Moreover, I thought this is Sage's credo to have parents be `UniqueRepresentation`, cf. the phrase *You are encouraged to make your parent \"unique\"* in the tutorial [How to implement new algebraic structures in Sage](http://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#coercion-and-categories). Also, most parents in `src/sage/geometry` (in particular the hyperbolic plane) have `UniqueRepresentation`.\n> \n> - Related to the above, we want parents to be hashable and have a good equality. I know that by making it a `UniqueRepresentation`, many of these issues are solved.\n \nIndeed!\n> However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.\n\n\nWhy should we avoid `UniqueRepresentation`? It's true that manifolds are mutable as Python objects, since the main idea is to add charts (and vector frames for differentiable manifolds) \"on the fly\" (for, in a concrete calculation, charts are often defined from previous ones by some transition map that might depend on some computational result and therefore it is impossible to introduce all charts at the instantiation of the manifold object). But this mutability is \"secondary\": the primary attributes of a manifold being its dimension, its name and its base field. With respect to these, the manifold is immutable. The need for `_clear_cache_()` in some doctests seems a very small annoyment, with respect to the benefit of `UniqueRepresentation`, doesn't it ? (I am afraid I have not understood the non-doctest case involving the garbage collector that you mentioned)\n\n> \n> - In the tests for `_element_constructor_`, you shouldn't call it explicitly but via `X(...)`, which also checks that it is working correctly with the coercion framework.\n\n\nOK, I will change this.\n> \n> - I don't quite agree with checking `self._field == RR` for real charts as the precision should not matter. I would check `isinstance(self._field, RealField)` instead. \n\n\nYes, I agree. I was also not satisfied with this.\n\n>Granted, we probably should have a function that checks against all known real field implementations...\n\n\n> \n> - In a similar vein, I don't like the input of `'real'` to `RR` (and `'complex'` to `CC`). I would make the user be explicit about what they want unless you are doing to do some special handling to make this pass special arguments to an underlying `SR` implementation.\n\n\nYes, I agree too.",
    "created_at": "2015-10-26T16:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324578",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:28'></a>Replying to [comment:27 tscrim]:

Thanks for your comments/suggestions.

> Some things from looking over the current structure:
> 
> - I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.
> 


I am not sure an ABC would help here: this would make a clear distinction between the manifold and strict subsets of it (thus avoiding the very few tests `self is self._manifold`), but on the other hand, we need open strict subsets to be in the class `TopologicalManifolds`. 
> - Maybe put the subsets into the `Subobjects` class and maybe consider not making it a facade?
> 


I had the impression that the facade feature is exactly what we need, since we can have the same point created from different facade parents by means of different charts: if `U` and `V` are two overelapping open subsets of manifold `M`, it may happen that the same point of `M` is declared in two different ways:

```
   p = U((x,y), chart=C1)
   q = V((u,v), chart=C2)
```
Thanks to the facade mecanism, `p` and `q` will have the same parent: `M` and then it is possible to check whether `p == q`; this will hold if the coordinates `(x,y)` in chart `C1` correspond to coordinates `(u,v)` in chart `C2`. Is there something bad in using facade parents?

> - Should manifolds and their subsets be `UniqueRepresentation`? I understand that the name as the only input means they are essentially treated as variables, but it means you have to do things like `TopManifold._clear_cache_()` (which may be needed not just necessarily in doctests if one does this before the gc comes around).


Actually, I don't see any use case (except for confusing the reader!) where one would define two different manifolds with the same name and same dimension over the same topological field. So `UniqueRepresentation` seems quite appropriate here. Moreover, I thought this is Sage's credo to have parents be `UniqueRepresentation`, cf. the phrase *You are encouraged to make your parent "unique"* in the tutorial [How to implement new algebraic structures in Sage](http://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#coercion-and-categories). Also, most parents in `src/sage/geometry` (in particular the hyperbolic plane) have `UniqueRepresentation`.
> 
> - Related to the above, we want parents to be hashable and have a good equality. I know that by making it a `UniqueRepresentation`, many of these issues are solved.
 
Indeed!
> However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.


Why should we avoid `UniqueRepresentation`? It's true that manifolds are mutable as Python objects, since the main idea is to add charts (and vector frames for differentiable manifolds) "on the fly" (for, in a concrete calculation, charts are often defined from previous ones by some transition map that might depend on some computational result and therefore it is impossible to introduce all charts at the instantiation of the manifold object). But this mutability is "secondary": the primary attributes of a manifold being its dimension, its name and its base field. With respect to these, the manifold is immutable. The need for `_clear_cache_()` in some doctests seems a very small annoyment, with respect to the benefit of `UniqueRepresentation`, doesn't it ? (I am afraid I have not understood the non-doctest case involving the garbage collector that you mentioned)

> 
> - In the tests for `_element_constructor_`, you shouldn't call it explicitly but via `X(...)`, which also checks that it is working correctly with the coercion framework.


OK, I will change this.
> 
> - I don't quite agree with checking `self._field == RR` for real charts as the precision should not matter. I would check `isinstance(self._field, RealField)` instead. 


Yes, I agree. I was also not satisfied with this.

>Granted, we probably should have a function that checks against all known real field implementations...


> 
> - In a similar vein, I don't like the input of `'real'` to `RR` (and `'complex'` to `CC`). I would make the user be explicit about what they want unless you are doing to do some special handling to make this pass special arguments to an underlying `SR` implementation.


Yes, I agree too.



---

archive/issue_comments_324579.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:28 egourgoulhon]:\n> Replying to [comment:27 tscrim]:\n> > \n> > - I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.\n> > \n \n> \n> I am not sure an ABC would help here: this would make a clear distinction between the manifold and strict subsets of it (thus avoiding the very few tests `self is self._manifold`), but on the other hand, we need open strict subsets to be in the class `TopologicalManifolds`. \n> \n\n\nI gave a second thought to this: are you thinking about something like\n\n```\n                               The_ABC\n                              /      \\\n  TopologicalManifoldStrictSubset  TopologicalManifold\n                              \\      /\n                 TopologicalManifoldStrictOpenSubset\n```\nwith the methods superset(), intersection() and union() being implemented in each of the classes `TopologicalManifoldStrictSubset` and `TopologicalManifold` ?",
    "created_at": "2015-10-27T13:29:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324579",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:29'></a>Replying to [comment:28 egourgoulhon]:
> Replying to [comment:27 tscrim]:
> > 
> > - I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.
> > 
 
> 
> I am not sure an ABC would help here: this would make a clear distinction between the manifold and strict subsets of it (thus avoiding the very few tests `self is self._manifold`), but on the other hand, we need open strict subsets to be in the class `TopologicalManifolds`. 
> 


I gave a second thought to this: are you thinking about something like

```
                               The_ABC
                              /      \
  TopologicalManifoldStrictSubset  TopologicalManifold
                              \      /
                 TopologicalManifoldStrictOpenSubset
```
with the methods superset(), intersection() and union() being implemented in each of the classes `TopologicalManifoldStrictSubset` and `TopologicalManifold` ?



---

archive/issue_comments_324580.json:
```json
{
    "body": "<a id='comment:30'></a>In a short word, yes, that is correct. I will respond in more detail tomorrow morning when I wake up.",
    "created_at": "2015-10-28T04:45:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324580",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:30'></a>In a short word, yes, that is correct. I will respond in more detail tomorrow morning when I wake up.



---

archive/issue_comments_324581.json:
```json
{
    "body": "<a id='comment:31'></a>Replying to [comment:28 egourgoulhon]:\n> Replying to [comment:27 tscrim]:\n> \n> Thanks for your comments/suggestions.\n> \n> > Some things from looking over the current structure:\n> > \n> > - I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.\n> > \n \n> \n> I am not sure an ABC would help here: this would make a clear distinction between the manifold and strict subsets of it (thus avoiding the very few tests `self is self._manifold`), but on the other hand, we need open strict subsets to be in the class `TopologicalManifolds`. \n\n\nThe diagram you have below is what I was thinking (at least the first 2 levels). This gives better separation of concerns and better distinguishes the two classes.\n\n> > - Maybe put the subsets into the `Subobjects` class and maybe consider not making it a facade?\n> > \n \n> \n> I had the impression that the facade feature is exactly what we need, since we can have the same point created from different facade parents by means of different charts: if `U` and `V` are two overelapping open subsets of manifold `M`, it may happen that the same point of `M` is declared in two different ways:\n> \n> ```\n>    p = U((x,y), chart=C1)\n>    q = V((u,v), chart=C2)\n> ```\n> Thanks to the facade mecanism, `p` and `q` will have the same parent: `M` and then it is possible to check whether `p == q`; this will hold if the coordinates `(x,y)` in chart `C1` correspond to coordinates `(u,v)` in chart `C2`. Is there something bad in using facade parents?\n\n\nIt depends on what you want the points associated with. If they are to be considered proper subsets of the manifold, where you want to do operations, then the point should know that it belongs to the subset. If it is really just reflecting a particular chart, then you probably should reconsider your entire class hierarchy because I think it shouldn't quack like a manifold in that case.\n\nIt really comes down to what you're doing mostly in the code. If you'd be doing a lot of conversions between points thought of as being in the subset and as in the manifold, then a facade is probably an okay way to go. If you care about associating the point with a particular subset, then it should not be a facade.\n\n> > - Should manifolds and their subsets be `UniqueRepresentation`? I understand that the name as the only input means they are essentially treated as variables, but it means you have to do things like `TopManifold._clear_cache_()` (which may be needed not just necessarily in doctests if one does this before the gc comes around).\n \n> \n> Actually, I don't see any use case (except for confusing the reader!) where one would define two different manifolds with the same name and same dimension over the same topological field. So `UniqueRepresentation` seems quite appropriate here. Moreover, I thought this is Sage's credo to have parents be `UniqueRepresentation`, cf. the phrase *You are encouraged to make your parent \"unique\"* in the tutorial [How to implement new algebraic structures in Sage](http://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#coercion-and-categories). Also, most parents in `src/sage/geometry` (in particular the hyperbolic plane) have `UniqueRepresentation`.\n\n\nThe hyperbolic plane works well because it is uniquely defined. Also not all parents are `UniqueRepresentations`, the reason why we do this is because of the coercion framework and speed. Identity checks are typically much faster than equality checks.\n\n> > However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.\n\n> \n> Why should we avoid `UniqueRepresentation`? It's true that manifolds are mutable as Python objects, since the main idea is to add charts (and vector frames for differentiable manifolds) \"on the fly\" (for, in a concrete calculation, charts are often defined from previous ones by some transition map that might depend on some computational result and therefore it is impossible to introduce all charts at the instantiation of the manifold object). But this mutability is \"secondary\": the primary attributes of a manifold being its dimension, its name and its base field. With respect to these, the manifold is immutable. The need for `_clear_cache_()` in some doctests seems a very small annoyment, with respect to the benefit of `UniqueRepresentation`, doesn't it ? (I am afraid I have not understood the non-doctest case involving the garbage collector that you mentioned)\n\n\nThis comes down to the manifold not being well-defined by its dimension, name, and base field. It also needs to be defined by its chart. I understand that giving two distinct manifolds the same name is bad mathematically, and you are reflecting that in your code. However what if I create a manifold `M`, then decide I want to create a new (and different) manifold `M` of the same dimension over the same base field? When I try to do this na\u00efvely, I get all of the previous chart information much to my surprise (the garbage collector this was more about temporary objects).",
    "created_at": "2015-10-28T15:04:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324581",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:31'></a>Replying to [comment:28 egourgoulhon]:
> Replying to [comment:27 tscrim]:
> 
> Thanks for your comments/suggestions.
> 
> > Some things from looking over the current structure:
> > 
> > - I would separate out parts of the subset class that applies to `Top(ological)Manifold` and `TopManifoldSubset` into an ABC (abstract base class) so you don't have to do things like `self is manifold`.
> > 
 
> 
> I am not sure an ABC would help here: this would make a clear distinction between the manifold and strict subsets of it (thus avoiding the very few tests `self is self._manifold`), but on the other hand, we need open strict subsets to be in the class `TopologicalManifolds`. 


The diagram you have below is what I was thinking (at least the first 2 levels). This gives better separation of concerns and better distinguishes the two classes.

> > - Maybe put the subsets into the `Subobjects` class and maybe consider not making it a facade?
> > 
 
> 
> I had the impression that the facade feature is exactly what we need, since we can have the same point created from different facade parents by means of different charts: if `U` and `V` are two overelapping open subsets of manifold `M`, it may happen that the same point of `M` is declared in two different ways:
> 
> ```
>    p = U((x,y), chart=C1)
>    q = V((u,v), chart=C2)
> ```
> Thanks to the facade mecanism, `p` and `q` will have the same parent: `M` and then it is possible to check whether `p == q`; this will hold if the coordinates `(x,y)` in chart `C1` correspond to coordinates `(u,v)` in chart `C2`. Is there something bad in using facade parents?


It depends on what you want the points associated with. If they are to be considered proper subsets of the manifold, where you want to do operations, then the point should know that it belongs to the subset. If it is really just reflecting a particular chart, then you probably should reconsider your entire class hierarchy because I think it shouldn't quack like a manifold in that case.

It really comes down to what you're doing mostly in the code. If you'd be doing a lot of conversions between points thought of as being in the subset and as in the manifold, then a facade is probably an okay way to go. If you care about associating the point with a particular subset, then it should not be a facade.

> > - Should manifolds and their subsets be `UniqueRepresentation`? I understand that the name as the only input means they are essentially treated as variables, but it means you have to do things like `TopManifold._clear_cache_()` (which may be needed not just necessarily in doctests if one does this before the gc comes around).
 
> 
> Actually, I don't see any use case (except for confusing the reader!) where one would define two different manifolds with the same name and same dimension over the same topological field. So `UniqueRepresentation` seems quite appropriate here. Moreover, I thought this is Sage's credo to have parents be `UniqueRepresentation`, cf. the phrase *You are encouraged to make your parent "unique"* in the tutorial [How to implement new algebraic structures in Sage](http://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#coercion-and-categories). Also, most parents in `src/sage/geometry` (in particular the hyperbolic plane) have `UniqueRepresentation`.


The hyperbolic plane works well because it is uniquely defined. Also not all parents are `UniqueRepresentations`, the reason why we do this is because of the coercion framework and speed. Identity checks are typically much faster than equality checks.

> > However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.

> 
> Why should we avoid `UniqueRepresentation`? It's true that manifolds are mutable as Python objects, since the main idea is to add charts (and vector frames for differentiable manifolds) "on the fly" (for, in a concrete calculation, charts are often defined from previous ones by some transition map that might depend on some computational result and therefore it is impossible to introduce all charts at the instantiation of the manifold object). But this mutability is "secondary": the primary attributes of a manifold being its dimension, its name and its base field. With respect to these, the manifold is immutable. The need for `_clear_cache_()` in some doctests seems a very small annoyment, with respect to the benefit of `UniqueRepresentation`, doesn't it ? (I am afraid I have not understood the non-doctest case involving the garbage collector that you mentioned)


This comes down to the manifold not being well-defined by its dimension, name, and base field. It also needs to be defined by its chart. I understand that giving two distinct manifolds the same name is bad mathematically, and you are reflecting that in your code. However what if I create a manifold `M`, then decide I want to create a new (and different) manifold `M` of the same dimension over the same base field? When I try to do this naïvely, I get all of the previous chart information much to my surprise (the garbage collector this was more about temporary objects).



---

archive/issue_comments_324582.json:
```json
{
    "body": "<a id='comment:32'></a>Replying to [comment:31 tscrim]:\n> \n> It really comes down to what you're doing mostly in the code. If you'd be doing a lot of conversions between points thought of as being in the subset and as in the manifold, then a facade is probably an okay way to go. If you care about associating the point with a particular subset, then it should not be a facade.\n\n\nI think we are precisely in the first case. In particular we do not care about associating the point with a particular subset (since many overlapping subsets can be introduced that contain the point and none of them is to be privileged with respect to the point). So I would say that we should use the facade.\n \n> \n> The hyperbolic plane works well because it is uniquely defined. Also not all parents are `UniqueRepresentations`, the reason why we do this is because of the coercion framework and speed. Identity checks are typically much faster than equality checks.\n\n\nThanks for these explanations.\n> \n> > > However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.\n\n> > \n> > Why should we avoid `UniqueRepresentation`? It's true that manifolds are mutable as Python objects, since the main idea is to add charts (and vector frames for differentiable manifolds) \"on the fly\" (for, in a concrete calculation, charts are often defined from previous ones by some transition map that might depend on some computational result and therefore it is impossible to introduce all charts at the instantiation of the manifold object). But this mutability is \"secondary\": the primary attributes of a manifold being its dimension, its name and its base field. With respect to these, the manifold is immutable. The need for `_clear_cache_()` in some doctests seems a very small annoyment, with respect to the benefit of `UniqueRepresentation`, doesn't it ? (I am afraid I have not understood the non-doctest case involving the garbage collector that you mentioned)\n\n> \n> This comes down to the manifold not being well-defined by its dimension, name, and base field. It also needs to be defined by its chart. \n\n\nIndeed. More precisely, a manifold is defined by its maximal atlas. But there is no way to represent the latter in Sage, nor in any computer system. Accordingly, we cannot check the equality of two manifolds. This is why equality by id seems reasonable here.\n\n> I understand that giving two distinct manifolds the same name is bad mathematically, and you are reflecting that in your code. However what if I create a manifold `M`, then decide I want to create a new (and different) manifold `M` of the same dimension over the same base field? When I try to do this na\u00efvely, I get all of the previous chart information much to my surprise (the garbage collector this was more about temporary objects).\n\n\nYou are right: a user may want to restart some computation by creating a manifold with the same name as that used previously. If he is doing so in the same session, the `UniqueRepresentation` behavior will return the previously created object. We cannot demand that the user runs `_clear_cache_()` before creating the manifold...",
    "created_at": "2015-10-28T21:00:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324582",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:32'></a>Replying to [comment:31 tscrim]:
> 
> It really comes down to what you're doing mostly in the code. If you'd be doing a lot of conversions between points thought of as being in the subset and as in the manifold, then a facade is probably an okay way to go. If you care about associating the point with a particular subset, then it should not be a facade.


I think we are precisely in the first case. In particular we do not care about associating the point with a particular subset (since many overlapping subsets can be introduced that contain the point and none of them is to be privileged with respect to the point). So I would say that we should use the facade.
 
> 
> The hyperbolic plane works well because it is uniquely defined. Also not all parents are `UniqueRepresentations`, the reason why we do this is because of the coercion framework and speed. Identity checks are typically much faster than equality checks.


Thanks for these explanations.
> 
> > > However the manifolds are essentially mutable, but by doing a `__hash__` which only depends upon the name(s) and dimension means this is okay (`__eq__` defaults to check by `is`). This would alleviate the need for `UniqueRepresentation`.

> > 
> > Why should we avoid `UniqueRepresentation`? It's true that manifolds are mutable as Python objects, since the main idea is to add charts (and vector frames for differentiable manifolds) "on the fly" (for, in a concrete calculation, charts are often defined from previous ones by some transition map that might depend on some computational result and therefore it is impossible to introduce all charts at the instantiation of the manifold object). But this mutability is "secondary": the primary attributes of a manifold being its dimension, its name and its base field. With respect to these, the manifold is immutable. The need for `_clear_cache_()` in some doctests seems a very small annoyment, with respect to the benefit of `UniqueRepresentation`, doesn't it ? (I am afraid I have not understood the non-doctest case involving the garbage collector that you mentioned)

> 
> This comes down to the manifold not being well-defined by its dimension, name, and base field. It also needs to be defined by its chart. 


Indeed. More precisely, a manifold is defined by its maximal atlas. But there is no way to represent the latter in Sage, nor in any computer system. Accordingly, we cannot check the equality of two manifolds. This is why equality by id seems reasonable here.

> I understand that giving two distinct manifolds the same name is bad mathematically, and you are reflecting that in your code. However what if I create a manifold `M`, then decide I want to create a new (and different) manifold `M` of the same dimension over the same base field? When I try to do this naïvely, I get all of the previous chart information much to my surprise (the garbage collector this was more about temporary objects).


You are right: a user may want to restart some computation by creating a manifold with the same name as that used previously. If he is doing so in the same session, the `UniqueRepresentation` behavior will return the previously created object. We cannot demand that the user runs `_clear_cache_()` before creating the manifold...



---

archive/issue_comments_324583.json:
```json
{
    "body": "<a id='comment:33'></a>Replying to [comment:32 egourgoulhon]:\n> Replying to [comment:31 tscrim]:\n> > It really comes down to what you're doing mostly in the code. If you'd be doing a lot of conversions between points thought of as being in the subset and as in the manifold, then a facade is probably an okay way to go. If you care about associating the point with a particular subset, then it should not be a facade.\n\n> \n> I think we are precisely in the first case. In particular we do not care about associating the point with a particular subset (since many overlapping subsets can be introduced that contain the point and none of them is to be privileged with respect to the point). So I would say that we should use the facade.\n\n\nThen we go with that.\n\n> > This comes down to the manifold not being well-defined by its dimension, name, and base field. It also needs to be defined by its chart. \n\n> \n> Indeed. More precisely, a manifold is defined by its maximal atlas. But there is no way to represent the latter in Sage, nor in any computer system. Accordingly, we cannot check the equality of two manifolds. This is why equality by id seems reasonable here.\n\n\nThen we are in agreement: equality by id.\n\n> > I understand that giving two distinct manifolds the same name is bad mathematically, and you are reflecting that in your code. However what if I create a manifold `M`, then decide I want to create a new (and different) manifold `M` of the same dimension over the same base field? When I try to do this na\u00efvely, I get all of the previous chart information much to my surprise (the garbage collector this was more about temporary objects).\n\n> \n> You are right: a user may want to restart some computation by creating a manifold with the same name as that used previously. If he is doing so in the same session, the `UniqueRepresentation` behavior will return the previously created object. We cannot demand that the user runs `_clear_cache_()` before creating the manifold...\n\n\nAs I outlined above, it should be easy enough to remove the `UniqueRepresentation` behavior and still retain the desirable behaviors such as hashability.",
    "created_at": "2015-10-31T15:34:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324583",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:33'></a>Replying to [comment:32 egourgoulhon]:
> Replying to [comment:31 tscrim]:
> > It really comes down to what you're doing mostly in the code. If you'd be doing a lot of conversions between points thought of as being in the subset and as in the manifold, then a facade is probably an okay way to go. If you care about associating the point with a particular subset, then it should not be a facade.

> 
> I think we are precisely in the first case. In particular we do not care about associating the point with a particular subset (since many overlapping subsets can be introduced that contain the point and none of them is to be privileged with respect to the point). So I would say that we should use the facade.


Then we go with that.

> > This comes down to the manifold not being well-defined by its dimension, name, and base field. It also needs to be defined by its chart. 

> 
> Indeed. More precisely, a manifold is defined by its maximal atlas. But there is no way to represent the latter in Sage, nor in any computer system. Accordingly, we cannot check the equality of two manifolds. This is why equality by id seems reasonable here.


Then we are in agreement: equality by id.

> > I understand that giving two distinct manifolds the same name is bad mathematically, and you are reflecting that in your code. However what if I create a manifold `M`, then decide I want to create a new (and different) manifold `M` of the same dimension over the same base field? When I try to do this naïvely, I get all of the previous chart information much to my surprise (the garbage collector this was more about temporary objects).

> 
> You are right: a user may want to restart some computation by creating a manifold with the same name as that used previously. If he is doing so in the same session, the `UniqueRepresentation` behavior will return the previously created object. We cannot demand that the user runs `_clear_cache_()` before creating the manifold...


As I outlined above, it should be easy enough to remove the `UniqueRepresentation` behavior and still retain the desirable behaviors such as hashability.



---

archive/issue_comments_324584.json:
```json
{
    "body": "<a id='comment:34'></a>Replying to [comment:33 tscrim]:\n> \n> As I outlined above, it should be easy enough to remove the `UniqueRepresentation` behavior and still retain the desirable behaviors such as hashability.\n\n\nI am on it and should push a new commit soon.",
    "created_at": "2015-10-31T15:39:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324584",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:34'></a>Replying to [comment:33 tscrim]:
> 
> As I outlined above, it should be easy enough to remove the `UniqueRepresentation` behavior and still retain the desirable behaviors such as hashability.


I am on it and should push a new commit soon.



---

archive/issue_comments_324585.json:
```json
{
    "body": "<a id='comment:35'></a>Replying to [comment:34 egourgoulhon]:\n> Replying to [comment:33 tscrim]:\n> > \n> > As I outlined above, it should be easy enough to remove the `UniqueRepresentation` behavior and still retain the desirable behaviors such as hashability.\n\n> \n> I am on it and should push a new commit soon. \n\n\nThanks. Also thank you for all your work on this.",
    "created_at": "2015-10-31T15:44:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324585",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:35'></a>Replying to [comment:34 egourgoulhon]:
> Replying to [comment:33 tscrim]:
> > 
> > As I outlined above, it should be easy enough to remove the `UniqueRepresentation` behavior and still retain the desirable behaviors such as hashability.

> 
> I am on it and should push a new commit soon. 


Thanks. Also thank you for all your work on this.



---

archive/issue_comments_324586.json:
```json
{
    "body": "Changing commit from \"6dec6d592a09e56921b9a761827309dd31ae2533\" to \"f342e03e7008831c4789b94b03674c1a0cbbf3a6\"",
    "created_at": "2015-11-01T20:26:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324586",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "6dec6d592a09e56921b9a761827309dd31ae2533" to "f342e03e7008831c4789b94b03674c1a0cbbf3a6"



---

archive/issue_comments_324587.json:
```json
{
    "body": "<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-11-01T20:26:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324587",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324588.json:
```json
{
    "body": "<a id='comment:37'></a>The above commit addresses some of the comments by Travis and Vincent:\n- The class `TopManifold` has been renamed `TopologicalManifold` and the class `TopManifoldSubset` has been renamed `TopologicalManifoldSubset`.\n- A function `Manifold` has been introduced as the unique entry point to construct manifolds (this is the only piece that is imported in the global namespace, as a lazy import).\n- Tests of `_element_constructor_` are performed by call to the parent.\n- The classes `TopologicalManifold`, `TopologicalManifoldSubset`,  `Chart` and `RealChart` do not longer inherit from `UniqueRepresentation`. Consequently, they have been provided with functions `__hash__`, `__eq__`, `__ne__` and `__reduce__` (the latter turned out to be necessary for correct pickling). In addition, the class `Chart` has been endowed with `__getstate__` and `__setstate__`.\n\nIt seemed necessary to implement a proper `__eq__`, i.e. not to have equality by id, since we cannot afford equality by id when relaxing the unique representation, otherwise the pickling test `loads(dumps(M)) == M` would failed, since obviously `id(loads(dumps(M))` differs from `id(M)`. \n\nOther issues mentionned by Travis have not been addressed yet:\n\n- need for an ABC for manifolds and their subsets, introduce a specific class for open subsets (currently they are dealt by class `TopologicalManifold`, with the attribute `self._manifold` representing the ambient manifold)\n- treatment of real and complex fields as base fields (i.e. avoiding to default to the finite precision representations `RR` and `CC`)",
    "created_at": "2015-11-01T21:03:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324588",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:37'></a>The above commit addresses some of the comments by Travis and Vincent:
- The class `TopManifold` has been renamed `TopologicalManifold` and the class `TopManifoldSubset` has been renamed `TopologicalManifoldSubset`.
- A function `Manifold` has been introduced as the unique entry point to construct manifolds (this is the only piece that is imported in the global namespace, as a lazy import).
- Tests of `_element_constructor_` are performed by call to the parent.
- The classes `TopologicalManifold`, `TopologicalManifoldSubset`,  `Chart` and `RealChart` do not longer inherit from `UniqueRepresentation`. Consequently, they have been provided with functions `__hash__`, `__eq__`, `__ne__` and `__reduce__` (the latter turned out to be necessary for correct pickling). In addition, the class `Chart` has been endowed with `__getstate__` and `__setstate__`.

It seemed necessary to implement a proper `__eq__`, i.e. not to have equality by id, since we cannot afford equality by id when relaxing the unique representation, otherwise the pickling test `loads(dumps(M)) == M` would failed, since obviously `id(loads(dumps(M))` differs from `id(M)`. 

Other issues mentionned by Travis have not been addressed yet:

- need for an ABC for manifolds and their subsets, introduce a specific class for open subsets (currently they are dealt by class `TopologicalManifold`, with the attribute `self._manifold` representing the ambient manifold)
- treatment of real and complex fields as base fields (i.e. avoiding to default to the finite precision representations `RR` and `CC`)



---

archive/issue_comments_324589.json:
```json
{
    "body": "<a id='comment:38'></a>Oh yea...pickling. Uggg...\n\nI worry that the current equality check is too general. Perhaps also for equality add a check to see if the current atlases are equal (or one is a subset of the other), which in turn would have to check equality on charts? Overall it is not pretty, but I would hope one is not checking equality of manifolds too often (and we can somewhat short circuit this by first checking `self is other` [which is also a general python recommendation]).",
    "created_at": "2015-11-02T04:21:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324589",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:38'></a>Oh yea...pickling. Uggg...

I worry that the current equality check is too general. Perhaps also for equality add a check to see if the current atlases are equal (or one is a subset of the other), which in turn would have to check equality on charts? Overall it is not pretty, but I would hope one is not checking equality of manifolds too often (and we can somewhat short circuit this by first checking `self is other` [which is also a general python recommendation]).



---

archive/issue_comments_324590.json:
```json
{
    "body": "<a id='comment:39'></a>Replying to [comment:38 tscrim]:\n> Oh yea...pickling. Uggg...\n> \n> I worry that the current equality check is too general. Perhaps also for equality add a check to see if the current atlases are equal (or one is a subset of the other), which in turn would have to check equality on charts? Overall it is not pretty, but I would hope one is not checking equality of manifolds too often \n\n\nUnfortunately yes: charts are used as dictionary keys for the coordinate expressions of scalar functions defined on the manifold (these functions will appear massively as the components of tensor fields), therefore one checks often equality of charts and the latter starts by checking the equality of manifolds on which they are defined. By the way, if we introduce the check of atlases in the manifold equality, there is a danger of endless loop: to compare charts, one first compare their domains, i.e. manifolds... To circumvent this, maybe we should introduce two comparison operators: a fast `__eq__`, which cheks only the name, dimension and base field and a more mathematically meaningful `is_isomorphic_to`, which checks in addition the atlases.",
    "created_at": "2015-11-02T08:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324590",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:39'></a>Replying to [comment:38 tscrim]:
> Oh yea...pickling. Uggg...
> 
> I worry that the current equality check is too general. Perhaps also for equality add a check to see if the current atlases are equal (or one is a subset of the other), which in turn would have to check equality on charts? Overall it is not pretty, but I would hope one is not checking equality of manifolds too often 


Unfortunately yes: charts are used as dictionary keys for the coordinate expressions of scalar functions defined on the manifold (these functions will appear massively as the components of tensor fields), therefore one checks often equality of charts and the latter starts by checking the equality of manifolds on which they are defined. By the way, if we introduce the check of atlases in the manifold equality, there is a danger of endless loop: to compare charts, one first compare their domains, i.e. manifolds... To circumvent this, maybe we should introduce two comparison operators: a fast `__eq__`, which cheks only the name, dimension and base field and a more mathematically meaningful `is_isomorphic_to`, which checks in addition the atlases.



---

archive/issue_comments_324591.json:
```json
{
    "body": "<a id='comment:40'></a>I've already noticed some important loss of performance due to the equality not being by id; I am afraid that for tensor computations this will become much worse. Moreover, a sophisticated equality check (either with `__eq__` or `is_isomorphic_to`) seems difficult to acheive: checking the equality of the user-defined atlases is definitevely not sufficient to assert the mathematical equality of two manifolds; one should compare the maximal atlases instead, which is impossible. For example, if one first construct S<sup>2</sup> with an atlas of two stereographic charts and then another S<sup>2</sup> with an atlas of two polar charts, the two atlases differ, while both objects represent the same manifold. There is also the issue of endless loop mentioned in comment:39. \n\nFor the above reasons, I am considering to revert to the `UniqueRepresentation` for manifolds. To solve the issue of the redefinition by the end user disccused in comment:32, we could have some handling of the cache in the function `Manifold`, so that\n\n```\n  M1 = Manifold(2, 'M')\n  M2 = Manifold(2, 'M')\n```\nwill construct two different objects. What do you think?",
    "created_at": "2015-11-03T10:31:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324591",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:40'></a>I've already noticed some important loss of performance due to the equality not being by id; I am afraid that for tensor computations this will become much worse. Moreover, a sophisticated equality check (either with `__eq__` or `is_isomorphic_to`) seems difficult to acheive: checking the equality of the user-defined atlases is definitevely not sufficient to assert the mathematical equality of two manifolds; one should compare the maximal atlases instead, which is impossible. For example, if one first construct S<sup>2</sup> with an atlas of two stereographic charts and then another S<sup>2</sup> with an atlas of two polar charts, the two atlases differ, while both objects represent the same manifold. There is also the issue of endless loop mentioned in comment:39. 

For the above reasons, I am considering to revert to the `UniqueRepresentation` for manifolds. To solve the issue of the redefinition by the end user disccused in comment:32, we could have some handling of the cache in the function `Manifold`, so that

```
  M1 = Manifold(2, 'M')
  M2 = Manifold(2, 'M')
```
will construct two different objects. What do you think?



---

archive/issue_comments_324592.json:
```json
{
    "body": "<a id='comment:41'></a>Replying to [comment:40 egourgoulhon]:\n> I've already noticed some important loss of performance due to the equality not being by id; I am afraid that for tensor computations this will become much worse.\n\n\nDid you have as the first lines of the `__eq__` being\n\n```\nif self is other:\n    return True\n```\nsince \"most\" equality checks should be by identity. Granted, we do lose some speed because this is a python check, as opposed to a cython check.\n\n> Moreover, a sophisticated equality check (either with `__eq__` or `is_isomorphic_to`) seems difficult to acheive: checking the equality of the user-defined atlases is definitevely not sufficient to assert the mathematical equality of two manifolds; one should compare the maximal atlases instead, which is impossible. For example, if one first construct S<sup>2</sup> with an atlas of two stereographic charts and then another S<sup>2</sup> with an atlas of two polar charts, the two atlases differ, while both objects represent the same manifold.\n\n\n`__eq__` does not have to represent mathematical equality; IIRC we already have examples of this in Sage, both when `__eq__` is weaker and stronger than mathematical equality (which often times people wish it could be isomorphism). So we are okay with making `__eq__` not reflect the mathematical equality.\n\n> There is also the issue of endless loop mentioned in comment:39. \n\n\nThe design reflects the mathematics as charts are morphism from **R**<sup>n</sup> -> *M* and that the manifold *M* is an abstract set of points. My proposal goes around the mathematical definition of a manifold as a set of points by saying the manifold *M* is defined by its charts. So this approach is definitely bad.\n\n> For the above reasons, I am considering to revert to the `UniqueRepresentation` for manifolds. To solve the issue of the redefinition by the end user disccused in comment:32, we could have some handling of the cache in the function `Manifold`, so that\n> \n> ```\n>   M1 = Manifold(2, 'M')\n>   M2 = Manifold(2, 'M')\n> ```\n> will construct two different objects. What do you think?\n\n\nI worry that this will cause subtle issues with pickling. For example, if we clear the cache when creating `M2`, then `loads(dumps(M1))` will probably not equal `M1`, but instead equal `M2`. I haven't checked if this actually happens.\n\nThere are a few different options that I see at this point.\n\n- Drop pickling `==` support and use `sage.misc.fast_methods.WithEqualityById` (this will get your speed back). However we could get close by implementing pickling as saving the current atlas.\n- Go back to `UniqueRepresentation`, but also have it additionally keyed by the time it was created:\n  {{{\nsage: import time\nsage: time.time()\n1446566813.121567\n  }}}\n  You could do this by having\n  {{{\n`@`staticmethod\ndef __classcall__(cls, dim, name, latex, R, time_key=None):\n    if time_key is None:\n       from time import time\n       time_key = time()\n    return super(TopologicalManifold, cls).__classcall__(cls, dim, latex, R, time_key=time_key)\n\ndef __init__(self, dim, name, latex, R, time_key):\n    # Just ignore the time_key input\n  }}}\n  (or doing it via a `UniqueFactory`).\n- Warn the user that they can only create one manifold of a given (latex) name of a given dimension over a given field.\n- Figure out some other way to better uniquely specify a manifold.\n- Ask someone else, like Jeroen, Simon, Volker, and/or sage-devel, for other options.\n\nPersonally I would go for first one since pickling within a session is, I believe, usually not needed/used.",
    "created_at": "2015-11-03T16:22:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324592",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:41'></a>Replying to [comment:40 egourgoulhon]:
> I've already noticed some important loss of performance due to the equality not being by id; I am afraid that for tensor computations this will become much worse.


Did you have as the first lines of the `__eq__` being

```
if self is other:
    return True
```
since "most" equality checks should be by identity. Granted, we do lose some speed because this is a python check, as opposed to a cython check.

> Moreover, a sophisticated equality check (either with `__eq__` or `is_isomorphic_to`) seems difficult to acheive: checking the equality of the user-defined atlases is definitevely not sufficient to assert the mathematical equality of two manifolds; one should compare the maximal atlases instead, which is impossible. For example, if one first construct S<sup>2</sup> with an atlas of two stereographic charts and then another S<sup>2</sup> with an atlas of two polar charts, the two atlases differ, while both objects represent the same manifold.


`__eq__` does not have to represent mathematical equality; IIRC we already have examples of this in Sage, both when `__eq__` is weaker and stronger than mathematical equality (which often times people wish it could be isomorphism). So we are okay with making `__eq__` not reflect the mathematical equality.

> There is also the issue of endless loop mentioned in comment:39. 


The design reflects the mathematics as charts are morphism from **R**<sup>n</sup> -> *M* and that the manifold *M* is an abstract set of points. My proposal goes around the mathematical definition of a manifold as a set of points by saying the manifold *M* is defined by its charts. So this approach is definitely bad.

> For the above reasons, I am considering to revert to the `UniqueRepresentation` for manifolds. To solve the issue of the redefinition by the end user disccused in comment:32, we could have some handling of the cache in the function `Manifold`, so that
> 
> ```
>   M1 = Manifold(2, 'M')
>   M2 = Manifold(2, 'M')
> ```
> will construct two different objects. What do you think?


I worry that this will cause subtle issues with pickling. For example, if we clear the cache when creating `M2`, then `loads(dumps(M1))` will probably not equal `M1`, but instead equal `M2`. I haven't checked if this actually happens.

There are a few different options that I see at this point.

- Drop pickling `==` support and use `sage.misc.fast_methods.WithEqualityById` (this will get your speed back). However we could get close by implementing pickling as saving the current atlas.
- Go back to `UniqueRepresentation`, but also have it additionally keyed by the time it was created:
  {{{
sage: import time
sage: time.time()
1446566813.121567
  }}}
  You could do this by having
  {{{
`@`staticmethod
def __classcall__(cls, dim, name, latex, R, time_key=None):
    if time_key is None:
       from time import time
       time_key = time()
    return super(TopologicalManifold, cls).__classcall__(cls, dim, latex, R, time_key=time_key)

def __init__(self, dim, name, latex, R, time_key):
    # Just ignore the time_key input
  }}}
  (or doing it via a `UniqueFactory`).
- Warn the user that they can only create one manifold of a given (latex) name of a given dimension over a given field.
- Figure out some other way to better uniquely specify a manifold.
- Ask someone else, like Jeroen, Simon, Volker, and/or sage-devel, for other options.

Personally I would go for first one since pickling within a session is, I believe, usually not needed/used.



---

archive/issue_comments_324593.json:
```json
{
    "body": "<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-11-03T23:30:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324593",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324594.json:
```json
{
    "body": "Changing commit from \"f342e03e7008831c4789b94b03674c1a0cbbf3a6\" to \"902908b41a95d3455bfcc497997ad2054c530a96\"",
    "created_at": "2015-11-03T23:30:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324594",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "f342e03e7008831c4789b94b03674c1a0cbbf3a6" to "902908b41a95d3455bfcc497997ad2054c530a96"



---

archive/issue_comments_324595.json:
```json
{
    "body": "<a id='comment:43'></a>Replying to [comment:41 tscrim]:\n> Replying to [comment:40 egourgoulhon]:\n> > I've already noticed some important loss of performance due to the equality not being by id; I am afraid that for tensor computations this will become much worse.\n\n> \n> Did you have as the first lines of the `__eq__` being\n> \n> ```\n> if self is other:\n>     return True\n> ```\n\n\nActually no (except for points).\n> since \"most\" equality checks should be by identity. \n\n\nWell, as soon as we have more than two charts on a manifold, this is no longer true.\n\n> Granted, we do lose some speed because this is a python check, as opposed to a cython check.\n> \n\n\n> `__eq__` does not have to represent mathematical equality; IIRC we already have examples of this in Sage, both when `__eq__` is weaker and stronger than mathematical equality (which often times people wish it could be isomorphism). So we are okay with making `__eq__` not reflect the mathematical equality.\n\n\nOK. \n \n> > For the above reasons, I am considering to revert to the `UniqueRepresentation` for manifolds. To solve the issue of the redefinition by the end user disccused in comment:32, we could have some handling of the cache in the function `Manifold`, so that\n> > \n> > ```\n> >   M1 = Manifold(2, 'M')\n> >   M2 = Manifold(2, 'M')\n> > ```\n> > will construct two different objects. What do you think?\n\n> \n> I worry that this will cause subtle issues with pickling. For example, if we clear the cache when creating `M2`, then `loads(dumps(M1))` will probably not equal `M1`, but instead equal `M2`. I haven't checked if this actually happens.\n\n\nThanks for pointing this, I think you are right. \n\n> \n> There are a few different options that I see at this point.\n> \n> - Drop pickling `==` support and use `sage.misc.fast_methods.WithEqualityById` (this will get your speed back). However we could get close by implementing pickling as saving the current atlas.\n\n\nI am quite reluctant to drop pickling `==` support, although, as you say, pickling within a session is usually not needed/used. This would break all `TestSuite()` tests, except of course if we run them with `skip='_test_pickling'`. \n\n> - Go back to `UniqueRepresentation`, but also have it additionally keyed by the time it was created:\n>   {{{\n> sage: import time\n> sage: time.time()\n> 1446566813.121567\n>   }}}\n>   You could do this by having\n>   {{{\n> `@`staticmethod\n> def __classcall__(cls, dim, name, latex, R, time_key=None):\n>     if time_key is None:\n>        from time import time\n>        time_key = time()\n>     return super(TopologicalManifold, cls).__classcall__(cls, dim, latex, R, time_key=time_key)\n> \n> def __init__(self, dim, name, latex, R, time_key):\n>     # Just ignore the time_key input\n>   }}}\n>   (or doing it via a `UniqueFactory`).\n\n\nI like very much this one; thanks a lot for suggesting it! I have implemented it in the above commit, with a small modification: I have not redefined `TopologicalManifold.__classcall__` (which  is inherited from `UniqueRepresentation`), instead I have simply set the time tag in the function `Manifold`. Everything works well: see the rubric \"Reusability of the manifold name\" in the documentation of the function `Manifold`. \n\n> - Ask someone else, like Jeroen, Simon, Volker, and/or sage-devel, for other options.\n\n\nGood idea, I will.",
    "created_at": "2015-11-03T23:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324595",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:43'></a>Replying to [comment:41 tscrim]:
> Replying to [comment:40 egourgoulhon]:
> > I've already noticed some important loss of performance due to the equality not being by id; I am afraid that for tensor computations this will become much worse.

> 
> Did you have as the first lines of the `__eq__` being
> 
> ```
> if self is other:
>     return True
> ```


Actually no (except for points).
> since "most" equality checks should be by identity. 


Well, as soon as we have more than two charts on a manifold, this is no longer true.

> Granted, we do lose some speed because this is a python check, as opposed to a cython check.
> 


> `__eq__` does not have to represent mathematical equality; IIRC we already have examples of this in Sage, both when `__eq__` is weaker and stronger than mathematical equality (which often times people wish it could be isomorphism). So we are okay with making `__eq__` not reflect the mathematical equality.


OK. 
 
> > For the above reasons, I am considering to revert to the `UniqueRepresentation` for manifolds. To solve the issue of the redefinition by the end user disccused in comment:32, we could have some handling of the cache in the function `Manifold`, so that
> > 
> > ```
> >   M1 = Manifold(2, 'M')
> >   M2 = Manifold(2, 'M')
> > ```
> > will construct two different objects. What do you think?

> 
> I worry that this will cause subtle issues with pickling. For example, if we clear the cache when creating `M2`, then `loads(dumps(M1))` will probably not equal `M1`, but instead equal `M2`. I haven't checked if this actually happens.


Thanks for pointing this, I think you are right. 

> 
> There are a few different options that I see at this point.
> 
> - Drop pickling `==` support and use `sage.misc.fast_methods.WithEqualityById` (this will get your speed back). However we could get close by implementing pickling as saving the current atlas.


I am quite reluctant to drop pickling `==` support, although, as you say, pickling within a session is usually not needed/used. This would break all `TestSuite()` tests, except of course if we run them with `skip='_test_pickling'`. 

> - Go back to `UniqueRepresentation`, but also have it additionally keyed by the time it was created:
>   {{{
> sage: import time
> sage: time.time()
> 1446566813.121567
>   }}}
>   You could do this by having
>   {{{
> `@`staticmethod
> def __classcall__(cls, dim, name, latex, R, time_key=None):
>     if time_key is None:
>        from time import time
>        time_key = time()
>     return super(TopologicalManifold, cls).__classcall__(cls, dim, latex, R, time_key=time_key)
> 
> def __init__(self, dim, name, latex, R, time_key):
>     # Just ignore the time_key input
>   }}}
>   (or doing it via a `UniqueFactory`).


I like very much this one; thanks a lot for suggesting it! I have implemented it in the above commit, with a small modification: I have not redefined `TopologicalManifold.__classcall__` (which  is inherited from `UniqueRepresentation`), instead I have simply set the time tag in the function `Manifold`. Everything works well: see the rubric "Reusability of the manifold name" in the documentation of the function `Manifold`. 

> - Ask someone else, like Jeroen, Simon, Volker, and/or sage-devel, for other options.


Good idea, I will.



---

archive/issue_comments_324596.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,22 @@\n+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. \n+\n+This tickets implements the following Python classes:\n+\n+- `TopologicalManifold`: topological manifold over a topological field *K*\n+- `TopologicalManifoldPoint`: point in a topological manifold\n+- `TopologicalManifoldSubset`: generic subset of a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**).\n+\n+**Documentation**:\n+The reference manual is produced by\n+`sage -docbuild reference/manifolds html`\n+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/\n+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).\n \n \n Author: Eric Gourgoulhon\n``````\n",
    "created_at": "2015-11-04T07:26:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324596",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,22 @@
+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. 
+
+This tickets implements the following Python classes:
+
+- `TopologicalManifold`: topological manifold over a topological field *K*
+- `TopologicalManifoldPoint`: point in a topological manifold
+- `TopologicalManifoldSubset`: generic subset of a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**).
+
+**Documentation**:
+The reference manual is produced by
+`sage -docbuild reference/manifolds html`
+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/
+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).
 
 
 Author: Eric Gourgoulhon
``````




---

archive/issue_comments_324597.json:
```json
{
    "body": "<a id='comment:45'></a>Replying to [comment:37 egourgoulhon]:\n>\n> It seemed necessary to implement a proper `__eq__`, i.e. not to have equality by id, since we cannot afford equality by id when relaxing the unique representation, otherwise the pickling test `loads(dumps(M)) == M` would failed, since obviously `id(loads(dumps(M))` differs from `id(M)`. \n\n\nCan't you just drop that test? I don't think it's something that has to be true:\n\n```\nsage: A=object()\nsage: loads(dumps(A)) == A\nFalse\n```",
    "created_at": "2015-11-05T01:01:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324597",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:45'></a>Replying to [comment:37 egourgoulhon]:
>
> It seemed necessary to implement a proper `__eq__`, i.e. not to have equality by id, since we cannot afford equality by id when relaxing the unique representation, otherwise the pickling test `loads(dumps(M)) == M` would failed, since obviously `id(loads(dumps(M))` differs from `id(M)`. 


Can't you just drop that test? I don't think it's something that has to be true:

```
sage: A=object()
sage: loads(dumps(A)) == A
False
```



---

archive/issue_comments_324598.json:
```json
{
    "body": "<a id='comment:46'></a>Replying to [comment:45 nbruin]:\n> Replying to [comment:37 egourgoulhon]:\n> >\n> > It seemed necessary to implement a proper `__eq__`, i.e. not to have equality by id, since we cannot afford equality by id when relaxing the unique representation, otherwise the pickling test `loads(dumps(M)) == M` would failed, since obviously `id(loads(dumps(M))` differs from `id(M)`. \n\n> \n> Can't you just drop that test? I don't think it's something that has to be true:\n\n\nWell actually this is part of the `_test_pickling` method, as defined in `sage/structure/sage_object.pyx`. So shall we run the test suite as `TestSuite(M).run(skip='_test_pickling')` or shall we redefine `_test_pickling`?",
    "created_at": "2015-11-05T09:34:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324598",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:46'></a>Replying to [comment:45 nbruin]:
> Replying to [comment:37 egourgoulhon]:
> >
> > It seemed necessary to implement a proper `__eq__`, i.e. not to have equality by id, since we cannot afford equality by id when relaxing the unique representation, otherwise the pickling test `loads(dumps(M)) == M` would failed, since obviously `id(loads(dumps(M))` differs from `id(M)`. 

> 
> Can't you just drop that test? I don't think it's something that has to be true:


Well actually this is part of the `_test_pickling` method, as defined in `sage/structure/sage_object.pyx`. So shall we run the test suite as `TestSuite(M).run(skip='_test_pickling')` or shall we redefine `_test_pickling`?



---

archive/issue_comments_324599.json:
```json
{
    "body": "<a id='comment:47'></a>There is no reason to write ugly stuff like\n\n```\nself.__eq__(other)\n```\nand\n\n```\nfoo.__hash__()\n```\n\nThe alternatives\n\n```\nself == other\n```\nand\n\n```\nhash(foo)\n```\nare easier to read and faster.",
    "created_at": "2015-11-05T11:10:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324599",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:47'></a>There is no reason to write ugly stuff like

```
self.__eq__(other)
```
and

```
foo.__hash__()
```

The alternatives

```
self == other
```
and

```
hash(foo)
```
are easier to read and faster.



---

archive/issue_comments_324600.json:
```json
{
    "body": "<a id='comment:48'></a>In think this also holds for `type(foo)` instead if `foo.__class__` but I'm not 100% sure if those are really equivalent.",
    "created_at": "2015-11-05T11:12:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324600",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:48'></a>In think this also holds for `type(foo)` instead if `foo.__class__` but I'm not 100% sure if those are really equivalent.



---

archive/issue_comments_324601.json:
```json
{
    "body": "<a id='comment:49'></a>Replying to [comment:47 jdemeyer]:\n> There is no reason to write ugly stuff like\n> \n> ```\n> self.__eq__(other)\n> ```\n> and\n> \n> ```\n> foo.__hash__()\n> ```\n> \n> The alternatives\n> \n> ```\n> self == other\n> ```\n> and\n> \n> ```\n> hash(foo)\n> ```\n> are easier to read and faster.\n\n\nOK I will change this. Thanks.",
    "created_at": "2015-11-05T12:45:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324601",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:49'></a>Replying to [comment:47 jdemeyer]:
> There is no reason to write ugly stuff like
> 
> ```
> self.__eq__(other)
> ```
> and
> 
> ```
> foo.__hash__()
> ```
> 
> The alternatives
> 
> ```
> self == other
> ```
> and
> 
> ```
> hash(foo)
> ```
> are easier to read and faster.


OK I will change this. Thanks.



---

archive/issue_comments_324602.json:
```json
{
    "body": "<a id='comment:50'></a>Replying to [comment:48 jdemeyer]:\n> In think this also holds for `type(foo)` instead if `foo.__class__` but I'm not 100% sure if those are really equivalent.\n\n\nFrom [this link](http://stackoverflow.com/questions/1060499/difference-between-typeobj-and-obj-class) and [that one](http://stackoverflow.com/questions/10386166/python-self-class-vs-typeself), it seems that for Python new-style classes (i.e. the only classes used in Sage), `type(foo)` is fully equivalent to `foo.__class__` and it is indeed best practice to use `type(foo)`.",
    "created_at": "2015-11-05T13:00:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324602",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:50'></a>Replying to [comment:48 jdemeyer]:
> In think this also holds for `type(foo)` instead if `foo.__class__` but I'm not 100% sure if those are really equivalent.


From [this link](http://stackoverflow.com/questions/1060499/difference-between-typeobj-and-obj-class) and [that one](http://stackoverflow.com/questions/10386166/python-self-class-vs-typeself), it seems that for Python new-style classes (i.e. the only classes used in Sage), `type(foo)` is fully equivalent to `foo.__class__` and it is indeed best practice to use `type(foo)`.



---

archive/issue_comments_324603.json:
```json
{
    "body": "Changing commit from \"902908b41a95d3455bfcc497997ad2054c530a96\" to \"252e616cc053a3b76ee563282222507cd78c9fb8\"",
    "created_at": "2015-11-09T10:16:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324603",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "902908b41a95d3455bfcc497997ad2054c530a96" to "252e616cc053a3b76ee563282222507cd78c9fb8"



---

archive/issue_comments_324604.json:
```json
{
    "body": "<a id='comment:51'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-11-09T10:16:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324604",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:51'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324605.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,22 @@\n+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. \n+\n+This tickets implements the following Python classes:\n+\n+- `TopologicalManifold`: topological manifold over a topological field *K*\n+- `TopologicalManifoldPoint`: point in a topological manifold\n+- `TopologicalManifoldSubset`: generic subset of a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.\n+\n+**Documentation**:\n+The reference manual is produced by\n+`sage -docbuild reference/manifolds html`\n+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/\n+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).\n \n \n Author: Eric Gourgoulhon\n``````\n",
    "created_at": "2015-11-09T10:46:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324605",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,22 @@
+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. 
+
+This tickets implements the following Python classes:
+
+- `TopologicalManifold`: topological manifold over a topological field *K*
+- `TopologicalManifoldPoint`: point in a topological manifold
+- `TopologicalManifoldSubset`: generic subset of a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.
+
+**Documentation**:
+The reference manual is produced by
+`sage -docbuild reference/manifolds html`
+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/
+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).
 
 
 Author: Eric Gourgoulhon
``````




---

archive/issue_comments_324606.json:
```json
{
    "body": "<a id='comment:52'></a>The above commit takes into account [this discussion on sage-devel](https://groups.google.com/forum/#!topic/sage-devel/Vzfj1haZHho), as well as the first recommendation of Travis in comment:41 : it removes `UniqueRepresentation` for manifolds and charts, leaving only `WithEqualityById`. Some methods `_test_pickling` have been introduced. They are weaker than `SageObject._test_pickling` in the sense that they do not demand `loads(dumps(M)) == M` (which equality-by-id forbids without any unique representation). However, these local `_test_pickling` methods perform non trivial tests: they guarantee that `loads(dumps(M))` proceeds without any error and they check the identity of some characteristics between the unpickled object and the original one. All the test suites are passed.\n\nIn addition the above commit takes into account the recommendation of Jeroen in comment:49.",
    "created_at": "2015-11-09T10:46:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324606",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:52'></a>The above commit takes into account [this discussion on sage-devel](https://groups.google.com/forum/#!topic/sage-devel/Vzfj1haZHho), as well as the first recommendation of Travis in comment:41 : it removes `UniqueRepresentation` for manifolds and charts, leaving only `WithEqualityById`. Some methods `_test_pickling` have been introduced. They are weaker than `SageObject._test_pickling` in the sense that they do not demand `loads(dumps(M)) == M` (which equality-by-id forbids without any unique representation). However, these local `_test_pickling` methods perform non trivial tests: they guarantee that `loads(dumps(M))` proceeds without any error and they check the identity of some characteristics between the unpickled object and the original one. All the test suites are passed.

In addition the above commit takes into account the recommendation of Jeroen in comment:49.



---

archive/issue_comments_324607.json:
```json
{
    "body": "<a id='comment:53'></a>Replying to [comment:27 tscrim]:\n> \n> - I don't quite agree with checking `self._field == RR` for real charts as the precision should not matter. I would check `isinstance(self._field, RealField)` instead. Granted, we probably should have a function that checks against all known real field implementations...\n> \n> - In a similar vein, I don't like the input of `'real'` to `RR` (and `'complex'` to `CC`). I would make the user be explicit about what they want unless you are doing to do some special handling to make this pass special arguments to an underlying `SR` implementation.\n\n\nActually, the precision is not used in the current setting, so neither `RR` nor `RealField` is really necessary. `RR` was used as a substitute for the true real field, which cannot be represented in the computer. Looking further, why not using Sage's `RealLazyField` for this? It seems that it is intended to be closer to the true **R**. One drawback is that we have (for the moment)\n\n```\nsage: RLF in Fields().Topological()\nFalse\n```\nSo `RLF` cannot be passed to the manifold constructor. \n\nThe same considerations apply of course to `ComplexLazyField`.",
    "created_at": "2015-11-09T14:08:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324607",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:53'></a>Replying to [comment:27 tscrim]:
> 
> - I don't quite agree with checking `self._field == RR` for real charts as the precision should not matter. I would check `isinstance(self._field, RealField)` instead. Granted, we probably should have a function that checks against all known real field implementations...
> 
> - In a similar vein, I don't like the input of `'real'` to `RR` (and `'complex'` to `CC`). I would make the user be explicit about what they want unless you are doing to do some special handling to make this pass special arguments to an underlying `SR` implementation.


Actually, the precision is not used in the current setting, so neither `RR` nor `RealField` is really necessary. `RR` was used as a substitute for the true real field, which cannot be represented in the computer. Looking further, why not using Sage's `RealLazyField` for this? It seems that it is intended to be closer to the true **R**. One drawback is that we have (for the moment)

```
sage: RLF in Fields().Topological()
False
```
So `RLF` cannot be passed to the manifold constructor. 

The same considerations apply of course to `ComplexLazyField`.



---

archive/issue_comments_324608.json:
```json
{
    "body": "<a id='comment:54'></a>What we need is a category or ABC of realizations of the real field that allows us to set things like the category across the board and give us ways to tell a manifold is over the real numbers. Although perhaps in this case we can just handle the strings `\"real\"` and `\"complex\"` and have them default to the category of `Manifolds(RR)` and `Manifolds(CC)`.",
    "created_at": "2015-11-09T14:12:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324608",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:54'></a>What we need is a category or ABC of realizations of the real field that allows us to set things like the category across the board and give us ways to tell a manifold is over the real numbers. Although perhaps in this case we can just handle the strings `"real"` and `"complex"` and have them default to the category of `Manifolds(RR)` and `Manifolds(CC)`.



---

archive/issue_comments_324609.json:
```json
{
    "body": "<a id='comment:55'></a>Replying to [comment:54 tscrim]:\n> What we need is a category or ABC of realizations of the real field that allows us to set things like the category across the board and give us ways to tell a manifold is over the real numbers. Although perhaps in this case we can just handle the strings `\"real\"` and `\"complex\"` and have them default to the category of `Manifolds(RR)` and `Manifolds(CC)`.\n\n\nYes, for the time being, we could have two attributes in the manifold class:\n- `_field_type`, a string with values `'real'`, `'complex'` or `'other'`, which is the thing that is checked against to know if we are dealing with e.g. a real manifold; for instance, to decide whether the charts are constructed in the subclass `RealChart` of the generic class `Chart`. \n- `_field`, which contains the field for the manifold category; it could default to `RR` for `_field_type == 'real'`.\nDo you agree?",
    "created_at": "2015-11-10T06:52:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324609",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:55'></a>Replying to [comment:54 tscrim]:
> What we need is a category or ABC of realizations of the real field that allows us to set things like the category across the board and give us ways to tell a manifold is over the real numbers. Although perhaps in this case we can just handle the strings `"real"` and `"complex"` and have them default to the category of `Manifolds(RR)` and `Manifolds(CC)`.


Yes, for the time being, we could have two attributes in the manifold class:
- `_field_type`, a string with values `'real'`, `'complex'` or `'other'`, which is the thing that is checked against to know if we are dealing with e.g. a real manifold; for instance, to decide whether the charts are constructed in the subclass `RealChart` of the generic class `Chart`. 
- `_field`, which contains the field for the manifold category; it could default to `RR` for `_field_type == 'real'`.
Do you agree?



---

archive/issue_comments_324610.json:
```json
{
    "body": "<a id='comment:56'></a>Replying to [comment:55 egourgoulhon]:\n> Replying to [comment:54 tscrim]:\n> > What we need is a category or ABC of realizations of the real field that allows us to set things like the category across the board and give us ways to tell a manifold is over the real numbers. Although perhaps in this case we can just handle the strings `\"real\"` and `\"complex\"` and have them default to the category of `Manifolds(RR)` and `Manifolds(CC)`.\n\n> \n> Yes, for the time being, we could have two attributes in the manifold class:\n> - `_field_type`, a string with values `'real'`, `'complex'` or `'other'`, which is the thing that is checked against to know if we are dealing with e.g. a real manifold; for instance, to decide whether the charts are constructed in the subclass `RealChart` of the generic class `Chart`. \n> - `_field`, which contains the field for the manifold category; it could default to `RR` for `_field_type == 'real'`\n> Do you agree?\n\n\nYes that sounds like a good plan along with some simple type checking for default values of `_field_type` against `RealField` and `ComplexField` since (IMO) these are what most users will use for the reals and complexes.",
    "created_at": "2015-11-12T14:55:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324610",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:56'></a>Replying to [comment:55 egourgoulhon]:
> Replying to [comment:54 tscrim]:
> > What we need is a category or ABC of realizations of the real field that allows us to set things like the category across the board and give us ways to tell a manifold is over the real numbers. Although perhaps in this case we can just handle the strings `"real"` and `"complex"` and have them default to the category of `Manifolds(RR)` and `Manifolds(CC)`.

> 
> Yes, for the time being, we could have two attributes in the manifold class:
> - `_field_type`, a string with values `'real'`, `'complex'` or `'other'`, which is the thing that is checked against to know if we are dealing with e.g. a real manifold; for instance, to decide whether the charts are constructed in the subclass `RealChart` of the generic class `Chart`. 
> - `_field`, which contains the field for the manifold category; it could default to `RR` for `_field_type == 'real'`
> Do you agree?


Yes that sounds like a good plan along with some simple type checking for default values of `_field_type` against `RealField` and `ComplexField` since (IMO) these are what most users will use for the reals and complexes.



---

archive/issue_comments_324611.json:
```json
{
    "body": "<a id='comment:57'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-11-17T13:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324611",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:57'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324612.json:
```json
{
    "body": "Changing commit from \"252e616cc053a3b76ee563282222507cd78c9fb8\" to \"65186990b1106f89652107356b60faa048113915\"",
    "created_at": "2015-11-17T13:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324612",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "252e616cc053a3b76ee563282222507cd78c9fb8" to "65186990b1106f89652107356b60faa048113915"



---

archive/issue_comments_324613.json:
```json
{
    "body": "<a id='comment:58'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-11-19T19:54:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324613",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:58'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324614.json:
```json
{
    "body": "Changing commit from \"65186990b1106f89652107356b60faa048113915\" to \"0b08b114e03c063bd2e500ac900fd843fb12673b\"",
    "created_at": "2015-11-19T19:54:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324614",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "65186990b1106f89652107356b60faa048113915" to "0b08b114e03c063bd2e500ac900fd843fb12673b"



---

archive/issue_comments_324615.json:
```json
{
    "body": "<a id='comment:59'></a>I've done some small doc/review tweaks, but I was wondering if you were doing any changes to it, because I want to do some moderate refactoring to try and simplify the structure. In particular, you are not really using the subsets as facade parents as the points know what subset they belong to.",
    "created_at": "2015-11-19T19:57:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324615",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:59'></a>I've done some small doc/review tweaks, but I was wondering if you were doing any changes to it, because I want to do some moderate refactoring to try and simplify the structure. In particular, you are not really using the subsets as facade parents as the points know what subset they belong to.



---

archive/issue_comments_324616.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Travis Scrimshaw\"",
    "created_at": "2015-11-19T19:57:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324616",
    "user": "https://github.com/tscrim"
}
```

Changing reviewer from "" to "Travis Scrimshaw"



---

archive/issue_comments_324617.json:
```json
{
    "body": "<a id='comment:61'></a>Replying to [comment:59 tscrim]:\n> I've done some small doc/review tweaks,\n\n\nThanks for these changes!\n\n> but I was wondering if you were doing any changes to it,\n\n\nNo, not at the moment: I've worked on the subsequent tickets to check if the introduced changes (in particular the removal of unique representation) propagate smoothly. So far, so good...\n\n> because I want to do some moderate refactoring to try and simplify the structure. In particular, you are not really using the subsets as facade parents as the points know what subset they belong to.\n\n\nWell, it is true that points have an attribute called `_subset`, but this is a misnomer: `_creation_subset` would have been better. Indeed, from a pure mathematical point of view, a point of a manifold has no privileged subset attached to it. On the contrary, the point belongs to an infinite number of intersecting subsets. The attribute `_subset`, which is set to the facade parent at the point creation, is used only for fast check in the methods `TopologicalManifoldSubset.__contains__` and `TopologicalManifold.__contains__`. I think it can be suppressed, at the price of a small decrease in efficiency. Therefore, I still think that the facade mechanism is appropriate here: the creation subset (i.e. the facade parent) should not play any role: only the whole manifold matters. This is particularly true when dealing with tangent planes (ticket #19092): for a given point p, we do not want to have two tangent spaces, T_p M and T_p U with U open subset of M, do we?",
    "created_at": "2015-11-19T22:31:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324617",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:61'></a>Replying to [comment:59 tscrim]:
> I've done some small doc/review tweaks,


Thanks for these changes!

> but I was wondering if you were doing any changes to it,


No, not at the moment: I've worked on the subsequent tickets to check if the introduced changes (in particular the removal of unique representation) propagate smoothly. So far, so good...

> because I want to do some moderate refactoring to try and simplify the structure. In particular, you are not really using the subsets as facade parents as the points know what subset they belong to.


Well, it is true that points have an attribute called `_subset`, but this is a misnomer: `_creation_subset` would have been better. Indeed, from a pure mathematical point of view, a point of a manifold has no privileged subset attached to it. On the contrary, the point belongs to an infinite number of intersecting subsets. The attribute `_subset`, which is set to the facade parent at the point creation, is used only for fast check in the methods `TopologicalManifoldSubset.__contains__` and `TopologicalManifold.__contains__`. I think it can be suppressed, at the price of a small decrease in efficiency. Therefore, I still think that the facade mechanism is appropriate here: the creation subset (i.e. the facade parent) should not play any role: only the whole manifold matters. This is particularly true when dealing with tangent planes (ticket #19092): for a given point p, we do not want to have two tangent spaces, T_p M and T_p U with U open subset of M, do we?



---

archive/issue_comments_324618.json:
```json
{
    "body": "<a id='comment:62'></a>Replying to [comment:61 egourgoulhon]:\n> Replying to [comment:59 tscrim]:\n> > but I was wondering if you were doing any changes to it,\n\n> \n> No, not at the moment: I've worked on the subsequent tickets to check if the introduced changes (in particular the removal of unique representation) propagate smoothly. So far, so good...\n\n\nI will then start my refactoring. I will try to make every change as granular as possible in the commits so we can cherry-pick changes if you don't necessarily agree with them.\n\n> > because I want to do some moderate refactoring to try and simplify the structure. In particular, you are not really using the subsets as facade parents as the points know what subset they belong to.\n\n> \n> Well, it is true that points have an attribute called `_subset`, but this is a misnomer: `_creation_subset` would have been better. Indeed, from a pure mathematical point of view, a point of a manifold has no privileged subset attached to it. On the contrary, the point belongs to an infinite number of intersecting subsets. The attribute `_subset`, which is set to the facade parent at the point creation, is used only for fast check in the methods `TopologicalManifoldSubset.__contains__` and `TopologicalManifold.__contains__`. I think it can be suppressed, at the price of a small decrease in efficiency. Therefore, I still think that the facade mechanism is appropriate here: the creation subset (i.e. the facade parent) should not play any role: only the whole manifold matters. This is particularly true when dealing with tangent planes (ticket #19092): for a given point p, we do not want to have two tangent spaces, T_p M and T_p U with U open subset of M, do we? \n\n\nAt present, anytime an element is passed to the `_element_constructor_`, a new instance of that point is created. In a way, you are hacking the coercion/category framework by setting the parent of the point to be the manifold, so `M(p)` just shortcuts out to return `p`. The code tells me that points should be elements of a particular subset.\n\nFor the tangent spaces, you should coerce the point to the manifold in the distinguished chart as the input. You're going to have to do this anyways:\n\n```\nsage: M = Manifold(2, 'M', field='real', type='topological')\nsage: X.<x,y> = M.chart()\nsage: U.<u,v> = M.chart()\nsage: trans = X.transition_map(U, [x-2,y-2])\nsage: p = M.point((0,0), X)\nsage: p2 = M.point((-2,-2), U)\nsage: p == p2\nTrue\nsage: p is p2\nFalse\n```\n\nHow about this, let me make my changes and you can see what breaks or how much things slow down and we will use that to decide what we should do going forward. Does that sound reasonable to try? (In general, I would also argue that users should create their points from the manifold using one of those charts.)",
    "created_at": "2015-11-20T19:02:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324618",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:62'></a>Replying to [comment:61 egourgoulhon]:
> Replying to [comment:59 tscrim]:
> > but I was wondering if you were doing any changes to it,

> 
> No, not at the moment: I've worked on the subsequent tickets to check if the introduced changes (in particular the removal of unique representation) propagate smoothly. So far, so good...


I will then start my refactoring. I will try to make every change as granular as possible in the commits so we can cherry-pick changes if you don't necessarily agree with them.

> > because I want to do some moderate refactoring to try and simplify the structure. In particular, you are not really using the subsets as facade parents as the points know what subset they belong to.

> 
> Well, it is true that points have an attribute called `_subset`, but this is a misnomer: `_creation_subset` would have been better. Indeed, from a pure mathematical point of view, a point of a manifold has no privileged subset attached to it. On the contrary, the point belongs to an infinite number of intersecting subsets. The attribute `_subset`, which is set to the facade parent at the point creation, is used only for fast check in the methods `TopologicalManifoldSubset.__contains__` and `TopologicalManifold.__contains__`. I think it can be suppressed, at the price of a small decrease in efficiency. Therefore, I still think that the facade mechanism is appropriate here: the creation subset (i.e. the facade parent) should not play any role: only the whole manifold matters. This is particularly true when dealing with tangent planes (ticket #19092): for a given point p, we do not want to have two tangent spaces, T_p M and T_p U with U open subset of M, do we? 


At present, anytime an element is passed to the `_element_constructor_`, a new instance of that point is created. In a way, you are hacking the coercion/category framework by setting the parent of the point to be the manifold, so `M(p)` just shortcuts out to return `p`. The code tells me that points should be elements of a particular subset.

For the tangent spaces, you should coerce the point to the manifold in the distinguished chart as the input. You're going to have to do this anyways:

```
sage: M = Manifold(2, 'M', field='real', type='topological')
sage: X.<x,y> = M.chart()
sage: U.<u,v> = M.chart()
sage: trans = X.transition_map(U, [x-2,y-2])
sage: p = M.point((0,0), X)
sage: p2 = M.point((-2,-2), U)
sage: p == p2
True
sage: p is p2
False
```

How about this, let me make my changes and you can see what breaks or how much things slow down and we will use that to decide what we should do going forward. Does that sound reasonable to try? (In general, I would also argue that users should create their points from the manifold using one of those charts.)



---

archive/issue_comments_324619.json:
```json
{
    "body": "<a id='comment:63'></a>Replying to [comment:62 tscrim]:\n> \n> I will then start my refactoring. I will try to make every change as granular as possible in the commits so we can cherry-pick changes if you don't necessarily agree with them.\n> \n\n\nOK very good. \nHave you noticed that some doctests failed in the latest commit? This due to a typo: \"coordintes\" instead of \"coordinates\" in the replacement of\n\n```\n        if self._restrictions != []:\n            substitutions = dict(zip(self._xx, coordinates))\n```\nby \n\n```\n        if self._restrictions:\n            substitutions = {x: coordintes[i] for i,x in enumerate(self._xx)}\n```\nin `chart.py`. By the way, why is the second form better than the first one?\n\n> \n> How about this, let me make my changes and you can see what breaks or how much things slow down and we will use that to decide what we should do going forward. Does that sound reasonable to try? \n\nYes, absolutely!",
    "created_at": "2015-11-20T21:42:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324619",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:63'></a>Replying to [comment:62 tscrim]:
> 
> I will then start my refactoring. I will try to make every change as granular as possible in the commits so we can cherry-pick changes if you don't necessarily agree with them.
> 


OK very good. 
Have you noticed that some doctests failed in the latest commit? This due to a typo: "coordintes" instead of "coordinates" in the replacement of

```
        if self._restrictions != []:
            substitutions = dict(zip(self._xx, coordinates))
```
by 

```
        if self._restrictions:
            substitutions = {x: coordintes[i] for i,x in enumerate(self._xx)}
```
in `chart.py`. By the way, why is the second form better than the first one?

> 
> How about this, let me make my changes and you can see what breaks or how much things slow down and we will use that to decide what we should do going forward. Does that sound reasonable to try? 

Yes, absolutely!



---

archive/issue_comments_324620.json:
```json
{
    "body": "<a id='comment:64'></a>Replying to [comment:63 egourgoulhon]:\n\n> Have you noticed that some doctests failed in the latest commit? This due to a typo: \"coordintes\" instead of \"coordinates\" in the replacement of\n> \n> ```\n>         if self._restrictions != []:\n>             substitutions = dict(zip(self._xx, coordinates))\n> ```\n> by \n> \n> ```\n>         if self._restrictions:\n>             substitutions = {x: coordintes[i] for i,x in enumerate(self._xx)}\n> ```\n> in `chart.py`. By the way, why is the second form better than the first one?\n\n\nNo, but I didn't run all of the doctests before I pushed (in part because I was planning to do a lot more work).\n\nI think the latter is more clear in terms of code. I also thought I had run some timings before that the second was faster, but this is not the case:\n\n```\nsage: k,v = range(1000), range(1000)\nsage: %timeit d = dict(zip(k,v))\nThe slowest run took 5.50 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 58.4 \u00b5s per loop\nsage: %timeit d = {x: v[i] for i,x in enumerate(k)}\n```\nSo I will just revert this change (and any others like it).",
    "created_at": "2015-11-20T23:17:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324620",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:64'></a>Replying to [comment:63 egourgoulhon]:

> Have you noticed that some doctests failed in the latest commit? This due to a typo: "coordintes" instead of "coordinates" in the replacement of
> 
> ```
>         if self._restrictions != []:
>             substitutions = dict(zip(self._xx, coordinates))
> ```
> by 
> 
> ```
>         if self._restrictions:
>             substitutions = {x: coordintes[i] for i,x in enumerate(self._xx)}
> ```
> in `chart.py`. By the way, why is the second form better than the first one?


No, but I didn't run all of the doctests before I pushed (in part because I was planning to do a lot more work).

I think the latter is more clear in terms of code. I also thought I had run some timings before that the second was faster, but this is not the case:

```
sage: k,v = range(1000), range(1000)
sage: %timeit d = dict(zip(k,v))
The slowest run took 5.50 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 58.4 µs per loop
sage: %timeit d = {x: v[i] for i,x in enumerate(k)}
```
So I will just revert this change (and any others like it).



---

archive/issue_comments_324621.json:
```json
{
    "body": "<a id='comment:65'></a>Status report: Still working on refactoring. I have had to go through a few iterations, but I think I've arrived to a model which will scale nicely with the additional manifold structures of smooth/differentiable/(almost-)complex. I'm hoping to get it posted in a day or two.\n\nQuestion, do you know what are the main bottleneck operations are? I'm wondering if there would be any benefits from doing a partial cythonization- while I'm mucking around. If you don't know off-hand, then I wouldn't worry about it.",
    "created_at": "2015-11-25T05:38:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324621",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:65'></a>Status report: Still working on refactoring. I have had to go through a few iterations, but I think I've arrived to a model which will scale nicely with the additional manifold structures of smooth/differentiable/(almost-)complex. I'm hoping to get it posted in a day or two.

Question, do you know what are the main bottleneck operations are? I'm wondering if there would be any benefits from doing a partial cythonization- while I'm mucking around. If you don't know off-hand, then I wouldn't worry about it.



---

archive/issue_comments_324622.json:
```json
{
    "body": "<a id='comment:66'></a>Replying to [comment:65 tscrim]:\n> Status report: Still working on refactoring. I have had to go through a few iterations, but I think I've arrived to a model which will scale nicely with the additional manifold structures of smooth/differentiable/(almost-)complex. I'm hoping to get it posted in a day or two.\n> \n\n\nOK very good. Thank you for working on this!\n\n> Question, do you know what are the main bottleneck operations are? I'm wondering if there would be any benefits from doing a partial cythonization- while I'm mucking around. \n\n\nIn actual calculations, the main bottleneck is the simplification of symbolic expressions, which is performed in Lisp by Maxima. So I don't think that cythonizing would improve much here. On the other hand, parallelization over the components of vector fields (and more generally tensorial objects), as performed in #18100, helps a lot.",
    "created_at": "2015-11-25T07:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324622",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:66'></a>Replying to [comment:65 tscrim]:
> Status report: Still working on refactoring. I have had to go through a few iterations, but I think I've arrived to a model which will scale nicely with the additional manifold structures of smooth/differentiable/(almost-)complex. I'm hoping to get it posted in a day or two.
> 


OK very good. Thank you for working on this!

> Question, do you know what are the main bottleneck operations are? I'm wondering if there would be any benefits from doing a partial cythonization- while I'm mucking around. 


In actual calculations, the main bottleneck is the simplification of symbolic expressions, which is performed in Lisp by Maxima. So I don't think that cythonizing would improve much here. On the other hand, parallelization over the components of vector fields (and more generally tensorial objects), as performed in #18100, helps a lot.



---

archive/issue_comments_324623.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-11-25T21:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324623",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_324624.json:
```json
{
    "body": "Changing branch from \"public/manifolds/top_manif_basics\" to \"u/tscrim/top_manifolds_refactor\"",
    "created_at": "2015-11-25T21:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324624",
    "user": "https://github.com/tscrim"
}
```

Changing branch from "public/manifolds/top_manif_basics" to "u/tscrim/top_manifolds_refactor"



---

archive/issue_comments_324625.json:
```json
{
    "body": "<a id='comment:67'></a>Okay, I've refactored the code and it works up to \"trivial\" doctest failures. So almost all functionality on the outside hasn't changed, but internally, a lot of the logic within each function has changed at the cost of a slightly more complex class hierarchy (there might even be some more places to streamline things around too). Something else to do would be to define coercions between the respective subsets, but that we can do on a follow up since these are just sets at this point.\n\nThe biggest thing to note is that I have separated out the structure of the manifold into a separate class. This has several distinct advantages:\n\n- It has better encapsulation of data, which should result in fewer copies of the defining data needed and fewer duplication of functions.\n- It could allow us to strength/weaken the structure on the manifold dynamically.\n- We might only need to have one manifold class and one subset class, that way we don't have to duplicate documentation.\n\nThe main drawback I see at the point is we don't expose the attributes of the structure (e.g., the differential order) directly from the manifold instance. However, if we want this behavior, then we can attach the appropriate data as (hidden) (class) attributes to keep some of the modularity; it just results in more classes.\n\nI didn't want to change documentation until I knew you approved of this refactoring (or the alternative proposed above). Please tell me what you think and how you feel it fits with the differentiable manifolds part. I hope this does not cause too much trouble with rebasing.\n\n---\nNew commits:",
    "created_at": "2015-11-25T21:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324625",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:67'></a>Okay, I've refactored the code and it works up to "trivial" doctest failures. So almost all functionality on the outside hasn't changed, but internally, a lot of the logic within each function has changed at the cost of a slightly more complex class hierarchy (there might even be some more places to streamline things around too). Something else to do would be to define coercions between the respective subsets, but that we can do on a follow up since these are just sets at this point.

The biggest thing to note is that I have separated out the structure of the manifold into a separate class. This has several distinct advantages:

- It has better encapsulation of data, which should result in fewer copies of the defining data needed and fewer duplication of functions.
- It could allow us to strength/weaken the structure on the manifold dynamically.
- We might only need to have one manifold class and one subset class, that way we don't have to duplicate documentation.

The main drawback I see at the point is we don't expose the attributes of the structure (e.g., the differential order) directly from the manifold instance. However, if we want this behavior, then we can attach the appropriate data as (hidden) (class) attributes to keep some of the modularity; it just results in more classes.

I didn't want to change documentation until I knew you approved of this refactoring (or the alternative proposed above). Please tell me what you think and how you feel it fits with the differentiable manifolds part. I hope this does not cause too much trouble with rebasing.

---
New commits:



---

archive/issue_comments_324626.json:
```json
{
    "body": "Changing commit from \"0b08b114e03c063bd2e500ac900fd843fb12673b\" to \"0fb39df7fafe7f0a765bf73b3f34a6cb41e65c40\"",
    "created_at": "2015-11-25T21:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324626",
    "user": "https://github.com/tscrim"
}
```

Changing commit from "0b08b114e03c063bd2e500ac900fd843fb12673b" to "0fb39df7fafe7f0a765bf73b3f34a6cb41e65c40"



---

archive/issue_comments_324627.json:
```json
{
    "body": "<a id='comment:68'></a>The refactoring with the new classes `AbstractObject`, `AbstractSet`, `ManifoldSubset` and `TopologicalSubmanifold` looks good. It clarify things, thanks! A suggestion regarding the naming: what about replacing `AbstractObject`, which sounds too general, by `AbstractNamedObject`, which would better reflect the class content?\n\nRegarding the separation manifold/structure, I am wondering how this could fit with differentiable manifolds? Since the structure classes are singleton, they store things like the differential order but not properties specific to a given manifold, like the set of vector frames defined on the manifold or its module of vector fields. Then, how could one have a single class for all kind of manifolds? For instance, the class `DifferentiableManifold` introduced in #18783 inherits from `TopologicalManifold` and has the additional attributes `_frames`, `_coframes`, `_frame_changes`, `_parallelizable_parts`, `_vector_field_modules`, etc., which have no meaning for a topological manifold. Besides, we don't want the user to write something like `v = M.structure().vector_frame(...)` instead of `v = M.vector_frame(...)`, do we?",
    "created_at": "2015-11-28T17:47:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324627",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:68'></a>The refactoring with the new classes `AbstractObject`, `AbstractSet`, `ManifoldSubset` and `TopologicalSubmanifold` looks good. It clarify things, thanks! A suggestion regarding the naming: what about replacing `AbstractObject`, which sounds too general, by `AbstractNamedObject`, which would better reflect the class content?

Regarding the separation manifold/structure, I am wondering how this could fit with differentiable manifolds? Since the structure classes are singleton, they store things like the differential order but not properties specific to a given manifold, like the set of vector frames defined on the manifold or its module of vector fields. Then, how could one have a single class for all kind of manifolds? For instance, the class `DifferentiableManifold` introduced in #18783 inherits from `TopologicalManifold` and has the additional attributes `_frames`, `_coframes`, `_frame_changes`, `_parallelizable_parts`, `_vector_field_modules`, etc., which have no meaning for a topological manifold. Besides, we don't want the user to write something like `v = M.structure().vector_frame(...)` instead of `v = M.vector_frame(...)`, do we?



---

archive/issue_comments_324628.json:
```json
{
    "body": "<a id='comment:69'></a>Replying to [comment:68 egourgoulhon]:\n> The refactoring with the new classes `AbstractObject`, `AbstractSet`, `ManifoldSubset` and `TopologicalSubmanifold` looks good. It clarify things, thanks! A suggestion regarding the naming: what about replacing `AbstractObject`, which sounds too general, by `AbstractNamedObject`, which would better reflect the class content?\n\n\nThat is okay with me.\n\n> Regarding the separation manifold/structure, I am wondering how this could fit with differentiable manifolds? Since the structure classes are singleton, they store things like the differential order but not properties specific to a given manifold, like the set of vector frames defined on the manifold or its module of vector fields.\n\n\nI wasn't imagining that they would be singletons, as they would carry instance information like differential order.\n\n> Then, how could one have a single class for all kind of manifolds? For instance, the class `DifferentiableManifold` introduced in #18783 inherits from `TopologicalManifold` and has the additional attributes `_frames`, `_coframes`, `_frame_changes`, `_parallelizable_parts`, `_vector_field_modules`, etc., which have no meaning for a topological manifold. Besides, we don't want the user to write something like `v = M.structure().vector_frame(...)` instead of `v = M.vector_frame(...)`, do we?\n\n\nGood point. Then rather these being instance objects, they should probably be mix-in classes. This would help keep some separation of concerns, avoid some redundancies, and make it easy to manage the distinction between the full manifold and the submanifolds.",
    "created_at": "2015-11-28T18:21:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324628",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:69'></a>Replying to [comment:68 egourgoulhon]:
> The refactoring with the new classes `AbstractObject`, `AbstractSet`, `ManifoldSubset` and `TopologicalSubmanifold` looks good. It clarify things, thanks! A suggestion regarding the naming: what about replacing `AbstractObject`, which sounds too general, by `AbstractNamedObject`, which would better reflect the class content?


That is okay with me.

> Regarding the separation manifold/structure, I am wondering how this could fit with differentiable manifolds? Since the structure classes are singleton, they store things like the differential order but not properties specific to a given manifold, like the set of vector frames defined on the manifold or its module of vector fields.


I wasn't imagining that they would be singletons, as they would carry instance information like differential order.

> Then, how could one have a single class for all kind of manifolds? For instance, the class `DifferentiableManifold` introduced in #18783 inherits from `TopologicalManifold` and has the additional attributes `_frames`, `_coframes`, `_frame_changes`, `_parallelizable_parts`, `_vector_field_modules`, etc., which have no meaning for a topological manifold. Besides, we don't want the user to write something like `v = M.structure().vector_frame(...)` instead of `v = M.vector_frame(...)`, do we?


Good point. Then rather these being instance objects, they should probably be mix-in classes. This would help keep some separation of concerns, avoid some redundancies, and make it easy to manage the distinction between the full manifold and the submanifolds.



---

archive/issue_comments_324629.json:
```json
{
    "body": "<a id='comment:70'></a>Replying to [comment:69 tscrim]:\n> I wasn't imagining that they would be singletons,\n\nOK (I thought that since you were using singletons for the topological structure, you planed to use them for any kind of structure).\n> as they would carry instance information like differential order.\n\nRegarding the specific case of the differential order, we may also consider that it is part of the structure per se and not of the instance, i.e. consider that a C<sup>2</sup>-structure differs from a C<sup>4</sup>-structure. \n\n\n> > Then, how could one have a single class for all kind of manifolds? For instance, the class `DifferentiableManifold` introduced in #18783 inherits from `TopologicalManifold` and has the additional attributes `_frames`, `_coframes`, `_frame_changes`, `_parallelizable_parts`, `_vector_field_modules`, etc., which have no meaning for a topological manifold. Besides, we don't want the user to write something like `v = M.structure().vector_frame(...)` instead of `v = M.vector_frame(...)`, do we?\n\n> \n> Good point. Then rather these being instance objects, they should probably be mix-in classes. This would help keep some separation of concerns, avoid some redundancies, and make it easy to manage the distinction between the full manifold and the submanifolds.\n\n\nCould you please describe further how you would use mix-in classes? and why this would be superior to the simple heritage `TopologicalManifold <-- DifferentiableManifold` ?",
    "created_at": "2015-11-29T10:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324629",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:70'></a>Replying to [comment:69 tscrim]:
> I wasn't imagining that they would be singletons,

OK (I thought that since you were using singletons for the topological structure, you planed to use them for any kind of structure).
> as they would carry instance information like differential order.

Regarding the specific case of the differential order, we may also consider that it is part of the structure per se and not of the instance, i.e. consider that a C<sup>2</sup>-structure differs from a C<sup>4</sup>-structure. 


> > Then, how could one have a single class for all kind of manifolds? For instance, the class `DifferentiableManifold` introduced in #18783 inherits from `TopologicalManifold` and has the additional attributes `_frames`, `_coframes`, `_frame_changes`, `_parallelizable_parts`, `_vector_field_modules`, etc., which have no meaning for a topological manifold. Besides, we don't want the user to write something like `v = M.structure().vector_frame(...)` instead of `v = M.vector_frame(...)`, do we?

> 
> Good point. Then rather these being instance objects, they should probably be mix-in classes. This would help keep some separation of concerns, avoid some redundancies, and make it easy to manage the distinction between the full manifold and the submanifolds.


Could you please describe further how you would use mix-in classes? and why this would be superior to the simple heritage `TopologicalManifold <-- DifferentiableManifold` ?



---

archive/issue_comments_324630.json:
```json
{
    "body": "Changing author from \"Eric Gourgoulhon\" to \"Eric Gourgoulhon, Travis Scrimshaw\"",
    "created_at": "2015-11-29T10:34:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324630",
    "user": "https://github.com/egourgoulhon"
}
```

Changing author from "Eric Gourgoulhon" to "Eric Gourgoulhon, Travis Scrimshaw"



---

archive/issue_comments_324631.json:
```json
{
    "body": "<a id='comment:72'></a>Replying to [comment:70 egourgoulhon]:\n> Could you please describe further how you would use mix-in classes? and why this would be superior to the simple heritage `TopologicalManifold <-- DifferentiableManifold` ?\n\n\nIf we just had a simple inheritance, then we'd have this as our hierarchy:\n\n```\n     Abstract\n   /         \\\nSubset      TopManifold\n  |    ____/   |\n  |   /        |\nTopSub      DiffManifold\n  |    ____/\n  |   /\nDiffSub\n```\nHowever, with a mixin, we would have this:\n\n```\n     Abstract\n   /         \\\nSubset      TopManifold\n  |    ____/        |\n  |   /             |\nTopSub  DiffMixin   |\n  |    /        \\   |\nDiffSub          DiffManifold\n```\nIn particular, notice that this does not introduce another diamond problem. It also makes it easier to add another class at the `Subset` and `TopManifold` level if we ever wanted to.\n\nIdeally, I would like to abstract away the `Subset` parts to a mixin to completely avoid any diamonds, but I couldn't really figure out a good way to make that work.",
    "created_at": "2015-11-29T16:03:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324631",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:72'></a>Replying to [comment:70 egourgoulhon]:
> Could you please describe further how you would use mix-in classes? and why this would be superior to the simple heritage `TopologicalManifold <-- DifferentiableManifold` ?


If we just had a simple inheritance, then we'd have this as our hierarchy:

```
     Abstract
   /         \
Subset      TopManifold
  |    ____/   |
  |   /        |
TopSub      DiffManifold
  |    ____/
  |   /
DiffSub
```
However, with a mixin, we would have this:

```
     Abstract
   /         \
Subset      TopManifold
  |    ____/        |
  |   /             |
TopSub  DiffMixin   |
  |    /        \   |
DiffSub          DiffManifold
```
In particular, notice that this does not introduce another diamond problem. It also makes it easier to add another class at the `Subset` and `TopManifold` level if we ever wanted to.

Ideally, I would like to abstract away the `Subset` parts to a mixin to completely avoid any diamonds, but I couldn't really figure out a good way to make that work.



---

archive/issue_comments_324632.json:
```json
{
    "body": "<a id='comment:73'></a>Thanks for these explanations.",
    "created_at": "2015-11-29T20:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324632",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:73'></a>Thanks for these explanations.



---

archive/issue_comments_324633.json:
```json
{
    "body": "<a id='comment:74'></a>Replying to [comment:61 egourgoulhon]:\n> \n> No, not at the moment: I've worked on the subsequent tickets to check if the introduced changes (in particular the removal of unique representation) propagate smoothly. So far, so good...\n> \n\n\nBad news: the removal of unique representation breaks parallel computations in #19147 (affine connections). For instance, in the branch of #19147, if one performs\n\n```\nsage: M = Manifold(3, 'M')\nsage: X.<x,y,z> = M.chart()\nsage: nab = M.affine_connection('nabla', r'\\nabla')\nsage: nab[0,0,1], nab[2,1,2] = x^2, y*z\nsage: use_multiproc(2)  # parallelization on 2 proc\nsage: nab.riemann()\n```\none gets the error message:\n\n```\nRuntimeError: There is a bug in the coercion code in Sage.\nBoth x (=Scalar field on the 3-dimensional differentiable manifold M) and y (=Scalar field on the 3-dimensional differentiable manifold M) are supposed to have identical parents but they don't.\nIn fact, x has parent 'Algebra of differentiable scalar fields on the 3-dimensional differentiable manifold M'\nwhereas y has parent 'Algebra of differentiable scalar fields on the 3-dimensional differentiable manifold M'\n```\nand sage terminates badly (core dumped). \nThe reason is that the parallelization is using the pickling: the parallel iterator `sage.parallel.multiprocessing_sage.parallel_iter` invokes the function `sage.misc.fpickle.pickle_function`.\nWith unique representation, the pickling was fine and the above issue did not occur.\nNote that parallelization of heavy computations like that of the Riemann tensor is really important!...",
    "created_at": "2015-11-29T21:09:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324633",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:74'></a>Replying to [comment:61 egourgoulhon]:
> 
> No, not at the moment: I've worked on the subsequent tickets to check if the introduced changes (in particular the removal of unique representation) propagate smoothly. So far, so good...
> 


Bad news: the removal of unique representation breaks parallel computations in #19147 (affine connections). For instance, in the branch of #19147, if one performs

```
sage: M = Manifold(3, 'M')
sage: X.<x,y,z> = M.chart()
sage: nab = M.affine_connection('nabla', r'\nabla')
sage: nab[0,0,1], nab[2,1,2] = x^2, y*z
sage: use_multiproc(2)  # parallelization on 2 proc
sage: nab.riemann()
```
one gets the error message:

```
RuntimeError: There is a bug in the coercion code in Sage.
Both x (=Scalar field on the 3-dimensional differentiable manifold M) and y (=Scalar field on the 3-dimensional differentiable manifold M) are supposed to have identical parents but they don't.
In fact, x has parent 'Algebra of differentiable scalar fields on the 3-dimensional differentiable manifold M'
whereas y has parent 'Algebra of differentiable scalar fields on the 3-dimensional differentiable manifold M'
```
and sage terminates badly (core dumped). 
The reason is that the parallelization is using the pickling: the parallel iterator `sage.parallel.multiprocessing_sage.parallel_iter` invokes the function `sage.misc.fpickle.pickle_function`.
With unique representation, the pickling was fine and the above issue did not occur.
Note that parallelization of heavy computations like that of the Riemann tensor is really important!...



---

archive/issue_comments_324634.json:
```json
{
    "body": "<a id='comment:75'></a>I think what we will have to do is one (or more) of the following:\n\n- implement custom multiprocessing,\n- move the parallelization code into the scalar fields algebra,\n- implement a custom coercion scheme by overriding `__add__`, etc., or\n- improve coercion support for non-`UniqueRepresentation` objects.\n\nI think the first or second option will be the best possibility for this to work.",
    "created_at": "2015-11-29T22:57:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324634",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:75'></a>I think what we will have to do is one (or more) of the following:

- implement custom multiprocessing,
- move the parallelization code into the scalar fields algebra,
- implement a custom coercion scheme by overriding `__add__`, etc., or
- improve coercion support for non-`UniqueRepresentation` objects.

I think the first or second option will be the best possibility for this to work.



---

archive/issue_comments_324635.json:
```json
{
    "body": "<a id='comment:76'></a>Replying to [comment:75 tscrim]:\n> I think what we will have to do is one (or more) of the following:\n> \n> - implement custom multiprocessing,\n> - move the parallelization code into the scalar fields algebra,\n> - implement a custom coercion scheme by overriding `__add__`, etc., or\n> - improve coercion support for non-`UniqueRepresentation` objects.\n> \n> I think the first or second option will be the best possibility for this to work.\n\n\nThe first looks to me much better than the second one: the nice feature of the parallelization framework as implemented in #18100 is that it is implemented at the `Components` level, i.e. for any indexed set of ring elements, whatever the ring. It sounds bad to redefine this for the special case where the ring is an algebra of scalar fields. I shall discuss with Marco about implementing some multiprocessing that does not rely on pickling.\n\nAnother solution would be to revert to `UniqueRepresentation` for manifolds (once again!). Since now the user creates manifolds via the front-end function `Manifold` and not by a direct call to the manifold class constructor, the main issue raised at the end of comment:31 could be overcome by the handling of the cache in `Manifold`. In this way\n\n```\nsage: M1 = Manifold(2, 'M')\nsage: M2 = Manifold(2, 'M')\n```\nwould result in two different objects, as desired, but\n\n```\nsage: M1 == loads(dumps(M1))\n```\nwould still work, because the unpickling does not go through the function `Manifold`. \nThere remains the issue with `UniqueRepresentation` raised by Nils Bruin in the [sage-devel thread](https://groups.google.com/d/msg/sage-devel/Vzfj1haZHho/sLfOJ3ujBQAJ): *Avoid UniqueRepresentation if you can. It requires expensive processing of construction parameters and hence introduces bad overhead and it introduces \"global variables\" in a way that is much worse than global variables.* \nHowever, in a typical work session, one should not create so many manifolds, so the \"expensive processing of construction parameters\" is not a too severe issue.",
    "created_at": "2015-11-30T10:03:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324635",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:76'></a>Replying to [comment:75 tscrim]:
> I think what we will have to do is one (or more) of the following:
> 
> - implement custom multiprocessing,
> - move the parallelization code into the scalar fields algebra,
> - implement a custom coercion scheme by overriding `__add__`, etc., or
> - improve coercion support for non-`UniqueRepresentation` objects.
> 
> I think the first or second option will be the best possibility for this to work.


The first looks to me much better than the second one: the nice feature of the parallelization framework as implemented in #18100 is that it is implemented at the `Components` level, i.e. for any indexed set of ring elements, whatever the ring. It sounds bad to redefine this for the special case where the ring is an algebra of scalar fields. I shall discuss with Marco about implementing some multiprocessing that does not rely on pickling.

Another solution would be to revert to `UniqueRepresentation` for manifolds (once again!). Since now the user creates manifolds via the front-end function `Manifold` and not by a direct call to the manifold class constructor, the main issue raised at the end of comment:31 could be overcome by the handling of the cache in `Manifold`. In this way

```
sage: M1 = Manifold(2, 'M')
sage: M2 = Manifold(2, 'M')
```
would result in two different objects, as desired, but

```
sage: M1 == loads(dumps(M1))
```
would still work, because the unpickling does not go through the function `Manifold`. 
There remains the issue with `UniqueRepresentation` raised by Nils Bruin in the [sage-devel thread](https://groups.google.com/d/msg/sage-devel/Vzfj1haZHho/sLfOJ3ujBQAJ): *Avoid UniqueRepresentation if you can. It requires expensive processing of construction parameters and hence introduces bad overhead and it introduces "global variables" in a way that is much worse than global variables.* 
However, in a typical work session, one should not create so many manifolds, so the "expensive processing of construction parameters" is not a too severe issue.



---

archive/issue_comments_324636.json:
```json
{
    "body": "<a id='comment:77'></a>Replying to [comment:76 egourgoulhon]:\n> Another solution would be to revert to `UniqueRepresentation` for manifolds (once again!). Since now the user creates manifolds via the front-end function `Manifold` and not by a direct call to the manifold class constructor, the main issue raised at the end of comment:31 could be overcome by the handling of the cache in `Manifold`. In this way\n> \n> ```\n> sage: M1 = Manifold(2, 'M')\n> sage: M2 = Manifold(2, 'M')\n> ```\n> would result in two different objects, as desired, but\n> \n> ```\n> sage: M1 == loads(dumps(M1))\n> ```\n> would still work, because the unpickling does not go through the function `Manifold`. \n\n\nThis breaks pickling:\n\n```\nsage: class Foo(UniqueRepresentation):\n....:     def __init__(self, i):\n....:         pass\n....:     \nsage: F1 = Foo(1)\nsage: Foo._clear_cache_()\nsage: F2 = Foo(1)\nsage: F1 is F2\nFalse\nsage: F1 == loads(dumps(F1))\nFalse\nsage: F2 == loads(dumps(F1))\nTrue\n```\nThe reason is pickling still goes through the `UniqueRepresentation` cache. I am still convinced we should not be using `UniqueRepresentation` for the manifolds.",
    "created_at": "2015-11-30T16:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324636",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:77'></a>Replying to [comment:76 egourgoulhon]:
> Another solution would be to revert to `UniqueRepresentation` for manifolds (once again!). Since now the user creates manifolds via the front-end function `Manifold` and not by a direct call to the manifold class constructor, the main issue raised at the end of comment:31 could be overcome by the handling of the cache in `Manifold`. In this way
> 
> ```
> sage: M1 = Manifold(2, 'M')
> sage: M2 = Manifold(2, 'M')
> ```
> would result in two different objects, as desired, but
> 
> ```
> sage: M1 == loads(dumps(M1))
> ```
> would still work, because the unpickling does not go through the function `Manifold`. 


This breaks pickling:

```
sage: class Foo(UniqueRepresentation):
....:     def __init__(self, i):
....:         pass
....:     
sage: F1 = Foo(1)
sage: Foo._clear_cache_()
sage: F2 = Foo(1)
sage: F1 is F2
False
sage: F1 == loads(dumps(F1))
False
sage: F2 == loads(dumps(F1))
True
```
The reason is pickling still goes through the `UniqueRepresentation` cache. I am still convinced we should not be using `UniqueRepresentation` for the manifolds.



---

archive/issue_comments_324637.json:
```json
{
    "body": "<a id='comment:78'></a>Replying to [comment:77 tscrim]:\n> \n> This breaks pickling:\n\nYes but by \"handling of the cache\" I had in mind not a call to `_clear_cache_` but rather adding a \nunique tag to the constructor, such as the time tag that you already suggested. In this way, pickling would work. But I agree that this is a trick and that manifolds do not have a unique (mathematical) representation. However, given that in general we cannot decide whether two given manifolds are equal (isomorphic), making each of them unique with some tag could be an idea... What would be the drawbacks?",
    "created_at": "2015-11-30T17:16:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324637",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:78'></a>Replying to [comment:77 tscrim]:
> 
> This breaks pickling:

Yes but by "handling of the cache" I had in mind not a call to `_clear_cache_` but rather adding a 
unique tag to the constructor, such as the time tag that you already suggested. In this way, pickling would work. But I agree that this is a trick and that manifolds do not have a unique (mathematical) representation. However, given that in general we cannot decide whether two given manifolds are equal (isomorphic), making each of them unique with some tag could be an idea... What would be the drawbacks?



---

archive/issue_comments_324638.json:
```json
{
    "body": "<a id='comment:79'></a>Marco and I have discussed the thing this morning. It's clear that the `multiprocessing` Python module relies on pickling; some references are\n- https://docs.python.org/2/library/multiprocessing.html\n- http://matthewrocklin.com/blog/work/2013/12/05/Parallelism-and-Serialization/\n- http://stackoverflow.com/questions/8804830/python-multiprocessing-pickling-error\nTherefore, unless one develops a brand new way of parallelizing Python codes, good pickling is required for parallelization. Given the importance of parallelization in tensor calculus, I am really considering reverting to `UniqueRepresentation` for the manifold classes. The argument goes as follows: from the [sage-devel discussion](https://groups.google.com/forum/#!msg/sage-devel/Vzfj1haZHho/), we get that manifolds must implement equality by identity (i.e. inherit from `WithEqualityById`), mostly because there exist no algorithm to decide whether two given manifolds are homeo/diffeomorphic  (especially with manifolds with incomplete atlases, as we manipulate them). Then to have good pickling, i.e. to ensure `M == loads(dumps(M))`, the only way is to inherit from `CachedRepresentation` as well. Having both `WithEqualityById` and `CachedRepresentation` implies`UniqueRepresentation`.",
    "created_at": "2015-12-01T13:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324638",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:79'></a>Marco and I have discussed the thing this morning. It's clear that the `multiprocessing` Python module relies on pickling; some references are
- https://docs.python.org/2/library/multiprocessing.html
- http://matthewrocklin.com/blog/work/2013/12/05/Parallelism-and-Serialization/
- http://stackoverflow.com/questions/8804830/python-multiprocessing-pickling-error
Therefore, unless one develops a brand new way of parallelizing Python codes, good pickling is required for parallelization. Given the importance of parallelization in tensor calculus, I am really considering reverting to `UniqueRepresentation` for the manifold classes. The argument goes as follows: from the [sage-devel discussion](https://groups.google.com/forum/#!msg/sage-devel/Vzfj1haZHho/), we get that manifolds must implement equality by identity (i.e. inherit from `WithEqualityById`), mostly because there exist no algorithm to decide whether two given manifolds are homeo/diffeomorphic  (especially with manifolds with incomplete atlases, as we manipulate them). Then to have good pickling, i.e. to ensure `M == loads(dumps(M))`, the only way is to inherit from `CachedRepresentation` as well. Having both `WithEqualityById` and `CachedRepresentation` implies`UniqueRepresentation`.



---

archive/issue_comments_324639.json:
```json
{
    "body": "<a id='comment:80'></a>I did some exploring in the coercion code and some testing using this:\n\n```python\nfrom sage.structure.parent import Parent\nfrom sage.structure.element_wrapper import ElementWrapper\nfrom sage.misc.fast_methods import WithEqualityById\nfrom sage.categories.additive_groups import AdditiveGroups\n\nclass Foo(Parent, WithEqualityById):\n    def __init__(self):\n        Parent.__init__(self, category=AdditiveGroups())\n\n    def __reduce__(self):\n        return (Foo, ())\n\n    def _coerce_map_from_(self, R):\n        return isinstance(R, Foo)\n\n    def _element_constructor_(self, x):\n        if isinstance(x, ElementWrapper) and isinstance(x.parent(), Foo):\n            return self(x.value)\n        return super(Foo, self)._element_constructor_(x)\n\n    class Element(ElementWrapper):\n        def _add_(self, other):\n            return self.parent()(self.value+other.value)\n```\nwhich I think is a minimal example of the behavior you want. Pickling and coercion seem to work fine:\n\n```\nsage: F = Foo()\nsage: F2 = loads(dumps(F))\nsage: F(1) + F2(1)\n2\nsage: F == F2\nFalse\n```\n\nFurthermore, from looking at your code, the reason why it now breaks is you're assuming unique representation by not passing the scalar field algebra as the first argument of the scalar field. So it's getting mismatches because the `domain.scalar_field_algebra()` may not be the scalar field algebra that was suppose to be creating that particular scalar field. So for the scalar fields, I would instead have the first argument be the corresponding algebra and get the domain from that (with appropriate handling of parameters for the methods which create the scalar fields). You might also consider caching the scalar field algebra that gets created for a particular manifold to have unique representation behavior.",
    "created_at": "2015-12-01T17:48:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324639",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:80'></a>I did some exploring in the coercion code and some testing using this:

```python
from sage.structure.parent import Parent
from sage.structure.element_wrapper import ElementWrapper
from sage.misc.fast_methods import WithEqualityById
from sage.categories.additive_groups import AdditiveGroups

class Foo(Parent, WithEqualityById):
    def __init__(self):
        Parent.__init__(self, category=AdditiveGroups())

    def __reduce__(self):
        return (Foo, ())

    def _coerce_map_from_(self, R):
        return isinstance(R, Foo)

    def _element_constructor_(self, x):
        if isinstance(x, ElementWrapper) and isinstance(x.parent(), Foo):
            return self(x.value)
        return super(Foo, self)._element_constructor_(x)

    class Element(ElementWrapper):
        def _add_(self, other):
            return self.parent()(self.value+other.value)
```
which I think is a minimal example of the behavior you want. Pickling and coercion seem to work fine:

```
sage: F = Foo()
sage: F2 = loads(dumps(F))
sage: F(1) + F2(1)
2
sage: F == F2
False
```

Furthermore, from looking at your code, the reason why it now breaks is you're assuming unique representation by not passing the scalar field algebra as the first argument of the scalar field. So it's getting mismatches because the `domain.scalar_field_algebra()` may not be the scalar field algebra that was suppose to be creating that particular scalar field. So for the scalar fields, I would instead have the first argument be the corresponding algebra and get the domain from that (with appropriate handling of parameters for the methods which create the scalar fields). You might also consider caching the scalar field algebra that gets created for a particular manifold to have unique representation behavior.



---

archive/issue_comments_324640.json:
```json
{
    "body": "<a id='comment:81'></a>Replying to [comment:80 tscrim]:\n> I did some exploring in the coercion code and some testing using this:\n\n\nThanks for the exploration. \nThe trick\n>{{{#!python \n>     def _coerce_map_from_(self, R):\n>         return isinstance(R, Foo)\n> }}}\n\nis too permissive to be applicable to scalar field algebras. For them, the coercion is currently based on the concept of restriction to a subdomain, i.e. there is a coerce map from C<sup>k</sup>(M) to C<sup>k</sup>(N) iff N is a subset of M (cf. the code of `_coerce_map_from_` in `scalar_field_algebra.py`). It is very desirable to keep this feature, which is mathematically neat.\n> \n> Furthermore, from looking at your code, the reason why it now breaks is you're assuming unique representation by not passing the scalar field algebra as the first argument of the scalar field. So it's getting mismatches because the `domain.scalar_field_algebra()` may not be the scalar field algebra that was suppose to be creating that particular scalar field. So for the scalar fields, I would instead have the first argument be the corresponding algebra and get the domain from that (with appropriate handling of parameters for the methods which create the scalar fields).\n\n\nI've done this (actually this should have been done before: it is cleaner to have the parent as first argument when constructing elements). But this does not solve the problem. There is a difference though: on the example of comment:74, we do no longer get the coercion error message but the ECL error message arising from Maxima; the latter was previously appearing after the coercion error message:\n\n```\n;;;\n;;; Stack overflow.\n;;; Jumping to the outermost toplevel prompt\n;;;\n```\nand that a lot of text until `Abandon (core dumped)`. I've pushed the new code (i.e. with the algebra as first argument of scalar fields) to the branch of #19147, in case you want to have a look.\n> You might also consider caching the scalar field algebra that gets created for a particular manifold to have unique representation behavior.\n\nThis was already the case (cf. the code of `DifferentiableManifold.scalar_field_algebra()`).",
    "created_at": "2015-12-01T22:50:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324640",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:81'></a>Replying to [comment:80 tscrim]:
> I did some exploring in the coercion code and some testing using this:


Thanks for the exploration. 
The trick
>{{{#!python 
>     def _coerce_map_from_(self, R):
>         return isinstance(R, Foo)
> }}}

is too permissive to be applicable to scalar field algebras. For them, the coercion is currently based on the concept of restriction to a subdomain, i.e. there is a coerce map from C<sup>k</sup>(M) to C<sup>k</sup>(N) iff N is a subset of M (cf. the code of `_coerce_map_from_` in `scalar_field_algebra.py`). It is very desirable to keep this feature, which is mathematically neat.
> 
> Furthermore, from looking at your code, the reason why it now breaks is you're assuming unique representation by not passing the scalar field algebra as the first argument of the scalar field. So it's getting mismatches because the `domain.scalar_field_algebra()` may not be the scalar field algebra that was suppose to be creating that particular scalar field. So for the scalar fields, I would instead have the first argument be the corresponding algebra and get the domain from that (with appropriate handling of parameters for the methods which create the scalar fields).


I've done this (actually this should have been done before: it is cleaner to have the parent as first argument when constructing elements). But this does not solve the problem. There is a difference though: on the example of comment:74, we do no longer get the coercion error message but the ECL error message arising from Maxima; the latter was previously appearing after the coercion error message:

```
;;;
;;; Stack overflow.
;;; Jumping to the outermost toplevel prompt
;;;
```
and that a lot of text until `Abandon (core dumped)`. I've pushed the new code (i.e. with the algebra as first argument of scalar fields) to the branch of #19147, in case you want to have a look.
> You might also consider caching the scalar field algebra that gets created for a particular manifold to have unique representation behavior.

This was already the case (cf. the code of `DifferentiableManifold.scalar_field_algebra()`).



---

archive/issue_comments_324641.json:
```json
{
    "body": "<a id='comment:82'></a>Replying to [comment:81 egourgoulhon]:\n> Replying to [comment:80 tscrim]:\n\n\n> The trick\n> >{{{#!python \n> >     def _coerce_map_from_(self, R):\n> >         return isinstance(R, Foo)\n> > }}}\n\n> is too permissive to be applicable to scalar field algebras. For them, the coercion is currently based on the concept of restriction to a subdomain, i.e. there is a coerce map from C<sup>k</sup>(M) to C<sup>k</sup>(N) iff N is a subset of M (cf. the code of `_coerce_map_from_` in `scalar_field_algebra.py`). It is very desirable to keep this feature, which is mathematically neat.\n\nI completely agree. I was just using it for illustrative purposes.\n\n> > Furthermore, from looking at your code, the reason why it now breaks is you're assuming unique representation by not passing the scalar field algebra as the first argument of the scalar field. So it's getting mismatches because the `domain.scalar_field_algebra()` may not be the scalar field algebra that was suppose to be creating that particular scalar field. So for the scalar fields, I would instead have the first argument be the corresponding algebra and get the domain from that (with appropriate handling of parameters for the methods which create the scalar fields).\n\n> \n> I've done this (actually this should have been done before: it is cleaner to have the parent as first argument when constructing elements). But this does not solve the problem. There is a difference though: on the example of comment:74, we do no longer get the coercion error message but the ECL error message arising from Maxima; the latter was previously appearing after the coercion error message:\n> \n> ```\n> ;;;\n> ;;; Stack overflow.\n> ;;; Jumping to the outermost toplevel prompt\n> ;;;\n> ```\n> and that a lot of text until `Abandon (core dumped)`. I've pushed the new code (i.e. with the algebra as first argument of scalar fields) to the branch of #19147, in case you want to have a look.\n\n\nHmm...that is very strange. Perhaps something with pickling and the interface?\n\nHowever, I starting to lean towards reinstating the `UniqueRepresentation` behavior with initialization using a large random number via `manifold_constructor`. This will keep memory down with pickling because of all of the extra data that would need to be initialized after every pickling within the session. In an ideal world, I think we would implement our own variable system for the manifolds and hold some kind of global reference to that. I will think about this on my way home right now.\n\nQuestion, should override the `__copy__` for the manifold (at least, I feel there might be some use cases for building two manifolds with a common base atlas)?",
    "created_at": "2015-12-01T23:29:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324641",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:82'></a>Replying to [comment:81 egourgoulhon]:
> Replying to [comment:80 tscrim]:


> The trick
> >{{{#!python 
> >     def _coerce_map_from_(self, R):
> >         return isinstance(R, Foo)
> > }}}

> is too permissive to be applicable to scalar field algebras. For them, the coercion is currently based on the concept of restriction to a subdomain, i.e. there is a coerce map from C<sup>k</sup>(M) to C<sup>k</sup>(N) iff N is a subset of M (cf. the code of `_coerce_map_from_` in `scalar_field_algebra.py`). It is very desirable to keep this feature, which is mathematically neat.

I completely agree. I was just using it for illustrative purposes.

> > Furthermore, from looking at your code, the reason why it now breaks is you're assuming unique representation by not passing the scalar field algebra as the first argument of the scalar field. So it's getting mismatches because the `domain.scalar_field_algebra()` may not be the scalar field algebra that was suppose to be creating that particular scalar field. So for the scalar fields, I would instead have the first argument be the corresponding algebra and get the domain from that (with appropriate handling of parameters for the methods which create the scalar fields).

> 
> I've done this (actually this should have been done before: it is cleaner to have the parent as first argument when constructing elements). But this does not solve the problem. There is a difference though: on the example of comment:74, we do no longer get the coercion error message but the ECL error message arising from Maxima; the latter was previously appearing after the coercion error message:
> 
> ```
> ;;;
> ;;; Stack overflow.
> ;;; Jumping to the outermost toplevel prompt
> ;;;
> ```
> and that a lot of text until `Abandon (core dumped)`. I've pushed the new code (i.e. with the algebra as first argument of scalar fields) to the branch of #19147, in case you want to have a look.


Hmm...that is very strange. Perhaps something with pickling and the interface?

However, I starting to lean towards reinstating the `UniqueRepresentation` behavior with initialization using a large random number via `manifold_constructor`. This will keep memory down with pickling because of all of the extra data that would need to be initialized after every pickling within the session. In an ideal world, I think we would implement our own variable system for the manifolds and hold some kind of global reference to that. I will think about this on my way home right now.

Question, should override the `__copy__` for the manifold (at least, I feel there might be some use cases for building two manifolds with a common base atlas)?



---

archive/issue_comments_324642.json:
```json
{
    "body": "<a id='comment:83'></a>Okay, let's revert back to having `UniqueRepresentation` because it will work as a session/variable manager. I don't think we should spend a lot of time doing that as we can hack around it (even though it is in effect what we are doing/should do). I don't like it because it is a hack, but it seems like the best option for now. Unless you want to directly use Python's multiprocessing with shared memory for the corresponding parents to avoid pickling, which I would still somewhat prefer in a way so we don't have to do this hack. (Multithreading in Python has shared memory, but unfortunately it can't run on multiple processors because of the GIL.) Anyways, I leave the decision up to you.",
    "created_at": "2015-12-02T03:05:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324642",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:83'></a>Okay, let's revert back to having `UniqueRepresentation` because it will work as a session/variable manager. I don't think we should spend a lot of time doing that as we can hack around it (even though it is in effect what we are doing/should do). I don't like it because it is a hack, but it seems like the best option for now. Unless you want to directly use Python's multiprocessing with shared memory for the corresponding parents to avoid pickling, which I would still somewhat prefer in a way so we don't have to do this hack. (Multithreading in Python has shared memory, but unfortunately it can't run on multiple processors because of the GIL.) Anyways, I leave the decision up to you.



---

archive/issue_comments_324643.json:
```json
{
    "body": "<a id='comment:84'></a>Replying to [comment:82 tscrim]:\n> However, I starting to lean towards reinstating the `UniqueRepresentation` behavior with initialization using a large random number via `manifold_constructor`. This will keep memory down with pickling because of all of the extra data that would need to be initialized after every pickling within the session. \n\n\nOK.\n>In an ideal world, I think we would implement our own variable system for the manifolds and hold some kind of global reference to that.\n\n\nYes this could be something to implement in the future. \n> \n> Question, should override the `__copy__` for the manifold (at least, I feel there might be some use cases for building two manifolds with a common base atlas)?\n\n\nYes, a use case could be trying different things by extending the atlas of a given manifold. The initial manifold, arising for instance from some manifold catalog, could be copied to serve as a reference for the various trials.",
    "created_at": "2015-12-02T10:34:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324643",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:84'></a>Replying to [comment:82 tscrim]:
> However, I starting to lean towards reinstating the `UniqueRepresentation` behavior with initialization using a large random number via `manifold_constructor`. This will keep memory down with pickling because of all of the extra data that would need to be initialized after every pickling within the session. 


OK.
>In an ideal world, I think we would implement our own variable system for the manifolds and hold some kind of global reference to that.


Yes this could be something to implement in the future. 
> 
> Question, should override the `__copy__` for the manifold (at least, I feel there might be some use cases for building two manifolds with a common base atlas)?


Yes, a use case could be trying different things by extending the atlas of a given manifold. The initial manifold, arising for instance from some manifold catalog, could be copied to serve as a reference for the various trials.



---

archive/issue_comments_324644.json:
```json
{
    "body": "<a id='comment:85'></a>Replying to [comment:83 tscrim]:\n> Okay, let's revert back to having `UniqueRepresentation` because it will work as a session/variable manager. I don't think we should spend a lot of time doing that as we can hack around it (even though it is in effect what we are doing/should do). I don't like it because it is a hack, but it seems like the best option for now. Unless you want to directly use Python's multiprocessing with shared memory for the corresponding parents to avoid pickling, which I would still somewhat prefer in a way so we don't have to do this hack. (Multithreading in Python has shared memory, but unfortunately it can't run on multiple processors because of the GIL.) Anyways, I leave the decision up to you.\n\n\nYes, I think it is reasonable to revert to `UniqueRepresentation` at this stage, leaving Python's multiprocessing without pickling for a future development, exploring meanwhile other ways of parallelization (IPython parallel framework ?). I've rerun this morning some benchmarks on the commit of #19209 based on `UniqueRepresentation` (commit [82f6f495b](http://git.sagemath.org/sage.git/commit/?id=82f6f495bb6f729624dd8396208f5a3c67e2fa8d)) merged into Sage 6.10.beta6: the gain in the computation of the Riemann tensor of a non-trivial metric (4-dimensional [Kerr metric](http://sagemanifolds.obspm.fr/examples/html/SM_Kerr.html)) is really significant: a factor of 4 when using 8 cores instead of 1 (30 s instead of 115 s on Xeon E5-2623 CPUs).",
    "created_at": "2015-12-02T10:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324644",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:85'></a>Replying to [comment:83 tscrim]:
> Okay, let's revert back to having `UniqueRepresentation` because it will work as a session/variable manager. I don't think we should spend a lot of time doing that as we can hack around it (even though it is in effect what we are doing/should do). I don't like it because it is a hack, but it seems like the best option for now. Unless you want to directly use Python's multiprocessing with shared memory for the corresponding parents to avoid pickling, which I would still somewhat prefer in a way so we don't have to do this hack. (Multithreading in Python has shared memory, but unfortunately it can't run on multiple processors because of the GIL.) Anyways, I leave the decision up to you.


Yes, I think it is reasonable to revert to `UniqueRepresentation` at this stage, leaving Python's multiprocessing without pickling for a future development, exploring meanwhile other ways of parallelization (IPython parallel framework ?). I've rerun this morning some benchmarks on the commit of #19209 based on `UniqueRepresentation` (commit [82f6f495b](http://git.sagemath.org/sage.git/commit/?id=82f6f495bb6f729624dd8396208f5a3c67e2fa8d)) merged into Sage 6.10.beta6: the gain in the computation of the Riemann tensor of a non-trivial metric (4-dimensional [Kerr metric](http://sagemanifolds.obspm.fr/examples/html/SM_Kerr.html)) is really significant: a factor of 4 when using 8 cores instead of 1 (30 s instead of 115 s on Xeon E5-2623 CPUs).



---

archive/issue_comments_324645.json:
```json
{
    "body": "<a id='comment:86'></a>I've started to work again on the ticket (not finished yet) and have one question: given the inheritance diagram of comment:72, shall we rename the class `Manifold` to `TopologicalManifold` ? Then, can we revert to `Manifold` for `manifold_constructor` ?\n\n---\nNew commits:",
    "created_at": "2015-12-14T14:41:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324645",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:86'></a>I've started to work again on the ticket (not finished yet) and have one question: given the inheritance diagram of comment:72, shall we rename the class `Manifold` to `TopologicalManifold` ? Then, can we revert to `Manifold` for `manifold_constructor` ?

---
New commits:



---

archive/issue_comments_324646.json:
```json
{
    "body": "Changing commit from \"0fb39df7fafe7f0a765bf73b3f34a6cb41e65c40\" to \"c5f35afa41b2dac89471ba63d80fd2ae8eebbc2f\"",
    "created_at": "2015-12-14T14:41:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324646",
    "user": "https://github.com/egourgoulhon"
}
```

Changing commit from "0fb39df7fafe7f0a765bf73b3f34a6cb41e65c40" to "c5f35afa41b2dac89471ba63d80fd2ae8eebbc2f"



---

archive/issue_comments_324647.json:
```json
{
    "body": "Changing branch from \"u/tscrim/top_manifolds_refactor\" to \"public/manifolds/top_manif_basics\"",
    "created_at": "2015-12-14T14:41:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324647",
    "user": "https://github.com/egourgoulhon"
}
```

Changing branch from "u/tscrim/top_manifolds_refactor" to "public/manifolds/top_manif_basics"



---

archive/issue_events_052104.json:
```json
{
    "actor": "https://github.com/egourgoulhon",
    "created_at": "2015-12-14T14:41:11Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "milestone": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18529#event-52104"
}
```



---

archive/issue_comments_324648.json:
```json
{
    "body": "<a id='comment:87'></a>IMO, it is more clear to have in the code `manifold_constructor` as that is suppose to be a top-level function (which we import at `Manifold` into the global namespace). Yet I think that is not a strong argument as it introduces a disassociation. Given that we will be using mixin classes, we should revert `Manifold` back to `TopologicalManifold`. So I leave the other name change up to you.",
    "created_at": "2015-12-14T14:57:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324648",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:87'></a>IMO, it is more clear to have in the code `manifold_constructor` as that is suppose to be a top-level function (which we import at `Manifold` into the global namespace). Yet I think that is not a strong argument as it introduces a disassociation. Given that we will be using mixin classes, we should revert `Manifold` back to `TopologicalManifold`. So I leave the other name change up to you.



---

archive/issue_comments_324649.json:
```json
{
    "body": "<a id='comment:88'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-12-15T16:11:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324649",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:88'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324650.json:
```json
{
    "body": "Changing commit from \"c5f35afa41b2dac89471ba63d80fd2ae8eebbc2f\" to \"3a525002469e0ef676a0dcf48f8f7f8683b85853\"",
    "created_at": "2015-12-15T16:11:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324650",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "c5f35afa41b2dac89471ba63d80fd2ae8eebbc2f" to "3a525002469e0ef676a0dcf48f8f7f8683b85853"



---

archive/issue_comments_324651.json:
```json
{
    "body": "<a id='comment:89'></a>In the above commit, I've\n- renamed class `Manifold` to `TopologicalManifold`\n- renamed function `manifold_constructor` to `Manifold`, i.e. to the name by which it is imported \n  to the global namespace (IMHO, this makes the documentation more clear for a beginner: \n  previously, `sage: Manifold??` was returning something like `def manifold_constructor`...\n  Also the html doc looks better with a single name)\n- renamed class `TopologicalSubmanifold` to `OpenTopologicalSubmanifold`, to avoid any ambiguity with \n  embedded submanifolds of lower dimension\n- revert the attribute `_open_covers` to a list of lists (instead of a set of frozensets), mostly to\n  ensure the reproductibility of computations from one machine to another one, i.e. this garantees\n  that `for ... in` loops are always performed in the same way (maybe this is something to \n  be discussed further...). Moreover, the mathematical definition of an \n  open cover refers to an indexed family, which corresponds more to a list than to a frozenset.   \n- removed the method `is_open()` from `AbstractSet` (where it was always returning `True`!) and\n  implemented it in `TopologicalManifold`. Now it is on the same footing as methods `superset`,\n  `union` and `intersection`, which are not implemented in the base class `AbstractSet` but in each\n  of the subclasses `TopologicalManifold` and `ManifoldSubset`\n- removed the (unused) argument `category` from `ManifoldSubset.__init__`\n- added an example to illustrate the class `OpenTopologicalSubmanifold`, as well as enough doctests\n  to get a full coverage\n\nTo answer to some of your questions in the code:\n- I don't think that `ManifoldPoint` must inherit from `AbstractNamedObject` since the name is\n  not essential in the definition of a point (it can have no name), contrary to that of a subset. \n  Moreover, it would slower the creation of points, which can be a problem (no such problem for\n  parent objects, which are not expected to be massively created)\n- Yes, I think we need `list_of_subsets` to have something duplicable from one machine to another one\n  (cf. remark above about `_open_covers`).\n\nThe test suite of `ManifoldSubset` and `OpenTopologicalSubmanifold` fails because of the lack of a method `lift`. What this method shall be? I guess we have to wait for the morphism ticket (#18725) to implement it.",
    "created_at": "2015-12-15T16:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324651",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:89'></a>In the above commit, I've
- renamed class `Manifold` to `TopologicalManifold`
- renamed function `manifold_constructor` to `Manifold`, i.e. to the name by which it is imported 
  to the global namespace (IMHO, this makes the documentation more clear for a beginner: 
  previously, `sage: Manifold??` was returning something like `def manifold_constructor`...
  Also the html doc looks better with a single name)
- renamed class `TopologicalSubmanifold` to `OpenTopologicalSubmanifold`, to avoid any ambiguity with 
  embedded submanifolds of lower dimension
- revert the attribute `_open_covers` to a list of lists (instead of a set of frozensets), mostly to
  ensure the reproductibility of computations from one machine to another one, i.e. this garantees
  that `for ... in` loops are always performed in the same way (maybe this is something to 
  be discussed further...). Moreover, the mathematical definition of an 
  open cover refers to an indexed family, which corresponds more to a list than to a frozenset.   
- removed the method `is_open()` from `AbstractSet` (where it was always returning `True`!) and
  implemented it in `TopologicalManifold`. Now it is on the same footing as methods `superset`,
  `union` and `intersection`, which are not implemented in the base class `AbstractSet` but in each
  of the subclasses `TopologicalManifold` and `ManifoldSubset`
- removed the (unused) argument `category` from `ManifoldSubset.__init__`
- added an example to illustrate the class `OpenTopologicalSubmanifold`, as well as enough doctests
  to get a full coverage

To answer to some of your questions in the code:
- I don't think that `ManifoldPoint` must inherit from `AbstractNamedObject` since the name is
  not essential in the definition of a point (it can have no name), contrary to that of a subset. 
  Moreover, it would slower the creation of points, which can be a problem (no such problem for
  parent objects, which are not expected to be massively created)
- Yes, I think we need `list_of_subsets` to have something duplicable from one machine to another one
  (cf. remark above about `_open_covers`).

The test suite of `ManifoldSubset` and `OpenTopologicalSubmanifold` fails because of the lack of a method `lift`. What this method shall be? I guess we have to wait for the morphism ticket (#18725) to implement it.



---

archive/issue_comments_324652.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,26 @@\n+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. \n+\n+This tickets implements the following Python classes:\n+\n+- `TopologicalManifold`: topological manifold over a topological field *K*\n+  - `OpenTopologicalSubmanifold`: open subset of a topological manifold\n+- `ManifoldSubset`: generic subset of a topological manifold\n+- `ManifoldPoint`: point in a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+as well as some technical classes: `AbstractNamedObject`, `AbstractSet`, `TopologicalStructure` and\n+`RealTopologicalStructure`. \n+\n+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.\n+\n+**Documentation**:\n+The reference manual is produced by\n+`sage -docbuild reference/manifolds html`\n+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/\n+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).\n \n \n Author: Eric Gourgoulhon\n``````\n",
    "created_at": "2015-12-16T10:03:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324652",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,26 @@
+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. 
+
+This tickets implements the following Python classes:
+
+- `TopologicalManifold`: topological manifold over a topological field *K*
+  - `OpenTopologicalSubmanifold`: open subset of a topological manifold
+- `ManifoldSubset`: generic subset of a topological manifold
+- `ManifoldPoint`: point in a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+as well as some technical classes: `AbstractNamedObject`, `AbstractSet`, `TopologicalStructure` and
+`RealTopologicalStructure`. 
+
+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.
+
+**Documentation**:
+The reference manual is produced by
+`sage -docbuild reference/manifolds html`
+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/
+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).
 
 
 Author: Eric Gourgoulhon
``````




---

archive/issue_comments_324653.json:
```json
{
    "body": "Changing commit from \"3a525002469e0ef676a0dcf48f8f7f8683b85853\" to \"cb534171ae64a7f61a4ea53f41982de0e9eecbd2\"",
    "created_at": "2015-12-16T16:27:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324653",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "3a525002469e0ef676a0dcf48f8f7f8683b85853" to "cb534171ae64a7f61a4ea53f41982de0e9eecbd2"



---

archive/issue_comments_324654.json:
```json
{
    "body": "<a id='comment:91'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-12-16T16:27:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324654",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:91'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324655.json:
```json
{
    "body": "<a id='comment:92'></a>In the above commit, the class `AbstractNamedObject` has been improved so that there is no need to redefine its method `_repr_()` in the classes that inherit from it. Consequently, methods `_repr_()` have been removed from all the set and manifold classes. For all these classes, `_repr_()` and `_latex_()` are now on the same footing: they use the `AbstractNamedObject` implementation. This will also be used for the scalar field algebras of #18640.",
    "created_at": "2015-12-16T16:35:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324655",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:92'></a>In the above commit, the class `AbstractNamedObject` has been improved so that there is no need to redefine its method `_repr_()` in the classes that inherit from it. Consequently, methods `_repr_()` have been removed from all the set and manifold classes. For all these classes, `_repr_()` and `_latex_()` are now on the same footing: they use the `AbstractNamedObject` implementation. This will also be used for the scalar field algebras of #18640.



---

archive/issue_comments_324656.json:
```json
{
    "body": "Changing commit from \"cb534171ae64a7f61a4ea53f41982de0e9eecbd2\" to \"c38ae80cbd8032cf7041259284b6f646265d1e42\"",
    "created_at": "2015-12-18T12:50:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324656",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "cb534171ae64a7f61a4ea53f41982de0e9eecbd2" to "c38ae80cbd8032cf7041259284b6f646265d1e42"



---

archive/issue_comments_324657.json:
```json
{
    "body": "<a id='comment:93'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-12-18T12:50:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324657",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:93'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324658.json:
```json
{
    "body": "<a id='comment:94'></a>*Status report:* I've propagated the refactoring introduced in this ticket up to #18843 (tensor fields on diff. manifolds). In particular, I've introduced the mixin class `DifferentiableMixin` in #18783 to deal with differentiable manifolds and open submanifolds, in agreement with the diagram of comment:72. So far, so good...",
    "created_at": "2015-12-18T12:58:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324658",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:94'></a>*Status report:* I've propagated the refactoring introduced in this ticket up to #18843 (tensor fields on diff. manifolds). In particular, I've introduced the mixin class `DifferentiableMixin` in #18783 to deal with differentiable manifolds and open submanifolds, in agreement with the diagram of comment:72. So far, so good...



---

archive/issue_comments_324659.json:
```json
{
    "body": "<a id='comment:95'></a>Sorry for the delay in getting to this.\n\nReplying to [comment:89 egourgoulhon]:\n> - revert the attribute `_open_covers` to a list of lists (instead of a set of frozensets), mostly to\n>   ensure the reproductibility of computations from one machine to another one, i.e. this garantees\n>   that `for ... in` loops are always performed in the same way (maybe this is something to \n>   be discussed further...). Moreover, the mathematical definition of an \n>   open cover refers to an indexed family, which corresponds more to a list than to a frozenset.   \n\n\nThe `set` of `frozenset`s will have a faster lookup as manifolds get larger. I think this is still valid mathematically because the indexed family does not have to be ordered as far as I know. So it would be more like a `dict`, but I don't think we care about the indexing; if we did, then we should go to a `list`. For the doctests, we can just do a `sorted` or we have an internal method which returns it in a canonical way (i.e., ordered via its string representation).\n\n> - removed the method `is_open()` from `AbstractSet` (where it was always returning `True`!) and\n>   implemented it in `TopologicalManifold`.\n\n\nPerhaps the default value for `is_open` in `AbstractSet` should return an `Unknown`, be an ``@`abstract_method`, or raise a `NotImplementedError`? I'm in favor of the first one.\n\n> - removed the (unused) argument `category` from `ManifoldSubset.__init__`\n\n\nThis was previously there as I was wanting to call the `__init__`, but since I copied the constructor, this has become unnecessary. Although now I'm thinking we should have an `_init_subset` method to remove the duplicated code and have that be called by both `ManifoldSubset.__init__` and `OpenTopologicalSubmanifold.__init__`.\n\n> - added an example to illustrate the class `OpenTopologicalSubmanifold`, as well as enough doctests\n>   to get a full coverage\n\n\nThank you.\n\n> To answer to some of your questions in the code:\n> - I don't think that `ManifoldPoint` must inherit from `AbstractNamedObject` since the name is\n>   not essential in the definition of a point (it can have no name), contrary to that of a subset. \n>   Moreover, it would slower the creation of points, which can be a problem (no such problem for\n>   parent objects, which are not expected to be massively created)\n\n\nFair enough. Although if that extra little function call is going to matter, then I think we should cythonize `ManifoldPoint`.\n\n> - Yes, I think we need `list_of_subsets` to have something duplicable from one machine to another one\n>   (cf. remark above about `_open_covers`).\n\n\nSame comments about `_open_covers` as well.\n\n> The test suite of `ManifoldSubset` and `OpenTopologicalSubmanifold` fails because of the lack of a method `lift`. What this method shall be? I guess we have to wait for the morphism ticket (#18725) to implement it. \n\n\n`lift` can just be a method that creates the corresponding point in the ambient manifold, and similarly for `retract`. Once we have #18725, we can convert it to a ``@`lazy_attribute` which is set to the morphism (note that this does not change the API).\n\nI don't reall agree with comment:92. I feel that this only removes a few docstrings, adds some internal complexity, and increases memory usage (although since we aren't really using this for `TopologicalPoint`, the memory usage is less of a concern). In principle, it is a mixin class, but it just acts like an ABC. So it is perfectly valid to override its `_repr_`.\n\nI'm glad to hear the mixin class idea is working.",
    "created_at": "2015-12-18T15:36:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324659",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:95'></a>Sorry for the delay in getting to this.

Replying to [comment:89 egourgoulhon]:
> - revert the attribute `_open_covers` to a list of lists (instead of a set of frozensets), mostly to
>   ensure the reproductibility of computations from one machine to another one, i.e. this garantees
>   that `for ... in` loops are always performed in the same way (maybe this is something to 
>   be discussed further...). Moreover, the mathematical definition of an 
>   open cover refers to an indexed family, which corresponds more to a list than to a frozenset.   


The `set` of `frozenset`s will have a faster lookup as manifolds get larger. I think this is still valid mathematically because the indexed family does not have to be ordered as far as I know. So it would be more like a `dict`, but I don't think we care about the indexing; if we did, then we should go to a `list`. For the doctests, we can just do a `sorted` or we have an internal method which returns it in a canonical way (i.e., ordered via its string representation).

> - removed the method `is_open()` from `AbstractSet` (where it was always returning `True`!) and
>   implemented it in `TopologicalManifold`.


Perhaps the default value for `is_open` in `AbstractSet` should return an `Unknown`, be an ``@`abstract_method`, or raise a `NotImplementedError`? I'm in favor of the first one.

> - removed the (unused) argument `category` from `ManifoldSubset.__init__`


This was previously there as I was wanting to call the `__init__`, but since I copied the constructor, this has become unnecessary. Although now I'm thinking we should have an `_init_subset` method to remove the duplicated code and have that be called by both `ManifoldSubset.__init__` and `OpenTopologicalSubmanifold.__init__`.

> - added an example to illustrate the class `OpenTopologicalSubmanifold`, as well as enough doctests
>   to get a full coverage


Thank you.

> To answer to some of your questions in the code:
> - I don't think that `ManifoldPoint` must inherit from `AbstractNamedObject` since the name is
>   not essential in the definition of a point (it can have no name), contrary to that of a subset. 
>   Moreover, it would slower the creation of points, which can be a problem (no such problem for
>   parent objects, which are not expected to be massively created)


Fair enough. Although if that extra little function call is going to matter, then I think we should cythonize `ManifoldPoint`.

> - Yes, I think we need `list_of_subsets` to have something duplicable from one machine to another one
>   (cf. remark above about `_open_covers`).


Same comments about `_open_covers` as well.

> The test suite of `ManifoldSubset` and `OpenTopologicalSubmanifold` fails because of the lack of a method `lift`. What this method shall be? I guess we have to wait for the morphism ticket (#18725) to implement it. 


`lift` can just be a method that creates the corresponding point in the ambient manifold, and similarly for `retract`. Once we have #18725, we can convert it to a ``@`lazy_attribute` which is set to the morphism (note that this does not change the API).

I don't reall agree with comment:92. I feel that this only removes a few docstrings, adds some internal complexity, and increases memory usage (although since we aren't really using this for `TopologicalPoint`, the memory usage is less of a concern). In principle, it is a mixin class, but it just acts like an ABC. So it is perfectly valid to override its `_repr_`.

I'm glad to hear the mixin class idea is working.



---

archive/issue_comments_324660.json:
```json
{
    "body": "<a id='comment:96'></a>Replying to [comment:95 tscrim]:\n> Sorry for the delay in getting to this.\n\n\nNo problem. \n\n> \n> The `set` of `frozenset`s will have a faster lookup as manifolds get larger. I think this is still valid mathematically because the indexed family does not have to be ordered as far as I know. So it would be more like a `dict`, but I don't think we care about the indexing; if we did, then we should go to a `list`. For the doctests, we can just do a `sorted` or we have an internal method which returns it in a canonical way (i.e., ordered via its string representation).\n\n\nIt is not only a matter of doctests, but of reproductability of real computations. For instance the comparison of two vector fields on non-parallelizable manifolds makes use of open covers.  \n> \n> \n> > The test suite of `ManifoldSubset` and `OpenTopologicalSubmanifold` fails because of the lack of a method `lift`. What this method shall be? I guess we have to wait for the morphism ticket (#18725) to implement it. \n\n> \n> `lift` can just be a method that creates the corresponding point in the ambient manifold, and similarly for `retract`. Once we have #18725, we can convert it to a ``@`lazy_attribute` which is set to the morphism (note that this does not change the API).\n> \n\n\nOK, thanks.\n\n> I don't reall agree with comment:92. I feel that this only removes a few docstrings, adds some internal complexity, and increases memory usage (although since we aren't really using this for `TopologicalPoint`, the memory usage is less of a concern). In principle, it is a mixin class, but it just acts like an ABC. So it is perfectly valid to override its `_repr_`.\n\n\nOK, I will revert to the previous version.",
    "created_at": "2015-12-18T17:26:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324660",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:96'></a>Replying to [comment:95 tscrim]:
> Sorry for the delay in getting to this.


No problem. 

> 
> The `set` of `frozenset`s will have a faster lookup as manifolds get larger. I think this is still valid mathematically because the indexed family does not have to be ordered as far as I know. So it would be more like a `dict`, but I don't think we care about the indexing; if we did, then we should go to a `list`. For the doctests, we can just do a `sorted` or we have an internal method which returns it in a canonical way (i.e., ordered via its string representation).


It is not only a matter of doctests, but of reproductability of real computations. For instance the comparison of two vector fields on non-parallelizable manifolds makes use of open covers.  
> 
> 
> > The test suite of `ManifoldSubset` and `OpenTopologicalSubmanifold` fails because of the lack of a method `lift`. What this method shall be? I guess we have to wait for the morphism ticket (#18725) to implement it. 

> 
> `lift` can just be a method that creates the corresponding point in the ambient manifold, and similarly for `retract`. Once we have #18725, we can convert it to a ``@`lazy_attribute` which is set to the morphism (note that this does not change the API).
> 


OK, thanks.

> I don't reall agree with comment:92. I feel that this only removes a few docstrings, adds some internal complexity, and increases memory usage (although since we aren't really using this for `TopologicalPoint`, the memory usage is less of a concern). In principle, it is a mixin class, but it just acts like an ABC. So it is perfectly valid to override its `_repr_`.


OK, I will revert to the previous version.



---

archive/issue_comments_324661.json:
```json
{
    "body": "<a id='comment:97'></a>Replying to [comment:96 egourgoulhon]:\n> Replying to [comment:95 tscrim]:\n> > The `set` of `frozenset`s will have a faster lookup as manifolds get larger. I think this is still valid mathematically because the indexed family does not have to be ordered as far as I know. So it would be more like a `dict`, but I don't think we care about the indexing; if we did, then we should go to a `list`. For the doctests, we can just do a `sorted` or we have an internal method which returns it in a canonical way (i.e., ordered via its string representation).\n\n> \n> It is not only a matter of doctests, but of reproductability of real computations. For instance the comparison of two vector fields on non-parallelizable manifolds makes use of open covers.  \n\n\nBut does it depend on the ordering of subsets that give the open cover, or which open cover it takes? Does the API for that have any control over what order it was given (rather than the order in which the open covers were created)? What I'm getting at is that it shouldn't depend upon these things, right? Or are you trying to put a total ordering on these vector fields, and if so, why?",
    "created_at": "2015-12-18T17:33:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324661",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:97'></a>Replying to [comment:96 egourgoulhon]:
> Replying to [comment:95 tscrim]:
> > The `set` of `frozenset`s will have a faster lookup as manifolds get larger. I think this is still valid mathematically because the indexed family does not have to be ordered as far as I know. So it would be more like a `dict`, but I don't think we care about the indexing; if we did, then we should go to a `list`. For the doctests, we can just do a `sorted` or we have an internal method which returns it in a canonical way (i.e., ordered via its string representation).

> 
> It is not only a matter of doctests, but of reproductability of real computations. For instance the comparison of two vector fields on non-parallelizable manifolds makes use of open covers.  


But does it depend on the ordering of subsets that give the open cover, or which open cover it takes? Does the API for that have any control over what order it was given (rather than the order in which the open covers were created)? What I'm getting at is that it shouldn't depend upon these things, right? Or are you trying to put a total ordering on these vector fields, and if so, why?



---

archive/issue_comments_324662.json:
```json
{
    "body": "<a id='comment:98'></a>Replying to [comment:97 tscrim]:\n> Replying to [comment:96 egourgoulhon]:\n> > It is not only a matter of doctests, but of reproductability of real computations. For instance the comparison of two vector fields on non-parallelizable manifolds makes use of open covers.  \n\n> \n> But does it depend on the ordering of subsets that give the open cover, or which open cover it takes? \n\nFor this specific case (comparison), it depends on the open cover, not on the ordering of the subsets in it. \n> Does the API for that have any control over what order it was given (rather than the order in which the open covers were created)? \n\nNo there is no control at the API level, because the API is `__eq__` (one cannot pass extra parameters)\n> What I'm getting at is that it shouldn't depend upon these things, right? \n\nYes, in the ideal mathematical world. In the much less ideal symbolic world, this is not so true... The argument goes as follows: in order to have a pretty fast `__eq__` operator for tensor fields, the comparison is not performed on all the subdomains where the tensor fields have known (or computable) restrictions, but only on a single open cover, which is mathematically sufficient. So one has to pick an open cover. By making `_open_covers` a list, we ensure that the picked one is always the same. The key point is that sometimes the comparison fails because of simplification issues (no normal form for symbolic expressions), i.e. `__eq__` returns `False` while the two tensor fields are mathematically equals. This is not satisfactory but I guess this is inescapable when dealing with symbolics. At least, by making `_open_covers` a list, we garantee that the output of `__eq__`, whatever its mathematical relevance,  is consistent from one machine to the next one.",
    "created_at": "2015-12-21T10:17:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324662",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:98'></a>Replying to [comment:97 tscrim]:
> Replying to [comment:96 egourgoulhon]:
> > It is not only a matter of doctests, but of reproductability of real computations. For instance the comparison of two vector fields on non-parallelizable manifolds makes use of open covers.  

> 
> But does it depend on the ordering of subsets that give the open cover, or which open cover it takes? 

For this specific case (comparison), it depends on the open cover, not on the ordering of the subsets in it. 
> Does the API for that have any control over what order it was given (rather than the order in which the open covers were created)? 

No there is no control at the API level, because the API is `__eq__` (one cannot pass extra parameters)
> What I'm getting at is that it shouldn't depend upon these things, right? 

Yes, in the ideal mathematical world. In the much less ideal symbolic world, this is not so true... The argument goes as follows: in order to have a pretty fast `__eq__` operator for tensor fields, the comparison is not performed on all the subdomains where the tensor fields have known (or computable) restrictions, but only on a single open cover, which is mathematically sufficient. So one has to pick an open cover. By making `_open_covers` a list, we ensure that the picked one is always the same. The key point is that sometimes the comparison fails because of simplification issues (no normal form for symbolic expressions), i.e. `__eq__` returns `False` while the two tensor fields are mathematically equals. This is not satisfactory but I guess this is inescapable when dealing with symbolics. At least, by making `_open_covers` a list, we garantee that the output of `__eq__`, whatever its mathematical relevance,  is consistent from one machine to the next one.



---

archive/issue_comments_324663.json:
```json
{
    "body": "<a id='comment:99'></a>Then how about we have a `_distinguished_open_cover`, which is set to the first open cover that gets added? IMO, this will be\n\n- lightweight (just a pointer);\n- (marginally) faster (only an attribute lookup instead of attribute plus index grab; granted, this speedup will probably never be noticable);\n- keep the `O(1)` checking speed of something being an open cover;\n- and more robust when doing the comparisons (we check to see if the distinguished open cover is an open cover of the other one, so we don't have to worry about things breaking if something ends up being out of order in the creating of the open cover list).\n\nIt means one additional attribute we'll have to manage, but I think that is an epsilon cost.",
    "created_at": "2015-12-21T20:10:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324663",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:99'></a>Then how about we have a `_distinguished_open_cover`, which is set to the first open cover that gets added? IMO, this will be

- lightweight (just a pointer);
- (marginally) faster (only an attribute lookup instead of attribute plus index grab; granted, this speedup will probably never be noticable);
- keep the `O(1)` checking speed of something being an open cover;
- and more robust when doing the comparisons (we check to see if the distinguished open cover is an open cover of the other one, so we don't have to worry about things breaking if something ends up being out of order in the creating of the open cover list).

It means one additional attribute we'll have to manage, but I think that is an epsilon cost.



---

archive/issue_comments_324664.json:
```json
{
    "body": "<a id='comment:100'></a>Replying to [comment:99 tscrim]:\n> Then how about we have a `_distinguished_open_cover`, which is set to the first open cover that gets added? \n\nWell the tensor field `__eq__` mentionned above is only one of the possible examples where open covers could be involved. One may imagine that they are also used in tensor field `_add_` for instance. This is not the case at the moment, but this is certainly something to be considered when discussing the tensor field arithmetics. \nSo, at this stage, I would prefer a sequence (i.e. a Python list) of open covers instead of a set with a distinguished element. IMO, this offers a greater flexibility for future operations, like `_add_`. With a sequence, you may always say that your distinguished element is the first one, and if, for some reason, the attempted operation fails with it, you may try with the second one, and so on (while if you have only a distinguished element, you don't know what to do in case of failure).\nSo could we stay with a list at this stage?",
    "created_at": "2015-12-23T16:24:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324664",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:100'></a>Replying to [comment:99 tscrim]:
> Then how about we have a `_distinguished_open_cover`, which is set to the first open cover that gets added? 

Well the tensor field `__eq__` mentionned above is only one of the possible examples where open covers could be involved. One may imagine that they are also used in tensor field `_add_` for instance. This is not the case at the moment, but this is certainly something to be considered when discussing the tensor field arithmetics. 
So, at this stage, I would prefer a sequence (i.e. a Python list) of open covers instead of a set with a distinguished element. IMO, this offers a greater flexibility for future operations, like `_add_`. With a sequence, you may always say that your distinguished element is the first one, and if, for some reason, the attempted operation fails with it, you may try with the second one, and so on (while if you have only a distinguished element, you don't know what to do in case of failure).
So could we stay with a list at this stage?



---

archive/issue_comments_324665.json:
```json
{
    "body": "<a id='comment:101'></a>Replying to [comment:100 egourgoulhon]:\n> So could we stay with a list at this stage? \n\n\nSince you feel strongly about it, then we can leave it be. I got reminded recently about something with premature optimization and the root of all evil... :P",
    "created_at": "2015-12-23T17:33:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324665",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:101'></a>Replying to [comment:100 egourgoulhon]:
> So could we stay with a list at this stage? 


Since you feel strongly about it, then we can leave it be. I got reminded recently about something with premature optimization and the root of all evil... :P



---

archive/issue_comments_324666.json:
```json
{
    "body": "Changing commit from \"c38ae80cbd8032cf7041259284b6f646265d1e42\" to \"19caedb4d055887ad33ab2ab7b051d166bd58c90\"",
    "created_at": "2016-01-03T19:49:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324666",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "c38ae80cbd8032cf7041259284b6f646265d1e42" to "19caedb4d055887ad33ab2ab7b051d166bd58c90"



---

archive/issue_comments_324667.json:
```json
{
    "body": "<a id='comment:2'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-03T19:49:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324667",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324668.json:
```json
{
    "body": "<a id='comment:103'></a>Replying to [comment:95 tscrim]:\n> \n> I don't reall agree with comment:92. I feel that this only removes a few docstrings, adds some internal complexity, and increases memory usage (although since we aren't really using this for `TopologicalPoint`, the memory usage is less of a concern). In principle, it is a mixin class, but it just acts like an ABC. So it is perfectly valid to override its `_repr_`.\n> \n\nIn the above commit, I've reverted to the previous version of `AbstractNamedObject` and have restored the `_repr_` methods.",
    "created_at": "2016-01-03T19:54:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324668",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:103'></a>Replying to [comment:95 tscrim]:
> 
> I don't reall agree with comment:92. I feel that this only removes a few docstrings, adds some internal complexity, and increases memory usage (although since we aren't really using this for `TopologicalPoint`, the memory usage is less of a concern). In principle, it is a mixin class, but it just acts like an ABC. So it is perfectly valid to override its `_repr_`.
> 

In the above commit, I've reverted to the previous version of `AbstractNamedObject` and have restored the `_repr_` methods.



---

archive/issue_comments_324669.json:
```json
{
    "body": "<a id='comment:4'></a>Okay,thanks. So the only thing left to do is implement\n\n```python\ndef lift(self, p):\n    return self._manifold(p)\n\ndef retract(self, p):\n    return self(p)\n```\nfor the subset class (not that we will really use them). Once that is done, I believe the only thing left is for me to take one last look through everything. Thank you for all your work on this.",
    "created_at": "2016-01-03T23:40:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324669",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>Okay,thanks. So the only thing left to do is implement

```python
def lift(self, p):
    return self._manifold(p)

def retract(self, p):
    return self(p)
```
for the subset class (not that we will really use them). Once that is done, I believe the only thing left is for me to take one last look through everything. Thank you for all your work on this.



---

archive/issue_comments_324670.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-04T11:14:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324670",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324671.json:
```json
{
    "body": "Changing commit from \"19caedb4d055887ad33ab2ab7b051d166bd58c90\" to \"3cd03a48d847e12745ed8c25b23f19db141c179a\"",
    "created_at": "2016-01-04T11:14:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324671",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "19caedb4d055887ad33ab2ab7b051d166bd58c90" to "3cd03a48d847e12745ed8c25b23f19db141c179a"



---

archive/issue_comments_324672.json:
```json
{
    "body": "<a id='comment:106'></a>The above commit implements the methods `lift` and `retract` as you suggested; it also implements the method `__eq__` in class `CoordChange`, which fixes the `_test_pickling` of that class.",
    "created_at": "2016-01-04T11:17:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324672",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:106'></a>The above commit implements the methods `lift` and `retract` as you suggested; it also implements the method `__eq__` in class `CoordChange`, which fixes the `_test_pickling` of that class.



---

archive/issue_comments_324673.json:
```json
{
    "body": "<a id='comment:7'></a>I've continued to propagate the refactorization initialized in comment:67 up to #19124 (curves in differentiable manifolds) in the ticket hierarchy of #18528. At this stage, the class hierarchy is an extension of the second diagram of comment:72:\n\n```\nHierarchy-1:\n               AbstractSet\n               /         \\\n     ManifoldSubset    TopologicalManifold\n             |      ____/        |\n             |     /             |\n  OpenTopSubmanifold             |\n     |                           |\n     |     DifferentiableMixin   |\n     |       /              \\    |\n  OpenDiffSubmanifold   DifferentiableManifold\n     |                           |\n     |      IntervalMixin        |\n     |       /          \\        |\n  OpenSubinterval       OpenInterval\n                             |\n                         RealLine\n```\nNow, prior to the refactoring, the class hierarchy was\n\n```\nHierarchy-2:\n\n      ManifoldSubset\n            |\n     TopologicalManifold\n            |\n   DifferentiableManifold\n            |\n        OpenInterval\n            |\n        RealLine\n```  \nIt is clear that Hierarchy-2 is much simpler than Hierarchy-1: it involves much less classes and has no multiple heritage issues. Moreover, Hierarchy-2 reflects fully the mathematics: the real line **R** is the open interval (-oo, +oo), which is a 1-dimensional differentiable manifold, which is a 1-dimensional topological manifold, which is a subset of a topological manifold (itself). Within Hierarchy-2, open subsets are not handled by a specific class, but directly by the manifold classes: an open subset of a topological (resp. differentiable) manifold is created as an instance of `TopologicalManifold` (resp. `DifferentiableManifold`). Again, this reflects the mathematics since an open subset of a manifold inherits the manifold structure. \nThe classes of Hierarchy-2 have an attribute `_manifold` (which could also be called `_ambient`), which is the only piece that permits to distinguish between a manifold per se (`_manifold` is then set to `self`) and an open subset of a larger manifold (`_manifold` is then set to the latter). In Hierarchy-1, the attribute `_manifold` exists only for the subset classes. For motivating Hierarchy-1, you said that it avoids tests of the type `self is self._manifold`. Now, in Hierarchy-2, these tests appear only in two places: (i) the `_repr_` method (to return \"Open subset of...\" instead of \"Manifold...\") and (ii) the `union` and `intersection` methods. Hence the question: are there any other reason to introduce Hierarchy-1? Given its complexity, as compared with Hierarchy-2, I am wondering whether it is worth continuing with it...\nNote that with Hierarchy-2, one can still distinguish open subsets from the ambient manifold by the category: `Manifolds(K).Subobjects()` for open subsets versus `Manifolds(K)` for the ambient manifold. There is no need to have a separate class for this.\nAnother argument in favor of Hierarchy-2 regards the construction of a new manifold by the disjoint union of two manifolds (not implemented yet): suppose we have two manifolds *A* and *B* of the same dimension over the same topological field **K**. We can then form the manifold *M = A* U *B* and consider *A* and *B* as open subsets of *M* by simplify changing their attribute `_manifold` from `self` to *M*. With Hierarchy-1, one would need to create brand new objects of the subset type by copying all the information (atlases, vector frames, etc.) contained in *A* and *B*.",
    "created_at": "2016-01-04T20:53:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324673",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:7'></a>I've continued to propagate the refactorization initialized in comment:67 up to #19124 (curves in differentiable manifolds) in the ticket hierarchy of #18528. At this stage, the class hierarchy is an extension of the second diagram of comment:72:

```
Hierarchy-1:
               AbstractSet
               /         \
     ManifoldSubset    TopologicalManifold
             |      ____/        |
             |     /             |
  OpenTopSubmanifold             |
     |                           |
     |     DifferentiableMixin   |
     |       /              \    |
  OpenDiffSubmanifold   DifferentiableManifold
     |                           |
     |      IntervalMixin        |
     |       /          \        |
  OpenSubinterval       OpenInterval
                             |
                         RealLine
```
Now, prior to the refactoring, the class hierarchy was

```
Hierarchy-2:

      ManifoldSubset
            |
     TopologicalManifold
            |
   DifferentiableManifold
            |
        OpenInterval
            |
        RealLine
```  
It is clear that Hierarchy-2 is much simpler than Hierarchy-1: it involves much less classes and has no multiple heritage issues. Moreover, Hierarchy-2 reflects fully the mathematics: the real line **R** is the open interval (-oo, +oo), which is a 1-dimensional differentiable manifold, which is a 1-dimensional topological manifold, which is a subset of a topological manifold (itself). Within Hierarchy-2, open subsets are not handled by a specific class, but directly by the manifold classes: an open subset of a topological (resp. differentiable) manifold is created as an instance of `TopologicalManifold` (resp. `DifferentiableManifold`). Again, this reflects the mathematics since an open subset of a manifold inherits the manifold structure. 
The classes of Hierarchy-2 have an attribute `_manifold` (which could also be called `_ambient`), which is the only piece that permits to distinguish between a manifold per se (`_manifold` is then set to `self`) and an open subset of a larger manifold (`_manifold` is then set to the latter). In Hierarchy-1, the attribute `_manifold` exists only for the subset classes. For motivating Hierarchy-1, you said that it avoids tests of the type `self is self._manifold`. Now, in Hierarchy-2, these tests appear only in two places: (i) the `_repr_` method (to return "Open subset of..." instead of "Manifold...") and (ii) the `union` and `intersection` methods. Hence the question: are there any other reason to introduce Hierarchy-1? Given its complexity, as compared with Hierarchy-2, I am wondering whether it is worth continuing with it...
Note that with Hierarchy-2, one can still distinguish open subsets from the ambient manifold by the category: `Manifolds(K).Subobjects()` for open subsets versus `Manifolds(K)` for the ambient manifold. There is no need to have a separate class for this.
Another argument in favor of Hierarchy-2 regards the construction of a new manifold by the disjoint union of two manifolds (not implemented yet): suppose we have two manifolds *A* and *B* of the same dimension over the same topological field **K**. We can then form the manifold *M = A* U *B* and consider *A* and *B* as open subsets of *M* by simplify changing their attribute `_manifold` from `self` to *M*. With Hierarchy-1, one would need to create brand new objects of the subset type by copying all the information (atlases, vector frames, etc.) contained in *A* and *B*.



---

archive/issue_comments_324674.json:
```json
{
    "body": "<a id='comment:8'></a>There are 2 really, really good ideas for having a more complicated class hierarchy: encapsulation and localization.\n\nYou had many `if self._manifold is self:` statements, which breaks the localization principle; it is acting differently because it is essentially a different object. This is a strong code smell and you had enough of these at this level to (IMO) warrant splitting the classes.\n\nAdditionally, subsets of a manifold are precisely that, subsets. So we should encapsulate that in separate classes. Mathematically we identity an open subset as a manifold, but by doing so, we loose the information that it is really a subset of another manifold. As such, I feel that having separate classes actually better reflects the mathematics.\n\nIn an ideal world, I would like to have a hierarchy similar to Hierachy-2, but with an additional subclass corresponding to each type of manifold that is obtained by adding a subset mixin class. Yet, that doesn't seem possible with the current core design.\n\nWhile the Hierarchy-1 seems more complicated, it actually will be easier to maintain and debug as code is local to the class (i.e., if you are a subclass of `A`, then you act in the same way and like `A` irregardless of your input).\n\nThis assessment is based on my experiences and what I learned as good OOP principles. However, I have not looked at SageManifolds beyond this ticket at present, whereas you have worked heavily on it. So perhaps we can get some more data. How many times before the refactoring did you have to do a `self._manifold is self` test? Also what is your thoughts on maintenance and extendability?\n\nSomething else might be to get a 3rd party's opinion (Nicolas and/or Darij comes to my mind). I could also sit down and plan out how I would do everything from the ground up to see if I can devise a better overall strategy if you think there might be some benefit to that at this stage.",
    "created_at": "2016-01-05T07:55:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324674",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>There are 2 really, really good ideas for having a more complicated class hierarchy: encapsulation and localization.

You had many `if self._manifold is self:` statements, which breaks the localization principle; it is acting differently because it is essentially a different object. This is a strong code smell and you had enough of these at this level to (IMO) warrant splitting the classes.

Additionally, subsets of a manifold are precisely that, subsets. So we should encapsulate that in separate classes. Mathematically we identity an open subset as a manifold, but by doing so, we loose the information that it is really a subset of another manifold. As such, I feel that having separate classes actually better reflects the mathematics.

In an ideal world, I would like to have a hierarchy similar to Hierachy-2, but with an additional subclass corresponding to each type of manifold that is obtained by adding a subset mixin class. Yet, that doesn't seem possible with the current core design.

While the Hierarchy-1 seems more complicated, it actually will be easier to maintain and debug as code is local to the class (i.e., if you are a subclass of `A`, then you act in the same way and like `A` irregardless of your input).

This assessment is based on my experiences and what I learned as good OOP principles. However, I have not looked at SageManifolds beyond this ticket at present, whereas you have worked heavily on it. So perhaps we can get some more data. How many times before the refactoring did you have to do a `self._manifold is self` test? Also what is your thoughts on maintenance and extendability?

Something else might be to get a 3rd party's opinion (Nicolas and/or Darij comes to my mind). I could also sit down and plan out how I would do everything from the ground up to see if I can devise a better overall strategy if you think there might be some benefit to that at this stage.



---

archive/issue_comments_324675.json:
```json
{
    "body": "<a id='comment:109'></a>Replying to [comment:108 tscrim]:\n> \n> You had many `if self._manifold is self:` statements, which breaks the localization principle; \n\n\nWell not so many: grep returns only 5 occurences in the whole SageManifolds:\n- in `TopologicalManifold._repr_` for returning \"Manifold...\" instead of \"Open subset of manifold...\"\n- in `DifferentiableManifold._repr_` for the same reason\n- in `ManifoldSubset.superset`, because a superset can only be `self` in case of the whole manifold\n- in `ManifoldSubset.intersection`, because the intersection with the whole manifold is trivial\n- in `ManifoldSubset.union`, because the union with the whole manifold is trivial\n \n> \n> Additionally, subsets of a manifold are precisely that, subsets. So we should encapsulate that in separate classes. Mathematically we identity an open subset as a manifold, but by doing so, we loose the information that it is really a subset of another manifold. As such, I feel that having separate classes actually better reflects the mathematics.\n\n\nActually, at the moment, we are dealing with the open subsets in exactly the same way as we are doing with the whole manifold, i.e. we set up charts on them, define tensor fields, etc. This can be seen by noticing that in Hierarchy-1, the class `OpenTopSubmanifold` has very few methods in addition to those inherited from `TopologicalManifold`. Similarly, none of the classes `OpenDiffSubmanifold` and `DifferentiableManifold` introduces any attribute or method by itself, in addition to those inherited from `DifferentiableMixin` (except for their `__init__`). \nMaybe, in a future development, one could have operations that make sense only for open subsets or only for the whole manifold. Then having two separate classes is clearly the way to go. However,  at the moment I don't see any such operation, apart from those listed above: the printout (via `_repr_`) and the union/intersection with other subsets. \n\n> \n> In an ideal world, I would like to have a hierarchy similar to Hierachy-2, but with an additional subclass corresponding to each type of manifold that is obtained by adding a subset mixin class. Yet, that doesn't seem possible with the current core design.\n> \n> While the Hierarchy-1 seems more complicated, it actually will be easier to maintain and debug as code is local to the class (i.e., if you are a subclass of `A`, then you act in the same way and like `A` irregardless of your input).\n> \n> This assessment is based on my experiences and what I learned as good OOP principles. However, I have not looked at SageManifolds beyond this ticket at present, whereas you have worked heavily on it. So perhaps we can get some more data. How many times before the refactoring did you have to do a `self._manifold is self` test? \n\n\nFive times, as mentioned above. \n\n> Also what is your thoughts on maintenance and extendability?\n\n\nIt seems to me that, in terms of maintenance, Hierarchy-2 is better, being simpler; it is also certainly better for somebody new entering into the code. \nOn the contrary, if one regards extendability, Hierarchy-1 offers the possibility to have different operations for manifolds and subsets, as mentioned above. This is a good point in favor of it. Even if at the moment I don't have in mind any such operation (apart from those listed above), I would slightly tend to maintain Hierarchy-1 because of this.  \n\n> \n> Something else might be to get a 3rd party's opinion (Nicolas and/or Darij comes to my mind).\n\n\nYes extra points of view would be helpful! In addition to Nicolas and Darij, I don't know if other people associated to this ticket (Vincent, John, Nils, Jeoren,...) are reading this and have an opinion...\n\n> I could also sit down and plan out how I would do everything from the ground up to see if I can devise a better overall strategy if you think there might be some benefit to that at this stage.\n\n\nThanks, but maybe this is not necessary at this stage, especially if we conclude that we maintain Hierarchy-1. Since all this has little impact on the user interface, maybe we could rediscuss it after having a whole view of all the manifold tickets.",
    "created_at": "2016-01-05T14:20:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324675",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:109'></a>Replying to [comment:108 tscrim]:
> 
> You had many `if self._manifold is self:` statements, which breaks the localization principle; 


Well not so many: grep returns only 5 occurences in the whole SageManifolds:
- in `TopologicalManifold._repr_` for returning "Manifold..." instead of "Open subset of manifold..."
- in `DifferentiableManifold._repr_` for the same reason
- in `ManifoldSubset.superset`, because a superset can only be `self` in case of the whole manifold
- in `ManifoldSubset.intersection`, because the intersection with the whole manifold is trivial
- in `ManifoldSubset.union`, because the union with the whole manifold is trivial
 
> 
> Additionally, subsets of a manifold are precisely that, subsets. So we should encapsulate that in separate classes. Mathematically we identity an open subset as a manifold, but by doing so, we loose the information that it is really a subset of another manifold. As such, I feel that having separate classes actually better reflects the mathematics.


Actually, at the moment, we are dealing with the open subsets in exactly the same way as we are doing with the whole manifold, i.e. we set up charts on them, define tensor fields, etc. This can be seen by noticing that in Hierarchy-1, the class `OpenTopSubmanifold` has very few methods in addition to those inherited from `TopologicalManifold`. Similarly, none of the classes `OpenDiffSubmanifold` and `DifferentiableManifold` introduces any attribute or method by itself, in addition to those inherited from `DifferentiableMixin` (except for their `__init__`). 
Maybe, in a future development, one could have operations that make sense only for open subsets or only for the whole manifold. Then having two separate classes is clearly the way to go. However,  at the moment I don't see any such operation, apart from those listed above: the printout (via `_repr_`) and the union/intersection with other subsets. 

> 
> In an ideal world, I would like to have a hierarchy similar to Hierachy-2, but with an additional subclass corresponding to each type of manifold that is obtained by adding a subset mixin class. Yet, that doesn't seem possible with the current core design.
> 
> While the Hierarchy-1 seems more complicated, it actually will be easier to maintain and debug as code is local to the class (i.e., if you are a subclass of `A`, then you act in the same way and like `A` irregardless of your input).
> 
> This assessment is based on my experiences and what I learned as good OOP principles. However, I have not looked at SageManifolds beyond this ticket at present, whereas you have worked heavily on it. So perhaps we can get some more data. How many times before the refactoring did you have to do a `self._manifold is self` test? 


Five times, as mentioned above. 

> Also what is your thoughts on maintenance and extendability?


It seems to me that, in terms of maintenance, Hierarchy-2 is better, being simpler; it is also certainly better for somebody new entering into the code. 
On the contrary, if one regards extendability, Hierarchy-1 offers the possibility to have different operations for manifolds and subsets, as mentioned above. This is a good point in favor of it. Even if at the moment I don't have in mind any such operation (apart from those listed above), I would slightly tend to maintain Hierarchy-1 because of this.  

> 
> Something else might be to get a 3rd party's opinion (Nicolas and/or Darij comes to my mind).


Yes extra points of view would be helpful! In addition to Nicolas and Darij, I don't know if other people associated to this ticket (Vincent, John, Nils, Jeoren,...) are reading this and have an opinion...

> I could also sit down and plan out how I would do everything from the ground up to see if I can devise a better overall strategy if you think there might be some benefit to that at this stage.


Thanks, but maybe this is not necessary at this stage, especially if we conclude that we maintain Hierarchy-1. Since all this has little impact on the user interface, maybe we could rediscuss it after having a whole view of all the manifold tickets.



---

archive/issue_comments_324676.json:
```json
{
    "body": "<a id='comment:0'></a>Giving a second thought to this, another hierarchy that would preserve the distinction between whole manifolds and open subsets is \n\n```\nHierarchy-3: \n\n AbstractAmbient          ManifoldSubset\n   |  |  |                      |\n   |  |  |               OpenTopSubmanifold\n   |  |   \\               /     |\n   |  |   TopologicalManifold   |\n   |  |                         |\n   |  |                OpenDiffSubmanifold\n   |   \\                  /     |\n   |   DifferentiableManifold   |\n   |                            |\n   |                   OpenSubinterval\n    \\____            ____/\n         OpenInterval\n              |\n          RealLine\n```\nThe class `AbstractAmbient` would only implement the methods `union` and `intersection`, which are trivial in this case. Each of the classes `TopologicalManifold`, `DifferentiableManifold` and `OpenInterval` would implement only the method `_repr_`. \n\nHierarchy-3 is simpler than Hierarchy-1 and does not require any mixin class. \nIt is also easy to add a new structure, like complex manifolds. \nHierarchy-3 is also mathematically neat, since a topological (resp. differentiable) manifold is obviously a open subset of a topological (resp. differentiable) manifold. In this respect it reverses the logic of Hierarchy-1, where the class `OpenTopSubmanifold` inherits from `TopologicalManifold`, not the opposite. Maybe the latter logic is quite well spread for *algebraic* structures in Sage, I mean classes for substructures inheriting from classes for the ambient structure. But for *topology*, the reverse logic, as proposed in Hierarchy-3, could be more adapted: a topological space is often treated as an open subset of itself. For instance, this occurs in its very definition: a topological space is a set X endowed with a collection of subsets of X, called the open subsets, such that the empty set and X are open, etc. \nWhat do you think?",
    "created_at": "2016-01-05T15:34:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324676",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:0'></a>Giving a second thought to this, another hierarchy that would preserve the distinction between whole manifolds and open subsets is 

```
Hierarchy-3: 

 AbstractAmbient          ManifoldSubset
   |  |  |                      |
   |  |  |               OpenTopSubmanifold
   |  |   \               /     |
   |  |   TopologicalManifold   |
   |  |                         |
   |  |                OpenDiffSubmanifold
   |   \                  /     |
   |   DifferentiableManifold   |
   |                            |
   |                   OpenSubinterval
    \____            ____/
         OpenInterval
              |
          RealLine
```
The class `AbstractAmbient` would only implement the methods `union` and `intersection`, which are trivial in this case. Each of the classes `TopologicalManifold`, `DifferentiableManifold` and `OpenInterval` would implement only the method `_repr_`. 

Hierarchy-3 is simpler than Hierarchy-1 and does not require any mixin class. 
It is also easy to add a new structure, like complex manifolds. 
Hierarchy-3 is also mathematically neat, since a topological (resp. differentiable) manifold is obviously a open subset of a topological (resp. differentiable) manifold. In this respect it reverses the logic of Hierarchy-1, where the class `OpenTopSubmanifold` inherits from `TopologicalManifold`, not the opposite. Maybe the latter logic is quite well spread for *algebraic* structures in Sage, I mean classes for substructures inheriting from classes for the ambient structure. But for *topology*, the reverse logic, as proposed in Hierarchy-3, could be more adapted: a topological space is often treated as an open subset of itself. For instance, this occurs in its very definition: a topological space is a set X endowed with a collection of subsets of X, called the open subsets, such that the empty set and X are open, etc. 
What do you think?



---

archive/issue_comments_324677.json:
```json
{
    "body": "<a id='comment:1'></a>Here is another proposal, which is a kind of mix between Hierarchy-1 and Hierarchy-3:\n\n```\n\nHierarchy-4:\n\n AbstractAmbient           AbstractSet              AbstractSubset\n   |  |  |                      |    \\              /   |   |   |\n   |  |  |                      |     ManifoldSubset    |   |   |\n   |  |  |                      |                       |   |   |\n   |  |  |           TopologicalManifoldOpenSet         |   |   |\n   |  |   \\               /     |       \\              /    |   |\n   |  |   TopologicalManifold   |     OpenTopSubmanifold    |   |\n   |  |                         |                           |   |\n   |  |            DifferentiableManifoldOpenSet            |   |\n   |   \\                  /     |        \\                 /    |\n   |   DifferentiableManifold   |        OpenDiffSubmanifold    |\n   |                            |                               |\n   |                     IntervalOpenSet                       /\n    \\____            ____/            \\             __________/\n         OpenInterval                OpenSubInterval\n              |\n          RealLine\n```\nContrary to Hierarchy-1, it has no diamond problem and involves no mixin class.\nAs in Hierarchy-3, the class `AbstractAmbient` implements only the methods `union` and `intersection`, but contrary to Hierarchy-3, the classes for ambient objects (`TopologicalManifold`, `DifferentiableManifold`, etc.) do no longer have the attribute `_manifold`. This attribute is present only in the sub-object classes `OpenTopSubmanifold`, `OpenDiffSubmanifold` and `OpenSubinterval`, as in Hierarchy-1. In Hierarchy-4, the attribute `_manifold` is inherited from `AbstractSubset`. The class `ManifoldSubset` implements generic (not open) subsets of a manifold.\nThe classes `TopologicalManifold` and `OpenTopSubmanifold` do not implement\nany new method by themselves: most methods are implemented in their parent\nabstract class `TopologicalManifoldOpenSet`, like `chart()`, `atlas()`,\n`scalar_field_algebra()`, etc.\nSimilarly, methods for differentiable manifolds, like `vector_frame()` or\n`tensor_field()`, are implemented in the abstract class `DifferentiableManifoldOpenSet`.",
    "created_at": "2016-01-08T10:37:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324677",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:1'></a>Here is another proposal, which is a kind of mix between Hierarchy-1 and Hierarchy-3:

```

Hierarchy-4:

 AbstractAmbient           AbstractSet              AbstractSubset
   |  |  |                      |    \              /   |   |   |
   |  |  |                      |     ManifoldSubset    |   |   |
   |  |  |                      |                       |   |   |
   |  |  |           TopologicalManifoldOpenSet         |   |   |
   |  |   \               /     |       \              /    |   |
   |  |   TopologicalManifold   |     OpenTopSubmanifold    |   |
   |  |                         |                           |   |
   |  |            DifferentiableManifoldOpenSet            |   |
   |   \                  /     |        \                 /    |
   |   DifferentiableManifold   |        OpenDiffSubmanifold    |
   |                            |                               |
   |                     IntervalOpenSet                       /
    \____            ____/            \             __________/
         OpenInterval                OpenSubInterval
              |
          RealLine
```
Contrary to Hierarchy-1, it has no diamond problem and involves no mixin class.
As in Hierarchy-3, the class `AbstractAmbient` implements only the methods `union` and `intersection`, but contrary to Hierarchy-3, the classes for ambient objects (`TopologicalManifold`, `DifferentiableManifold`, etc.) do no longer have the attribute `_manifold`. This attribute is present only in the sub-object classes `OpenTopSubmanifold`, `OpenDiffSubmanifold` and `OpenSubinterval`, as in Hierarchy-1. In Hierarchy-4, the attribute `_manifold` is inherited from `AbstractSubset`. The class `ManifoldSubset` implements generic (not open) subsets of a manifold.
The classes `TopologicalManifold` and `OpenTopSubmanifold` do not implement
any new method by themselves: most methods are implemented in their parent
abstract class `TopologicalManifoldOpenSet`, like `chart()`, `atlas()`,
`scalar_field_algebra()`, etc.
Similarly, methods for differentiable manifolds, like `vector_frame()` or
`tensor_field()`, are implemented in the abstract class `DifferentiableManifoldOpenSet`.



---

archive/issue_comments_324678.json:
```json
{
    "body": "<a id='comment:2'></a>I think if we are really going to go through with what might be some hard work and separate out the subset features, we should just do this:\n\n```\n   AbstractSet                                  AbstractSubsetMixin\n        |                                           |   |   |\n        |                                          /    |   |\n TopologicalManifold                              /     |   |\n        |          \\_____                        /     /    |\n        |                \\                      /     /     |\n        |                 TopologicalSubmanifold     /      |\nDifferentiableManifold                              /      /\n        |            \\__                           /      /\n        |               \\                         /      /\n        |                DifferentiableSubmanifold      /\n   OpenInterval                                        /\n        |     \\__________                 ____________/\n        |                \\               /\n        |                 OpenSubinterval\n     RealLine\n```\nIt is what I was hoping to obtain, but had trouble separating out the subset portion because there still is a small diamond problem with `Parent`. Which is why `AbstractSubset` would have to be a mixin, both in this hierarchy and Hierarchy-3,4 to be effective.\n\nIt does seem like perhaps Hierarchy-2 would be the best since there is so few tests for `if self._manifold is self`. The biggest trouble I have with this is the separations of concerns: that it makes it somewhat harder to separate these classes later if they start needing different attributes. We also have well-established code in Sage for which there is a different class for subobjects.\n\nAh hell, perhaps we should just revert back to Hierarchy-2 to keep the simplicity. I'm starting to wonder if there is perhaps a more fundamental issue in that we are trying to be too close to the mathematical definitions rather than be programmers, which could potentially be a complete rewrite of most things. However, we have working code, which is always better than no code. Anyways, I'm going to shutup now and just ask do you want me to handle the revert or are you willing to do it?",
    "created_at": "2016-01-10T03:43:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324678",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>I think if we are really going to go through with what might be some hard work and separate out the subset features, we should just do this:

```
   AbstractSet                                  AbstractSubsetMixin
        |                                           |   |   |
        |                                          /    |   |
 TopologicalManifold                              /     |   |
        |          \_____                        /     /    |
        |                \                      /     /     |
        |                 TopologicalSubmanifold     /      |
DifferentiableManifold                              /      /
        |            \__                           /      /
        |               \                         /      /
        |                DifferentiableSubmanifold      /
   OpenInterval                                        /
        |     \__________                 ____________/
        |                \               /
        |                 OpenSubinterval
     RealLine
```
It is what I was hoping to obtain, but had trouble separating out the subset portion because there still is a small diamond problem with `Parent`. Which is why `AbstractSubset` would have to be a mixin, both in this hierarchy and Hierarchy-3,4 to be effective.

It does seem like perhaps Hierarchy-2 would be the best since there is so few tests for `if self._manifold is self`. The biggest trouble I have with this is the separations of concerns: that it makes it somewhat harder to separate these classes later if they start needing different attributes. We also have well-established code in Sage for which there is a different class for subobjects.

Ah hell, perhaps we should just revert back to Hierarchy-2 to keep the simplicity. I'm starting to wonder if there is perhaps a more fundamental issue in that we are trying to be too close to the mathematical definitions rather than be programmers, which could potentially be a complete rewrite of most things. However, we have working code, which is always better than no code. Anyways, I'm going to shutup now and just ask do you want me to handle the revert or are you willing to do it?



---

archive/issue_comments_324679.json:
```json
{
    "body": "<a id='comment:113'></a>Replying to [comment:112 tscrim]:\n> It is what I was hoping to obtain, but had trouble separating out the subset portion because there still is a small diamond problem with `Parent`. Which is why `AbstractSubset` would have to be a mixin, both in this hierarchy and Hierarchy-3,4 to be effective.\n\n\nYes. Similarly `AbstractAmbient` in Hierarchy-4 has to be a mixin, so that only `AbstractSet` inheritates from `Parent`.\n\n> \n> It does seem like perhaps Hierarchy-2 would be the best since there is so few tests for `if self._manifold is self`. The biggest trouble I have with this is the separations of concerns: that it makes it somewhat harder to separate these classes later if they start needing different attributes. We also have well-established code in Sage for which there is a different class for subobjects.\n\n\nAs said before, it is difficult to see at the monent what kind of different attributes would exist for manifolds and open submanifolds. Basically, our open submanifolds behave just like manifolds, especially when defining fields on them. This reflects the fact that both are open sets, which is the true basic structure in topology. Things are probably different in other parts of Sage, which deal with algebraic structures, instead of topological ones.\n> \n> Ah hell, perhaps we should just revert back to Hierarchy-2 to keep the simplicity. I'm starting to wonder if there is perhaps a more fundamental issue in that we are trying to be too close to the mathematical definitions rather than be programmers, which could potentially be a complete rewrite of most things. However, we have working code, which is always better than no code. \n\n\nOK, let us revert to Hierarchy-2. It is simple, effective, offers a better gathering of documentation, and, via `self._manifold = self`, it embodies the fact that a manifold is an open subset of itself, which is not a totally crazy mathematical idea.\nAnyway, the whole discussion has been very interesting (at least to me) and we can keep the above diagrams for future thoughts.\n>Anyways, I'm going to shutup now and just ask do you want me to handle the revert or are you willing to do it?\n\nI will do it. Of course, it will not be a complete revert to the state prior to your refactorization: we shall keep your singleton classes for the structure (topological, differentiable, etc.) and your removal of facade parents, which are nice features.",
    "created_at": "2016-01-10T14:29:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324679",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:113'></a>Replying to [comment:112 tscrim]:
> It is what I was hoping to obtain, but had trouble separating out the subset portion because there still is a small diamond problem with `Parent`. Which is why `AbstractSubset` would have to be a mixin, both in this hierarchy and Hierarchy-3,4 to be effective.


Yes. Similarly `AbstractAmbient` in Hierarchy-4 has to be a mixin, so that only `AbstractSet` inheritates from `Parent`.

> 
> It does seem like perhaps Hierarchy-2 would be the best since there is so few tests for `if self._manifold is self`. The biggest trouble I have with this is the separations of concerns: that it makes it somewhat harder to separate these classes later if they start needing different attributes. We also have well-established code in Sage for which there is a different class for subobjects.


As said before, it is difficult to see at the monent what kind of different attributes would exist for manifolds and open submanifolds. Basically, our open submanifolds behave just like manifolds, especially when defining fields on them. This reflects the fact that both are open sets, which is the true basic structure in topology. Things are probably different in other parts of Sage, which deal with algebraic structures, instead of topological ones.
> 
> Ah hell, perhaps we should just revert back to Hierarchy-2 to keep the simplicity. I'm starting to wonder if there is perhaps a more fundamental issue in that we are trying to be too close to the mathematical definitions rather than be programmers, which could potentially be a complete rewrite of most things. However, we have working code, which is always better than no code. 


OK, let us revert to Hierarchy-2. It is simple, effective, offers a better gathering of documentation, and, via `self._manifold = self`, it embodies the fact that a manifold is an open subset of itself, which is not a totally crazy mathematical idea.
Anyway, the whole discussion has been very interesting (at least to me) and we can keep the above diagrams for future thoughts.
>Anyways, I'm going to shutup now and just ask do you want me to handle the revert or are you willing to do it?

I will do it. Of course, it will not be a complete revert to the state prior to your refactorization: we shall keep your singleton classes for the structure (topological, differentiable, etc.) and your removal of facade parents, which are nice features.



---

archive/issue_comments_324680.json:
```json
{
    "body": "<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-10T22:28:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324680",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324681.json:
```json
{
    "body": "Changing commit from \"3cd03a48d847e12745ed8c25b23f19db141c179a\" to \"984c3c26bf827f44eee26fc6afd321e11dca8f2e\"",
    "created_at": "2016-01-10T22:28:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324681",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "3cd03a48d847e12745ed8c25b23f19db141c179a" to "984c3c26bf827f44eee26fc6afd321e11dca8f2e"



---

archive/issue_comments_324682.json:
```json
{
    "body": "<a id='comment:5'></a>Following comment:113, the above commit reverts to Hierarchy-2 (only the first two items of it,  `ManifoldSubset` and `TopologicalManifold` are implemented in this ticket).",
    "created_at": "2016-01-10T22:37:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324682",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:5'></a>Following comment:113, the above commit reverts to Hierarchy-2 (only the first two items of it,  `ManifoldSubset` and `TopologicalManifold` are implemented in this ticket).



---

archive/issue_comments_324683.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-01-10T22:37:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324683",
    "user": "https://github.com/egourgoulhon"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_324684.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,24 @@\n+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.\n+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. \n+\n+This tickets implements the following Python classes:\n+\n+- `ManifoldSubset`: generic subset of a topological manifold (the open subsets being implemented by the subsclass `TopologicalManifold`)\n+  - `TopologicalManifold`: topological manifold over a topological field *K*\n+- `ManifoldPoint`: point in a topological manifold\n+- `Chart`: chart of a topological manifold\n+  - `RealChart`: chart of a topological manifold over the real field\n+- `CoordChange`: transition map between two charts of a topological manifold\n+\n+as well as the singleton classes`TopologicalStructure` and `RealTopologicalStructure`. \n+\n+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.\n+\n+**Documentation**:\n+The reference manual is produced by\n+`sage -docbuild reference/manifolds html`\n+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/\n+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).\n \n \n Author: Eric Gourgoulhon\n``````\n",
    "created_at": "2016-01-10T22:45:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324684",
    "user": "https://github.com/egourgoulhon"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,24 @@
+This is the implementation of topological manifolds over a topological field *K* resulting from the [SageManifolds project](http://sagemanifolds.obspm.fr/). See the meta-ticket #18528 for an overview.
+By *topological manifold over a topological field K* it is meant a second countable Hausdorff space *M* such that every point in *M* has a neighborhood homeomorphic to *K<sup>n</sup>*, with the same non-negative integer *n* for all points. 
+
+This tickets implements the following Python classes:
+
+- `ManifoldSubset`: generic subset of a topological manifold (the open subsets being implemented by the subsclass `TopologicalManifold`)
+  - `TopologicalManifold`: topological manifold over a topological field *K*
+- `ManifoldPoint`: point in a topological manifold
+- `Chart`: chart of a topological manifold
+  - `RealChart`: chart of a topological manifold over the real field
+- `CoordChange`: transition map between two charts of a topological manifold
+
+as well as the singleton classes`TopologicalStructure` and `RealTopologicalStructure`. 
+
+`TopologicalManifold` is intended to serve as a base class for specific manifolds, like smooth manifolds (*K*=**R**) and complex manifolds (*K*=**C**). The follow-up ticket, implementing continuous functions to the base field, is #18640.
+
+**Documentation**:
+The reference manual is produced by
+`sage -docbuild reference/manifolds html`
+It can also be accessed online at http://sagemanifolds.obspm.fr/doc/18529/reference/manifolds/
+More documentation (e.g. example worksheets) can be found [here](http://sagemanifolds.obspm.fr/documentation.html).
 
 
 Author: Eric Gourgoulhon
``````




---

archive/issue_comments_324685.json:
```json
{
    "body": "<a id='comment:7'></a>I also think this discussion was good. I'm just slightly frustrated at myself for not being able to come up with a clear better alternative to get rid of the code smell.\n\nAnyways, now it is back to going over the documentation and technicalities of the code. I hope to finish this review in a couple of days. I'm also thinking that the followup tickets will probably be a lot easier/faster to review too.",
    "created_at": "2016-01-12T04:17:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324685",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>I also think this discussion was good. I'm just slightly frustrated at myself for not being able to come up with a clear better alternative to get rid of the code smell.

Anyways, now it is back to going over the documentation and technicalities of the code. I hope to finish this review in a couple of days. I'm also thinking that the followup tickets will probably be a lot easier/faster to review too.



---

archive/issue_comments_324686.json:
```json
{
    "body": "<a id='comment:118'></a>Replying to [comment:117 tscrim]:\n> I also think this discussion was good. I'm just slightly frustrated at myself for not being able to come up with a clear better alternative to get rid of the code smell.\n> \n\n\nI think there is still the opportunity to implement another hierarchy latter, if we feel that specificities for subsets are required. Also, if we do this latter, when more tickets of #18528 are merged, this would alleviate the propagation of the changes to other tickets and one would notice at once possible side effects.\n\n> Anyways, now it is back to going over the documentation and technicalities of the code. I hope to finish this review in a couple of days. \n\n\nThanks.\n\n> I'm also thinking that the followup tickets will probably be a lot easier/faster to review too.\n\n\nI've propagated the latest changes in this ticket to all tickets of #18528. Everything is OK. In particular, the new singleton classes for manifold structures have allowed to simplify the code, avoiding to redefine the methods `chart` and `scalar_field_algebra` in the class `DifferentiableManifold`.",
    "created_at": "2016-01-12T12:32:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324686",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:118'></a>Replying to [comment:117 tscrim]:
> I also think this discussion was good. I'm just slightly frustrated at myself for not being able to come up with a clear better alternative to get rid of the code smell.
> 


I think there is still the opportunity to implement another hierarchy latter, if we feel that specificities for subsets are required. Also, if we do this latter, when more tickets of #18528 are merged, this would alleviate the propagation of the changes to other tickets and one would notice at once possible side effects.

> Anyways, now it is back to going over the documentation and technicalities of the code. I hope to finish this review in a couple of days. 


Thanks.

> I'm also thinking that the followup tickets will probably be a lot easier/faster to review too.


I've propagated the latest changes in this ticket to all tickets of #18528. Everything is OK. In particular, the new singleton classes for manifold structures have allowed to simplify the code, avoiding to redefine the methods `chart` and `scalar_field_algebra` in the class `DifferentiableManifold`.



---

archive/issue_comments_324687.json:
```json
{
    "body": "Changing commit from \"984c3c26bf827f44eee26fc6afd321e11dca8f2e\" to \"4ed37cece6c44c8c55e79b4dd9990eafe29c20d9\"",
    "created_at": "2016-01-24T01:14:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324687",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "984c3c26bf827f44eee26fc6afd321e11dca8f2e" to "4ed37cece6c44c8c55e79b4dd9990eafe29c20d9"



---

archive/issue_comments_324688.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-24T01:14:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324688",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_052105.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2016-01-24T01:23:06Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "milestone": "sage-7.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18529#event-52105"
}
```



---

archive/issue_comments_324689.json:
```json
{
    "body": "Changing reviewer from \"Travis Scrimshaw\" to \"Travis Scrimshaw, Eric Gourgoulhon\"",
    "created_at": "2016-01-24T01:23:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324689",
    "user": "https://github.com/tscrim"
}
```

Changing reviewer from "Travis Scrimshaw" to "Travis Scrimshaw, Eric Gourgoulhon"



---

archive/issue_comments_324690.json:
```json
{
    "body": "<a id='comment:0'></a>Okay, I've made my last pass through everything. I have two comments left:\n\n- In `Chart.set_inverse`, there is a keyword `check` that I changed to `verbose` because there was no check being done. Irregardless, I don't quite like that the default is to print things to the terminal. Is there a specific reason for this? I feel like the default should be `False`.\n- In `ManifoldPoint`, the methods `set_coord` should be the full `set_coordinates` (and similar methods). The short version can be an alias. (Same discussion as for `disp` vs `display`.).\n\nOnce we take care of these, then this will be a positive review.",
    "created_at": "2016-01-24T01:23:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324690",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>Okay, I've made my last pass through everything. I have two comments left:

- In `Chart.set_inverse`, there is a keyword `check` that I changed to `verbose` because there was no check being done. Irregardless, I don't quite like that the default is to print things to the terminal. Is there a specific reason for this? I feel like the default should be `False`.
- In `ManifoldPoint`, the methods `set_coord` should be the full `set_coordinates` (and similar methods). The short version can be an alias. (Same discussion as for `disp` vs `display`.).

Once we take care of these, then this will be a positive review.



---

archive/issue_comments_324691.json:
```json
{
    "body": "Changing commit from \"4ed37cece6c44c8c55e79b4dd9990eafe29c20d9\" to \"cf5e98b2041d1fdee0756e99a85ada0b865375da\"",
    "created_at": "2016-01-24T01:25:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324691",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "4ed37cece6c44c8c55e79b4dd9990eafe29c20d9" to "cf5e98b2041d1fdee0756e99a85ada0b865375da"



---

archive/issue_comments_324692.json:
```json
{
    "body": "<a id='comment:1'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-24T01:25:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324692",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324693.json:
```json
{
    "body": "Changing commit from \"cf5e98b2041d1fdee0756e99a85ada0b865375da\" to \"00d265cf2855121dba914868264da6ea3a9c42af\"",
    "created_at": "2016-01-24T20:00:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324693",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "cf5e98b2041d1fdee0756e99a85ada0b865375da" to "00d265cf2855121dba914868264da6ea3a9c42af"



---

archive/issue_comments_324694.json:
```json
{
    "body": "<a id='comment:2'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-24T20:00:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324694",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_324695.json:
```json
{
    "body": "<a id='comment:123'></a>Replying to [comment:120 tscrim]:\n> Okay, I've made my last pass through everything.\n\n\nThanks a lot for all your changes.\n\n> I have two comments left:\n> \n> - In `Chart.set_inverse`, there is a keyword `check` that I changed to `verbose` because there was no check being done.\n\n\nYes, `verbose` seems more appropriate.\n\n> Irregardless, I don't quite like that the default is to print things to the terminal. Is there a specific reason for this? \n\n\nNo. \n>I feel like the default should be `False`.\n\n\nI've set it to `False` in the above commit.\n> - In `ManifoldPoint`, the methods `set_coord` should be the full `set_coordinates` (and similar methods). The short version can be an alias. (Same discussion as for `disp` vs `display`.).\n> \n\n\nI've performed the change in the above commit, adding aliases for short versions of `coordinates`, `add_coordinates` and `set_coordinates`. I've also corrected one or two typos.",
    "created_at": "2016-01-24T20:10:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324695",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:123'></a>Replying to [comment:120 tscrim]:
> Okay, I've made my last pass through everything.


Thanks a lot for all your changes.

> I have two comments left:
> 
> - In `Chart.set_inverse`, there is a keyword `check` that I changed to `verbose` because there was no check being done.


Yes, `verbose` seems more appropriate.

> Irregardless, I don't quite like that the default is to print things to the terminal. Is there a specific reason for this? 


No. 
>I feel like the default should be `False`.


I've set it to `False` in the above commit.
> - In `ManifoldPoint`, the methods `set_coord` should be the full `set_coordinates` (and similar methods). The short version can be an alias. (Same discussion as for `disp` vs `display`.).
> 


I've performed the change in the above commit, adding aliases for short versions of `coordinates`, `add_coordinates` and `set_coordinates`. I've also corrected one or two typos.



---

archive/issue_comments_324696.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-01-24T20:15:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324696",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_324697.json:
```json
{
    "body": "<a id='comment:4'></a>LGTM. Here is the start of the main body of SageManifolds into Sage. Thank you for all your hard work.",
    "created_at": "2016-01-24T20:15:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324697",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>LGTM. Here is the start of the main body of SageManifolds into Sage. Thank you for all your hard work.



---

archive/issue_comments_324698.json:
```json
{
    "body": "<a id='comment:5'></a>Thanks a lot for the detailed review work, the numerous improvements and the enlightening discussions!",
    "created_at": "2016-01-24T20:56:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324698",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:5'></a>Thanks a lot for the detailed review work, the numerous improvements and the enlightening discussions!



---

archive/issue_comments_324699.json:
```json
{
    "body": "Changing branch from \"public/manifolds/top_manif_basics\" to \"00d265cf2855121dba914868264da6ea3a9c42af\"",
    "created_at": "2016-01-28T17:14:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324699",
    "user": "https://github.com/vbraun"
}
```

Changing branch from "public/manifolds/top_manif_basics" to "00d265cf2855121dba914868264da6ea3a9c42af"



---

archive/issue_comments_324700.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-01-28T17:14:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18529#issuecomment-324700",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_052106.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-01-28T17:14:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/18529",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/18529#event-52106"
}
```
