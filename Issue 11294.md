# Issue 11294: Adding turning_number() function to word paths

archive/issues_011294.json:
```json
{
    "body": "Assignee: sage-combinat\n\nCC:  slabbe tmonteil\n\nKeywords: discrete path, turning number\n\nA very useful function about discrete paths is the one returning its turning number, i.e. the number of \"left\" turns minus the number of \"right\" turns on the square grid.\n\nThe purpose of this ticket is to add this functionality.\n\nIssue created by migration from https://trac.sagemath.org/ticket/11466\n\n",
    "created_at": "2011-06-12T17:26:25Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "title": "Adding turning_number() function to word paths",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11294",
    "user": "abmasse"
}
```
Assignee: sage-combinat

CC:  slabbe tmonteil

Keywords: discrete path, turning number

A very useful function about discrete paths is the one returning its turning number, i.e. the number of "left" turns minus the number of "right" turns on the square grid.

The purpose of this ticket is to add this functionality.

Issue created by migration from https://trac.sagemath.org/ticket/11466





---

archive/issue_comments_124546.json:
```json
{
    "body": "Apply over sage-4.7",
    "created_at": "2011-06-13T01:54:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11294",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11294#issuecomment-124546",
    "user": "abmasse"
}
```

Apply over sage-4.7



---

archive/issue_comments_124547.json:
```json
{
    "body": "Attachment [trac_11466-turning_number-abm.patch](tarball://root/attachments/some-uuid/ticket11466/trac_11466-turning_number-abm.patch) by abmasse created at 2011-06-13 01:55:43\n\nI just uploaded a patch providing the function turning_number() for square grid paths. This is clearly generalizable to other word paths alphabets, but I don't feel like writing it right now, since I don't need it.\n\nNeeds review!",
    "created_at": "2011-06-13T01:55:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11294",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11294#issuecomment-124547",
    "user": "abmasse"
}
```

Attachment [trac_11466-turning_number-abm.patch](tarball://root/attachments/some-uuid/ticket11466/trac_11466-turning_number-abm.patch) by abmasse created at 2011-06-13 01:55:43

I just uploaded a patch providing the function turning_number() for square grid paths. This is clearly generalizable to other word paths alphabets, but I don't feel like writing it right now, since I don't need it.

Needs review!



---

archive/issue_comments_124548.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2011-06-13T01:55:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11294",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11294#issuecomment-124548",
    "user": "abmasse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_124549.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-06-13T14:11:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11294",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11294#issuecomment-124549",
    "user": "tmonteil"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_124550.json:
```json
{
    "body": "Hi Alexandre,\n\nfirst, you should define more precisely what is the turning number of a discrete curve, since it is not a direct generalisation of the [turning number](http://en.wikipedia.org/wiki/Winding_number#Turning_number) defined for smooth curves to discrete ones. When the discrete curve turns by pi/2 or -pi/2, then there is a canonical way to smooth it, and in this case your construction yields the good number 1/4 or -1/4. But when the discrete curve turns back (what you call an opposite step), there are two different ways to smooth it to get a turning number of 1/2 or -1/2. What you are doing with the `remove_opposite_steps()` method is to choose one of them, in a way that is not local. Think to `luuuddl` and `luuuddr`: in the first case, your algorithm considers that the curve turned by +pi at the top extremity, whereas in the second case, it considers that the curve turned by -pi. Hence, you should explain more, or give a reference.\n\nSecond, your method `remove_opposite_steps()` is far from optimal since it builds a lot of lists/words during the process (a part of `w` is copied many times). You should only modify the extremities of the lists/words `left` and `right`, with a constant cost at each loop.\n\nFor example, i quickly tried this (the variables `i` and `length` may be renamed, and there may be a way to avoid transforming the word into a list to use the `pop()` method):\n\n\n```\n    def rr(self):\n        a,b,A,B = self.parent().alphabet()\n        opposite_steps = [[a,A], [A,a], [b,B], [B,b]]\n        i = 0\n        left = []\n        right = list(self.reversal())\n        length = len(right)\n        while length != 0:\n            if i !=0 and [left[-1],right[-1]] in opposite_steps:\n                left.pop()\n                right.pop()\n                i -= 1\n                length -= 1\n            else:\n                left.append(right.pop())\n                i += 1\n                length -= 1\n        return self.parent()(left)\n```\n\n\nThe results are:\n\n\n```\nsage: Freeman = WordPaths(Integers(4))\nsage: timeit('Freeman(words.RandomWord(10000,4)).remove_opposite_steps()')\n5 loops, best of 3: 2.54 s per loop\nsage: timeit('Freeman(words.RandomWord(10000,4)).rr()')                   \n5 loops, best of 3: 139 ms per loop\n```\n",
    "created_at": "2011-06-13T14:11:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11294",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11294#issuecomment-124550",
    "user": "tmonteil"
}
```

Hi Alexandre,

first, you should define more precisely what is the turning number of a discrete curve, since it is not a direct generalisation of the [turning number](http://en.wikipedia.org/wiki/Winding_number#Turning_number) defined for smooth curves to discrete ones. When the discrete curve turns by pi/2 or -pi/2, then there is a canonical way to smooth it, and in this case your construction yields the good number 1/4 or -1/4. But when the discrete curve turns back (what you call an opposite step), there are two different ways to smooth it to get a turning number of 1/2 or -1/2. What you are doing with the `remove_opposite_steps()` method is to choose one of them, in a way that is not local. Think to `luuuddl` and `luuuddr`: in the first case, your algorithm considers that the curve turned by +pi at the top extremity, whereas in the second case, it considers that the curve turned by -pi. Hence, you should explain more, or give a reference.

Second, your method `remove_opposite_steps()` is far from optimal since it builds a lot of lists/words during the process (a part of `w` is copied many times). You should only modify the extremities of the lists/words `left` and `right`, with a constant cost at each loop.

For example, i quickly tried this (the variables `i` and `length` may be renamed, and there may be a way to avoid transforming the word into a list to use the `pop()` method):


```
    def rr(self):
        a,b,A,B = self.parent().alphabet()
        opposite_steps = [[a,A], [A,a], [b,B], [B,b]]
        i = 0
        left = []
        right = list(self.reversal())
        length = len(right)
        while length != 0:
            if i !=0 and [left[-1],right[-1]] in opposite_steps:
                left.pop()
                right.pop()
                i -= 1
                length -= 1
            else:
                left.append(right.pop())
                i += 1
                length -= 1
        return self.parent()(left)
```


The results are:


```
sage: Freeman = WordPaths(Integers(4))
sage: timeit('Freeman(words.RandomWord(10000,4)).remove_opposite_steps()')
5 loops, best of 3: 2.54 s per loop
sage: timeit('Freeman(words.RandomWord(10000,4)).rr()')                   
5 loops, best of 3: 139 ms per loop
```

