# Issue 20257: Poset is_chain_of_poset(): error checking and saturated-keyword

Issue created by migration from https://trac.sagemath.org/ticket/20494

Original creator: jmantysalo

Original creation time: 2016-04-24 04:48:41

This should be shown as an error


```
P = Posets.PentagonPoset()
P.is_chain_of_poset([1, 2, 4, 'junk'], ordered=True)
```


Also keyword `saturated` was asked to be added some time ago.



---

Comment by jmantysalo created at 2016-04-24 05:22:26

Frédéric, I think it was you who asked for `saturated`-option.
----
New commits:


---

Comment by jmantysalo created at 2016-04-24 05:22:26

Changing status from new to needs_review.


---

Comment by jmantysalo created at 2016-05-11 19:33:58

Just pinging...


---

Comment by jmantysalo created at 2016-05-19 07:14:51

`ping`.


---

Comment by tscrim created at 2016-05-19 14:07:04

Two things:


```diff
-        - ``saturated`` -- a Boolean. If ``True``, then return ``True``
-          only if `elms` is a saturated chain. A chain `C` is saturated
-          when `a < b < c` and `a, c \in C` implies `b \in C`.
+        - ``saturated`` -- boolean; if ``True``, then return ``True``
+          only if `elms` is a saturated chain
```

and put

```
A chain `C` is saturated when `a < b < c` and `a, c \in C` implies `b \in C`.
```

in with the body of the docstring.

The other thing is I would also have the code be this like this:

```python
# _element_to_vertex can be assumed to be a linear extension
# of the poset according to the documentation of class
# HasseDiagram.
H = self._hasse_diagram

if ordered:
    elms = [self._element_to_vertex(e) for e in elms]
else:
    elms = sorted(set([self._element_to_vertex(e) for e in elms]))

if saturated:
    return all(H.covers(a, b) for a, b in zip(elms, elms[1:]))
else:
    return all(H.is_lequal(a, b) for a, b in zip(elms, elms[1:]))
```



---

Comment by jmantysalo created at 2016-05-19 15:45:04

The code you suggests would mean that `[1, 1, 2]` is _not_ a saturated chain of `ChainPoset(42)`. Is this how you want it to be?


---

Comment by kdilks created at 2016-05-19 19:26:47

It's my understanding that if repeated elements are allowed, then it's a multichain, and if repeated elements aren't allowed then it's just a chain. I don't know if Sage fully distinguishes between the two, so it might be worth having a separate ticket just dedicated to making that distinction clear in function names/documentation.


---

Comment by jmantysalo created at 2016-05-20 05:40:09

Replying to [comment:7 kdilks]:
> It's my understanding that if repeated elements are allowed, then it's a multichain, and if repeated elements aren't allowed then it's just a chain. I don't know if Sage fully distinguishes between the two, so it might be worth having a separate ticket just dedicated to making that distinction clear in function names/documentation.

True. But currently


```
P = Posets.PentagonPoset()
P.is_chain_of_poset([2, 2, 3])
```


returns `True`. With suggested code it would still return `True`, but `P.is_chain_of_poset([2,2,3], saturated=True)` would return `False`.

How about third parameter `allow_multichain` with default value `True` to maintain current behaviour?


---

Comment by jmantysalo created at 2016-05-20 08:23:37

Replying to [comment:8 jmantysalo]:

> How about third parameter `allow_multichain` with default value `True` to maintain current behaviour?

Forget. Already ``ordered`` makes difference between multichain and chain.

Arghs. What to do? It sounds natural to have three different boolean options, as all `2^3` combinations are usable.


---

Comment by jmantysalo created at 2016-05-31 05:40:24

Changing status from needs_review to needs_info.


---

Comment by jmantysalo created at 2016-05-31 05:40:24

Frédéric? How should this function work?


---

Comment by kdilks created at 2016-06-13 01:31:35

I'm thinking we just find a way to make the code handle all three boolean options. Though I would call the third option `strict=True`, with `strict=False` corresponding to multichains.

Another thing to consider would be to add functions that take an unordered chain and return the ordered list, take a multichain and return the underlying strict chain, etc.


---

Comment by jmantysalo created at 2016-07-04 11:26:17

Replying to [comment:11 kdilks]:
> I'm thinking we just find a way to make the code handle all three boolean options. Though I would call the third option `strict=True`, with `strict=False` corresponding to multichains.

But how to resolve the problem with current `ordered`-option that makes two different things? We do not want to make an option that will change default value depending on other parameter? Or do we - have `strict=None` as a default. Sounds odd to me...

> Another thing to consider would be to add functions that take an unordered chain and return the ordered list, take a multichain and return the underlying strict chain, etc.

I did #20934 for that.
