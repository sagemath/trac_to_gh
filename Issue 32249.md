# Issue 32249: KeyError followed by AttributeError while calling .closest_vector()

Issue created by migration from https://trac.sagemath.org/ticket/32486

Original creator: @maxale

Original creation time: 2021-09-07 20:47:17

CC:  malb slabbe

The following code in Sage 9.4 gives me *KeyError: ((None,), ())* followed by *AttributeError: 'sage.symbolic.expression.Expression' object has no attribute 'ceil*':


```
from sage.modules.free_module_integer import IntegerLattice                                                                                                                                                                                                               
L = IntegerLattice([[-1,  0,  1],[1,0,2]])                                                                                                                                                                                                                                
L.closest_vector((1,1,1))
```


It was suggested at https://ask.sagemath.org/question/58842/ that the latter error comes from `sqrt(5).ceil()` not working.

I see the same error on many other `.closest_vector()` call - so essentially its functionality is broken at the moment.


---

Comment by nbruin created at 2021-09-25 18:18:53

Yes, it looks like in:

https://github.com/sagemath/sage/blob/c349c87d0dea805c92d589a259c4ed1a20407ca5/src/sage/modules/diamond_cutting.py#L261

there should be a numerical norm computation rather than the symbolic one that occurs now. This code is in a branch of the code that deals with non-maximal-rank lattices. It's clear this code has not been well-tested for this scenario, so I'd recommend against using it in this case at this point without reviewing the code a little more comprehensively. Errors like this may be indicative of carelessly written code that you wouldn't want to trust the results of, but it could also just be a one-off edge case that was missed.


---

Comment by cremona created at 2021-09-25 20:57:33

My guess is that the code contains something like sqrt(n) which meed to be trwated as a real not a symbolic sqrt.


---

Comment by nbruin created at 2021-09-25 22:41:21

Replying to [comment:3 cremona]:
> My guess is that the code contains something like sqrt(n) which meed to be trwated as a real not a symbolic sqrt.
Indeed, that is exactly what happens in the line referenced above. However, when figuring out what the largest norm is that occurs, one should probably not take square roots at all! Perhaps at a later point, the actual L_2-norm is required rather than its square, but then one should compute it there, and not for the whole list. That's another signal that makes me a little reserved about the apparent code quality here.


---

Comment by dimpase created at 2021-10-02 09:00:50

cc-ind the author - hopefully we at least might know the reference for this method.


---

Comment by dimpase created at 2021-10-02 09:34:12

please review - I replaced L_2 by L_1 norms, added the test from the ticket description
----
New commits:


---

Comment by dimpase created at 2021-10-02 09:34:12

Changing status from new to needs_review.


---

Comment by malb created at 2021-10-02 14:14:16

I don't think that's the right fix, \ell_2 norm is generally understood and LLL (which is called after) works in the \ell_2 norm. Shouldn't `RR(abs(v))` do the trick?


---

Comment by dimpase created at 2021-10-02 17:17:00

there is no need for a square root taking (what happens in `abs()`), it goes via SR, and thus is a bad idea - in particular if you just need an upper bound!


---

Comment by dimpase created at 2021-10-02 17:40:05

We're taking slightly longer vectors in this patch, but this can only be harmful for the performance, as far as I understand.

Besides, I'm sure there are good algorithms to find a ceil(abs(v)), without first computing a floating point approximation of abs(v), no?


---

Comment by dimpase created at 2021-10-02 19:11:42

if one has to go with \ell_2 norm then one needs to call a function for the squared \ell_2 norm n2 of v, 
and then take (r,rem)-n2.sqrtrem() (which basically wraps one call to GMP) of the result;

then ceil(abs(v)) is r if rem==0, and r+1 otherwise.


---

Comment by git created at 2021-10-02 19:43:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-10-02 19:47:48

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by dimpase created at 2021-10-02 19:50:07

OK, so this is the original algorithm, using inner_product and carefully rounded sqrt from GMP.
Please review.


---

Comment by malb created at 2021-10-03 13:32:10

Looks good to me, thanks Dima!


---

Comment by malb created at 2021-10-03 13:32:10

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-10-10 10:17:29

Resolution: fixed


---

Comment by @maxale created at 2022-08-31 21:21:27

I'd like to bring everyone's attention to yet another bug #34091 in `.closest_vector()` that also renders it unusable.
