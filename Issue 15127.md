# Issue 15127: Introduce factor_or_zero into global namespace

archive/issues_015127.json:
```json
{
    "body": "CC:  @vbraun @tscrim @mguaypaq\n\nThe current top level factor command raises an error if factor is applied to 0.  This is inconvenient for trying to factor polynomial expressions which reduce to 0 or lists of integers.\n\nA function which does not force the user to handle 0 as a corner case is SUPER useful for users who just want to observe patterns in factorizations of lists or expressions that might reduce to 0.  The error message of factor should indicate to the user to call `factor_or_zero` an error message such as `ArithmeticError:  Prime factorization of 0 not defined.  Use factor_or_zero to return 0 as the factorization of 0.`\n\nIssue created by migration from https://trac.sagemath.org/ticket/15364\n\n",
    "created_at": "2013-11-06T19:34:58Z",
    "labels": [
        "factorization",
        "major"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Introduce factor_or_zero into global namespace",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15127",
    "user": "@zabrocki"
}
```
CC:  @vbraun @tscrim @mguaypaq

The current top level factor command raises an error if factor is applied to 0.  This is inconvenient for trying to factor polynomial expressions which reduce to 0 or lists of integers.

A function which does not force the user to handle 0 as a corner case is SUPER useful for users who just want to observe patterns in factorizations of lists or expressions that might reduce to 0.  The error message of factor should indicate to the user to call `factor_or_zero` an error message such as `ArithmeticError:  Prime factorization of 0 not defined.  Use factor_or_zero to return 0 as the factorization of 0.`

Issue created by migration from https://trac.sagemath.org/ticket/15364





---

archive/issue_comments_193926.json:
```json
{
    "body": "I guess your usage scenario is\n\n```\n[factor_or_zero(a) for a in some_list_of_expressions]\n```\n\nCan't you do:\n\n```\n[(factor(a) if a !=0 else None) for a in some_list_of_expressions]\n```\n\nit's not that much longer (you can save some parentheses if you want) and that way sage doesn't have to choose an arbitrary sentinel value. Plus, the pattern can be used in other similar situations as well.\n\nAt some point it's more beneficial to teach users how to use the building blocks available than to provide them with increasingly special-purpose bricks.",
    "created_at": "2013-11-06T20:40:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193926",
    "user": "@nbruin"
}
```

I guess your usage scenario is

```
[factor_or_zero(a) for a in some_list_of_expressions]
```

Can't you do:

```
[(factor(a) if a !=0 else None) for a in some_list_of_expressions]
```

it's not that much longer (you can save some parentheses if you want) and that way sage doesn't have to choose an arbitrary sentinel value. Plus, the pattern can be used in other similar situations as well.

At some point it's more beneficial to teach users how to use the building blocks available than to provide them with increasingly special-purpose bricks.



---

archive/issue_comments_193927.json:
```json
{
    "body": "I think that is one of many scenarios.  The purpose of `factor` is biased towards number theory.  Most of my colleagues use it in algebra to put coefficients in a readable form.  I just want to give people who use algebra a less onerous alternative.  I don't want to have to put an if statement *every* time that I factor an algebraic expression.\n\nSolution during Sage Days on Monday (which completely stopped everything for much longer than was necessary):\n\n```\nsage: map(factor, list_of_coefficients)\nArithmeticError\nsage: list_coefficients.remove(0)\nsage: map(factor, list_of_coefficients)\n```\n\n\nA more common scenario is\n\n```\nsage: factor(1/(1-x)-x/(1-x)-1)\nValueError: factorization of 0 not defined\n```\n\nOr that a similar expression should come up as the coefficient of some element in an algebra and one should want to\n`elt.map_coefficients(factor)`.",
    "created_at": "2013-11-06T23:00:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193927",
    "user": "@zabrocki"
}
```

I think that is one of many scenarios.  The purpose of `factor` is biased towards number theory.  Most of my colleagues use it in algebra to put coefficients in a readable form.  I just want to give people who use algebra a less onerous alternative.  I don't want to have to put an if statement *every* time that I factor an algebraic expression.

Solution during Sage Days on Monday (which completely stopped everything for much longer than was necessary):

```
sage: map(factor, list_of_coefficients)
ArithmeticError
sage: list_coefficients.remove(0)
sage: map(factor, list_of_coefficients)
```


A more common scenario is

```
sage: factor(1/(1-x)-x/(1-x)-1)
ValueError: factorization of 0 not defined
```

Or that a similar expression should come up as the coefficient of some element in an algebra and one should want to
`elt.map_coefficients(factor)`.



---

archive/issue_comments_193928.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2013-11-06T23:01:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193928",
    "user": "@zabrocki"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_193929.json:
```json
{
    "body": "New commits:",
    "created_at": "2013-11-07T22:33:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193929",
    "user": "@zabrocki"
}
```

New commits:



---

archive/issue_comments_193930.json:
```json
{
    "body": "Changing priority from major to minor.",
    "created_at": "2013-11-07T22:33:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193930",
    "user": "@zabrocki"
}
```

Changing priority from major to minor.



---

archive/issue_comments_193931.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-11-07T23:56:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193931",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193932.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-11-08T00:04:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193932",
    "user": "@zabrocki"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_193933.json:
```json
{
    "body": "Please be aware that `Factorization` objects (which is what `factor` normally returns) have some methods which should probably be imitated by the `0` object, or else the can is merely being kicked down the road. For instance, the `value` method of a factorization multiplies it back together, and it is way more useful than it looks from that description:\n\n\n```\nsage: Q = FractionField(P)\nsage: Q(14*x) / Q(28*(x+1))\n14*x/(28*x + 28)\nsage: factor(_).value()\n1/2*x/(x + 1)\n```\n\n\n0, of course, doesn't have that attribute:\n\n```\nsage: 0.value()\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-4-65708360c0e8> in <module>()\n----> 1 Integer(0).value()\n\n/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/structure/element.so in sage.structure.element.Element.__getattr__ (sage/structure/element.c:3873)()\n\n/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1696)()\n\nAttributeError: 'sage.rings.integer.Integer' object has no attribute 'value'\n```\n",
    "created_at": "2013-11-08T08:15:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193933",
    "user": "@darijgr"
}
```

Please be aware that `Factorization` objects (which is what `factor` normally returns) have some methods which should probably be imitated by the `0` object, or else the can is merely being kicked down the road. For instance, the `value` method of a factorization multiplies it back together, and it is way more useful than it looks from that description:


```
sage: Q = FractionField(P)
sage: Q(14*x) / Q(28*(x+1))
14*x/(28*x + 28)
sage: factor(_).value()
1/2*x/(x + 1)
```


0, of course, doesn't have that attribute:

```
sage: 0.value()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-4-65708360c0e8> in <module>()
----> 1 Integer(0).value()

/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/structure/element.so in sage.structure.element.Element.__getattr__ (sage/structure/element.c:3873)()

/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1696)()

AttributeError: 'sage.rings.integer.Integer' object has no attribute 'value'
```




---

archive/issue_comments_193934.json:
```json
{
    "body": "You are right.  For consistency it should return a factorization object rather than an actual 0.\n----\nNew commits:",
    "created_at": "2013-11-08T15:44:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193934",
    "user": "@zabrocki"
}
```

You are right.  For consistency it should return a factorization object rather than an actual 0.
----
New commits:



---

archive/issue_comments_193935.json:
```json
{
    "body": "Replying to [comment:9 zabrocki]:\n> You are right.  For consistency it should return a factorization object rather than an actual 0.\nAnd now compare:\n\n```\nsage: var('x')\nx\nsage: factor(x^2-1) #this is just a symbolic_expression\n(x - 1)*(x + 1)\nsage: PQ.<X>=QQ[]\nsage: factor(X^2-1)\n(X - 1) * (X + 1)\nsage: factor(X^2-1).universe()\nUnivariate Polynomial Ring in X over Rational Field\nsage: PZ.<Y>=ZZ[]\nsage: factor(Y^2-1)\n(Y - 1) * (Y + 1)\nsage: factor(Y^2-1).universe()\nUnivariate Polynomial Ring in Y over Integer Ring\n```\n\nyou should probably be consistent with that too.\n\nFrom the application you describe, I guess you're mostly interested in application to SR (the first case) in which case the most appropriate thing to do is probably to add a method `simplify_factor` to SymbolicExpression, which could happily simplify the expression \"0\" to the product \"0\". In the other cases, the code is just a lot clearer if people specify their own little one-off function that does with 0 what they want.",
    "created_at": "2013-11-08T16:43:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193935",
    "user": "@nbruin"
}
```

Replying to [comment:9 zabrocki]:
> You are right.  For consistency it should return a factorization object rather than an actual 0.
And now compare:

```
sage: var('x')
x
sage: factor(x^2-1) #this is just a symbolic_expression
(x - 1)*(x + 1)
sage: PQ.<X>=QQ[]
sage: factor(X^2-1)
(X - 1) * (X + 1)
sage: factor(X^2-1).universe()
Univariate Polynomial Ring in X over Rational Field
sage: PZ.<Y>=ZZ[]
sage: factor(Y^2-1)
(Y - 1) * (Y + 1)
sage: factor(Y^2-1).universe()
Univariate Polynomial Ring in Y over Integer Ring
```

you should probably be consistent with that too.

From the application you describe, I guess you're mostly interested in application to SR (the first case) in which case the most appropriate thing to do is probably to add a method `simplify_factor` to SymbolicExpression, which could happily simplify the expression "0" to the product "0". In the other cases, the code is just a lot clearer if people specify their own little one-off function that does with 0 what they want.



---

archive/issue_comments_193936.json:
```json
{
    "body": "For Factorization objects: I think you really don't want those to get out into the wild when constructed with 0:\n\n```\nsage: a=Factorization([(0,1)])\nsage: b=Factorization([(2,1)])\nsage: a.gcd(b)\n1\nsage: a^(-1)\n0^-1\n```\n\nThat's just wrong. I think that's even worse than getting an attribute error on `.value()`.",
    "created_at": "2013-11-08T18:48:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193936",
    "user": "@nbruin"
}
```

For Factorization objects: I think you really don't want those to get out into the wild when constructed with 0:

```
sage: a=Factorization([(0,1)])
sage: b=Factorization([(2,1)])
sage: a.gcd(b)
1
sage: a^(-1)
0^-1
```

That's just wrong. I think that's even worse than getting an attribute error on `.value()`.



---

archive/issue_comments_193937.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-11-08T19:14:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193937",
    "user": "@zabrocki"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_193938.json:
```json
{
    "body": "> From the application you describe, I guess you're mostly interested in application to SR (the first case) in which case the most appropriate thing to do is probably to add a method `simplify_factor` to SymbolicExpression, which could happily simplify the expression \"0\" to the product \"0\". In the other cases, the code is just a lot clearer if people specify their own little one-off function that does with 0 what they want.\n\nI (and my colleagues that are likely to use this code) will probably be working with algebras over polynomial rings/fraction fields or integer coefficients.  SR is rather slow so I don't use it much.  This is a convenience function.  I can go through my list worksheets and could say that in about 1/3 of them I've had to work around factor throwing errors at me.\n\n> For Factorization objects: I think you really don't want those to get out into the wild when constructed with 0:\n> {{{\n> sage: a=Factorization([(0,1)])\n> sage: b=Factorization([(2,1)])\n> sage: a.gcd(b)\n> 1\n> sage: a^(-1)\n> 0^-1\n> }}}\n> That's just wrong. I think that's even worse than getting an attribute error on `.value()`.\nYou are right.  We might need to clean up the factorization code so that it handles the 0 object properly.",
    "created_at": "2013-11-08T19:14:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193938",
    "user": "@zabrocki"
}
```

> From the application you describe, I guess you're mostly interested in application to SR (the first case) in which case the most appropriate thing to do is probably to add a method `simplify_factor` to SymbolicExpression, which could happily simplify the expression "0" to the product "0". In the other cases, the code is just a lot clearer if people specify their own little one-off function that does with 0 what they want.

I (and my colleagues that are likely to use this code) will probably be working with algebras over polynomial rings/fraction fields or integer coefficients.  SR is rather slow so I don't use it much.  This is a convenience function.  I can go through my list worksheets and could say that in about 1/3 of them I've had to work around factor throwing errors at me.

> For Factorization objects: I think you really don't want those to get out into the wild when constructed with 0:
> {{{
> sage: a=Factorization([(0,1)])
> sage: b=Factorization([(2,1)])
> sage: a.gcd(b)
> 1
> sage: a^(-1)
> 0^-1
> }}}
> That's just wrong. I think that's even worse than getting an attribute error on `.value()`.
You are right.  We might need to clean up the factorization code so that it handles the 0 object properly.



---

archive/issue_comments_193939.json:
```json
{
    "body": "I noticed another problem with `factor` and the factorization objects that it returns.   I took a symmetric function expression and used `.map_coefficients(factor)` and my coefficients which were 1 and -1 disappeared (I was applying it to an expression with polynomial coefficients, but you get the idea from the following expression).\n\n\n```\nsage: s = SymmetricFunctions(QQ).s()\nsage: (s[3,2]+2*s[2,2,1]).map_coefficients(factor)\n2*s[2, 2, 1]\n```\n\n\nThis happens because `map_coefficients` is calling `s.sum_of_terms` which calls `s.term` which calls `s._from_dict` and we have the strange behavior that `s._from_dict({Partition([3,2]) : factor(1)})` is 0.\n\nIf you trace it further, you see that `_from_dict` removes the zeros and computes \n\n`dict( (key, coeff) for key, coeff in d.iteritems() if coeff)`\n\nNow `bool(factor(2))` is `True` while `bool(factor(1))` and `bool(factor(-1))` is `False`.  I don't know if there is a good reason that `factor(1)` and `factor(-1)` should be `False` or if this bug should be fixed in `combinat/free_module.py` in the code for `_from_dict`.",
    "created_at": "2014-03-12T20:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193939",
    "user": "@zabrocki"
}
```

I noticed another problem with `factor` and the factorization objects that it returns.   I took a symmetric function expression and used `.map_coefficients(factor)` and my coefficients which were 1 and -1 disappeared (I was applying it to an expression with polynomial coefficients, but you get the idea from the following expression).


```
sage: s = SymmetricFunctions(QQ).s()
sage: (s[3,2]+2*s[2,2,1]).map_coefficients(factor)
2*s[2, 2, 1]
```


This happens because `map_coefficients` is calling `s.sum_of_terms` which calls `s.term` which calls `s._from_dict` and we have the strange behavior that `s._from_dict({Partition([3,2]) : factor(1)})` is 0.

If you trace it further, you see that `_from_dict` removes the zeros and computes 

`dict( (key, coeff) for key, coeff in d.iteritems() if coeff)`

Now `bool(factor(2))` is `True` while `bool(factor(1))` and `bool(factor(-1))` is `False`.  I don't know if there is a good reason that `factor(1)` and `factor(-1)` should be `False` or if this bug should be fixed in `combinat/free_module.py` in the code for `_from_dict`.



---

archive/issue_comments_193940.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-01-26T12:56:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193940",
    "user": "@zabrocki"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_193941.json:
```json
{
    "body": "I was the one pushing for a means of gussying up algebraic expressions through a `factor_or_zero` command and this ticket hasn't been modified in 6 years.  I propose that it be closed.  While I do think that this is a problem that sometimes I am able to find no combination of `expand`, `simplify` and `factor` can clean up a coefficients of an element in an algebra, after the discussions here I don't think that doing that through playing with `factor` is the right way to go.",
    "created_at": "2020-01-26T12:56:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193941",
    "user": "@zabrocki"
}
```

I was the one pushing for a means of gussying up algebraic expressions through a `factor_or_zero` command and this ticket hasn't been modified in 6 years.  I propose that it be closed.  While I do think that this is a problem that sometimes I am able to find no combination of `expand`, `simplify` and `factor` can clean up a coefficients of an element in an algebra, after the discussions here I don't think that doing that through playing with `factor` is the right way to go.



---

archive/issue_comments_193942.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-02-06T01:01:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193942",
    "user": "@kwankyu"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_193943.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2020-02-06T12:05:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15127",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15127#issuecomment-193943",
    "user": "@fchapoton"
}
```

Resolution: wontfix
