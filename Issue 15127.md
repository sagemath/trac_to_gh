# Issue 15127: Introduce factor_or_zero into global namespace

Issue created by migration from Trac.

Original creator: zabrocki

Original creation time: 2013-11-06 19:34:58

CC:  vbraun tscrim mguaypaq

The current top level factor command raises an error if factor is applied to 0.  This is inconvenient for trying to factor polynomial expressions which reduce to 0 or lists of integers.

A function which does not force the user to handle 0 as a corner case is SUPER useful for users who just want to observe patterns in factorizations of lists or expressions that might reduce to 0.  The error message of factor should indicate to the user to call `factor_or_zero` an error message such as `ArithmeticError:  Prime factorization of 0 not defined.  Use factor_or_zero to return 0 as the factorization of 0.`


---

Comment by nbruin created at 2013-11-06 20:40:22

I guess your usage scenario is

```
[factor_or_zero(a) for a in some_list_of_expressions]
```

Can't you do:

```
[(factor(a) if a !=0 else None) for a in some_list_of_expressions]
```

it's not that much longer (you can save some parentheses if you want) and that way sage doesn't have to choose an arbitrary sentinel value. Plus, the pattern can be used in other similar situations as well.

At some point it's more beneficial to teach users how to use the building blocks available than to provide them with increasingly special-purpose bricks.


---

Comment by zabrocki created at 2013-11-06 23:00:14

I think that is one of many scenarios.  The purpose of `factor` is biased towards number theory.  Most of my colleagues use it in algebra to put coefficients in a readable form.  I just want to give people who use algebra a less onerous alternative.  I don't want to have to put an if statement _every_ time that I factor an algebraic expression.

Solution during Sage Days on Monday (which completely stopped everything for much longer than was necessary):

```
sage: map(factor, list_of_coefficients)
ArithmeticError
sage: list_coefficients.remove(0)
sage: map(factor, list_of_coefficients)
```


A more common scenario is

```
sage: factor(1/(1-x)-x/(1-x)-1)
ValueError: factorization of 0 not defined
```

Or that a similar expression should come up as the coefficient of some element in an algebra and one should want to
`elt.map_coefficients(factor)`.


---

Comment by zabrocki created at 2013-11-06 23:01:52

Changing type from PLEASE CHANGE to enhancement.


---

Comment by zabrocki created at 2013-11-07 22:33:36

New commits:


---

Comment by zabrocki created at 2013-11-07 22:33:36

Changing priority from major to minor.


---

Comment by git created at 2013-11-07 23:56:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2013-11-08 00:04:27

Changing status from new to needs_review.


---

Comment by darij created at 2013-11-08 08:15:23

Please be aware that `Factorization` objects (which is what `factor` normally returns) have some methods which should probably be imitated by the `0` object, or else the can is merely being kicked down the road. For instance, the `value` method of a factorization multiplies it back together, and it is way more useful than it looks from that description:


```
sage: Q = FractionField(P)
sage: Q(14*x) / Q(28*(x+1))
14*x/(28*x + 28)
sage: factor(_).value()
1/2*x/(x + 1)
```


0, of course, doesn't have that attribute:

```
sage: 0.value()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-4-65708360c0e8> in <module>()
----> 1 Integer(0).value()

/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/structure/element.so in sage.structure.element.Element.__getattr__ (sage/structure/element.c:3873)()

/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1696)()

AttributeError: 'sage.rings.integer.Integer' object has no attribute 'value'
```



---

Comment by zabrocki created at 2013-11-08 15:44:17

You are right.  For consistency it should return a factorization object rather than an actual 0.
----
New commits:


---

Comment by nbruin created at 2013-11-08 16:43:29

Replying to [comment:9 zabrocki]:
> You are right.  For consistency it should return a factorization object rather than an actual 0.
And now compare:

```
sage: var('x')
x
sage: factor(x^2-1) #this is just a symbolic_expression
(x - 1)*(x + 1)
sage: PQ.<X>=QQ[]
sage: factor(X^2-1)
(X - 1) * (X + 1)
sage: factor(X^2-1).universe()
Univariate Polynomial Ring in X over Rational Field
sage: PZ.<Y>=ZZ[]
sage: factor(Y^2-1)
(Y - 1) * (Y + 1)
sage: factor(Y^2-1).universe()
Univariate Polynomial Ring in Y over Integer Ring
```

you should probably be consistent with that too.

From the application you describe, I guess you're mostly interested in application to SR (the first case) in which case the most appropriate thing to do is probably to add a method `simplify_factor` to SymbolicExpression, which could happily simplify the expression "0" to the product "0". In the other cases, the code is just a lot clearer if people specify their own little one-off function that does with 0 what they want.


---

Comment by nbruin created at 2013-11-08 18:48:45

For Factorization objects: I think you really don't want those to get out into the wild when constructed with 0:

```
sage: a=Factorization([(0,1)])
sage: b=Factorization([(2,1)])
sage: a.gcd(b)
1
sage: a^(-1)
0^-1
```

That's just wrong. I think that's even worse than getting an attribute error on `.value()`.


---

Comment by zabrocki created at 2013-11-08 19:14:16

Changing status from needs_review to needs_work.


---

Comment by zabrocki created at 2013-11-08 19:14:16

> From the application you describe, I guess you're mostly interested in application to SR (the first case) in which case the most appropriate thing to do is probably to add a method `simplify_factor` to SymbolicExpression, which could happily simplify the expression "0" to the product "0". In the other cases, the code is just a lot clearer if people specify their own little one-off function that does with 0 what they want.

I (and my colleagues that are likely to use this code) will probably be working with algebras over polynomial rings/fraction fields or integer coefficients.  SR is rather slow so I don't use it much.  This is a convenience function.  I can go through my list worksheets and could say that in about 1/3 of them I've had to work around factor throwing errors at me.

> For Factorization objects: I think you really don't want those to get out into the wild when constructed with 0:
> {{{
> sage: a=Factorization([(0,1)])
> sage: b=Factorization([(2,1)])
> sage: a.gcd(b)
> 1
> sage: a^(-1)
> 0^-1
> }}}
> That's just wrong. I think that's even worse than getting an attribute error on `.value()`.
You are right.  We might need to clean up the factorization code so that it handles the 0 object properly.


---

Comment by zabrocki created at 2014-03-12 20:50:59

I noticed another problem with `factor` and the factorization objects that it returns.   I took a symmetric function expression and used `.map_coefficients(factor)` and my coefficients which were 1 and -1 disappeared (I was applying it to an expression with polynomial coefficients, but you get the idea from the following expression).


```
sage: s = SymmetricFunctions(QQ).s()
sage: (s[3,2]+2*s[2,2,1]).map_coefficients(factor)
2*s[2, 2, 1]
```


This happens because `map_coefficients` is calling `s.sum_of_terms` which calls `s.term` which calls `s._from_dict` and we have the strange behavior that `s._from_dict({Partition([3,2]) : factor(1)})` is 0.

If you trace it further, you see that `_from_dict` removes the zeros and computes 

`dict( (key, coeff) for key, coeff in d.iteritems() if coeff)`

Now `bool(factor(2))` is `True` while `bool(factor(1))` and `bool(factor(-1))` is `False`.  I don't know if there is a good reason that `factor(1)` and `factor(-1)` should be `False` or if this bug should be fixed in `combinat/free_module.py` in the code for `_from_dict`.


---

Comment by zabrocki created at 2020-01-26 12:56:26

Changing status from needs_work to needs_review.


---

Comment by zabrocki created at 2020-01-26 12:56:26

I was the one pushing for a means of gussying up algebraic expressions through a `factor_or_zero` command and this ticket hasn't been modified in 6 years.  I propose that it be closed.  While I do think that this is a problem that sometimes I am able to find no combination of `expand`, `simplify` and `factor` can clean up a coefficients of an element in an algebra, after the discussions here I don't think that doing that through playing with `factor` is the right way to go.


---

Comment by klee created at 2020-02-06 01:01:45

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2020-02-06 12:05:30

Resolution: wontfix
