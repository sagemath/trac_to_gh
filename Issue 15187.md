# Issue 15187: A coercion-related memory leak

archive/issues_015187.json:
```json
{
    "body": "CC:  @nbruin\n\nYet another leak (this test is with #15303):\n\n```\nsage: import gc\nsage: K = IntegerModRing(111115)\nsage: C = type(K)\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])\n1\nsage: K.has_coerce_map_from(ZZ)\nTrue\nsage: del K\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak\n0\nsage: a = K.get_action(ZZ, op=operator.add, self_on_left=True)\nsage: del K,a\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])\n0\nsage: K = IntegerModRing(111115)\nsage: a = K.get_action(ZZ, op=operator.mul, self_on_left=True)\nsage: b = ZZ.get_action(K, op=operator.mul, self_on_left=False)\nsage: del K,a,b\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak\n0\nsage: K = IntegerModRing(111115)\nsage: x = K.one()\nsage: del K,x\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak\n0\nsage: K = IntegerModRing(111115)\nsage: x = K.one()*2\nsage: del K,x\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # LEAK\n1\n```\n\n\nThis is astonishing. Wouldn't one think that getting (thus, caching) a coercion or getting an action should trigger a leak, or creating an element? No, we actually need to multiply two elements to find the leak.\n\nSurprising:\n\n```\nsage: K = IntegerModRing(111115)\nsage: K.get_action(ZZ, op=operator.mul, self_on_left=True) is None\nTrue\nsage: ZZ.get_action(K, op=operator.mul, self_on_left=True) is None\nTrue\n```\n\nShouldn't there be an action? OK, perhaps not, since coercion is used for the multiplication:\n\n```\nsage: cm = sage.structure.element.get_coercion_model()\nsage: cm.explain(K,ZZ, op=operator.mul)\nCoercion on right operand via\n    Natural morphism:\n      From: Integer Ring\n      To:   Ring of integers modulo 111115\nArithmetic performed after coercions.\nResult lives in Ring of integers modulo 111115\nRing of integers modulo 111115\n```\n\nBut if coercion is used, then why is establishing a coercion not enough to trigger the leak? In a new session:\n\n```\nsage: import gc\nsage: K = IntegerModRing(111115)\nsage: C = type(K)\nsage: phi = K.coerce_map_from(ZZ)\nsage: x = phi(2)\nsage: del K,phi,x\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])\n0\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/15424\n\n",
    "created_at": "2013-11-15T16:35:24Z",
    "labels": [
        "memleak",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "A coercion-related memory leak",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15187",
    "user": "@simon-king-jena"
}
```
CC:  @nbruin

Yet another leak (this test is with #15303):

```
sage: import gc
sage: K = IntegerModRing(111115)
sage: C = type(K)
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])
1
sage: K.has_coerce_map_from(ZZ)
True
sage: del K
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak
0
sage: a = K.get_action(ZZ, op=operator.add, self_on_left=True)
sage: del K,a
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])
0
sage: K = IntegerModRing(111115)
sage: a = K.get_action(ZZ, op=operator.mul, self_on_left=True)
sage: b = ZZ.get_action(K, op=operator.mul, self_on_left=False)
sage: del K,a,b
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak
0
sage: K = IntegerModRing(111115)
sage: x = K.one()
sage: del K,x
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak
0
sage: K = IntegerModRing(111115)
sage: x = K.one()*2
sage: del K,x
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # LEAK
1
```


This is astonishing. Wouldn't one think that getting (thus, caching) a coercion or getting an action should trigger a leak, or creating an element? No, we actually need to multiply two elements to find the leak.

Surprising:

```
sage: K = IntegerModRing(111115)
sage: K.get_action(ZZ, op=operator.mul, self_on_left=True) is None
True
sage: ZZ.get_action(K, op=operator.mul, self_on_left=True) is None
True
```

Shouldn't there be an action? OK, perhaps not, since coercion is used for the multiplication:

```
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.explain(K,ZZ, op=operator.mul)
Coercion on right operand via
    Natural morphism:
      From: Integer Ring
      To:   Ring of integers modulo 111115
Arithmetic performed after coercions.
Result lives in Ring of integers modulo 111115
Ring of integers modulo 111115
```

But if coercion is used, then why is establishing a coercion not enough to trigger the leak? In a new session:

```
sage: import gc
sage: K = IntegerModRing(111115)
sage: C = type(K)
sage: phi = K.coerce_map_from(ZZ)
sage: x = phi(2)
sage: del K,phi,x
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])
0
```


Issue created by migration from https://trac.sagemath.org/ticket/15424





---

archive/issue_comments_195027.json:
```json
{
    "body": "I tried to see where the reference can be coming from:\n\n```\n%cpaste\nimport gc\nfrom sage.structure.coerce_dict import *\ndef all_referrers(c,X):\n    found_IDs=set()\n    R=[]\n    new=gc.get_referrers(c)\n    found_IDs.add(id(new))\n    found_IDs.add(id(R))\n    found_IDs.add(id(globals()))    \n    while len(new)>0:\n        r=new.pop()\n        if id(r) in found_IDs or type(r) not in X:\n            print \"skipping\",type(r)\n            continue\n        R.append(r)\n        found_IDs.add(id(r))\n        new.extend(gc.get_referrers(r))\n        print \"type(r)=%s len(R)=%s len(new)=%s\"%(type(r),len(R),len(new))\n    return R\n\ndef getR():\n    K = IntegerModRing(111115)\n    C = type(K)\n    phi = K.coerce_map_from(ZZ)\n    del phi\n    #vary this line:\n    x = K.one()*2\n    #del K,x\n    _ = gc.collect()\n    X=set([list,dict,tuple,\n           RingHomset_generic_with_category,\n           sage.rings.finite_rings.integer_mod.Integer_to_IntegerMod,\n           TripleDict, MonoDict, C])\n    R=all_referrers(list(c for c in gc.get_objects() if isinstance(c,C))[0],X)\n    return R\n--\nRingHomset_generic_with_category=type(ZZ.Hom(QQ))\nR=getR()\n```\n\nand I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one. I think there is a ticket somewhere that mentions the same phenomenon (also doing arithmetic), in the context of finite fields. Somewhere from the era when we started to work on #715 in earnest.",
    "created_at": "2013-11-16T01:08:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195027",
    "user": "@nbruin"
}
```

I tried to see where the reference can be coming from:

```
%cpaste
import gc
from sage.structure.coerce_dict import *
def all_referrers(c,X):
    found_IDs=set()
    R=[]
    new=gc.get_referrers(c)
    found_IDs.add(id(new))
    found_IDs.add(id(R))
    found_IDs.add(id(globals()))    
    while len(new)>0:
        r=new.pop()
        if id(r) in found_IDs or type(r) not in X:
            print "skipping",type(r)
            continue
        R.append(r)
        found_IDs.add(id(r))
        new.extend(gc.get_referrers(r))
        print "type(r)=%s len(R)=%s len(new)=%s"%(type(r),len(R),len(new))
    return R

def getR():
    K = IntegerModRing(111115)
    C = type(K)
    phi = K.coerce_map_from(ZZ)
    del phi
    #vary this line:
    x = K.one()*2
    #del K,x
    _ = gc.collect()
    X=set([list,dict,tuple,
           RingHomset_generic_with_category,
           sage.rings.finite_rings.integer_mod.Integer_to_IntegerMod,
           TripleDict, MonoDict, C])
    R=all_referrers(list(c for c in gc.get_objects() if isinstance(c,C))[0],X)
    return R
--
RingHomset_generic_with_category=type(ZZ.Hom(QQ))
R=getR()
```

and I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one. I think there is a ticket somewhere that mentions the same phenomenon (also doing arithmetic), in the context of finite fields. Somewhere from the era when we started to work on #715 in earnest.



---

archive/issue_comments_195028.json:
```json
{
    "body": "Replying to [comment:1 nbruin]:\n> and I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one.\n\nHm. Is there any global `TripleDict` beside the one in `sage.categories.homset`? With grep, I found none. But in this case, the values would not be morphisms but homsets.",
    "created_at": "2013-11-16T16:05:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195028",
    "user": "@simon-king-jena"
}
```

Replying to [comment:1 nbruin]:
> and I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one.

Hm. Is there any global `TripleDict` beside the one in `sage.categories.homset`? With grep, I found none. But in this case, the values would not be morphisms but homsets.



---

archive/issue_comments_195029.json:
```json
{
    "body": "I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.",
    "created_at": "2013-11-16T16:19:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195029",
    "user": "@simon-king-jena"
}
```

I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.



---

archive/issue_comments_195030.json:
```json
{
    "body": "Replying to [comment:3 SimonKing]:\n> I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.\n\nNo, it does not.",
    "created_at": "2013-11-16T17:11:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195030",
    "user": "@simon-king-jena"
}
```

Replying to [comment:3 SimonKing]:
> I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.

No, it does not.



---

archive/issue_comments_195031.json:
```json
{
    "body": "OK, looking at the referrers to the TripleDict I get a  sage.structure.coerce.CoercionModel_cache_maps `sage.structure.coerce.CoercionModel_cache_maps`, so I guess it's not a \"global\" cache but one stored on an object that has an awfully long lifespan.\n\nCorrection: the values are either `None` or a pair of maps. So I guess the keys are not domain and codomain but parents of pairs of elements and the pair of maps are the ones that map into the common parent.\n\nSo my guess is that this cache is used when determining a common parent and then stores the maps needed to get to that. It seems to me we can mitigate this leak considerably if we DON'T store the maps here if we find a coercion from one into the other would do the job: instead store a symbolic \"coerce_to_first\" or \"coerce_to_second\" value in there.\n\nIn cases where there is a genuine third parent into which we're mapping, it's a little safer: then the codomain at least doesn't keep alive the keys. It's unclear to me how long we should be keeping the common overparent in that case. This cache will mean its life is bounded below by the shortest life time of the two \"covered\" parents.",
    "created_at": "2013-11-16T18:14:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195031",
    "user": "@nbruin"
}
```

OK, looking at the referrers to the TripleDict I get a  sage.structure.coerce.CoercionModel_cache_maps `sage.structure.coerce.CoercionModel_cache_maps`, so I guess it's not a "global" cache but one stored on an object that has an awfully long lifespan.

Correction: the values are either `None` or a pair of maps. So I guess the keys are not domain and codomain but parents of pairs of elements and the pair of maps are the ones that map into the common parent.

So my guess is that this cache is used when determining a common parent and then stores the maps needed to get to that. It seems to me we can mitigate this leak considerably if we DON'T store the maps here if we find a coercion from one into the other would do the job: instead store a symbolic "coerce_to_first" or "coerce_to_second" value in there.

In cases where there is a genuine third parent into which we're mapping, it's a little safer: then the codomain at least doesn't keep alive the keys. It's unclear to me how long we should be keeping the common overparent in that case. This cache will mean its life is bounded below by the shortest life time of the two "covered" parents.



---

archive/issue_comments_195032.json:
```json
{
    "body": "Attachment [chain.png](tarball://root/attachments/some-uuid/ticket15424/chain.png) by @simon-king-jena created at 2013-11-16 18:15:58\n\nA reference chain preventing an integer mod ring from garbage collection",
    "created_at": "2013-11-16T18:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195032",
    "user": "@simon-king-jena"
}
```

Attachment [chain.png](tarball://root/attachments/some-uuid/ticket15424/chain.png) by @simon-king-jena created at 2013-11-16 18:15:58

A reference chain preventing an integer mod ring from garbage collection



---

archive/issue_comments_195033.json:
```json
{
    "body": "The attached picture shows that the offending reference chain starts in the module `sage.functions.other` (which I have never even heard of) and proceeds (via some `__dict__` of 73 items) to `CoercionModel_cache_maps`, which then references a `TripleDict`.",
    "created_at": "2013-11-16T18:18:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195033",
    "user": "@simon-king-jena"
}
```

The attached picture shows that the offending reference chain starts in the module `sage.functions.other` (which I have never even heard of) and proceeds (via some `__dict__` of 73 items) to `CoercionModel_cache_maps`, which then references a `TripleDict`.



---

archive/issue_comments_195034.json:
```json
{
    "body": "Indeed, `sage.functions.other` contains the line `coercion_model = sage.structure.element.get_coercion_model()`. But I think keeping a reference to the coercion model must be legal. Hence I need to look further.",
    "created_at": "2013-11-16T18:20:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195034",
    "user": "@simon-king-jena"
}
```

Indeed, `sage.functions.other` contains the line `coercion_model = sage.structure.element.get_coercion_model()`. But I think keeping a reference to the coercion model must be legal. Hence I need to look further.



---

archive/issue_comments_195035.json:
```json
{
    "body": "Ouch. I thought that in our coercion model, maps and actions are cached on the level of parents. Now I see that they *additionally* are cached in the coercion model!\n\nApparently this additional cache is not always used. For example, it is not used if you just do `K.coerce_map_from(ZZ)`. But it seems that a coercion map *is* stored in the additional cache if you do a multiplication.\n\nAnd then you have a strongly referenced `TripleDict`, a key `(ZZ,K,None)` and a morphism `phi:ZZ->K` as value. Even with #14711, `phi` would strongly reference `K`. `ZZ` is immortal. Hence, the callback for the item `(ZZ,K,None):phi` will never be called.\n\nWhat shall we do about it? Isn't it the case that we are only storing maps that already are cached on the level of parents? Then it would be safe to just store a *weak* reference to this map, and the problem was solved.",
    "created_at": "2013-11-16T18:30:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195035",
    "user": "@simon-king-jena"
}
```

Ouch. I thought that in our coercion model, maps and actions are cached on the level of parents. Now I see that they *additionally* are cached in the coercion model!

Apparently this additional cache is not always used. For example, it is not used if you just do `K.coerce_map_from(ZZ)`. But it seems that a coercion map *is* stored in the additional cache if you do a multiplication.

And then you have a strongly referenced `TripleDict`, a key `(ZZ,K,None)` and a morphism `phi:ZZ->K` as value. Even with #14711, `phi` would strongly reference `K`. `ZZ` is immortal. Hence, the callback for the item `(ZZ,K,None):phi` will never be called.

What shall we do about it? Isn't it the case that we are only storing maps that already are cached on the level of parents? Then it would be safe to just store a *weak* reference to this map, and the problem was solved.



---

archive/issue_comments_195036.json:
```json
{
    "body": "PS: Similarly for `CoercionModel_cache_maps._action_maps`.",
    "created_at": "2013-11-16T18:49:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195036",
    "user": "@simon-king-jena"
}
```

PS: Similarly for `CoercionModel_cache_maps._action_maps`.



---

archive/issue_comments_195037.json:
```json
{
    "body": "PPS: Which means that we need to make maps weakrefable (actions already are weakrefable).",
    "created_at": "2013-11-16T19:29:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195037",
    "user": "@simon-king-jena"
}
```

PPS: Which means that we need to make maps weakrefable (actions already are weakrefable).



---

archive/issue_comments_195038.json:
```json
{
    "body": "I did not run the complete doctests, but I have added a new test that shows that I have fixed the problem. It is orthogonal to #14711.\n\nAs I said above: The idea is to only keep a weak reference from coercion model to coerce maps, which needs to make morphisms weakrefable, and which should be safe because the maps are cached on their dodomain anyway.\n----\nNew commits:",
    "created_at": "2013-11-16T20:02:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195038",
    "user": "@simon-king-jena"
}
```

I did not run the complete doctests, but I have added a new test that shows that I have fixed the problem. It is orthogonal to #14711.

As I said above: The idea is to only keep a weak reference from coercion model to coerce maps, which needs to make morphisms weakrefable, and which should be safe because the maps are cached on their dodomain anyway.
----
New commits:



---

archive/issue_comments_195039.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-11-16T20:02:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195039",
    "user": "@simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_195040.json:
```json
{
    "body": "Changing keywords from \"\" to \"coercion model, weak reference\".",
    "created_at": "2013-11-16T20:02:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195040",
    "user": "@simon-king-jena"
}
```

Changing keywords from "" to "coercion model, weak reference".



---

archive/issue_comments_195041.json:
```json
{
    "body": "Argh. Schemes seem to hate me.\n\nAlmost always when I implement something that fixes a problem, it turns out that some examples from sage.schemes will fail, because the elliptic curve code relies on what I intended to fix.\n\nBut this time it is extreme:\n\n```\nsage -t src/sage/schemes/elliptic_curves/ell_rational_field.py  # 652 doctests failed\n```\n",
    "created_at": "2013-11-16T20:20:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195041",
    "user": "@simon-king-jena"
}
```

Argh. Schemes seem to hate me.

Almost always when I implement something that fixes a problem, it turns out that some examples from sage.schemes will fail, because the elliptic curve code relies on what I intended to fix.

But this time it is extreme:

```
sage -t src/sage/schemes/elliptic_curves/ell_rational_field.py  # 652 doctests failed
```




---

archive/issue_comments_195042.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-11-16T20:23:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195042",
    "user": "@simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_195043.json:
```json
{
    "body": "Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for. Or are you afraid the callback is too expensive to handle?",
    "created_at": "2013-11-16T20:55:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195043",
    "user": "@nbruin"
}
```

Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for. Or are you afraid the callback is too expensive to handle?



---

archive/issue_comments_195044.json:
```json
{
    "body": "Replying to [comment:15 nbruin]:\n> Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for.\n\nOops, I forgot about this.\n\n> Or are you afraid the callback is too expensive to handle?\n\nNo. `CoercionModel_cache_maps._coercion_maps` stores tuples (namely: pairs of coercion maps, in both directions, hence, often `(mor,None)` or `(None,mor)`). We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.",
    "created_at": "2013-11-16T22:08:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195044",
    "user": "@simon-king-jena"
}
```

Replying to [comment:15 nbruin]:
> Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for.

Oops, I forgot about this.

> Or are you afraid the callback is too expensive to handle?

No. `CoercionModel_cache_maps._coercion_maps` stores tuples (namely: pairs of coercion maps, in both directions, hence, often `(mor,None)` or `(None,mor)`). We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.



---

archive/issue_comments_195045.json:
```json
{
    "body": "Replying to [comment:16 SimonKing]:\n> We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.\n\nNo, this won't work, because there would be no reference back to the pair, and thus it would be immediately garbage collected.",
    "created_at": "2013-11-16T22:14:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195045",
    "user": "@simon-king-jena"
}
```

Replying to [comment:16 SimonKing]:
> We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.

No, this won't work, because there would be no reference back to the pair, and thus it would be immediately garbage collected.



---

archive/issue_comments_195046.json:
```json
{
    "body": "Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.",
    "created_at": "2013-11-16T22:22:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195046",
    "user": "@nbruin"
}
```

Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.



---

archive/issue_comments_195047.json:
```json
{
    "body": "Replying to [comment:18 nbruin]:\n> Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.\n\nOK, then let us see if it fixes the problem.",
    "created_at": "2013-11-16T23:28:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195047",
    "user": "@simon-king-jena"
}
```

Replying to [comment:18 nbruin]:
> Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.

OK, then let us see if it fixes the problem.



---

archive/issue_comments_195048.json:
```json
{
    "body": "Yep, #14058 fixes the problem. Then I give a review to this ticket, saying that it is a duplicate and please be resolved as such.",
    "created_at": "2013-11-16T23:51:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195048",
    "user": "@simon-king-jena"
}
```

Yep, #14058 fixes the problem. Then I give a review to this ticket, saying that it is a duplicate and please be resolved as such.



---

archive/issue_comments_195049.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2013-11-16T23:51:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195049",
    "user": "@simon-king-jena"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_195050.json:
```json
{
    "body": "Resolution: duplicate",
    "created_at": "2013-11-21T13:02:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15187#issuecomment-195050",
    "user": "@jdemeyer"
}
```

Resolution: duplicate
