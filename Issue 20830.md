# Issue 20830: Symbolic factor() should do integer factorisation of integers/rationals

Issue created by migration from Trac.

Original creator: rws

Original creation time: 2016-07-21 06:37:44

Let symbolic `factor()` do integer factorisation if given an integer or fraction.

```
sage: SR(50).factor()
50
sage: SR(100/49).factor()
100/49
```


Too much surprise for new users.


---

Comment by rws created at 2016-07-21 08:27:23

Changing status from new to needs_review.


---

Comment by rws created at 2016-07-21 08:27:23

New commits:


---

Comment by tscrim created at 2016-07-21 14:43:58

One minor thing: could you move the import into the `factor_list` method? I worry that this could lead to import hell.


---

Comment by nbruin created at 2016-07-21 18:34:45

Two comments:

- I don't think SR needs to be imported at all. The very fact that we land in this `factor_list` implementation should mean that `self.parent()` should be SR. And if it isn't, that's probably the better parent to use anyway.

- If we're going to do this anyway, I think it's better if we have

```
sage: (5/3*x/(x+1)).factor_list()
[(x + 1, -1), (x, 1), (5, 1), (3,-1)]
```

because it's closer to the idea that the factorisation of a product U*V has a tendency to be the concatenation of the factorisations of U and V.


It should be clear that `factor_list` just returns *a* factorisation:

```
sage: ((sqrt(5)+1)^2*(x^2-5)).expand_rational().factor_list()
[(x^2 - 5, 1), (sqrt(5) + 3, 1), (2, 1)]
```


but keeping the convention that we factor rational numbers into their prime factors should be fine and could be nice for newbies.


---

Comment by git created at 2016-07-22 07:34:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-07-22 23:06:35

Instead of having a special check and a special method for integer/rationals couldn't we use something simpler and more generic like

```python
def _factorization_from_pyobject(self):
    try:
        a = self.pyobject()
    except TypeError:
        return

    try:
        f = a.factor()
    except (AttributeError, NotImplementedError):
        return

    # from here I assume that a is a Sage object which might not be the case...
    P = self.parent()
    facs = [(P(p), P(e)) for p,e in f]
    if f.unit().is_one():
        return facs
    else:
        return [(P(f.unit()), P(1))] + facs
```



---

Comment by rws created at 2016-07-23 07:49:38

Vincent, if you think it's better, then please go ahead on a new branch. I'm not so deep in Python that I could object.


---

Comment by nbruin created at 2016-07-23 15:57:18

I think "factor" in general could be a little fickle to depend on:

```
sage: K.<a>=NumberField(x^2+5)
sage: K(2).factor()
ArithmeticError: non-principal ideal in factorization
sage:  SR(2).pyobject().factor()
2
sage: (2+I-I).pyobject().factor() 
(-I) * (I + 1)^2
```



---

Comment by rws created at 2016-08-18 13:00:57

Changing status from needs_review to needs_work.


---

Comment by rws created at 2017-04-07 08:06:39

I think this ticket should also do:

```
sage: (2+6*x).factor_list()
[(3*x + 1, 1), (2, 1)]
```



---

Comment by rws created at 2017-04-16 06:43:15

Changing status from needs_work to needs_review.


---

Comment by rws created at 2017-04-16 06:43:15

I used Vincent's code for a new version that tries also to separate the content in a univariate polynomial.
----
New commits:


---

Comment by git created at 2017-11-09 07:15:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2017-11-28 07:16:40

Doctest errors, see patchbot.


---

Comment by rws created at 2017-11-28 07:16:40

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-12-06 16:09:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2017-12-06 16:09:54

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2019-03-28 09:01:01

LGTM, I only have one comment:

```diff
+            raise ValueError
```

This is only used internally, so it might be good to consider a customized exception:

```python
class CannotFactor(RuntimeError):
    pass
```

And yes, I think `RuntimeError` is more appropriate (but if you insist on `ValueError` then I am good with it as well, although wanting to hear your arguments for that ;) )
