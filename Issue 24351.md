# Issue 24351: py3: several long/int related fixes

Issue created by migration from Trac.

Original creator: embray

Original creation time: 2018-01-23 12:32:15

CC:  jdemeyer chapoton

These fix a number of major crashes related to handling of Python `int`s on Python 3, especially in cases that were trying to cram them into C `long`s.


---

Comment by embray created at 2018-01-23 12:33:33

I think this uses `integer_check_long` more or less as intended, but Jeroen will probably want to make sure, as its author.


---

Comment by embray created at 2018-01-23 12:33:33

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2018-01-23 13:21:01

Several quick comments:

1. In Cython, don't use `six` unless you have a very good reason. Cython supports `long(x)` both on Python 2 and Python 3.

2. In `integer_mod.pyx` you write

```
elif (isinstance(value, int) and
      integer_check_long_py(value, &longval, &err) and not err):
```

And you sure that you need the `isinstance(value, int)` check? Part of the point of `integer_check_long_py` is that there is no need for explicit type checking.

3. In `rational.pyx`, do you really need `IF PY_MAJOR_VERSION <= 2:`?


---

Comment by embray created at 2018-01-23 13:30:45

Changing status from needs_review to needs_work.


---

Comment by embray created at 2018-01-23 13:34:58

Replying to [comment:2 jdemeyer]:
> Several quick comments:
> 
> 1. In Cython, don't use `six` unless you have a very good reason. Cython supports `long(x)` both on Python 2 and Python 3.

Yes, I think when I wrote that one bit I just forgot I was in a Cython module.


---

Comment by embray created at 2018-01-23 13:46:31

Replying to [comment:2 jdemeyer]:

> 3. In `rational.pyx`, do you really need `IF PY_MAJOR_VERSION <= 2:`?

I believe so. In Python 2 we need both `__long__` and `__int__`, but on Python 3 if you have both defined Cython will take `__int__` (really it should take `__long__`).  But it seems to be confused.  However, if you have just `__long__` it will use it correctly.


---

Comment by git created at 2018-01-23 13:56:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2018-01-23 13:56:40

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-01-23 17:36:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2018-02-09 15:47:25

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2018-02-09 15:47:25

does not apply


---

Comment by git created at 2018-02-12 10:41:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by embray created at 2018-02-12 10:41:37

Changing status from needs_work to needs_review.


---

Comment by embray created at 2018-02-12 10:41:37

Well, it does now...


---

Comment by jdemeyer created at 2018-02-12 11:18:30

1. In `src/sage/rings/finite_rings/integer_mod.pyx`, what does "nor can it be coerced to an int" in the error message mean? You're _only_ checking for `int`/`long`, not for something that can be coerced to an int (whatever that would mean).

2. In `integer.pyx` and `rational.pyx`, you have

```
        if type(a) is not int:
            raise ValueError("must be a Python int object")

        do_something_with(PyInt_AS_LONG(a))
```

First of all, the check for `int` seems wrong since it will also pass the `int == long` type on Python 3. Second, the exception should be a `TypeError`. Since there was no check before, maybe you shouldn't add a check.

3. Don't use `PY_NEW(Rational)`. Just use `Rational.__new__(Rational)`.

4. `int_toRR` could be made more efficient by directly using an `mpz_t` instead of an `Integer`.

5. In `src/sage/structure/coerce_actions.pyx`, I would replace

```
if integer_check_long(nn, &n_long, &err) and not err:
```

by

```
integer_check_long(nn, &n_long, &err)
if not err:
```



---

Comment by jdemeyer created at 2018-02-12 11:18:38

Changing status from needs_review to needs_work.


---

Comment by embray created at 2018-02-12 11:21:26

> Don't use `PY_NEW(Rational)`. Just use `Rational.__new__(Rational)`

Can you explain this a little more?  I used to have the latter but I changed it because in the past you've told me to use `PY_NEW`, but for `Integer`.  Why for `Integer` and not `Rational`?


---

Comment by jdemeyer created at 2018-02-12 11:24:00

Also, I'm not entirely convinced by the logic in `integer_mod.pyx`. It seems that the type of the result should _only_ depend on the parent, not on the input number.


---

Comment by jdemeyer created at 2018-02-12 11:25:42

Replying to [comment:14 embray]:
> > Don't use `PY_NEW(Rational)`. Just use `Rational.__new__(Rational)`
> 
> Can you explain this a little more?  I used to have the latter but I changed it because in the past you've told me to use `PY_NEW`, but for `Integer`.

For `Integer`, we add a specific hacked `tp_new` slot. See `fast_tp_new` in `integer.pyx`. This bypasses the Cython-generated `tp_new`, so Cython might optimize `Integer.__new__(Integer)` wrongly. This is not the case for `Rational`.


---

Comment by embray created at 2018-02-12 11:36:42

Replying to [comment:12 jdemeyer]:
> 1. In `src/sage/rings/finite_rings/integer_mod.pyx`, what does "nor can it be coerced to an int" in the error message mean? You're _only_ checking for `int`/`long`, not for something that can be coerced to an int (whatever that would mean).

I think originally this `integer_check_long` which tries `__index__` and some other conversions if possible.  But I changed it--I don't remember exactly why.

> 2. In `integer.pyx` and `rational.pyx`, you have
> {{{
>         if type(a) is not int:
>             raise ValueError("must be a Python int object")
> 
>         do_something_with(PyInt_AS_LONG(a))
> }}}
> First of all, the check for `int` seems wrong since it will also pass the `int == long` type on Python 3. Second, the exception should be a `TypeError`. Since there was no check before, maybe you shouldn't add a check.

In both these cases this is code that will only ever be used on Python 2, because I also added a `long_to_<F>` map.  If anything the `int_to_<F>` could be omitted completely on Python 2 with a compile-time `IF` but I didn't because it at least does build on Python 3, but never get used.  What do you think?

I added the check very deliberately because, as you can read in the commit messages, the previous code did not have the check supposedly for "efficiency" because in practice the code is never run except through the coercion model where the appropriate type checks have already been made. However, in testing, the code is still tested directly.  And this is unsafe--on Python 2 it happened that it could work okay, but in fact it can actually lead to a segfault.  Keeping the check is good, and not having it was a needless micro-optimization.  I agree, in retrospect, it should be a `TypeError`.


> 4. `int_toRR` could be made more efficient by directly using an `mpz_t` instead of an `Integer`.

Indeed--there's no need for the `Integer` there.

> 5. In `src/sage/structure/coerce_actions.pyx`, I would replace
> {{{
> if integer_check_long(nn, &n_long, &err) and not err:
> }}}
> by
> {{{
> integer_check_long(nn, &n_long, &err)
> if not err:
> }}}

I don't care much either way.


---

Comment by embray created at 2018-02-12 11:42:00

I wonder if we couldn't add the same hack for Rational, for consistency's sake if nothing else.  Because that's completely non-obvious.  But that's an orthogonal issue.


---

Comment by embray created at 2018-02-12 11:43:28

It occurs to me I should actually add a separate `long_toRR` as I did for in integer and rational.


---

Comment by embray created at 2018-02-12 11:45:25

General question: What is the difference between `Morphism` and `Map` and why is one used in some cases and the other in other cases?


---

Comment by git created at 2018-02-12 11:47:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2018-02-12 11:56:11

Replying to [comment:20 embray]:
> General question: What is the difference between `Morphism` and `Map` and why is one used in some cases and the other in other cases?

I guess the difference is mathematical: a `Morphism` must be a morphism (this means in particular that it is defined everywhere). Coercions are required to be morphisms, conversions may be maps which are not morphisms.

But I don't know how this mathematical difference is relevant for the implementation.


---

Comment by embray created at 2018-02-12 14:14:27

Right, I know what these terms mean in mathematics but it's really unclear how or why they're being used in certain cases in Sage...


---

Comment by embray created at 2018-02-12 14:26:34

Replying to [comment:19 embray]:
> It occurs to me I should actually add a separate `long_toRR` as I did for in integer and rational.

In second thought, I'll leave this as-is for now, just in this case.  Reason being that the existing class does not override `__init__` and requires passing in the domain and codomain as arguments anyways (this is in contrast with, say, `int_to_Q` whose `__init__` bakes these in).  It would be good to change this for consistency's sake, and there's probably no problem with changing this since it's really an internal implementation detail.  But for now, since `int_toRR` is defined the way it is, there's no good reason to have separate `int` and `long` maps.

Still need your opinion on what to do with the `int_to_<F>` maps that are only relevant to Python 2.


---

Comment by git created at 2018-02-12 15:03:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2018-02-12 15:04:06

Not totally sure about this last change, but I _think_ it's better.


---

Comment by embray created at 2018-02-12 15:04:06

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2018-02-12 20:41:53

Replying to [comment:24 embray]:
> Still need your opinion on what to do with the `int_to_<F>` maps that are only relevant to Python 2.

I would just keep them.


---

Comment by jdemeyer created at 2018-02-13 15:37:53

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2018-02-13 15:37:53

1. Why `long(x)` here? Surely, `int(x)` makes more sense:

```
        if not isinstance(x, (int, long)):
            x = long(x)
```


2. After `mpz_init(x_mpz)` you need `mpz_clear(x_mpz)`.

3. [comment:15] (I would suggest to deal with that in a separate ticket, you know me)


---

Comment by embray created at 2018-02-14 16:28:23

Replying to [comment:28 jdemeyer]:
> 1. Why `long(x)` here? Surely, `int(x)` makes more sense:
> {{{
>         if not isinstance(x, (int, long)):
>             x = long(x)
> }}}

Honestly, neither is quite right.  You certainly don't want `int()` since that could overflow on Python 2.  The problem with the original design of this class it wants to be able to accept anything in its domain that can be converted to an int.  But this has problems if you want it to work for long too.  I don't know that there's actually any code that relies on its current behavior though so maybe that should just be changed.

> 2. After `mpz_init(x_mpz)` you need `mpz_clear(x_mpz)`.

Oops, of course.
 
> 3. [comment:15] (I would suggest to deal with that in a separate ticket, you know me)

Well, the solution there is just consistent with the existing logic of that class.  I'm not sure it makes a whole lot of sense either.  I would propose to leave it as-is for now (because it fixes any Python 3 specific bugs) but you could open a separate ticket if you think the logic is wrong in general.


---

Comment by jdemeyer created at 2018-02-14 16:31:26

`int(x)` doesn't overflow. It just returns a `long` instance:

```
sage: int(float(1e100))
10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104L
```



---

Comment by jdemeyer created at 2018-02-15 06:35:28

Replying to [comment:29 embray]:
> I would propose to leave it as-is for now

What's the point of replacing wrong code with different wrong code?


---

Comment by embray created at 2018-02-15 16:21:02

The answer is right in both the title and "component" of the ticket: "py3:".

This is far from the only "wrong" or at least "bad" code I've encountered in Sage in the course of making Python 3 (some of it is downright atrocious).  The focus of this changeset is to merely fix the bugs on Python 3.

> `int(x)` doesn't overflow

I was imprecise. The problem isn't that `int(x)` itself will overflow.  The behavior you cite is due to how `float.__int__` is implemented.  Not all the `__int__` in Sage return `long` objects (for Python 2) where it should.  Maybe that should be fixed (I can't remember a specific example), but it's safer to ask explicitly for a long.


---

Comment by jdemeyer created at 2018-02-15 16:25:03

Replying to [comment:32 embray]:
> Not all the `__int__` in Sage return `long` objects (for Python 2) where it should.  Maybe that should be fixed (I can't remember a specific example), but it's safer to ask explicitly for a long.

But `int(x)` is used in so many places in Sage and in Python. I feel like we should have noticed any bugs there...


---

Comment by embray created at 2018-02-15 16:28:16

In this case I could change it and see how things go.  You're right--my only justifications in this case are vague hand-waving. I don't think there's a specific issue it addresses.  Although I will say that the use of `int(x)` in many places _does_ have bugs, and they just don't show up because that code normally involves smaller numbers.


---

Comment by embray created at 2018-02-15 16:58:12

Looks like there's one test I forgot to update after [45a005d6](https://git.sagemath.org/sage.git/commit/?id=45a005d6c12d1fc7aa946f4635067f79067baeb8).  Thought I had all those but apparently not.


---

Comment by jdemeyer created at 2018-02-16 08:50:31

I will

1. add the few minor fixes which are still needed

2. revert the changes to `integer_mod.pyx` and open a new ticket for that

3. give positive review to this ticket


---

Comment by jdemeyer created at 2018-02-16 09:07:53

Changing status from needs_work to positive_review.


---

Comment by jdemeyer created at 2018-02-16 09:07:53

Last 10 new commits:


---

Comment by embray created at 2018-02-16 10:21:04

I had already fixed those things...

I'm not sure why this change:


```
-        elif err == ERR_OVERFLOW:
+        elif isinstance(x, long):
```


Why a relatively slow `isinstance` when the whole point of `ERR_OVERFLOW` is that the value was already an int/long too big to fit in a C long?  At any rate, there's now an unused `cimport` of `ERR_OVERFLOW`...


---

Comment by embray created at 2018-02-16 10:21:04

Changing status from positive_review to needs_info.


---

Comment by jdemeyer created at 2018-02-16 13:58:55

Replying to [comment:39 embray]:
> I had already fixed those things...

But not in a branch on this ticket.

> I'm not sure why this change:
> 
> {{{
> -        elif err == ERR_OVERFLOW:
> +        elif isinstance(x, long):
> }}}

> Why a relatively slow `isinstance`

First of all, it's not at all slow. This uses `PyLong_Check()` which has an optimized code path:

```C
#define PyLong_Check(op) \
        PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
```

This shouldn't take any measurable time.

The reason that I changed it is because I want to check the actual condition that I need: it must be an actual Python `long` since that is what `mpz_set_pylong` takes (without checking). It is really just an extra safety check.


---

Comment by jdemeyer created at 2018-02-16 13:58:55

Changing status from needs_info to needs_review.


---

Comment by embray created at 2018-02-21 11:49:18

I think by the time I pushed my fixes you changed it to your branch.

I see now, upon closer inspection, that `integer_check_long_py` does _not_ set `err = ERR_TYPE` if it was not passed an int/long.  So indeed in that case this additional check would be needed.  But I think that's a defect in `integer_check_long_py`.  It has _already_ checked whether or not the argument is a `long`, so if it fails that check (as well as the `int` check) it should set `err=ERR_TYPE`.  Then the additional `isinstance(...)` (fast or not--it's not micro-optimization I'm concerned with here) is unnecessary.


---

Comment by embray created at 2018-02-21 11:52:18

While you're at it, one (small) gripe I have with `integer_check_long(_py)` is that it requires a non-NULL err argument at all.  There are times I've used it where I didn't need the `err` value at all, and it would be nice if it could accept a NULL pointer (and in that case just not set the error).


---

Comment by jdemeyer created at 2018-02-21 13:21:04

To be honest, it was not easy to decide the API for `integer_check_long(_py)`. My idea was to look at various use cases and then maybe reconsider how the API should be done.

But that shouldn't affect the status of this ticket.


---

Comment by jdemeyer created at 2018-02-22 08:39:45

Replying to [comment:42 embray]:
> There are times I've used it where I didn't need the `err` value at all

Then the only information that you have is that the object is an integer of some sort where you don't care about its value. To me, that sounds unlikely so I wonder where it came up.


---

Comment by embray created at 2018-02-22 16:04:19

Replying to [comment:44 jdemeyer]:
> Replying to [comment:42 embray]:
> > There are times I've used it where I didn't need the `err` value at all
> 
> Then the only information that you have is that the object is an integer of some sort where you don't care about its value. To me, that sounds unlikely so I wonder where it came up.

Perhaps you're right. I definitely remember times during development where I wanted this, but I think maybe it was only while testing things and ignoring the error value.  Unless a specific example comes up again I won't worry about it.

The other thing I would still change.  It doesn't make sense to have a superfluous `isinstance(..., long)` there.  A small fix to `integer_check_long_py` would make more sense.


---

Comment by jdemeyer created at 2018-02-22 16:07:42

Replying to [comment:45 embray]:
> It doesn't make sense to have a superfluous `isinstance(..., long)` there.

I think it does make sense. It doesn't hurt and it's a safety net against calling `mpz_set_pylong` with a non-`long` which could potentially segfault Python.


---

Comment by embray created at 2018-02-22 16:22:41

Please re-read #24588#comment:41.

The (as you wrote, somewhat loose to begin with) API for `integer_check_long_py` doesn't make a whole lot of sense. It already checks `isinstance(x, long)` and should probably set the relevant error in that case.


---

Comment by embray created at 2018-02-22 17:11:40

The following small change is all I'm suggesting.  This brings the API for `integer_check_long_py` more in line with the general `integer_check_long`, which to me makes much more sense, especially since it seems `integer_check_long_py` is more useful on its own than you maybe initially intended.  You are willing to take it, or leave it if you still disagree.
----
New commits:


---

Comment by jdemeyer created at 2018-02-23 09:12:45

I don't agree entirely with this change:

```diff
`@``@` -176,10 +176,11 `@``@` cdef inline bint integer_check_long(x, long* value, int* err) except -1:
             err[0] = ERR_OVERFLOW
         return 1
     elif PyIndex_Check(x):
-        err[0] = ERR_INDEX
+        err[0] = 0
         try:
             x = PyNumber_Index(x)
         except TypeError:
+            err[0] = ERR_INDEX
             return 0
         return integer_check_long_py(x, value, err)
     else:
```

It seems safer and more natural to set `err[0] = ERR_INDEX` whenever any exception in `__index__` occurs. In any case, setting `err[0] = 0` is pointless because `integer_check_long_py()` is now guaranteed to set `err[0]` to some value.

I just reverted that. If you agree, you can set positive review.


---

Comment by embray created at 2018-02-23 14:22:03

Changing status from needs_review to positive_review.


---

Comment by embray created at 2018-02-23 14:22:03

Yep, I think I was misunderstanding what `ERR_INDEX` was supposed to be. Finally we've reached an agreement :)
----
New commits:


---

Comment by vbraun created at 2018-02-25 20:00:54

Resolution: fixed
