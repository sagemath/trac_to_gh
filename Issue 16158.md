# Issue 16158: adjacency_matrix raises error for large multigraphs

Issue created by migration from Trac.

Original creator: lipshitz

Original creation time: 2014-05-24 21:50:19

For G a graph, G.adjacency_matrix() calls G.density() to decide whether
to use a dense or sparse matrix. G.density() raises a TypeError if G is a
multigraph. This is silly.

To witness the problem, try:
sage: G = Graph([(i,i+1) for i in range(500)]+[(0,1),], multiedges=True)
sage: G.adjacency_matrix()

The revised code tries density and, if that raises a TypeError, defaults
to a dense matrix. (So, if someone extends density, this code
automatically improves.)


---

Comment by git created at 2014-05-25 03:00:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lipshitz created at 2014-05-25 03:01:55

Changing status from new to needs_review.


---

Comment by ncohen created at 2014-05-25 15:47:47

(curious)


---

Comment by ncohen created at 2014-05-26 10:44:00

Changing status from needs_review to needs_info.


---

Comment by ncohen created at 2014-05-26 10:44:00

Could you test that the graph is not a multigraph instead of catching the exception ?

Nathann


---

Comment by lipshitz created at 2014-05-26 13:17:15

Replying to [comment:5 ncohen]:
> Could you test that the graph is not a multigraph instead of catching the exception ?
> 
> Nathann

Sure -- if you think that's better.  My reason for doing it this way:  if someone later improves density() to work for multigraphs, adjacency_matrix will then automatically use the improved code. (I imagine someone might improve density() but not think to look at adjacency_matrix.)  And trying density() probably doesn't take much time.

Do you still prefer to test if it's a multigraph, rather than catch the exception?  If so, I'm happy to change it.


---

Comment by ncohen created at 2014-05-26 13:18:49

Hello !

> Sure -- if you think that's better.  My reason for doing it this way:  if someone later improves density() to work for multigraphs, adjacency_matrix will then automatically use the improved code. (I imagine someone might improve density() but not think to look at adjacency_matrix.)  And trying density() probably doesn't take much time.

It is not a problem of improving `.density()` : how do you define the density of a multigraph ?

Nathann


---

Comment by lipshitz created at 2014-05-26 15:13:30

Hi Nathann,

Fair enough!  On the other hand, the relevant notion here seems to be the density of the honest graph obtained by replacing each multiple edge with a single edge. I could change the code to compute that, and decide whether to return a dense or sparse matrix based on that computation. Or just have multi graphs always return a dense matrix, like the code does now. Do you have a preference?

Robert

Replying to [comment:7 ncohen]:
> Hello !
> 
> > Sure -- if you think that's better.  My reason for doing it this way:  if someone later improves density() to work for multigraphs, adjacency_matrix will then automatically use the improved code. (I imagine someone might improve density() but not think to look at adjacency_matrix.)  And trying density() probably doesn't take much time.
> 
> It is not a problem of improving `.density()` : how do you define the density of a multigraph ?
> 
> Nathann


---

Comment by ncohen created at 2014-05-26 15:16:02

Hello !

> Fair enough!  On the other hand, the relevant notion here seems to be the density of the honest graph obtained by replacing each multiple edge with a single edge.

I agree, but this is too expensive. And this is equivalent to building a sparse matrix, computing the number of non-null entries, and converting it to a dense matrix if it saves space.

> I could change the code to compute that, and decide whether to return a dense or sparse matrix based on that computation. Or just have multi graphs always return a dense matrix, like the code does now. Do you have a preference?

Returning a dense matrix in all cases makes sense to me.

Nathann


---

Comment by git created at 2014-05-27 00:20:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lipshitz created at 2014-05-27 00:46:45

Changing status from needs_info to needs_review.


---

Comment by lipshitz created at 2014-05-27 00:46:45

Replying to [comment:9 ncohen]:
> Hello !
> 
> > Fair enough!  On the other hand, the relevant notion here seems to be the density of the honest graph obtained by replacing each multiple edge with a single edge.
> 
> I agree, but this is too expensive. And this is equivalent to building a sparse matrix, computing the number of non-null entries, and converting it to a dense matrix if it saves space.
> 
> > I could change the code to compute that, and decide whether to return a dense or sparse matrix based on that computation. Or just have multi graphs always return a dense matrix, like the code does now. Do you have a preference?
> 
> Returning a dense matrix in all cases makes sense to me.
> 
> Nathann


Done, I think.

Robert


---

Comment by ncohen created at 2014-05-27 09:09:02

Why this double if/else ? All you have to do is replace

```
if n <= 256 or self.density() > 0.05:
```


with that


```
if n <= 256 or self.has_multiple_edges() or self.density() > 0.05:
```


You can also write that if you prefer :


```
if (n <= 256 or 
    self.has_multiple_edges() or
    self.density() > 0.05):
```


Nathann


---

Comment by ncohen created at 2014-05-27 09:09:02

Changing status from needs_review to needs_work.


---

Comment by git created at 2014-05-27 14:19:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lipshitz created at 2014-05-27 14:21:03

Changing status from needs_work to needs_review.


---

Comment by lipshitz created at 2014-05-27 14:21:03

Replying to [comment:12 ncohen]:
> Why this double if/else ? All you have to do is replace
> {{{
> if n <= 256 or self.density() > 0.05:
> }}}
> 
> with that
> 
> {{{
> if n <= 256 or self.has_multiple_edges() or self.density() > 0.05:
> }}}
> 
> You can also write that if you prefer :
> 
> {{{
> if (n <= 256 or 
>     self.has_multiple_edges() or
>     self.density() > 0.05):
> }}}
> 
> Nathann

Okay -- done. I didn't realize Python was that clever in evaluating "or" statements.


---

Comment by ncohen created at 2014-05-27 14:25:05

I can't fathom what everybody seems to have against if/else these days, but anyway the  code is correct....

Nathann


---

Comment by ncohen created at 2014-05-27 14:28:12

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2014-05-27 14:28:12

Please fill the "author" field with your full name.

Nathann


---

Comment by vbraun created at 2014-05-29 14:51:22

Resolution: fixed
