# Issue 33763: cleaning and enhancement to PolyDict

Issue created by migration from https://trac.sagemath.org/ticket/34000

Original creator: vdelecroix

Original creation time: 2022-06-16 09:04:15

CC:  caruso mmezzarobba saraedum




---

Comment by vdelecroix created at 2022-06-16 16:28:00

New commits:


---

Comment by vdelecroix created at 2022-06-16 16:28:00

Changing status from new to needs_review.


---

Comment by mmezzarobba created at 2022-06-18 07:54:01

Two things that I did not understand while skimming through the code:
* in `MPolynomial_polydict.integral()`, why do you have two different code paths for determining the result's parent?
* what do the `RuntimeError`s now raised by `PolyDict` on various occasions correspond to?


---

Comment by vdelecroix created at 2022-06-18 12:31:10

Replying to [comment:3 mmezzarobba]:
> Two things that I did not understand while skimming through the code:

Thanks for having a look.

> * in `MPolynomial_polydict.integral()`, why do you have two different code paths for determining the result's parent?

I shamefully copied the code from univariate polynomials, see [polynomial_element.pyx#L3980-L3985](https://github.com/sagemath/sage/blob/develop/src/sage/rings/polynomial/polynomial_element.pyx#L3980-L3985)

> * what do the `RuntimeError`s now raised by `PolyDict` on various occasions correspond to?

One of them is ensuring that keys are `ETuple`. All others are here because I also made uniform that no coefficient is zero. At least, it did not break any test.


---

Comment by mmezzarobba created at 2022-06-18 18:30:34

Replying to [comment:4 vdelecroix]:
> > * what do the `RuntimeError`s now raised by `PolyDict` on various occasions correspond to?
> 
> One of them is ensuring that keys are `ETuple`. All others are here because I also made uniform that no coefficient is zero. At least, it did not break any test.

Sorry, my question was not clear. I was mostly wondering why you were raising `RuntimeError`s rather than `ValueError`s/`TypeError`s/... (if the purpose was argument checking) or using assertions (if you wanted to guard against things that should never happen).


---

Comment by git created at 2022-06-18 19:28:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2022-06-18 19:29:31

Replying to [comment:5 mmezzarobba]:
> Replying to [comment:4 vdelecroix]:
> > > * what do the `RuntimeError`s now raised by `PolyDict` on various occasions correspond to?
> > 
> > One of them is ensuring that keys are `ETuple`. All others are here because I also made uniform that no coefficient is zero. At least, it did not break any test.
> 
> Sorry, my question was not clear. I was mostly wondering why you were raising `RuntimeError`s rather than `ValueError`s/`TypeError`s/... (if the purpose was argument checking) or using assertions (if you wanted to guard against things that should never happen).

It is really a `RuntimeError` : it is assumed that keys are `ETuple` and coefficients are nonzero.


---

Comment by vdelecroix created at 2022-06-18 19:30:31

I hope I clarified the code related to your comments in â€‹6eac6b0 and 065d42e.


---

Comment by vdelecroix created at 2022-06-18 19:39:02

Let me change `RuntimeError` for assertions.


---

Comment by git created at 2022-06-18 19:44:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-06-19 08:53:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2022-06-19 08:55:37

In the last commit I fixed a bug in `eadd_p` and optimized `homogenize` in order to fix a bug that show up in doctests from `sage.schemes.elliptic_curve.constructor`.
----
New commits:


---

Comment by git created at 2022-06-19 09:50:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2022-06-19 12:32:26

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2022-06-19 12:32:26


```
sage -t --long src/sage/rings/tate_algebra_element.pyx  # 5 doctests failed
sage -t --long src/sage/rings/tate_algebra_ideal.pyx  # 3 doctests failed
sage -t --long src/sage/rings/polynomial/multi_polynomial.pyx  # 1 doctest failed
```



---

Comment by git created at 2022-06-19 13:31:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2022-06-19 13:44:25

`@`Xavier Caruso: now that I made systematic zero coefficient removal in `polydict.pyx` I have trouble with Tate algebras. Namely, it seems that you always want to keep zeros there even though there is no natural way we can make difference between exact and inexact zero in the base ring

```
sage: R = Zp(2, print_mode='digits', prec=10)
sage: R(0, 5).is_zero()
True
sage: R(0, 5) == R(0)
True
sage: not (R(0, 5) != R(0))
True
```

This affects code such as

```
sage: R = Zp(2, print_mode='digits', prec=10)
sage: A.<x,y> = TateAlgebra(R)
sage: f = 1 + 64*x
sage: f -= R(1, 5)
sage: f
...00000 + ...0000000001000000*x
```

which now returns `...0000000001000000*x`.

On the other hand, I believe that the code in Tate algebra is buggy for the following reason. The conversion `R -> A` does not commute with binary operations

```
sage: R = Zp(2, print_mode='digits', prec=10)
sage: A.<x,y> = TateAlgebra(R)
sage: A(R(1)) - A(R(1,5))
...00000
sage: A(R(1) - R(1,5))
0
```

The following is also broken

```
sage: A({(1,1): R(0,5)})
0
```

(it should have been `R(0,5)*x*y` which prints as `...00000*x*y`)

The main question is : how do we test whether an element is exactly zero in `R` ? `r.precision_absolute() == infinity and r.is_zero()`? I could introduce an attribute `zero_test` in `PolyDict` to make this check consistently.


---

Comment by vdelecroix created at 2022-06-19 18:07:08

For the same reason as in [This is the Trac macro *comment:16* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:16-macro) multivariate polynomials over p-adics are similarly broken in the current sage

```
sage: R = Zp(2)
sage: Rxy.<x,y> = R[]
sage: Rxy(R(0,5))
0
sage: x - x
0
```



---

Comment by vdelecroix created at 2022-06-19 18:16:44

Replying to [comment:17 vdelecroix]:
> For the same reason as in [This is the Trac macro *comment:16* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:16-macro) multivariate polynomials over p-adics are similarly broken in the current sage
> {{{
> sage: R = Zp(2)
> sage: Rxy.<x,y> = R[]
> sage: Rxy(R(0,5))
> 0
> sage: x - x
> 0
> }}}

hmm as well as multivariate polynomial rings over power series

```
sage: R.<x> = PowerSeriesRing(QQ)
sage: A.<y,z> = R[]
sage: O(x^3) * y
0
```



---

Comment by caruso created at 2022-06-19 18:31:34

Replying to [comment:16 vdelecroix]:
> The main question is : how do we test whether an element is exactly zero in `R` ? `r.precision_absolute() == infinity and r.is_zero()`? I could introduce an attribute `zero_test` in `PolyDict` to make this check consistently.

I think you can use the method `_is_exact_zero` for padics.

I'll have a look at the bug in coercion from base ring to Tate algebra you noticed.


---

Comment by vdelecroix created at 2022-06-19 18:38:24

Replying to [comment:19 caruso]:
> Replying to [comment:16 vdelecroix]:
> > The main question is : how do we test whether an element is exactly zero in `R` ? `r.precision_absolute() == infinity and r.is_zero()`? I could introduce an attribute `zero_test` in `PolyDict` to make this check consistently.
> 
> I think you can use the method `_is_exact_zero` for padics.

Thanks. Though very specific to p-adics. And it does not exist for power series.

> I'll have a look at the bug in coercion from base ring to Tate algebra you noticed.

It is not a bug in the coercion system. It is the way elements of the Tate algebra are constructed. The `PolyDict` class does a cleaning of zero coefficients in its input.


---

Comment by vdelecroix created at 2022-06-19 18:44:26

As far as this ticket is concerned there is an easy way out : leave simplification of zero coefficients in `PolyDict` to the user (via the `PolyDict.remove_zeros` method). This will solve the construction issues with Tate algebra.

I opened ticket #34024 to fix polynomials.


---

Comment by git created at 2022-06-19 19:32:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2022-06-19 19:34:52

`@`Xavier Caruso Even with [This is the Trac macro *comment:21* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:21-macro) implemented I got the following failure

```
sage -t --random-seed=31078045756822634162710736872151007113 tate_algebra_ideal.pyx
**********************************************************************
File "tate_algebra_ideal.pyx", line 857, in sage.rings.tate_algebra_ideal.groebner_basis_pote
Failed example:
    I.groebner_basis(algorithm="PoTe", prec=100)  # indirect doctest
Expected:
    [...0000000001*x^3 + ...2222222222*y + ...000000000*x^2*y^2 + O(3^99 * <x, y>),
     ...0000000001*x^2*y + ...01210121020 + O(3^100 * <x, y>),
     ...0000000001*y^2 + ...01210121020*x + ...000000000*x^2*y^3 + ...0000000000*x^3*y + O(3^99 * <x, y>)]
Got:
    [...0000000001*x^3 + ...2222222222*y + ...000000000*x^2*y^2 + O(3^99 * <x, y>),
     ...0000000001*x^2*y + ...01210121020 + O(3^100 * <x, y>),
     ...0000000001*y^2 + ...01210121020*x + ...0000000000*x^3*y + O(3^99 * <x, y>)]
**********************************************************************
File "tate_algebra_ideal.pyx", line 1104, in sage.rings.tate_algebra_ideal.groebner_basis_vapote
Failed example:
    I.groebner_basis(algorithm="VaPoTe", prec=100)  # indirect doctest
Expected:
    [...0000000001*x^3 + ...2222222222*y + ...000000000*x^2*y^2 + O(3^99 * <x, y>),
     ...0000000001*x^2*y + ...01210121020 + O(3^100 * <x, y>),
     ...0000000001*y^2 + ...01210121020*x + ...000000000*x^2*y^3 + ...0000000000*x^3*y + O(3^99 * <x, y>)]
Got:
    [...0000000001*x^3 + ...2222222222*y + ...000000000*x^2*y^2 + O(3^99 * <x, y>),
     ...0000000001*x^2*y + ...01210121020 + O(3^100 * <x, y>),
     ...0000000001*y^2 + ...01210121020*x + ...0000000000*x^3*y + O(3^99 * <x, y>)]
**********************************************************************
2 items had failures:
   1 of   9 in sage.rings.tate_algebra_ideal.groebner_basis_pote
   1 of  10 in sage.rings.tate_algebra_ideal.groebner_basis_vapote
    [126 tests, 2 failures, 3.46 s]
```


Also, it did not magically fix [This is the Trac macro *comment:16* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:16-macro) since Tate algebras use multivariate polynomials over p-adic rings...


---

Comment by caruso created at 2022-06-20 08:08:47

Replying to [comment:23 vdelecroix]:
> `@`Xavier Caruso Even with [This is the Trac macro *comment:21* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:21-macro) implemented I got the following failure

Hmm. Difficult to say what is the correct answer.
I'll try to investigate this more but maybe, the easiest fix is to change the doctest.


---

Comment by git created at 2022-08-12 16:01:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by vdelecroix created at 2022-08-12 16:02:41

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2022-08-12 16:02:41

rebased on 9.7.beta8 and failing doctests modified


---

Comment by vdelecroix created at 2022-08-13 06:41:05

green bot


---

Comment by tscrim created at 2022-08-16 06:16:33

I think some timings are needed here before a positive review to see what sort of speed regressions we incur because we no longer have the option to turn off certain features and checks.

Why is addition the only operation that gets a special in-place operation? I think it would be good to make this universal.

It is generally not a good ideal to check `if type(e) is not ETuple:`. I understand this is faster than `isinstance(e, ETuple)`, but it is less future-proof if someone subclasses `ETuple`.

Naively coverage seems to have decreased; e.g., `__len__` no longer has documentation. It is a bit of a misdirect that the coverage has increased as it is just total percentage.
