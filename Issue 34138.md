# Issue 34138: sage.algebras.yangian.GeneratorIndexingSet should be a Parent

Issue created by migration from https://trac.sagemath.org/ticket/34375

Original creator: mkoeppe

Original creation time: 2022-08-16 20:12:30

CC:  tscrim

Currently:

```
sage: from sage.algebras.yangian import GeneratorIndexingSet
sage: I = GeneratorIndexingSet((1,2))
sage: I
Cartesian product of Positive integers, (1, 2), (1, 2)
sage: Set(I)  # loops forever
```



---

Comment by mkoeppe created at 2022-08-18 23:43:38

Changing priority from major to minor.


---

Comment by mkoeppe created at 2022-08-18 23:43:38

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2022-08-18 23:43:38

New commits:


---

Comment by tscrim created at 2022-08-19 04:28:01

This probably can now just be replaced by `cartesian_product`. I believe when I wrote this, it was not as good as it is now. I don't think the faÃ§ade for tuples property is so important (in particular, I don't think it makes any real difference in speed).


---

Comment by mkoeppe created at 2022-08-20 18:00:25

Probably, but I'm not inclined to work on that


---

Comment by mkoeppe created at 2022-08-20 18:00:44

(edit: NOT inclined)


---

Comment by tscrim created at 2022-08-27 03:05:38

Actually, I am starting to get a little worried about this (AFAIK implicit) requirement that every input to index a `CFM` basis (or perhaps more generally that anything that could potentially model a set within Sage that the user could potentially get to using public functions) needs to be a `Parent`. It is more restrictive than before and could potentially have knock-on effects, including speed regressions (an element can be a heavy object to construct compared to, e.g., a `tuple` and have slower hashing).

I would say the bug described in the ticket is really a fault of `Set` and not of the `GeneratorIndexingSet` (which clearly knows it is infinite through `cardinality()`).

Hence, I think this ticket as-is needs more justification than what has been given.

That being said, would be good here to avoid code duplication with `cartesian_product` as I described in comment:3.


---

Comment by mkoeppe created at 2022-08-27 03:07:39

Replying to [comment:6 tscrim]:
> this (AFAIK implicit) requirement that every input to index a `CFM` basis (or perhaps more generally that anything that could potentially model a set within Sage that the user could potentially get to using public functions) needs to be a `Parent`. 

Nobody is making or proposing this change


---

Comment by mkoeppe created at 2022-08-27 03:08:16

Your `GeneratorIndexingSet` is an infinite generator without advertising that it's infinite. Which is inconvient


---

Comment by tscrim created at 2022-08-27 03:12:22


```
sage: from sage.algebras.yangian import GeneratorIndexingSet
sage: I = GeneratorIndexingSet((1,2))
sage: I.cardinality()
+Infinity
```



---

Comment by mkoeppe created at 2022-08-27 03:13:14

A duck-typed cardinality method, I see.


---

Comment by tscrim created at 2022-08-27 03:14:00

Replying to [comment:7 mkoeppe]:
> Replying to [comment:6 tscrim]:
> > this (AFAIK implicit) requirement that every input to index a `CFM` basis (or perhaps more generally that anything that could potentially model a set within Sage that the user could potentially get to using public functions) needs to be a `Parent`. 
> 
> Nobody is making or proposing this change

That is the by-product of saying that `GeneratorIndexingSet` must be a `Parent` subclass. What about any other (infinite) set that is not a `Parent`?


---

Comment by mkoeppe created at 2022-08-27 03:18:03

I ran into this problem only because we a `_test_as_set_object` method in the category.
This calls `Set` and then runs tests on that. There's no problem otherwise. If you don't want your `GeneratorIndexingSet` put in a class/category  where `cardinality` actually means something, we can just disable this `TestSuite` test


---

Comment by tscrim created at 2022-08-27 03:23:05

I think that is a bad test. It exactly is (somewhat implicitly) giving the specification I said in comment:6. Why is that implementation of `Set` special that it must work for that? What about for objects that are not supposed to model sets? It should be a bad thing to skip tests, usually because some functionality is not implemented. I don't like allowing such a broad exception.


---

Comment by mkoeppe created at 2022-08-27 03:24:23

`_test_as_set_object` is a method of `Set_base`


---

Comment by tscrim created at 2022-08-27 03:31:59

Then I don't understand the problem. The `TestSuite(I).run()` should still pass. It sounds like this ticket should either be a wontfix or could be changed into the comment:3 proposal. I would say it is the fault of `Set(I)` of not handling cases correctly or this falls under the undecidable problem of determining if a general iterator is infinite ahead of time.


---

Comment by mkoeppe created at 2022-08-27 03:37:31

Replying to [comment:15 tscrim]:
> this falls under the undecidable problem of determining if a general iterator is infinite ahead of time.

Exactly, which is why it's not enough just to give something a `cardinality` method and hope that someone hears it quack. Best to make it a proper enumerated set, not a naked `UniqueRepresentation`.


---

Comment by tscrim created at 2022-08-27 03:56:26

Replying to [comment:16 mkoeppe]:
> Replying to [comment:15 tscrim]:
> > this falls under the undecidable problem of determining if a general iterator is infinite ahead of time.
> 
> Exactly, which is why it's not enough just to give something a `cardinality` method and hope that someone hears it quack. Best to make it a proper enumerated set, not a naked `UniqueRepresentation`. 

I think it is foolhardy to enable one specific implementation to dictate what all other classes must do, independent of what their intended purpose is for (a la comment:6).


---

Comment by mkoeppe created at 2022-08-27 04:00:59

Which "implementation" are you referring to?


---

Comment by tscrim created at 2022-08-27 04:03:34

Replying to [comment:18 mkoeppe]:
> Which "implementation" are you referring to?

The implementation of `Set`.


---

Comment by mkoeppe created at 2022-08-27 04:11:17

This file clearly needs to be updated using the infrastructure of `EnumeratedSet`s. Smelly duck typing going on there with details such as `cardinality` returning an `int`, not an `Integer`.


---

Comment by tscrim created at 2022-08-27 04:46:58

I really don't think we should mandate that it needs to be an `EnumeratedSet` (basically comment:6). However, it is bad that `cardinality()` can return an `Integer` when used within Sage (which I cannot reproduce without specifying that the level is an `int`).


---

Comment by mkoeppe created at 2022-08-27 04:55:12

Also stuff like this

```
sage: from sage.algebras.yangian import GeneratorIndexingSet
sage: I = GeneratorIndexingSet((1,2))
sage: bool(I)
TypeError: 'PlusInfinity' object cannot be interpreted as an integer
```



---

Comment by mkoeppe created at 2022-08-27 04:55:27

So let's just fix it.


---

Comment by tscrim created at 2022-08-27 04:57:26

Again, what makes this one so special that it is not actually a (major) policy change (which imposes a (IMO strong) restriction on future code)?


---

Comment by mkoeppe created at 2022-08-27 04:59:24

"this one" being `Set` or `GeneratorIndexingSet`?


---

Comment by mkoeppe created at 2022-08-27 05:05:12

What's special about `GeneratorIndexingSet` is that it provides an incorrect implementation of the [collections.abc.Set](https://docs.python.org/3/library/collections.abc.html#collections.abc.Set) protocol. It tries to duck-type its way through `CombinatorialFreeModule`, and the duck can easily get stuck somewhere


---

Comment by mkoeppe created at 2022-08-27 05:09:02

There's no policy change happening on this ticket. I noticed that the off-quacking duck gets stuck when I made the changes in #34375.


---

Comment by tscrim created at 2022-08-27 05:12:19

It doesn't have to do because it is not a subclass. It makes no claims to be a `collections.abc.Set` nor that it can work like a `Set`. Not everything has to conform to being a `collections.abc.set` or be taken as an input to a very specific implementation `Set` of a (mathematical) set. If it is not a broad policy change (like you are actually trying to do). then the infinite loop in the ticket description is either an undecideable problem or a bug that is actually in `Set` for not handling input that has a `cardinality` but is not a subclass of `Parent`.


---

Comment by mkoeppe created at 2022-08-27 05:13:37

Related is ticket #34385, which aims to standardize the quacking dialects that can pass through Sage without getting stuck. For example, `CombinatorialFreeModule.__classcall_private_` has special code for classes `range`, `list`, `tuple`, which of course falls short of the abstract quacking protocols in modern Python.


---

Comment by tscrim created at 2022-08-27 05:14:41

#34385 = policy = comment:6


---

Comment by tscrim created at 2022-08-27 05:17:06

Replying to [comment:30 tscrim]:
> #34385 = policy = comment:6

Actually, this is an overreach on my part as I only read your explanation in comment:29, which is much broader than the focus of #34385.


---

Comment by mkoeppe created at 2022-08-27 05:17:46

More importantly, #34385 is not under review here.


---

Comment by tscrim created at 2022-08-27 05:19:42

Replying to [comment:32 mkoeppe]:
> More importantly, #34385 is not under review here.

It seems like you are trying to use it for your justification here.


---

Comment by mkoeppe created at 2022-08-27 05:20:09

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2022-08-27 05:21:07

I've changed the ticket description to make a broader change - to make it an actual enumerated set. Would you agree that this by itself would be an improvement?


---

Comment by mkoeppe created at 2022-08-27 05:29:40

Replying to [comment:28 tscrim]:
> It doesn't have to do because it is not a subclass. It makes no claims to be a `collections.abc.Set` nor that it can work like a `Set`.

You are right about this; but it does make the claim of supporting the `collections.abc.Sized` protocol and violates that.


---

Comment by tscrim created at 2022-08-27 05:34:24

Replying to [comment:35 mkoeppe]:
> I've changed the ticket description to make a broader change - to make it an actual enumerated set. Would you agree that this by itself would be an improvement?

Depends on how exactly it is implemented. Merely changing it into a `Parent` at best is a neutral change, but likely a slightly negative one as the class has become a lot heavier (in terms of methods, restrictions, and creation time). If you want to make it a parent, the best and easiest way to do that is comment:3. It is clearly what it is meant to model and would remove a lot of code duplication (mainly, it would remove the class altogether). I was going to do this today.


---

Comment by tscrim created at 2022-08-27 05:38:01

Replying to [comment:36 mkoeppe]:
> Replying to [comment:28 tscrim]:
> > It doesn't have to do because it is not a subclass. It makes no claims to be a `collections.abc.Set` nor that it can work like a `Set`.
> 
> You are right about this; but it does make the claim of supporting the `collections.abc.Sized` protocol and violates that.

I don't think implementing a `__len__` does not mean it claims to support that ABC. Even if we allow that, I really do not see anywhere on that document (you have referenced multiple times in multiple places) what specifications are on the behaviors of such objects. It only states that by being a subclass of these ABCs, it is guaranteed that these methods are implemented.


---

Comment by mkoeppe created at 2022-08-27 05:40:19

Replying to [comment:38 tscrim]:
> Replying to [comment:36 mkoeppe]:
> it does make the claim of supporting the `collections.abc.Sized` protocol and violates that.
> 
> I don't think implementing a `__len__` does not mean it claims to support that ABC. Even if we allow that, I really do not see anywhere on that document (you have referenced multiple times in multiple places) what specifications are on the behaviors of such objects. It only states that by being a subclass of these ABCs, it is guaranteed that these methods are implemented.

See https://docs.python.org/3/library/collections.abc.html#collections.abc.Set
item 3) 
   "Some simple interfaces are directly recognizable by the presence of the required methods (unless those methods have been set to None):"


---

Comment by mkoeppe created at 2022-08-27 05:41:09


```
sage: import collections.abc
sage: from sage.algebras.yangian import GeneratorIndexingSet
sage: issubclass(GeneratorIndexingSet, collections.abc.Sized)
True
```



---

Comment by mkoeppe created at 2022-08-27 05:43:12

Also 

```
sage: issubclass(GeneratorIndexingSet, collections.abc.Container)
True
sage: issubclass(GeneratorIndexingSet, collections.abc.Collection)
True
```

but

```
sage: issubclass(GeneratorIndexingSet, collections.abc.Set)
False
```



---

Comment by tscrim created at 2022-08-27 05:44:59

That is because it is testing the existence of methods. Furthermore, that comment doesn't specify the semantics/behavior of the methods.


---

Comment by mkoeppe created at 2022-08-27 05:45:42

I think we'll stop this type of discussion here, it's not useful


---

Comment by mkoeppe created at 2022-08-27 05:45:55

Replying to [comment:37 tscrim]:
> If you want to make it a parent, the best and easiest way to do that is comment:3. It is clearly what it is meant to model and would remove a lot of code duplication (mainly, it would remove the class altogether). I was going to do this today.

Sounds good to me


---

Comment by tscrim created at 2022-08-27 05:47:19

As an extreme example, it does not require that `len(F) == len(list(F))` or that `all(x in F for x in F)` is `True` (of course, this would likely be a bug).


---

Comment by tscrim created at 2022-08-27 05:59:26

Changing component from combinatorics to algebra.


---

Comment by tscrim created at 2022-08-27 05:59:26

Here is the replacement.
----
New commits:


---

Comment by tscrim created at 2022-08-27 05:59:26

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2022-08-27 06:01:42

I (manually) checked that I can unpickle things before this change. Tests pass for me in `yangian.py` too.


---

Comment by git created at 2022-08-27 06:05:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-27 06:55:18

Replying to [comment:45 tscrim]:
> As an extreme example, it does not require that `len(F) == len(list(F))` 

I think you are misunderstanding the nature of the Python documentation. This is not a formal specification such as the ISO C specification, which marks various things as Undefined Behavior etc. or uses words such as MUST, SHALL, MUST NOT. So it's just misguided to try to apply language-lawyer techniques to the documentation.

The point of the `collections.abc` is to be useful -- to enable people to reliably define containers that behave just like the predefined container classes and for consumers of instances of these classes to be able to detect what protocol they can expect to work. So yes, one IS allowed to rely on such behavior.


---

Comment by tscrim created at 2022-08-27 07:23:54

You cannot have it both ways. It either is a set of specifications saying "if `isinstance` returns `True`*<sup>1</sup> then it must behave like the corresponding default Python objects that implement these ABCs" or not. You're hitting an important point that it takes care not to use enforcement words, because they understand that there can be good reasons for, e.g., a `Mapping` to not behave like a Python `dict` (much less implement operations/methods not given by the specifications).

<sup>1</sup>This is an overly broad description for the ABCs because it actually does not test inheritance like for proper classes. It is testing the existence of certain methods. You would have a more sound (although still far from watertight) argument if it actually inherited from this ABC.


---

Comment by mkoeppe created at 2022-08-27 07:32:19

Replying to [comment:50 tscrim]:
> You're hitting an important point that it takes care not to use enforcement words, because they understand that there can be good reasons 

No, my point is that the whole Python documentation is not written in the style of a formal specification. It's a useless exercise to try to poke holes into it


---

Comment by tscrim created at 2022-08-27 07:34:10

Replying to [comment:51 mkoeppe]:
> Replying to [comment:50 tscrim]:
> > You're hitting an important point that it takes care not to use enforcement words, because they understand that there can be good reasons 
> 
> No, my point is that the whole Python documentation is not written in the style of a formal specification. It's a useless exercise to try to poke holes into it 

Then stop referencing it and considering it to be gospel.


---

Comment by mkoeppe created at 2022-08-27 07:34:40

Really now?


---

Comment by mkoeppe created at 2022-08-27 07:36:58

Replying to [comment:50 tscrim]:
> if `isinstance` returns `True`*<sup>1</sup>  [...]
> 
> <sup>1</sup>This is an overly broad description for the ABCs because it actually does not test inheritance like for proper classes. It is testing the existence of certain methods. You would have a more sound (although still far from watertight) argument if it actually inherited from this ABC.

No, you are getting this wrong too. `isinstance` is guaranteed to say `yes` when a class supports the protocol. That's what these ABCs are for.

The document explains clearly the various mechanisms that lead to isinstance saying yes. 
I have already quoted for you:

  3) Some simple interfaces are directly recognizable by the presence of the required methods (unless those methods have been set to None)

But here's also:

  Complex interfaces do not support this last technique because an interface is more than just the presence of method names. Interfaces specify semantics and relationships between methods that cannot be inferred solely from the presence of specific method names. For example, knowing that a class supplies `__getitem__`, `__len__`, and `__iter__` is insufficient for distinguishing a `Sequence` from a `Mapping`.

and of course 1 (actual normal inheritance) & 2 ("virtual subclasses" through `register`).


---

Comment by tscrim created at 2022-08-27 07:37:09

Sorry, that came off harsher than I intended. You're trying to have it both ways by saying "we must follow Python's stuff" and constantly citing the ABC documentation as what we should do, but now you're saying that there is nothing within it that in mandated to follow.


---

Comment by mkoeppe created at 2022-08-27 07:39:58

Replying to [comment:55 tscrim]:
> now you're saying that there is nothing within it that in mandated to follow.

No, that's not at all what I'm saying.


---

Comment by tscrim created at 2022-08-27 07:40:12

This class is not registered as any ABC, and it clearly is not a direct subclass. As per the doc you just cited, it is stating it is testing by existence of the required method. The second part you are referencing is saying semi-explicitly that this does not guarantee any semantics. So having `isinstance(F, ABC)` being `True` does _not_ imply any behavior that should be followed.


---

Comment by mkoeppe created at 2022-08-27 07:40:43

Which class is "this class" now?


---

Comment by tscrim created at 2022-08-27 07:41:25

Replying to [comment:58 mkoeppe]:
> Which class is "this class" now?

`sage.algebras.yangian.GeneratorIndexingSet`.


---

Comment by mkoeppe created at 2022-08-27 07:42:15

The semantics of `Sized` is guaranteed because of presence of `__len__`.


---

Comment by tscrim created at 2022-08-27 07:42:41

Replying to [comment:56 mkoeppe]:
> Replying to [comment:55 tscrim]:
> > now you're saying that there is nothing within it that in mandated to follow.
> 
> No, that's not at all what I'm saying.

Then what are you saying? Specifically when you refer to the ABC doc and say because `F` implements these methods, `F` should follow other Python objects?


---

Comment by mkoeppe created at 2022-08-27 07:43:28

Yes, by providing this special method `__len__`, a class promises to follow the `Sized` protocol.


---

Comment by mkoeppe created at 2022-08-27 07:43:57

That's what mechanism 3) is doing.


---

Comment by tscrim created at 2022-08-27 07:44:09

Replying to [comment:60 mkoeppe]:
> The semantics of `Sized` is guaranteed because of presence of `__len__`.

There are no semantics that have been specified. By your own admission, there are none in the Python (ABC) doc.


---

Comment by mkoeppe created at 2022-08-27 07:45:37

Replying to [comment:64 tscrim]:
> Replying to [comment:60 mkoeppe]:
> > The semantics of `Sized` is guaranteed because of presence of `__len__`.
> 
> There are no semantics that have been specified. By your own admission, there are none in the Python (ABC) doc.

You are still missing my point about this not being a formal specification.

It's invalid to say "haha, I can do anything I want because it's not explicitly forbidden".

This is a valid approach with a formal specification.

It is meaningless with the Python docs.


---

Comment by mkoeppe created at 2022-08-27 07:47:47

One has to ask: What were the intentions in defining these ABCs?

And the answer is certainly not to say "these are good-sounding names, but they guarantee NOTHING!"


---

Comment by tscrim created at 2022-08-27 07:48:09

Replying to [comment:62 mkoeppe]:
> Yes, by providing this special method `__len__`, a class promises to follow the `Sized` protocol.

So anything that implements `__len__`, no matter what it does, must do what behaviors? Furthermore, where is this specified? If not anywhere, why?

Membership testing on the ABC is clearly not promising anything other than the method is implemented.

As an example, what if I have `x` be an element of a free monoid. What about if I want `len(x)` to be the length of the word but when I iterate over it, I want the pairs `(gen, exp)` because that is what is most convenient for the implementation and applications.


---

Comment by mkoeppe created at 2022-08-27 07:49:44

Replying to [comment:67 tscrim]:
> Replying to [comment:62 mkoeppe]:
> > Yes, by providing this special method `__len__`, a class promises to follow the `Sized` protocol.
> 
> So anything that implements `__len__`, no matter what it does, must do what behaviors? 

The obvious ones. No language-lawyering allowed.


---

Comment by tscrim created at 2022-08-27 07:52:01

Replying to [comment:65 mkoeppe]:
> Replying to [comment:64 tscrim]:
> > Replying to [comment:60 mkoeppe]:
> > > The semantics of `Sized` is guaranteed because of presence of `__len__`.
> > 
> > There are no semantics that have been specified. By your own admission, there are none in the Python (ABC) doc.
> 
> You are still missing my point about this not being a formal specification.
> 
> It's invalid to say "haha, I can do anything I want because it's not explicitly forbidden".

It's also invalid to say "Because it doesn't follow my arbitrary specifications of what I think is good that you cannot do it."

> This is a valid approach with a formal specification.
> 
> It is meaningless with the Python docs.

Then please stop citing and using them as specifications or as a reason why we should do certain things.


---

Comment by tscrim created at 2022-08-27 07:53:20

Replying to [comment:66 mkoeppe]:
> One has to ask: What were the intentions in defining these ABCs?
> 
> And the answer is certainly not to say "these are good-sounding names, but they guarantee NOTHING!"

Indeed, it is sayin "if I am a subclass of this ABC, then I will implement the specifications of this ABC". In this case, it is just that these methods are provided.


---

Comment by tscrim created at 2022-08-27 07:54:23

Replying to [comment:68 mkoeppe]:
> Replying to [comment:67 tscrim]:
> > Replying to [comment:62 mkoeppe]:
> > > Yes, by providing this special method `__len__`, a class promises to follow the `Sized` protocol.
> > 
> > So anything that implements `__len__`, no matter what it does, must do what behaviors? 
> 
> The obvious ones. No language-lawyering allowed.

Which are?


---

Comment by mkoeppe created at 2022-08-27 07:55:15

Replying to [comment:70 tscrim]:
> Replying to [comment:66 mkoeppe]:
> > One has to ask: What were the intentions in defining these ABCs?
> > 
> > And the answer is certainly not to say "these are good-sounding names, but they guarantee NOTHING!"
> 
> Indeed, it is sayin "if I am a subclass of this ABC, then I will implement the specifications of this ABC". In this case, it is just that these methods are provided.

You are still missing that for these special ABCs there are 3 additional special mechanisms that make a class a subclass of the ABC. I've already quoted them for you in comment:54


---

Comment by mkoeppe created at 2022-08-27 07:58:45

I recommend to read the PEP that introduced these things - https://peps.python.org/pep-3119/#abcs-for-containers-and-iterators


---

Comment by tscrim created at 2022-08-27 08:02:52

Replying to [comment:72 mkoeppe]:
> Replying to [comment:70 tscrim]:
> > Replying to [comment:66 mkoeppe]:
> > > One has to ask: What were the intentions in defining these ABCs?
> > > 
> > > And the answer is certainly not to say "these are good-sounding names, but they guarantee NOTHING!"
> > 
> > Indeed, it is sayin "if I am a subclass of this ABC, then I will implement the specifications of this ABC". In this case, it is just that these methods are provided.
> 
> You are still missing that for these special ABCs there are 3 additional special mechanisms that make a class a subclass of the ABC. I've already quoted them for you in comment:54

I am wondering if we have a slightly different definition of the words that they are using in the doc. We are disagreeing on the existence of something in that doc. The PEP you just cited actually has specifications. However, that is about something that is an explicit subclass. The `isinstance` test here is wrong.


---

Comment by mkoeppe created at 2022-08-27 08:04:10

I think you'll have to take a bit of time reading it.
It's my bedtime anyway, so there's plenty of time.


---

Comment by tscrim created at 2022-08-27 08:11:06

To guarantee that the behaviors specified in the PEP are followed, you should use `issubclass` rather than `isinstance` to check it if you don't want false-positives (as it is just checking if the method is there). As I mentioned, not everything that implements a `__len__` should be considered an element of `collections.abc.Sized`.


---

Comment by mkoeppe created at 2022-08-27 14:11:51

No, that does not make any sense.


---

Comment by mkoeppe created at 2022-08-27 14:12:41

But in the meantime, the bots have all turned green. We can continue the discussion about `containers.abc` on another ticket.


---

Comment by mkoeppe created at 2022-08-27 14:12:41

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-08-30 06:39:24

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2022-08-30 06:39:24


```
sage -t --long --warn-long 49.3 --random-seed=123 src/sage/algebras/yangian.py
    Timed out
**********************************************************************
Tests run before process (pid=4057225) timed out:
sage: Y = Yangian(QQ, 4) ## line 152 ##
...
sage: grY = Yangian(QQ, 4, filtration='natural').graded_algebra() ## line 973 ##
sage: x = grY.gen(12, 2, 1) * grY.gen(2, 1, 1) # indirect doctest ## line 974 ##
sage: x ## line 975 ##
tbar(2)[1,1]*tbar(12)[2,1]
sage: x == grY.gen(2, 1, 1) * grY.gen(12, 2, 1) ## line 977 ##
True
sage: sig_on_count() # check sig_on/off pairings (virtual doctest) ## line 979 ##
0
sage: grY = Yangian(QQ, 4).graded_algebra() ## line 1003 ##
sage: TestSuite(grY).run()  # long time ## line 1004 ##
------------------------------------------------------------------------
```



---

Comment by git created at 2022-08-30 06:57:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-30 06:57:58

The generic element for the new indices was too big. I explicitly pass in a few elements for testing. It now passes in a little over a second for me (on my fairly fast computer).


---

Comment by tscrim created at 2022-08-30 06:57:58

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2022-09-01 01:34:13

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-09-27 22:27:43

Resolution: fixed
