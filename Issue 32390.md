# Issue 32390: Expose backend of ring extension

Issue created by migration from https://trac.sagemath.org/ticket/32627

Original creator: klee

Original creation time: 2021-10-05 02:41:30

CC:  caruso jsrn roed saraedum

We add `backend_morphism` and `top` to expose the backend defining a ring extension. So we can


```sage
sage: F = GF(5^2)
sage: K = GF(5^4).over(F)
sage: K.backend_morphism()
Ring morphism:
  From: Finite Field in z2 of size 5^2
  To:   Finite Field in z4 of size 5^4
  Defn: z2 |--> z4^3 + z4^2 + z4 + 3
sage: K.top() == GF(5^4)
True
```



---

Comment by git created at 2021-10-05 02:44:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-10-07 03:10:35

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.


---

Comment by git created at 2021-12-24 04:52:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by lorenz created at 2021-12-28 08:44:36

Is the name "backend morphism" standard? I would probably call this `.base_change()` or `.base_change_morphism()`, `.embedding()` or `.embedding_morphism()` (assuming these maps are supposed to be injective as the name "extension" suggests), or even just `.morphism()`.


---

Comment by klee created at 2021-12-28 09:03:18

Replying to [comment:8 lorenz]:
> Is the name "backend morphism" standard?

No. It is not a mathematical term. It means the morphism at backend of (defining) the ring extension. 

I named it so since the method just returns `self._backend_defining_morphism`. The latter was named by the authors of ring extensions in Sage.   

> I would probably call this `.base_change()` or `.base_change_morphism()`, `.embedding()` or `.embedding_morphism()` (assuming these maps are supposed to be injective as the name "extension" suggests), or even just `.morphism()`.

I am okay with the last one `.morphism()`.


---

Comment by klee created at 2021-12-28 09:05:18

Or `.defining_morphism()`?


---

Comment by lorenz created at 2021-12-28 09:21:50

Replying to [comment:10 klee]:
> Or `.defining_morphism()`?

Sounds good to me.


---

Comment by git created at 2021-12-28 10:04:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-12-28 10:08:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-12-28 10:11:35

Changing status from needs_review to needs_work.


---

Comment by klee created at 2021-12-28 10:19:15

I forgot that the name `.defining_morphism()` is already taken.

```sage
sage: F = GF(5^2)
sage: K = GF(5^4).over(F)
sage: K.defining_morphism()
Ring morphism:
  From: Finite Field in z2 of size 5^2
  To:   Field in z4 with defining polynomial x^2 + (4*z2 + 3)*x + z2 over its base
  Defn: z2 |--> z2
sage: K.backend_morphism()
Ring morphism:
  From: Finite Field in z2 of size 5^2
  To:   Finite Field in z4 of size 5^4
  Defn: z2 |--> z4^3 + z4^2 + z4 + 3
```



---

Comment by klee created at 2021-12-28 10:21:51

Then `.backend_morphism()` again seems the best option...


---

Comment by lorenz created at 2021-12-28 14:03:11

I think `.backend_morphism()` is a less-than-optimal name because (1) it means nothing to mathematicians unaware of Sage internals, (2) it bakes an implementation detail into the interface, (3) the current documentation fails to explain what a backend morphism _is_.

What this means is that this method will only be useful to people who are familiar with the internals of this class, and such people can already simply access the `_backend_defining_morphism` attribute. Hence, in my opinion _something_ should be changed: (a) rename to something clearer and more mathematically meaningful; (b) expose this via an optional argument to `.defining_morphism()` (perhaps named `flatten` or `flatten_codomain`); (c) keep the name but clarify in the documentation what the returned object actually is?


---

Comment by klee created at 2021-12-28 15:34:26

I agree with your arguments. But I also want to avoid difficult names for simple things.

In the previous example, let us call the first map by (a) and the second map by (b). I think there are two ways to proceed.

(1) ".defining_morphism()" returns (b); the map (a) is registered as coercion map. This would break the design choices made by the original authors. Hence I am not sure if this would work out well.

(2) ".defining_morphism()" returns (a) (as it does now); ".morphism()" returns (b). This is of course an easy solution. 

Which do you prefer? I prefer (1) but I am also okay with (2).


---

Comment by klee created at 2021-12-29 06:30:23

Replying to [comment:17 lorenz]:
> ... What this means is that this method will only be useful to people who are familiar with the internals of this class, and such people can already simply access the `_backend_defining_morphism` attribute. 

They cannot because that attribute is defined in a cython module. Maybe this was the reason I introduced `.backend_morphism()` method in the first place.


---

Comment by git created at 2021-12-29 06:31:05

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by klee created at 2021-12-29 06:32:47

The last commit is my attempt to implement something close to (1). If we decide to go this way, then I need to add deprecation warnings of course.


---

Comment by klee created at 2021-12-29 06:34:41

Changing status from needs_work to needs_review.


---

Comment by klee created at 2021-12-29 06:34:41

Let's see how much this renaming of `.defining_morphism()` breaks sage.


---

Comment by klee created at 2021-12-29 06:38:22

With the current branch, 

```sage
sage: F = GF(5^2)
sage: K = GF(5^4).over(F)
sage: K.morphism_from_base()
Ring morphism:
  From: Finite Field in z2 of size 5^2
  To:   Field in z4 with defining polynomial x^2 + (4*z2 + 3)*x + z2 over its base
  Defn: z2 |--> z2
sage: K.defining_morphism()
Ring morphism:
  From: Finite Field in z2 of size 5^2
  To:   Finite Field in z4 of size 5^4
  Defn: z2 |--> z4^3 + z4^2 + z4 + 3
sage: K.top()
Finite Field in z4 of size 5^4
sage: K.base()
Finite Field in z2 of size 5^2
```



---

Comment by caruso created at 2021-12-29 09:58:31

cc roed and saraedum who contributed to the writing of the class `RingExtension`.

When I designed ticket #21413, this idea was to keep the backend morphism private. The point behind this was the following: the backend ring/morphism reflects how things are implemented internally while the ring extension itself is the mathematical object the user is supposed to work with.

For instance, if I do some complicated construction but the software understands by itself than the top ring is something simple and/or already efficiently implemented, then it can switch silently (magically) to this implementation. The basic example is the creation of towers of extensions (of finite fields, number fields, p-adic fields...) where it's convenient to flatten extensions to improve performances but where the user would certainly like to keep track of the intermediate fields. This philosophy is actually already more or less implemented for number fields; my motivation was to design a general framework to handle this.

For this reason, I'm really in favor to expose the backend ring/morphism to the user, but I can change my mind if you have good arguments. Why do you need this?

Besides, I thought a long time (and changed my mind several times) to the coersion model and I came with something which, I think, was satisfying. Changing the defition of `defining_morphism` would break this so again, I'm not really enthousiastic.


---

Comment by klee created at 2021-12-29 11:24:29

Thank you for comments.

> For this reason, I'm really in favor to expose the backend ring/morphism to the user, 

You mean "not to expose"?

> but I can change my mind if you have good arguments. Why do you need this?

I want to recover the morphism defining the extension when I am only given a ring extension. I think this is a natural need.
 
> Besides, I thought a long time (and changed my mind several times) to the coersion model and I came with something which, I think, was satisfying. Changing the definition of `defining_morphism` would break this so again, I'm not really enthousiastic.

The present definition of `defining_morphism` is not what one(mathematician) would naturally expect. A ring extension R over S is defined by a morphism from S to R. 

It seems `defining_morphism` is not yet used elsewhere in Sage library. So it seems quite safe to change the name. The new name `morphism_from_base` seems in good match with the definition. No?

But I do not insist to change the present definition if it is only me who finds the definition unnatural.


---

Comment by git created at 2021-12-30 00:35:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-12-30 00:45:27

Replying to [comment:24 caruso]:
> For instance, if I do some complicated construction but the software understands by itself than the top ring is something simple and/or already efficiently implemented, then it can switch silently (magically) to this implementation. The basic example is the creation of towers of extensions (of finite fields, number fields, p-adic fields...) where it's convenient to flatten extensions to improve performances but where the user would certainly like to keep track of the intermediate fields. This philosophy is actually already more or less implemented for number fields; my motivation was to design a general framework to handle this.

I understand the motivation. But I do not see why this is the reason not to expose the defining morphism (in my sense) and the top ring from the ring extension.


---

Comment by git created at 2021-12-31 00:45:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-01-01 03:07:41

Replying to [comment:24 caruso]:

> For this reason, I'm really in favor to expose the backend ring/morphism to the user, but I can change my mind if you have good arguments. Why do you need this?

I needed this ticket for #33075. But now I have made #33075 independent from this ticket. To do that, I was forced to write

```python
from sage.rings.ring_extension_conversion import backend_morphism

embedF = backend_morphism(self.defining_morphism())
```


to obtain the defining morphism from the ring extension `self`. Is there a simple solution?

> Besides, I thought a long time (and changed my mind several times) to the coersion model and I came with something which, I think, was satisfying. Changing the defition of `defining_morphism` would break this so again.

What is broken? There is no change in the coercion model.


---

Comment by caruso created at 2022-01-02 11:42:59

Replying to [comment:31 klee]:

> I needed this ticket for #33075. But now I have made #33075 independent from this ticket. To do that, I was forced to write
> {{{#!python
> from sage.rings.ring_extension_conversion import backend_morphism
> embedF = backend_morphism(self.defining_morphism())
> }}}
> 
> to obtain the defining morphism from the ring extension `self`. Is there a simple solution?

Thanks! I think that it's indeed the simplest solution.

However, I continue claiming that if you want to use the `over` constructor, you should consider to option to always work with `L/K` in place of `L`.


---

Comment by klee created at 2022-01-03 02:27:08

Replying to [comment:32 caruso]:
> Replying to [comment:31 klee]:
> 
> > I needed this ticket for #33075. But now I have made #33075 independent from this ticket. To do that, I was forced to write
> > {{{#!python
> > from sage.rings.ring_extension_conversion import backend_morphism
> > embedF = backend_morphism(self.defining_morphism())
> > }}}
> > 
> > to obtain the defining morphism from the ring extension `self`. Is there a simple solution?
> 
> Thanks! I think that it's indeed the simplest solution.

For #33075, I found that even this `embedF = self.defining_morphism()` works, perhaps because of the coercion from the extension to the top ring. This is even compatible with this ticket.

> However, I continue claiming that if you want to use the `over` constructor, you should consider to option to always work with `L/K` in place of `L`.

I don't get this. Real users choose to use whatever of `L/K` and `L` because they have access to both naturally. But for code in Sage library, it is presently inconvenient to get access to `L` (the defining morphism from `K` to `L`) from `L/K`. They are not implementation details but mathematically related objects.

The present definition of `defining_morphism()` is strange in that the object(the extension) appears as the codomain of the morphism that defines the object. I think there is no `defining_xxx()` method that has this cyclicity in Sage.
