# Issue 30410: Make lazy_import more friendly to pyflakes and other static checkers

Issue created by migration from https://trac.sagemath.org/ticket/30647

Original creator: mkoeppe

Original creation time: 2020-09-23 18:09:12

CC:  dcoudert @tobiasdiez chapoton jhpalmieri tscrim

`pyflakes` does not know about `lazy_import` and may therefore emit distracting warnings - as noted in #30616#comment:8

It should be investigated whether it is possible to support a syntax for lazy imports that looks like `import` to pyflakes, using Python 3's import machinery.

See also: 
- #22793 New LazyImport implementation based on lazy_object_proxy


---

Comment by @tobiasdiez created at 2020-09-23 18:16:32

> As a workaround, you could use lazy imports in conjunction with traditional imports, but place the traditional imports within a if TYPE_CHECKING: statement. That way, it won't execute at runtime, but the type checker will know about import for type checking purposes.

(from https://github.com/microsoft/pyright/issues/954#issuecomment-675516511)


---

Comment by chapoton created at 2020-09-23 18:21:20

Note that the patchbot "pyflakes plugin" knows about lazy imports.

BUT only with a basic syntax, one-liners.


---

Comment by mkoeppe created at 2020-09-23 18:28:35

Ah, OK, found it at https://github.com/sagemath/sage-patchbot/blob/master/sage_patchbot/plugins.py#L283


---

Comment by mkoeppe created at 2020-09-23 18:30:12

Replying to [comment:2 gh-tobiasdiez]:
> > As a workaround, you could use lazy imports in conjunction with traditional imports, but place the traditional imports within a if TYPE_CHECKING: statement. That way, it won't execute at runtime, but the type checker will know about import for type checking purposes.
> 
> (from https://github.com/microsoft/pyright/issues/954#issuecomment-675516511)

Thanks for the pointer!

Given that lazy imports are so widely used in sage, we probably don't want to use this workaround unless really necessary. It would add a lot of clutter to lots of files


---

Comment by mkoeppe created at 2020-09-23 18:39:51

A simple solution would be to make `lazy_import` return the (tuple of) lazy import objects that it creates, instead of relying on the magical namespace injection as a side effect. Then we could write

```
rightnormalform, centralizer, supersummitset = lazy_import(
  'sage.libs.braiding',
  ['rightnormalform', 'centralizer', 'supersummitset'],
  feature=PythonModule('sage.libs.braiding', spkg='libbraiding'))
```


Of course, we could as well just use `LazyImport` directly:

```
LibBraiding = PythonModule('sage.libs.braiding', spkg='libbraiding')
rightnormalform = LazyImport('sage.libs.braiding', 'rightnormalform', feature=LibBraiding)
centralizer     = LazyImport('sage.libs.braiding', 'centralizer',     feature=LibBraiding)
supersummitset  = LazyImport('sage.libs.braiding', 'supersummitset',  feature=LibBraiding)
```



---

Comment by mkoeppe created at 2020-09-23 18:54:45

Expanding on this, we could introduce a method `PythonModule.lazy_import` that would enable writing this:

```
LibBraiding = PythonModule('sage.libs.braiding', spkg='libbraiding')
rightnormalform = LibBraiding.lazy_import('rightnormalform')
centralizer,  supersummitset = LibBraiding.lazy_import(
  'centralizer', 'supersummitset')
```



---

Comment by @tobiasdiez created at 2020-09-23 19:39:20

I think this will not be sufficient for the static typing analysis. You would need to provide the information that `lazy_import('class')` returns an instance of `class`. 

Maybe one could declare it as `lazy_import(Type[C] cls) -> C` and call it via `lazy_import(sage.libs.braiding.rightnormalform)` (note that the argument is not a string). Not sure if that works.


---

Comment by git created at 2020-09-23 22:18:47

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-09-23 23:06:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-23 23:20:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-09-23 23:21:41

Here's something that seems to work.


---

Comment by mkoeppe created at 2020-09-23 23:21:41

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2020-09-23 23:22:24

Replying to [comment:8 gh-tobiasdiez]:
> I think this will not be sufficient for the static typing analysis. You would need to provide the information that `lazy_import('class')` returns an instance of `class`. 

In the current version, I suppose one could just use a typed assignment


---

Comment by mkoeppe created at 2020-09-23 23:55:58

I was hoping for a syntax such as `from sage.__lazy__.libs.braiding import rightnormalform`. I *think* this can be implemented with the python3 import machinery (https://docs.python.org/3/reference/import.html#finders-and-loaders) but haven't investigated.


---

Comment by jhpalmieri created at 2020-09-29 20:02:13

Could you please document the `feature` argument in `lazy_import.pyx`?


---

Comment by @tobiasdiez created at 2020-09-29 21:02:06

Replying to [comment:14 mkoeppe]:
> Replying to [comment:8 gh-tobiasdiez]:
> > I think this will not be sufficient for the static typing analysis. You would need to provide the information that `lazy_import('class')` returns an instance of `class`. 
> 
> In the current version, I suppose one could just use a typed assignment

What do you mean with typed assignment?
In the previous version,

```
try:
    from sage.graphs.mcqd import mcqd
except ImportError:
    from sage.misc.package import PackageNotFoundError
    raise PackageNotFoundError("mcqd")
return mcqd(self)
```

static type checkers can check if `mcqd` is actually a function defined in `sage.graphs.mcqd` and if `self` is allowed as an argument of `mcqd`. I doubt that they are intelligent enough to give the same information for the new version:


```
from sage.features import PythonModule
Mcqd = PythonModule('sage.graphs.mcqd', spkg='mcqd')
mcqd = Mcqd.lazy_import('mcqd', namespace=None)
return mcqd(self)
```



---

Comment by mkoeppe created at 2020-10-01 03:58:07

Changing status from needs_review to needs_info.


---

Comment by @tobiasdiez created at 2020-10-01 14:57:06

Another option would be to introduce (global) booleans that indicate whether a given library is available. E.g.


```
// e.g. in sage.distribution
def is_mcqd():
   try:
      from sage.graphs.mcqd import mcqd
      return true 
   except ImportError:
      return false
   // or some other way to determine if mcqd is available

// usage in another module:

// at the beginning: global import
if sage.distribution.is_mcqd():
    from sage.graphs.mcqd import mcqd
...
// later in the code
if sage.distribution.is_mcqd():
    return mcqd(self)
else:
    return ...
```


Yet another solution would be the following pattern:


```
try:
    from sage.graphs.mcqd import mcqd as _mcqd 
except ImportError:
    mcqd = None
else:
    mcqd = _mcqd

// later
if mcqd:
    return mcqd(self)
else:
    return ...
```

suggested in https://github.com/python/mypy/issues/1297#issuecomment-508593494.
This should work with mypy, not sure about pyright.


---

Comment by mkoeppe created at 2020-12-19 17:32:34

Replying to [comment:20 jhpalmieri]:
> Could you please document the `feature` argument in `lazy_import.pyx`?

This has now happened in #30587.


---

Comment by mkoeppe created at 2020-12-19 17:34:07

Replying to [comment:18 mkoeppe]:
> I was hoping for a syntax such as `from sage.__lazy__.libs.braiding import rightnormalform`. I *think* this can be implemented with the python3 import machinery (https://docs.python.org/3/reference/import.html#finders-and-loaders) but haven't investigated. 

This was previously discussed in #22752


---

Comment by mkoeppe created at 2022-12-06 22:32:14

Another solution is to provide type stub files (`__init__.pyi`), see section "type checkers" in https://scientific-python.org/specs/spec-0001/
