# Issue 34233: categories of lazy series

Issue created by migration from https://trac.sagemath.org/ticket/34470

Original creator: mantepse

Original creation time: 2022-09-01 09:50:28

CC:  tscrim




---

Comment by mantepse created at 2022-09-01 10:25:58

Changing component from PLEASE CHANGE to categories.


---

Comment by mantepse created at 2022-09-01 10:25:58

Changing keywords from "" to "LazyPowerSeries".


---

Comment by mantepse created at 2022-09-01 10:25:58

Changing type from PLEASE CHANGE to defect.


---

Comment by tscrim created at 2022-09-01 12:25:24

Indeed, a valuation ring is not simply the ring version of a valuation field.

Something in UFDs does not need to be constructive, although it does make it somewhat useless to be in that category. I cannot seem to find much of anything on factoring multivariate FPS. I suspect we can do something recursive and take advantage of the group of units being so large. Although I don’t know of a way to do this after thinking about it for the past 20 minutes. However, it is known to be a UFD (with finitely many products?).


---

Comment by mantepse created at 2022-09-01 13:47:03


```
Init signature: UniqueFactorizationDomains(s=None)
Docstring:     
   The category of unique factorization domains constructive unique
   factorization domains, i.e. where one can constructively factor
   members into a product of a finite number of irreducible elements
```


(the typo should be a ticket I'll open shortly)


---

Comment by tscrim created at 2022-09-01 13:58:55

I see. I don’t agree with that definition (there could be ambiguity about what constructively means) as the ability for something to actually do the properties specified in the category is always an implicit requirement. Anyways, it is explicitly requiring it to be done, so it shouldn’t be in UFD for now.


---

Comment by mantepse created at 2022-09-11 19:56:49

Shouldn't all of these actually be in `GradedAlgebrasWithBasis`?  I have no idea what the consequences might be.  However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type

```
sage: s = SymmetricFunctions(QQ).s()
sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
sage: f[::2]
[s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
```

instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.
----
Last 10 new commits:


---

Comment by git created at 2022-09-12 13:10:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-12 13:10:51

Replying to [comment:8 Martin Rubey]:
> Shouldn't all of these actually be in `GradedAlgebrasWithBasis`?  I have no idea what the consequences might be.

This I agree with overall, but Matthias made a good point that most of the default evaluation morphisms would not be as rings but as graded algebras, which have quite strong restrictions. There are ways around this for various special cases, but `Hom(R, S)` would still not default to the set of ring homomorphism, which would be strange for nearly all of commutative algebra. However, it should be allowed to be in `GradedAlgebrasWithBasis()` and work.

For the lazy graded algebras, that definitely should be in there.

> However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type
> {{{
> sage: s = SymmetricFunctions(QQ).s()
> sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
> sage: f[::2]
> [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
> }}}
> instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.

Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don’t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.

We can support that for the lazy graded algebras, although from the above, it creates the same tension with something that should, generically speaking, act like the underlying algebra element. There is some justification for allowing the difference since the user should be aware that it is a completely different type. I didn’t quite think this through so thoroughly when we were first doing this… I see this as a judgement call with which behavior would be better to support, and I don’t have too strong of an opinion either way. (I might even be a bit contrarian either way you chose to make sure the choice is sound, but quite likely not.)

Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.
----
New commits:


---

Comment by mantepse created at 2022-09-12 13:33:57

Replying to [comment:10 Travis Scrimshaw]:
> > However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type
> > {{{
> > sage: s = SymmetricFunctions(QQ).s()
> > sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
> > sage: f[::2]
> > [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
> > }}}
> > instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.
> 
> Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don’t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.

OK, too bad.  I could not think of a sensible example where the indices are integers, but I agree that there might be.

Could we at least have it for symmetric functions and similar stuff, interpreting integer and slice arguments as specifying degrees, and all the rest as indices?  And, perhaps more importantly, for polynomials?

> Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.

Yes, I find that this is a very impractical decision for me, because I work a lot with coefficients, and I keep forgetting how to obtain them.  Doing `list(p)[:5]` seems extremely unintuitive for me.

Remembering stuff is even harder when implementations of basic functions are so different:

```
sage: R.<s,t> = PowerSeriesRing(ZZ); R
Multivariate Power Series Ring in s, t over Integer Ring
sage: f = 1 + t + s + s*t + R.O(3)
sage: f.coefficients()
{1: 1, s: 1, t: 1, s*t: 1}
```



---

Comment by tscrim created at 2022-09-12 14:23:03

Replying to [comment:11 Martin Rubey]:
> Replying to [comment:10 Travis Scrimshaw]:
> > > However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type
> > > {{{
> > > sage: s = SymmetricFunctions(QQ).s()
> > > sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
> > > sage: f[::2]
> > > [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
> > > }}}
> > > instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.
> > 
> > Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don’t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.
> 
> OK, too bad.  I could not think of a sensible example where the indices are integers, but I agree that there might be.

The free monoid/group with one generator comes to mind. The exterior algebra is another if we realize subsets as binary representation of integers (this was originally the GSoC project Trevor was working on until we found it better to continue working with subsets through a different implementation).

> Could we at least have it for symmetric functions and similar stuff, interpreting integer and slice arguments as specifying degrees, and all the rest as indices?  And, perhaps more importantly, for polynomials?

I am a -1 on doing it for symmetric functions as they are not grouped together by degree like how the implementation is here. I also don’t like such a special case. In principle, considering the input `f = s[2]`, the result of `f[2]` could support `1` and not `0`. It doesn’t because it does not automatically cast the input. However, imagine the surprise if `f[2]` returned `s[2]` and not `1`. (And doing it a second time `_[2]` returns `0` since `2` is not a partition and the syntactic sugar rush has ended.) This would be even more so for the above examples.

This is a good chunk of the reason why I am rethinking the behavior of `__getitem__` for all lazy graded algebras. Yes, it is more work to type something like `homogeneous_component`, but at least it is explicit.

> > Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.
> 
> Yes, I find that this is a very impractical decision for me, because I work a lot with coefficients, and I keep forgetting how to obtain them.  Doing `list(p)[:5]` seems extremely unintuitive for me.

Well, I would probably do `[p[k] for k in range(5)]` if no slicing was supported to not create a longer list than needed. Basically, my understanding of their decision was to not support slicing because there are too many natural things people would want/expect, so now you just have to be explicit about it. I am not sure how much I (currently) agree with their decision, but I can understand a few different logical arguments behind it.

> Remembering stuff is even harder when implementations of basic functions are so different:
> {{{
> sage: R.<s,t> = PowerSeriesRing(ZZ); R
> Multivariate Power Series Ring in s, t over Integer Ring
> sage: f = 1 + t + s + s*t + R.O(3)
> sage: f.coefficients()
> {1: 1, s: 1, t: 1, s*t: 1}
> }}}

Ouch, that is a bit unfortunate. It is generally a good thing to make the API uniform for these things.


---

Comment by mantepse created at 2022-09-12 18:02:19

OK, we disagree slightly. I guess there is nothing we can do about it, so let it be.

Just a few minor observations:

* Note that currently, `__getitem__` of symmetric functions returns 0 when given an integer.

* For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.

* Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.

In summary:

The fundamental problem I see is that there may be ZZ-graded algebras where the index set is a subset of the integers, but the degree is something else.  I agree that this is a problem.  I disagree that this is a problem for symmetric functions.  The current behaviour of `f[i]` for a symmetric function `f` and an integer `i` is even more surprising but nobody has complained about it so far.


---

Comment by git created at 2022-09-12 22:22:40

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by tscrim created at 2022-09-13 00:46:09

Replying to [comment:13 Martin Rubey]:
> Just a few minor observations:
> 
> * Note that currently, `__getitem__` of symmetric functions returns 0 when given an integer.

Indeed, it also returns `0` for things like `x[2,1]` for `x = s[2,1]` because it doesn’t actually convert things to a partition to check it.

> * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.

That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).

> * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.

This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent )and Dirichlet) series. This would also be consistent with iteration over the elements too.

> In summary:
> 
> The fundamental problem I see is that there may be ZZ-graded algebras where the index set is a subset of the integers, but the degree is something else.  I agree that this is a problem.  I disagree that this is a problem for symmetric functions.  The current behaviour of `f[i]` for a symmetric function `f` and an integer `i` is even more surprising but nobody has complained about it so far.

It is initially surprising. Yet, you already have to know it is a way to pull coefficients of an indexed element, which means you should know it is not a partition that you are passing. Thus, with a moment of thought, it is consistent behavior (as the coefficient of the integer `i` is clearly `0`).

I am okay with doing stuff for the lazy series since they are different objects/implementations, but not for classical symmetric functions. It creates too much tension with the `__getitem__` behavior from CFM elements. You would not have `list(x)[i] != x[i]` for instance. There also is an issue for non-graded bases (say, if I implemented dual Grothendieck functions, something I want to do at some point) behaving very differently than the graded ones (a basis need not even be filtered).


---

Comment by mantepse created at 2022-09-13 06:45:37

Replying to [comment:15 Travis Scrimshaw]:

> > * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.
> 
> That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).

Yes, provided that `__getitem__` does not provide this functionality.

Let me stress that for my daily experimental work with sage, aliases are a major problem, because they are listed in the tab completion just as any other method.  They even appear twice in the documentation.  It happens very frequently that I am looking for a particular functionality, and cannot find it, so I page through the tab completion.  As an example, for SymmetricFunctions(QQ).s(), this list has currently 148 elements, even if I remove the underscore methods.

'' (if you happen to know how to make emacs and sage-shell-mode (optionally) omit the underscore methods, please let me know)

Again, this is a major problem for me.

Related to this, less severe, is that tab-completion stops working after methods.  So I have to assign names to things, and in the end I am surprised because I accidentally used the same name in a computation for two different things.
 
> > * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.
> 
> This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent )and Dirichlet) series. This would also be consistent with iteration over the elements too.

I don't understand your proposal here?  How would `lazy_list(s)` know the valuation?

> There also is an issue for non-graded bases behaving very differently than the graded ones.

Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.


---

Comment by mantepse created at 2022-09-13 06:58:47

It is actually a bit strange that we do not include the `x^n` in the `__getitem__` `LazyLaurentSeries`, univariate `LazyPowerSeries` and `LazyDirichletSeries`.

Similarly,

```
sage: s = SymmetricFunctions(QQ).s()
sage: L = LazySymmetricFunctions(s)
sage: (s[2,1]*s[2,1])[Partition([3,2,1])]
2
sage: L(s[2,1]*s[2,1])[Partition([3,2,1])]
TypeError
```

is actually quite inconsistent.

So, how about turning things around and make `__getitem__` consistently pick out a single coefficient (no idea how to do this with multivariate polynomials, though), and improve `restrict_degree` and `homogeneous_parts` to give us the other thing.

Of course, this is a bit impractical, because for univariate power series I am not interested at all in the `x^n`, wheras for multivariate power series, I am only interested in the full graded piece.


---

Comment by mantepse created at 2022-09-13 07:12:41

I just realised that I am confusing two different instances of `__getitem__`:

* `SymmetricFunctions(QQ).s().__getitem__`, and

* `SymmetricFunctions(QQ).s().an_element().__getitem__`.

Clearly, the first one should only take partitions.

However, for the second, it might actually be *more* consistent, to only take integers and slices.


---

Comment by tscrim created at 2022-09-13 07:47:32

Replying to [comment:16 Martin Rubey]:
> Replying to [comment:15 Travis Scrimshaw]:
> 
> > > * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.
> > 
> > That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).
> 
> Yes, provided that `__getitem__` does not provide this functionality.

This would be a bad practice. We agree that things in the category should not assume that `__getitem__` is implementing this, right? So if I write generic code at the category level that is using this property of being in the category, I need this method. We cannot remove such an alias (or redirection or code duplication) without breaking that.

> Let me stress that for my daily experimental work with sage, aliases are a major problem, because they are listed in the tab completion just as any other method.  They even appear twice in the documentation.  It happens very frequently that I am looking for a particular functionality, and cannot find it, so I page through the tab completion.  As an example, for SymmetricFunctions(QQ).s(), this list has currently 148 elements, even if I remove the underscore methods.

I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`). It would be nice to remove the duplicate documentation for aliases, but I don't think sphinx thinks its a priority for them.

> '' (if you happen to know how to make emacs and sage-shell-mode (optionally) omit the underscore methods, please let me know)

Unfortunately I have no idea as I don't use emacs.

> Again, this is a major problem for me.

I don't think there is too much anyone can do about this. It is better to have things discoverable by tab completion, and we want methods that are useful for other people to be included to.

> Related to this, less severe, is that tab-completion stops working after methods.  So I have to assign names to things, and in the end I am surprised because I accidentally used the same name in a computation for two different things.

I don't understand this. Do you mean it does not work for attributes? I have those intermingled in my tab completion lists.

> > > * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.
> > 
> > This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent (and Dirichlet) series. This would also be consistent with iteration over the elements too.
> 
> I don't understand your proposal here?  How would `lazy_list(s)` know the valuation?

They don't, and that is a benefit to me. You don't fall into the pitfalls of the polynomials.

> > There also is an issue for non-graded bases behaving very differently than the graded ones.
> 
> Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.

I am focusing on just the symmetric function part now. The ring of symmetric functions has a ZZ-grading, but not every basis consists of homogeneous elements (i.e., is naturally ZZ-graded). What should I expect if I use a basis such as `g[la] = s[la] + lower deg terms`? It is a filtered basis of a graded algebra.

In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?

NB: Our implementation only works for graded bases.


---

Comment by mantepse created at 2022-09-13 08:41:44

Replying to [comment:19 Travis Scrimshaw]:

> I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`).

I miscommunicated.  My problem is when I actually do not know whether some sort of functionality exists.  For example, I'd like to get all elements of a given degree in a multivariate polynomial.  So I do

```
sage: R.<x,y,z> = ZZ[]; f = R.an_element(); f.<tab>
```

Now, emacs offers me 97 methods.  Fortunately, I can search in the list of completions, where I find `degree`, `degrees`, `total_degree`, `weighted_degree`.  Those do not fit.  I also notice `truncate`, `monomials`, and so on.  With a lot of luck I will actually find `homogeneous_components`, buried among the other 96 methods.

I am not saying that this can be made much better easily.  However, I am saying that this can be made much worse, by introducing more aliases.  I am guessing that it would be extremely difficult for emacs to detect whether one method is an alias of another.


---

Comment by mantepse created at 2022-09-13 09:02:45

Replying to [comment:19 Travis Scrimshaw]:
>
> > Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.
> 
> I am focusing on just the symmetric function part now. The ring of symmetric functions has a ZZ-grading, but not every basis consists of homogeneous elements (i.e., is naturally ZZ-graded). What should I expect if I use a basis such as `g[la] = s[la] + lower deg terms`? It is a filtered basis of a graded algebra.
> 
> In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?

Why would it be strange for `x[2]` to return `g[1,1] + g[1]`?  

> NB: Our implementation only works for graded bases.

Yes, I can think of some places where things might go wrong.  Do you have an example in sage (or is there an easy way to define a basis) such that I can experiment?


---

Comment by mantepse created at 2022-09-13 11:04:13

Answering my own question:

```
sage: ht = SymmetricFunctions(QQ).ht()
sage: s = SymmetricFunctions(QQ).s()
sage: s(ht[2])
-s[1] + s[2]
```

is a basis which is not homogeneous.  I am guessing that there is some trouble here:

```
sage: ht[2].homogeneous_degree()
2
sage: s(ht[2]).homogeneous_degree()
ValueError
sage: (ht[1] + ht[2]).homogeneous_degree()
ValueError
sage: s(ht[1] + ht[2]).homogeneous_degree()
2
```



---

Comment by tscrim created at 2022-09-13 11:57:52

Replying to [comment:20 Martin Rubey]:
> Replying to [comment:19 Travis Scrimshaw]:
> 
> > I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`).
> 
> I miscommunicated.  My problem is when I actually do not know whether some sort of functionality exists.  For example, I'd like to get all elements of a given degree in a multivariate polynomial.  So I do
> {{{
> sage: R.<x,y,z> = ZZ[]; f = R.an_element(); f.<tab>
> }}}
> Now, emacs offers me 97 methods.  Fortunately, I can search in the list of completions, where I find `degree`, `degrees`, `total_degree`, `weighted_degree`.  Those do not fit.  I also notice `truncate`, `monomials`, and so on.  With a lot of luck I will actually find `homogeneous_components`, buried among the other 96 methods.

I see. We might need some better class-level documentation or more tutorials. If I couldn’t immediately find it by tab completion, I might then go to the doc for the class and skim through its methods, and then up through the categories. Although I think I quickly realize certain large chunks of the tab completion available methods can be ignored because I know they are not what I want.

> I am not saying that this can be made much better easily.  However, I am saying that this can be made much worse, by introducing more aliases.  I am guessing that it would be extremely difficult for emacs to detect whether one method is an alias of another.

Indeed, we should be careful to not overpopulate any namespace. Yet, we generally cannot keep it so small.

Detecting when a method is an alias of another is easy I think, just check the address of the method:

```
sage: class Foo:
....:     def bar(x):
....:         return x + 5
....:     baz = bar

sage: Foo.bar is Foo.baz
True
```

However, the question is which one to keep. The alias sometimes can be the one you will actually recognize (e.g., same function but different names coming from different fields).


---

Comment by tscrim created at 2022-09-13 12:04:02

Replying to [comment:21 Martin Rubey]:
> Replying to [comment:19 Travis Scrimshaw]:
> > In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?
> 
> Why would it be strange for `x[2]` to return `g[1,1] + g[1]`?  

It is returning something that is not obviously homogeneous, and you get more terms than before. I guess for filtered algebras you can make it be “up to degree i,” which is how we define degree for filtered: the smallest filtered piece something belongs to. Although using that, slices do not make sense.


---

Comment by mantepse created at 2022-09-13 12:13:24

Yes.  I was just about to send the following, before you answered :-)

Apparently, I misunderstood the notion of homogeneous component in a filtered algebra, at least if I follow `FilteredModulesWithBasis`.  In your example, `g[1,1] + g[1]` would **not** be considered homogeneous.  In fact, right now it seems to me that it is not possible to define "homogeneous element" other than depending on a basis.


---

Comment by mantepse created at 2022-09-13 12:21:46

sorry, I meant "homogeneous component", not "homogeneous element".


---

Comment by tscrim created at 2022-09-13 12:32:56

It is perhaps slightly non-standard notion of degree and homogeneous, but we wanted to make filtered and graded stuff behave somewhat uniformly/consistently.


---

Comment by git created at 2022-09-16 10:02:26

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mantepse created at 2022-09-16 10:26:03

I just noticed that it would be great to absorb the two `check` functions in the `TESTS` section, line 103ff of `lazy_ring.py` into the `TestSuite` framework, but I do not know how to do this.


```
sage: L = LazyPowerSeriesRing(ZZ, 't, s')
sage: L.some_elements()
[1 + 1 + 1 + 1 + O(t,s)^5]
```

is a bad bug.  Most of the `some_elements` methods return a very poor selection.


```
sage: LazyDirichletSeriesRing(ZZ, 't, s')
Lazy Dirichlet Series Ring in t over Integer Ring
```

is a bit surprising.


---

Comment by tscrim created at 2022-09-16 10:29:29

I will respond in more detail and to the other ticket when I get back after dinner.

To add to the `TestSuite`, you just need to name a function `_test_foo`.

The result of `some_elements()` generally needs a bit of human intervention.


---

Comment by mantepse created at 2022-09-16 10:41:37

Just let me know what I should implement, so we don't tread on each others toes.


---

Comment by tscrim created at 2022-09-16 10:54:58

I spent basically no time doing what I did. Feel free to go ahead and do what you want/need to do. I can just cherry-pick stuff as necessary.

BTW - the controversial stuff here is the UFD category part.


---

Comment by mantepse created at 2022-09-16 13:10:09

OK, I am going to spend one more afternoon on this.  I'll try to put everything in different commits as much as seems reasonable.  It would be great however, if you could point out which patchbot was failing on #32367.


---

Comment by tscrim created at 2022-09-16 13:18:45

Replying to [comment:33 Martin Rubey]:
> OK, I am going to spend one more afternoon on this.  I'll try to put everything in different commits as much as seems reasonable.  It would be great however, if you could point out which patchbot was failing on #32367.

I just did a moment ago. I also pushed my changes and cherry-picked the `_im_gens_` there too.


---

Comment by git created at 2022-09-16 14:28:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-16 14:56:24

Hurray, I actually found a real bug in the comparison of 'exact' series :-)


---

Comment by git created at 2022-09-16 16:37:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-16 20:27:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-16 20:42:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-16 20:56:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-16 20:57:22

Changing status from new to needs_review.


---

Comment by tscrim created at 2022-09-16 23:35:52

Good catch. Although I am wondering how much more complicated equality becomes if we do not insist. I will try to take a look today, and if not, then tomorrow.

Also

```diff
-        TESTS:
+        TESTS::
 
             sage: L.<t> = LazyPowerSeriesRing(QQ)
```



---

Comment by mantepse created at 2022-09-17 06:02:16

I actually think now that it is better this way. We probably don't gain anything by postponing. In any case it is premature optimization.


---

Comment by git created at 2022-09-17 08:06:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-17 08:39:58

Some more low-hanging fruits, possibly for other tickets:

* move the two checks in the global `TESTS:` section of `lazy_series.py` to the `TestSuite` framework.  The padics people have some very nice tests, by the way.  I wonder why there is no generic test of division in the category framework, or did I overlook it?  Possibly related: #17965

* implement `some_elements` for the graded completion, and think of better `_an_element` and `some_elements` in general. Currently, most examples are 'exact'.  Why is `an_element` of `ZZ` just `1`, the is not a very typical element.

* Stream_cauchy_compose and Stream_plethysm have some similarities, maybe we can make them more obvious.

* there are some non-lazy sums of the form `sum(a[i]*b[i] for i in ...)` in `stream.py`. These should possibly be replaced by something like
   {{{
   s = zero
   for i in ...:
       left = a[i]
       if left:
           s += left * b[i]
   }}}
   (not only for performance, but also we should not evaluate `b[i]` when we shouldn't, even if this makes the sum asymmetric).  This should be a helper function

* the testsuites now give us a very rough performance measure, maybe we can exploit that

* I vaguely remember that somewhere in `lazy_series.py` I had to be careful when trying to detect a geometric series.  This should be easier now.


---

Comment by mantepse created at 2022-09-17 10:33:30

I just noticed in `discrete_valuation.py`

```
    def super_categories(self):
        """
        EXAMPLES::

            sage: DiscreteValuationRings().super_categories()
            [Category of euclidean domains]
        """
        return [EuclideanDomains()]
```

shouldn't that be `PrincipalIdealDomains()`, according to https://en.wikipedia.org/wiki/Discrete_valuation_ring?


---

Comment by tscrim created at 2022-09-17 10:59:09

Replying to [comment:43 Martin Rubey]:
> I actually think now that it is better this way. We probably don't gain anything by postponing. In any case it is premature optimization.

+1 It is an implementation detail that we can easily change later on.


---

Comment by tscrim created at 2022-09-17 11:02:47

Replying to [comment:45 Martin Rubey]:
> Some more low-hanging fruits, possibly for other tickets:
> 
> * move the two checks in the global `TESTS:` section of `lazy_series.py` to the `TestSuite` framework.  The padics people have some very nice tests, by the way.  I wonder why there is no generic test of division in the category framework, or did I overlook it?  Possibly related: #17965

Division is not guaranteed except in `Fields`, so it doesn’t make sense to test it in any more general category. However, I don’t think there are any such tests.

> * implement `some_elements` for the graded completion, and think of better `_an_element` and `some_elements` in general. Currently, most examples are 'exact'.  Why is `an_element` of `ZZ` just `1`, the is not a very typical element.

The result of `an_element()` doesn’t need to be so generic. Beyond an example, it is used by the coercion framework for setting things up via the generic coercion map using `_element_constructor_`.

> * Stream_cauchy_compose and Stream_plethysm have some similarities, maybe we can make them more obvious.

+1 Probably good place for subclassing.

> * there are some non-lazy sums of the form `sum(a[i]*b[i] for i in ...)` in `stream.py`. These should possibly be replaced by something like
>    {{{
>    s = zero
>    for i in ...:
>        left = a[i]
>        if left:
>            s += left * b[i]
>    }}}
>    (not only for performance, but also we should not evaluate `b[i]` when we shouldn't, even if this makes the sum asymmetric).  This should be a helper function

Sounds good overall. I might need to see details before a final verdict, but I think it should be good.

> * the testsuites now give us a very rough performance measure, maybe we can exploit that

Indeed.

> * I vaguely remember that somewhere in `lazy_series.py` I had to be careful when trying to detect a geometric series.  This should be easier now.

Great! I think this was with exact series in some way. I don’t remember exactly, but I also recall something like that.


---

Comment by git created at 2022-09-17 11:49:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-17 11:51:18

I did a few more corrections (in fact, I overlooked the wrong _an_element in my previous commit).

Unfortunately, I really should stop now.

If there is anything which absolutely needs to be done for positive review, please let me know. Otherwise, I'd like to move the remaining stuff into new tickets.


---

Comment by tscrim created at 2022-09-17 14:53:54

One thing I would really like to see is an attempt to make a positive valuation element for `some_elements` of the `LazyCompletionGradedAlgebra`:

```python
it = iter(self._laurent_poly_ring.basis())
extra_elt = sum(b for _ in range(4) if (b := next(it)).degree())
if extra_elt:
    elts.append(extra_elt)
```

Of course, if the graded algebra is "trivial" with everything in degree 0, this won't get anything (or if the first few basis elements are all degree 0). So we just need to protect against that.

Other than that, I think we should bring this these into UFDs where appropriate. That way we signal the correct mathematical information, and the functions that want the constructive behavior will fail with either an `AttributeError` or a `NotImplementedError`.

Actually, FPS in a single variable are a Euclidean domain (see [this MSE post](https://math.stackexchange.com/questions/3911013/show-that-the-ring-of-formal-power-series-is-a-euclidean-domain)): The Euclidean algorithm uses the valuation and works as follows:

For f(x) / g(x), we want to consider f(x) = q(x) g(x) + r(x). Define F(x) by x<sup>val(f)</sup> F(x) = f(x) and similarly G(x) using g(x). This breaks up into 2 cases:

1. If val(f) >= val(g), we have f(x) / g(x) = x^val(f) - val(g)^ F(x) / G(x).
2. If val(f) < val(g), then we have q(x) = 0 and r(x) = f(x). Then we proceed with the Euclidean algorithm.

For this implementation, we can simply in the `__init__` make `self.euclidean_degree = self.valuation`. This would also become a simple `quo_rem` function.

Furthermore, this gives me an idea for doing the GCD. Let f(X) = d<sub>f</sub>(X) F(X), where F(X) is a unit and d<sub>f</sub>(X) is the lowest degree portion of f(X); similarly for g(X). Then, we have

gcd(f(X), g(X)) = gcd(d<sub>f</sub>(X)F(X), d<sub>g</sub>(X)G(X)) = gcd(d<sub>f</sub>(X), d<sub>g</sub>(X))

This would then be very easy to implement. I can do this tomorrow if you don't want to do it.

Once we do this, this we achieve the actual stated goal of the ticket. `:P`


---

Comment by git created at 2022-09-17 15:01:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-17 15:01:55

funniest bug ever :-)


---

Comment by mantepse created at 2022-09-17 15:02:53

The following would make our test suite run *much* faster.

```
diff --git a/src/sage/libs/lrcalc/lrcalc.py b/src/sage/libs/lrcalc/lrcalc.py
index b541bfacd89..1bfaba4ec14 100644
--- a/src/sage/libs/lrcalc/lrcalc.py
+++ b/src/sage/libs/lrcalc/lrcalc.py
@@ -202,7 +202,7 @@ def _lrcalc_dict_to_sage(result):
         sage: mult([2,1],[3,2,1],3) # indirect doctest
         {[3, 3, 3]: 1, [4, 3, 2]: 2, [4, 4, 1]: 1, [5, 2, 2]: 1, [5, 3, 1]: 1}
     """
-    return {_Partitions(la): Integer(k) for la, k in result.items()}
+    return {_Partitions.element_class(_Partitions, la): Integer(k) for la, k in result.items()}
 
 def lrcoef_unsafe(outer, inner1, inner2):
     r"""
```



---

Comment by tscrim created at 2022-09-17 15:08:14

Indeed, and much better `is_unit` tests. `:)`

+1 for comment:54; this avoids some checks IIRC.

I am not sure for comment:46 in light of comment:51. I am not immediately sure if the valuation always defines a Euclidean function, but I am thinking it does. Although we might not be able to do a generic implementation as everything depends on `quo_rem` and there might be other (and better) Euclidean functions.


---

Comment by mantepse created at 2022-09-17 15:22:51

See #34549 for lrcalc.


---

Comment by git created at 2022-09-17 21:10:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-18 00:56:09

Thanks.

Unfortunately what I said about the gcd proof is false. We cannot simply factor out the lowest term like that. Consider `f(x,y) = x + y + HOT`, but we can only span a 2 dimensional subspace of `span{x^2, xy, y^2}` for any given unit. This discrepancy only gets worse for higher degrees. Thus, there exists elements in R[This is the Trac macro *x,y* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x,y-macro) / U, where U is the group of units, whose representatives are always infinite sums.

We might be able to do something using something in [this article](https://www.sciencedirect.com/science/article/pii/S0747717108801058), but it seems a bit involved.

Perhaps it is best to leave the UFD separate for now.


---

Comment by mantepse created at 2022-09-18 08:00:03

Yes, please!  I'd really like to have factorization, but more than that I'd like to have the current branch in develop.

I tried to find some facts concerning formal Dirichlet series.  What I found would be the diff below.  However, I do not want to hold up this ticket any longer.  So I'd rather include it in a later ticket.  I suggest that we document your findings there, also.


```diff
diff --git a/src/sage/rings/lazy_series_ring.py b/src/sage/rings/lazy_series_ring.py
index ca2ccf29f2c..a3dcd136aa2 100644
--- a/src/sage/rings/lazy_series_ring.py
+++ b/src/sage/rings/lazy_series_ring.py
@@ -763,7 +763,8 @@ class LazySeriesRing(UniqueRepresentation, Parent):
 
         EXAMPLES::
 
-            sage: Zp(3)._test_invert()
+            sage: L = LazyLaurentSeriesRing(QQ, 'z')
+            sage: L._test_invert()
 
         .. SEEALSO::
 
@@ -2175,7 +2176,7 @@ class LazyDirichletSeriesRing(LazySeriesRing):
     Element = LazyDirichletSeries
 
     def __init__(self, base_ring, names, sparse=True, category=None):
-        """
+        r"""
         Initialize the ring.
 
         TESTS::
@@ -2198,14 +2199,45 @@ class LazyDirichletSeriesRing(LazySeriesRing):
             sage: L in PrincipalIdealDomains
             False
 
-        In particular, it is not a :wikipedia:`discrete_valuation_ring`.
+        In particular, it is not a
+        :wikipedia:`discrete_valuation_ring`.  On the other hand, it
+        is a :wikipedia:`local_ring`.  The unique maximal ideal
+        consists of all non-invertible series, i.e., series with
+        vanishing constant term.
 
         .. TODO::
 
             According to the answers in
             https://mathoverflow.net/questions/5522/dirichlet-series-with-integer-coefficients-as-a-ufd,
             the ring of formal Dirichlet series is actually a
-            UniqueFactorizationDomain.
+            :wikipedia:`Unique_factorization_domain`.
+
+        .. NOTE::
+
+            An interesting valuation is described in Emil Daniel
+            Schwab; Gheorghe Silberberg A note on some discrete
+            valuation rings of arithmetical functions Archivum
+            Mathematicum, Vol. 36 (2000), No. 2, 103--109,
+            http://dml.cz/dmlcz/107723.  Let `J_k` be the ideal of
+            Dirichlet series whose coefficient `f[n]` of `n^s`
+            vanishes if `n` has less than `k` prime factors, counting
+            multiplicities.  For any Dirichlet series `f`, let `D(f)`
+            be the largest integer `k` such that `f` is in `J_k`.
+            Then `D` is surjective, `D(f g) = D(f) + D(g)` for
+            nonzero `f` and `g`, and `D(f + g) \geq \min(D(f), D(g))`
+            provided that `f + g` is nonzero.
+
+            For example, `J_1` are series with no constant term, and
+            `J_2` are series such that `f[1]` and `f[p]` for prime
+            `p` vanish.
+
+            Since this is a chain of increasing ideals, the ring of
+            formal Dirichlet series is not a
+            :wikipedia:`Noetherian_ring`.
+
+            Evidently, this valuation cannot be computed for a given
+            series.
+
         """
         if base_ring.characteristic() > 0:
             raise ValueError("positive characteristic not allowed for Dirichlet series")
```



---

Comment by mantepse created at 2022-09-18 14:04:20

Replying to [comment:38 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[f9dd62e](https://git.sagemath.org/sage.git/commit/?id=f9dd62e7b9db93db213eb4d8b10e7e1f77920a5d)||`fix equality of exact series, do not produce coefficients of polynomials by iterating over them`||

The following commit fixes an oversight in this commit.


---

Comment by git created at 2022-09-18 14:07:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-18 16:13:56

I found a number of additional bugs from some additional test suites to test the different categories. I will have more changes, but now I really need to go to bed. It took me much longer than it should have to find the bad equality test that stemmed from not converting the coefficients to the base ring in `_an_element_`.
----
New commits:


---

Comment by mantepse created at 2022-09-18 16:22:21

I'm sorry about that, I fixed the same bug independently (and it took me a very long time, too).  Unfortunately, I did this in #34552.


---

Comment by mantepse created at 2022-09-18 16:31:58

(so, in case you continue while I sleep, please check #34552)


---

Comment by git created at 2022-09-19 07:51:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-19 07:51:50

Travis, do you know already why this branch is failing tests in the species directory?
----
New commits:


---

Comment by tscrim created at 2022-09-19 07:53:28

Replying to [comment:66 Martin Rubey]:
> Travis, do you know already why this branch is failing tests in the species directory?

No, I don't. I haven't been testing that directory. Let me do so right now.


---

Comment by tscrim created at 2022-09-19 07:57:47

In the branch I just pushed, I made some changes:

- I fixed a major bug with the `UniqueRepresentation`.
- I changed `_true_order` to be a boolean as I felt there was no reason to duplicate the approximate and actual orders (now they can't get out of sync).
- I made the `R[This is the Trac macro *x* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x-macro)` fraction field `R((x))` when `R` is a field.
- Implemented `f // g` generically. It won't necessarily fail outright if it cannot work as it has to actually try to do the normal division.
- I marked some tests as `# long time` as they were taking nearly 2 seconds on my (8 year old) laptop.
- I brought in your doc in comment:59.

Next to figure out what is going wrong with the species.


---

Comment by tscrim created at 2022-09-19 08:02:12

Ah, I know why: I am dynamically setting the `Element` attribute of the FPS based on the input ring.


---

Comment by mantepse created at 2022-09-19 08:02:55

Oh wow, you did a lot of work!

I fixed a few bugs also in #34552, so I think it would be prudent not to increase the scope of this branch.


---

Comment by mantepse created at 2022-09-19 08:09:43

Also, just as a heads up, I will eventually want to make things in `__invert__` and `revert` fully lazy, see the todo notes in #34552.

Finally: I wanted to introduce something simlilar to `LazyPowerSeries_gcd` for `revert` and `compose`, except that I only need it for the testsuite.  Maybe there is a more structured way?


---

Comment by git created at 2022-09-19 08:14:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-19 08:17:30

Here is the fix for species.

I decided to do the mixin approach for FPS (in contrast to FLS) since it is more specialized code. I could simply move `[x]gcd` to the `LazyPowerSeries` class and add checks to error out when invalid. This gets rid of the dynamic class, but they will always appear (where we have less understanding, even over *Z* as I understand it). Your choice.


---

Comment by tscrim created at 2022-09-19 08:18:30

Also +1 for cutting this ticket off and moving on to #34552 for additional changes.


---

Comment by mantepse created at 2022-09-19 08:23:07

Sorry, I don't understand enough of mixin, please decide yourself.

Just an explanation (no need to change anything now) for my seemingly weird `true_order` duplicating `approximate_order`.  The idea (I don't know yet whether it was good or not) was as follows:

`true_order` could be used in places where we currently use `approximate_order`, and sometimes even without checking.  However, if we make a mistake, and `true_order` is actually not yet set, we would be told by the exception that would be raised (because we cannot compute with `None`).


---

Comment by mantepse created at 2022-09-19 08:25:47

#32367 is not positive review, by the way.  Is something missing there, or do you want to make them positive all at once?


---

Comment by mantepse created at 2022-09-19 08:48:00

Shall we somehow notify Volker that it is only necessary to merge the top ticket (which will be either this one or #34552)?


---

Comment by tscrim created at 2022-09-19 08:50:43

Then let’s leave it as is.

I see. We could go back to doing `_true_order` being an (extended?) integer then. It is unlikely that they do get out of sync, but some care might be needed, especially with the `_element_constructor_`. We should note this reasoning somewhere in either a code or regular doc comment.

#32367 is just waiting for a green patchbot. If you want to run all tests and build the doc to verify my changes are good, then you can set a positive review as well.

The whole sequence of tickets will be merged. We have set them up so they merge cleanly. There is nothing we need to worry about for that.


---

Comment by mantepse created at 2022-09-19 09:14:23

OK.  I thought the github patchbot is enough.

Concerning `_true_order_`: once the dust has settled, I might work on #34553 and check whether it is overall better to improve `_approximate_order_` in `Stream_inexact.__getitem__`.  I am quite sure it is, but I'd like to have a good testsuite first.  So, currently it's premature optimization.

I was thinking about my very original goal, extending species to the multivariate setting.  Possibly it makes sense to regard them as a graded algebra.  They have a basis (see https://en.wikipedia.org/wiki/Burnside_ring), but usually we do **not** want to compute in this basis, and only use the grading.


---

Comment by tscrim created at 2022-09-19 09:26:12

There are mechanisms in Sage to have a basis in a graded algebra that is not graded (or even filtered). I guess in some way, as long as we have a way to separate elements of the ring into graded pieces, we can use the `LazyCompletionSeries`. Actually, in that way this would work for filtered algebras as well (with the generalized definition of homogeneous).


---

Comment by mantepse created at 2022-09-19 09:49:49

I actually think that having a graded algebra with a non-graded basis, but using the "generalized" definition of graded is going to be problematic, because our product assumes that it knows in which graded piece it is.

But let's see when we get there.


---

Comment by tscrim created at 2022-09-19 10:10:12

Ah, right, we do use the graded property. In fact, we even need it: it an algebra was (lower) filtered, we could have accumulation in the constant coefficient.


---

Comment by git created at 2022-09-20 02:31:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-20 02:34:43

Patchbot here was morally green (something seems broken with its giac and unrelated to this ticket) up to the pyflakes things I just fixed.

I think anything further can be done on subsequent tickets and we are at a good cutoff point. If you're happy as well, we feel free to set a positive review.


---

Comment by mantepse created at 2022-09-20 05:20:41

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-09-22 03:45:56

This has no additional conflict with the changes I made in #34413.


---

Comment by git created at 2022-09-26 10:29:02

Changing status from positive_review to needs_review.


---

Comment by git created at 2022-09-26 10:29:02

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:


---

Comment by mantepse created at 2022-09-26 10:29:20

trivial (automatic) merge, necessary to make the patchbots happy.


---

Comment by mantepse created at 2022-09-26 10:29:20

Changing status from needs_review to positive_review.


---

Comment by git created at 2022-10-05 15:32:09

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2022-10-05 15:32:09

Changing status from positive_review to needs_review.


---

Comment by mantepse created at 2022-10-05 15:33:22

Trivial merge, done because I keep switching between 9.8.beta0 and 9.8.beta1, which is a waste of time.


---

Comment by mantepse created at 2022-10-05 15:33:33

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-10-16 22:15:53

Resolution: fixed
