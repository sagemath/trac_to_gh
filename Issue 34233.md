# Issue 34233: categories of lazy series

archive/issues_034233.json:
```json
{
    "body": "CC:  @tscrim\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/34470\n\n",
    "created_at": "2022-09-01T09:50:28Z",
    "labels": [],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "categories of lazy series",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/34233",
    "user": "https://github.com/mantepse"
}
```
CC:  @tscrim



Issue created by migration from https://trac.sagemath.org/ticket/34470





---

archive/issue_comments_484941.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to categories.",
    "created_at": "2022-09-01T10:25:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484941",
    "user": "https://github.com/mantepse"
}
```

Changing component from PLEASE CHANGE to categories.



---

archive/issue_comments_484942.json:
```json
{
    "body": "Changing keywords from \"\" to \"LazyPowerSeries\".",
    "created_at": "2022-09-01T10:25:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484942",
    "user": "https://github.com/mantepse"
}
```

Changing keywords from "" to "LazyPowerSeries".



---

archive/issue_comments_484943.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2022-09-01T10:25:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484943",
    "user": "https://github.com/mantepse"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_484944.json:
```json
{
    "body": "Indeed, a valuation ring is not simply the ring version of a valuation field.\n\nSomething in UFDs does not need to be constructive, although it does make it somewhat useless to be in that category. I cannot seem to find much of anything on factoring multivariate FPS. I suspect we can do something recursive and take advantage of the group of units being so large. Although I don\u2019t know of a way to do this after thinking about it for the past 20 minutes. However, it is known to be a UFD (with finitely many products?).",
    "created_at": "2022-09-01T12:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484944",
    "user": "https://github.com/tscrim"
}
```

Indeed, a valuation ring is not simply the ring version of a valuation field.

Something in UFDs does not need to be constructive, although it does make it somewhat useless to be in that category. I cannot seem to find much of anything on factoring multivariate FPS. I suspect we can do something recursive and take advantage of the group of units being so large. Although I don’t know of a way to do this after thinking about it for the past 20 minutes. However, it is known to be a UFD (with finitely many products?).



---

archive/issue_comments_484945.json:
```json
{
    "body": "\n```\nInit signature: UniqueFactorizationDomains(s=None)\nDocstring:     \n   The category of unique factorization domains constructive unique\n   factorization domains, i.e. where one can constructively factor\n   members into a product of a finite number of irreducible elements\n```\n\n\n(the typo should be a ticket I'll open shortly)",
    "created_at": "2022-09-01T13:47:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484945",
    "user": "https://github.com/mantepse"
}
```


```
Init signature: UniqueFactorizationDomains(s=None)
Docstring:     
   The category of unique factorization domains constructive unique
   factorization domains, i.e. where one can constructively factor
   members into a product of a finite number of irreducible elements
```


(the typo should be a ticket I'll open shortly)



---

archive/issue_comments_484946.json:
```json
{
    "body": "I see. I don\u2019t agree with that definition (there could be ambiguity about what constructively means) as the ability for something to actually do the properties specified in the category is always an implicit requirement. Anyways, it is explicitly requiring it to be done, so it shouldn\u2019t be in UFD for now.",
    "created_at": "2022-09-01T13:58:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484946",
    "user": "https://github.com/tscrim"
}
```

I see. I don’t agree with that definition (there could be ambiguity about what constructively means) as the ability for something to actually do the properties specified in the category is always an implicit requirement. Anyways, it is explicitly requiring it to be done, so it shouldn’t be in UFD for now.



---

archive/issue_comments_484947.json:
```json
{
    "body": "Shouldn't all of these actually be in `GradedAlgebrasWithBasis`?  I have no idea what the consequences might be.  However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type\n\n```\nsage: s = SymmetricFunctions(QQ).s()\nsage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])\nsage: f[::2]\n[s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]\n```\n\ninstead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.\n----\nLast 10 new commits:",
    "created_at": "2022-09-11T19:56:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484947",
    "user": "https://github.com/mantepse"
}
```

Shouldn't all of these actually be in `GradedAlgebrasWithBasis`?  I have no idea what the consequences might be.  However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type

```
sage: s = SymmetricFunctions(QQ).s()
sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
sage: f[::2]
[s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
```

instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.
----
Last 10 new commits:



---

archive/issue_comments_484948.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-12T13:10:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484948",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484949.json:
```json
{
    "body": "Replying to [comment:8 Martin Rubey]:\n> Shouldn't all of these actually be in `GradedAlgebrasWithBasis`?  I have no idea what the consequences might be.\n\nThis I agree with overall, but Matthias made a good point that most of the default evaluation morphisms would not be as rings but as graded algebras, which have quite strong restrictions. There are ways around this for various special cases, but `Hom(R, S)` would still not default to the set of ring homomorphism, which would be strange for nearly all of commutative algebra. However, it should be allowed to be in `GradedAlgebrasWithBasis()` and work.\n\nFor the lazy graded algebras, that definitely should be in there.\n\n> However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type\n> {{{\n> sage: s = SymmetricFunctions(QQ).s()\n> sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])\n> sage: f[::2]\n> [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]\n> }}}\n> instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.\n\nStrong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don\u2019t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.\n\nWe can support that for the lazy graded algebras, although from the above, it creates the same tension with something that should, generically speaking, act like the underlying algebra element. There is some justification for allowing the difference since the user should be aware that it is a completely different type. I didn\u2019t quite think this through so thoroughly when we were first doing this\u2026 I see this as a judgement call with which behavior would be better to support, and I don\u2019t have too strong of an opinion either way. (I might even be a bit contrarian either way you chose to make sure the choice is sound, but quite likely not.)\n\nSomewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.\n----\nNew commits:",
    "created_at": "2022-09-12T13:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484949",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:8 Martin Rubey]:
> Shouldn't all of these actually be in `GradedAlgebrasWithBasis`?  I have no idea what the consequences might be.

This I agree with overall, but Matthias made a good point that most of the default evaluation morphisms would not be as rings but as graded algebras, which have quite strong restrictions. There are ways around this for various special cases, but `Hom(R, S)` would still not default to the set of ring homomorphism, which would be strange for nearly all of commutative algebra. However, it should be allowed to be in `GradedAlgebrasWithBasis()` and work.

For the lazy graded algebras, that definitely should be in there.

> However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type
> {{{
> sage: s = SymmetricFunctions(QQ).s()
> sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
> sage: f[::2]
> [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
> }}}
> instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.

Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don’t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.

We can support that for the lazy graded algebras, although from the above, it creates the same tension with something that should, generically speaking, act like the underlying algebra element. There is some justification for allowing the difference since the user should be aware that it is a completely different type. I didn’t quite think this through so thoroughly when we were first doing this… I see this as a judgement call with which behavior would be better to support, and I don’t have too strong of an opinion either way. (I might even be a bit contrarian either way you chose to make sure the choice is sound, but quite likely not.)

Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.
----
New commits:



---

archive/issue_comments_484950.json:
```json
{
    "body": "Replying to [comment:10 Travis Scrimshaw]:\n> > However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type\n> > {{{\n> > sage: s = SymmetricFunctions(QQ).s()\n> > sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])\n> > sage: f[::2]\n> > [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]\n> > }}}\n> > instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.\n> \n> Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don\u2019t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.\n\nOK, too bad.  I could not think of a sensible example where the indices are integers, but I agree that there might be.\n\nCould we at least have it for symmetric functions and similar stuff, interpreting integer and slice arguments as specifying degrees, and all the rest as indices?  And, perhaps more importantly, for polynomials?\n\n> Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.\n\nYes, I find that this is a very impractical decision for me, because I work a lot with coefficients, and I keep forgetting how to obtain them.  Doing `list(p)[:5]` seems extremely unintuitive for me.\n\nRemembering stuff is even harder when implementations of basic functions are so different:\n\n```\nsage: R.<s,t> = PowerSeriesRing(ZZ); R\nMultivariate Power Series Ring in s, t over Integer Ring\nsage: f = 1 + t + s + s*t + R.O(3)\nsage: f.coefficients()\n{1: 1, s: 1, t: 1, s*t: 1}\n```\n",
    "created_at": "2022-09-12T13:33:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484950",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:10 Travis Scrimshaw]:
> > However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type
> > {{{
> > sage: s = SymmetricFunctions(QQ).s()
> > sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
> > sage: f[::2]
> > [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
> > }}}
> > instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.
> 
> Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don’t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.

OK, too bad.  I could not think of a sensible example where the indices are integers, but I agree that there might be.

Could we at least have it for symmetric functions and similar stuff, interpreting integer and slice arguments as specifying degrees, and all the rest as indices?  And, perhaps more importantly, for polynomials?

> Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.

Yes, I find that this is a very impractical decision for me, because I work a lot with coefficients, and I keep forgetting how to obtain them.  Doing `list(p)[:5]` seems extremely unintuitive for me.

Remembering stuff is even harder when implementations of basic functions are so different:

```
sage: R.<s,t> = PowerSeriesRing(ZZ); R
Multivariate Power Series Ring in s, t over Integer Ring
sage: f = 1 + t + s + s*t + R.O(3)
sage: f.coefficients()
{1: 1, s: 1, t: 1, s*t: 1}
```




---

archive/issue_comments_484951.json:
```json
{
    "body": "Replying to [comment:11 Martin Rubey]:\n> Replying to [comment:10 Travis Scrimshaw]:\n> > > However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type\n> > > {{{\n> > > sage: s = SymmetricFunctions(QQ).s()\n> > > sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])\n> > > sage: f[::2]\n> > > [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]\n> > > }}}\n> > > instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.\n> > \n> > Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don\u2019t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.\n> \n> OK, too bad.  I could not think of a sensible example where the indices are integers, but I agree that there might be.\n\nThe free monoid/group with one generator comes to mind. The exterior algebra is another if we realize subsets as binary representation of integers (this was originally the GSoC project Trevor was working on until we found it better to continue working with subsets through a different implementation).\n\n> Could we at least have it for symmetric functions and similar stuff, interpreting integer and slice arguments as specifying degrees, and all the rest as indices?  And, perhaps more importantly, for polynomials?\n\nI am a -1 on doing it for symmetric functions as they are not grouped together by degree like how the implementation is here. I also don\u2019t like such a special case. In principle, considering the input `f = s[2]`, the result of `f[2]` could support `1` and not `0`. It doesn\u2019t because it does not automatically cast the input. However, imagine the surprise if `f[2]` returned `s[2]` and not `1`. (And doing it a second time `_[2]` returns `0` since `2` is not a partition and the syntactic sugar rush has ended.) This would be even more so for the above examples.\n\nThis is a good chunk of the reason why I am rethinking the behavior of `__getitem__` for all lazy graded algebras. Yes, it is more work to type something like `homogeneous_component`, but at least it is explicit.\n\n> > Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.\n> \n> Yes, I find that this is a very impractical decision for me, because I work a lot with coefficients, and I keep forgetting how to obtain them.  Doing `list(p)[:5]` seems extremely unintuitive for me.\n\nWell, I would probably do `[p[k] for k in range(5)]` if no slicing was supported to not create a longer list than needed. Basically, my understanding of their decision was to not support slicing because there are too many natural things people would want/expect, so now you just have to be explicit about it. I am not sure how much I (currently) agree with their decision, but I can understand a few different logical arguments behind it.\n\n> Remembering stuff is even harder when implementations of basic functions are so different:\n> {{{\n> sage: R.<s,t> = PowerSeriesRing(ZZ); R\n> Multivariate Power Series Ring in s, t over Integer Ring\n> sage: f = 1 + t + s + s*t + R.O(3)\n> sage: f.coefficients()\n> {1: 1, s: 1, t: 1, s*t: 1}\n> }}}\n\nOuch, that is a bit unfortunate. It is generally a good thing to make the API uniform for these things.",
    "created_at": "2022-09-12T14:23:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484951",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:11 Martin Rubey]:
> Replying to [comment:10 Travis Scrimshaw]:
> > > However, it might be nice if, for any element of an integer graded algebra, `__getitem__` would be defined as we just did for `LazyModuleElement`.  I'd love to be able to type
> > > {{{
> > > sage: s = SymmetricFunctions(QQ).s()
> > > sage: f = s[2,1]*(s[1]+s[2]+s[3]+s[4])
> > > sage: f[::2]
> > > [s[2, 1, 1] + s[2, 2] + s[3, 1], s[3, 2, 1] + s[4, 1, 1] + s[4, 2] + s[5, 1]]
> > > }}}
> > > instead of a clumsy list with `restrict_degree`.  More importantly, I'd love to know that this is uniform across graded algebras.
> > 
> > Strong -1 on this for graded algebras in general because in CFM elements, `f[i]` should get the coefficient with index `i`. What happens when the indexing set contains integers? Slices also don’t make sense. Furthermore, implementations should be allowed to implement their own version of `__getitem__`, which might be useful for them.
> 
> OK, too bad.  I could not think of a sensible example where the indices are integers, but I agree that there might be.

The free monoid/group with one generator comes to mind. The exterior algebra is another if we realize subsets as binary representation of integers (this was originally the GSoC project Trevor was working on until we found it better to continue working with subsets through a different implementation).

> Could we at least have it for symmetric functions and similar stuff, interpreting integer and slice arguments as specifying degrees, and all the rest as indices?  And, perhaps more importantly, for polynomials?

I am a -1 on doing it for symmetric functions as they are not grouped together by degree like how the implementation is here. I also don’t like such a special case. In principle, considering the input `f = s[2]`, the result of `f[2]` could support `1` and not `0`. It doesn’t because it does not automatically cast the input. However, imagine the surprise if `f[2]` returned `s[2]` and not `1`. (And doing it a second time `_[2]` returns `0` since `2` is not a partition and the syntactic sugar rush has ended.) This would be even more so for the above examples.

This is a good chunk of the reason why I am rethinking the behavior of `__getitem__` for all lazy graded algebras. Yes, it is more work to type something like `homogeneous_component`, but at least it is explicit.

> > Somewhat related: There was an agreement to explicitly move away from allowing slices for (univariate) polynomials.
> 
> Yes, I find that this is a very impractical decision for me, because I work a lot with coefficients, and I keep forgetting how to obtain them.  Doing `list(p)[:5]` seems extremely unintuitive for me.

Well, I would probably do `[p[k] for k in range(5)]` if no slicing was supported to not create a longer list than needed. Basically, my understanding of their decision was to not support slicing because there are too many natural things people would want/expect, so now you just have to be explicit about it. I am not sure how much I (currently) agree with their decision, but I can understand a few different logical arguments behind it.

> Remembering stuff is even harder when implementations of basic functions are so different:
> {{{
> sage: R.<s,t> = PowerSeriesRing(ZZ); R
> Multivariate Power Series Ring in s, t over Integer Ring
> sage: f = 1 + t + s + s*t + R.O(3)
> sage: f.coefficients()
> {1: 1, s: 1, t: 1, s*t: 1}
> }}}

Ouch, that is a bit unfortunate. It is generally a good thing to make the API uniform for these things.



---

archive/issue_comments_484952.json:
```json
{
    "body": "OK, we disagree slightly. I guess there is nothing we can do about it, so let it be.\n\nJust a few minor observations:\n\n* Note that currently, `__getitem__` of symmetric functions returns 0 when given an integer.\n\n* For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.\n\n* Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.\n\nIn summary:\n\nThe fundamental problem I see is that there may be ZZ-graded algebras where the index set is a subset of the integers, but the degree is something else.  I agree that this is a problem.  I disagree that this is a problem for symmetric functions.  The current behaviour of `f[i]` for a symmetric function `f` and an integer `i` is even more surprising but nobody has complained about it so far.",
    "created_at": "2022-09-12T18:02:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484952",
    "user": "https://github.com/mantepse"
}
```

OK, we disagree slightly. I guess there is nothing we can do about it, so let it be.

Just a few minor observations:

* Note that currently, `__getitem__` of symmetric functions returns 0 when given an integer.

* For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.

* Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.

In summary:

The fundamental problem I see is that there may be ZZ-graded algebras where the index set is a subset of the integers, but the degree is something else.  I agree that this is a problem.  I disagree that this is a problem for symmetric functions.  The current behaviour of `f[i]` for a symmetric function `f` and an integer `i` is even more surprising but nobody has complained about it so far.



---

archive/issue_comments_484953.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2022-09-12T22:22:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484953",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_484954.json:
```json
{
    "body": "Replying to [comment:13 Martin Rubey]:\n> Just a few minor observations:\n> \n> * Note that currently, `__getitem__` of symmetric functions returns 0 when given an integer.\n\nIndeed, it also returns `0` for things like `x[2,1]` for `x = s[2,1]` because it doesn\u2019t actually convert things to a partition to check it.\n\n> * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.\n\nThat is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).\n\n> * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.\n\nThis is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent )and Dirichlet) series. This would also be consistent with iteration over the elements too.\n\n> In summary:\n> \n> The fundamental problem I see is that there may be ZZ-graded algebras where the index set is a subset of the integers, but the degree is something else.  I agree that this is a problem.  I disagree that this is a problem for symmetric functions.  The current behaviour of `f[i]` for a symmetric function `f` and an integer `i` is even more surprising but nobody has complained about it so far.\n\nIt is initially surprising. Yet, you already have to know it is a way to pull coefficients of an indexed element, which means you should know it is not a partition that you are passing. Thus, with a moment of thought, it is consistent behavior (as the coefficient of the integer `i` is clearly `0`).\n\nI am okay with doing stuff for the lazy series since they are different objects/implementations, but not for classical symmetric functions. It creates too much tension with the `__getitem__` behavior from CFM elements. You would not have `list(x)[i] != x[i]` for instance. There also is an issue for non-graded bases (say, if I implemented dual Grothendieck functions, something I want to do at some point) behaving very differently than the graded ones (a basis need not even be filtered).",
    "created_at": "2022-09-13T00:46:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484954",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:13 Martin Rubey]:
> Just a few minor observations:
> 
> * Note that currently, `__getitem__` of symmetric functions returns 0 when given an integer.

Indeed, it also returns `0` for things like `x[2,1]` for `x = s[2,1]` because it doesn’t actually convert things to a partition to check it.

> * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.

That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).

> * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.

This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent )and Dirichlet) series. This would also be consistent with iteration over the elements too.

> In summary:
> 
> The fundamental problem I see is that there may be ZZ-graded algebras where the index set is a subset of the integers, but the degree is something else.  I agree that this is a problem.  I disagree that this is a problem for symmetric functions.  The current behaviour of `f[i]` for a symmetric function `f` and an integer `i` is even more surprising but nobody has complained about it so far.

It is initially surprising. Yet, you already have to know it is a way to pull coefficients of an indexed element, which means you should know it is not a partition that you are passing. Thus, with a moment of thought, it is consistent behavior (as the coefficient of the integer `i` is clearly `0`).

I am okay with doing stuff for the lazy series since they are different objects/implementations, but not for classical symmetric functions. It creates too much tension with the `__getitem__` behavior from CFM elements. You would not have `list(x)[i] != x[i]` for instance. There also is an issue for non-graded bases (say, if I implemented dual Grothendieck functions, something I want to do at some point) behaving very differently than the graded ones (a basis need not even be filtered).



---

archive/issue_comments_484955.json:
```json
{
    "body": "Replying to [comment:15 Travis Scrimshaw]:\n\n> > * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.\n> \n> That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).\n\nYes, provided that `__getitem__` does not provide this functionality.\n\nLet me stress that for my daily experimental work with sage, aliases are a major problem, because they are listed in the tab completion just as any other method.  They even appear twice in the documentation.  It happens very frequently that I am looking for a particular functionality, and cannot find it, so I page through the tab completion.  As an example, for SymmetricFunctions(QQ).s(), this list has currently 148 elements, even if I remove the underscore methods.\n\n'' (if you happen to know how to make emacs and sage-shell-mode (optionally) omit the underscore methods, please let me know)\n\nAgain, this is a major problem for me.\n\nRelated to this, less severe, is that tab-completion stops working after methods.  So I have to assign names to things, and in the end I am surprised because I accidentally used the same name in a computation for two different things.\n \n> > * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.\n> \n> This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent )and Dirichlet) series. This would also be consistent with iteration over the elements too.\n\nI don't understand your proposal here?  How would `lazy_list(s)` know the valuation?\n\n> There also is an issue for non-graded bases behaving very differently than the graded ones.\n\nHm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.",
    "created_at": "2022-09-13T06:45:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484955",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:15 Travis Scrimshaw]:

> > * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.
> 
> That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).

Yes, provided that `__getitem__` does not provide this functionality.

Let me stress that for my daily experimental work with sage, aliases are a major problem, because they are listed in the tab completion just as any other method.  They even appear twice in the documentation.  It happens very frequently that I am looking for a particular functionality, and cannot find it, so I page through the tab completion.  As an example, for SymmetricFunctions(QQ).s(), this list has currently 148 elements, even if I remove the underscore methods.

'' (if you happen to know how to make emacs and sage-shell-mode (optionally) omit the underscore methods, please let me know)

Again, this is a major problem for me.

Related to this, less severe, is that tab-completion stops working after methods.  So I have to assign names to things, and in the end I am surprised because I accidentally used the same name in a computation for two different things.
 
> > * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.
> 
> This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent )and Dirichlet) series. This would also be consistent with iteration over the elements too.

I don't understand your proposal here?  How would `lazy_list(s)` know the valuation?

> There also is an issue for non-graded bases behaving very differently than the graded ones.

Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.



---

archive/issue_comments_484956.json:
```json
{
    "body": "It is actually a bit strange that we do not include the `x^n` in the `__getitem__` `LazyLaurentSeries`, univariate `LazyPowerSeries` and `LazyDirichletSeries`.\n\nSimilarly,\n\n```\nsage: s = SymmetricFunctions(QQ).s()\nsage: L = LazySymmetricFunctions(s)\nsage: (s[2,1]*s[2,1])[Partition([3,2,1])]\n2\nsage: L(s[2,1]*s[2,1])[Partition([3,2,1])]\nTypeError\n```\n\nis actually quite inconsistent.\n\nSo, how about turning things around and make `__getitem__` consistently pick out a single coefficient (no idea how to do this with multivariate polynomials, though), and improve `restrict_degree` and `homogeneous_parts` to give us the other thing.\n\nOf course, this is a bit impractical, because for univariate power series I am not interested at all in the `x^n`, wheras for multivariate power series, I am only interested in the full graded piece.",
    "created_at": "2022-09-13T06:58:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484956",
    "user": "https://github.com/mantepse"
}
```

It is actually a bit strange that we do not include the `x^n` in the `__getitem__` `LazyLaurentSeries`, univariate `LazyPowerSeries` and `LazyDirichletSeries`.

Similarly,

```
sage: s = SymmetricFunctions(QQ).s()
sage: L = LazySymmetricFunctions(s)
sage: (s[2,1]*s[2,1])[Partition([3,2,1])]
2
sage: L(s[2,1]*s[2,1])[Partition([3,2,1])]
TypeError
```

is actually quite inconsistent.

So, how about turning things around and make `__getitem__` consistently pick out a single coefficient (no idea how to do this with multivariate polynomials, though), and improve `restrict_degree` and `homogeneous_parts` to give us the other thing.

Of course, this is a bit impractical, because for univariate power series I am not interested at all in the `x^n`, wheras for multivariate power series, I am only interested in the full graded piece.



---

archive/issue_comments_484957.json:
```json
{
    "body": "I just realised that I am confusing two different instances of `__getitem__`:\n\n* `SymmetricFunctions(QQ).s().__getitem__`, and\n\n* `SymmetricFunctions(QQ).s().an_element().__getitem__`.\n\nClearly, the first one should only take partitions.\n\nHowever, for the second, it might actually be *more* consistent, to only take integers and slices.",
    "created_at": "2022-09-13T07:12:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484957",
    "user": "https://github.com/mantepse"
}
```

I just realised that I am confusing two different instances of `__getitem__`:

* `SymmetricFunctions(QQ).s().__getitem__`, and

* `SymmetricFunctions(QQ).s().an_element().__getitem__`.

Clearly, the first one should only take partitions.

However, for the second, it might actually be *more* consistent, to only take integers and slices.



---

archive/issue_comments_484958.json:
```json
{
    "body": "Replying to [comment:16 Martin Rubey]:\n> Replying to [comment:15 Travis Scrimshaw]:\n> \n> > > * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.\n> > \n> > That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).\n> \n> Yes, provided that `__getitem__` does not provide this functionality.\n\nThis would be a bad practice. We agree that things in the category should not assume that `__getitem__` is implementing this, right? So if I write generic code at the category level that is using this property of being in the category, I need this method. We cannot remove such an alias (or redirection or code duplication) without breaking that.\n\n> Let me stress that for my daily experimental work with sage, aliases are a major problem, because they are listed in the tab completion just as any other method.  They even appear twice in the documentation.  It happens very frequently that I am looking for a particular functionality, and cannot find it, so I page through the tab completion.  As an example, for SymmetricFunctions(QQ).s(), this list has currently 148 elements, even if I remove the underscore methods.\n\nI agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`). It would be nice to remove the duplicate documentation for aliases, but I don't think sphinx thinks its a priority for them.\n\n> '' (if you happen to know how to make emacs and sage-shell-mode (optionally) omit the underscore methods, please let me know)\n\nUnfortunately I have no idea as I don't use emacs.\n\n> Again, this is a major problem for me.\n\nI don't think there is too much anyone can do about this. It is better to have things discoverable by tab completion, and we want methods that are useful for other people to be included to.\n\n> Related to this, less severe, is that tab-completion stops working after methods.  So I have to assign names to things, and in the end I am surprised because I accidentally used the same name in a computation for two different things.\n\nI don't understand this. Do you mean it does not work for attributes? I have those intermingled in my tab completion lists.\n\n> > > * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.\n> > \n> > This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent (and Dirichlet) series. This would also be consistent with iteration over the elements too.\n> \n> I don't understand your proposal here?  How would `lazy_list(s)` know the valuation?\n\nThey don't, and that is a benefit to me. You don't fall into the pitfalls of the polynomials.\n\n> > There also is an issue for non-graded bases behaving very differently than the graded ones.\n> \n> Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.\n\nI am focusing on just the symmetric function part now. The ring of symmetric functions has a ZZ-grading, but not every basis consists of homogeneous elements (i.e., is naturally ZZ-graded). What should I expect if I use a basis such as `g[la] = s[la] + lower deg terms`? It is a filtered basis of a graded algebra.\n\nIn particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?\n\nNB: Our implementation only works for graded bases.",
    "created_at": "2022-09-13T07:47:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484958",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:16 Martin Rubey]:
> Replying to [comment:15 Travis Scrimshaw]:
> 
> > > * For lazy series, `homogeneous_component` would just be yet another alias for `__getitem__`.
> > 
> > That is fine (and even desirable) since it would make it compatible with other graded algebras (with basis).
> 
> Yes, provided that `__getitem__` does not provide this functionality.

This would be a bad practice. We agree that things in the category should not assume that `__getitem__` is implementing this, right? So if I write generic code at the category level that is using this property of being in the category, I need this method. We cannot remove such an alias (or redirection or code duplication) without breaking that.

> Let me stress that for my daily experimental work with sage, aliases are a major problem, because they are listed in the tab completion just as any other method.  They even appear twice in the documentation.  It happens very frequently that I am looking for a particular functionality, and cannot find it, so I page through the tab completion.  As an example, for SymmetricFunctions(QQ).s(), this list has currently 148 elements, even if I remove the underscore methods.

I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`). It would be nice to remove the duplicate documentation for aliases, but I don't think sphinx thinks its a priority for them.

> '' (if you happen to know how to make emacs and sage-shell-mode (optionally) omit the underscore methods, please let me know)

Unfortunately I have no idea as I don't use emacs.

> Again, this is a major problem for me.

I don't think there is too much anyone can do about this. It is better to have things discoverable by tab completion, and we want methods that are useful for other people to be included to.

> Related to this, less severe, is that tab-completion stops working after methods.  So I have to assign names to things, and in the end I am surprised because I accidentally used the same name in a computation for two different things.

I don't understand this. Do you mean it does not work for attributes? I have those intermingled in my tab completion lists.

> > > * Also, for a lazy series `s` we cannot do `list(s)[a:b:c]`.  For power (Taylor) series, we could in principle do `lazy_list(s)`, once `lazy_list` is imported, but for `LazyLaurentSeries` this does not work, because it would begin with degree 0.
> > 
> > This is a good argument for adding functionality on top of those for the corresponding polynomial ring for at least the lazy Laurent (and Dirichlet) series. This would also be consistent with iteration over the elements too.
> 
> I don't understand your proposal here?  How would `lazy_list(s)` know the valuation?

They don't, and that is a benefit to me. You don't fall into the pitfalls of the polynomials.

> > There also is an issue for non-graded bases behaving very differently than the graded ones.
> 
> Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.

I am focusing on just the symmetric function part now. The ring of symmetric functions has a ZZ-grading, but not every basis consists of homogeneous elements (i.e., is naturally ZZ-graded). What should I expect if I use a basis such as `g[la] = s[la] + lower deg terms`? It is a filtered basis of a graded algebra.

In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?

NB: Our implementation only works for graded bases.



---

archive/issue_comments_484959.json:
```json
{
    "body": "Replying to [comment:19 Travis Scrimshaw]:\n\n> I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`).\n\nI miscommunicated.  My problem is when I actually do not know whether some sort of functionality exists.  For example, I'd like to get all elements of a given degree in a multivariate polynomial.  So I do\n\n```\nsage: R.<x,y,z> = ZZ[]; f = R.an_element(); f.<tab>\n```\n\nNow, emacs offers me 97 methods.  Fortunately, I can search in the list of completions, where I find `degree`, `degrees`, `total_degree`, `weighted_degree`.  Those do not fit.  I also notice `truncate`, `monomials`, and so on.  With a lot of luck I will actually find `homogeneous_components`, buried among the other 96 methods.\n\nI am not saying that this can be made much better easily.  However, I am saying that this can be made much worse, by introducing more aliases.  I am guessing that it would be extremely difficult for emacs to detect whether one method is an alias of another.",
    "created_at": "2022-09-13T08:41:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484959",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:19 Travis Scrimshaw]:

> I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`).

I miscommunicated.  My problem is when I actually do not know whether some sort of functionality exists.  For example, I'd like to get all elements of a given degree in a multivariate polynomial.  So I do

```
sage: R.<x,y,z> = ZZ[]; f = R.an_element(); f.<tab>
```

Now, emacs offers me 97 methods.  Fortunately, I can search in the list of completions, where I find `degree`, `degrees`, `total_degree`, `weighted_degree`.  Those do not fit.  I also notice `truncate`, `monomials`, and so on.  With a lot of luck I will actually find `homogeneous_components`, buried among the other 96 methods.

I am not saying that this can be made much better easily.  However, I am saying that this can be made much worse, by introducing more aliases.  I am guessing that it would be extremely difficult for emacs to detect whether one method is an alias of another.



---

archive/issue_comments_484960.json:
```json
{
    "body": "Replying to [comment:19 Travis Scrimshaw]:\n>\n> > Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.\n> \n> I am focusing on just the symmetric function part now. The ring of symmetric functions has a ZZ-grading, but not every basis consists of homogeneous elements (i.e., is naturally ZZ-graded). What should I expect if I use a basis such as `g[la] = s[la] + lower deg terms`? It is a filtered basis of a graded algebra.\n> \n> In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?\n\nWhy would it be strange for `x[2]` to return `g[1,1] + g[1]`?  \n\n> NB: Our implementation only works for graded bases.\n\nYes, I can think of some places where things might go wrong.  Do you have an example in sage (or is there an easy way to define a basis) such that I can experiment?",
    "created_at": "2022-09-13T09:02:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484960",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:19 Travis Scrimshaw]:
>
> > Hm, I don't see that: my proposal (modulo the fundamental problem of integer indices, which probably kills the proposal anyway) is exclusively for algebras with a ZZ-grading.
> 
> I am focusing on just the symmetric function part now. The ring of symmetric functions has a ZZ-grading, but not every basis consists of homogeneous elements (i.e., is naturally ZZ-graded). What should I expect if I use a basis such as `g[la] = s[la] + lower deg terms`? It is a filtered basis of a graded algebra.
> 
> In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?

Why would it be strange for `x[2]` to return `g[1,1] + g[1]`?  

> NB: Our implementation only works for graded bases.

Yes, I can think of some places where things might go wrong.  Do you have an example in sage (or is there an easy way to define a basis) such that I can experiment?



---

archive/issue_comments_484961.json:
```json
{
    "body": "Answering my own question:\n\n```\nsage: ht = SymmetricFunctions(QQ).ht()\nsage: s = SymmetricFunctions(QQ).s()\nsage: s(ht[2])\n-s[1] + s[2]\n```\n\nis a basis which is not homogeneous.  I am guessing that there is some trouble here:\n\n```\nsage: ht[2].homogeneous_degree()\n2\nsage: s(ht[2]).homogeneous_degree()\nValueError\nsage: (ht[1] + ht[2]).homogeneous_degree()\nValueError\nsage: s(ht[1] + ht[2]).homogeneous_degree()\n2\n```\n",
    "created_at": "2022-09-13T11:04:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484961",
    "user": "https://github.com/mantepse"
}
```

Answering my own question:

```
sage: ht = SymmetricFunctions(QQ).ht()
sage: s = SymmetricFunctions(QQ).s()
sage: s(ht[2])
-s[1] + s[2]
```

is a basis which is not homogeneous.  I am guessing that there is some trouble here:

```
sage: ht[2].homogeneous_degree()
2
sage: s(ht[2]).homogeneous_degree()
ValueError
sage: (ht[1] + ht[2]).homogeneous_degree()
ValueError
sage: s(ht[1] + ht[2]).homogeneous_degree()
2
```




---

archive/issue_comments_484962.json:
```json
{
    "body": "Replying to [comment:20 Martin Rubey]:\n> Replying to [comment:19 Travis Scrimshaw]:\n> \n> > I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`).\n> \n> I miscommunicated.  My problem is when I actually do not know whether some sort of functionality exists.  For example, I'd like to get all elements of a given degree in a multivariate polynomial.  So I do\n> {{{\n> sage: R.<x,y,z> = ZZ[]; f = R.an_element(); f.<tab>\n> }}}\n> Now, emacs offers me 97 methods.  Fortunately, I can search in the list of completions, where I find `degree`, `degrees`, `total_degree`, `weighted_degree`.  Those do not fit.  I also notice `truncate`, `monomials`, and so on.  With a lot of luck I will actually find `homogeneous_components`, buried among the other 96 methods.\n\nI see. We might need some better class-level documentation or more tutorials. If I couldn\u2019t immediately find it by tab completion, I might then go to the doc for the class and skim through its methods, and then up through the categories. Although I think I quickly realize certain large chunks of the tab completion available methods can be ignored because I know they are not what I want.\n\n> I am not saying that this can be made much better easily.  However, I am saying that this can be made much worse, by introducing more aliases.  I am guessing that it would be extremely difficult for emacs to detect whether one method is an alias of another.\n\nIndeed, we should be careful to not overpopulate any namespace. Yet, we generally cannot keep it so small.\n\nDetecting when a method is an alias of another is easy I think, just check the address of the method:\n\n```\nsage: class Foo:\n....:     def bar(x):\n....:         return x + 5\n....:     baz = bar\n\nsage: Foo.bar is Foo.baz\nTrue\n```\n\nHowever, the question is which one to keep. The alias sometimes can be the one you will actually recognize (e.g., same function but different names coming from different fields).",
    "created_at": "2022-09-13T11:57:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484962",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:20 Martin Rubey]:
> Replying to [comment:19 Travis Scrimshaw]:
> 
> > I agree that such pollution can be difficult at times. I usually know possible first letters, so that significantly narrows down my search (e.g., doing `s.e<tab>`).
> 
> I miscommunicated.  My problem is when I actually do not know whether some sort of functionality exists.  For example, I'd like to get all elements of a given degree in a multivariate polynomial.  So I do
> {{{
> sage: R.<x,y,z> = ZZ[]; f = R.an_element(); f.<tab>
> }}}
> Now, emacs offers me 97 methods.  Fortunately, I can search in the list of completions, where I find `degree`, `degrees`, `total_degree`, `weighted_degree`.  Those do not fit.  I also notice `truncate`, `monomials`, and so on.  With a lot of luck I will actually find `homogeneous_components`, buried among the other 96 methods.

I see. We might need some better class-level documentation or more tutorials. If I couldn’t immediately find it by tab completion, I might then go to the doc for the class and skim through its methods, and then up through the categories. Although I think I quickly realize certain large chunks of the tab completion available methods can be ignored because I know they are not what I want.

> I am not saying that this can be made much better easily.  However, I am saying that this can be made much worse, by introducing more aliases.  I am guessing that it would be extremely difficult for emacs to detect whether one method is an alias of another.

Indeed, we should be careful to not overpopulate any namespace. Yet, we generally cannot keep it so small.

Detecting when a method is an alias of another is easy I think, just check the address of the method:

```
sage: class Foo:
....:     def bar(x):
....:         return x + 5
....:     baz = bar

sage: Foo.bar is Foo.baz
True
```

However, the question is which one to keep. The alias sometimes can be the one you will actually recognize (e.g., same function but different names coming from different fields).



---

archive/issue_comments_484963.json:
```json
{
    "body": "Replying to [comment:21 Martin Rubey]:\n> Replying to [comment:19 Travis Scrimshaw]:\n> > In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?\n> \n> Why would it be strange for `x[2]` to return `g[1,1] + g[1]`?  \n\nIt is returning something that is not obviously homogeneous, and you get more terms than before. I guess for filtered algebras you can make it be \u201cup to degree i,\u201d which is how we define degree for filtered: the smallest filtered piece something belongs to. Although using that, slices do not make sense.",
    "created_at": "2022-09-13T12:04:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484963",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:21 Martin Rubey]:
> Replying to [comment:19 Travis Scrimshaw]:
> > In particular, consider `g[i] = s[i]` for all positive integers `i` and `g[1,1] = s[1,1] - s[1]`. Then if `x = g[1,1]`, then the degree 2 homogeneous component of `x` would be `g[1,1] + g[1]`, which would be really strange for `x[2]`. If `x[2] == g[1,1]`, then this would not be compatible with switching to the Schur basis. Or would it simply return `0`? Or raise an error?
> 
> Why would it be strange for `x[2]` to return `g[1,1] + g[1]`?  

It is returning something that is not obviously homogeneous, and you get more terms than before. I guess for filtered algebras you can make it be “up to degree i,” which is how we define degree for filtered: the smallest filtered piece something belongs to. Although using that, slices do not make sense.



---

archive/issue_comments_484964.json:
```json
{
    "body": "Yes.  I was just about to send the following, before you answered :-)\n\nApparently, I misunderstood the notion of homogeneous component in a filtered algebra, at least if I follow `FilteredModulesWithBasis`.  In your example, `g[1,1] + g[1]` would **not** be considered homogeneous.  In fact, right now it seems to me that it is not possible to define \"homogeneous element\" other than depending on a basis.",
    "created_at": "2022-09-13T12:13:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484964",
    "user": "https://github.com/mantepse"
}
```

Yes.  I was just about to send the following, before you answered :-)

Apparently, I misunderstood the notion of homogeneous component in a filtered algebra, at least if I follow `FilteredModulesWithBasis`.  In your example, `g[1,1] + g[1]` would **not** be considered homogeneous.  In fact, right now it seems to me that it is not possible to define "homogeneous element" other than depending on a basis.



---

archive/issue_comments_484965.json:
```json
{
    "body": "sorry, I meant \"homogeneous component\", not \"homogeneous element\".",
    "created_at": "2022-09-13T12:21:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484965",
    "user": "https://github.com/mantepse"
}
```

sorry, I meant "homogeneous component", not "homogeneous element".



---

archive/issue_comments_484966.json:
```json
{
    "body": "It is perhaps slightly non-standard notion of degree and homogeneous, but we wanted to make filtered and graded stuff behave somewhat uniformly/consistently.",
    "created_at": "2022-09-13T12:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484966",
    "user": "https://github.com/tscrim"
}
```

It is perhaps slightly non-standard notion of degree and homogeneous, but we wanted to make filtered and graded stuff behave somewhat uniformly/consistently.



---

archive/issue_comments_484967.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2022-09-16T10:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484967",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_484968.json:
```json
{
    "body": "I just noticed that it would be great to absorb the two `check` functions in the `TESTS` section, line 103ff of `lazy_ring.py` into the `TestSuite` framework, but I do not know how to do this.\n\n\n```\nsage: L = LazyPowerSeriesRing(ZZ, 't, s')\nsage: L.some_elements()\n[1 + 1 + 1 + 1 + O(t,s)^5]\n```\n\nis a bad bug.  Most of the `some_elements` methods return a very poor selection.\n\n\n```\nsage: LazyDirichletSeriesRing(ZZ, 't, s')\nLazy Dirichlet Series Ring in t over Integer Ring\n```\n\nis a bit surprising.",
    "created_at": "2022-09-16T10:26:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484968",
    "user": "https://github.com/mantepse"
}
```

I just noticed that it would be great to absorb the two `check` functions in the `TESTS` section, line 103ff of `lazy_ring.py` into the `TestSuite` framework, but I do not know how to do this.


```
sage: L = LazyPowerSeriesRing(ZZ, 't, s')
sage: L.some_elements()
[1 + 1 + 1 + 1 + O(t,s)^5]
```

is a bad bug.  Most of the `some_elements` methods return a very poor selection.


```
sage: LazyDirichletSeriesRing(ZZ, 't, s')
Lazy Dirichlet Series Ring in t over Integer Ring
```

is a bit surprising.



---

archive/issue_comments_484969.json:
```json
{
    "body": "I will respond in more detail and to the other ticket when I get back after dinner.\n\nTo add to the `TestSuite`, you just need to name a function `_test_foo`.\n\nThe result of `some_elements()` generally needs a bit of human intervention.",
    "created_at": "2022-09-16T10:29:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484969",
    "user": "https://github.com/tscrim"
}
```

I will respond in more detail and to the other ticket when I get back after dinner.

To add to the `TestSuite`, you just need to name a function `_test_foo`.

The result of `some_elements()` generally needs a bit of human intervention.



---

archive/issue_comments_484970.json:
```json
{
    "body": "Just let me know what I should implement, so we don't tread on each others toes.",
    "created_at": "2022-09-16T10:41:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484970",
    "user": "https://github.com/mantepse"
}
```

Just let me know what I should implement, so we don't tread on each others toes.



---

archive/issue_comments_484971.json:
```json
{
    "body": "I spent basically no time doing what I did. Feel free to go ahead and do what you want/need to do. I can just cherry-pick stuff as necessary.\n\nBTW - the controversial stuff here is the UFD category part.",
    "created_at": "2022-09-16T10:54:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484971",
    "user": "https://github.com/tscrim"
}
```

I spent basically no time doing what I did. Feel free to go ahead and do what you want/need to do. I can just cherry-pick stuff as necessary.

BTW - the controversial stuff here is the UFD category part.



---

archive/issue_comments_484972.json:
```json
{
    "body": "OK, I am going to spend one more afternoon on this.  I'll try to put everything in different commits as much as seems reasonable.  It would be great however, if you could point out which patchbot was failing on #32367.",
    "created_at": "2022-09-16T13:10:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484972",
    "user": "https://github.com/mantepse"
}
```

OK, I am going to spend one more afternoon on this.  I'll try to put everything in different commits as much as seems reasonable.  It would be great however, if you could point out which patchbot was failing on #32367.



---

archive/issue_comments_484973.json:
```json
{
    "body": "Replying to [comment:33 Martin Rubey]:\n> OK, I am going to spend one more afternoon on this.  I'll try to put everything in different commits as much as seems reasonable.  It would be great however, if you could point out which patchbot was failing on #32367.\n\nI just did a moment ago. I also pushed my changes and cherry-picked the `_im_gens_` there too.",
    "created_at": "2022-09-16T13:18:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484973",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:33 Martin Rubey]:
> OK, I am going to spend one more afternoon on this.  I'll try to put everything in different commits as much as seems reasonable.  It would be great however, if you could point out which patchbot was failing on #32367.

I just did a moment ago. I also pushed my changes and cherry-picked the `_im_gens_` there too.



---

archive/issue_comments_484974.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-16T14:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484974",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484975.json:
```json
{
    "body": "Hurray, I actually found a real bug in the comparison of 'exact' series :-)",
    "created_at": "2022-09-16T14:56:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484975",
    "user": "https://github.com/mantepse"
}
```

Hurray, I actually found a real bug in the comparison of 'exact' series :-)



---

archive/issue_comments_484976.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-16T16:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484976",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484977.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-16T20:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484977",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484978.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-16T20:42:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484978",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484979.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-16T20:56:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484979",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484980.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-09-16T20:57:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484980",
    "user": "https://github.com/mantepse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_484981.json:
```json
{
    "body": "Good catch. Although I am wondering how much more complicated equality becomes if we do not insist. I will try to take a look today, and if not, then tomorrow.\n\nAlso\n\n```diff\n-        TESTS:\n+        TESTS::\n \n             sage: L.<t> = LazyPowerSeriesRing(QQ)\n```\n",
    "created_at": "2022-09-16T23:35:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484981",
    "user": "https://github.com/tscrim"
}
```

Good catch. Although I am wondering how much more complicated equality becomes if we do not insist. I will try to take a look today, and if not, then tomorrow.

Also

```diff
-        TESTS:
+        TESTS::
 
             sage: L.<t> = LazyPowerSeriesRing(QQ)
```




---

archive/issue_comments_484982.json:
```json
{
    "body": "I actually think now that it is better this way. We probably don't gain anything by postponing. In any case it is premature optimization.",
    "created_at": "2022-09-17T06:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484982",
    "user": "https://github.com/mantepse"
}
```

I actually think now that it is better this way. We probably don't gain anything by postponing. In any case it is premature optimization.



---

archive/issue_comments_484983.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-17T08:06:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484983",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484984.json:
```json
{
    "body": "Some more low-hanging fruits, possibly for other tickets:\n\n* move the two checks in the global `TESTS:` section of `lazy_series.py` to the `TestSuite` framework.  The padics people have some very nice tests, by the way.  I wonder why there is no generic test of division in the category framework, or did I overlook it?  Possibly related: #17965\n\n* implement `some_elements` for the graded completion, and think of better `_an_element` and `some_elements` in general. Currently, most examples are 'exact'.  Why is `an_element` of `ZZ` just `1`, the is not a very typical element.\n\n* Stream_cauchy_compose and Stream_plethysm have some similarities, maybe we can make them more obvious.\n\n* there are some non-lazy sums of the form `sum(a[i]*b[i] for i in ...)` in `stream.py`. These should possibly be replaced by something like\n   {{{\n   s = zero\n   for i in ...:\n       left = a[i]\n       if left:\n           s += left * b[i]\n   }}}\n   (not only for performance, but also we should not evaluate `b[i]` when we shouldn't, even if this makes the sum asymmetric).  This should be a helper function\n\n* the testsuites now give us a very rough performance measure, maybe we can exploit that\n\n* I vaguely remember that somewhere in `lazy_series.py` I had to be careful when trying to detect a geometric series.  This should be easier now.",
    "created_at": "2022-09-17T08:39:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484984",
    "user": "https://github.com/mantepse"
}
```

Some more low-hanging fruits, possibly for other tickets:

* move the two checks in the global `TESTS:` section of `lazy_series.py` to the `TestSuite` framework.  The padics people have some very nice tests, by the way.  I wonder why there is no generic test of division in the category framework, or did I overlook it?  Possibly related: #17965

* implement `some_elements` for the graded completion, and think of better `_an_element` and `some_elements` in general. Currently, most examples are 'exact'.  Why is `an_element` of `ZZ` just `1`, the is not a very typical element.

* Stream_cauchy_compose and Stream_plethysm have some similarities, maybe we can make them more obvious.

* there are some non-lazy sums of the form `sum(a[i]*b[i] for i in ...)` in `stream.py`. These should possibly be replaced by something like
   {{{
   s = zero
   for i in ...:
       left = a[i]
       if left:
           s += left * b[i]
   }}}
   (not only for performance, but also we should not evaluate `b[i]` when we shouldn't, even if this makes the sum asymmetric).  This should be a helper function

* the testsuites now give us a very rough performance measure, maybe we can exploit that

* I vaguely remember that somewhere in `lazy_series.py` I had to be careful when trying to detect a geometric series.  This should be easier now.



---

archive/issue_comments_484985.json:
```json
{
    "body": "I just noticed in `discrete_valuation.py`\n\n```\n    def super_categories(self):\n        \"\"\"\n        EXAMPLES::\n\n            sage: DiscreteValuationRings().super_categories()\n            [Category of euclidean domains]\n        \"\"\"\n        return [EuclideanDomains()]\n```\n\nshouldn't that be `PrincipalIdealDomains()`, according to https://en.wikipedia.org/wiki/Discrete_valuation_ring?",
    "created_at": "2022-09-17T10:33:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484985",
    "user": "https://github.com/mantepse"
}
```

I just noticed in `discrete_valuation.py`

```
    def super_categories(self):
        """
        EXAMPLES::

            sage: DiscreteValuationRings().super_categories()
            [Category of euclidean domains]
        """
        return [EuclideanDomains()]
```

shouldn't that be `PrincipalIdealDomains()`, according to https://en.wikipedia.org/wiki/Discrete_valuation_ring?



---

archive/issue_comments_484986.json:
```json
{
    "body": "Replying to [comment:43 Martin Rubey]:\n> I actually think now that it is better this way. We probably don't gain anything by postponing. In any case it is premature optimization.\n\n+1 It is an implementation detail that we can easily change later on.",
    "created_at": "2022-09-17T10:59:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484986",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:43 Martin Rubey]:
> I actually think now that it is better this way. We probably don't gain anything by postponing. In any case it is premature optimization.

+1 It is an implementation detail that we can easily change later on.



---

archive/issue_comments_484987.json:
```json
{
    "body": "Replying to [comment:45 Martin Rubey]:\n> Some more low-hanging fruits, possibly for other tickets:\n> \n> * move the two checks in the global `TESTS:` section of `lazy_series.py` to the `TestSuite` framework.  The padics people have some very nice tests, by the way.  I wonder why there is no generic test of division in the category framework, or did I overlook it?  Possibly related: #17965\n\nDivision is not guaranteed except in `Fields`, so it doesn\u2019t make sense to test it in any more general category. However, I don\u2019t think there are any such tests.\n\n> * implement `some_elements` for the graded completion, and think of better `_an_element` and `some_elements` in general. Currently, most examples are 'exact'.  Why is `an_element` of `ZZ` just `1`, the is not a very typical element.\n\nThe result of `an_element()` doesn\u2019t need to be so generic. Beyond an example, it is used by the coercion framework for setting things up via the generic coercion map using `_element_constructor_`.\n\n> * Stream_cauchy_compose and Stream_plethysm have some similarities, maybe we can make them more obvious.\n\n+1 Probably good place for subclassing.\n\n> * there are some non-lazy sums of the form `sum(a[i]*b[i] for i in ...)` in `stream.py`. These should possibly be replaced by something like\n>    {{{\n>    s = zero\n>    for i in ...:\n>        left = a[i]\n>        if left:\n>            s += left * b[i]\n>    }}}\n>    (not only for performance, but also we should not evaluate `b[i]` when we shouldn't, even if this makes the sum asymmetric).  This should be a helper function\n\nSounds good overall. I might need to see details before a final verdict, but I think it should be good.\n\n> * the testsuites now give us a very rough performance measure, maybe we can exploit that\n\nIndeed.\n\n> * I vaguely remember that somewhere in `lazy_series.py` I had to be careful when trying to detect a geometric series.  This should be easier now.\n\nGreat! I think this was with exact series in some way. I don\u2019t remember exactly, but I also recall something like that.",
    "created_at": "2022-09-17T11:02:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484987",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:45 Martin Rubey]:
> Some more low-hanging fruits, possibly for other tickets:
> 
> * move the two checks in the global `TESTS:` section of `lazy_series.py` to the `TestSuite` framework.  The padics people have some very nice tests, by the way.  I wonder why there is no generic test of division in the category framework, or did I overlook it?  Possibly related: #17965

Division is not guaranteed except in `Fields`, so it doesn’t make sense to test it in any more general category. However, I don’t think there are any such tests.

> * implement `some_elements` for the graded completion, and think of better `_an_element` and `some_elements` in general. Currently, most examples are 'exact'.  Why is `an_element` of `ZZ` just `1`, the is not a very typical element.

The result of `an_element()` doesn’t need to be so generic. Beyond an example, it is used by the coercion framework for setting things up via the generic coercion map using `_element_constructor_`.

> * Stream_cauchy_compose and Stream_plethysm have some similarities, maybe we can make them more obvious.

+1 Probably good place for subclassing.

> * there are some non-lazy sums of the form `sum(a[i]*b[i] for i in ...)` in `stream.py`. These should possibly be replaced by something like
>    {{{
>    s = zero
>    for i in ...:
>        left = a[i]
>        if left:
>            s += left * b[i]
>    }}}
>    (not only for performance, but also we should not evaluate `b[i]` when we shouldn't, even if this makes the sum asymmetric).  This should be a helper function

Sounds good overall. I might need to see details before a final verdict, but I think it should be good.

> * the testsuites now give us a very rough performance measure, maybe we can exploit that

Indeed.

> * I vaguely remember that somewhere in `lazy_series.py` I had to be careful when trying to detect a geometric series.  This should be easier now.

Great! I think this was with exact series in some way. I don’t remember exactly, but I also recall something like that.



---

archive/issue_comments_484988.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-17T11:49:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484988",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484989.json:
```json
{
    "body": "I did a few more corrections (in fact, I overlooked the wrong _an_element in my previous commit).\n\nUnfortunately, I really should stop now.\n\nIf there is anything which absolutely needs to be done for positive review, please let me know. Otherwise, I'd like to move the remaining stuff into new tickets.",
    "created_at": "2022-09-17T11:51:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484989",
    "user": "https://github.com/mantepse"
}
```

I did a few more corrections (in fact, I overlooked the wrong _an_element in my previous commit).

Unfortunately, I really should stop now.

If there is anything which absolutely needs to be done for positive review, please let me know. Otherwise, I'd like to move the remaining stuff into new tickets.



---

archive/issue_comments_484990.json:
```json
{
    "body": "One thing I would really like to see is an attempt to make a positive valuation element for `some_elements` of the `LazyCompletionGradedAlgebra`:\n\n```python\nit = iter(self._laurent_poly_ring.basis())\nextra_elt = sum(b for _ in range(4) if (b := next(it)).degree())\nif extra_elt:\n    elts.append(extra_elt)\n```\n\nOf course, if the graded algebra is \"trivial\" with everything in degree 0, this won't get anything (or if the first few basis elements are all degree 0). So we just need to protect against that.\n\nOther than that, I think we should bring this these into UFDs where appropriate. That way we signal the correct mathematical information, and the functions that want the constructive behavior will fail with either an `AttributeError` or a `NotImplementedError`.\n\nActually, FPS in a single variable are a Euclidean domain (see [this MSE post](https://math.stackexchange.com/questions/3911013/show-that-the-ring-of-formal-power-series-is-a-euclidean-domain)): The Euclidean algorithm uses the valuation and works as follows:\n\nFor f(x) / g(x), we want to consider f(x) = q(x) g(x) + r(x). Define F(x) by x<sup>val(f)</sup> F(x) = f(x) and similarly G(x) using g(x). This breaks up into 2 cases:\n\n1. If val(f) >= val(g), we have f(x) / g(x) = x^val(f) - val(g)^ F(x) / G(x).\n2. If val(f) < val(g), then we have q(x) = 0 and r(x) = f(x). Then we proceed with the Euclidean algorithm.\n\nFor this implementation, we can simply in the `__init__` make `self.euclidean_degree = self.valuation`. This would also become a simple `quo_rem` function.\n\nFurthermore, this gives me an idea for doing the GCD. Let f(X) = d<sub>f</sub>(X) F(X), where F(X) is a unit and d<sub>f</sub>(X) is the lowest degree portion of f(X); similarly for g(X). Then, we have\n\ngcd(f(X), g(X)) = gcd(d<sub>f</sub>(X)F(X), d<sub>g</sub>(X)G(X)) = gcd(d<sub>f</sub>(X), d<sub>g</sub>(X))\n\nThis would then be very easy to implement. I can do this tomorrow if you don't want to do it.\n\nOnce we do this, this we achieve the actual stated goal of the ticket. `:P`",
    "created_at": "2022-09-17T14:53:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484990",
    "user": "https://github.com/tscrim"
}
```

One thing I would really like to see is an attempt to make a positive valuation element for `some_elements` of the `LazyCompletionGradedAlgebra`:

```python
it = iter(self._laurent_poly_ring.basis())
extra_elt = sum(b for _ in range(4) if (b := next(it)).degree())
if extra_elt:
    elts.append(extra_elt)
```

Of course, if the graded algebra is "trivial" with everything in degree 0, this won't get anything (or if the first few basis elements are all degree 0). So we just need to protect against that.

Other than that, I think we should bring this these into UFDs where appropriate. That way we signal the correct mathematical information, and the functions that want the constructive behavior will fail with either an `AttributeError` or a `NotImplementedError`.

Actually, FPS in a single variable are a Euclidean domain (see [this MSE post](https://math.stackexchange.com/questions/3911013/show-that-the-ring-of-formal-power-series-is-a-euclidean-domain)): The Euclidean algorithm uses the valuation and works as follows:

For f(x) / g(x), we want to consider f(x) = q(x) g(x) + r(x). Define F(x) by x<sup>val(f)</sup> F(x) = f(x) and similarly G(x) using g(x). This breaks up into 2 cases:

1. If val(f) >= val(g), we have f(x) / g(x) = x^val(f) - val(g)^ F(x) / G(x).
2. If val(f) < val(g), then we have q(x) = 0 and r(x) = f(x). Then we proceed with the Euclidean algorithm.

For this implementation, we can simply in the `__init__` make `self.euclidean_degree = self.valuation`. This would also become a simple `quo_rem` function.

Furthermore, this gives me an idea for doing the GCD. Let f(X) = d<sub>f</sub>(X) F(X), where F(X) is a unit and d<sub>f</sub>(X) is the lowest degree portion of f(X); similarly for g(X). Then, we have

gcd(f(X), g(X)) = gcd(d<sub>f</sub>(X)F(X), d<sub>g</sub>(X)G(X)) = gcd(d<sub>f</sub>(X), d<sub>g</sub>(X))

This would then be very easy to implement. I can do this tomorrow if you don't want to do it.

Once we do this, this we achieve the actual stated goal of the ticket. `:P`



---

archive/issue_comments_484991.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-17T15:01:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484991",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484992.json:
```json
{
    "body": "funniest bug ever :-)",
    "created_at": "2022-09-17T15:01:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484992",
    "user": "https://github.com/mantepse"
}
```

funniest bug ever :-)



---

archive/issue_comments_484993.json:
```json
{
    "body": "The following would make our test suite run *much* faster.\n\n```\ndiff --git a/src/sage/libs/lrcalc/lrcalc.py b/src/sage/libs/lrcalc/lrcalc.py\nindex b541bfacd89..1bfaba4ec14 100644\n--- a/src/sage/libs/lrcalc/lrcalc.py\n+++ b/src/sage/libs/lrcalc/lrcalc.py\n@@ -202,7 +202,7 @@ def _lrcalc_dict_to_sage(result):\n         sage: mult([2,1],[3,2,1],3) # indirect doctest\n         {[3, 3, 3]: 1, [4, 3, 2]: 2, [4, 4, 1]: 1, [5, 2, 2]: 1, [5, 3, 1]: 1}\n     \"\"\"\n-    return {_Partitions(la): Integer(k) for la, k in result.items()}\n+    return {_Partitions.element_class(_Partitions, la): Integer(k) for la, k in result.items()}\n \n def lrcoef_unsafe(outer, inner1, inner2):\n     r\"\"\"\n```\n",
    "created_at": "2022-09-17T15:02:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484993",
    "user": "https://github.com/mantepse"
}
```

The following would make our test suite run *much* faster.

```
diff --git a/src/sage/libs/lrcalc/lrcalc.py b/src/sage/libs/lrcalc/lrcalc.py
index b541bfacd89..1bfaba4ec14 100644
--- a/src/sage/libs/lrcalc/lrcalc.py
+++ b/src/sage/libs/lrcalc/lrcalc.py
@@ -202,7 +202,7 @@ def _lrcalc_dict_to_sage(result):
         sage: mult([2,1],[3,2,1],3) # indirect doctest
         {[3, 3, 3]: 1, [4, 3, 2]: 2, [4, 4, 1]: 1, [5, 2, 2]: 1, [5, 3, 1]: 1}
     """
-    return {_Partitions(la): Integer(k) for la, k in result.items()}
+    return {_Partitions.element_class(_Partitions, la): Integer(k) for la, k in result.items()}
 
 def lrcoef_unsafe(outer, inner1, inner2):
     r"""
```




---

archive/issue_comments_484994.json:
```json
{
    "body": "Indeed, and much better `is_unit` tests. `:)`\n\n+1 for comment:54; this avoids some checks IIRC.\n\nI am not sure for comment:46 in light of comment:51. I am not immediately sure if the valuation always defines a Euclidean function, but I am thinking it does. Although we might not be able to do a generic implementation as everything depends on `quo_rem` and there might be other (and better) Euclidean functions.",
    "created_at": "2022-09-17T15:08:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484994",
    "user": "https://github.com/tscrim"
}
```

Indeed, and much better `is_unit` tests. `:)`

+1 for comment:54; this avoids some checks IIRC.

I am not sure for comment:46 in light of comment:51. I am not immediately sure if the valuation always defines a Euclidean function, but I am thinking it does. Although we might not be able to do a generic implementation as everything depends on `quo_rem` and there might be other (and better) Euclidean functions.



---

archive/issue_comments_484995.json:
```json
{
    "body": "See #34549 for lrcalc.",
    "created_at": "2022-09-17T15:22:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484995",
    "user": "https://github.com/mantepse"
}
```

See #34549 for lrcalc.



---

archive/issue_comments_484996.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-17T21:10:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484996",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_484997.json:
```json
{
    "body": "Thanks.\n\nUnfortunately what I said about the gcd proof is false. We cannot simply factor out the lowest term like that. Consider `f(x,y) = x + y + HOT`, but we can only span a 2 dimensional subspace of `span{x^2, xy, y^2}` for any given unit. This discrepancy only gets worse for higher degrees. Thus, there exists elements in R[This is the Trac macro *x,y* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x,y-macro) / U, where U is the group of units, whose representatives are always infinite sums.\n\nWe might be able to do something using something in [this article](https://www.sciencedirect.com/science/article/pii/S0747717108801058), but it seems a bit involved.\n\nPerhaps it is best to leave the UFD separate for now.",
    "created_at": "2022-09-18T00:56:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484997",
    "user": "https://github.com/tscrim"
}
```

Thanks.

Unfortunately what I said about the gcd proof is false. We cannot simply factor out the lowest term like that. Consider `f(x,y) = x + y + HOT`, but we can only span a 2 dimensional subspace of `span{x^2, xy, y^2}` for any given unit. This discrepancy only gets worse for higher degrees. Thus, there exists elements in R[This is the Trac macro *x,y* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x,y-macro) / U, where U is the group of units, whose representatives are always infinite sums.

We might be able to do something using something in [this article](https://www.sciencedirect.com/science/article/pii/S0747717108801058), but it seems a bit involved.

Perhaps it is best to leave the UFD separate for now.



---

archive/issue_comments_484998.json:
```json
{
    "body": "Yes, please!  I'd really like to have factorization, but more than that I'd like to have the current branch in develop.\n\nI tried to find some facts concerning formal Dirichlet series.  What I found would be the diff below.  However, I do not want to hold up this ticket any longer.  So I'd rather include it in a later ticket.  I suggest that we document your findings there, also.\n\n\n```diff\ndiff --git a/src/sage/rings/lazy_series_ring.py b/src/sage/rings/lazy_series_ring.py\nindex ca2ccf29f2c..a3dcd136aa2 100644\n--- a/src/sage/rings/lazy_series_ring.py\n+++ b/src/sage/rings/lazy_series_ring.py\n@@ -763,7 +763,8 @@ class LazySeriesRing(UniqueRepresentation, Parent):\n \n         EXAMPLES::\n \n-            sage: Zp(3)._test_invert()\n+            sage: L = LazyLaurentSeriesRing(QQ, 'z')\n+            sage: L._test_invert()\n \n         .. SEEALSO::\n \n@@ -2175,7 +2176,7 @@ class LazyDirichletSeriesRing(LazySeriesRing):\n     Element = LazyDirichletSeries\n \n     def __init__(self, base_ring, names, sparse=True, category=None):\n-        \"\"\"\n+        r\"\"\"\n         Initialize the ring.\n \n         TESTS::\n@@ -2198,14 +2199,45 @@ class LazyDirichletSeriesRing(LazySeriesRing):\n             sage: L in PrincipalIdealDomains\n             False\n \n-        In particular, it is not a :wikipedia:`discrete_valuation_ring`.\n+        In particular, it is not a\n+        :wikipedia:`discrete_valuation_ring`.  On the other hand, it\n+        is a :wikipedia:`local_ring`.  The unique maximal ideal\n+        consists of all non-invertible series, i.e., series with\n+        vanishing constant term.\n \n         .. TODO::\n \n             According to the answers in\n             https://mathoverflow.net/questions/5522/dirichlet-series-with-integer-coefficients-as-a-ufd,\n             the ring of formal Dirichlet series is actually a\n-            UniqueFactorizationDomain.\n+            :wikipedia:`Unique_factorization_domain`.\n+\n+        .. NOTE::\n+\n+            An interesting valuation is described in Emil Daniel\n+            Schwab; Gheorghe Silberberg A note on some discrete\n+            valuation rings of arithmetical functions Archivum\n+            Mathematicum, Vol. 36 (2000), No. 2, 103--109,\n+            http://dml.cz/dmlcz/107723.  Let `J_k` be the ideal of\n+            Dirichlet series whose coefficient `f[n]` of `n^s`\n+            vanishes if `n` has less than `k` prime factors, counting\n+            multiplicities.  For any Dirichlet series `f`, let `D(f)`\n+            be the largest integer `k` such that `f` is in `J_k`.\n+            Then `D` is surjective, `D(f g) = D(f) + D(g)` for\n+            nonzero `f` and `g`, and `D(f + g) \\geq \\min(D(f), D(g))`\n+            provided that `f + g` is nonzero.\n+\n+            For example, `J_1` are series with no constant term, and\n+            `J_2` are series such that `f[1]` and `f[p]` for prime\n+            `p` vanish.\n+\n+            Since this is a chain of increasing ideals, the ring of\n+            formal Dirichlet series is not a\n+            :wikipedia:`Noetherian_ring`.\n+\n+            Evidently, this valuation cannot be computed for a given\n+            series.\n+\n         \"\"\"\n         if base_ring.characteristic() > 0:\n             raise ValueError(\"positive characteristic not allowed for Dirichlet series\")\n```\n",
    "created_at": "2022-09-18T08:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484998",
    "user": "https://github.com/mantepse"
}
```

Yes, please!  I'd really like to have factorization, but more than that I'd like to have the current branch in develop.

I tried to find some facts concerning formal Dirichlet series.  What I found would be the diff below.  However, I do not want to hold up this ticket any longer.  So I'd rather include it in a later ticket.  I suggest that we document your findings there, also.


```diff
diff --git a/src/sage/rings/lazy_series_ring.py b/src/sage/rings/lazy_series_ring.py
index ca2ccf29f2c..a3dcd136aa2 100644
--- a/src/sage/rings/lazy_series_ring.py
+++ b/src/sage/rings/lazy_series_ring.py
@@ -763,7 +763,8 @@ class LazySeriesRing(UniqueRepresentation, Parent):
 
         EXAMPLES::
 
-            sage: Zp(3)._test_invert()
+            sage: L = LazyLaurentSeriesRing(QQ, 'z')
+            sage: L._test_invert()
 
         .. SEEALSO::
 
@@ -2175,7 +2176,7 @@ class LazyDirichletSeriesRing(LazySeriesRing):
     Element = LazyDirichletSeries
 
     def __init__(self, base_ring, names, sparse=True, category=None):
-        """
+        r"""
         Initialize the ring.
 
         TESTS::
@@ -2198,14 +2199,45 @@ class LazyDirichletSeriesRing(LazySeriesRing):
             sage: L in PrincipalIdealDomains
             False
 
-        In particular, it is not a :wikipedia:`discrete_valuation_ring`.
+        In particular, it is not a
+        :wikipedia:`discrete_valuation_ring`.  On the other hand, it
+        is a :wikipedia:`local_ring`.  The unique maximal ideal
+        consists of all non-invertible series, i.e., series with
+        vanishing constant term.
 
         .. TODO::
 
             According to the answers in
             https://mathoverflow.net/questions/5522/dirichlet-series-with-integer-coefficients-as-a-ufd,
             the ring of formal Dirichlet series is actually a
-            UniqueFactorizationDomain.
+            :wikipedia:`Unique_factorization_domain`.
+
+        .. NOTE::
+
+            An interesting valuation is described in Emil Daniel
+            Schwab; Gheorghe Silberberg A note on some discrete
+            valuation rings of arithmetical functions Archivum
+            Mathematicum, Vol. 36 (2000), No. 2, 103--109,
+            http://dml.cz/dmlcz/107723.  Let `J_k` be the ideal of
+            Dirichlet series whose coefficient `f[n]` of `n^s`
+            vanishes if `n` has less than `k` prime factors, counting
+            multiplicities.  For any Dirichlet series `f`, let `D(f)`
+            be the largest integer `k` such that `f` is in `J_k`.
+            Then `D` is surjective, `D(f g) = D(f) + D(g)` for
+            nonzero `f` and `g`, and `D(f + g) \geq \min(D(f), D(g))`
+            provided that `f + g` is nonzero.
+
+            For example, `J_1` are series with no constant term, and
+            `J_2` are series such that `f[1]` and `f[p]` for prime
+            `p` vanish.
+
+            Since this is a chain of increasing ideals, the ring of
+            formal Dirichlet series is not a
+            :wikipedia:`Noetherian_ring`.
+
+            Evidently, this valuation cannot be computed for a given
+            series.
+
         """
         if base_ring.characteristic() > 0:
             raise ValueError("positive characteristic not allowed for Dirichlet series")
```




---

archive/issue_comments_484999.json:
```json
{
    "body": "Replying to [comment:38 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[f9dd62e](https://git.sagemath.org/sage.git/commit/?id=f9dd62e7b9db93db213eb4d8b10e7e1f77920a5d)||`fix equality of exact series, do not produce coefficients of polynomials by iterating over them`||\n\nThe following commit fixes an oversight in this commit.",
    "created_at": "2022-09-18T14:04:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-484999",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:38 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[f9dd62e](https://git.sagemath.org/sage.git/commit/?id=f9dd62e7b9db93db213eb4d8b10e7e1f77920a5d)||`fix equality of exact series, do not produce coefficients of polynomials by iterating over them`||

The following commit fixes an oversight in this commit.



---

archive/issue_comments_485000.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-18T14:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485000",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_485001.json:
```json
{
    "body": "I found a number of additional bugs from some additional test suites to test the different categories. I will have more changes, but now I really need to go to bed. It took me much longer than it should have to find the bad equality test that stemmed from not converting the coefficients to the base ring in `_an_element_`.\n----\nNew commits:",
    "created_at": "2022-09-18T16:13:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485001",
    "user": "https://github.com/tscrim"
}
```

I found a number of additional bugs from some additional test suites to test the different categories. I will have more changes, but now I really need to go to bed. It took me much longer than it should have to find the bad equality test that stemmed from not converting the coefficients to the base ring in `_an_element_`.
----
New commits:



---

archive/issue_comments_485002.json:
```json
{
    "body": "I'm sorry about that, I fixed the same bug independently (and it took me a very long time, too).  Unfortunately, I did this in #34552.",
    "created_at": "2022-09-18T16:22:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485002",
    "user": "https://github.com/mantepse"
}
```

I'm sorry about that, I fixed the same bug independently (and it took me a very long time, too).  Unfortunately, I did this in #34552.



---

archive/issue_comments_485003.json:
```json
{
    "body": "(so, in case you continue while I sleep, please check #34552)",
    "created_at": "2022-09-18T16:31:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485003",
    "user": "https://github.com/mantepse"
}
```

(so, in case you continue while I sleep, please check #34552)



---

archive/issue_comments_485004.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-19T07:51:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485004",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_485005.json:
```json
{
    "body": "Travis, do you know already why this branch is failing tests in the species directory?\n----\nNew commits:",
    "created_at": "2022-09-19T07:51:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485005",
    "user": "https://github.com/mantepse"
}
```

Travis, do you know already why this branch is failing tests in the species directory?
----
New commits:



---

archive/issue_comments_485006.json:
```json
{
    "body": "Replying to [comment:66 Martin Rubey]:\n> Travis, do you know already why this branch is failing tests in the species directory?\n\nNo, I don't. I haven't been testing that directory. Let me do so right now.",
    "created_at": "2022-09-19T07:53:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485006",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:66 Martin Rubey]:
> Travis, do you know already why this branch is failing tests in the species directory?

No, I don't. I haven't been testing that directory. Let me do so right now.



---

archive/issue_comments_485007.json:
```json
{
    "body": "In the branch I just pushed, I made some changes:\n\n- I fixed a major bug with the `UniqueRepresentation`.\n- I changed `_true_order` to be a boolean as I felt there was no reason to duplicate the approximate and actual orders (now they can't get out of sync).\n- I made the `R[This is the Trac macro *x* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x-macro)` fraction field `R((x))` when `R` is a field.\n- Implemented `f // g` generically. It won't necessarily fail outright if it cannot work as it has to actually try to do the normal division.\n- I marked some tests as `# long time` as they were taking nearly 2 seconds on my (8 year old) laptop.\n- I brought in your doc in comment:59.\n\nNext to figure out what is going wrong with the species.",
    "created_at": "2022-09-19T07:57:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485007",
    "user": "https://github.com/tscrim"
}
```

In the branch I just pushed, I made some changes:

- I fixed a major bug with the `UniqueRepresentation`.
- I changed `_true_order` to be a boolean as I felt there was no reason to duplicate the approximate and actual orders (now they can't get out of sync).
- I made the `R[This is the Trac macro *x* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x-macro)` fraction field `R((x))` when `R` is a field.
- Implemented `f // g` generically. It won't necessarily fail outright if it cannot work as it has to actually try to do the normal division.
- I marked some tests as `# long time` as they were taking nearly 2 seconds on my (8 year old) laptop.
- I brought in your doc in comment:59.

Next to figure out what is going wrong with the species.



---

archive/issue_comments_485008.json:
```json
{
    "body": "Ah, I know why: I am dynamically setting the `Element` attribute of the FPS based on the input ring.",
    "created_at": "2022-09-19T08:02:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485008",
    "user": "https://github.com/tscrim"
}
```

Ah, I know why: I am dynamically setting the `Element` attribute of the FPS based on the input ring.



---

archive/issue_comments_485009.json:
```json
{
    "body": "Oh wow, you did a lot of work!\n\nI fixed a few bugs also in #34552, so I think it would be prudent not to increase the scope of this branch.",
    "created_at": "2022-09-19T08:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485009",
    "user": "https://github.com/mantepse"
}
```

Oh wow, you did a lot of work!

I fixed a few bugs also in #34552, so I think it would be prudent not to increase the scope of this branch.



---

archive/issue_comments_485010.json:
```json
{
    "body": "Also, just as a heads up, I will eventually want to make things in `__invert__` and `revert` fully lazy, see the todo notes in #34552.\n\nFinally: I wanted to introduce something simlilar to `LazyPowerSeries_gcd` for `revert` and `compose`, except that I only need it for the testsuite.  Maybe there is a more structured way?",
    "created_at": "2022-09-19T08:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485010",
    "user": "https://github.com/mantepse"
}
```

Also, just as a heads up, I will eventually want to make things in `__invert__` and `revert` fully lazy, see the todo notes in #34552.

Finally: I wanted to introduce something simlilar to `LazyPowerSeries_gcd` for `revert` and `compose`, except that I only need it for the testsuite.  Maybe there is a more structured way?



---

archive/issue_comments_485011.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-19T08:14:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485011",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_485012.json:
```json
{
    "body": "Here is the fix for species.\n\nI decided to do the mixin approach for FPS (in contrast to FLS) since it is more specialized code. I could simply move `[x]gcd` to the `LazyPowerSeries` class and add checks to error out when invalid. This gets rid of the dynamic class, but they will always appear (where we have less understanding, even over **Z** as I understand it). Your choice.",
    "created_at": "2022-09-19T08:17:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485012",
    "user": "https://github.com/tscrim"
}
```

Here is the fix for species.

I decided to do the mixin approach for FPS (in contrast to FLS) since it is more specialized code. I could simply move `[x]gcd` to the `LazyPowerSeries` class and add checks to error out when invalid. This gets rid of the dynamic class, but they will always appear (where we have less understanding, even over **Z** as I understand it). Your choice.



---

archive/issue_comments_485013.json:
```json
{
    "body": "Also +1 for cutting this ticket off and moving on to #34552 for additional changes.",
    "created_at": "2022-09-19T08:18:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485013",
    "user": "https://github.com/tscrim"
}
```

Also +1 for cutting this ticket off and moving on to #34552 for additional changes.



---

archive/issue_comments_485014.json:
```json
{
    "body": "Sorry, I don't understand enough of mixin, please decide yourself.\n\nJust an explanation (no need to change anything now) for my seemingly weird `true_order` duplicating `approximate_order`.  The idea (I don't know yet whether it was good or not) was as follows:\n\n`true_order` could be used in places where we currently use `approximate_order`, and sometimes even without checking.  However, if we make a mistake, and `true_order` is actually not yet set, we would be told by the exception that would be raised (because we cannot compute with `None`).",
    "created_at": "2022-09-19T08:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485014",
    "user": "https://github.com/mantepse"
}
```

Sorry, I don't understand enough of mixin, please decide yourself.

Just an explanation (no need to change anything now) for my seemingly weird `true_order` duplicating `approximate_order`.  The idea (I don't know yet whether it was good or not) was as follows:

`true_order` could be used in places where we currently use `approximate_order`, and sometimes even without checking.  However, if we make a mistake, and `true_order` is actually not yet set, we would be told by the exception that would be raised (because we cannot compute with `None`).



---

archive/issue_comments_485015.json:
```json
{
    "body": "#32367 is not positive review, by the way.  Is something missing there, or do you want to make them positive all at once?",
    "created_at": "2022-09-19T08:25:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485015",
    "user": "https://github.com/mantepse"
}
```

#32367 is not positive review, by the way.  Is something missing there, or do you want to make them positive all at once?



---

archive/issue_comments_485016.json:
```json
{
    "body": "Shall we somehow notify Volker that it is only necessary to merge the top ticket (which will be either this one or #34552)?",
    "created_at": "2022-09-19T08:48:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485016",
    "user": "https://github.com/mantepse"
}
```

Shall we somehow notify Volker that it is only necessary to merge the top ticket (which will be either this one or #34552)?



---

archive/issue_comments_485017.json:
```json
{
    "body": "Then let\u2019s leave it as is.\n\nI see. We could go back to doing `_true_order` being an (extended?) integer then. It is unlikely that they do get out of sync, but some care might be needed, especially with the `_element_constructor_`. We should note this reasoning somewhere in either a code or regular doc comment.\n\n#32367 is just waiting for a green patchbot. If you want to run all tests and build the doc to verify my changes are good, then you can set a positive review as well.\n\nThe whole sequence of tickets will be merged. We have set them up so they merge cleanly. There is nothing we need to worry about for that.",
    "created_at": "2022-09-19T08:50:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485017",
    "user": "https://github.com/tscrim"
}
```

Then let’s leave it as is.

I see. We could go back to doing `_true_order` being an (extended?) integer then. It is unlikely that they do get out of sync, but some care might be needed, especially with the `_element_constructor_`. We should note this reasoning somewhere in either a code or regular doc comment.

#32367 is just waiting for a green patchbot. If you want to run all tests and build the doc to verify my changes are good, then you can set a positive review as well.

The whole sequence of tickets will be merged. We have set them up so they merge cleanly. There is nothing we need to worry about for that.



---

archive/issue_comments_485018.json:
```json
{
    "body": "OK.  I thought the github patchbot is enough.\n\nConcerning `_true_order_`: once the dust has settled, I might work on #34553 and check whether it is overall better to improve `_approximate_order_` in `Stream_inexact.__getitem__`.  I am quite sure it is, but I'd like to have a good testsuite first.  So, currently it's premature optimization.\n\nI was thinking about my very original goal, extending species to the multivariate setting.  Possibly it makes sense to regard them as a graded algebra.  They have a basis (see https://en.wikipedia.org/wiki/Burnside_ring), but usually we do **not** want to compute in this basis, and only use the grading.",
    "created_at": "2022-09-19T09:14:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485018",
    "user": "https://github.com/mantepse"
}
```

OK.  I thought the github patchbot is enough.

Concerning `_true_order_`: once the dust has settled, I might work on #34553 and check whether it is overall better to improve `_approximate_order_` in `Stream_inexact.__getitem__`.  I am quite sure it is, but I'd like to have a good testsuite first.  So, currently it's premature optimization.

I was thinking about my very original goal, extending species to the multivariate setting.  Possibly it makes sense to regard them as a graded algebra.  They have a basis (see https://en.wikipedia.org/wiki/Burnside_ring), but usually we do **not** want to compute in this basis, and only use the grading.



---

archive/issue_comments_485019.json:
```json
{
    "body": "There are mechanisms in Sage to have a basis in a graded algebra that is not graded (or even filtered). I guess in some way, as long as we have a way to separate elements of the ring into graded pieces, we can use the `LazyCompletionSeries`. Actually, in that way this would work for filtered algebras as well (with the generalized definition of homogeneous).",
    "created_at": "2022-09-19T09:26:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485019",
    "user": "https://github.com/tscrim"
}
```

There are mechanisms in Sage to have a basis in a graded algebra that is not graded (or even filtered). I guess in some way, as long as we have a way to separate elements of the ring into graded pieces, we can use the `LazyCompletionSeries`. Actually, in that way this would work for filtered algebras as well (with the generalized definition of homogeneous).



---

archive/issue_comments_485020.json:
```json
{
    "body": "I actually think that having a graded algebra with a non-graded basis, but using the \"generalized\" definition of graded is going to be problematic, because our product assumes that it knows in which graded piece it is.\n\nBut let's see when we get there.",
    "created_at": "2022-09-19T09:49:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485020",
    "user": "https://github.com/mantepse"
}
```

I actually think that having a graded algebra with a non-graded basis, but using the "generalized" definition of graded is going to be problematic, because our product assumes that it knows in which graded piece it is.

But let's see when we get there.



---

archive/issue_comments_485021.json:
```json
{
    "body": "Ah, right, we do use the graded property. In fact, we even need it: it an algebra was (lower) filtered, we could have accumulation in the constant coefficient.",
    "created_at": "2022-09-19T10:10:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485021",
    "user": "https://github.com/tscrim"
}
```

Ah, right, we do use the graded property. In fact, we even need it: it an algebra was (lower) filtered, we could have accumulation in the constant coefficient.



---

archive/issue_events_089569.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/34233#event-89569"
}
```



---

archive/issue_comments_485022.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-20T02:31:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485022",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_485023.json:
```json
{
    "body": "Patchbot here was morally green (something seems broken with its giac and unrelated to this ticket) up to the pyflakes things I just fixed.\n\nI think anything further can be done on subsequent tickets and we are at a good cutoff point. If you're happy as well, we feel free to set a positive review.",
    "created_at": "2022-09-20T02:34:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485023",
    "user": "https://github.com/tscrim"
}
```

Patchbot here was morally green (something seems broken with its giac and unrelated to this ticket) up to the pyflakes things I just fixed.

I think anything further can be done on subsequent tickets and we are at a good cutoff point. If you're happy as well, we feel free to set a positive review.



---

archive/issue_comments_485024.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-09-20T05:20:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485024",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_485025.json:
```json
{
    "body": "This has no additional conflict with the changes I made in #34413.",
    "created_at": "2022-09-22T03:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485025",
    "user": "https://github.com/tscrim"
}
```

This has no additional conflict with the changes I made in #34413.



---

archive/issue_comments_485026.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2022-09-26T10:29:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485026",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_485027.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:",
    "created_at": "2022-09-26T10:29:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485027",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:



---

archive/issue_comments_485028.json:
```json
{
    "body": "trivial (automatic) merge, necessary to make the patchbots happy.",
    "created_at": "2022-09-26T10:29:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485028",
    "user": "https://github.com/mantepse"
}
```

trivial (automatic) merge, necessary to make the patchbots happy.



---

archive/issue_comments_485029.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-09-26T10:29:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485029",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_485030.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2022-10-05T15:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485030",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_485031.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2022-10-05T15:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485031",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_485032.json:
```json
{
    "body": "Trivial merge, done because I keep switching between 9.8.beta0 and 9.8.beta1, which is a waste of time.",
    "created_at": "2022-10-05T15:33:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485032",
    "user": "https://github.com/mantepse"
}
```

Trivial merge, done because I keep switching between 9.8.beta0 and 9.8.beta1, which is a waste of time.



---

archive/issue_comments_485033.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-10-05T15:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485033",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_485034.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2022-10-16T22:15:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34233#issuecomment-485034",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_089570.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-10-16T22:15:53Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/34233",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/34233#event-89570"
}
```
