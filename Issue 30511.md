# Issue 30511: Replace startup exception by warning

Issue created by migration from https://trac.sagemath.org/ticket/30748

Original creator: @tobiasdiez

Original creation time: 2020-10-08 21:53:33

CC:  mkoeppe chapoton tscrim

In #22752 it was introduced that when a lazy import is used during startup, then an RuntimeException is thrown. This leads to problems if you want to use code with lazy imports in a library mode (e.g. in standalone tests or python scripts). To support these use cases, I've degraded the exception to a print statement.

Another possible solution would be to also introduce a `start_startup` method that is used at the very beginning of loading sage, and then only consider everything between `start_startup` and `finish_startup` as "startup".


---

Comment by @tobiasdiez created at 2020-10-08 21:53:40

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2020-10-08 22:14:17

Perhaps the start_startup....finish_startup could be a context manager?


---

Comment by @tobiasdiez created at 2020-10-09 07:52:11

I like the idea! Where is the startup code located? I couldn't find the global "import sage.all". 

Second question, is how LazyImport gets access to the global startup guard. Should this be done via `global`?


---

Comment by git created at 2020-10-11 15:28:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-10-11 15:28:42

I've now implemented the idea with the context manager.


---

Comment by git created at 2020-11-02 19:53:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-11-05 18:40:07

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2020-11-05 18:40:07

Doctests fail (are not in the correct format), see patchbot output


---

Comment by git created at 2020-11-07 20:25:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-11-07 20:26:25

Should be fixed now.


---

Comment by @tobiasdiez created at 2020-11-07 20:26:25

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2020-11-08 00:01:13

Patchbot still complains


---

Comment by @tobiasdiez created at 2020-11-08 13:30:37

The pyflakes warnings are not related to my changes, and the additional startup_module is also expected since `startup_guard` is now a new class. So I'm not sure what I can/should do.


---

Comment by mkoeppe created at 2020-11-09 03:35:05

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2020-11-09 03:35:05

Replying to [comment:11 mkoeppe]:
> Patchbot still complains
... take a look at "shortlog" and you will see many errors.


---

Comment by git created at 2020-11-09 11:03:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-11-09 11:05:17

Changing status from needs_work to needs_review.


---

Comment by @tobiasdiez created at 2020-11-09 11:05:17

Ah thanks, wasn't aware of these links before. Should be fixed now (hopefully).


---

Comment by mkoeppe created at 2020-11-09 16:58:08

please set back to needs review when the doctests succeed


---

Comment by mkoeppe created at 2020-11-09 16:58:08

Changing status from needs_review to needs_work.


---

Comment by @tobiasdiez created at 2020-11-09 21:12:35

Sorry, I thought I've fixed all doctests.

On a closer inspection, now a lot of doctests are failing because of this warnings `print('Option ``at_startup=True`` for lazy import {0} not needed anymore'.format(self._name))`. I have to admit I don't really understand the purpose of this message, but I guess it should be shown if `lazy_import` is used with `at_startup = true` but sage is actually not loading at this point. If that's the case, then the current output of these doctests seems to be correct now, but I'm not sure why these warnings were not shown before.


---

Comment by git created at 2020-11-12 09:39:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-11-12 10:07:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-11-12 11:04:11

Changing status from needs_work to needs_review.


---

Comment by git created at 2020-11-12 12:01:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-12-06 15:03:20

I would appreciate if this could be reviewed relatively soon, as it's blocking my local development (I've to include it in every branch I'm working on). Thanks!


---

Comment by mkoeppe created at 2020-12-06 18:17:38

Changing keywords from "" to "sd111".


---

Comment by mkoeppe created at 2020-12-06 18:17:38

Hoping we can make progress on this ticket this week - https://wiki.sagemath.org/days111


---

Comment by @tobiasdiez created at 2020-12-18 21:54:58

Did you had a chance to look at this ticket during the Sage days?


---

Comment by mkoeppe created at 2020-12-19 05:28:23

Yes, briefly. Overall I'm not convinced by the change to a context manager (which I had suggested). So let's please split this ticket please into a minimal change (error to warning) and defer the change to using a context manager for later consideration.


---

Comment by @tobiasdiez created at 2020-12-19 09:08:20

Ok, I've extracted it to #31080. But I would still ask you to also review this ticket, as otherwise I have to subtract it from some of my other tickets (which is not as easy as just pulling the new version of a branch).

Why don't you like the context manager? I think it's the right tool, as we are managing a local state.


---

Comment by mkoeppe created at 2020-12-19 17:42:09

Making changes always has a cost, and the benefit here is not clear.

We only have a small number of developers who know about the details of the issues with circular imports in sage. Changing code makes it harder for them to contribute later.


---

Comment by mkoeppe created at 2020-12-19 18:19:36

Replying to [comment:27 gh-tobiasdiez]:
> Why don't you like the context manager? I think it's the right tool, as we are managing a local state.

I also thought it could be the right tool -- but I think it's best to revisit it in the context of the modularization of the core of sagelib (tickets such as #29865)


---

Comment by git created at 2020-12-19 21:25:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-12-19 21:27:03

I've thought about this again and realized that one actually would like to neither throw an error nor print an error message. Instead one should try to catch the resolved import already during development time. Thus, I've now implemented it as a doctest that fails as soon as there are resolved imports during startup.

What do you think?


---

Comment by mkoeppe created at 2020-12-19 21:47:04

I think I agree but this is orthogonal to the conversion to a context manager -- so shouldn't this be done in #31080 instead?


---

Comment by git created at 2020-12-20 11:34:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-12-20 11:35:53

I needed the context manager to write the tests.

> but I think it's best to revisit it in the context of the modularization of the core of sagelib (tickets such as #29865) 

What does the context manager has to do with modularization? It sets only the IS_STARTUP flag...


---

Comment by mkoeppe created at 2020-12-20 18:18:44

How is the startup phase defined?


---

Comment by @tobiasdiez created at 2020-12-20 19:36:18

It's essentially equivalent to "during the import of sage.all", but not quite. There are a few imports in sage.all that are are outside of the startup phase (and I didn't change anything there). The new context manger makes this quite clear: startup phase = everything between enter/exit of the startup_guard (or, equivalently, within the `with startup_guard` block).


---

Comment by git created at 2020-12-20 19:39:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-12-20 19:49:42

Replying to [comment:37 gh-tobiasdiez]:
> It's essentially equivalent to "during the import of sage.all", but not quite. There are a few imports in sage.all that are are outside of the startup phase (and I didn't change anything there). The new context manger makes this quite clear: startup phase = everything between enter/exit of the startup_guard (or, equivalently, within the `with startup_guard` block).
Well, the concept of `sage.all` will certainly be affected by the modularization...


---

Comment by @tobiasdiez created at 2020-12-20 19:56:37

Sure, but in a modularized setting you probably don't need this check since it's only purpose right now is to make sure that lazy imports are indeed lazy and not already resolved during startup. If that's the case for sage.all, then it's also the case for sub-modules.

In either case, the startup context manager will make it easy to define also other parts as startup in a modularized setting in case this is necessary.


---

Comment by mkoeppe created at 2020-12-20 20:04:09

Without code that's a little bit too vague, which is why it's too early to do this ticket. In particular, it's unclear whether a single flag / context manager can really do the job for several modules.


---

Comment by @tobiasdiez created at 2020-12-20 20:34:34

I agree, but the new code is still an improvement over the current one in my opinion (which used a custom-build context manager in some sense). So can we please not hold this ticket off, just because there might be possible changes in the future...

Moreover, the startup manager can easily be extended to handle multiple startup contexts by passing the context name as an argument to the `startup` method, including neasting etc because we use a context manager (which is not easily possible with the current code).


---

Comment by mkoeppe created at 2020-12-20 20:41:40

Replying to [comment:35 gh-tobiasdiez]:
> I needed the context manager to write the tests.

I don't think so, the same thing can be done in the original code


---

Comment by mkoeppe created at 2020-12-20 20:47:57

By the way, I would guess that also the print message 

```
   print(f"Option ``at_startup=True`` for lazy import {self._name} not needed anymore"`
```

should be handled in the doctest as well instead of printing at runtime.


---

Comment by @tobiasdiez created at 2020-12-20 20:49:44

Replying to [comment:43 mkoeppe]:
> Replying to [comment:35 gh-tobiasdiez]:
> > I needed the context manager to write the tests.
> 
> I don't think so, the same thing can be done in the original code

I was not able to, but you are invited to try (although its more time effective to just review this ticket...).


---

Comment by @tobiasdiez created at 2020-12-20 20:50:16

Replying to [comment:44 mkoeppe]:
> By the way, I would guess that also the print message 
> {{{
>    print(f"Option ``at_startup=True`` for lazy import {self._name} not needed anymore"`
> }}}
> should be handled in the doctest as well instead of printing at runtime.

Good point, something for a followup ticket.


---

Comment by git created at 2020-12-29 10:24:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2021-01-15 12:19:47

How should we proceed with this ticket?


---

Comment by mkoeppe created at 2021-01-15 18:25:44

As previously suggested, we defer it until the design constraints from modularization become clearer.


---

Comment by @tobiasdiez created at 2021-05-18 07:41:19

What's the status of the modularization? Any new input that is relevant for this PR?


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mjo created at 2021-11-30 00:24:20

Changing status from needs_review to needs_info.


---

Comment by mkoeppe created at 2021-11-30 00:59:03

We now have a number of small, medium, and large distributions (see #29705 for distribution names in boldface, in particular on tickets that need review), so the question of how to organize startup could be investigated with concrete examples.


---

Comment by git created at 2021-11-30 14:51:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-11-30 15:44:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2021-11-30 16:18:44

As far as I can see (please correct me if I'm wrong), the other (distribution) packages don't use `sage.all` and thus shouldn't be affected by the changes to the startup guard.

I've now introduced a third "startup state" (Uninitialized) that represents that sage is used without `sage.all` (or before `sage.all` is imported), e.g. in a modularized environment. This makes it possible to fix #32619 in a more ergonomic way.

From my point of view this is ready for review.


---

Comment by @tobiasdiez created at 2021-11-30 16:18:44

Changing status from needs_info to needs_review.


---

Comment by git created at 2021-11-30 16:29:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-11-30 18:31:12

This looks like a good solution. I'll take a closer look soon and test it with the modularized distributions


---

Comment by @tobiasdiez created at 2021-12-28 18:00:07

Replying to [comment:59 mkoeppe]:
> This looks like a good solution. I'll take a closer look soon and test it with the modularized distributions

Did you already found the time to test it?


---

Comment by mkoeppe created at 2022-03-20 17:01:47

I have been testing this for a while now with #32432, and there are no problems. (As you point out in comment:57, it's not really being invoked in this context). On the other hand, I don't have additional evidence yet that this change going in a useful direction for modularization.


---

Comment by mkoeppe created at 2022-03-20 17:16:57

I confirm that it fixes the error shown by `./sage -t src/sage/all.py` noted in the ticket description of #33531 (the error is replaced by 21 pytest warnings).

Tests pass.


---

Comment by @tobiasdiez created at 2022-03-20 17:17:53

I think having an explicit start and endpoint for the resolution of the lazy imports is already an improvement as it converts the state management to a local thing, removing the "external" component.

Also the design should be flexible enough to incorporate new needs that may arise in the context of modularization.


---

Comment by mkoeppe created at 2022-03-20 17:19:27

Replying to [comment:65 gh-tobiasdiez]:
> I think having an explicit start and endpoint for the resolution of the lazy imports is already an improvement

Yes, it's good that there's a start now.


---

Comment by mkoeppe created at 2022-03-20 17:20:07

But I don't understand the semantics of `startup`. Why would it allow going from FINISHED back to RUNNING?


---

Comment by @tobiasdiez created at 2022-03-20 17:25:15

That's needed due to the nature of how the doctests are invoked. At the beginning sage/all is imported, so the state is already "FINISHED". In order to write a meaningful test, one has to be able to reset this state (this is similar to the old test_fake_startup method).


---

Comment by mkoeppe created at 2022-03-20 17:35:37

I think I would prefer it if this only-for-doctesting behavior was invoked explicitly. I think in normal operation, it should just remain in FINISHED.


---

Comment by mkoeppe created at 2022-03-20 17:38:52

And actually I don't think `startup_guard` should be a new separate module.


---

Comment by @tobiasdiez created at 2022-03-20 17:44:46

Replying to [comment:69 mkoeppe]:
> I think I would prefer it if this only-for-doctesting behavior was invoked explicitly. I think in normal operation, it should just remain in FINISHED.

I'm not sure, but what output would you expect from

```
with startup_guard.startup():
   print(startup_guard.startup_state)

print(startup_guard.startup_state)

with startup_guard.startup():
   print(startup_guard.startup_state)
```

Since this is now a proper guard, for me "RUNNING, FINISHED, RUNNING" feels correctly.


---

Comment by @tobiasdiez created at 2022-03-20 17:45:02

Replying to [comment:70 mkoeppe]:
> And actually I don't think `startup_guard` should be a new separate module. 

Where would you put it?


---

Comment by mkoeppe created at 2022-03-20 17:52:41

Where it was - lazy_import.


---

Comment by mkoeppe created at 2022-03-20 17:55:02

Replying to [comment:71 gh-tobiasdiez]:
> Since this is now a proper guard, for me "RUNNING, FINISHED, RUNNING" feels correctly.

It makes no sense to discuss this abstractly, without reference to what the guard protects.


---

Comment by @tobiasdiez created at 2022-03-20 18:02:07

Replying to [comment:73 mkoeppe]:
> Where it was - lazy_import.

I guess these points are connected. For me the guard is a general "we in the progress of starting sage", which is then used by the lazy import feature to decide how imports during the startup are handled. But the startup guard could for example also used to control logging or other things.


---

Comment by @tobiasdiez created at 2022-03-20 18:05:08

Replying to [comment:74 mkoeppe]:
> Replying to [comment:71 gh-tobiasdiez]:
> > Since this is now a proper guard, for me "RUNNING, FINISHED, RUNNING" feels correctly.
> 
> It makes no sense to discuss this abstractly, without reference to what the guard protects.

That feels like an abstract answer (a bit of pun intended). Of course the startup guard signals that sage is starting (or if you want that lazy imports are lazy). So with that, what is the expected behavior of

```
with startup_guard.startup():
   lazy_import(xyz1)

lazy_import(xyz2)

with startup_guard.startup():
   lazy_import(xyz3)
```


I would say only xyz2 should be imported directly, while 1 and 3 are only imported lazily.


---

Comment by mkoeppe created at 2022-03-20 18:10:01

Replying to [comment:76 gh-tobiasdiez]:
> I would say only xyz2 should be imported directly, while 1 and 3 are only imported lazily. 

No, that's absolutely not what the intended semantics is. lazy imports are always lazy.


---

Comment by mkoeppe created at 2022-03-20 18:12:17

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2022-03-20 18:23:28

Replying to [comment:75 gh-tobiasdiez]:
> For me the guard is a general "we in the progress of starting sage", which is then used by the lazy import feature to decide how imports during the startup are handled. But the startup guard could for example also used to control logging or other things.

I'd say this is speculative/premature abstraction. It's first necessary to capture the intended semantics for the actual use case.


---

Comment by @tobiasdiez created at 2022-03-20 18:47:22

Replying to [comment:79 mkoeppe]:
> Replying to [comment:75 gh-tobiasdiez]:
> > For me the guard is a general "we in the progress of starting sage", which is then used by the lazy import feature to decide how imports during the startup are handled. But the startup guard could for example also used to control logging or other things.
> 
> I'd say this is speculative/premature abstraction. It's first necessary to capture the intended semantics for the actual use case.

The code above was of course only meant schematically. Read "what should be imported directly" as "what is the output of _get_imports_resolved_at_startup".


---

Comment by @tobiasdiez created at 2022-04-05 15:13:34

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2022-04-10 17:28:40

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2022-04-10 17:28:40

Well, the review says: Someone needs to figure out the semantics before pushing this code.


---

Comment by git created at 2022-04-11 17:22:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-04-11 17:51:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-04-11 17:51:58

I've narrowed down the scope of the lock/guard. What do you think?


---

Comment by mkoeppe created at 2022-04-11 17:55:41

Thanks, this is better for the discussion of the needed semantics.

So what needs to be figured out is: What should happen if
1) There is a sequence of two start ups.
2) Two startups are nested.


---

Comment by @tobiasdiez created at 2022-04-11 22:42:07

That feels like an academic issues since the actual code doesn't use either of these constructions and can easily be changed if these situations occur in the future.


---

Comment by mkoeppe created at 2022-04-11 23:29:56

It's just hard to see what the improvement brought by the ticket would be. Replacing True/False by LOCKED/UNLOCKED can't count as an improvement; and the semantics is made murkier, not clearer (see comment:69).


---

Comment by mkoeppe created at 2022-04-11 23:35:04

Replying to [comment:87 mkoeppe]:
> What should happen if
> 1) There is a sequence of two start ups.

For example, if a user tries to reload the module `sage.all`.


---

Comment by @tobiasdiez created at 2022-04-13 20:18:19

Replying to [comment:89 mkoeppe]:
> It's just hard to see what the improvement brought by the ticket would be. Replacing True/False by LOCKED/UNLOCKED can't count as an improvement; and the semantics is made murkier, not clearer (see comment:69).

As written in the ticket description, the ticket fixes a bug with importing (using importlib) the sage all module.

And yes, replacing the boolean by an enum is an improvement by itself, https://stackoverflow.com/questions/4337942/using-enum-vs-boolean.


---

Comment by git created at 2022-04-13 20:27:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-05-22 23:51:01

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2022-05-24 15:35:27

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2022-05-24 15:35:27

comment:87 is still unaddressed. Besides, the new term "lock" suggests that the mechanism is related concurrency (it isn't). Introducing a new term does not help clarify the semantics.


---

Comment by @tobiasdiez created at 2022-05-25 14:22:40

Replying to [comment:94 mkoeppe]:
> comment:87 is still unaddressed. Besides, the new term "lock" suggests that the mechanism is related concurrency (it isn't). Introducing a new term does not help clarify the semantics.
> 

There is a doctest describing the behavior of two sequential locks, the behavior of nested locks is not further specified as we don't need it yet (but as with this simplest implementation the both locks share the global "lock" variable, the state is in "locked" until the nested lock exits and then switches to "unlocked").

I'm open for suggestions for how to improve the terminology. I thought that "locked" is pretty standard for a "guard", e.g. file locks. "Started"/"Not started" or "Initialized/Not initialized" is confusing with how sequential locks work.


---

Comment by @tobiasdiez created at 2022-05-25 14:22:40

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2022-05-25 16:37:31

Replying to [comment:95 gh-tobiasdiez]:
> I thought that "locked" is pretty standard for a "guard", e.g. file locks. "Started"/"Not started" or "Initialized/Not initialized" is confusing with how sequential locks work.

Yes, file locks are locks. They protect against concurrent operations.

The start-up guard has nothing to do with concurrency. It just makes no sense to work with this analogy.


---

Comment by mkoeppe created at 2022-05-25 17:12:12

In other words, still comment:74


---

Comment by @tobiasdiez created at 2022-05-25 20:01:39

Replying to [comment:97 mkoeppe]:
> In other words, still comment:74

That concerned the more general version, now the purpose and scope of the lock should be clear.


---

Comment by mkoeppe created at 2022-05-25 20:08:03

Well, it clearly isn't clear, as I said in comment:96. Try to explain it in the documentation or in the ticket.


---

Comment by mkoeppe created at 2022-05-25 20:19:06

comment:74 is: You are trying to explain things in too much generality, based on an abstraction that you have come up with. But the abstraction does not capture the purpose of the startup guard mechanism: What exactly is the guard intended to protect?
Short of explaining this, you are essentially trying to explain to me what a bit is.


---

Comment by @tobiasdiez created at 2022-05-25 21:11:06

The purpose of the guard/lock/whatever you want to call it is the same as in the develop branch: when the guard is active, lazy imports should not be resolved. The only difference is that the guard has to be activated now explicitly.


---

Comment by mkoeppe created at 2022-05-25 21:27:00

Replying to [comment:101 gh-tobiasdiez]:
>  when the guard is active, lazy imports should not be resolved.

No, that's not what it does.


---

Comment by @tobiasdiez created at 2022-05-25 21:44:39

Replying to [comment:102 mkoeppe]:
> Replying to [comment:101 gh-tobiasdiez]:
> >  when the guard is active, lazy imports should not be resolved.
> 
> No, that's not what it does.

So what is it doing then?


---

Comment by mkoeppe created at 2022-05-25 22:05:39

You can see it in the source code of `LazyImport._get_object` - it does not change what is resolved when or anything. It only informs developers (by printing warnings) whether the laziness was effective or if the module was imported anyway.


---

Comment by @tobiasdiez created at 2022-05-26 10:05:33

Yes, but isn't this a qualification of what "should" in "lazy import should not be resolved" means? Also from the ticket description: "convert runtime warning about resolved lazy imports to doctest."

Anyway, now that we agree on the terminology, do you still have questions about the serial behavior?


---

Comment by mkoeppe created at 2022-05-26 14:20:50

Replying to [comment:105 gh-tobiasdiez]:
> Yes, but isn't this a qualification of what "should" in "lazy import should not be resolved" means?

OK, I now understand what you meant by "should".


---

Comment by mkoeppe created at 2022-05-26 14:26:27

Replying to [comment:105 gh-tobiasdiez]:
> do you still have questions about the serial behavior?

Yes. You are changing the serial behavior in this ticket. Why is this change an improvement over what's in the develop branch?


---

Comment by mkoeppe created at 2022-05-26 15:36:53

Replying to [comment:105 gh-tobiasdiez]:
> now that we agree on the terminology

We don't. It's not a lock, so please don't introduce this terminology in the ticket.


---

Comment by @tobiasdiez created at 2022-05-27 16:48:05

Replying to [comment:107 mkoeppe]:
> Replying to [comment:105 gh-tobiasdiez]:
> > do you still have questions about the serial behavior?
> 
> Yes. You are changing the serial behavior in this ticket. Why is this change an improvement over what's in the develop branch?

It's not really a change, the start/end methods were just called test_fake_startup/ensure_startup_finished. The improvement is currently only visible in the tests, as this is the only place where it is used. But I think it may be handy also in the `all` script to have more freedom on how to order/group imports there without being constrained by the lazy import guard.


---

Comment by @tobiasdiez created at 2022-05-27 16:50:02

Replying to [comment:108 mkoeppe]:
> Replying to [comment:105 gh-tobiasdiez]:
> > now that we agree on the terminology
> 
> We don't. It's not a lock, so please don't introduce this terminology in the ticket.

comment:95


---

Comment by mkoeppe created at 2022-05-27 21:41:17

In comment:95 you called it a "sequential lock". It isn't.


---

Comment by mkoeppe created at 2022-05-27 21:45:03

Or is your reference to comment:95 "I'm open for suggestions"?

Let's see. A "lock" is locked or unlocked. A "guard" is ... active/inactive? engaged/disengaged? on/off?

Anything like this sounds fine, I don't have a preference. It's just important to avoid using words that can be mistaken as standard technical terms when there is no relation.


---

Comment by mkoeppe created at 2022-05-27 22:22:03

Replying to [comment:109 gh-tobiasdiez]:
> Replying to [comment:107 mkoeppe]:
> > Replying to [comment:105 gh-tobiasdiez]:
> > > do you still have questions about the serial behavior?
> > 
> > Yes. You are changing the serial behavior in this ticket. Why is this change an improvement over what's in the develop branch?
> 
> It's not really a change, the start/end methods were just called test_fake_startup/ensure_startup_finished.

OK, that's not quite where I wanted to take the discussion. 

Let's please ignore the old doctesting-only helper functions - they have no relevance for discussing the semantics. 

In `develop`, `finish_startup` can only be called once, and an error is raised otherwise; and then there is `ensure_startup_finished`, which can be called multiple times and which is a no-op if it was called before.

> [...] I think it may be handy also in the `all` script to have more freedom on how to order/group imports there without being constrained by the lazy import guard.

Yes, I am interested in this -- which is why I brought up the scenarios of sequences of such startup-guarded blocks and also nested startup-guarded blocks in comment:87. 

So with the changes on this ticket, it becomes possible to have a sequence of two startup-guarded blocks:

```
with ...:
    Block 1
with ...:
    Block 2
```

I think we both agree on what the first block should do. Now, why should the second one behave as you implemented?


---

Comment by @tobiasdiez created at 2022-05-28 21:23:55

Because its not important in which block the lazy import is placed, it's only important whether it's guarded or not. What other implementation would you suggest?


---

Comment by mkoeppe created at 2022-05-28 21:33:45

Replying to [comment:114 gh-tobiasdiez]:
> Because its not important in which block the lazy import is placed, it's only important whether it's guarded or not.

But *why* do you think that this the right semantics?


---

Comment by @tobiasdiez created at 2022-05-29 08:18:04

It seemed the most logical and easy to implement solution, that worked well with the currently only use case of the tests. What other implementation do you have in mind? Make the second block a noop?


---

Comment by mkoeppe created at 2022-05-29 22:52:31

Replying to [comment:116 gh-tobiasdiez]:
> Make the second block a noop? 

Yes, a kind of no-op is what I had in mind.

In the current code, this structure does not appear lexically (and I don't have a use case for it in modularization):

```
with ...:
    Block 1
with ...:
    Block 2
```

However, this sequence will be executed when a user reloads the `sage.all` module using `importlib.reload`.
(Currently this is an error. And of course it is unclear if reloading actually can be made to work properly, given that we have so much complicated global state.)

So in this situation, in the second block, it would makes no sense to do any of the tracking of resolved lazy imports and emitting warnings. The startup was done already.


---

Comment by mkoeppe created at 2022-05-29 22:59:06

On the other hand, this structure:

```
with ...:
    with ...:
        Block 1
    with ...:
        Block 2
    Block 3
```

would appear in the course of modularization in some follow-up ticket of #29941, #28925. Blocks 1 and 2 would be imports done by modules like `sage.all__sagemath_environment`, `sage.all__sagemath_objects`.


---

Comment by @tobiasdiez created at 2022-05-30 10:46:37

Replying to [comment:117 mkoeppe]:
> Replying to [comment:116 gh-tobiasdiez]:
> > Make the second block a noop? 
> 
> Yes, a kind of no-op is what I had in mind.
> 
> In the current code, this structure does not appear lexically (and I don't have a use case for it in modularization):
> {{{
> with ...:
>     Block 1
> with ...:
>     Block 2
> }}}
> However, this sequence will be executed when a user reloads the `sage.all` module using `importlib.reload`.
> (Currently this is an error. And of course it is unclear if reloading actually can be made to work properly, given that we have so much complicated global state.)
> 
> So in this situation, in the second block, it would makes no sense to do any of the tracking of resolved lazy imports and emitting warnings. The startup was done already.

In this use case the current implementation is almost noop, since now the guard is only checked in the doctests and no warnings are issued.


---

Comment by @tobiasdiez created at 2022-05-30 10:53:19

Replying to [comment:118 mkoeppe]:
> On the other hand, this structure:
> {{{
> with ...:
>     with ...:
>         Block 1
>     with ...:
>         Block 2
>     Block 3
> }}}
> would appear in the course of modularization in some follow-up ticket of #29941, #28925. Blocks 1 and 2 would be imports done by modules like `sage.all__sagemath_environment`, `sage.all__sagemath_objects`.

In my opinion, the submodules shouldn't have their own startup scripts. The all script is one of the things that make sage so hard to use as a library. But if the nested structure does arise in the future, then the implementation of the guard can easily be changed to accommodate of this.


---

Comment by mkoeppe created at 2022-05-30 18:47:03

Replying to [comment:120 gh-tobiasdiez]:
> Replying to [comment:118 mkoeppe]:
> > imports done by modules like `sage.all__sagemath_environment`, `sage.all__sagemath_objects`.
> 
> In my opinion, the submodules shouldn't have their own startup scripts. The all script is one of the things that make sage so hard to use as a library. 

The `all` scripts have two purposes: (1) To orchestrate startup, and I agree with you that the library should be changed to make it unnecessary - that's #33580. (2) To fill the top-level namespace that is available at the `sage:` prompt. And this is not going away.


---

Comment by mkoeppe created at 2022-05-30 19:00:57

Replying to [comment:120 gh-tobiasdiez]:
> But if the nested structure does arise in the future

Well, it will, as I said in comment:118.

> then the implementation of the guard can easily be changed to accommodate of this. 

In your current branch you are introducing a public interface (including new terminology) for the `GuardState`. That's not a good way forward when we already know that it does not capture what is needed.


---

Comment by mkoeppe created at 2022-05-30 20:31:45

Replying to [comment:119 gh-tobiasdiez]:
> Replying to [comment:117 mkoeppe]:
> > Replying to [comment:116 gh-tobiasdiez]:
> > > Make the second block a noop? 
> > 
> > Yes, a kind of no-op is what I had in mind.
> > [...] this sequence will be executed when a user reloads the `sage.all` module using `importlib.reload`. [...]
> > 
> > So in this situation, in the second block, it would makes no sense to do any of the tracking of resolved lazy imports and emitting warnings. The startup was done already.
> 
> In this use case the current implementation is almost noop, since now the guard is only checked in the doctests and no warnings are issued. 

Not no-op enough. The doctests can also be invoked from within a running Sage.


---

Comment by @tobiasdiez created at 2022-05-30 20:36:26

Replying to [comment:121 mkoeppe]:
> (2) To fill the top-level namespace that is available at the `sage:` prompt. And this is not going away.

But you only have one prompt so one global guard should be sufficient. I don't see the need why the submodule needs its own guard, or even why it's the responsibility of the module to declare what methods should be available in the sage prompt in the first place.


---

Comment by @tobiasdiez created at 2022-05-30 20:38:43

Replying to [comment:123 mkoeppe]:
> Replying to [comment:119 gh-tobiasdiez]:
> > Replying to [comment:117 mkoeppe]:
> > > Replying to [comment:116 gh-tobiasdiez]:
> > > > Make the second block a noop? 
> > > 
> > > Yes, a kind of no-op is what I had in mind.
> > > [...] this sequence will be executed when a user reloads the `sage.all` module using `importlib.reload`. [...]
> > > 
> > > So in this situation, in the second block, it would makes no sense to do any of the tracking of resolved lazy imports and emitting warnings. The startup was done already.
> > 
> > In this use case the current implementation is almost noop, since now the guard is only checked in the doctests and no warnings are issued. 
> 
> Not no-op enough. The doctests can also be invoked from within a running Sage.

The test would still only fail if there are already resolved lazy imports in the first load.


---

Comment by mkoeppe created at 2022-05-30 20:40:15

Replying to [comment:124 gh-tobiasdiez]:
> Replying to [comment:121 mkoeppe]:
> > (2) To fill the top-level namespace that is available at the `sage:` prompt. And this is not going away.
> 
> But you only have one prompt 

Nope. See https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#testing-distribution-packages

> I don't see the need why the submodule needs its own guard, or even why it's the responsibility of the module 

Not the module, the distribution.


---

Comment by mkoeppe created at 2022-05-30 20:41:12

Replying to [comment:125 gh-tobiasdiez]:
> Replying to [comment:123 mkoeppe]:
> > Not no-op enough. The doctests can also be invoked from within a running Sage.
> 
> The test would still only fail if there are already resolved lazy imports in the first load. 

There are two types warnings, right? Let's break the analysis down by type.
