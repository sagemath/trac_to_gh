# Issue 11998: Genus computation (using singular) and _singular_ object for function filed

Issue created by migration from Trac.

Original creator: sydahmad

Original creation time: 2011-12-17 02:22:47

Assignee: AlexGhitza

CC:  mderickx minz saraedum

Keywords: function field, genus, singular

Following my the discussion on sage-devel this adds genus() function to the FunctionField class, to compute the genus of the function field using singular.

It is not as fast as magma but it is at least a first step.


---

Comment by sydahmad created at 2011-12-17 03:23:13

Changing status from new to needs_review.


---

Comment by sydahmad created at 2011-12-17 03:23:13

if we have:

kx.<x> = FunctionField(QQ)
kxY.<Y> = PolynomialRing(QQ)

kxY._singular_ should be k(x)[Y] (which is what this code generates) however, singular only computes the genus of an ideal of k[x][Y] ring. So, I have to generate a tmpR = k[x][Y] each time I need to compute the genus. Maybe it's worth it to add __singular_deg2_ private object to store this ring as well. 

Also, it makes sense to store the genus in __genus. But I'm not sure how should I check it's validity. Can the defining polynomial of the function field change after its creation. If not then we can set __genus = -1 and if it's non-negative then it's valid.


---

Comment by sydahmad created at 2011-12-17 03:24:11

Changing component from algebraic geometry to algebra.


---

Comment by sydahmad created at 2011-12-17 03:24:23

Changing component from algebra to algebraic geometry.


---

Comment by mderickx created at 2011-12-17 09:49:17

Replying to [comment:1 sydahmad]:
> if we have:
> 
> kx.<x> = FunctionField(QQ)
> kxY.<Y> = PolynomialRing(QQ)
> 
> kxY._singular_ should be k(x)[Y] (which is what this code generates) however, singular only computes the genus of an ideal of k[x][Y] ring. So, I have to generate a tmpR = k[x][Y] each time I need to compute the genus. Maybe it's worth it to add __singular_deg2_ private object to store this ring as well. 
>

Well if we are going to cache the genus computation then this won't be needed.

Replying to [comment:1 sydahmad]:
> Also, it makes sense to store the genus in __genus. But I'm not sure how should I check it's validity. Can the defining polynomial of the function field change after its creation. If not then we can set __genus = -1 and if it's non-negative then it's valid.

You should look at the documentation of cached_method on how to do this. It would be indeed some function ideal for caching since it's answer takes a while to compute while it takes only a small integer to store it. 

Note that you can change the defining polynomial (because you have to go trough a lot of trouble to make python objects immutable). But you are safe to assume that the defining polynomial doesn't change. In fact the current code already assumes that as shown below.


```
sage: K.<x>=FunctionField(QQ)
sage: R.<y>=K[]
sage: L=K.extension(y^3+y*x+x)
sage: L
Function field in y defined by y^3 + x*y + x
sage: L.__init__(y^3+x,'y')
sage: L
Function field in y defined by y^3 + x
sage: K.extension(y^3+y*x+x)
Function field in y defined by y^3 + x
```



---

Comment by saraedum created at 2011-12-17 20:56:21

I'm surprised myself but singular does not complain about fractions:

```
sage: singular.ideal('y^5 - (x^3 + 2*x*y + 1/x)')
-x^3-2*x*y+y^5
sage: singular.eval('1/x')
0
```


The 1/x was just thrown out because in singular it evaluates to 0. Anyway I think you're maybe doing too many direct calls to singular. Why not go to the polynomial ring QQ[x,y] create the ideal there get its singular object and determine the genus in singular? Or maybe I misunderstand what the genus function in singular does.

Also, is_RationalFunctionField() should imho be a member method is_rational() of FunctionField that is overwritten in RationalFunctionField and FunctionField_polymod.


---

Comment by saraedum created at 2011-12-17 20:56:21

Changing status from needs_review to needs_work.


---

Comment by saraedum created at 2011-12-17 22:01:09

Thinking about this, is_RationalFunctionField()/is_rational() is probably not the right name. Take QQ(x) and the extension given by y^2=x then that gives you a rational function field but probably that's not what you want there. In this case what you actually want is probably one implementation in RationalFunctionField (returning 0) and one in FunctionField_polymod (calling singular).


---

Comment by was created at 2011-12-20 03:39:21

Just a quick observation.  The docstring for is_RationalFunctionField claims that it checks if the input is "of rational function field *type*".  However, that is not what it does.  It checks if it is either of rational function field type, or if it isn't, it also checks if the input is in the category of Function Fields and is equal to its base.  I think the docstring should be changed.  Also, be sure to include an example that illustrates something that is not of RationalFunctionField type but is in the category FunctionFields().

```
        960	def is_RationalFunctionField(x): 
 	961	    """ 
 	962	    Return True if ``x`` is of rational function field type. 
...
 	971	    """ 
 	972	    if isinstance(x, RationalFunctionField): return True 
 	973	    if (x in FunctionFields()): 
 	974	        return x == x.base_field() 
 	975	    else: 
```



---

Comment by sydahmad created at 2011-12-20 07:41:27

Replying to [comment:7 saraedum]:

> I'm surprised myself but singular does not complain about fractions: ` sage: singular.ideal('y^5 - (x^3 + 2*x*y + 1/x)') -x<sup>3-2*x*y+y</sup>5 sage: singular.eval('1/x') 0 ` The 1/x was just thrown out because in singular it evaluates to 0.

So, basically, I need to clear the denominator before handing the job to Singular, correct? If yes is there a method to do so, or I just compute the GCD of the denom of all coeffs?

Thanx.


---

Comment by sydahmad created at 2011-12-20 08:27:00

Replying to [comment:8 saraedum]:

> Thinking about this, is_RationalFunctionField()/is_rational() is probably not the right name. Take QQ(x) and the extension given by y^2 = x then that gives you a rational function field but probably that's not what you want there. In this case what you actually want is probably one implementation in RationalFunctionField (returning 0) and one in FunctionField_polymod (calling singular).^

This is why the function is called "is_RationalFunctionField()". This is because it does not check if (mathematically) the function field is rational, but it checks, if it is (programatically) of RationalFunctionField type. I need that because (AFAIUnderstood the manual) when I ask Singular to create a ring of k(t)[y] form, singular expects that k be a prime field (you only get to give the characteristic). so I can not accept k(x)[y]/(y^2 - x) for my purpose:


```
sage: singular.eval('ring r = (7^2,a,b),(x,y,z),dp;')
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)

/home/syd/Programmes/sage-4.7.2/devel/sage-sydevel/<ipython console> in <module>()

/home/syd/Programmes/sage-4.7.2/local/lib/python2.6/site-packages/sage/interfaces/singular.pyc in eval(self, x, allow_semicolon, strip, **kw\
ds)
    572
    573         if s.find("error") != -1 or s.find("Segment fault") != -1:
--> 574             raise RuntimeError, 'Singular error:\n%s'%s
    575
    576         if get_verbose() > 0:

RuntimeError: Singular error:
   ? too many parameters
   ? cannot make ring
   ? error occurred in or before STDIN line 41: `ring r = (7^2,a,b),(x,y,z),dp;`
   ? expected ring-expression. type 'help ring;'

```



So, I'm OK with making it a method of FunctionField class but I think we should keep the name. We can have an additional method of "is_rational()" if you like (which will involve computing the genus).


---

Comment by sydahmad created at 2011-12-20 08:41:56

Replying to [comment:9 was]:
> Just a quick observation.  The docstring for is_RationalFunctionField claims that it checks if the input is "of rational function field *type*".  However, that is not what it does.

What I needed was the type check, but because I wanted to follow is_FunctionField line by line and that there's no category of RationalFunctionFields I thought that this is the closest approximation.

```
  	973	    if (x in FunctionFields()): 
  	974	        return x == x.base_field() 
  	975	    else: 
```

Saying that, I do not think that I can come up with such an example because I do not know how the members of FunctionFields category which are not of FunctionField type looks like, I even do not know if they have base_field() method or not (David Roe told me last week that categorical parenthood does not implies OOP parenthood), and if not, the code will generate an error. So, I think we should get rid of these three lines instead.


---

Comment by saraedum created at 2011-12-21 14:38:06

Replying to [comment:10 sydahmad]:
> Replying to [comment:7 saraedum]:
> 
> > I'm surprised myself but singular does not complain about fractions: ` sage: singular.ideal('y^5 - (x^3 + 2*x*y + 1/x)') -x<sup>3-2*x*y+y</sup>5 sage: singular.eval('1/x') 0 ` The 1/x was just thrown out because in singular it evaluates to 0.
> 
> So, basically, I need to clear the denominator before handing the job to Singular, correct? If yes is there a method to do so, or I just compute the GCD of the denom of all coeffs?
> 
> Thanx.

There's a method `_make_monic_integral()` that seems to do just that.


---

Comment by sydahmad created at 2011-12-22 09:13:15

Changing status from needs_work to needs_review.


---

Comment by sydahmad created at 2011-12-22 09:13:15

I addressed cache_method, reducing calls and using integral polynomial. I also got rid of the line in is_RationalFunctionField which was making the documentation invalid. About the name and place of definition of is_RationalFunctionField, I think the name is appropriate because it shows that we are asking about the type of the object and not the rationality of the function field. For the same reason, because it's asking about the type of the object and not one of its attribute, doesn't it make sense to remain outside, like is_FunctionField (though we don't have a cat (yet!)).

Anyways, if there's a unanimous decision about its name and its place of definition, I'll apply it. But if it is defined in the FunctionField class it will be only:


```
def is_RationalFunctionField(self):
    return False;
```

and in the RationalFunctionField class:


```
def is_RationalFunctionField(self):
    return True;
```

We can also, get rid of it, but I think it improves the readability of the code.

And sorry about two patches. I initiated my queue after the first submission and now hg doesn't let me rollback.


---

Comment by sydahmad created at 2011-12-29 02:48:44

I have finally qfolded the two patches in one but I don't know how to delete the two first files. Maybe I don't have permission to do so. If anybody can delete _"_[trac_12170.patch](http://trac.sagemath.org/sage_trac/attachment/ticket/12170/trac_12170.patch)_" and "_[trac_12170_1.patch](http://trac.sagemath.org/sage_trac/attachment/ticket/12170/trac_12170_1.patch)" from this ticket please do so.


---

Comment by dimpase created at 2012-01-26 05:43:18

Replying to [comment:17 sydahmad]:
> I have finally qfolded the two patches in one but I don't know how to delete the two first files. Maybe I don't have permission to do so. If anybody can delete _"_[trac_12170.patch](http://trac.sagemath.org/sage_trac/attachment/ticket/12170/trac_12170.patch)_" and "_[trac_12170_1.patch](http://trac.sagemath.org/sage_trac/attachment/ticket/12170/trac_12170_1.patch)" from this ticket please do so.

You can just mention in the ticket's Description which patch to apply.


---

Attachment

adds genus computation; adds function fieds and rational func field over non prime finite fields to _singular_init and can_convert_to_singular in the singular interface with reduce no of calls to Singular; non integral polynomial bug fixed.


---

Comment by sydahmad created at 2012-02-20 16:46:34

Replying to [ticket:12170 sydahmad]:
> Following my the discussion on sage-devel this adds genus() function to the FunctionField class, to compute the genus of the function field using singular.
> 
> It is not as fast as magma but it is at least a first step.


---

Comment by davidloeffler created at 2012-03-13 13:48:51

Apply trac_12170-gen_comp_singular_obj.patch

(for patchbot)


---

Comment by dimpase created at 2013-10-15 20:03:15

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2013-10-19 09:20:27

Resolution: fixed
