# Issue 27148: Random hangs in giac interface since upgrade to 1.5 (at least on Cygwin)

archive/issues_027148.json:
```json
{
    "body": "CC:  @frederichan-IMJPRG parisse @slel\n\nKeywords: giac\n\nSince the upgrade to giac 1.5 (#26315) the test suite for `sage.interfaces.giac` will sometimes randomly hang.\n\nI don't have a reliable way to reproduce the problem: I just run \n\n\n```\n./sage -t --long src/sage/interfaces/giac.py\n```\n\n\nin an infinitely loop, and once out of roughly every 5 runs the test process will just hang without any CPU usage, usually on completely arbitrary lines in the test.  Though the test process will at least respond to being killed with a SIGTERM so the issue *probably* isn't a threading deadlock in openblas, at last (those tend to be unresponsive to signals in Cygwin since it's using Windows native threads directly).\n\nIssue created by migration from https://trac.sagemath.org/ticket/27385\n\n",
    "created_at": "2019-02-28T11:08:28Z",
    "labels": [
        "component: interfaces",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.8",
    "title": "Random hangs in giac interface since upgrade to 1.5 (at least on Cygwin)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27148",
    "user": "https://github.com/embray"
}
```
CC:  @frederichan-IMJPRG parisse @slel

Keywords: giac

Since the upgrade to giac 1.5 (#26315) the test suite for `sage.interfaces.giac` will sometimes randomly hang.

I don't have a reliable way to reproduce the problem: I just run 


```
./sage -t --long src/sage/interfaces/giac.py
```


in an infinitely loop, and once out of roughly every 5 runs the test process will just hang without any CPU usage, usually on completely arbitrary lines in the test.  Though the test process will at least respond to being killed with a SIGTERM so the issue *probably* isn't a threading deadlock in openblas, at last (those tend to be unresponsive to signals in Cygwin since it's using Windows native threads directly).

Issue created by migration from https://trac.sagemath.org/ticket/27385





---

archive/issue_comments_382008.json:
```json
{
    "body": "Definitely seeing something in strace where the python process is waiting for giac to exit, and it's off in some loop calling\n\n\n```\n921 23821490 [main] giac 21056 clock_nanosleep: clock_nanosleep (0.001000000)\n```\n\n\nuntil I send `kill -SIGTERM` to the python process.  In the process of shutting down, python tries a few times to kill giac with SIGHUP, SIGINT, and SIGQUIT and it doesn't respond.  It keeps going in a loop.  Finally a few moments later the sage-cleaner comes along and SIGKILLs giac.\n\nSo at the very least that points us in the right direction: There's some miscommunication happening, somewhere, with how sage tries to kill giac processes.",
    "created_at": "2019-02-28T14:10:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382008",
    "user": "https://github.com/embray"
}
```

Definitely seeing something in strace where the python process is waiting for giac to exit, and it's off in some loop calling


```
921 23821490 [main] giac 21056 clock_nanosleep: clock_nanosleep (0.001000000)
```


until I send `kill -SIGTERM` to the python process.  In the process of shutting down, python tries a few times to kill giac with SIGHUP, SIGINT, and SIGQUIT and it doesn't respond.  It keeps going in a loop.  Finally a few moments later the sage-cleaner comes along and SIGKILLs giac.

So at the very least that points us in the right direction: There's some miscommunication happening, somewhere, with how sage tries to kill giac processes.



---

archive/issue_comments_382009.json:
```json
{
    "body": "Since you seem to be able to reproduce it relatively reliably (5 runs of a single test should be cheap), couldn't you bisect between giac 1.4.9.45 and 1.5.0.37?",
    "created_at": "2019-03-04T14:28:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382009",
    "user": "https://github.com/timokau"
}
```

Since you seem to be able to reproduce it relatively reliably (5 runs of a single test should be cheap), couldn't you bisect between giac 1.4.9.45 and 1.5.0.37?



---

archive/issue_comments_382010.json:
```json
{
    "body": "That's exactly what I'm working on doing now.  It's just taking a long time to download the tarballs because there's something wrong with the webserver they're hosted on.\n\nI'm still at a bit of a loss about the overall issue.  It's getting stuck in this while loop in the `icas_eval` function while pexpect is waiting for a prompt:\n\n\n```\n3348       while (1){\n3349         // look at other threads\n3350         int cs=context_list().size(),ci=0;\n3351         for (;ci<cs;++ci){\n3352           context * cptr=context_list()[ci];\n3353           if (cptr!=contextptr)\n3354             status=check_thread(cptr);\n3355         }\n3356         // 0 finished, 2/3 debug/wait click\n3357         status=giac::check_thread(contextptr);\n3358 #ifdef HAVE_LIBFLTK\n3359         if (xcas::Xcas_Debug_Window && status<2)\n3360           xcas::Xcas_Debug_Window->hide();\n3361 #endif\n3362         if (status<=0){\n3363 #ifdef HAVE_LIBFLTK\n3364           Fl::flush();\n3365 #endif\n3366           break;\n3367         }\n3368 #ifdef HAVE_LIBFLTK\n3369         if (status!=1)\n3370           xcas::Xcas_debugguer(status,contextptr);\n3371 #else\n3372         // FIXME Debugguer without FLTK\n3373         giac::thread_eval_status(1,contextptr);\n3374 #endif\n3375         if (ctrl_c){\n3376           if (giac::is_context_busy(contextptr))\n3377             giac::kill_thread(true,contextptr);\n3378           ctrl_c=false; interrupted=false;\n3379         }\n3380         else\n3381           usleep(1000);\n3382       }\n\n```\n\n\nStill not sure if there's an easy way to reproduce this outside of Sage.",
    "created_at": "2019-03-04T15:26:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382010",
    "user": "https://github.com/embray"
}
```

That's exactly what I'm working on doing now.  It's just taking a long time to download the tarballs because there's something wrong with the webserver they're hosted on.

I'm still at a bit of a loss about the overall issue.  It's getting stuck in this while loop in the `icas_eval` function while pexpect is waiting for a prompt:


```
3348       while (1){
3349         // look at other threads
3350         int cs=context_list().size(),ci=0;
3351         for (;ci<cs;++ci){
3352           context * cptr=context_list()[ci];
3353           if (cptr!=contextptr)
3354             status=check_thread(cptr);
3355         }
3356         // 0 finished, 2/3 debug/wait click
3357         status=giac::check_thread(contextptr);
3358 #ifdef HAVE_LIBFLTK
3359         if (xcas::Xcas_Debug_Window && status<2)
3360           xcas::Xcas_Debug_Window->hide();
3361 #endif
3362         if (status<=0){
3363 #ifdef HAVE_LIBFLTK
3364           Fl::flush();
3365 #endif
3366           break;
3367         }
3368 #ifdef HAVE_LIBFLTK
3369         if (status!=1)
3370           xcas::Xcas_debugguer(status,contextptr);
3371 #else
3372         // FIXME Debugguer without FLTK
3373         giac::thread_eval_status(1,contextptr);
3374 #endif
3375         if (ctrl_c){
3376           if (giac::is_context_busy(contextptr))
3377             giac::kill_thread(true,contextptr);
3378           ctrl_c=false; interrupted=false;
3379         }
3380         else
3381           usleep(1000);
3382       }

```


Still not sure if there's an easy way to reproduce this outside of Sage.



---

archive/issue_comments_382011.json:
```json
{
    "body": "After painstakingly manually bisecting between the various giac [source tarballs](http://www-fourier.ujf-grenoble.fr/~parisse/debian/dists/stable/main/source/), I'm reasonably certain that the issue started between giac-1.5.0-21 and giac-1.5.0-25.  I'm going to start diffing between those versions to see if any specific changes stand out.\n\nThe issue is hard to reproduce exactly reliably, but can be done simply by slamming the icas command line with a lot of input in rapid succession.  For example by doing, via the pexpect interface in Sage:\n\n\n```\nidx = 0\nwhile True:\n    print(idx)\n    giac.eval('1 + 1')\n    idx += 1\n```\n\n\neventually, usually after a few thousand iterations, or as few as a few dozen it will freeze in the `while(1)` loop I posted in the comment above.\n\nI suspect a subtle race condition, possibly involving a slight error in clock arithmetic or something like that; I've seen that sort of thing before. E.g. https://bugs.python.org/issue26939",
    "created_at": "2019-03-06T11:18:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382011",
    "user": "https://github.com/embray"
}
```

After painstakingly manually bisecting between the various giac [source tarballs](http://www-fourier.ujf-grenoble.fr/~parisse/debian/dists/stable/main/source/), I'm reasonably certain that the issue started between giac-1.5.0-21 and giac-1.5.0-25.  I'm going to start diffing between those versions to see if any specific changes stand out.

The issue is hard to reproduce exactly reliably, but can be done simply by slamming the icas command line with a lot of input in rapid succession.  For example by doing, via the pexpect interface in Sage:


```
idx = 0
while True:
    print(idx)
    giac.eval('1 + 1')
    idx += 1
```


eventually, usually after a few thousand iterations, or as few as a few dozen it will freeze in the `while(1)` loop I posted in the comment above.

I suspect a subtle race condition, possibly involving a slight error in clock arithmetic or something like that; I've seen that sort of thing before. E.g. https://bugs.python.org/issue26939



---

archive/issue_comments_382012.json:
```json
{
    "body": "The relevant change that caused this problem to appear is, quite subtly, \n\n\n```diff\ndiff -ruN giac-1.5.0-21/src/icas.cc giac-1.5.0-25/src/icas.cc\n--- giac-1.5.0-21/src/icas.cc   2018-11-17 14:35:47.000000000 +0100\n+++ giac-1.5.0-25/src/icas.cc   2018-12-09 11:02:08.000000000 +0100\n@@ -160,6 +160,7 @@\n using namespace giac;\n #define STDIN_FILENO 0\n namespace xcas {\n+  /*\n   void icas_eval(giac::gen & g,giac::gen & gg,int & reading_file,std::string &filename,giac::context * contextptr){\n     gg=protecteval(g,10,contextptr);\n   }\n@@ -167,6 +168,7 @@\n   bool fltk_view(const giac::gen & g,giac::gen & ge,const std::string & filename,std::string & figure_filename,int file_type,const giac::context *contextptr){\n     return false;\n   }\n+  */\n }\n\n #else\n```\n\n\nSomewhere along the line there was some experimentation with integrating the `xcas::icas_eval` REPL loop into the command-line icas interface, probably so that it can have optional graphics support if compiled with FLTK (e.g. opening windows to view plots), and so it uses this threaded eval loop in order to allow non-blocking I/O while also interacting with a GUI window.\n\nPrior to 1.5.0-25, there was some hackery in `icas.cc` to override `xcas::icas_eval` with a dummy, non-threaded version, at least when compiled without FLTK.  But I guess at some point it was decided that the threaded version worked well-enough in icas as well(??) and the dummy override was not even removed but just...commented out.\n\nSince the threaded eval loop is apparently working well-enough on other platforms I think what I'll do for now, so I can move on to other things, is provide a patch to re-disable the threaded eval just on Cygwin.  It would be good to then investigate what the bug is in the threaded eval, but that is lower priority for the purposes of fixing Sage.",
    "created_at": "2019-03-06T12:06:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382012",
    "user": "https://github.com/embray"
}
```

The relevant change that caused this problem to appear is, quite subtly, 


```diff
diff -ruN giac-1.5.0-21/src/icas.cc giac-1.5.0-25/src/icas.cc
--- giac-1.5.0-21/src/icas.cc   2018-11-17 14:35:47.000000000 +0100
+++ giac-1.5.0-25/src/icas.cc   2018-12-09 11:02:08.000000000 +0100
@@ -160,6 +160,7 @@
 using namespace giac;
 #define STDIN_FILENO 0
 namespace xcas {
+  /*
   void icas_eval(giac::gen & g,giac::gen & gg,int & reading_file,std::string &filename,giac::context * contextptr){
     gg=protecteval(g,10,contextptr);
   }
@@ -167,6 +168,7 @@
   bool fltk_view(const giac::gen & g,giac::gen & ge,const std::string & filename,std::string & figure_filename,int file_type,const giac::context *contextptr){
     return false;
   }
+  */
 }

 #else
```


Somewhere along the line there was some experimentation with integrating the `xcas::icas_eval` REPL loop into the command-line icas interface, probably so that it can have optional graphics support if compiled with FLTK (e.g. opening windows to view plots), and so it uses this threaded eval loop in order to allow non-blocking I/O while also interacting with a GUI window.

Prior to 1.5.0-25, there was some hackery in `icas.cc` to override `xcas::icas_eval` with a dummy, non-threaded version, at least when compiled without FLTK.  But I guess at some point it was decided that the threaded version worked well-enough in icas as well(??) and the dummy override was not even removed but just...commented out.

Since the threaded eval loop is apparently working well-enough on other platforms I think what I'll do for now, so I can move on to other things, is provide a patch to re-disable the threaded eval just on Cygwin.  It would be good to then investigate what the bug is in the threaded eval, but that is lower priority for the purposes of fixing Sage.



---

archive/issue_comments_382013.json:
```json
{
    "body": "Good work! Did you try reproducing it on non-cygwin and/or plain giac without sage's interface?",
    "created_at": "2019-03-06T13:26:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382013",
    "user": "https://github.com/timokau"
}
```

Good work! Did you try reproducing it on non-cygwin and/or plain giac without sage's interface?



---

archive/issue_comments_382014.json:
```json
{
    "body": "I haven't tried reproducing the problem outside of Sage, but using `giac.eval` is pretty close to just using pexpect directly, and in this case it's useful just to slam the interface with input much faster than a human could, making the deadloop more probable.\n\nI've tried to reproduce the problem in Linux but haven't been successful.  I bet it might be possible to reproduce by reducing the delay in the `usleep()` call quoted above but I'm not sure.",
    "created_at": "2019-03-06T13:48:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382014",
    "user": "https://github.com/embray"
}
```

I haven't tried reproducing the problem outside of Sage, but using `giac.eval` is pretty close to just using pexpect directly, and in this case it's useful just to slam the interface with input much faster than a human could, making the deadloop more probable.

I've tried to reproduce the problem in Linux but haven't been successful.  I bet it might be possible to reproduce by reducing the delay in the `usleep()` call quoted above but I'm not sure.



---

archive/issue_comments_382015.json:
```json
{
    "body": "Replying to [comment:8 embray]:\n> I haven't tried reproducing the problem outside of Sage, but using `giac.eval` is pretty close to just using pexpect directly, and in this case it's useful just to slam the interface with input much faster than a human could, making the deadloop more probable.\n\nYou should be able to do the same thing in a shell: `while :; do echo '1+1;'; done | giac`",
    "created_at": "2019-03-06T13:54:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382015",
    "user": "https://github.com/timokau"
}
```

Replying to [comment:8 embray]:
> I haven't tried reproducing the problem outside of Sage, but using `giac.eval` is pretty close to just using pexpect directly, and in this case it's useful just to slam the interface with input much faster than a human could, making the deadloop more probable.

You should be able to do the same thing in a shell: `while :; do echo '1+1;'; done | giac`



---

archive/issue_comments_382016.json:
```json
{
    "body": "Temporary fix for now.  This patch only impacts Cygwin so I think it should be no problem, but I bumped the patch version for the buildbots anyways.\n\nI'd like to continue to investigate the problem when I can, but for the purposes of getting 8.7 stable on Cygwin again I think we should go ahead and use this patch since it's an easy fix.\n----\nNew commits:",
    "created_at": "2019-03-06T14:56:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382016",
    "user": "https://github.com/embray"
}
```

Temporary fix for now.  This patch only impacts Cygwin so I think it should be no problem, but I bumped the patch version for the buildbots anyways.

I'd like to continue to investigate the problem when I can, but for the purposes of getting 8.7 stable on Cygwin again I think we should go ahead and use this patch since it's an easy fix.
----
New commits:



---

archive/issue_comments_382017.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-03-06T14:56:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382017",
    "user": "https://github.com/embray"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_382018.json:
```json
{
    "body": "Replying to [comment:9 gh-timokau]:\n> Replying to [comment:8 embray]:\n> > I haven't tried reproducing the problem outside of Sage, but using `giac.eval` is pretty close to just using pexpect directly, and in this case it's useful just to slam the interface with input much faster than a human could, making the deadloop more probable.\n> \n> You should be able to do the same thing in a shell: `while :; do echo '1+1;'; done | giac`\n\nYep, I was able to reproduce the same problem like that too.",
    "created_at": "2019-03-06T14:58:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382018",
    "user": "https://github.com/embray"
}
```

Replying to [comment:9 gh-timokau]:
> Replying to [comment:8 embray]:
> > I haven't tried reproducing the problem outside of Sage, but using `giac.eval` is pretty close to just using pexpect directly, and in this case it's useful just to slam the interface with input much faster than a human could, making the deadloop more probable.
> 
> You should be able to do the same thing in a shell: `while :; do echo '1+1;'; done | giac`

Yep, I was able to reproduce the same problem like that too.



---

archive/issue_comments_382019.json:
```json
{
    "body": "Sorry I can't test on cygwin, but are you able to build giacpy_sage on cygwin?\nbecause this cython interface should avoid these problems and provides the samething.",
    "created_at": "2019-03-06T15:30:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382019",
    "user": "https://github.com/frederichan-IMJPRG"
}
```

Sorry I can't test on cygwin, but are you able to build giacpy_sage on cygwin?
because this cython interface should avoid these problems and provides the samething.



---

archive/issue_comments_382020.json:
```json
{
    "body": "Replying to [comment:12 frederichan]:\n> Sorry I can't test on cygwin, but are you able to build giacpy_sage on cygwin?\n> because this cython interface should avoid these problems and provides the samething.\n\nI'll give giacpy a try; I believe I have in the past, and it worked fine.  Nevertheless as long as the pexpect interface exists in sage, and giacpy_sage remains an optional package, it needs to work reliably.\n\nAs for giacpy_sage, what is the plan for that?  Are we going to make it a standard package and perhaps deprecate, and eventually remove, the pexpect interface?",
    "created_at": "2019-03-06T15:41:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382020",
    "user": "https://github.com/embray"
}
```

Replying to [comment:12 frederichan]:
> Sorry I can't test on cygwin, but are you able to build giacpy_sage on cygwin?
> because this cython interface should avoid these problems and provides the samething.

I'll give giacpy a try; I believe I have in the past, and it worked fine.  Nevertheless as long as the pexpect interface exists in sage, and giacpy_sage remains an optional package, it needs to work reliably.

As for giacpy_sage, what is the plan for that?  Are we going to make it a standard package and perhaps deprecate, and eventually remove, the pexpect interface?



---

archive/issue_comments_382021.json:
```json
{
    "body": "Yeah, there's definitely a race condition in this loop.  I haven't confirmed for sure that this is the problem but it probably is.  A cleaned up version of it (with some ifdefs removed) looks like:\n\n\n```cpp\n      giac::make_thread(g1,eval_level(contextptr),icas_eval_callback,&result,contextptr);\n      int status;\n      while (1){\n        // look at other threads\n        int cs=context_list().size(),ci=0;\n        for (;ci<cs;++ci){\n          context * cptr=context_list()[ci];\n          if (cptr!=contextptr)\n            status=check_thread(cptr);\n        }\n\n        // 0 finished, 2/3 debug/wait click\n        status=giac::check_thread(contextptr);\n        if (status<=0){\n          break;\n        }\n\n        giac::thread_eval_status(1,contextptr);\n        if (ctrl_c){\n          if (giac::is_context_busy(contextptr))\n            giac::kill_thread(true,contextptr);\n          ctrl_c=false; interrupted=false;\n        }\n        else\n          usleep(1000);\n      }\n      gg=result;\n    }\n```\n\n\nFirst of all, the \"check other threads\" loop at the beginning appears to be irrelevant in this case, as there is only one thread running anyways.  There is a variable called `thread_eval_status` (which is protected by a mutex) which contains a \"status\" flag of the currently executing \"eval thread\" if any.  As the comment in the code states, a value of 0 means the eval thread is finished and has exited.  The function `giac::check_thread` first checks the value of this flag.  As we can see, the loop is only broken out of if this flag is `<=0` indicating that the thread finished, or possibly an error occurred.  \n\nAfter checking this flag it then immediately, in fact forcibly sets the value of the flag back to `1` with `status=giac::check_thread(contextptr);`.  I'm not sure why it does this but in any case there's an obvious race condition here where the `check_thread()` call could return non-zero so the loop is not broken out of, then the eval thread completes and sets `thread_eval_status=0`, then the loop immediately sets `thread_eval_status=1` again.  The `thread_eval_status` is never set back to `0` and the loop continues forever (even though the thread has actually exited).  If I'm correct that this is the problem it should be possible to reproduce on Linux as well, but it's probably more rare.\n\nI think this code has a few problems.  There are many ways to skin this cat, but in the present implementation it would still be more correct to use a condition variable to signal a change in the `thread_eval_status` flag.  It probably still needs to loop every now and then so that it can check the `ctrl_c` flag set by its `SIGINT` handler, but it could do that with `pthread_cond_timedwait`, just for example.",
    "created_at": "2019-03-06T17:52:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382021",
    "user": "https://github.com/embray"
}
```

Yeah, there's definitely a race condition in this loop.  I haven't confirmed for sure that this is the problem but it probably is.  A cleaned up version of it (with some ifdefs removed) looks like:


```cpp
      giac::make_thread(g1,eval_level(contextptr),icas_eval_callback,&result,contextptr);
      int status;
      while (1){
        // look at other threads
        int cs=context_list().size(),ci=0;
        for (;ci<cs;++ci){
          context * cptr=context_list()[ci];
          if (cptr!=contextptr)
            status=check_thread(cptr);
        }

        // 0 finished, 2/3 debug/wait click
        status=giac::check_thread(contextptr);
        if (status<=0){
          break;
        }

        giac::thread_eval_status(1,contextptr);
        if (ctrl_c){
          if (giac::is_context_busy(contextptr))
            giac::kill_thread(true,contextptr);
          ctrl_c=false; interrupted=false;
        }
        else
          usleep(1000);
      }
      gg=result;
    }
```


First of all, the "check other threads" loop at the beginning appears to be irrelevant in this case, as there is only one thread running anyways.  There is a variable called `thread_eval_status` (which is protected by a mutex) which contains a "status" flag of the currently executing "eval thread" if any.  As the comment in the code states, a value of 0 means the eval thread is finished and has exited.  The function `giac::check_thread` first checks the value of this flag.  As we can see, the loop is only broken out of if this flag is `<=0` indicating that the thread finished, or possibly an error occurred.  

After checking this flag it then immediately, in fact forcibly sets the value of the flag back to `1` with `status=giac::check_thread(contextptr);`.  I'm not sure why it does this but in any case there's an obvious race condition here where the `check_thread()` call could return non-zero so the loop is not broken out of, then the eval thread completes and sets `thread_eval_status=0`, then the loop immediately sets `thread_eval_status=1` again.  The `thread_eval_status` is never set back to `0` and the loop continues forever (even though the thread has actually exited).  If I'm correct that this is the problem it should be possible to reproduce on Linux as well, but it's probably more rare.

I think this code has a few problems.  There are many ways to skin this cat, but in the present implementation it would still be more correct to use a condition variable to signal a change in the `thread_eval_status` flag.  It probably still needs to loop every now and then so that it can check the `ctrl_c` flag set by its `SIGINT` handler, but it could do that with `pthread_cond_timedwait`, just for example.



---

archive/issue_comments_382022.json:
```json
{
    "body": "Actually, I never run this code because I always compile with FLTK. \nThe thread_eval_status is set to 2 (or 3) if a user program is stopped waiting an interaction from the user (2 program is debugged, 3 waits for a user input in the GUI). The FLTK code branch checks that the status is != from 1 then calls the user interaction code, this code will set the status back to 1. The non-FLTK branch should do something similar, but nothing is implemented for that currently, as explained by the comment (// FIXME Debugguer without FLTK) then it sets back the status to 1, but it does not check that status!=1, and that's indeed a potential race condition. I will add this condition and that should fix the issue.",
    "created_at": "2019-03-06T18:55:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382022",
    "user": "https://trac.sagemath.org/admin/accounts/users/parisse"
}
```

Actually, I never run this code because I always compile with FLTK. 
The thread_eval_status is set to 2 (or 3) if a user program is stopped waiting an interaction from the user (2 program is debugged, 3 waits for a user input in the GUI). The FLTK code branch checks that the status is != from 1 then calls the user interaction code, this code will set the status back to 1. The non-FLTK branch should do something similar, but nothing is implemented for that currently, as explained by the comment (// FIXME Debugguer without FLTK) then it sets back the status to 1, but it does not check that status!=1, and that's indeed a potential race condition. I will add this condition and that should fix the issue.



---

archive/issue_comments_382023.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-03-21T12:36:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382023",
    "user": "https://github.com/dimpase"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_382024.json:
```json
{
    "body": "Looks good to me, modulo its working on Cygwin - something I did't test, even though I have access to a Windows 10 VM on Azure, so I potentially could.",
    "created_at": "2019-03-21T12:36:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382024",
    "user": "https://github.com/dimpase"
}
```

Looks good to me, modulo its working on Cygwin - something I did't test, even though I have access to a Windows 10 VM on Azure, so I potentially could.



---

archive/issue_comments_382025.json:
```json
{
    "body": "The best way to test this is to just run something like:\n\n\n\n```\nidx = 0\nwhile True:\n    print(idx)\n    giac.eval('1 + 1')\n    idx += 1\n```\n\n\n(where the 'print' is just to see that it's doing something).  Before long it will stop printing--it can take anywhere from a few dozen to a few thousand iterations--and the `icas` process will sit in a busy loop.",
    "created_at": "2019-03-21T13:04:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382025",
    "user": "https://github.com/embray"
}
```

The best way to test this is to just run something like:



```
idx = 0
while True:
    print(idx)
    giac.eval('1 + 1')
    idx += 1
```


(where the 'print' is just to see that it's doing something).  Before long it will stop printing--it can take anywhere from a few dozen to a few thousand iterations--and the `icas` process will sit in a busy loop.



---

archive/issue_events_068016.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-03-25T10:41:19Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27148#event-68016"
}
```



---

archive/issue_comments_382026.json:
```json
{
    "body": "Moving all blocker/critical issues from 8.7 to 8.8.",
    "created_at": "2019-03-25T10:41:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382026",
    "user": "https://github.com/embray"
}
```

Moving all blocker/critical issues from 8.7 to 8.8.



---

archive/issue_comments_382027.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-03-25T19:44:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382027",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_068017.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-03-25T19:44:06Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27148#event-68017"
}
```



---

archive/issue_comments_382028.json:
```json
{
    "body": "The tests for `sage.interfaces.giac` also hang for me occasionally on CentOS Linux release 7.6.1810 (Core), with Giac using about 3% CPU. I have observed this 4-5 times with Sage 8.8. However, I cannot reliably reproduce the issue \u2013 the infinite loop suggested in comment:17 does not seem to work for me.",
    "created_at": "2019-07-01T18:22:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382028",
    "user": "https://github.com/mwageringel"
}
```

The tests for `sage.interfaces.giac` also hang for me occasionally on CentOS Linux release 7.6.1810 (Core), with Giac using about 3% CPU. I have observed this 4-5 times with Sage 8.8. However, I cannot reliably reproduce the issue – the infinite loop suggested in comment:17 does not seem to work for me.



---

archive/issue_comments_382029.json:
```json
{
    "body": "Replying to [comment:20 gh-mwageringel]:\n> The tests for `sage.interfaces.giac` also hang for me occasionally on CentOS Linux release 7.6.1810 (Core), with Giac using about 3% CPU. I have observed this 4-5 times with Sage 8.8. However, I cannot reliably reproduce the issue \u2013 the infinite loop suggested in comment:17 does not seem to work for me.\n\nThe workaround/patch in this ticket explicitly only targeted Cygwin, but as I found through subsequent investigation, the issue could theoretically impact any platform.\n\nYou could try building giac using the patch from this ticket, but instead of `#ifdef __CYGWIN__` try just `#if 1`.",
    "created_at": "2019-07-02T12:12:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382029",
    "user": "https://github.com/embray"
}
```

Replying to [comment:20 gh-mwageringel]:
> The tests for `sage.interfaces.giac` also hang for me occasionally on CentOS Linux release 7.6.1810 (Core), with Giac using about 3% CPU. I have observed this 4-5 times with Sage 8.8. However, I cannot reliably reproduce the issue – the infinite loop suggested in comment:17 does not seem to work for me.

The workaround/patch in this ticket explicitly only targeted Cygwin, but as I found through subsequent investigation, the issue could theoretically impact any platform.

You could try building giac using the patch from this ticket, but instead of `#ifdef __CYGWIN__` try just `#if 1`.



---

archive/issue_comments_382030.json:
```json
{
    "body": "Replying to [comment:21 embray]:\n> You could try building giac using the patch from this ticket, but instead of `#ifdef __CYGWIN__` try just `#if 1`.\n\nYes, this seems to solve the problem on my machine. I tested this quite extensively and have not been able to replicate the problem since I applied the patch.",
    "created_at": "2019-07-02T20:53:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382030",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:21 embray]:
> You could try building giac using the patch from this ticket, but instead of `#ifdef __CYGWIN__` try just `#if 1`.

Yes, this seems to solve the problem on my machine. I tested this quite extensively and have not been able to replicate the problem since I applied the patch.



---

archive/issue_comments_382031.json:
```json
{
    "body": "Did you upgrade to the latest version of giac (1.5.0-61)? I thought I fixed that 4 months ago. I'd prefer not to waste time checking again...",
    "created_at": "2019-07-03T05:08:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382031",
    "user": "https://trac.sagemath.org/admin/accounts/users/parisse"
}
```

Did you upgrade to the latest version of giac (1.5.0-61)? I thought I fixed that 4 months ago. I'd prefer not to waste time checking again...



---

archive/issue_comments_382032.json:
```json
{
    "body": "Replying to [comment:23 parisse]:\n> Did you upgrade to the latest version of giac (1.5.0-61)?\n\nNo.",
    "created_at": "2019-07-03T06:30:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382032",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:23 parisse]:
> Did you upgrade to the latest version of giac (1.5.0-61)?

No.



---

archive/issue_comments_382033.json:
```json
{
    "body": "Replying to [comment:24 gh-mwageringel]:\n> Replying to [comment:23 parisse]:\n> > Did you upgrade to the latest version of giac (1.5.0-61)?\n> \n> No.\nI've opened #28101 to do an update.",
    "created_at": "2019-07-03T06:57:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27148#issuecomment-382033",
    "user": "https://github.com/dimpase"
}
```

Replying to [comment:24 gh-mwageringel]:
> Replying to [comment:23 parisse]:
> > Did you upgrade to the latest version of giac (1.5.0-61)?
> 
> No.
I've opened #28101 to do an update.
