# Issue 16240: implement Dirichlet series

Issue created by migration from Trac.

Original creator: rws

Original creation time: 2014-06-12 16:28:24

CC:  kcrisman mkamalakshya jonhanke slelievre

Keywords: moebius, zeta, sigma, euler_phi, euler

kcrisman in comment:20 of #8383:
> Did somebody say [defining Dirichlet series](http://ask.sagemath.org/question/2540/defining-dirichlet-series)?  [Here is an implementation](http://www.wordpress.jonhanke.com/Software/Sage__Dirichlet_series/Dirichlet_series.sage) that I haven't had time to try out but which might be a good basis for that.  [This sage-support thread](https://groups.google.com/forum/#!msg/sage-support/v7TFXKbAV0E/) may also be relevant, though I don't know how advanced that psage code is.


---

Attachment


---

Comment by kcrisman created at 2014-07-08 13:42:48

I've attached the relevant file as well.


---

Comment by mkamalakshya created at 2014-08-16 11:05:23

New commits:


---

Comment by kcrisman created at 2015-03-17 14:10:17

See also how to [do it in Pari](http://math.stackexchange.com/questions/1193708/question-about-direuler-command-in-pari-gp).  Indeed, it has multiplication of Dirichlet series and so forth.  Maybe that could be used somehow, since it already exists and is presumably well-tested.


---

Comment by rws created at 2015-03-22 16:18:01

This is not correct. The commit author (contrary to the committer) should show as `Jonathan Hanke`. This is done by using the `--author` option of `git ci`. I will change that.


---

Comment by rws created at 2015-03-22 16:26:10

Changing status from new to needs_review.


---

Comment by rws created at 2015-03-22 16:26:10

I also moved the file under `modular/`.
----
New commits:


---

Comment by rws created at 2015-03-22 16:26:26

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-03-22 17:01:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-03-23 12:35:00

About PARI: `dirmul` and `dirdiv` already work in Sage. `direuler` is difficult because of the syntax `direuler(p=a,b,expr)` involving a loop variable and an expression to be evaluated.


---

Comment by git created at 2015-03-23 15:15:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jj created at 2015-03-24 19:46:58

Hi

Just an idea:

Shouldn't it be possible to define/implement Dirichlet series by specifying a function
(from Z/ideals/whatever) for their coefficients?

I guess that would require some base class (which ideally would accept/parse/recognize
functions from Z/whatever) for the coefficient functions.
It would do parsing tasks, printing(!) of functions, arithmetic operations/dirichlet
convolutions/etc... (Completely) multiplicative functions would be a "nice" subclass.
Ideally the implementation would at least support basic Dirichlet series example.

Again: Just an idea (for either an extension or a new implementation/ticket).

Regards,
Jonas


---

Comment by kcrisman created at 2015-03-24 19:54:13

You are quite right - so, does Pari support this?  If not, then it's probably a fairly big job and should be a different ticket (while you should make sure that this ticket remains agnostic with respect to your questions so the backend can be changed).  If yes, hopefully we could just hook into their stuff for anything nontrivial.


---

Comment by rws created at 2015-03-25 06:54:11

At the moment this is implemented:

```
sage: Lminus4 = dirichlet_series([kronecker(-4,n) for n in range(1,21)]); Lminus4
1 + -1/(3^s) + 1/(5^s) + -1/(7^s) + 1/(9^s) + -1/(11^s) + 1/(13^s) + -1/(15^s) + 1/(17^s) + -1/(19^s) + O(21^(-s))
sage: zeta = dirichlet_series([1]*20); zeta
1 + 1/(2^s) + 1/(3^s) + 1/(4^s) + 1/(5^s) + 1/(6^s) + 1/(7^s) + 1/(8^s) + 1/(9^s) + 1/(10^s) + 1/(11^s) + 1/(12^s) + 1/(13^s) + 1/(14^s) + 1/(15^s) + 1/(16^s) + 1/(17^s) + 1/(18^s) + 1/(19^s) + 1/(20^s) + O(21^(-s))
sage: zeta * Lminus4^(-1)
1 + 1/(2^s) + 2/(3^s) + 1/(4^s) + 2/(6^s) + 2/(7^s) + 1/(8^s) + 2/(9^s) + 2/(11^s) + 2/(12^s) + 2/(14^s) + 1/(16^s) + 2/(18^s) + 2/(19^s) + O(21^(-s))
```

Please give a concrete example what you like to see!


---

Comment by rws created at 2015-03-25 09:27:21

I just found this:
https://github.com/williamstein/psage/blob/master/psage/lseries/eulerprod.py#L1128

EDIT: This has much more generality and lets this ticket look like a child's toy, so there 8P


---

Comment by jdemeyer created at 2015-03-25 09:42:09

Concerning the dependencies #18038 and #18041: if you want to use `direuler` _now_, you can still do it using strings: `pari("direuler(...)")` should work just like in GP:

```
sage: pari("direuler(p=2, 20, 1/(1-X)/(1-p*X))")
[1, 3, 4, 7, 6, 12, 8, 15, 13, 18, 12, 28, 14, 24, 24, 31, 18, 39, 20, 42]
```



---

Comment by jj created at 2015-03-25 19:35:15

rws:

I'm in particular hoping for an exact implementation of arithmetic/multiplicative functions:


```
id = ArithmeticFunctions().id()
sigma0 = ArithmeticFunction(lambda n: sigma0(n))
id*id == sigma0 // Dirichlet convolution
```


...


```
f = DirichletSeries(id)*DirichletSeries(id)
f == DirichletSeries(sigma0)
f[91234154]
f // nice representations:
=> sum_{n in Z} (sum_{d|n} 1)
or: sum_{n in Z} sigma0(n)
```


...

Those certainly form a nice subset of possible coefficient functions / dirichlet series.
More generally I was hoping for the possibility to specify Dirichlet series /
coefficient functions exactly, not only up to some precision.
E.g. (bad example) DirichletSeries(lambda n: sin(n))
or e.g. by specifying an (exact) generating series as e.g. a rational function

Calculating the n'th coefficient from these to get a DirichletSeries as now
is at least rather simple.

Other ideas: exact verification of identities (not only up to precision),
nice representations/output of coefficient functions after operations (hard),
support functions from ideals (TODO: figure out the correct category for the domain
of coefficient functions).

I am aware that this is not a small task and might not be easily possible in python.
But I hope you get the idea of what I had in mind...


---

Comment by kcrisman created at 2015-03-25 20:24:18

That is probably a bit beyond this ticket, though maybe not.  It would be nice to have such "symbolic" ones too.


---

Comment by rws created at 2015-03-26 09:29:59

Replying to [comment:24 jj]:
> {{{
> f = DirichletSeries(id)*DirichletSeries(id)
> f == DirichletSeries(sigma0)
> f[91234154]
> f // nice representations:
> => sum_{n in Z} (sum_{d|n} 1)
> or: sum_{n in Z} sigma0(n)
> }}}
> nice representations/output of coefficient functions after operations (hard),
That would first need conversion of the g.f. into divisor sum form. Another ticket.
> {{{
> id = ArithmeticFunctions().id()
> sigma0 = ArithmeticFunction(lambda n: sigma0(n))
> id*id == sigma0 // Dirichlet convolution
> }}}
That would need ability to compute a g.f. from the coefficients. I think this is possible but hard.
> support functions from ideals (TODO: figure out the correct category for the domain
> of coefficient functions).
And a third ticket.

So this ticket would prepare for the others by providing creation from expressions of a limited form (polynomial fractions with generator from `zeta(a*s+b)` and `L(c)`).


---

Comment by jj created at 2015-03-26 19:14:24

Replying to [comment:26 rws]:
> Replying to [comment:24 jj]:
> > {{{
> > f = DirichletSeries(id)*DirichletSeries(id)
> > f == DirichletSeries(sigma0)
> > f[91234154]
> > f // nice representations:
> > => sum_{n in Z} (sum_{d|n} 1)
> > or: sum_{n in Z} sigma0(n)
> > }}}
> > nice representations/output of coefficient functions after operations (hard),
> That would first need conversion of the g.f. into divisor sum form. Another ticket.
>

There are (at least) two different (exact) approaches:
- Coefficient functions
- Generating functions (as q-series?), I am not entirely sure what you mean by it...

I was emphasizing on the coefficient function part.
Clearly it is possible to define dirichlet series by specifying the coefficient function (as a normal function). It is even relatively simple to implement all kind of operations.
Individual coefficients could also be calculated (up to some precision).
What is hard is getting a "nice representation" (e.g. a divisor sum form as you mentioned above).
- One idea might be to somehow "decompile" a function into source code / some at least nicer form.
- One idea might be to use symbolic expression (rather limited).
- Another idea might be to implement very basic coefficient functions and allow all kind of operations with them (using ast(?)/whatever) to be as flexible as possible with the combinations (include as many of the popular examples as possible).
- Finally we could simply use the old representation by just calculating the coefficients up to some precision. The advantage would be that "precision" is no longer part of the series, only of the representation.

> > {{{
> > id = ArithmeticFunctions().id()
> > sigma0 = ArithmeticFunction(lambda n: sigma0(n))
> > id*id == sigma0 // Dirichlet convolution
> > }}}
> That would need ability to compute a g.f. from the coefficients. I think this is possible but hard.

The relation between coefficient functions and generating series might be a challenge. I wonder what approach is more suitable. Maybe the two concepts both have interesting cases that cannot easily be translated to the other way. So maybe both ways should be supported (?).

> > support functions from ideals (TODO: figure out the correct category for the domain
> > of coefficient functions).
> And a third ticket.
> 
> So this ticket would prepare for the others by providing creation from expressions of a limited form (polynomial fractions with generator from `zeta(a*s+b)` and `L(c)`).

I was thinking in very general terms ("any" function from Z). That should be fairly simple (even with operations on series) and allow the calculation of the coefficients up to an arbitrary precision. Example:

```
(F+G).cf = lambda n: F.cf(n) + G.cf(n)
(F*G).cf = lambda n: sum(F.cf(d)*G.cf(n/d) for d in divisors(n))
```


However it will be very hard to get "nice" representation of the coefficient functions.

Maybe "polynomial fractions with genertore from zeta(a*s+b) and L(c)" is more powerful, I don't know.

Side remark: *Dirichlet series* could/should be viewed as something like a *Fourier transform* of an *Arithmetic function*.


---

Comment by rws created at 2015-03-27 06:48:18

Replying to [comment:27 jj]:
> - Generating functions (as q-series?), I am not entirely sure what you mean by it...
See https://en.wikipedia.org/wiki/Generating_function#Dirichlet_series_generating_functions


---

Comment by jj created at 2015-03-27 15:09:23

Replying to [comment:28 rws]:
> Replying to [comment:27 jj]:
> > - Generating functions (as q-series?), I am not entirely sure what you mean by it...
> See https://en.wikipedia.org/wiki/Generating_function#Dirichlet_series_generating_functions

Yes but that doesn't explain how the g.f. is implemented (in an exact way).
For some families of Dirichlet series the corresponding ordinary (or exponential)
generating series could be stored as a rational function (e.g. 1/(1-q)).

I assumed you meant this when refering to g.f.
How else could you store the g.f. in an exact matter?


---

Comment by rws created at 2015-03-27 15:17:16

Replying to [comment:29 jj]:
> How else could you store the g.f. in an exact matter?
Nearly all D.g.f.'s I have seen (and certainly all that generate your arithmetic functions) are polynomials in A. `zeta(as+b)`, B. `L(chi(c,d), s)`, C. `(1-e^(-s+f))`, with a,b,c,d,e,f integer. Okay, this is not a proof, but well supported by data in the OEIS. So I want to store that polynomial.


---

Comment by kcrisman created at 2015-03-27 16:41:14

I agree that both of these representations are useful and desired.  Would it be possible to implement the basics here - esp. since it turns out Pari has a lot of the functionality we need - and then put the generating function stuff (which I would also use) in a separate ticket?  I'm just concerned that this will never happen despite a lot of enthusiasm.


---

Comment by jj created at 2015-03-28 16:47:01

Unfortunately experience shows that this concern is well founded.
So yes, I agree.


---

Comment by jj created at 2015-03-30 16:48:17

Just for your information:

I started some preliminary (poc) test implementation of arithmetic functions (no tests/documentation etc). The first idea was to use symbolic expressions but they don't work well together with sums which are absolutely crucial for operations on arithmetic functions...

The test implementation is available on u/jj/arith_functions:

http://git.sagemath.org/sage.git/commit/?id=526e1ae40f94cff95e5dc6926208b831643edfb4

Here is a simple example:

```
sigma3 = ArithmeticFunction(lambda n: sigma(n,3), lambda n,_: "sigma({},3)".format(n), lambda n,_: "\\sigma_{{3}}\\left({}\\right)".format(n))
sigma3^2
show(sigma3^2)
(sigma3^2)(5)
```



---

Comment by rws created at 2015-03-31 08:31:30

Replying to [comment:33 jj]:
> I started some preliminary (poc) test implementation of arithmetic functions (no tests/documentation etc).
> 
> http://git.sagemath.org/sage.git/commit/?id=526e1ae40f94cff95e5dc6926208b831643edfb4

I think you should open an enhancement ticket for this branch, just to make it possible to discuss specifics. Note: I am supporting your effort of formulating the algebraic side of these functions. Note too that Dirichlet series represent a superset of these functions, so your code cannot serve as the parent ring implementation of this ticket, and a different ticket is needed.


---

Comment by jj created at 2015-04-01 21:22:26

Ok, I created a ticket: http://trac.sagemath.org/ticket/18102

Regarding Dirichlet series: It seems that rational functions (over what?) might provide a nice (internal) basis for how (exact) Dirichlet series are stored. The coefficients can be calculated and it should be possible to automatically define a corresponding coefficient function. This would still benefit from a nice base class for arithmetic functions (in particular since we know to construct/represent the coefficient function, this additional information could be "passed on" to / used by the arithmetic function element).


---

Comment by rws created at 2015-04-12 09:10:00

Changing status from needs_work to needs_review.


---

Comment by rws created at 2015-04-12 09:10:00

This version now supports generating functions of a certain form. Please see the documentation. This should suffice as a first version. Further development possibilities were already discussed in this ticket.

Please review.
----
New commits:


---

Comment by vdelecroix created at 2015-04-12 11:35:56

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-04-12 11:35:56

Hello,

1. there is no need to add method `dirmul` and `dirdiv` to the pari `gen` object. This is taken care automatically since #17631. Doctesting is cool thoug. But move it somewhere else.

2. Why is this new module in `sage.modular`? It makes no sense.

3. You should try harder to use `pari` and not `gp`. Since #17631, most functions are available directly in `pari`.

4. `DirichletSeries` would better inherit from `RingElement`. In that case, you must not define `__add__`, `__mul__`, `__div__` etc but `_add_`, `_mul_`, `_div_`. That way you will get benefits from coercion (e.g. multiplication by scalars). You might have a look to polynomials (in `sage.rings.polynomials.*` or power series (in `sage.rings.power_series_*`).

5. What is the purpose of the commented code?

6. The error must be new style ones. Please use

```
    raise MyError("my message")
```

  instead of

```
    raise MyError, "my message"
```


Vincent


---

Comment by rws created at 2015-04-12 12:50:53

Replying to [comment:38 vdelecroix]:

Thanks, I accept points 1 and 6 but:

> 2. Why is this new module in `sage.modular`? It makes no sense.
The Dirichlet characters are there too. I don't see why not.

> 3. You should try harder to use `pari` and not `gp`. Since #17631, most functions are available directly in `pari`.
But not those needing closures, see comment:16 and #18038

> 4. `DirichletSeries` would better inherit from `RingElement`. In that case, you must not define `__add__`, `__mul__`, `__div__` etc but `_add_`, `_mul_`, `_div_`. That way you will get benefits from coercion (e.g. multiplication by scalars). You might have a look to polynomials (in `sage.rings.polynomials.*` or power series (in `sage.rings.power_series_*`).
This is clearly a separate ticket.

> 5. What is the purpose of the commented code?
I didn't want to erase useful ideas of the original author.


---

Comment by vdelecroix created at 2015-04-12 13:40:30

Hello,

Replying to [comment:39 rws]:
> Replying to [comment:38 vdelecroix]:
> 
> > 2. Why is this new module in `sage.modular`? It makes no sense.
> The Dirichlet characters are there too. I don't see why not.

Because `sage.modular` is intended for modular forms. A Dirichlet serie is not necessarily a modular form. To me, modules and submodules should work by inclusion. Or at least try to.

I do not see Dirichlet series as a subset of modular forms. I perfectly understand the reason why it is here, but it would be better in `sage.functions` or `sage.rings`. The directory `sage.modular` really contains too much stuff. This is historical as people that initiated Sage were very interested in modular forms.

> > 3. You should try harder to use `pari` and not `gp`. Since #17631, most functions are available directly in `pari`.
> But not those needing closures, see comment:16 and #18038

I see! Do you mind adding a comment in the docstring saying that as soon as #18038 is ready, this can be modified?

> > 5. What is the purpose of the commented code?
> I didn't want to erase useful ideas of the original author.

Why letting it commented then?

Vincent


---

Comment by vdelecroix created at 2015-04-13 14:24:41

Replying to [comment:40 vdelecroix]:
> Hello,
> 
> Replying to [comment:39 rws]:
> > Replying to [comment:38 vdelecroix]:
> > 
> > > 2. Why is this new module in `sage.modular`? It makes no sense.
> > The Dirichlet characters are there too. I don't see why not.
> 
> Because `sage.modular` is intended for modular forms. A Dirichlet serie is not necessarily a modular form. To me, modules and submodules should work by inclusion. Or at least try to.
> 
> I do not see Dirichlet series as a subset of modular forms. I perfectly understand the reason why it is here, but it would be better in `sage.functions` or `sage.rings`. The directory `sage.modular` really contains too much stuff. This is historical as people that initiated Sage were very interested in modular forms.

What do you think of `sage.lfunctions`?

Vincent


---

Comment by rws created at 2015-04-13 14:35:26

Replying to [comment:41 vdelecroix]:
> What do you think of `sage.lfunctions`?
What else would you put in there (I have no idea myself)?


---

Comment by vdelecroix created at 2015-04-13 14:41:19

Replying to [comment:42 rws]:
> Replying to [comment:41 vdelecroix]:
> > What do you think of `sage.lfunctions`?
> What else would you put in there (I have no idea myself)?

You can first have a look to what is already in.


---

Comment by rws created at 2015-04-13 14:44:48

I vaguely remember having had a look at some time but now I see you're right.


---

Comment by jj created at 2015-04-13 15:03:31

Replying to [comment:44 rws]:
> I vaguely remember having had a look at some time but now I see you're right.

Note that L-function / L-series usual refer to functions / series satisfying
some very specific (more restrictive) set of axioms (AC/FE/etc) - in contrast
to Dirichlet series or abstract Dirichlet series. So there is definitely some
justification for introducing a new class (at least if it supports exact
representation).

Also if I remember correctly the L-function is not an exact representation but
also restricted by precision. What I would like to see is support for exact
abstract Dirichlet series, e.g. by using symbolic coefficient functions or
by using exact generating series in terms of rational functions.

If they are not implemented in an exact way I am curious about the background:
How / in what context will they be used? Why is a new class required?

In any case I agree that Dirichlet series don't belong to sage.modular.

Best
    Jonas


---

Comment by vdelecroix created at 2015-04-13 15:13:25

Hello Jonas,

Replying to [comment:45 jj]:

Thanks for your input. After reading your comment I think that one reasonable option is to create a new module `dirichlet_series` and move `lfunctions` in there. What do you think?

Vincent


---

Comment by kcrisman created at 2015-04-13 15:15:53

I'm not sure that would be as useful of a top-level module, and might break some existing code that imports them.  I agree it would be confusing to have this in `lfunctions`, but not as confusing as having it somewhere else!


---

Comment by vdelecroix created at 2015-04-13 15:18:02

Replying to [comment:47 kcrisman]:
> I'm not sure that would be as useful of a top-level module, and might break some existing code that imports them.  I agree it would be confusing to have this in `lfunctions`, but not as confusing as having it somewhere else!

It is not a problem to keep the old `lfunctions` module as an alias for `dirichlet_series.lfunctions` (if we really care, there can be a deprecated alias). But for matter of code organisation that would be better to have `lfunctions` included in `dirichlet_series`.

Vincent


---

Comment by git created at 2015-04-14 08:31:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-04-14 08:33:48

Changing status from needs_work to needs_review.


---

Comment by rws created at 2015-04-14 08:33:48

That addresses all discussed issues save the new module, which IMHO should be a separate ticket and discussed on sage-devel.


---

Comment by vdelecroix created at 2015-04-14 08:59:15

Hello,

Thanks for moving it! You need to add an entry to your new file to get it included in the documentation (this is one line in `$SAGE_ROOT/doc/en/reference/lfunctions/index.rst`).

Vincent


---

Comment by vdelecroix created at 2015-04-14 09:22:25

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-04-14 09:22:25

Hello,

6 more questions/issues.

7. Why are you importing the alias `dirichlet_series` and not `DirichletSeries` in the global namespace?

8. How do I get the coefficients of the Dirichlet L functions obtained with the command `dirichlet_L(3,2,s)`?

9. There are several issues with the documentation:
 - you forgot `::` at line 107 (in `DirichletSeries` class documentation).
 - the `INPUT` block does not follow the convention (see the developer guide, section Documentation String)
 - doctests are missing from many important functions (e.g. `base_ring`, `is_Eulerian`, `has_infinite_precision`, `list`)

10. In `__mul__` I do not understand

```
R = self.base_ring() 
try: 
    _ = RR(other)
```

  Did you want to write `R(other)`? If so it is very wrong since if you multiply `2.0` with a Dirichlet serie with rational coefficients you would end up with rational coefficients as

```
sage: QQ(3.2314)
16157/5000
```

  You should really use coercion here (i.e. the item 4 in [comment:38 comment:38]) or do stronger type check such as `parent(other) is self.base_ring()`.

11. This should work

```
sage: D1 = dirichlet_series([1,1,1])
sage: D1 + 1
Traceback (most recent call last):
...
```

(also related to item 4 in [comment:38 comment:38]).

12. What is the purpose of this nested `MaskFunction` class?

Vincent


---

Comment by git created at 2015-04-14 14:53:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-04-14 14:55:09

Replying to [comment:52 vdelecroix]:
> 8. How do I get the coefficients of the Dirichlet L functions obtained with the command `dirichlet_L(3,2,s)`?
Analogous to polynomial coefficients, now added as example:

```
sage: D=dirichlet_series(dirichlet_L(3,2,s))
sage: D.list()
[1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1, 0, 1, -1]
sage: D.list(5)
[1, -1, 0, 1, -1]
```

> 10. In `__mul__` I do not understand
> {{{
> R = self.base_ring() 
> try: 
>     _ = RR(other)
> }}}
>   Did you want to write `R(other)`?
I haven't looked extensively at Jon's code as long as it worked.
>   You should really use coercion here (i.e. the item 4 in [comment:38 comment:38]) or do stronger type check such as `parent(other) is self.base_ring()`.

> 11. This should work
> {{{
> sage: D1 = dirichlet_series([1,1,1])
> sage: D1 + 1
> Traceback (most recent call last):
> ...
> }}}
No, this is a feature request. With this ticket you can do as well:

```
sage: D1 = dirichlet_series([1,1,1])
sage: one = dirichlet_series(1)
sage: D1 + one                                                                          
2 + 1/(2^s) + 1/(3^s) + O(4^(-s))                                                       
```

> 12. What is the purpose of this nested `MaskFunction` class?
As this is only of developer interest I added at l.156: 

```
                # the specific form of the factors returned by Maxima
                # (see ticket #18081) makes masking necessary
                arg = dirichlet_series._mask_exp_factors(arg)
```

The rest should be addressed with the latest commit.


---

Comment by rws created at 2015-04-14 14:55:58

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-08-03 07:11:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-06-13 08:29:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kcrisman created at 2016-07-13 17:48:46

What is the status of review on this?  I.e., what does the latest reviewer/author (rws) believe still needs review?  I personally dearly wish for convolution/DP but I think I won't get that on this ticket and better to have this in than not.


---

Comment by slelievre created at 2016-09-09 22:24:46

Changing keywords from "moebius, zeta, sigma, euler_phi, euler" to "moebius, zeta, sigma, euler_phi, euler, Dirichlet series".


---

Comment by rws created at 2017-04-11 15:22:23

Squashed, used lazy import, and completed coverage.
----
New commits:


---

Comment by kcrisman created at 2017-04-11 15:33:57

Curious whether this supports e.g. a Dirichlet series from the Möbius function (I couldn't find an example like that, other than the evident one where you take the appropriate version of zeta - but that is a theorem, not a series).  

It looks quite nice.  Ralf, what piece of this would you say still needs review?  After all, I think at least some of it you have in essence reviewed Jon Hanke's work.  So it would be nice to know what would still need a good hard look.

Final note - I'm confused by the `dummy`.  Is that something from pari or Sage?


---

Comment by rws created at 2017-04-12 15:20:27

Replying to [comment:65 kcrisman]:
> Curious whether this supports e.g. a Dirichlet series from the Möbius function (I couldn't find an example like that, other than the evident one where you take the appropriate version of zeta - but that is a theorem, not a series).

I don't understand. The Dirichlet g.f. of the Moebius function is `1/zeta(s)` via `Sum_{n >= 1} mu(n)/n^s = 1/zeta(s)` so you can get it via:

```
sage: var('s')
s
sage: dirichlet_series(1/zeta(s))
1 + -1/(2^s) + -1/(3^s) + -1/(5^s) + 1/(6^s) + -1/(7^s) + 1/(10^s) + -1/(11^s) + -1/(13^s) + 1/(14^s) + 1/(15^s) + -1/(17^s) + -1/(19^s) + O(20^(-s))
sage: _.list()
[1, -1, -1, 0, -1, 1, -1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1, 0, -1, 0]
```


> It looks quite nice.  Ralf, what piece of this would you say still needs review?  After all, I think at least some of it you have in essence reviewed Jon Hanke's work.  So it would be nice to know what would still need a good hard look.

The conversion from g.f. to the form Pari uses for generation is unpublished research. If I insist on a review it will never go into Sage so what do I say? I tested it on all known D.g.f.s collected from the OEIS. But there are surely future cases where it will fail.

> Final note - I'm confused by the `dummy`.  Is that something from pari or Sage?  

It is only used internally for pattern matching. If there is a next version pattern matching will be done in Pynac.


---

Comment by kcrisman created at 2017-04-13 01:10:59

Replying to [comment:66 rws]:
> Replying to [comment:65 kcrisman]:
> > Curious whether this supports e.g. a Dirichlet series from the Möbius function (I couldn't find an example like that, other than the evident one where you take the appropriate version of zeta - but that is a theorem, not a series).
> 
> I don't understand. The Dirichlet g.f. of the Moebius function is `1/zeta(s)` via `Sum_{n >= 1} mu(n)/n^s = 1/zeta(s)` so you can get it via:

What I meant was precisely that I knew you could do that, but one might want to just plug Moebius in if (say) one didn't know this fact.  (And not just for finitely many values.)  But apparently not, which is fine for now.

> The conversion from g.f. to the form Pari uses for generation is unpublished research. If I insist on a review it will never go into Sage so what do I say? I tested it on all known D.g.f.s collected from the OEIS. But there are surely future cases where it will fail.
> 

Sure.  I just meant that since this is currently "needs review", what things would still need to be looked at?  You can presumably vouch for quite a bit not due to your self.


---

Comment by rws created at 2017-04-13 06:20:11

Replying to [comment:67 kcrisman]:
> Sure.  I just meant that since this is currently "needs review", what things would still need to be looked at?  You can presumably vouch for quite a bit not due to your self.

I think it's ready but I can't set positive, can I?


---

Comment by kcrisman created at 2017-04-13 15:30:22

> > Sure.  I just meant that since this is currently "needs review", what things would still need to be looked at?  You can presumably vouch for quite a bit not due to your self.
> 
> I think it's ready but I can't set positive, can I?

Typically not, unless you really didn't add anything beyond window-dressing.  Which is why I'm asking what you _did_ add - I guess a lot of the examples, right?  Any actual code?  (Since you squashed I guess that won't be visible in the log.)  Then anyone (hopefully me) who is ready can just review the pieces that are "new since you", if that makes sense.


---

Comment by rws created at 2017-04-13 17:11:32

Jon's code was completely rewritten, so you would have to review it all.


---

Comment by kcrisman created at 2017-04-13 18:05:13

Okay, that's a bigger job, but good for us to know.  I didn't realize that.  No, typically we don't review external Pari code, though, so no worries there.


---

Comment by rws created at 2017-11-28 07:08:25

Import arith errors from patchbot.


---

Comment by rws created at 2017-11-28 07:08:25

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-02-23 07:19:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2018-02-23 07:20:14

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2019-03-09 08:09:14

New commits:


---

Comment by vdelecroix created at 2019-03-09 09:39:56

Changing status from needs_review to needs_info.


---

Comment by vdelecroix created at 2019-03-09 09:39:56

Why Dirichlet series derive from `SageObject`? Don't you want the Dirichlet series to form an algebra?


---

Comment by kcrisman created at 2019-05-02 17:28:04

> Why Dirichlet series derive from `SageObject`? Don't you want the Dirichlet series to form an algebra?

Yes, since these are formal Dirichlet series, ideally they would be, see e.g. Shapiro Chapter 4.6.


---

Comment by kcrisman created at 2019-08-21 02:11:53

See also #26098 which possibly might overlap this (or even supersede it?).


---

Comment by git created at 2021-07-15 18:57:39

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mantepse created at 2021-07-30 14:06:39

See #32309 for a lazy variant.


---

Comment by slelievre created at 2021-08-28 15:30:50

See also this call for feature requests posted on sage-devel:

- https://groups.google.com/g/sage-devel/c/ADTbjMZc4ng


---

Comment by mantepse created at 2021-08-29 16:21:37

Beware that there seem to be typos in the list given at https://drive.google.com/file/d/0B4PmRyK1JXgHY29aa00zZnhib1k/

For example,

```
(1+pX)/(1-X)     A048250 sum of squfr. div.             Z(s)Z(s-1)/Z(2s-1)
```

but A048250 has Dirichlet g.f.: zeta(s)*zeta(s-1)/zeta(2*s-2).


---

Comment by mantepse created at 2021-08-30 20:31:12

Here is a better reference: http://dx.doi.org/10.35834/mjms/1316032830
