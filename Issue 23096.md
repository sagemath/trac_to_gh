# Issue 23096: Improve calculation of sigma invariants for projective morphisms

Issue created by migration from Trac.

Original creator: bhutz

Original creation time: 2017-06-28 15:06:38

CC:  gjorgenson

The sigma invariants are the elementary symmetric functions evaluated at the multipliers. Currently they are computed over QQbar which can be very time consuming. They can be computed via resultants which is much faster and includes maps defined over polynomial rings.


---

Comment by bhutz created at 2017-06-28 15:11:37

New commits:


---

Comment by bhutz created at 2017-06-28 19:34:21

This is ready for a review.


---

Comment by bhutz created at 2017-06-28 19:34:21

Changing status from new to needs_review.


---

Comment by bhutz created at 2017-06-28 19:43:33

Changing status from needs_review to needs_work.


---

Comment by bhutz created at 2017-06-28 19:43:33

err. I think the definition here is not right. There should be one multiplier per periodic point (with multiplicity), not one per cycle?


---

Comment by bhutz created at 2017-06-28 20:10:52

well, it seems both definitions are used in the world.

 - define the sigma using every period n point (McMullen, Silverman). Really they define it from the fixed points of the nth iterate.

 - define the sigma via cycles (Milnor)

In both cases they define invariants of the moduli space, so it's not that one is right or wrong, they are just different.  I'm tempted to introduce a 'type' parameter that takes values 'cycles' or 'points' to both this function and multiplier_spectrum.


What do you think?


---

Comment by git created at 2017-06-28 21:29:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2017-06-28 21:30:50

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2017-06-28 21:30:50

I implemented it with the 'type' switch since both version appear in the literature.


---

Comment by gjorgenson created at 2017-06-28 21:41:02

That seems good to me also. I'll get started on reviewing the functionality.


---

Comment by gjorgenson created at 2017-07-03 06:55:19

Ok I looked this over and did some testing. The new method of computing the sigma invariants appears to be correct (and much nicer than the previous implementation!), and everything seems to be working properly. I only found a few really minor issues:

In sigma_invariants:
    - line 3725, multiplicity is spelled incorrectly (also occurs line 3565 in multiplier_spectra)
    - line 3750, add another space around the hyphen (also occurs line 3579)
    - line 3780, there is an extra newline
    - need an input check in place to make sure the base ring is (or has its coefficients in) a number field
    - perhaps put the "type" input check on line 3897 that can raise a value error with the other input checks at the beginning (same comment for multiplier_spectra)
    - it also might be good to add an example with formal=True illustrating the different options type='cycle', 'point'


---

Comment by git created at 2017-07-05 16:53:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2017-07-05 16:54:56

I think I fixed all those, so you can take another look.


---

Comment by gjorgenson created at 2017-07-05 18:12:40

Those changes look good. However I don't think the part of sigma_invariants that looks for a conjugation to avoid the point at infinity makes sense in positive characteristic:


```
sage: P.<x,y> = ProjectiveSpace(GF(3),1)
sage: H = End(P)
sage: f = H([x^2 - 2*y^2, y^2])
sage: f.sigma_invariants(1)
Traceback (click to the left of this block for traceback)
...
ZeroDivisionError: Inverse does not exist.
```


When working over a finite field, if it is possible to construct a morphism P1-->P1 that has every point of P1 as a n-periodic point that seems like it could also be a problem.


---

Comment by bhutz created at 2017-07-05 18:19:17

Changing status from needs_review to needs_work.


---

Comment by bhutz created at 2017-07-05 18:19:17

Good catch. I'll need to rethink how I deal with that case.


---

Comment by git created at 2017-07-06 00:21:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2017-07-06 00:23:38

ok. Here's another try at this. I'm no longer trying to move infinity out of the fixed points and instead am dealing with the multiplier at infinity and its multiplicities as a special case.

Interestingly, it looks like this exposed an issue with one of the earlier examples and also an issue when there are cycles of different periods with the same multiplier.


---

Comment by bhutz created at 2017-07-06 00:23:38

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2017-07-06 13:02:02

on further thought, I think this still fails to do the right thing where there are cycles of different length with the same multipliers.


---

Comment by bhutz created at 2017-07-06 13:02:02

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-07-06 18:12:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2017-07-06 18:16:35

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2017-07-06 18:16:35

I solved the cycle problem by building up the sigmas by divisor of n. Since the product of the dynatomic polys is the periodic point equation, this lets me assign a specific cycle length to each multiplier. Essentially it takes the formal period as the period. This has the advantage of being computable and always returns the same number of sigmas.


---

Comment by gjorgenson created at 2017-07-09 05:36:08

Changing status from needs_review to needs_work.


---

Comment by gjorgenson created at 2017-07-09 05:36:08

The new type='cycle' functionality looks good to me. While looking over the code I noticed just a few more superficial issues:

- line 3754: add period after "Default: False"
- line 3962: there's an extra newline
- the expressions of the form

```
e_inf = 1
while (y**e_inf).divides(fix_poly):
    e_inf += 1
e_inf -= 1
```

   could be shortened slightly to

```
e_inf = 0
while (y**(e_inf + 1)).divides(fix_poly):
    e_inf += 1
```

- change the code starting on line 3956 from

```
res = fix_poly.resultant(mult_poly, S.gen(0)).univariate_polynomial()
#take infinty into consideration
if inf_per.divides(n):
   res = res*((S.gen(1) - self.multiplier(inf, n)[0,0])**e_inf)
   res = res.univariate_polynomial()
```

   to

```
res = fix_poly.resultant(mult_poly, S.gen(0))
#take infinty into consideration
if inf_per.divides(n):
   res = res*((S.gen(1) - self.multiplier(inf, n)[0,0])**e_inf)
res = res.univariate_polynomial()
```

   otherwise there is a weird multiplication issue:

```
sage: P.<x,y> = ProjectiveSpace(QQ,1)
sage: H = End(P)
sage: f = H([x^2 + x*y + y^2, y^2 + x*y])
sage: f.sigma_invariants(1)
```

   The same issue occurs in the formal=True block version of this code starting at 3925. It looks like this actually always occurs with multiplication with elements of the original polynomial ring after calling .univariate_polynomial() for a constant polynomial:

```
sage: R.<s,t> = PolynomialRing(QQ, 2)
sage: f = R(1)
sage: f.univariate_polynomial()*t
```

   fails, but

```
sage: R.<s,t> = PolynomialRing(QQ, 2)
sage: f = s
sage: f.univariate_polynomial()*t
```

   is fine.
- the lines of the form `res = res*((S.gen(1) - self.multiplier(inf, n)[0,0])**e_inf)`
   could be rewritten `res *= (S.gen(1) - self.multiplier(inf, n)[0,0])**e_inf`


---

Comment by git created at 2017-07-09 15:35:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2017-07-09 15:41:29

Thanks. updated.

The issue with the univariate_polynomial of a constant is actually expected behavior. If you don't pass univeraite_polynomial a polynomial ring it creates it own. There is no reason it should be able to interact well with another polynomial ring. This is actually a little bit relevant to this ticket. In the new version I'm only calling univariate_polynomial once, so I don't rely anymore on Sage trying to 'do the right thing' in the background with multiplication of univariate and multivariate polynomial rings.


---

Comment by bhutz created at 2017-07-09 15:41:29

Changing status from needs_work to needs_review.


---

Comment by gjorgenson created at 2017-07-09 18:53:11

Changing status from needs_review to positive_review.


---

Comment by gjorgenson created at 2017-07-09 18:53:11

Ok that makes sense. With these new changes everything looks good to me.


---

Comment by bhutz created at 2017-07-21 19:37:37

Changing component from algebraic geometry to dynamics.


---

Comment by vbraun created at 2017-08-03 22:11:24

Resolution: fixed
