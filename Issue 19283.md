# Issue 19283: implement random triangulations in a bijective way

Issue created by migration from https://trac.sagemath.org/ticket/19520

Original creator: chapoton

Original creation time: 2015-11-04 14:18:42

CC:  ncohen

Keywords: random graph

This will provide a fast uniform (almost) random generator for triangulations.

This uses the algorithm via a bijection with blossoming trees due to Schaeffer and Poulalhon.


---

Comment by chapoton created at 2015-11-04 14:19:20

New commits:


---

Comment by chapoton created at 2015-11-04 14:19:20

Changing status from new to needs_review.


---

Comment by ncohen created at 2015-11-04 15:58:37

Hello,

If you add this then I do not think that we need our former 'randomtriangulation' anymore.

Nathann

P.S.: The difference between `listA += listB` and `listA.extend(listB)` is that the first one creates a copy og `listA` first.


---

Comment by chapoton created at 2015-11-04 16:36:25

Well, this is a different "random triangulation", not the same distribution at all. Mine is better because it's almost uniform, but nevertheless one could keep the other.

Should I use `.append` and `.extend` everywhere possible ?


---

Comment by git created at 2015-11-04 16:44:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-04 21:07:32

Hello Frédéric,

Yours is clearly better, and unless there is a specific reason why we should
keep the old one (please enlighten me) I do not see the point to have it around.

First, because 'graphs.RandomTriangulation' should preferably be what you
implement now: at least the notion of 'random' is clear (and what one would expect).

If you insist on keeping the other, then perhaps it could be a (non-default)
option of `RandomTriangulation`? Let us not kee code just for the sake of not
throwing anything away. What you did is what `RandomTriangulation` should be. If
it had been like this from the start, we certainly wouldn't have added the other
function later.

> Should I use `.append` and `.extend` everywhere possible ?

Yes, please. Let us not waste ressources when we can easily avoid it.

Nathann


---

Comment by git created at 2015-11-05 08:58:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-05 09:01:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-05 09:03:01

ok, done. So this ticket now replaces the old implementation of `RandomTriangulation` by a new one.


---

Comment by git created at 2015-11-05 11:08:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-05 14:34:11

Hello Frédéric,

I only read the content of `auxiliary_random_word` so far (one cannot say that the construction appears very explicitly in the paper `:-/`) and added a small commit at `public/19520`, mainly to point to where the constraints on the binary word are provided in the paper.

Is there any reason why you add +3n and -n in to 'height', instead of compution '3*number_of_1 - number_of_zeroes' like in Proposition 4.2?

Nathann


---

Comment by chapoton created at 2015-11-05 15:23:04

Hello,

yes, this part is indeed already not clear. I am not sure to be convinced myself
that the algorithm that I wrote to conjugate the binary word is correct. But it works..

The idea is (like for usual conjugation into Dyck words) to assign a height at every step of the path, and to cut where the height is minimal or almost minimal here...


---

Comment by ncohen created at 2015-11-05 15:39:58

> yes, this part is indeed already not clear. I am not sure to be convinced myself
> that the algorithm that I wrote to conjugate the binary word is correct.

I'm sorry but I will not accept a code without being convinced that it is correct. Please make sure that this part does what it should, and then set this ticket to `needs_review`.

Nathann


---

Comment by ncohen created at 2015-11-05 15:39:58

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-11-05 18:35:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-05 18:49:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-05 20:33:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-05 20:34:20

ok, should be much better now. I have added doc and explanations.
And indeed my code was awful, and working only by miracle.


---

Comment by chapoton created at 2015-11-05 20:34:20

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2015-11-06 13:48:38

Changing status from needs_review to needs_info.


---

Comment by ncohen created at 2015-11-06 13:48:38

Hello Frédéric,

Here is another (incomplete) review:

- The names of the two functions `contour_and_graph_from_word` and
  `auxiliary_random_word` are not very descriptive of what they do, and this is
  not really a problem since they are not meant to be called directly by the
  user. As they do not appear in the documentation anyway, could you turn them
  into private functions by adding a `_` at the beginning of their name?

  If you do so, please update the sphinx links.

- As a french person I understand why 'f' would denote a leaf, but that probably
  isn't the appropriate letter. Is there actually anything stopping you from
  using 'inner' and 'leaf' instead of 'i' and 'f'?

- As my notion of up/down is apparently the opposite of what the paper use, I
  rearranged the sentences of the doc of `contour_and_graph_from_word` so that
  'away/toward the root' appears before the notion of up/down (which matches the
  paper, as in your original text).

- What do you call 'every inner vertex has two leaves' ? In the sequence
  `[1,0,0,0,0,0]` that you use as an example in the docstring of
  `contour_and_graph_from_word`, the root vertex (that you consider to be an
  'inner' vertex) has exactly one neighbor, which is not a leaf.

- In `contour_and_graph_from_word` the variable `active_vertex` was always equal
  to `inner_stack[-1]`. I removed it. Less variables to keep track of --> easier
  to understand.

- This is a search operation in a list
  {{{
  inner_stack[-1] in leaf_stack:
  }}}
  This is not very efficient. Same for `leaf_stack.remove(x)`, which first looks
  for an occurrence of `x` in `leaf_stack`, then removes it.

  Fortunately none of these operations is necessary, for if there is a leaf to
  add to the current inner vertex it is the last element of `leaf_stack` (which
  also means that all 'search' operations actually read the list completely).

- Where exactly is the algorithm of `RandomTriangulation` to be found in
  [PS2006]_? In the documentation you say that it comes from this paper,
  but... where? `O_o`

The modifications I mention can be found at public/19520.

Thanks,

Nathann


---

Comment by chapoton created at 2015-11-06 14:30:50

Hello Nathann, thanks for your time and your work.

0) adding underscores to names, done

1) using 'in' and 'lf' instead, done

> - What do you call 'every inner vertex has two leaves' ? In the sequence
>   `[1,0,0,0,0,0]` that you use as an example in the docstring of
>   `contour_and_graph_from_word`, the root vertex (that you consider to be an
>   'inner' vertex) has exactly one neighbor, which is not a leaf.

No, no, in the example `1,0,0,0,0,0`, the inner-root does have two leaves.

One must be careful about what is called the root. There is a leaf-root and an inner-root. In the paper, the leaf-root is considered as the "true" root. And so the inner root would have only one leaf.

In the algorithms, it turns out to be more convenient to use the inner-root as "true" root, and to transform the leaf-root to become the rightmost leaf of the inner-root. In this case, the inner root also has two leaves.


> - Where exactly is the algorithm of `RandomTriangulation` to be found in
>   [PS2006]_? In the documentation you say that it comes from this paper,
>   but... where? `O_o`

This algorithm is my own implementation
of the bijective map described in section 2.1. I am not sure that it is really efficient. I perform the closure moves by successive reductions of the contour word,
until there is no sequence (in,in,in,lf) in the cyclic contour word.

> The modifications I mention can be found at public/19520.

Let us work together on the branch public/19520
----
New commits:


---

Comment by ncohen created at 2015-11-06 14:35:19

Hellooooo,

> No, no, in the example `1,0,0,0,0,0`, the inner-root does have two leaves.

Argggggg, sorry. I wrote this comment then spent more time understanding what was actually going on. This comment was indeed incorrect, but I hope that you will find nothing wrong in my modifications of doc/code.

> In the algorithms, it turns out to be more convenient to use the inner-root as "true" root, and to transform the leaf-root to become the rightmost leaf of the inner-root. In this case, the inner root also has two leaves.

Yepyep. I agree that the code seems consistent with this definition: all internal vertices have two leaves.

At first, I expected that discovering a leaf resulted in two consecutive '0' in the word, as going there (one 0) and going back (one 0) would take two moves. Turns out that 'discovering a leaf' takes only one 0.

This is the reason why I added in the documentation a comment about the expected length of a sequence with respect to its associated tree.

> This algorithm is my own implementation
> of the bijective map described in section 2.1. I am not sure that it is really efficient. I perform the closure moves by successive reductions of the contour word,
> until there is no sequence (in,in,in,lf) in the cyclic contour word.

I see. Could you add in the doc some pointers toward the corresponding sections of the paper (e.g. section 2.1) so that it is easier to know while reading the code which part of the paper you were 'translating'?

Thanks,

Nathann


---

Comment by git created at 2015-11-06 14:47:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-06 17:03:53

needs review?


---

Comment by git created at 2015-11-06 18:18:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-06 18:19:37

Changing status from needs_info to needs_review.


---

Comment by chapoton created at 2015-11-06 18:19:37

now, yes. I had forgotten to add some underscores..


---

Comment by vdelecroix created at 2015-11-06 23:28:34

Replying to [comment:2 ncohen]:
> Hello,
> 
> If you add this then I do not think that we need our former 'randomtriangulation' anymore.
> 
> Nathann
> 
> P.S.: The difference between `listA += listB` and `listA.extend(listB)` is that the first one creates a copy og `listA` first.

Where did you see that?

```
sage: l = [1,2]
sage: m = l
sage: l += [4,5]
sage: m
[1, 2, 4, 5]
```


See also [this stackoverflow question](http://stackoverflow.com/questions/9766387/different-behaviour-for-list-iadd-and-list-add)


---

Comment by ncohen created at 2015-11-07 09:16:48

Hmmmmmmmmmm.... You are right. And so 'l += b' is not equivalent to 'l = l + b'. Love it. I'll change it back to what it was, for then the original code was easier to read.

Nathann


---

Comment by chapoton created at 2015-11-07 09:47:01

But maybe `.append` is still a little bit faster than `+=` because there is no "try except" involved ?

NOTA BENE: I intend to use the same code to create a simplicial complex instead. I would rather do that in another ticket, if you don't mind.


---

Comment by ncohen created at 2015-11-07 09:49:51

try/except? Where?

From what I understand '+=' is an alias of 'extend'. 

Nathann


---

Comment by ncohen created at 2015-11-07 09:50:30

> NOTA BENE: I intend to use the same code to create a simplicial complex instead. I would rather do that in another ticket, if you don't mind.

I do not understand. Do you mean that you do not want the change `extend-> '+='`  to be done here because you fear a conflict with another branch?


---

Comment by chapoton created at 2015-11-07 09:57:43

No, see the first answer in the stackoverflow. It says `+=` tries iadd then add.

And my note bene has nothing to do with that, it was just information about my later plans. Sorry for the confusion.


---

Comment by ncohen created at 2015-11-07 10:04:17

Oh, so that's the exception your worry about. Well, I'd say that until your code proves to not be sufficiently fast we have no need for this kind of optimisation (if it makes a difference). Avoiding a copy of the list was sufficiently non-negligible, but that's not so bad. If it ever becomes a problem, your code can easily be turned into more efficient Cython anyway `:-)`

Nathann


---

Comment by chapoton created at 2015-11-07 10:06:01

Ok; I agree. But please don't waste your time to put back +=, it is just as readable now IMHO.


---

Comment by ncohen created at 2015-11-07 10:08:17

Okayyyy !!!


---

Comment by ncohen created at 2015-11-07 12:20:29

Hellooo Frédéric,

I am reading the 'main' part of the algorithm, and trying to understand how you find the subsequences of the form 'in,in,in,lf,in'. It seems (I am not sure) that you do this manually. Here is something that you may like:


```
sage: 'abcdefghihijk'.index('def')
3
```


This 'index' function of str also takes an optional argument that means that the search should not start from the first character of the string, but from some later index. Eg

```
sage: 'abcdefghihijk'.index('def',5)
...
ValueError: substring not found
```


If you do what I think you are doing, then you are rewriting this .index function.

Now, you cannot directly use this function, because it is a member of 'str' and not a member of 'list'. And your list is a sequence of pairs. Thus, it could be 'made to work' by creating a 'copy' of your list that only contains the indication of in/lf. Something like that

```
sage: w=[('in',3)]*5+[('lf',4)]+[('in',3)]
sage: s="".join(x[0] for x in w)
sage: s.index('inininlfin')
4
```


With this index you can now do whatever operation on w you need.

This requires a copy of the list into a string, though on the other hand it would make your code much easier to read -- if you actually do what I think you do.

What do you think?

Alternatively, you could 'rewrite' an index function that applies to lists. Something like:

```
sage: def find_pattern(l):
....:     for i in range(len(l)-4):
....:         if 'in' == l[i] == l[i+1] == l[i+2] == l[i+4] and l[i+3] == 'lf':
....:             return i
```


It is not the 'best algorithmic way to compute it', but it would work. Do you think something like that may improve the code?

Nathann


---

Comment by chapoton created at 2015-11-07 21:06:18

Hmm. Well, I can see that one could use `index` as you suggest. Does this improve the code ? I don't know if it will be simpler at the end.

I am currently running over the contour, contracting when I meet 'in,in,in,lf' (and  removing the next 'in' at the same time) ; this may happen several times in one run. Then doing it again and again, until nothing can be done. This must be done cyclically, so I shift and start again if something can still happen at the end. All this is certainly rather awkward. It may be possible to do all that in just one or two passes, by using a stack to remember how many 'in' one has at our disposal when meeting one 'lf', so that one can in some sense go backward when needed. I think I have seen some allusion to that kind of idea in the article.

So, what to do ? 

0) Keep more or less the current algo

1) try to make it clearer, maybe by using `index`

2) try to find an optimal or at least better algo, maybe with stacks

I have no clear opinion, but I would rather avoid doing a lot of work.


---

Comment by ncohen created at 2015-11-07 21:23:21

Hello Frédéric,

My last comment was written with 'if' everywhere, because I was not sure of what you were doing exactly by looking at the code. Hence, my message was both a request for a confirmation that I understood correctly what you were doing, and a proposal to rewrite the code in a more readable way.

I had totally missed the constraint that those merging operations had to be made cyclically, for instance. And right now, though I have 'some idea' of what you try to do in the code, I still do not understand it.

My proposition was not mainly a proposition to rewrite it more efficiently (and the 'string' of index version does have the 'copy' drawback I mentionned) but to rewrite it more clearly.

Tomorrow I will have a long bus trip, and I can try to rewrite a cyclic merging algorithm using 'index' that will only work on a string, leaving you to fill it with whatever it does at the same time with the graph.

At the moment I do not understand what your code does, and I try to do what I can to understand it and make life easier for whoever next will read it.

Nathann


---

Comment by ncohen created at 2015-11-08 07:34:59

Hello Frédéric,

I thought about it for a while and ended up with the following design: a function scans for a pattern through a list l and -- if it finds it -- rotates l so that it starts with that pattern.

Here is the code, hoping that it may help rewrite your code a bit more clearly:


```python
def rotate_l_to_next_pattern(pattern):
    global l
    # Find 'pattern' in l, and rotates l so that l starts with 'pattern'.
    n = len(n)
    for i in range(n):
        if all(l[(i+ii)%n] == x for ii,x in enumerate(pattern)):
            l = l[i:] + l[:i]
            return True
    return False

l = [0,1,0,0,0,0,0,1,1,0,1,0,1]
while rotate_l_to_next_pattern([0,1]):
    l[0] = 2
```


Nathann


---

Comment by git created at 2015-11-09 16:01:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-09 16:04:25

I have tried to simplify my code, but I have not used your proposal.
I have essentially kept my algo, but removed some variables, and reorganised a little bit.
Some parts are still not very nice. Tell me what you think.


---

Comment by git created at 2015-11-09 16:17:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-09 18:09:01

Helloooooo Frédéric,

Thanks, this code is a bit easier to understand (and I almost get what it does)!

I admit that I am still looking with longing at the `rotate_l_to_next_pattern` function I gave in an earlier comment hoping that it could fit, but so far I have a couple of questions left:

1) It seems that you consider the word as a circular word, but I am not convinced that your code would notice the pattern 'in,in,in,lf' if it appeared 'wrapped around' in this way: 'lf,in,in,in,in,in,in'. Is that correct? My previous code was written to handle this situation.

2) I do not understand the purpose of the second condition in `if not stack_in or (x != stack_in[-1]):`. I thought you were only looking for the pattern 'in,in,in,lf' but it seems that some additional constraint has to be added?

Also, could you add a check at the end of your function that the graph you return has the expected number of edges (as it is a planar triangulation)?

Thanks,

Nathann


---

Comment by git created at 2015-11-09 19:05:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-09 19:10:11

lo

> 1) It seems that you consider the word as a circular word, but I am not convinced that your code would notice the pattern 'in,in,in,lf' if it appeared 'wrapped around' in this way: 'lf,in,in,in,in,in,in'. Is that correct? My previous code was written to handle this situation.

This is taken care near the end of the 'while' loop, which bring all final 'in' to the beginning on the word, and start again.
 
> 2) I do not understand the purpose of the second condition in `if not stack_in or (x != stack_in[-1]):`. I thought you were only looking for the pattern 'in,in,in,lf' but it seems that some additional constraint has to be added?

This is because, when we meet in,in,in,lf, the next letter is always another in, that we must not add twice to the stack of in. Maybe one could add it there, instead, if you feel it is simpler.
 
> Also, could you add a check at the end of your function that the graph you return has the expected number of edges (as it is a planar triangulation)?

done
 
Thanks to you!


---

Comment by chapoton created at 2015-11-10 09:57:41

Hmm, I am putting this to needs_work, because I now have some doubts on
my algorithm.. Let me think about that.


---

Comment by chapoton created at 2015-11-10 09:57:41

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-11-10 10:42:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-10 10:44:10

ok, this should be good now. And the code is getting simpler. Back to needs review.


---

Comment by chapoton created at 2015-11-10 10:44:10

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2015-11-10 10:44:51

Yooooooo,

> ok, this should be good now. And the code is getting simpler. Back to needs review.\
Okay thanks! You'll get it today.

Nathann


---

Comment by ncohen created at 2015-11-10 22:18:50

Hello Frédéric,

You say in a comment that 'in1,in2,in3,lf' gets replaced by 'in1,in3', but your code removes the last two elements of the stack (which should be `in2,in3`). 

Thus, I get the impression that your code replaces 'in1,in2,in3,lf' by 'in1'.

Nathann


---

Comment by chapoton created at 2015-11-11 08:24:35

At this point, yes, but just the next step is another 'in3', that gets added.


---

Comment by ncohen created at 2015-11-12 17:40:24

Hello Frédéric,

I read in the paper that the order in which the replacements are performed did not matter (page 7, right before 'balanced trees').

I tried to simplify the code a bit, and ended up with the commit I just pushed to this ticket's public branch. Could you give me your opinion?

Thanks,

Nathann


---

Comment by git created at 2015-11-12 17:40:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-12 19:22:15

ok, it suits me. As far as I can tell, this is good to go

The resulting graphs can be nicely displayed by Ivan Kuckir graph viewer.


---

Comment by ncohen created at 2015-11-12 19:25:10

> ok, it suits me. As far as I can tell, this is good to go

Okay. I'll do a final check once at home and it will probably be reviewed tonight.

> The resulting graphs can be nicely displayed by Ivan Kuckir graph viewer.

What is that?

Nathann


---

Comment by chapoton created at 2015-11-12 19:35:55

> > The resulting graphs can be nicely displayed by Ivan Kuckir graph viewer.
> 
> What is that?

#13418


---

Comment by ncohen created at 2015-11-12 19:37:15

Don't you want to help me improve 'g.show(method='js')' instead? I am tring to add a zooming feature right now. It already works in d3.js but I'm not exactly a js expert.

Nathann


---

Comment by ncohen created at 2015-11-13 10:16:35

Errrrrrr... Don't know if it is my fault, but I just noticed that `:-P`


```
sage: print graphs.RandomTriangulation(7).vertices()
[0, 1, 2, 3, 4, 'a', 'b', ('in', 0), ('in', 1), ('in', 2), ('in', 3), ('in', 4)]
```


Nathann


---

Comment by git created at 2015-11-13 10:42:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-13 10:44:09

Arg... Sorry sorry, I was about to push it but I am currently experimenting with the distribution, to check if everything is 'uniform as expected'. It was my fault, and I did not expect you to fix it for me `^^;`


---

Comment by ncohen created at 2015-11-13 10:53:22

Hmmmmmmm... Okay okay. From looking at the distribution I can't say that I quite like it, but then I forgot too much about statistics to prove it in any way `:-/`

Nathann


---

Comment by chapoton created at 2015-11-13 10:56:02

The distribution is not exactly uniform, because it is uniform for "rooted" triangulations, and the presence of automorphisms breaks the uniformity. But in the large size limit, only a negligible number of triangulations do have automorphisms, so this becomes a better and better approx to uniform distribution.


---

Comment by git created at 2015-11-13 11:13:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-13 11:13:42

If you don't see anything wrong in this last commit, you can set the ticket to `positive_review`. Thanks!

Nathann


---

Comment by git created at 2015-11-13 11:15:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-13 11:16:05

ok, let it be. Thanks a lot for your collaboration.


---

Comment by chapoton created at 2015-11-13 11:16:05

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-11-16 01:35:08

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2015-11-16 01:35:08

Merge conflict, try again with the next beta


---

Comment by git created at 2015-11-23 08:25:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-11-23 08:26:43

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2015-11-24 13:01:26

Resolution: fixed
