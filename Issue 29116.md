# Issue 29116: fix parent of q-Catalan numbers

Issue created by migration from https://trac.sagemath.org/ticket/29353

Original creator: chapoton

Original creation time: 2020-03-17 19:33:34

at n=0 and n=1

plus some pep8 details in the modified file


---

Comment by chapoton created at 2020-03-17 19:34:02

New commits:


---

Comment by chapoton created at 2020-03-17 19:34:02

Changing status from new to needs_review.


---

Comment by tscrim created at 2020-03-17 22:32:48

Two questions:

On a similar but technically unrelated issue: What about `q_fatorial` at `n=0`? I think that should be special-cased to be `q_int(0, q)`. Similarly for `q_binomial` when using `cyclotomic` and `n = 0,1`.

Is `{0, 1}:` better (i.e., faster) than `[0, 1]:`? I have almost always seen the latter in Python code.

Otherwise LGTM.


---

Comment by chapoton created at 2020-03-18 07:27:53

Containment in sets seems to be faster (but I am not so sure):

```
sage: a = {range(200,400)}
sage: b = list(range(200,400))
sage: %timeit 123 in a
The slowest run took 28.00 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 5: 267 ns per loop
sage: %timeit 123 in b
10000 loops, best of 5: 33.2 Âµs per loop

sage: a = {0,1}
sage: b =[0,1]
sage: %timeit 5 in a
The slowest run took 29.97 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 5: 252 ns per loop
sage: %timeit 5 in b
The slowest run took 29.55 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 5: 307 ns per loop
```


I will take care of the q_factorial case too.


---

Comment by git created at 2020-03-18 07:33:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2020-03-18 07:46:57

I found that page about containment in sets

https://www.geeksforgeeks.org/sets-in-python/


---

Comment by tscrim created at 2020-03-18 08:25:10

Containment in sets is definitely faster, but you also have to create the set every time. Now that I am in front my computer, I can test this:

```
sage: def test_set(i):
....:     if i in {0,1}:
....:         return True
....:     return False
sage: def test_list(i):
....:     if i in [0,1]:
....:         return True
....:     return False
sage: %timeit test_set(1)
1000000 loops, best of 5: 372 ns per loop
sage: %timeit test_set(2)
1000000 loops, best of 5: 353 ns per loop
sage: %timeit test_list(1)
1000000 loops, best of 5: 344 ns per loop
sage: %timeit test_list(2)
1000000 loops, best of 5: 346 ns per loop
```

Surprisingly, tuples are the most optimized:

```
sage: def test_tuple(i):
....:     if i in (0,1):
....:         return True
....:     return False
sage: %timeit test_tuple(1)
1000000 loops, best of 5: 322 ns per loop
sage: %timeit test_tuple(2)
1000000 loops, best of 5: 328 ns per loop
```

Not that this matters too much, but just a question I had because it is not something I had seen before. You can set it to a positive review if you don't care enough to change it. I don't care either way.

Sorry, I missed the parent test for `q_binomial` and the code does cover the `(n,k) = (1,1)` case by taking the `k = min(k, n-k)`.

Thank you for fixing these bugs.


---

Comment by chapoton created at 2020-03-18 08:46:06

ok, setting to positive. Thanks for the review


---

Comment by chapoton created at 2020-03-18 08:46:06

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-03-22 23:20:43

Resolution: fixed
