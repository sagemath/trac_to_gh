# Issue 10852: specializations for symmetric functions

Issue created by migration from https://trac.sagemath.org/ticket/10930

Original creator: mantepse

Original creation time: 2011-03-14 08:19:49

Assignee: tbd

CC:  jbandlow zabrocki tscrim darij

Keywords: principal specialization, exponential specialization, symmetric functions

This patch implements the principal and exponential specialisations for symmetric functions as given in Stanley, Enumerative Combinatorics, Section 7.8.

Unfortunately, the patch currently has several problems:
1) it seems that always the default code in sf/sfa.py is called, I don't know why
2) I do not know how to give the desired default argument 1 the correct type in exponential_specialization
3) I guess one should rather implement this for quasi-symmetric functions, but I do not know enough about these currently
4) the documentation and sensible tests are still missing


---

Comment by mantepse created at 2011-03-14 08:20:48

patch for principal and exponential specialization


---

Comment by mantepse created at 2011-03-14 10:05:51

Changing assignee from tbd to mantepse.


---

Attachment


---

Comment by mantepse created at 2011-03-14 10:06:32

Changing priority from major to minor.


---

Comment by mantepse created at 2011-03-14 10:06:32

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by jbandlow created at 2011-03-14 17:58:34

Hi Martin,

Thanks submitting this!  A quick response to your points above.  I'm not sure what you mean by point (1)... can you elaborate?

For point (2), you can use None as the default value, and then do

```
    if q is None:
        q = self.parent().base_ring().one()
```

as the first line of your code.

For point (3), quasisymmetric functions are still somewhat immature--in particular they are not in Sage proper. So this is not too big of a concern.

For point (4), yes, there should be more doc and tests.  In particular, I find tests like

```
    all( e[mu].principal_specialization(4) == e[mu].expand(4)(1,q,q^2,q^3) for mu in Partitions(4) )
```

particularly convincing.


---

Comment by mantepse created at 2011-03-15 07:32:12

Hi Jason!

Many thanks for your quick comments.

1) Using trace I find


```
sage: S = SymmetricFunctions(QQ); s=S.s(); f = s[2,1]
sage: trace("f.principal_specialization()")
> <string>(1)<module>()

ipdb> s
--Call--
> /home/martin/SAGE/local/lib/python2.6/site-packages/sage/combinat/sf/sfa.py(1653)principal_specialization()
   1652 
-> 1653     def principal_specialization(self, n=infinity, q=var('q')):
   1654         r"""

ipdb> s
> /home/martin/SAGE/local/lib/python2.6/site-packages/sage/combinat/sf/sfa.py(1681)principal_specialization()
   1680         """
-> 1681         from sage.combinat.sf.sf import SymmetricFunctions
   1682         p = SymmetricFunctions(self.parent().base_ring()).p()

ipdb> 
```

but I was hoping that the principal specialisation from schur.py would be called.

2) Well, currently the actual value of 1 is not used at all (I test q==1 and call principal_specialization without passing q).  So my question really is: some day somebody might implement something where the q is actually used.  Is it better then if the default is None and the doc says, None should always mean one?

Thanks again!


---

Comment by mantepse created at 2011-03-19 19:20:24

I fixed indenting, bugs and added documentation and tests.  Feedback welcome!


---

Comment by jbandlow created at 2011-03-28 18:22:02

Hi Martin, a few more points:

1) If I'm not mistaken, the function f in the exponential_specialization code for Schur functions is returning the product of the hooks of partition. This can also be done with ` Partition(partition).hook_product(1) `

2) You do not give the result of the test in line 275 of the Schur function code.

3) See [this](http://groups.google.com/group/sage-devel/t/f5a9c012f6299a9e) and make sure that your patch satisfies these criteria. Please ask the sage-combinat list if you have any questions about these.

4) Once you have completed all of this, mark the patch as 'Needs Review' (by clicking the button at the bottom of the page). Then the 'Patchbot' will automatically apply and test your code.

Again, many thanks for your good work!


---

Comment by mantepse created at 2011-03-29 07:02:20

Replying to [comment:7 jbandlow]:

Jason, might it be that you were looking on a different version of the patch?  There is no exponential_specialization for Schur functions (I use the generic version) and there is no test in line 275...

On the other hand, I just noticed several other problems with the code.  Eg., ` s[1].exponential_specialization() ` doesn't work right now.  I also should include tests for calling without any arguments...


---

Comment by jbandlow created at 2011-04-04 13:59:54

Replying to [comment:8 mantepse]:

Hi Martin,

Sorry for the delay. Yes I was looking at the wrong version of the patch last time. Everything on the combinat queue now looks good to me. I think that all that is left is for you to prepare the patch for sage as mentioned in my point (3) above.


---

Comment by mantepse created at 2019-04-03 00:38:24

Changing status from new to needs_review.


---

Comment by mantepse created at 2019-04-03 00:38:24

New commits:


---

Comment by git created at 2019-04-03 08:34:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2019-04-15 16:16:50

Your description of the definition of `principle_specialization` is clear, but all of your `exponential_specialization` functions need a description.
The one place that you have a description, it doesn't make sense to me because you seem to explain q-exponential_specialization, but not exponential_specialization and they don't clearly seem to be compatible by setting q=1.  It wouldn't hurt to add a reference to the definition in the documentation either.


---

Comment by zabrocki created at 2019-04-15 16:16:50

Changing status from needs_review to needs_work.


---

Comment by git created at 2019-04-15 17:28:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-04-15 17:28:38

Thank you, that was an oversight.  I hope it is better now!


---

Comment by mantepse created at 2019-04-15 18:50:10

Changing status from needs_work to needs_review.


---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by mantepse created at 2019-11-29 14:13:09

ping?


---

Comment by zabrocki created at 2019-12-01 18:22:13

I think that this needs to be more compatible with Hall-Littlewood and Macdonald symmetric functions because this seems to be one place that they might be used.  If the base ring already has a q in it, this creates an expression with two q's.

```
sage: Ht = SymmetricFunctions(QQ['q,t'].fraction_field()).macdonald().Ht()
sage: Ht[2].principal_specialization()
(q*q + 1)/(q^3 - q^2 - q + 1)
sage: _.parent()
Fraction Field of Univariate Polynomial Ring in q over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
```

and I think that is wrong.  What about:

```
try:
    q = self.base_ring()('q')
except:
    q = self.base_ring()["q"].fraction_field().gen()
```

Currently in 'powersum.py' you have just the last line.

Also maybe should have doc tests comparing the principal specialization to plethysm.

```
sage: one=f.parent().one()
sage: f.principal_specialization(q=q)==f(one/(1-q)).coefficient([])
True
sage: f.principal_specialization(n=4,q=q)==f(one*(1-q^4)/(1-q)).coefficient([])
True
```



---

Comment by tscrim created at 2019-12-01 21:46:24

I am not sure I agree with you Mike that the `q` for the principle specialization should be the same `q` as for the Macdonald. For example, at `t=0`, the Macdonald `q` counts the affine grading whereas the principle specialization `q` counts the principle grading after restricting to a finite-type representation. Because of this, I feel they should be different variables (and I would try to have a different name, perhaps `q1`, if `'q' in self.base_ring().variable_names_recursive()`). Could you explain more why do you think they should be the same `q`?


---

Comment by zabrocki created at 2019-12-01 22:27:45

I was thinking of applications like The Delta Conjecture (e.g. see Theorem 5.1).  My comment is not specific to Macdonald polynomials though, it was just an example.  Whatever variable you use, if it is in your base ring it seems that you should be using that letter and not adding another copy of it by default.  If you want to use another variable in your specialization you can always add one.


---

Comment by tscrim created at 2019-12-02 02:02:09

I see. I think that violates the principle of least surprise: someone trying this method changes the variable in their base ring and suddenly the polynomial behaves differently. If you really wanted that base ring variable, then I think you should pass it as a parameter. So if you want a different variable name, then we should change the default name if q is already on the base ring.


---

Comment by zabrocki created at 2019-12-02 03:45:37

From my understanding what you are saying you are recommending behavior like:

```
sage: SymmetricFunctions(QQ).s()[1].principal_specialization()
1/(1-q)
sage: SymmetricFunctions(SR).s()[1].principal_specialization()
1/(1-z)
```



---

Comment by mantepse created at 2019-12-02 06:56:25

I think it is in the long run more user friendly, if the rule that determines which name is used for a variable, or whether a symbol is actually reused, is as simple and predictable as possible.  Therefore I would be rather against a "renaming" rule.


---

Comment by tscrim created at 2019-12-02 22:44:08

So you would rather it be a part of the base ring then Martin? Or same name (with possibly repeated variable name)?


---

Comment by mantepse created at 2019-12-03 06:43:22

I don't mind either way.  I guess that having two q's which are different in one expression is more likely to be overlooked, so I guess that checking whether q is there is less bad.  I would think that even the casual user might be aware that the base ring contains a q.

Is this OK for you?

A question: it turns out that the explicit `fraction_field()` in 

```
try:
    q = self.base_ring()('q')
except:
    q = self.base_ring()["q"].fraction_field().gen()
```

is unnecessary.  Should I keep it anyway?


---

Comment by tscrim created at 2019-12-03 10:54:03

If you are visually looking at output, then I agree, but if you are programming something, then it will break if you are doing something assuming that the output is a univariate polynomial ring. It is also much easier for the user to pass in the `q` of the base ring than to create a new polynomial ring with the variable.

Perhaps as a compromise, we raise an error if there is no `q` given but `q` is a variable name in the base ring? This is clearly the safest option, and it requires the user to know exactly what they are doing.

Also, I agree with removing the `fraction_field` since it is unnecessary.


---

Comment by mantepse created at 2019-12-03 13:05:26

Replying to [comment:33 tscrim]:
> If you are visually looking at output, then I agree, but if you are programming something, then it will break if you are doing something assuming that the output is a univariate polynomial ring. It is also much easier for the user to pass in the `q` of the base ring than to create a new polynomial ring with the variable.

I agree!

> Perhaps as a compromise, we raise an error if there is no `q` given but `q` is a variable name in the base ring? This is clearly the safest option, and it requires the user to know exactly what they are doing.

I think that is an excellent idea!

> Also, I agree with removing the `fraction_field` since it is unnecessary.

will do.


---

Comment by git created at 2019-12-03 13:34:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-12-03 13:42:59

> > Perhaps as a compromise, we raise an error if there is no `q` given but `q` is a variable name in the base ring? This is clearly the safest option, and it requires the user to know exactly what they 
are doing.
> 
> I think that is an excellent idea!

Unfortunately, it doesn't work.  The base ring could be the symbolic ring.


---

Comment by tscrim created at 2019-12-03 21:21:06

Replying to [comment:36 mantepse]:
> Unfortunately, it doesn't work.  The base ring could be the symbolic ring.

We can treat the symbolic ring as special. What I was think was doing

```python
try:
    if 'q' in self.base_ring().variable_names_recursive():
        raise ValueError("q is already a variable name, so you must give the parameter q")
    else:
        q = self.base_ring()['q'].gen()
except AttributeError:
    q = self.base_ring()['q'].gen()
```

For this, they symbolic ring would be treated the same as `QQ`, and we would get a univariate polynomial ring over `SR`. The other option is just explicitly test for `self.base_ring() is SR` and just let `q = SR.var('q')`.


---

Comment by git created at 2019-12-03 21:26:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-12-03 21:32:46

emails crossed :-)

I think it's OK to require q to be passed explicitely for the symbolic ring.  I would rather not test explicitely for `SR`, because it is quite possible to have, for example and some time in future, a polynomial ring which contains all variables.

Since not all rings have `variable_names_recursive`, I simply try to convert "q" to a ring element, as Mike proposed.

Are you OK with this version?


---

Comment by tscrim created at 2019-12-03 21:59:45

This is acceptable to me. Mike?


---

Comment by zabrocki created at 2019-12-04 20:24:11

I'll need a little time to try it out.  "explicitely" is spelled wrong and I want to check that all coercions are correct.

As long as there is an option to use one of the variables in the ring in case that is what is desired that should be ok.


---

Comment by git created at 2019-12-04 21:53:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-12-04 22:02:46

Thanks for spotting the misspelling!  I created ticket #28843 for the other occurrences of "explicitely" :-)


---

Comment by mantepse created at 2019-12-05 06:44:17

The startup modules plugin says:

```
========== startup_modules ==========
git checkout patchbot/ticket_merged
/local/sage-patchbot/sage/sage -c ''
Total count: 1687
New:
sage.combinat.q_analogues
====================
```

I am guessing that this happens because I import `q_binomial` and `q_factorial` in `elementary.py` and `homogeneous.py`.  Should I rather import them locally?


---

Comment by tscrim created at 2019-12-05 07:28:36

I think it is better to do them locally as I don't see the extra import making a timing difference.


---

Comment by git created at 2019-12-05 12:51:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-12-05 12:56:36

I just noticed that I overlooked the default values for the exponential specialisation.

I factored out the following little helper function, but I do not know where to put it:

```
def get_variable(ring, name):
    try:
        ring(name)
    except TypeError:
        return ring[name].gen()
    else:
        raise ValueError("the variable %s is in the base ring, pass it explicitly" % name)
```


This could also be used in `theta_qt`:

```
    def theta_qt(self, q=None, t=None):
        r"""
        Return the image of ``self`` under the `q,t`-deformed theta
        endomorphism which sends `p_k` to `\frac{1-q^k}{1-t^k} \cdot p_k`
        for all positive integers `k`.

        In general, this is well-defined outside of the powersum basis only
        if the base ring is a `\QQ`-algebra.

        INPUT:

        - ``q``, ``t`` -- parameters (default: ``None``, in which case 'q'
          and 't' are used)

...

        """
        parent = self.parent()
        BR = parent.base_ring()
        p = parent.realization_of().power()
        p_self = p(self)
        if t is None:
            if hasattr(parent,"t"):
                t = parent.t
            else:
                t = BR(QQ['t'].gen())
        if q is None:
            if hasattr(parent,"q"):
                q = parent.q
            else:
                q = BR(QQ['q'].gen())

```


same in `omega_qt`, `nabla`, `scalar_qt`, `scalar_jack`


---

Comment by zabrocki created at 2019-12-05 13:01:09

No it can't be.  For `theta_qt` the `q` and the `t` must be in the `base_ring`.


---

Comment by mantepse created at 2019-12-05 13:44:52

Replying to [comment:48 zabrocki]:
> No it can't be.  For `theta_qt` the `q` and the `t` must be in the `base_ring`.

You are right, I am sorry.


---

Comment by zabrocki created at 2019-12-05 16:49:21

I'm still testing this out but here are some initial comments:

"specialisation" -> "specialization"

Also in `exponential_specialization`, I think you should mention "where `n` is the homogeneous degree of `f`."

Are you sure that you intended the behavior with `t=None` and `q=None`?  You get expressions where the `q` and the `t` don't mix well.  This is not what I was expecting (maybe this is what you intended, but I'm asking for clarification).

```
sage: h = SymmetricFunctions(QQ).h()
sage: h[3].exponential_specialization(t=None,q=None)
((q^2 - 2*q + 1)/(q^2 + q + 1))*t^3
sage: _.parent()
Univariate Polynomial Ring in t over Fraction Field of Univariate Polynomial Ring in q over Rational Field
```

This is not what is documented under the INPUT section because it says that
"the default is to create the fraction field of polynomials in `t` over the coefficient ring."

Are you sure you don't want to be using `self.base_ring()['q,t'].fraction_field()` `self.base_ring()['t']['q'].fraction_field()` or more simply `SR` for these expressions?  When do you anticipate users wanting to calculate the principal or exponential specialization and what will be done with the expressions afterwards?  

The calculation for elementary, power sum, monomial and Schur are all handled differently and the documentation for the `exponential_specialization` or `principal_specialization` is the same.  I think that the mathematical formulas used in those methods should be documented.

"Note that the stable principal specialization can be obtained as a plethysm" delete the word "stable" since both the stable and non-stable are demonstrated to be plethysm in that example (n=infinity is "stable", right?)


---

Comment by git created at 2019-12-05 18:34:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-12-05 18:51:21

Dear Mike!

thank you for looking into this, and thank you for your comments.  I did the easy ones.

Replying to [comment:50 zabrocki]:

> Also in `exponential_specialization`, I think you should mention "where `n` is the homogeneous degree of `f`."

Could you say precisely where?  Currently, it is written, for example in `sfa.py`, on line 5543:

```
        By analogy `q`-exponential specialization is a ring homomorphism
        defined on homogeneous symmetric functions `f` of degree `n`
        as
```


Or am I misunderstanding you?

> Are you sure that you intended the behavior with `t=None` and `q=None`?  You get expressions where the `q` and the `t` don't mix well.  This is not what I was expecting (maybe this is what you intended, but I'm asking for clarification).
> {{{
> sage: h = SymmetricFunctions(QQ).h()
> sage: h[3].exponential_specialization(t=None,q=None)
> ((q^2 - 2*q + 1)/(q^2 + q + 1))*t^3
> sage: _.parent()
> Univariate Polynomial Ring in t over Fraction Field of Univariate Polynomial Ring in q over Rational Field
> }}}
> This is not what is documented under the INPUT section because it says that
> "the default is to create the fraction field of polynomials in `t` over the coefficient ring."

Yes, the documentation is inaccurate, because since a few commits ago it returns a polynomial.
 
> Are you sure you don't want to be using `self.base_ring()['q,t'].fraction_field()` `self.base_ring()['t']['q'].fraction_field()` or more simply `SR` for these expressions?  When do you anticipate users wanting to calculate the principal or exponential specialization and what will be done with the expressions afterwards?  

I don't think it is wise to use `SR` by default, because we always get something polynomial in `t` and rational in `q`.

What I would do with the result afterwards might be factorisation, evaluation at roots of unity, expanding into Taylor series.  In brief: it depends.

What would you expect / like? I admit I don't understand what you mean with "not mixing well".

> The calculation for elementary, power sum, monomial and Schur are all handled differently and the documentation for the `exponential_specialization` or `principal_specialization` is the same.  I think that the mathematical formulas used in those methods should be documented.

I agree that this makes sense.  It is a lot of work, but I'll do it.  It's a shame that I cannot easily inherit the "generic" documentation and append the special stuff.

Thanks again!


---

Comment by mantepse created at 2019-12-05 19:15:06

I just learnt that there is also a formula for the stable principal specialisation of P-Schur functions, but I'd prefer to keep this for a later ticket.


---

Comment by zabrocki created at 2019-12-05 20:18:26

> Could you say precisely where?  Currently, it is written, for example in `sfa.py`, on line 5543:
> {{{
>         By analogy `q`-exponential specialization is a ring homomorphism
>         defined on homogeneous symmetric functions `f` of degree `n`
>         as
> }}}
I missed that `f` was above because it wasn't mentioned in the formula for `ex_q(h_n)`.  I would suggest moving the "`f` of degree `n`" down a bit since the formula that immediately follows does not refer to `f`, but the one after that does.

> I don't think it is wise to use `SR` by default, because we always get something polynomial in `t` and rational in `q`.
>
Maybe not in `SR`, but what about the other rings?

> What I would do with the result afterwards might be factorisation, evaluation at roots of unity, expanding into Taylor series.  In brief: it depends.
The reason I ask is exactly because of the applications you want because evaluation at roots of unity and Taylor series are pretty tough when you have the ring as `Univariate Polynomial Ring in t over Fraction Field of Univariate Polynomial Ring in q over Rational Field`.

> What would you expect / like? I admit I don't understand what you mean with "not mixing well".
By "not mixing well" I meant that the expression was a polynomial in `t` with coefficients which are rational functions in `q` and you can't easily access the two generators at the same time and manipulate those sorts of expressions:

```
sage: a=h[3].exponential_specialization(t=None,q=None)
sage: (t,q)=(a.parent().gen(), a.parent().base_ring().gen())
```

Even once you do that, I wasn't able to get a Taylor series or evaluate at roots of unity easily.  I'm guessing that if you know your application, then this would determine what base ring you would be using and the user would put in specific values for `q` and `t`.

> I agree that this makes sense.  It is a lot of work, but I'll do it.  It's a shame that I cannot easily inherit the "generic" documentation and append the special stuff.
Maybe the generic implementation and for either power sum or complete symmetric functions is sufficient?
There will be significant speedup at q=1 for the Schur basis, but I just checked:

```
%time h(s[6,6,4,4,3,3,3,2,2,1]).exponential_specialization(t=None,q=None)
```

runs about twice as fast as

```
%time s[6,6,4,4,3,3,3,2,2,1].exponential_specialization(t=None,q=None)
```

on my computer.  I would coerce to the complete symmetric functions instead of the power sum.


---

Comment by git created at 2019-12-05 21:08:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-12-06 11:12:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-12-06 11:17:54

Since it was easy to do, I implemented the formula for the exponential specialization of Schur functions, which makes a factor of about 5000 in your example.

I also added math to the documentation.


---

Comment by mantepse created at 2019-12-10 13:49:56

Dear Mike,

should I switch to rational functions in `q` and `t` as default for the exponential specialization?


---

Comment by zabrocki created at 2019-12-26 17:12:57

I made some changes to the documentation, but there was one comment that I have that I have not yet changed.

In the documentation for the exponential specialization it reads "Note that setting `q = 1` in the stable principal specialization is an invalid operation."  This should be documented in principal specialization and this should be followed.  For instance

```
sage: e=SymmetricFunctions(QQ).e()
sage: e[2].principal_specialization(q=1)
+Infinity
sage: (e[2]-e[1,1]).principal_specialization(q=1)
SignError                                 Traceback (most recent call last)
...
```

That is, I think that you should raise an error in this case.  You can remove the comment from exponential specialization and just put it in principal specialization.
----
Last 10 new commits:


---

Comment by zabrocki created at 2019-12-26 17:12:57

Changing status from needs_review to needs_work.


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by git created at 2020-01-01 14:47:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2020-01-01 14:48:55

Done, ready for review again - and thank you for the useful comment!


---

Comment by mantepse created at 2020-01-01 14:48:55

Changing status from needs_work to needs_review.


---

Comment by mantepse created at 2020-03-26 12:04:43

I am again needing this for my research.  I'd be extremely grateful for a review!


---

Comment by git created at 2020-04-02 13:50:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-02 13:54:32

Before I move on with the review, can you please comment on the following:

- In powersum.py, you have a get_variable function that deals with unspecified q. In monomial.py, you don't. Is it actually unneeded in monomial.py, or have you forgotten to include it?

- In powersum.py, you use fractions like `(1-q**(n*part))/(1-q**part)`, which are undefined in general since the denominator can be non-invertible. This is probably fine for n == infinity, since the specialization is only defined in limited situations in that case, but for finite n the method should work in full generality. I suggest replacing this fraction by a sum.


---

Comment by git created at 2020-04-02 14:01:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-02 14:02:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mantepse created at 2020-04-02 20:37:02

Hi Darij!

* concerning `get_variable`, I see it in `monomial.py` also, line 427.  Or did I misunderstand?

* concerning division by zero: this problem actually affects all bases. The workaround 
  would be to have q symbolic and then take the limit.  I can think of a few problems, 
  let's first check that they are non-problems:
    - speed for large n and weird coefficient rings
    - less nice output when q is symbolic

* Heuristically, redirecting via the monomial basis seems faster in real life examples 
  than via the powersum basis.  Did you undo this on purpose?


```diff
@@ -5549,8 +5551,8 @@ class SymmetricFunctionAlgebra_generic_Element(CombinatorialFreeModule.Element):
             {'the stable principal specialization at q=1 is not defined'}
 
         """
-        m = self.parent().realization_of().monomial()
-        return m(self).principal_specialization(n, q=q)
+        p = self.parent().realization_of().powersum()
+        return p(self).principal_specialization(n, q=q)
```



---

Comment by @darijgr created at 2020-04-02 20:41:25

Hi Martin!

* I see `get_variable` defined only 9 times, but there are 6 files and 2 functions in each, so there are probably 3 missing. Sorry if it isn't monomial.py.

* Division by 0 shouldn't affect any basis (in principal_specialization) when n is finite! The definition works just fine, so I think the method should work as well -- which I think it doesn't.

* I undid my p->m change by accident (having a file open in two different editors); this is why I then force-pushed an updated commit where it was not undone. Or is it still?


---

Comment by git created at 2020-04-04 17:03:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2020-04-04 17:15:12

I'm ok with the current implementation and I checked that all tests pass.  Darij, do you have any additional comments or changes?


---

Comment by @darijgr created at 2020-04-04 17:20:15

The issues from #69 are still open; I'm worried it might even silently produce wrong results if the / operator gives a non-unique quotient in some non-integral domain.


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mantepse created at 2020-04-23 19:16:43

Replying to [comment:69 gh-darijgr]:
> Hi Martin!
> 
> * I see `get_variable` defined only 9 times, but there are 6 files and 2 functions in each, so there are probably 3 missing. Sorry if it isn't monomial.py.

I just checked. No there are none missing.  `get_variable` is not used in `principal_specialization` of `monomial.py` and not used at all in `sfa.py`.

> * Division by 0 shouldn't affect any basis (in principal_specialization) when n is finite! The definition works just fine, so I think the method should work as well -- which I think it doesn't.

This is correct, but, for example in `schur.py` I don't see a better way than actually computing with indeterminate `q` and substituting the value afterwards.  Do you think this is worth it?

> * I undid my p->m change by accident (having a file open in two different editors); this is why I then force-pushed an updated commit where it was not undone. Or is it still?

Actually, there is some nonsense going on right now, because for q other than 1, the monomial basis redirects to the powersum basis.  In any case, I'll add a comment.


---

Comment by @darijgr created at 2020-04-23 19:24:31

> I just checked. No there are none missing. get_variable is not used in principal_specialization of monomial.py and not used at all in sfa.py.

Oh, I see -- you're right! The q just gets passed.

> This is correct, but, for example in schur.py I don't see a better way than actually computing with indeterminate q and substituting the value afterwards. Do you think this is worth it?

That's what I would do.


---

Comment by git created at 2020-04-24 11:40:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2020-04-24 11:42:32

Please review :-)


---

Comment by git created at 2020-04-24 12:48:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-24 12:48:57

I've reviewed the docstrings, except for the fact that I'd like to see more doctests for bad cases (such as q = -1).

Will come back to the methods later tonight.


---

Comment by @darijgr created at 2020-04-24 13:27:40

The `get_variable` method uses `ring[name]` to adjoin a variable called `name` to `ring`. I'm not sure how universal this syntax is; if `ring` is, say, a realization of the symmetric functions, then this will try (and fail) to pick a basis element. Isn't there a better way?


---

Comment by mantepse created at 2020-04-24 13:45:17

Replying to [comment:79 gh-darijgr]:
> I've reviewed the docstrings, except for the fact that I'd like to see more doctests for bad cases (such as q = -1).

I'll incorporate all doctests you (explicitly!) suggest, OK?


---

Comment by git created at 2020-04-24 13:46:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-24 13:47:11

I've pushed a few doctests into the principal specialization in elementary.py. This is roughly the kind of stuff I want to test. If you can check that they work (errors can lie both in the tests and the code; I can't run sage on my machine), I'll add similar tests in all other functions.

One other cluster of possible issues I'd like to test is whether `_apply_module_morphism` does the necessary coercions for coefficients, seeing that (e.g.) the q-binomials are computed in the "wrong" ring.


---

Comment by mantepse created at 2020-04-24 13:56:21

I think it would be better to put these tests into `sfa.py` and test all implemened bases at once.


---

Comment by @darijgr created at 2020-04-24 14:00:57

OK, but are the results correct? Do they throw errors?


---

Comment by git created at 2020-04-24 17:19:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-24 17:23:06

The math is all correct. Now we need to (1) add doctests showing that no bad things happen coercion- and singularity-wise (ideally with some really nasty cases like q=2 in Zmod(4)) and (2) using something better than `ring[name]` in the `get_variable` methods. Then I'll take one more look at the yak-shaving part of the implementations and someone will have to run the doctests as I cannot. Sorry for how long this has been taking; the code is more complicated than it may look at a first sight.


---

Comment by git created at 2020-04-24 17:40:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-24 18:09:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-24 19:08:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2020-04-24 19:12:06

Redirecting to homogeneous instead of powersum in monomial.py has an interesting side effect:

```
    x.principal_specialization(3, q=var("q"))
Expected:
    5*(q^6 - 1)/(q^2 - 1) + 3*(q^3 - 1)/(q - 1) + 1
Got:
    -5*(q^3 - 1)^2/(q - 1)^2 + 3*(q^3 - 1)/(q - 1) + 10*(q^4 - 1)*(q^3 - 1)/((q^2 - 1)*(q - 1)) + 1
```

Do we still want this?  (I am well aware that this is most likely completely arbitrary.) For the record, redirecting to elementary would give

```
    x.principal_specialization(3, q=var("q"))
Expected:
    5*(q^6 - 1)/(q^2 - 1) + 3*(q^3 - 1)/(q - 1) + 1
Got:
    -10*(q^3 - 1)*q/(q - 1) + 5*(q^3 - 1)^2/(q - 1)^2 + 3*(q^3 - 1)/(q - 1) + 1
```



---

Comment by @darijgr created at 2020-04-24 19:13:42

Maybe we should use elementary instead of homogeneous then. Either way, we shouldn't use powersum, as it introduces a dependency on 1/n's. I view finite fields as more important than the symbolic ring (which can't ever be assumed completely bulletproof anyway).


---

Comment by @darijgr created at 2020-04-24 20:26:33

Also, thanks for fixing my doctests (yes, for some reason I thought (x+y)^2 = x^2 + y^2 over GF(3)). Will finish the review tomorrow.


---

Comment by mantepse created at 2020-04-25 09:59:49

Replying to [comment:92 gh-darijgr]:
> Maybe we should use elementary instead of homogeneous then. Either way, we shouldn't use powersum, as it introduces a dependency on 1/n's. I view finite fields as more important than the symbolic ring (which can't ever be assumed completely bulletproof anyway).

I agree, that's an excellent point!  Let's always redirect to elementary then, and write this in a comment (that elementary behaves well with respect to introducing singularities and seems fastest).


---

Comment by git created at 2020-04-25 11:41:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-25 15:35:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-25 15:36:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @darijgr created at 2020-04-25 15:36:50

Do the last two commits look good to you, Martin?


---

Comment by mantepse created at 2020-04-25 17:50:37

Actually, I now think that for monomial we should convert to powersum, not to elementary.

If something is nice in the monomial basis, it will also be nice in the powersum basis but not necessarily in the elementary basis, don't you think?

```
sage: p(m[7,4,2])
p[7, 4, 2] - p[7, 6] - p[9, 4] - p[11, 2] + 2*p[13]
```



---

Comment by @darijgr created at 2020-04-25 17:55:07

But powersum is broken for the reasons I claimed. Which is why I'm for adding all those weird-ring tests.

Are my changes so far OK? I'd then add the tests.


---

Comment by mantepse created at 2020-04-25 18:19:22

Replying to [comment:100 gh-darijgr]:
> But powersum is broken for the reasons I claimed. Which is why I'm for adding all those weird-ring tests.

I don't completely understand.  Am I wrong in assuming that passing from monomial to powersum will not introduce singularities?


---

Comment by @darijgr created at 2020-04-25 18:26:16

It will introduce singularities, since the powersum basis isn't a basis unless the base ring contains the rationals. (Of course, if you're doing the exponential specialization at q=1, you need the rationals anyway, but in all the other cases you don't.)


---

Comment by mantepse created at 2020-04-25 19:11:29

Replying to [comment:102 gh-darijgr]:
> It will introduce singularities, since the powersum basis isn't a basis unless the base ring contains the rationals. (Of course, if you're doing the exponential specialization at q=1, you need the rationals anyway, but in all the other cases you don't.)

Oops, sorry, I made a very fundamental mistake, you are right of course (witnessed by `p(m[1,1])`.


---

Comment by git created at 2020-04-25 19:24:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2020-04-25 19:25:58

I fixed the doctest and added a comment why we don't use the powersum basis as fallback.  Doctests pass on my computer.


---

Comment by mantepse created at 2020-04-25 19:26:16

(So, please go ahead!)


---

Comment by git created at 2020-04-25 20:05:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-25 20:06:11

OK, here are tests for principal_specialization. Can you check that they work before I adapt them for exponential_specialization too?


---

Comment by mantepse created at 2020-04-25 21:09:46

There are actually several failures.  The first one that fails is

```
sage: S = SymmetricFunctions(Zmod(4))
sage: B = [S.m(), S.e(), S.h(), S.s(), S.f()]
sage: m = S.m(); x = m[3,2,1]                                                                                                                         
sage: set([b(x).principal_specialization(n=4, q=Zmod(4)(2)) for b in B])
...
ZeroDivisionError: inverse of Mod(2, 4) does not exist

During handling of the above exception, another exception occurred:
...
TypeError: self must be an integral domain.
```

(It fails for the Schur basis.)


---

Comment by @darijgr created at 2020-04-25 21:10:47

Can we zoom? Assuming you can easily doctest the file, as we'd probably have to go through this a few times.


---

Comment by git created at 2020-04-25 21:38:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-25 22:03:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-25 22:12:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-25 22:13:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-25 22:56:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-25 22:57:17

I've added tests for exponential_specialization; I'm curious to hear what Sage thinks of them.

I haven't tested for removable singularities this time, since there aren't any (all denominators are unavoidable, although there is some occasional cancellation).


---

Comment by @darijgr created at 2020-04-25 22:59:27

PS. I have no idea why the trac merge is failing. Should we hit it with the rebase hammer?


---

Comment by mantepse created at 2020-04-26 07:20:51

There are a few failing tests.  I cannot correct them now, so I just paste them here:

```
File "src/sage/combinat/sf/sfa.py", line 5739, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    (m[2,1]+m[1,1]).exponential_specialization(q=None)                                                                                                
Expected:                                                                                                                                             
    t**2 * (1 - q)/(1 + q)                                                                                                                            
Got:                                                                                                                                                  
    ((-2*q^3 + q^2 + q)/(q^3 + 2*q^2 + 2*q + 1))*t^3 + (q/(q + 1))*t^2                                                                                
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5742, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    (m[2,1]+m[1,1]).exponential_specialization(q=q)                                                                                                   
Expected:                                                                                                                                             
    t**2 * (1 - q)/(1 + q)                                                                                                                            
Got:                                                                                                                                                  
    ((-2*q^3 + q^2 + q)/(q^3 + 2*q^2 + 2*q + 1))*t^3 + (q/(q + 1))*t^2                                                                                
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5745, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    (m[2,1]+m[1,1]).exponential_specialization(t=t)                                                                                                   
Expected:                                                                                                                                             
    t**2 * (1 - q)/(1 + q)                                                                                                                            
Got:                                                                                                                                                  
    1/2*t^2                                                                                                                                           
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5748, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    (m[2,1]+m[1,1]).exponential_specialization(q=q, t=t)                                                                                              
Expected:                                                                                                                                             
    t**2 * (1 - q)/(1 + q)                                                                                                                            
Got:                                                                                                                                                  
    (-2*q^3*t^3 + q^3*t^2 + q^2*t^3 + q^2*t^2 + q*t^3 + q*t^2)/(q^3 + 2*q^2 + 2*q + 1)                                                                
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5787, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    set(b[lam].exponential_specialization(q=None).parent() for b in B for lam in lams)                                                                
Expected:    
    {Fraction Field of Univariate Polynomial Ring in t over                                                                                           
      Univariate Polynomial Ring in q over Finite Field of size 3,                                                                                    
     Univariate Polynomial Ring in t over Univariate Polynomial Ring in q                                                                             
      over Finite Field of size 3}                                                                                                                    
Got:                                                                                                                                                  
    {Univariate Polynomial Ring in t over Fraction Field of Univariate Polynomial Ring in q over Finite Field of size 3,                              
     Univariate Polynomial Ring in t over Univariate Polynomial Ring in q over Finite Field of size 3}                                                
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5819, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    set(b[lam].exponential_specialization(q=q).parent() for b in B for lam in lams)                                                                   
Expected:                                                                                                                                             
    {Univariate Polynomial Ring in t over                                                                                                             
     Univariate Polynomial Ring in q over Rational Field}                                                                                             
Got:                                                                                                                                                  
    {Univariate Polynomial Ring in t over Fraction Field of Univariate Polynomial Ring in q over Rational Field,                                      
     Univariate Polynomial Ring in t over Univariate Polynomial Ring in q over Rational Field}                                                        
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5822, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    set(b[lam].exponential_specialization(q=q, t=1).parent() for b in B for lam in lams)                                                              
Expected:                                                                                                                                             
    {Univariate Polynomial Ring in q over Integer Ring}                                                                                               
Got:                                                                                                                                                  
    {Fraction Field of Univariate Polynomial Ring in q over Rational Field,                                                                           
     Univariate Polynomial Ring in q over Rational Field}                                                                                             
**********************************************************************                                                                                
1 item had failures:                                                                                                                                  
   7 of  46 in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization                                               
    [1155 tests, 7 failures, 4.81 s]                                                                       
```



---

Comment by @darijgr created at 2020-04-26 07:29:57

Oops -- all of these are my careless errors in the doctests. Can you try again after the next commit I'll push in a few seconds? Note that some results may be equivalent but in a different form.


---

Comment by git created at 2020-04-26 07:30:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-04-26 07:38:10

Can we avoid the doctests outputting a set either by sorting or checking some other condition? Such tests have had a history of being fickle.


---

Comment by @darijgr created at 2020-04-26 07:40:39

Ouch. Yes, we can do sorted(str(...) for ...).


---

Comment by mantepse created at 2020-04-26 08:13:39


```
sage -t src/sage/combinat/sf/sfa.py                                                                                                                   
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5739, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    m[1,1].exponential_specialization(q=None)                                                                                                         
Expected:                                                                                                                                             
    1/2*t^2                                                                                                                                           
Got:                                                                                                                                                  
    (q/(q + 1))*t^2                                                                                                                                   
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5742, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    m[1,1].exponential_specialization(q=q)                                                                                                            
Expected:                                                                                                                                             
    t^2 * (1 - q)/(1 + q)                                                                                                                             
Got:                                                                                                                                                  
    (q/(q + 1))*t^2                                                                                                                                   
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5748, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    m[1,1].exponential_specialization(q=q, t=t)                                                                                                       
Expected:                                                                                                                                             
    t^2 * (1 - q)/(1 + q)                                                                                                                             
Got:                                                                                                                                                  
    q*t^2/(q + 1)                                                                                                                                     
**********************************************************************                                                                                
File "src/sage/combinat/sf/sfa.py", line 5794, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization            
Failed example:                                                                                                                                       
    set(b[lam].exponential_specialization(q=q2, t=t2).parent() for b in B for lam in lams)                                                            
Expected:         
    {Fraction Field of Multivariate Polynomial Ring in q, t over Finite Field of size 3,                                                              
     Multivariate Polynomial Ring in q, t over Finite Field of size 3}                                                                                
Got:                                                                                                                                                  
    {Multivariate Polynomial Ring in q, t over Finite Field of size 3,                                                                                
     Fraction Field of Multivariate Polynomial Ring in q, t over Finite Field of size 3}                                                              
**********************************************************************                                                                                
1 item had failures:                                                                                                                                  
   4 of  46 in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.exponential_specialization                                               
    [1155 tests, 4 failures, 4.96 s]                                                                                                                  
----------------------------------------------------------------------                                                                                
sage -t src/sage/combinat/sf/sfa.py  # 4 doctests failed                                                                                              
----------------------------------------------------------------------                                                       
```



---

Comment by @darijgr created at 2020-04-26 10:24:49

Sage is right on all four counts here. Sorry again.


---

Comment by git created at 2020-04-26 10:31:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-26 10:32:32

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by @darijgr created at 2020-04-26 10:33:19

I've fixed what I believe to be all issues, and rebased the entire branch on the newest develop. And yet the merge is still failing :( Any ideas?


---

Comment by git created at 2020-04-26 15:50:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-26 15:52:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2020-04-26 15:53:23

Ignore the last two commits; I thought they'd fix the merge issue, but they didn't.

Any news on the new doctests? If they work right, I'd declare positive review and let it sort itself out once rc2 is out.


---

Comment by git created at 2020-04-26 18:34:41

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2020-04-26 18:41:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2020-04-26 18:42:38

Looks good to me!


---

Comment by @darijgr created at 2020-04-26 18:52:18

Changing status from needs_review to positive_review.


---

Comment by @darijgr created at 2020-04-26 18:52:18

Thanks for the merge! Positive review then.


---

Comment by mantepse created at 2020-04-26 18:58:59

Incredible! 03/14/11 - 04/26/20


---

Comment by fbissey created at 2020-04-28 02:53:32

Changing status from positive_review to needs_work.


---

Comment by fbissey created at 2020-04-28 02:53:32

Documentation doesn't build because in `sage/combinat/sfa.py` you have `[GriRei18_]` instead of `[GriRei18]_`.


---

Comment by git created at 2020-04-28 03:54:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-04-28 03:54:20

Changing status from needs_work to positive_review.


---

Comment by @darijgr created at 2020-04-28 07:57:27

Thanks, Francois and Matthias!


---

Comment by vbraun created at 2020-05-02 23:19:54

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2020-05-02 23:19:54

PDF docs don't build


---

Comment by @darijgr created at 2020-05-03 09:14:33

Log? I can't run make on cygwin right now.


---

Comment by git created at 2020-05-03 09:24:04

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by @darijgr created at 2020-05-03 09:24:38

Found it! Am pushing with force since I've once again rebased the entire branch (with my new commit as second-to-last and Matthias's as last).
----
Last 10 new commits:


---

Comment by @darijgr created at 2020-05-03 09:25:04

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2020-05-31 08:48:51

Resolution: fixed
