# Issue 29857: unable to coerce x (=3-dimensional vector space over the Rational Field) into Category of vector spaces over Rational Field

Issue created by migration from https://trac.sagemath.org/ticket/30094

Original creator: mkoeppe

Original creation time: 2020-07-08 20:40:59

CC:  egourgoulhon tscrim @mjungmath


```
sage: Q3 = FiniteRankFreeModule(QQ, 3)
sage: Q3 in Modules(QQ)
sage: Modules(QQ)(Q3)
TypeError: 'FiniteRankFreeModule_with_category' object has no attribute 'vector_space'
unable to coerce x (=3-dimensional vector space over the Rational Field) into Category of vector spaces over Rational Field
```


Compare with:

```
sage: Modules(QQ)(QQ^3)
Vector space of dimension 3 over Rational Field
```



---

Comment by mkoeppe created at 2020-07-10 18:07:46

Also it seems various maps are missing.

```
sage: Q3.has_coerce_map_from(QQ^3)
False
sage: Q3((QQ^3).an_element())
ValueError: the None has not been defined on the 3-dimensional vector space over the Rational Field
```



---

Comment by tscrim created at 2020-07-17 02:42:04

These are incompatible objects since `QQ^3` has a distinguished basis (the standard Euclidean basis) whereas `Q3` does not. So there should not be a map between them.

My 2 cents for the error reported in the ticket is to first check that the object is not in the category. The other option is to lift the `vector_space` method up to the category of modules and then implement a `change_ring` method for `Q3`.


---

Comment by mkoeppe created at 2020-07-17 02:44:09

Replying to [comment:4 tscrim]:
> These are incompatible objects since `QQ^3` has a distinguished basis (the standard Euclidean basis) whereas `Q3` does not. So there should not be a map between them.

Shouldn't there be a map in one direction that forgets the distinguished basis?


---

Comment by tscrim created at 2020-07-17 02:59:13

Replying to [comment:5 mkoeppe]:
> Replying to [comment:4 tscrim]:
> > These are incompatible objects since `QQ^3` has a distinguished basis (the standard Euclidean basis) whereas `Q3` does not. So there should not be a map between them.
> 
> Shouldn't there be a map in one direction that forgets the distinguished basis?

No, because where would you send the point `(1,3,1)` to? How would you know how it is expressed in one of the bases of `Q3`?


---

Comment by mkoeppe created at 2020-07-17 18:10:52

Ok, I feel we had this discussion before


---

Comment by mkoeppe created at 2020-07-17 18:16:39

Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?


---

Comment by @mjungmath created at 2020-07-17 18:43:23

Replying to [comment:8 mkoeppe]:
> Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?

No, I don't think it should. The identity map (like any other automorphism) is a basis independent object.


---

Comment by tscrim created at 2020-07-17 23:48:44

Replying to [comment:9 gh-mjungmath]:
> Replying to [comment:8 mkoeppe]:
> > Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?
> 
> No, I don't think it should. The identity map (like any other automorphism) is a basis independent object.

I might even go further to say that it would not be the identity map, but an isomorphism of free modules. We have to be careful about distinguishing things up to equality and up to isomorphism. For example, if I have `V = span_R{x,y,z}`, this is not equal to `W = R^3`. So there is no identity map from `V -> W` because I am not looking at `End(V)`, but `Mor(V, W)`. Yes, they are isomorphic, but there is no canonical isomorphism until I choose a distinguished basis for `V` and `W`.


---

Comment by mkoeppe created at 2020-07-17 23:50:07

Replying to [comment:10 tscrim]:
> Replying to [comment:9 gh-mjungmath]:
> > Replying to [comment:8 mkoeppe]:
> > > Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?
> > 
> > No, I don't think it should. The identity map (like any other automorphism) is a basis independent object.
> 
> I might even go further to say that it would not be the identity map, but an isomorphism of free modules. 

Of course, that's what I meant.


---

Comment by mkoeppe created at 2020-07-17 23:56:30

Replying to [comment:10 tscrim]:
> > Replying to [comment:8 mkoeppe]:
> > > Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?
> > 
> We have to be careful about distinguishing things up to equality and up to isomorphism. For example, if I have `V = span_R{x,y,z}`, this is not equal to `W = R^3`. 
> ... there is no canonical isomorphism until I choose a distinguished basis for `V` and `W`.

In my question above, this would be a method of `FreeModuleBasis` - so there is a particular basis. And `RR^3` also has a distinguished basis.


---

Comment by tscrim created at 2020-07-18 00:07:31

Replying to [comment:12 mkoeppe]:
> Replying to [comment:10 tscrim]:
> > > Replying to [comment:8 mkoeppe]:
> > > > Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?
> > > 
> > We have to be careful about distinguishing things up to equality and up to isomorphism. For example, if I have `V = span_R{x,y,z}`, this is not equal to `W = R^3`. 
> > ... there is no canonical isomorphism until I choose a distinguished basis for `V` and `W`.
> 
> In my question above, this would be a method of `FreeModuleBasis` - so there is a particular basis. And `RR^3` also has a distinguished basis. 

You were asking for a map from `self.free_module()`, which is the free module without a distinguished basis. If you want to go from a `FreeModuleBasis`, then that might be a good method as there is a canonical isomorphism of the homspace with the endspace and an identity map. Although I am not sure how much the basis is intended as a basis as a set or the span of the basis elements. I suspect the former, so such a method would not make sense. I would have to see what Eric and Michal say.


---

Comment by egourgoulhon created at 2020-07-18 14:11:27

Replying to [comment:13 tscrim]:
> Replying to [comment:12 mkoeppe]:
> > Replying to [comment:10 tscrim]:
> > > > Replying to [comment:8 mkoeppe]:
> > > > > Should `FreeModuleBasis` get a method that creates the identity map from `self.free_module()` to a free module with that basis?
> > > > 
> > > We have to be careful about distinguishing things up to equality and up to isomorphism. For example, if I have `V = span_R{x,y,z}`, this is not equal to `W = R^3`. 
> > > ... there is no canonical isomorphism until I choose a distinguished basis for `V` and `W`.
> > 
> > In my question above, this would be a method of `FreeModuleBasis` - so there is a particular basis. And `RR^3` also has a distinguished basis. 
> 
> You were asking for a map from `self.free_module()`, which is the free module without a distinguished basis. If you want to go from a `FreeModuleBasis`, then that might be a good method as there is a canonical isomorphism of the homspace with the endspace and an identity map. Although I am not sure how much the basis is intended as a basis as a set or the span of the basis elements. I suspect the former, so such a method would not make sense. I would have to see what Eric and Michal say.

I of course agree that one may implement a method in `FreeModuleBasis` that returns an isomorphism between `Q3` and `QQ^3`, but for which purpose? Such an isomorphism cannot be used for a coercion since a coercion must be unique and cannot depend on a extra parameter such as a
basis-dependent isomorphism.

Coming back to the issue mentioned in the ticket title and description, I would say that the problem arises because "vector spaces" as they are implemented in Sage are not really vector spaces in all their generality but only Cartesian powers `F^n`, where `F` is the base field.


---

Comment by mkoeppe created at 2020-07-18 16:34:15

Replying to [comment:14 egourgoulhon]:
> Coming back to the issue mentioned in the ticket title and description, I would say that the problem arises because "vector spaces" as they are implemented in Sage are not really vector spaces in all their generality but only Cartesian powers `F^n`, where `F` is the base field.    

OK, I think we are getting closer. 

When you say, '"vector spaces" as they are implemented in Sage', I assume you mean the ones implemented in `sage.modules.free_module` and constructed by the function `VectorSpace`, and then I agree with what you wrote.

What I was asking for in comment 8 is, given a basis, a map from a `FiniteRankFreeModule` (which is in the category of finite dimensional modules) to a parent that is in the category of finite dimensional modules with basis.


---

Comment by @mjungmath created at 2020-07-18 19:54:27

Replying to [comment:10 tscrim]:
> I might even go further to say that it would not be the identity map, but an isomorphism of free modules.

Well, yes. It is a special kind of automorphism. However, I wouldn't see it as an isomorphism between any two free modules of the same rank, in case this is what you are referring to.

Replying to [comment:13 tscrim]:
> Although I am not sure how much the basis is intended as a basis as a set or the span of the basis elements. I suspect the former, so such a method would not make sense. I would have to see what Eric and Michal say.

I am not sure what you mean with "the span of the basis elements". This does not make any sense to me because the span is always the free module again. Anyway, I would see an instance of `FreeModuleBasis` as a representation of a (finite) subset of the corresponding free module which is linearly independent and generates the module (possibly in the sense of formal linear combinations).


---

Comment by @mjungmath created at 2020-07-18 20:06:14

Replying to [comment:4 tscrim]:
> These are incompatible objects since `QQ^3` has a distinguished basis (the standard Euclidean basis) whereas `Q3` does not. So there should not be a map between them.

Agreed.

> My 2 cents for the error reported in the ticket is to first check that the object is not in the category. The other option is to lift the `vector_space` method up to the category of modules and then implement a `change_ring` method for `Q3`.

Sounds good. Who goes for it?


---

Comment by egourgoulhon created at 2020-07-18 22:08:27

Replying to [comment:15 mkoeppe]:
> Replying to [comment:14 egourgoulhon]:
> > Coming back to the issue mentioned in the ticket title and description, I would say that the problem arises because "vector spaces" as they are implemented in Sage are not really vector spaces in all their generality but only Cartesian powers `F^n`, where `F` is the base field.    
> 
> OK, I think we are getting closer. 
> 
> When you say, '"vector spaces" as they are implemented in Sage', I assume you mean the ones implemented in `sage.modules.free_module` and constructed by the function `VectorSpace`, 
Yes.
>and then I agree with what you wrote.
>
>What I was asking for in comment 8 is, given a basis, a map from a `FiniteRankFreeModule` (which is in the category of finite dimensional modules) to a parent that is in the category of finite dimensional modules with basis.
> 
Yes, this is the basis-dependent isomorphism I was referring to comment:14, but my concern, and that of Travis if I understand correctly, is that such an isomorphism cannot be used for a coercion, because it is not canonical (by definition, it depends on a choice of basis).


---

Comment by mkoeppe created at 2020-07-18 22:12:02

Replying to [comment:18 egourgoulhon]:
> Yes, this is the basis-dependent isomorphism I was referring to comment:14, but my concern, and that of Travis if I understand correctly, is that such an isomorphism cannot be used for a coercion, because it is not canonical (by definition, it depends on a choice of basis). 

I've pushed a rough implementation of this to the ticket.

Sure, I don't need this to be a coercion. Just a module morphism.



----
New commits:


---

Comment by tscrim created at 2020-07-18 23:46:33

Replying to [comment:16 gh-mjungmath]:
> Replying to [comment:13 tscrim]:
> > Although I am not sure how much the basis is intended as a basis as a set or the span of the basis elements. I suspect the former, so such a method would not make sense. I would have to see what Eric and Michal say.
> 
> I am not sure what you mean with "the span of the basis elements". This does not make any sense to me because the span is always the free module again. Anyway, I would see an instance of `FreeModuleBasis` as a representation of a (finite) subset of the corresponding free module which is linearly independent and generates the module (possibly in the sense of formal linear combinations).

The question is what does this class represent:

1. The basis itself, which is a finite set.
2. The span of the basis elements, which is a vector space where we can represent the points in terms of the chosen basis elements.

These are very different objects. One is finite, one is infinite (well, |R|<sup>n</sup>, where R is the base ring). Since you want to think of it as 1, then you are saying there should not be a morphism. However, most of the points of the free module should not be elements of this parent. The actual implementation is really treating it like 2, and its elements are the points of the free module represented using the chosen basis.

----

I like the proposed method overall. I have some suggestions:

1 - Change the name to something like `morphism_with_fixed_basis` as right now it sounds like it is constructing a map that happens to fix a basis.
2 - Allow the codomain of the map to be passed to the function. Then you can have the map be defined as

```python
        if codomain.dimension() != self.dimension():
            raise ValueError
        B = list(codomain.basis())
        def function(x):
            return codomain.sum(x[basis, i] * B[i] for i in self.irange())
```

This should be implementation independent (if it is not, then it is a bug IMO).


---

Comment by mkoeppe created at 2020-07-19 00:02:02

Replying to [comment:21 tscrim]:
> Replying to [comment:16 gh-mjungmath]:
> > Replying to [comment:13 tscrim]:
> > > Although I am not sure how much the basis is intended as a basis as a set or the span of the basis elements. I suspect the former, so such a method would not make sense. I would have to see what Eric and Michal say.
> > 
> > I am not sure what you mean with "the span of the basis elements". This does not make any sense to me because the span is always the free module again. Anyway, I would see an instance of `FreeModuleBasis` as a representation of a (finite) subset of the corresponding free module which is linearly independent and generates the module (possibly in the sense of formal linear combinations).
> 
> The question is what does this class represent:
> 
> 1. The basis itself, which is a finite set.
> 2. The span of the basis elements, which is a vector space where we can represent the points in terms of the chosen basis elements.

I think it's clear that 1 is intended:

```
sage: V = FiniteRankFreeModule(QQ, 3)
sage: e = V.basis("e")
sage: e[0] in e
True
sage: e[1] in e
True
sage: e[0] + e[1] in e
False


---

Comment by git created at 2020-07-19 00:13:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-07-19 01:34:09

Ah, right. Yes, it is clear that it is 1. I got myself confused.


---

Comment by @mjungmath created at 2020-07-19 08:01:57

Replying to [comment:23 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[7366741](https://git.sagemath.org/sage.git/commit/?id=73667410fb02014b789a49ef58e9846ecc729419)||`Rename, generalize`||

I must agree Eric in comment:14, I don't see the use of such a method `isomorphism_with_fixed_basis`, not even in `FiniteRankFreeModule`.

I see no problem in implementing the coercion on the level of modules right away. There is no need for such method either in this case. The vector space `QQ^3` forgets about the basis we have chosen, anyway (i.e. there is no going back). The important thing is that we are able to choose a basis. But this is ensured due to the definition of a free module.

I have to admit, I am not sure what's the problem is we're still discussing; apart from the error reported in the description. Is it still all about comment:2? As reported in this ticket, we want to coerce the free modules themselves and not their elements.


---

Comment by mkoeppe created at 2020-07-19 14:07:21

Replying to [comment:25 gh-mjungmath]:
> I have to admit, I am not sure what's the problem is we're still discussing

Thanks. I will split the ticket into two and clarify the descriptions.


---

Comment by mkoeppe created at 2020-07-19 14:35:55

The topic originally on the ticket description is now in #30174.
I hope this helps.


---

Comment by @mjungmath created at 2020-07-19 15:52:24

Looking at the code, I begin to like the idea, too. :)

It's still a draft, however I'd like to propose an improvement regarding the docstring:


```diff
         Construct the canonical isomorphism from the free module ``self``
-        to a free module in which ``basis`` of ``self`` is the distinguished basis.
+        to a free module in which ``basis`` of ``self`` is mapped to the
+        distinguished basis of ``codomain``.
```


I think it would also be good to specify input and output in the docstring. In particular, the input `codomain` should be described as an element of `ModulesWithBasis` having the same rank as `self` and over the same base ring. Furthermore, it should be explained that `CombinatorialFreeModule` is chosen by default if the input is `None`.


---

Comment by @mjungmath created at 2020-07-19 15:59:22

And probably we should raise an error in case both base rings are not equal.


---

Comment by mkoeppe created at 2020-07-19 16:14:21

Thanks for the suggestions, sounds all good. I don't have time to work on it today. Please feel free to commit changes to the branch


---

Comment by git created at 2020-07-19 19:15:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-19 20:22:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by egourgoulhon created at 2020-07-20 12:45:11

Thanks for the code! I think this should be changed:

```diff
-            return codomain.sum(x[basis, i] * codomain_basis[i]
-                                for i in self.irange())
+            return codomain.sum(x[basis, i] * codomain_basis[i - self._sindex]
+                                for i in self.irange())
```

The doctest 

```
sage: self = V = FiniteRankFreeModule(QQ, 3); V
```

could be changed to

```
sage: self = V = FiniteRankFreeModule(QQ, 3, start_index=1); V
```

to check that everything is OK with index ranges.


---

Comment by git created at 2020-07-20 13:34:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-20 13:36:15

Replying to [comment:35 egourgoulhon]:
> Thanks for the code! I think this should be changed:
> {{{
> #!diff
> -            return codomain.sum(x[basis, i] * codomain_basis[i]
> -                                for i in self.irange())
> +            return codomain.sum(x[basis, i] * codomain_basis[i - self._sindex]
> +                                for i in self.irange())
> }}}
> The doctest 
> {{{
> sage: self = V = FiniteRankFreeModule(QQ, 3); V
> }}}
> could be changed to
> {{{
> sage: self = V = FiniteRankFreeModule(QQ, 3, start_index=1); V
> }}}
> to check that everything is OK with index ranges.

Very good objection. I took that into consideration. I think, the ticket is ready for review now. Matthias?


---

Comment by mkoeppe created at 2020-07-20 15:49:06

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2020-07-20 15:50:40

I'm happy with these changes, thanks very much!


---

Comment by mkoeppe created at 2020-07-20 18:02:09

Of course, one could ask what the basis of the `CombinatorialFreeModule` should be indexed by.

```
sage: V = FiniteRankFreeModule(QQ, 3, start_index=1)
sage: basis = e = V.basis("e")
sage: phi_e.codomain().basis()
Finite family {'e_1': B['e_1'], 'e_2': B['e_2'], 'e_3': B['e_3']}
```

I think it would be more natural if this family was indexed by `V.irange()`.


---

Comment by @mjungmath created at 2020-07-20 18:53:09

Replying to [comment:40 mkoeppe]:
> Of course, one could ask what the basis of the `CombinatorialFreeModule` should be indexed by.
> {{{
> sage: V = FiniteRankFreeModule(QQ, 3, start_index=1)
> sage: basis = e = V.basis("e")
> sage: phi_e.codomain().basis()
> Finite family {'e_1': B['e_1'], 'e_2': B['e_2'], 'e_3': B['e_3']}
> }}}
> I think it would be more natural if this family was indexed by `V.irange()`.

I don't quite get what you want. I have quickly overviewd the documentation of `CombinatorialFreeModule`, and I think that our implementation already carries out the intended behavior.


---

Comment by mkoeppe created at 2020-07-20 19:09:17


```
sage: phi_e.codomain().basis().keys()
{'e_1', 'e_2', 'e_3'}
```

I think the code should be changed so that

```
sage: phi_e.codomain().basis().keys()
{1, 2, 3}
```



---

Comment by @mjungmath created at 2020-07-20 19:38:57

Replying to [comment:42 mkoeppe]:
> {{{
> sage: phi_e.codomain().basis().keys()
> {'e_1', 'e_2', 'e_3'}
> }}}
> I think the code should be changed so that
> {{{
> sage: phi_e.codomain().basis().keys()
> {1, 2, 3}
> }}}

As far as I understand it, the keys correspond to the basis element's name. And I thought that the intention was to name them after the basis we are coming from, wasn't it?

Notice that the names can also differ from the canonical choice, for example `a, b, c`, without labeled indices. In that case, the current implementation is preferrable anyway.


---

Comment by mkoeppe created at 2020-07-20 19:51:59

Are there methods in `FreeModuleBasis` or `FiniteRankFreeModule` that allow the user to look up a basis element by name?


---

Comment by @mjungmath created at 2020-07-20 21:32:12

I am sorry. I am little off track. You were obiously right:

> `basis_keys` - list, tuple, family, set, etc. defining the indexing set for the basis of this module

What you suggest sounds good then.


---

Comment by git created at 2020-07-20 21:38:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-20 21:50:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-07-20 21:52:26

Perhaps the prefix "B" should be changed to `basis._symbol`


---

Comment by git created at 2020-07-21 00:55:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-21 07:58:55

Replying to [comment:49 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[40f589f](https://git.sagemath.org/sage.git/commit/?id=40f589f9033607bae86eec49b1eeb2d020003880)||`Use basis._symbol as prefix instead of B`||

Replying to [comment:48 mkoeppe]:
> Perhaps the prefix "B" should be changed to `basis._symbol`


This won't work:


```
sage: M = FiniteRankFreeModule(QQ, 3)
sage: e = M.basis(['a', 'b', 'c'], symbol_dual=['d', 'e', 'f'])
sage: phi_e = phi_e = M.isomorphism_with_fixed_basis(e)
sage: phi_e.codomain().basis()
<repr(<sage.sets.family.FiniteFamily_with_category at 0x7f03d6b8bb88>) failed: TypeError: can only concatenate tuple (not "str") to tuple>
```


See comment:43.


---

Comment by @mjungmath created at 2020-07-21 07:59:05

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-07-21 14:47:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-07-21 14:48:32

Thanks for catching this. Here's a better version


---

Comment by mkoeppe created at 2020-07-21 14:48:32

Changing status from needs_work to needs_review.


---

Comment by @mjungmath created at 2020-07-21 14:55:02

I don't think the prefix is even necessary, but I can live with that.


---

Comment by egourgoulhon created at 2020-07-22 09:14:24

Changing status from needs_review to positive_review.


---

Comment by egourgoulhon created at 2020-07-22 09:14:24

LGTM. Thanks!


---

Comment by egourgoulhon created at 2020-07-22 09:27:23

Shouldn't the code of this ticket use #30180 (cf. comment 1 in that ticket)? Then #30180 should be added as a dependency.


---

Comment by egourgoulhon created at 2020-07-22 09:27:23

Changing status from positive_review to needs_info.


---

Comment by @mjungmath created at 2020-07-22 09:49:05

Replying to [comment:57 egourgoulhon]:
> Shouldn't the code of this ticket use #30180 (cf. comment 1 in that ticket)? Then #30180 should be added as a dependency. 

I think, the independence should be the other way around, right Matthias?


---

Comment by egourgoulhon created at 2020-07-22 14:02:12

Replying to [comment:58 gh-mjungmath]:
> Replying to [comment:57 egourgoulhon]:
> > Shouldn't the code of this ticket use #30180 (cf. comment 1 in that ticket)? Then #30180 should be added as a dependency. 
> 
> I think, the independence should be the other way around, right Matthias?
No, if the code in this ticket makes use of #30180's code, the dependency shall be set here to #30180.


---

Comment by @mjungmath created at 2020-07-22 14:15:13

Replying to [comment:59 egourgoulhon]:
> Replying to [comment:58 gh-mjungmath]:
> > Replying to [comment:57 egourgoulhon]:
> > > Shouldn't the code of this ticket use #30180 (cf. comment 1 in that ticket)? Then #30180 should be added as a dependency. 
> > 
> > I think, the independence should be the other way around, right Matthias?
> No, if the code in this ticket makes use of #30180's code, the dependency shall be set here to #30180. 

This code works independently of #30180 and I don't see any snippets from #30180 used here.


---

Comment by mkoeppe created at 2020-07-22 15:33:25

Both of you are right.


---

Comment by mkoeppe created at 2020-07-22 15:34:27

Thanks to the speedy review of #30180, I will use it now to simplify the code on the present ticket.


---

Comment by git created at 2020-07-22 15:40:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-07-22 15:40:41

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2020-07-24 00:34:42

Morally green patchbot.


---

Comment by egourgoulhon created at 2020-07-24 08:30:22

Changing status from needs_review to positive_review.


---

Comment by egourgoulhon created at 2020-07-24 08:30:22

Thanks for the update!


---

Comment by mkoeppe created at 2020-07-24 15:51:52

Thanks!


---

Comment by vbraun created at 2020-08-02 08:20:38

Resolution: fixed
