# Issue 26132: Improve triconnectivity algorithm: some cythonization

Issue created by migration from Trac.

Original creator: dcoudert

Original creation time: 2018-10-01 07:03:50

CC:  meghanamreddy saiharsh tscrim

We do some speed up improvements by
- changing the way edges are stored internally
- simplifying method ``__split_multiple_edges``
- declare variable types
- use int arrays


---

Comment by dcoudert created at 2018-10-01 07:08:41

This commit changes the way to deal with edges. We now associate each edge a unique identifier (int) and then store that identifier instead of the edge in data structures such as internal dictionaries, the doubly link list, the components, etc.

After that we can turn many data structures to arrays. Furthermore, it ensures that `_LinkedListNode` only stores an integer
value and not any types.

On the way, we drastically simplify method `__split_multiple_edges`. Indeed, we don't need to sort edges, but to arrange edges with same end points into buckets. If a bucket has more than one edge, we have a set of multiple edges.
----
New commits:


---

Comment by git created at 2018-10-01 07:36:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-01 07:38:04

In the second commit, we declare simple types, use int arrays instead of list/dict, etc.


---

Comment by git created at 2018-10-01 16:31:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-01 16:46:55

Changing status from new to needs_review.


---

Comment by dcoudert created at 2018-10-01 16:46:55

This last commit uses the observation that the index in list `int_to_edge` of virtual edges is `>= m` (the first virtual edge has index `m`, the second `m+1`, etc.). 
- The internal label of a virtual edge is now its index.
- To test if an edge is a virtual edge, it suffices to test if its index is `>= m`.
- We introduce 2 arrays to store edges extremities. The main motivation is to avoid constantly accessing list `int_to_edge`.

More cythonization can be done, in particular for the doubly linked list, but I don't know yet what's the best way to do it. May be for another ticket. We already do a lot here.

Also, I have some doubt in types declarations between `int` and `Py_ssize_t`. When should we use this `Py_ssize_t` ?


---

Comment by tscrim created at 2018-10-01 22:31:53

`Py_ssize_t` is for when you thing you might overflow the usual `int`. In general, you should use `Py_ssize_t` as `int` imposes a more artificial limitation on sizes.


---

Comment by tscrim created at 2018-10-01 22:35:39

Timings:

Your branch:

```
sage: G = graphs.JankoKharaghaniGraph(936)
sage: (G.order(), G.size())
(936, 175500)
sage: %time T = G.spqr_tree()
CPU times: user 4.28 s, sys: 124 ms, total: 4.41 s
Wall time: 4.37 s
```

vs 8.4.beta7:

```
sage: %time T = G.spqr_tree()
CPU times: user 6.2 s, sys: 92 ms, total: 6.3 s
Wall time: 6.22 s
```


So already you have a very good speedup on this example (cut ~1/3 of the run time). Let me take a look over things to see what I can improve as well.


---

Comment by git created at 2018-10-01 23:21:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-10-01 23:27:59

With Cythonizing the helper classes, I get a ~3x speedup versus 8.4.beta7:

```
sage: %time T = G.spqr_tree()
CPU times: user 2.63 s, sys: 72 ms, total: 2.7 s
Wall time: 2.66 s
```


I have not looked at the generated C code to see where inefficiencies are yet (i.e., types that we know that we can declare), but that might get even more speed out. However, the next step would be moving away from the Python types such as `list` and `dict` to C++ STL types `vector` and `map` with explicitly declared types. Actually, you might just consider separating these out into a separate C++  file/library (I believe you can simply replace `Py_ssize_t` with `ssize_t`). This will give you more control over things, but (of course) means you have to manage the memory more yourself.


---

Comment by tscrim created at 2018-10-01 23:44:54

Although to do that, I believe you would need to make `_LinkedList(Node)` and `_Component` into C++ classes. Well, I am saying/asking to get rid of as much of the Python as possible. :P


---

Comment by tscrim created at 2018-10-02 00:43:17

Actually, pulling it out to a separate library might be a little tricky because of having to work with the `Graph` object. Anyways, these are things that can wait for another ticket. Although one thing that would be really good would be if you could fix the type of `_LinkedListNode` (or maybe as a [fused type](https://cython.readthedocs.io/en/latest/src/userguide/fusedtypes.html)).


---

Comment by tscrim created at 2018-10-02 02:31:11

It seems like this code converts the graph internally into a specific format, so maybe it could work as a standalone library (or C++) with Sage handling the conversion.

Question, does `e_node_dict` always eventually expand out to `G.order()`? If so, then it would be better for it to be a fixed-length array of `_LinkedListNode`'s (once those become `struct`'s, but that seems a little more invasive of a change than I initially was thinking).

In general, the only bad bit of C code I see are those coming from the `graph_copy` manipulations and the fact that `_LinkedListNode` does not know its `data` type. For the graph manipulations, it might better to directly call the corresponding `_backend` method. At the very least, it avoids a level of python indirection, but you might have to unpack the `int_to_edge` into 3 arrays or an array of a `cdef struct` (I would go with the latter) and then feed each of those off.

I made `_LinkedListNode` know that `data` is a `Py_ssize_t`, which gave me a few extra ticks.

It might be better for `e_stack` to be a C++ STL `stack` (or `vector`) of `int`'s too.

I didn't see a general `_LinkedList` needing to be a doubly-linked list other than the `remove`. Do you think it would be possible to easily hold onto that `prev` so you don't need to manipulate a doubly-linked list (and only a singly-linked list)?

Speaking of which, the `_LinkedList` is a little strange in that its getter and setter methods are based on working with the nodes rather than the underlying data.

Okay, I am done with my comments and commits.


---

Comment by git created at 2018-10-02 02:31:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-10-02 13:10:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-02 13:17:22

Thank you Travis for the great improvements.

I removed `graph_copy`, `int_to_edge`, and `edge_to_int` as we don't need them anymore. In fact, we can use the status of an edge to decide if it is in the graph or not (active if 0,1,2 or inactive if -1).

I will check what can be done for `_LinkedListNode`. Note that I'm reluctant to go to C++ as I know very little of it.


---

Comment by git created at 2018-10-02 16:18:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-02 16:22:03

I changed `_LinkedListNode` and `_LinkedList` to struct, and changed the list/dict storing these objects to arrays. This gives additional speedup, but some parts of the code are less readable.


---

Comment by dcoudert created at 2018-10-02 16:41:04

To answer one of your questions. The doubly linked list is needed as we may replace the data stored in a node, pushed a new node at the beginning of the list, remove any node from a list, and merge 2 list. Using this data structure, these operations are performed in constant time.

I'm curious of the new running time of your favorite example.


---

Comment by tscrim created at 2018-10-02 22:53:09

Replying to [comment:17 dcoudert]:
> I changed `_LinkedListNode` and `_LinkedList` to struct, and changed the list/dict storing these objects to arrays. This gives additional speedup, but some parts of the code are less readable. 

I agree, but I feel like this is something we should care a little less about code reability than speed. In fact, this cut the time by another half:

```
sage: %time T = G.spqr_tree()
CPU times: user 1.2 s, sys: 36 ms, total: 1.23 s
Wall time: 1.2 s
```

Unfortunately Cython does not yet support C++ classes, which would have made the code more readable IMO. Although it just means we had to write more pure C-like code. The 2x speedup though makes it worth it.


---

Comment by tscrim created at 2018-10-02 23:03:30

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2018-10-02 23:03:30

Replying to [comment:18 dcoudert]:
> To answer one of your questions. The doubly linked list is needed as we may replace the data stored in a node, pushed a new node at the beginning of the list, remove any node from a list, and merge 2 list. Using this data structure, these operations are performed in constant time.

The only operation that requires the doubly part is the removal. The rest are constant time (with holding onto the head and tail of every linked list) with a singly-linked list. That is why I asked about holding onto the "previous" node of the one being removed if that was easily doable. I don't think so easily, it would probably make the code fairly difficult to read, and probably not gain much speed.

So I think this will be good for now. At least, I don't see a way to get really any more speed out. Thank you for all your hard work on this!


---

Comment by dcoudert created at 2018-10-03 06:18:01

Thank you for your great help.


---

Comment by vbraun created at 2018-10-04 21:54:09

Resolution: fixed
