# Issue 11292: Maximal orders in QuaternionAlgebra of prime discriminant has a bug

Issue created by migration from Trac.

Original creator: mmasdeu

Original creation time: 2011-06-11 09:12:18

Assignee: craigcitro

CC:  tornaria

Keywords: maximal order, quaternion algebra

In Sage 4.7 (and older) the following code enters an infinite loop:

```python
A.<i,j,k>=QuaternionAlgebra(17)
O=A.maximal_order()
```

The maximal_order() function is essentially a formula, except for when the prime (here 17) is 1 mod 8. In that case there is a mistake in how the formula ought to be.

It looks like the invariants as returned when starting from a Brandt module are in opposite order as when a QuaternionAlgebra is created by hand, and the code makes assumptions on that ordering.


---

Attachment


---

Comment by mmasdeu created at 2012-02-29 17:37:08

Changing status from new to needs_review.


---

Comment by davidloeffler created at 2012-03-13 09:25:03

Changing status from needs_review to positive_review.


---

Comment by davidloeffler created at 2012-03-13 09:25:03

It is absurd that code in the general-purpose sage/algebras/quatalg module calls code in sage/modular/quatalg/brandt -- we should move `sage.modular.quatalg.brandt.maximal_order` -- but that is orthogonal to this ticket. Patch looks fine and fixes the bug.


---

Comment by jdemeyer created at 2012-03-21 22:04:32

Resolution: fixed


---

Comment by daniels created at 2012-04-14 10:24:41

It looks like the new code can still produce incorrect results if p is 1 mod 8, e.g.:

```
sage: A.<i,j,k> = QuaternionAlgebra(17)
sage: print A.invariants()
(-3, -17)
sage: R = A.maximal_order()
sage: b = R.basis()
sage: print b
(1/2 + 1/2*j, 1/2*i + 1/2*k, -1/3*j - 1/3*k, k)
sage: b[0]*b[1]
9/2*i
sage: (b[0]*b[1]).reduced_norm() 
243/4
```

so the "order" is not actually multiplicatively closed.

The problem is that Pizer's formulas expect the invariants of the algebra to have a certain form, e.g.,

```
sage: A.<i,j,k> = QuaternionAlgebra(-17,-3)
sage: print A.maximal_order().basis()
(1/2 + 1/2*j, 1/2*i + 1/2*k, -1/3*j - 1/3*k, k)
```

seems to be correct. This could be fixed by simply swapping (i,j) in the formula depending on the invariants, but the invariants can deviate from the required form in more than one way, again possibly resulting in failure of the formula:


```
sage: A,<i,j,k> = QuaternionAlgebra(-17*9,-3)
sage: R = A.maximal_order()
sage: print A.maximal_order().basis()
(1/2 + 1/2*j, 1/2*i + 1/2*k, -1/3*j - 1/3*k, k)
sage: print (-1/3*j - 1/3*k).reduced_norm()
154/3
```


I'm not sure what the best way is to fix this: Just throw a NotImplementedError if the invariants are not of the required form or try to compute an isomorphism?

(PS: I've almost finished implementing a more general algorithm of Voight that would also work for non-prime discriminants, so perhaps not too much effort should be expended on this)
