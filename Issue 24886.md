# Issue 24886: Addition of Random Sampling method for closeness centrality to centrality.pyx

Issue created by migration from Trac.

Original creator: saiharsh

Original creation time: 2018-04-08 20:04:20

CC:  dcoudert dimpase

Keywords: Closeness Centrality

I would like to know, is it a good idea to add random sampling method for calculating closeness centrality, which will give error percentage < 5% on avg.

Reference:
https://arxiv.org/pdf/1409.0035.pdf

Currently, in sage, the closeness centrality is calculated by using
http://arxiv.org/abs/1507.01490


---

Comment by dcoudert created at 2018-04-09 07:06:50

It's an interesting proposal. You plan to code it in python or in cython ?


---

Comment by saiharsh created at 2018-04-09 14:09:54

Replying to [comment:1 dcoudert]:
> It's an interesting proposal. You plan to code it in python or in cython ?
Thanks, \\
As cython will give better performance than python. I will code it in cython. \\
Could you please say is Dijkstra algorithm in sage, is available in cython?. \\
If a graph is unweighted, shall I replace Dijkstra's algorithm with BFS for calculating closeness centrality. This will give an advantage in terms of running time.


---

Comment by dcoudert created at 2018-04-11 09:21:50

Before going to Cython, you have to learn more about the graphs module and it's various backends. Furthermore, you should have a look at the documentation of the `closeness_centrality` method. It clearly indicates that Dijkstra is used...

There is a Dijkstra implementation in the `SparseGraphBackend`. There is another one when you use the boost backend, plus the boost backend implements closeness centrality.


---

Comment by git created at 2018-04-14 15:24:54

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dcoudert created at 2018-04-14 15:29:27

on which branch are you working ? it does not seems to be a clean one.

You should start a new branch on top of last develop branch for instance.


---

Comment by saiharsh created at 2018-04-14 15:31:47

I will update it as soon as possible.
Replying to [comment:6 dcoudert]:
> on which branch are you working ? it does not seems to be a clean one.
> 
> You should start a new branch on top of last develop branch for instance.


---

Comment by saiharsh created at 2018-04-14 15:50:55

Just to be sure that I am doing right way.\\
http://doc.sagemath.org/html/en/developer/manual_git.html \\
Do I need to follow Checking Out Tickets and Pushing Your Changes to a Ticket from the above link?
Replying to [comment:6 dcoudert]:
> on which branch are you working ? it does not seems to be a clean one.
> 
> You should start a new branch on top of last develop branch for instance.


---

Comment by git created at 2018-04-14 18:31:20

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by saiharsh created at 2018-04-14 18:56:24

Replying to [comment:10 git]:
> Branch pushed to git repo; I updated commit sha1. Last 10 new commits:
> ||[60cb3ed](https://git.sagemath.org/sage.git/commit/?id=60cb3ede92ad0f2fbc5dbc0b13f9967baa1857a9)||`dfs_order reset`||
> ||[713062b](https://git.sagemath.org/sage.git/commit/?id=713062b0440319842c532f68fef26b42e9a19df9)||`Updated DFS, doctests passed, Reference and defination added`||
> ||[e8a817c](https://git.sagemath.org/sage.git/commit/?id=e8a817cf5d84c68e920c0da3181301ada3752e29)||`Examples, definition and reference updated`||
> ||[c5c8fca](https://git.sagemath.org/sage.git/commit/?id=c5c8fcab58e8c504cfc839e393ab28cb5bc40dc7)||`updated example, doctest passed.`||
> ||[79b64d6](https://git.sagemath.org/sage.git/commit/?id=79b64d603dc7cb9c342c1aea73416e12bf224090)||`Updated`||
> ||[e7ec5d6](https://git.sagemath.org/sage.git/commit/?id=e7ec5d6f4edb8ccc13b560572723adfb6d666b23)||`Extra spaces removed, minor updations`||
> ||[618efe4](https://git.sagemath.org/sage.git/commit/?id=618efe406a65110bd991c1568f848f9f49fc4d7b)||`Minor comments updated`||
> ||[ad71644](https://git.sagemath.org/sage.git/commit/?id=ad716448b924d312755abf2287fbb5b107d70624)||`Updated`||
> ||[9b43b3e](https://git.sagemath.org/sage.git/commit/?id=9b43b3e65623545d549e0003887e36d73d72a00d)||`git-trac-command folder removed.`||
> ||[f31e31c](https://git.sagemath.org/sage.git/commit/?id=f31e31c291ee587baa80b9f99c7e5dbc89fe251f)||`Closeness centrality added`||


---

Comment by git created at 2018-04-14 18:57:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-04-14 19:14:48

Solved the problem, I forgot to reset the master. \\
The current implementation uses BFS if a graph is unweighted and Dijkstra if a graph is weighted.

Algorithm: \\

1. Choose k random vertices from n vertices of input graph G.
2. Run k times BFS or Dijkstra and estimate closeness centrality for n-k vertices.

Instead of using 2D array and store `k*n` distances, I used a 1D array(sum_array), sum_array[v] will give the sum of the distances from v to k random vertices. From this optimization, less memory will be used.

Please let me know what more I can do to improve the code performance.



Replying to [comment:12 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[7ab7819](https://git.sagemath.org/sage.git/commit/?id=7ab7819982c339c84a22af4d0dd7b74e33ecac1f)||`Closeness centrality added`||


---

Comment by dcoudert created at 2018-04-15 12:04:51

Please do never hesitate to remind definitions, and more importantly to explain what your algorithm is doing. I had to look for definitions to guess what you are doing.

Before `improve the code performance`, the most important, and first step, is to have a clear and robust code. 

- Please check for typos: `verices`, 
- Your method is for undirected graphs only, right ?
- the notion of `farness`, used in other closeness centrality methods, is the sum of distances, `sum_array` in your code
- The method must start checking parameters before doing anything else
- You should reorganize your code to separate weighted and unweighted cases. There is no need to call `init_short_digraph` if the graph is weighted.
- `cdef long long int *distance` why `long long int` ? The largest distance is the diameter of the graph, and so in unweighted graphs it is at most `n-1`. So `int` or `uint32_t` is more than enough, no ?
- don't call a variable `sum`. It might conflict with builtin methods.
- `for i in range(0,k)` -> `for i in range(k)`
- In `distances = shortest_paths(G,randomk[i], algorithm=None)`, which `shortest_paths` method are you calling ? 
- according your code for weighted case, the `k` randomly chosen vertices have different centralities since the `sum` increases. Is that right ?

I will consider the unweighted case later. I'm not confortable with coding again a BFS for short digraph. I think we should do something more clever, like moving method `simple_BFS` from `distances_all_pairs.pyx` to the `static_sparse_graph` backend, and then use it.
So we could have a first ticket devoted to the cleaning of the usage of BFS for `short_digraph`.


---

Comment by saiharsh created at 2018-04-15 14:13:54

Replying to [comment:14 dcoudert]:
> Please do never hesitate to remind definitions, and more importantly to explain what your algorithm is doing. I had to look for definitions to guess what you are doing.
> 
Apologies, for not adding the proper explanation to the algorithm.
I will try to add all the required definitions whenever required.

> Before `improve the code performance`, the most important, and first step, is to have a clear and robust code. 
> 
> - Please check for typos: `verices`, 
> - Your method is for undirected graphs only, right ?
It's applicable to directed graph if it's connected.
> - the notion of `farness`, used in other closeness centrality methods, is the sum of distances, `sum_array` in your code
Farness says how far `u` is from `v`. \\
sum_array says it's the sum of distances from `v` to `k random vertices`.\\
Please correct me if I am wrong, shall I replace `sum_array` will `sum_of_farness`. \\
> - The method must start checking parameters before doing anything else
> - You should reorganize your code to separate weighted and unweighted cases. There is no need to call `init_short_digraph` if the graph is weighted.
Sure I will update it.
> - `cdef long long int *distance` why `long long int` ? The largest distance is the diameter of the graph, and so in unweighted graphs it is at most `n-1`. So `int` or `uint32_t` is more than enough, no ?
Yes, I will update it. I kept in mind that I will implement for weighted graph so I have taken long long int.

> - don't call a variable `sum`. It might conflict with builtin methods.
Sure shall I replace it with `sum_of_all_distances`? 

> - `for i in range(0,k)` -> `for i in range(k)`
> - In `distances = shortest_paths(G,randomk[i], algorithm=None)`, which `shortest_paths` method are you calling ?
It should be Dijstra, I will update the defination that weighted graph should have only positive weights.
 
> - according your code for weighted case, the `k` randomly chosen vertices have different centralities since the `sum` increases. Is that right ?
Yes, those `k` will be having exact closeness centrality value. as all the remaining vertices will be contributing in calculating closeness value for them. \\
   
Other `n-k` vertices will be estimated and only k vertices are contributing there distances in the estimation of `n-k` vertices. 
> 
> I will consider the unweighted case later. I'm not confortable with coding again a BFS for short digraph. I think we should do something more clever, like moving method `simple_BFS` from `distances_all_pairs.pyx` to the `static_sparse_graph` backend, and then use it.
> So we could have a first ticket devoted to the cleaning of the usage of BFS for `short_digraph`.
That is a really good suggestion. So shall I create a new ticket `cleaning of the usage of BFS` or do I need to do it in this ticket? 
If I create a new ticket then do I need to wait for `cleaning of the usage of BFS` to be accepted. 

Thank you, for taking your valuable time out for reviewing my code and giving feedback.


---

Comment by dcoudert created at 2018-04-15 16:49:52

> > - Your method is for undirected graphs only, right ?
> It's applicable to directed graph if it's connected.

OK, but again I had to check carefully the definition. The closeness centrality of v is computed using distances from each other node to v. So it works because you select k source nodes and compute shortest path distances from these nodes. So for a node v, you know the distance from a source node to v. It remains to sum over the sources.

> > - the notion of `farness`, used in other closeness centrality methods, is the sum of distances, `sum_array` in your code
> Farness says how far `u` is from `v`. \\

NO, it's not the distance from u to v, it's the sum of the distances from every nodes in the graph to u.
See https://en.wikipedia.org/wiki/Closeness_centrality where it is written: Closeness was defined by Bavelas (1950) as the reciprocal of the farness.

> sum_array says it's the sum of distances from `v` to `k random vertices`.\\
> Please correct me if I am wrong, shall I replace `sum_array` will `sum_of_farness`. \\

In this algorithm, instead of the farness, you use a kind of partial farness, that is the sum of the distances between each of the k source nodes of shortest path trees to v.

 
> > - The method must start checking parameters before doing anything else
> > - You should reorganize your code to separate weighted and unweighted cases. There is no need to call `init_short_digraph` if the graph is weighted.
> Sure I will update it.
> > - `cdef long long int *distance` why `long long int` ? The largest distance is the diameter of the graph, and so in unweighted graphs it is at most `n-1`. So `int` or `uint32_t` is more than enough, no ?
> Yes, I will update it. I kept in mind that I will implement for weighted graph so I have taken long long int.

but for weighted graphs you use `double`, which make sense since weights can be int or float.

 
> > - don't call a variable `sum`. It might conflict with builtin methods.
> Sure shall I replace it with `sum_of_all_distances`? 

for instance, yes.

However, keep in mind that this sum of all distances is the sum of the farness of the vertices.
So instead of adding each distances, it should be faster to compute the sum of the farness.

  
> > - `for i in range(0,k)` -> `for i in range(k)`
> > - In `distances = shortest_paths(G,randomk[i], algorithm=None)`, which `shortest_paths` method are you calling ?
> It should be Dijstra, I will update the defination that weighted graph should have only positive weights.
>  
> > - according your code for weighted case, the `k` randomly chosen vertices have different centralities since the `sum` increases. Is that right ?
> Yes, those `k` will be having exact closeness centrality value. as all the remaining vertices will be contributing in calculating closeness value for them. \\

This is true in undirected graphs only. In directed graph, you need distances to these k nodes to get exact closeness centrality.

 
> Other `n-k` vertices will be estimated and only k vertices are contributing there distances in the estimation of `n-k` vertices. 

OK

> > 
> > I will consider the unweighted case later. I'm not confortable with coding again a BFS for short digraph. I think we should do something more clever, like moving method `simple_BFS` from `distances_all_pairs.pyx` to the `static_sparse_graph` backend, and then use it.
> > So we could have a first ticket devoted to the cleaning of the usage of BFS for `short_digraph`.
> That is a really good suggestion. So shall I create a new ticket `cleaning of the usage of BFS` or do I need to do it in this ticket? 
> If I create a new ticket then do I need to wait for `cleaning of the usage of BFS` to be accepted. 

In general it's better to have targeted tickets. So yes we need a new ticket, and yes, you will have to add a dependency between this ticket and the new one, plus rebase on it.

It's more time and more work, but we should get in the end a better solution for this ticket.


---

Comment by saiharsh created at 2018-04-15 17:24:25

Replying to [comment:16 dcoudert]:
> > > - Your method is for undirected graphs only, right ?
> > It's applicable to directed graph if it's connected.
> 
> OK, but again I had to check carefully the definition. The closeness centrality of v is computed using distances from each other node to v. So it works because you select k source nodes and compute shortest path distances from these nodes. So for a node v, you know the distance from a source node to v. It remains to sum over the sources.
> 
As there is a confusion for a directed graph, let's fix that input graph can be undirected, weighted or unweighted.

> > > - the notion of `farness`, used in other closeness centrality methods, is the sum of distances, `sum_array` in your code
> > Farness says how far `u` is from `v`. \\
> 
> NO, it's not the distance from u to v, it's the sum of the distances from every nodes in the graph to u.
> See https://en.wikipedia.org/wiki/Closeness_centrality where it is written: Closeness was defined by Bavelas (1950) as the reciprocal of the farness.
> 
Yes, thanks for correcting me.
> > sum_array says it's the sum of distances from `v` to `k random vertices`.\\
> > Please correct me if I am wrong, shall I replace `sum_array` will `sum_of_farness`. \\
> 
> In this algorithm, instead of the farness, you use a kind of partial farness, that is the sum of the distances between each of the k source nodes of shortest path trees to v.
> 
Sure.
>  
> > > - The method must start checking parameters before doing anything else
> > > - You should reorganize your code to separate weighted and unweighted cases. There is no need to call `init_short_digraph` if the graph is weighted.
> > Sure I will update it.
> > > - `cdef long long int *distance` why `long long int` ? The largest distance is the diameter of the graph, and so in unweighted graphs it is at most `n-1`. So `int` or `uint32_t` is more than enough, no ?
> > Yes, I will update it. I kept in mind that I will implement for weighted graph so I have taken long long int.
> 
> but for weighted graphs you use `double`, which make sense since weights can be int or float.
> 
>  
> > > - don't call a variable `sum`. It might conflict with builtin methods.
> > Sure shall I replace it with `sum_of_all_distances`? 
> 
> for instance, yes.
> 
> However, keep in mind that this sum of all distances is the sum of the farness of the vertices.
> So instead of adding each distances, it should be faster to compute the sum of the farness.
The sum is farness, `not sum of farness`. \\
`sum`: it's the sum of the distances from every nodes in the graph to u(belong to k). \\
`sum of array`: it's the sum of the distances from k nodes in the graph to u(doesn't belong to k). \\
> 
>   
> > > - `for i in range(0,k)` -> `for i in range(k)`
> > > - In `distances = shortest_paths(G,randomk[i], algorithm=None)`, which `shortest_paths` method are you calling ?
> > It should be Dijstra, I will update the defination that weighted graph should have only positive weights.
> >  
> > > - according your code for weighted case, the `k` randomly chosen vertices have different centralities since the `sum` increases. Is that right ?
> > Yes, those `k` will be having exact closeness centrality value. as all the remaining vertices will be contributing in calculating closeness value for them. \\
> 
> This is true in undirected graphs only. In directed graph, you need distances to these k nodes to get exact closeness centrality.
> 
>  
> > Other `n-k` vertices will be estimated and only k vertices are contributing there distances in the estimation of `n-k` vertices. 
> 
> OK
> 
> > > 
> > > I will consider the unweighted case later. I'm not confortable with coding again a BFS for short digraph. I think we should do something more clever, like moving method `simple_BFS` from `distances_all_pairs.pyx` to the `static_sparse_graph` backend, and then use it.
> > > So we could have a first ticket devoted to the cleaning of the usage of BFS for `short_digraph`.
> > That is a really good suggestion. So shall I create a new ticket `cleaning of the usage of BFS` or do I need to do it in this ticket? 
> > If I create a new ticket then do I need to wait for `cleaning of the usage of BFS` to be accepted. 
> 
> In general it's better to have targeted tickets. So yes we need a new ticket, and yes, you will have to add a dependency between this ticket and the new one, plus rebase on it.
> 
> It's more time and more work, but we should get in the end a better solution for this ticket.
Sure I will generate a new ticket for `cleaning of the usage of BFS`

To be double sure, the main motive of the new ticket is to shift `BFS` from `distances_all_pairs.pyx` to the `static_sparse_backend.pyx` and update the reference where ever required.


---

Comment by dcoudert created at 2018-04-15 17:29:01

> To be double sure, the main motive of the new ticket is to shift `BFS` from `distances_all_pairs.pyx` to the `static_sparse_backend.pyx` and update the reference where ever required. 
> 

Yes. This BFS method is specific to `static_sparse_backend.pyx`, so it's better to have it in this file, and then cimport it when needed.


---

Comment by saiharsh created at 2018-04-15 17:36:59

Replying to [comment:18 dcoudert]:

> Yes. This BFS method is specific to `static_sparse_backend.pyx`, so it's better to have it in this file, and then cimport it when needed.
> 
Thanks, I will create a new ticket and keep you in cc, as my final exams are coming I might not be able to complete it sooner, I will try to update you on or before 22nd.


---

Comment by dcoudert created at 2018-05-01 08:11:31

To indicate a dependency, the right way is to put ticket number #25223 in the `Dependencies` cell of ticket description. I let you do it when you have rebase this ticket on top of it and perform the changes.

Don't forget to set the ticket to `needs review` when ready.


---

Comment by saiharsh created at 2018-05-01 17:21:56

simple_BFS() will return a single value i.e the highest distance value found in graph G from source but I need complete distance array.

Could you suggest what shall I do?
1. Change the definition of simple_BFS i.e pass extra parameter i.e flag, if the flag value is 'eccentricity' return single value if the flag is 'distance_array' return distance array.

2. Use own bfs function, a small advantage, it will take O(n) timeless, when comparing to step 1.


---

Comment by dcoudert created at 2018-05-01 17:46:55

You should reread the code of `simple_BFS`, that is not a function but a method/procedure, and revise the use of pointers in C ;)

The method `simple_BFS` takes as input an array `distances`. It fills that array. So you have access to all distances after the call.


---

Comment by git created at 2018-05-01 20:38:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-01 20:43:54

Replying to [comment:24 dcoudert]:
> You should reread the code of `simple_BFS`, that is not a function but a method/procedure, and revise the use of pointers in C ;)
> 
> The method `simple_BFS` takes as input an array `distances`. It fills that array. So you have access to all distances after the call.

Yep, you are right, it's a pointer and it's updated.
Made necessary changes.

Please have a look and let me know your feedback.


---

Comment by dcoudert created at 2018-05-01 20:59:20

There is a mistake in your code with the labels of vertices in `Graph` and in `short_digraph`.

In `Graph`, the label of a vertex can be an integer, a tuple, a string, or any hashable data structure. In `short_digraph`, vertices are integers from 0 to `n-1`. If you check in methods using short digraph, you can see the use of a list `vertex_to_int` and a dictionary `int_to_vertex` used to use the right label. An important assumption in the graph module is that the list on vertices is always ordered the same way. So usually you can do `int_to_vertex = G.vertices()` and later `int_to_vertex[i]` to access the right vertex label. And `vertex_to_int = {u:i for i,u in enumerate(int_to_vertex)}` can be used when you need the inverse function (not sure you need it here).

You must correct you code to take that into account.


---

Comment by git created at 2018-05-02 10:11:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-02 10:13:02

Replying to [comment:29 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[bc78e66](https://git.sagemath.org/sage.git/commit/?id=bc78e665b42a77cdc0025309cfc5c1bd14d339b9)||`Vertex label issue solved`||

Thanks for identifying the mistake, corrected the code, please let me know if any future changes are required.


---

Comment by dcoudert created at 2018-05-02 12:44:47

You have not adequately corrected the code. Have you tested it ?

I give you a set of corrections to be done.


- If the graph is directed, you must raise an error.

```
-    if G.is_directed():
-        return "G should be undirected Graph."
+    if G.is_directed():
+        raise ValueError("G should be undirected Graph.")
```

- `cdef int i,j,u,qstart, qend, v` -> `cdef int i, j, u, qstart, qend, v`
- `cdef uint32_t *p_tmp` not used, so remove
- `cdef bint weighted = G.weighted()` not needed. You use this value only once

- Check of input parameters must be performed before any malloc and raise an error !

```
-    if k > n:
-        return "k value need to be less than number of nodes"
+    if k > n:
+        raise ValueError("k value need to be less than number of nodes")
```

- `cdef list int_to_vertex = G.vertices()` must be put before the `if weighted` test. It will be used in the weighted case too
- `if weighted:` -> `if G.weighted():`
- `from sage.graphs.base.boost_graph import shortest_paths` you should use `cimport`, no ?

Weighted part:
- `distances = shortest_paths(G,randomk[i], algorithm='Dijstra')` the value `randomk[i]` is an integer in range `0..n-1`. This is not a valid vertex label. You must use `int_to_vertex[randomk[i]]`.
- `partial_farness[vertex] = float(distances[vertex])`. Here, `vertex` is the label of a vertex of the graph and `partial_farness` is an array of order `n`. So you need to use a mapping `vertex_to_int`.


Unweighted part:
- `bitset_init` must be done before the for loop. Then, inside the loop you can do a `bitset_clear`.
- `NULL,waiting_list,seen)` -> `NULL, waiting_list, seen)`


---

Comment by git created at 2018-05-03 14:50:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-03 15:00:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-03 15:14:04

1. Added ValueError() instead of return message
2. Removed all the unused variables
3. Added test cases
4. Fixed the gap in weighted part.
Can't add cimport as `boost_graph.pxd` doesn't have defination of shortest_paths(), shall I go ahead and add necessary lines in `boost_graph.pxd` for cimport instead of import. \\

Tested on both weighted and unweighted.

weighted graph G = `Graph([['0', '1',1],['0', '7',1],['0', '3',1],['0', '11',1],['2', '3',1],['1', '2',1],['1', '12',1],['2', '12',1],['3', '4',1],['3', '6',1],['4', '5',1],['4', '7',1],['4', '6',1],['5', '6',1],['7', '10',1],['7', '8',1],['7', '11',1],['8', '9',1],['8', '10',1],['8', '11',1],['9', '11',1]], weighted = True)`

weighted graph `G = Graph([['0', '1'],['0', '7'],['0', '3'],['0', '11'],['2', '3'],['1', '2'],['1', '12'],['2', '12'],['3', '4'],['3', '6'],['4', '5'],['4', '7'],['4', '6'],['5', '6'],['7', '10'],['7', '8'],['7', '11'],['8', '9'],['8', '10'],['8', '11'],['9', '11']])`

Please let me know if any more modifications needed.


---

Comment by dcoudert created at 2018-05-03 16:51:25

Good. I have few more comments.

> Can't add cimport as `boost_graph.pxd` doesn't have defination of shortest_paths(), shall I go ahead and add necessary lines in `boost_graph.pxd` for cimport instead of import. \\

Well, I don't know if it is really interesting to cimport it.

You may however do something like that to clarify in your code that this method uses boost:

```
from sage.graphs.base.boost_graph import shortest_paths as boost_shortest_paths
```



You must add
- a one line description of the method at it's beginning (see other methods for examples).

- a line like `:func:`centrality_closeness_random_k` | copy-paste-of-the-one-line-description` at the top of the file. It's a table to show what the module contains

Then,
- as for ticket #25002, references must be placed in `src/doc/en/reference/references/index.rst`. You could also actualize the ref https://dl.acm.org/citation.cfm?id=2660465

- You have put a TESTS section. You could also add an EXAMPLES section.

- ```G`` a undirected Graph` -> ```G`` -- a undirected Graph` and same modification for other input

- OUTPUT block: the description is not exactly what you return. By the way, you could return a dictionary indexed by vertices.

- `l = []`. You could directly do `l = list(range(n)`. 

- Instead of using `seen_random_vertices[i]`, may be you could only use the shuffled list `l` where the `k` first elements are those in `randomk` and elements `k..n-1` are those for which `seen_random_vertices[i]==0`. Think about it and see if you can simplify the code using this idea.

- I realize that `simple_BFS` calls `bitset_clear`. So you don't need to do it in `centrality_closeness_random_k`

- you will have to add a `bitset_free(seen)` somewhere ;)


---

Comment by saiharsh created at 2018-05-05 12:07:49

Replying to [comment:35 dcoudert]:
> Good. I have few more comments.
> 
> > Can't add cimport as `boost_graph.pxd` doesn't have defination of shortest_paths(), shall I go ahead and add necessary lines in `boost_graph.pxd` for cimport instead of import. \\
> 
> Well, I don't know if it is really interesting to cimport it.
> 
> You may however do something like that to clarify in your code that this method uses boost:
> {{{
> from sage.graphs.base.boost_graph import shortest_paths as boost_shortest_paths
> }}}
Updated
> 
> 
> You must add
> - a one line description of the method at it's beginning (see other methods for examples).
> 
> - a line like `:func:`centrality_closeness_random_k` | copy-paste-of-the-one-line-description` at the top of the file. It's a table to show what the module contains
> 
Added
> Then,
> - as for ticket #25002, references must be placed in `src/doc/en/reference/references/index.rst`. You could also actualize the ref https://dl.acm.org/citation.cfm?id=2660465
> 
Added [EDI2014] to index.rst \\
There are few references like BCM15(centrality_closeness_top_k) which is not available at index.rst \\

> - You have put a TESTS section. You could also add an EXAMPLES section.
As it's random answers will be keep on changing, any suggestion how I should design examples? \\
Which case I need to add in current test section?
> 
> - ```G`` a undirected Graph` -> ```G`` -- a undirected Graph` and same modification for other input
> 
> - OUTPUT block: the description is not exactly what you return. By the way, you could return a dictionary indexed by vertices.
> 
> - `l = []`. You could directly do `l = list(range(n)`. 
Updated
> 
> - Instead of using `seen_random_vertices[i]`, may be you could only use the shuffled list `l` where the `k` first elements are those in `randomk` and elements `k..n-1` are those for which `seen_random_vertices[i]==0`. Think about it and see if you can simplify the code using this idea.
> 
Good idea, thanks, as random vertices are stored in `l` there is no need to use `randomk` and `seen_random_vertices`.
> - I realize that `simple_BFS` calls `bitset_clear`. So you don't need to do it in `centrality_closeness_random_k`
> 
> - you will have to add a `bitset_free(seen)` somewhere ;)
Updated


---

Comment by git created at 2018-05-05 12:10:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-05-05 12:47:26

The code is becoming very simple and easy to read. I like that.

> > You must add
> > - a one line description of the method at it's beginning (see other methods for examples).

you forgot that one.

I suggest `Return an estimation of the closeness centrality of ``G``.`\\ \\
 
> > - a line like `:func:`centrality_closeness_random_k` | copy-paste-of-the-one-line-description` at the top of the file. It's a table to show what the module contains
> > 
> Added

should be same as above\\ \\

 
> > - as for ticket #25002, references must be placed in `src/doc/en/reference/references/index.rst`. You could also actualize the ref https://dl.acm.org/citation.cfm?id=2660465
> > 
> Added [EDI2014] to index.rst \\
> There are few references like BCM15(centrality_closeness_top_k) which is not available at index.rst \\

True, you can move them since it's only few references.\\ \\
 

> > - You have put a TESTS section. You could also add an EXAMPLES section.
> As it's random answers will be keep on changing, any suggestion how I should design examples? \\
> Which case I need to add in current test section?

One idea is to take a small distance regular graph like a cycle with 5 nodes or a PetersenGraph. Then, you can extract from the solution the list of values, and sort it. It should always be the same, no? \\


What if `G.order() == 0` or `G.order() == 1` ?
What if `G.size() == 0` ?
In both cases you can directly return the solution.

Also, the test `if k > n:` should at the very beginning, before any malloc.\\ \\



> > - I realize that `simple_BFS` calls `bitset_clear`. So you don't need to do it in `centrality_closeness_random_k`
TODO\\ \\


Other corrections:


```
-    The algorithm is based on performing a breadth-first-search (BFS) for
-    unweighted graph and Dijkstra for weighted graph from each vertex v
-    from set S, set S: Randomly choose k nodes from n nodes, where k < n
-    and n is no of nodes in input graph, by using this knowledge estimate
-    closeness centrality for n - k vertices.
+    The algorithm first randomly selects a set ``S`` of ``k`` vertices.
+    Then it computes a the shortest path distances from each vertex in 
+    ``S`` (using breadth-first-search (BFS) for unweighted graph and 
+    Dijkstra for weighted graph) and uses this knowledge to estimate
+    the closeness centrality of all vertices.
```



```
-    A dictionary indexed by vertices and values as estimated closeness centrality.
+    A dictionary indexed by vertices and values are estimated closeness centrality.
```



---

Comment by git created at 2018-05-05 12:55:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-10 15:32:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-10 15:41:12

Made necessary changes.
1. Updated the reference list i.e index.rst and removed the reference block from the code.
2. Added one example, if `k = n` we will get the same result every time as it's exact not estimated.
3. Added one test case.

It's saying auto merge is failed, is it related to my recent commit or it will be taken care.

Let me know your feedback.


---

Comment by dcoudert created at 2018-05-10 17:56:32

I also have a merge conflict when trying your branch.

I suggest that you first make sure to use the most develop branch of sagemath (8.3.beta0), and then try to rebase your ticket on it. You will have to resolve the merge conflit.


---

Comment by dcoudert created at 2018-05-15 11:07:06

I'm adding Dima to the discussion since he has much more expertise than myself on git.

`@`Dima: Sai Harsh did something wrong with its commits and I don't know how to help him resolving the issue. It might be simple to fix but beyond my ability to use git. Thanks.


---

Comment by saiharsh created at 2018-05-15 11:23:51

Replying to [comment:43 dcoudert]:
> I'm adding Dima to the discussion since he has much more expertise than myself on git.
> 
> `@`Dima: Sai Harsh did something wrong with its commits and I don't know how to help him resolving the issue. It might be simple to fix but beyond my ability to use git. Thanks. 

I committed the code on Sage 8.1beta0 and sage was updated to 8.3beta0 because of which automerge failed.

I followed the below doc to update the master. \\
http://doc.sagemath.org/html/en/developer/manual_git.html

But couldn't resolve the problem.

Please let me know what I should do to solve the problem.


---

Comment by dimpase created at 2018-05-15 11:41:01

for some reason [BCM15] was in src/sage/graphs/centrality.pyx as well as in the index.rst

So I removed it from the former and pushed the result in a public branch.

I started by checking out the latest develop branch from trac, and then pulling the ticket's branch. This failed (as expected) with conflicts marked in centrality.pyx; and that conflict was exactly the spurrous reference to [BCM15], which I removed.


---

Comment by dcoudert created at 2018-05-15 12:08:06

Thank you very much ! I really need to follow a git training...


---

Comment by dcoudert created at 2018-05-16 07:34:32

- `The algorithm first randomly selects a set ``S`` of ``k`` vertices.` -> `The algorithm first randomly selects a set `S` of `k` vertices.`. Both forms ```S``` and ``S`` are possible, but ``S`` will use latex and is more appropriate for math symbol. Update all the paragraph please

- I suspect that the method is not working for graphs with loops or multiple edges, right ? if it is the case, add `G._scream_if_not_simple()` as first instruction.

- for the unweighted case, you must add `free_short_digraph` at the end of the block.

almost done ;)


---

Comment by saiharsh created at 2018-05-16 10:31:32

Replying to [comment:46 dimpase]:
> for some reason [BCM15] was in src/sage/graphs/centrality.pyx as well as in the index.rst
> 
> So I removed it from the former and pushed the result in a public branch.
> 
> I started by checking out the latest develop branch from trac, and then pulling the ticket's branch. This failed (as expected) with conflicts marked in centrality.pyx; and that conflict was exactly the spurrous reference to [BCM15], which I removed.

`@`dimpase\\
Thanks for solving the problem. \\
1. Could you please say what are the commands I need to follow to solve the problem if I face it in future. (i.e auto merge failed)
2. What is the right way to update the master and rebase it to the current branch?


---

Comment by saiharsh created at 2018-05-16 10:34:09

Replying to [comment:48 dcoudert]:
> - `The algorithm first randomly selects a set ``S`` of ``k`` vertices.` -> `The algorithm first randomly selects a set `S` of `k` vertices.`. Both forms ```S``` and ``S`` are possible, but ``S`` will use latex and is more appropriate for math symbol. Update all the paragraph please
> 
Yes I will update it.

> - I suspect that the method is not working for graphs with loops or multiple edges, right ? if it is the case, add `G._scream_if_not_simple()` as first instruction.
Yes the method work only on simple graph.
> 
> - for the unweighted case, you must add `free_short_digraph` at the end of the block.
Sure, I will.
> 
> almost done ;)
Thanks.


---

Comment by dcoudert created at 2018-05-16 10:56:26

and do not forget to set this ticket to "needs review" when you think it is ready for review.


---

Comment by dimpase created at 2018-05-16 11:19:12

Replying to [comment:49 saiharsh]:
> Replying to [comment:46 dimpase]:
> > for some reason [BCM15] was in src/sage/graphs/centrality.pyx as well as in the index.rst
> > 
> > So I removed it from the former and pushed the result in a public branch.
> > 
> > I started by checking out the latest develop branch from trac, and then pulling the ticket's branch. This failed (as expected) with conflicts marked in centrality.pyx; and that conflict was exactly the spurrous reference to [BCM15], which I removed.
> 
> `@`dimpase\\
> Thanks for solving the problem. \\
> 1. Could you please say what are the commands I need to follow to solve the problem if I face it in future. (i.e auto merge failed)


There is no unique way to solve such issues. For starters, you need to understand the difference between merging and rebasing, see e.g. https://www.atlassian.com/git/tutorials/merging-vs-rebasing

> 2. What is the right way to update the master and rebase it to the current branch?

what I did: 

 1) make a fresh clone/branch of the master (more precisely, the `develop` branch on the git trac server). Say, if you already have a cloned repo, and assuming 
 `trac` is the name of the git trac remote, as shown by `git remote -v`, this would be `git checkout -b my_new_version trac/develop` followed by `git pull trac develop`.

 2) merge your changes; say, if they are already on the git trac in a branch foo, this could done by `git pull trac foo`. If it's merged automatically, done. Else, you need to resolve conflicts and commit the changes you've done. I simply use the command line, although there are various merging tools (they are needed in hard cases with a lot of changes, hopefully not what you have to deal with). This means, edit the files with conflicts marked by `>>>>`, `<<<<`, and `=====` markers, and commit the changes. Finally, don't forget to push your new branch to trac. 

 3) alternatively, instead of 1) and 2), you could have done `git pull trac develop` on your branch and resolved conflicts there, just as in 2).

Rebasing is less intuitive. I recommend doing `git pull trac develop` on the branch you are working as often as needed (approximately after each new beta/release candidate), but before doing this do a push to git trac server as a backup.
This way hopefully rebasing won't be needed.

Needless to say, make sure your branches are backed up often, say by pushing to a git server (trac or not).


---

Comment by saiharsh created at 2018-05-17 06:46:44

Replying to [comment:48 dcoudert]:
> - `The algorithm first randomly selects a set ``S`` of ``k`` vertices.` -> `The algorithm first randomly selects a set `S` of `k` vertices.`. Both forms ```S``` and ``S`` are possible, but ``S`` will use latex and is more appropriate for math symbol. Update all the paragraph please
There are few paragraphs, in which ```x``` used instead of ``x``. \\
Shall I replace for all ```x``` with ``x`` or only to centrality_closeness_random_k() paragraphs?


---

Comment by dcoudert created at 2018-05-17 07:09:27

only in your method.


---

Comment by git created at 2018-05-17 08:28:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-05-17 08:34:50

Not in the Input block. Sorry for the confusion.


---

Comment by git created at 2018-05-17 08:39:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-17 08:52:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-17 08:57:39

Replying to [comment:56 dcoudert]:
> Not in the Input block. Sorry for the confusion.
I have updated only on definition block.
Please have a look.


---

Comment by dcoudert created at 2018-05-17 09:05:09

Set the ticket to needs review if you think it is ready for review = you are satisfied with the code, you did several trials with different graphs and it's working well, you have build the documentation and it displays well.


---

Comment by saiharsh created at 2018-05-17 09:08:20

Replying to [comment:60 dcoudert]:
> Set the ticket to needs review if you think it is ready for review = you are satisfied with the code, you did several trials with different graphs and it's working well, you have build the documentation and it displays well.

Thanks, yes I feel it's ready.


---

Comment by saiharsh created at 2018-05-17 09:09:29

Changing status from new to needs_review.


---

Comment by git created at 2018-05-19 09:02:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-05-19 09:07:34

I did some minor corrections in this ticket. Please check if it is OK for you.

I have a question for graphs without edges. In method `centrality_closeness`, it is written that the closeness centrality of a vertex without (out)neighbors is not defined. So the method returns an empty dictionary. Here, we raise an error. I don't know which behavior is best. What do you think ?


---

Comment by saiharsh created at 2018-05-19 13:22:17

Replying to [comment:64 dcoudert]:
> I did some minor corrections in this ticket. Please check if it is OK for you.
Thanks, the current code is more readable than the previous version. \\
One doubt can't we use `l[i]` value directly instead of storing it in `u`? is it used for readability? 

> I have a question for graphs without edges. In method `centrality_closeness`, it is written that the closeness centrality of a vertex without (out)neighbors is not defined. So the method returns an empty dictionary. Here, we raise an error. I don't know which behavior is best. What do you think ?
I feel raise error is better because the user will get to know more information when compared to returning an empty list. \\
Correct me if I am wrong.


---

Comment by git created at 2018-05-19 15:39:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-05-19 15:42:18

> One doubt can't we use `l[i]` value directly instead of storing it in `u`? is it used for readability? 

I had in mind that it could be faster that way, but I agree that this is such a minor step that is it not interesting. I reverted this change.

> 
> > I have a question for graphs without edges. In method `centrality_closeness`, it is written that the closeness centrality of a vertex without (out)neighbors is not defined. So the method returns an empty dictionary. Here, we raise an error. I don't know which behavior is best. What do you think ?
> I feel raise error is better because the user will get to know more information when compared to returning an empty list. \\
> Correct me if I am wrong.

To be consistent with the `centrality_closeness` method, we can just consider that this value is not defined for isolated vertices. Check the way I propose to do that, avoiding as much as possible to select isolated vertices.


---

Comment by dimpase created at 2018-05-19 16:45:07

Instead of throwing an error, there is also an option to return `None`. (Just saying :-))


---

Comment by dcoudert created at 2018-05-19 17:31:46

You are right, but I prefer to have similar behavior than `closeness_centrality`.


---

Comment by git created at 2018-05-19 20:54:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-19 21:07:52

Replying to [comment:67 dcoudert]:
> To be consistent with the `centrality_closeness` method, we can just consider that this value is not defined for isolated vertices. Check the way I propose to do that, avoiding as much as possible to select isolated vertices.
I have forgotten about the isolated case, thanks for pointing it out.
For it `n` value need to be reduced as isolated vertices are not contributing anything in estimating the closeness centrality for other vertices. \\
1. Remove all the isolated vertices from `G`.
2. Find Closeness centrality on `G'`.
3. Add all isolated vertices to `G'`.
Closeness centrality for isolated vertices is zero.

Please have a look and let me know your feedback.
----
New commits:


---

Comment by dcoudert created at 2018-05-20 08:17:31

It is very bad to modify the input graph. It is a typical source of errors, so you should not do it.

A typical bug is when the graph is immutable:

```
sage: H = Graph([[0,1,2], [(0,1)]], immutable=True)
sage: centrality_closeness_random_k(H, 1)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
...
ValueError: Thou shalt not remove a vertex from an immutable graph
```




Also, I don't understand why the returned values are not the same in this example.

```
sage: from sage.graphs.centrality import centrality_closeness_random_k
sage: G = Graph([(0,1), (2,3)])
sage: centrality_closeness_random_k(G, 4)
{0: 1.5, 1: 3.536366632952126e-08, 2: 1.5, 3: 1.5}
sage: G.add_vertex(4)
sage: centrality_closeness_random_k(G, 4)
{0: 3.465914218230295e-08, 1: 3.465914218230295e-08, 2: 1.5, 3: 1.5, 4: 0.0}
```


Finally, as I already said, the behavior must be unified with the `centrality_closeness` method.


---

Comment by dcoudert created at 2018-05-20 08:17:31

Changing status from needs_review to needs_work.


---

Comment by saiharsh created at 2018-05-20 09:36:31

Replying to [comment:72 dcoudert]:
> It is very bad to modify the input graph. It is a typical source of errors, so you should not do it.
> 
> A typical bug is when the graph is immutable:
> {{{
> sage: H = Graph([[0,1,2], [(0,1)]], immutable=True)
> sage: centrality_closeness_random_k(H, 1)
> ---------------------------------------------------------------------------
> ValueError                                Traceback (most recent call last)
> ...
> ValueError: Thou shalt not remove a vertex from an immutable graph
> }}}
> 
I will update it the code in which I won't remove the vertex from input graph `G`.
> 
> 
> Also, I don't understand why the returned values are not the same in this example.
> {{{
> sage: from sage.graphs.centrality import centrality_closeness_random_k
> sage: G = Graph([(0,1), (2,3)])
> sage: centrality_closeness_random_k(G, 4)
> {0: 1.5, 1: 3.536366632952126e-08, 2: 1.5, 3: 1.5}
> sage: G.add_vertex(4)
> sage: centrality_closeness_random_k(G, 4)
> {0: 3.465914218230295e-08, 1: 3.465914218230295e-08, 2: 1.5, 3: 1.5, 4: 0.0}
> }}}
> 
It's because the estimation is defined on connected Graph not on disconnected graph.
Shall I use `connected_components_subgraphs()` function and estimate on connected component? but shall I take `k` value for each connected component? for some connected component `k<n` and for other `k>n`. \\
One option could be `k=n` if `k>n` or we can update input should be connected. \\
Which one could be better?

> Finally, as I already said, the behavior must be unified with the `centrality_closeness` method.
Yes, the method should be.


---

Comment by dcoudert created at 2018-05-20 10:53:04

I don't see any suitable way to handle properly connected components and isolated vertices.
Also I propose a radical solution: make this method work only for connected graphs, and raise an error if the graph is not connected.
Otherwise we will continue to discuss for ever without reaching a satisfactory solution.

So do the required modifications and mention it in the documentation of the method.


---

Comment by git created at 2018-05-20 15:00:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-05-20 15:07:34

Replying to [comment:74 dcoudert]:
> I don't see any suitable way to handle properly connected components and isolated vertices.
> Also I propose a radical solution: make this method work only for connected graphs, and raise an error if the graph is not connected.
> Otherwise we will continue to discuss for ever without reaching a satisfactory solution.
> 
> So do the required modifications and mention it in the documentation of the method.
As is_connected case is added. They won't be any Isolated vertices case. \\
As `closeness_centrality_top_k` make `k = n` if `k > n`, I updated same in random_k.


---

Comment by dcoudert created at 2018-05-20 17:09:07

OK. Make sense.

Don't forget to set the ticket to "needs review" when you think it's ready.


---

Comment by saiharsh created at 2018-05-20 17:22:48

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-05-21 09:26:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-05-21 09:28:39

I fixed a doctest error and did some minor corrections. In particular, check connectivity after other tests.

Do you agree ?


---

Comment by saiharsh created at 2018-05-21 09:38:28

Replying to [comment:80 dcoudert]:
> I fixed a doctest error and did some minor corrections. In particular, check connectivity after other tests.
> 
> Do you agree ?
Yes I agree.
Thanks for taking the case for a graph with zero vertices which is a connected graph.


---

Comment by dcoudert created at 2018-05-21 09:40:28

> Thanks for taking the case for a graph with zero vertices which is a connected graph. 
It was causing an error since a bitset cannot have size 0.


---

Comment by dcoudert created at 2018-05-21 09:41:52

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2018-05-21 09:41:52

For me this patch is now good to go.


---

Comment by vbraun created at 2018-05-24 07:10:49

Resolution: fixed
