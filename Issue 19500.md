# Issue 19500: SetPartition.to_permutation().cycle_tuples() is not the identity

archive/issues_019500.json:
```json
{
    "body": "Keywords: set partitions, permutations\n\nThe docstring of `SetPartition.to_permutation` says:\n\n```\n  Convert self to a permutation by considering the partitions ascycles.\n```\n\nHowever, I was very surprised to learn that it does not do this by sorting the blocks.  That is, there is currently no guarantee that:\n\n```\n  SetPartition([[1,2,3]]).to_permutation() == Permutation([2,3,1])\n```\n\nSince this caused some discomfort (I thought a conjecture I like a lot would be wrong...) I propose to change this behaviour.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19737\n\n",
    "created_at": "2015-12-17T07:40:21Z",
    "labels": [
        "combinatorics",
        "major",
        "bug"
    ],
    "title": "SetPartition.to_permutation().cycle_tuples() is not the identity",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19500",
    "user": "mantepse"
}
```
Keywords: set partitions, permutations

The docstring of `SetPartition.to_permutation` says:

```
  Convert self to a permutation by considering the partitions ascycles.
```

However, I was very surprised to learn that it does not do this by sorting the blocks.  That is, there is currently no guarantee that:

```
  SetPartition([[1,2,3]]).to_permutation() == Permutation([2,3,1])
```

Since this caused some discomfort (I thought a conjecture I like a lot would be wrong...) I propose to change this behaviour.

Issue created by migration from https://trac.sagemath.org/ticket/19737





---

archive/issue_comments_267905.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-12-17T10:09:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267905",
    "user": "mantepse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_267906.json:
```json
{
    "body": "What on earth is this `SetPartition.to_permutation` function? How is it mathematically defined? `O_o`",
    "created_at": "2015-12-17T12:13:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267906",
    "user": "ncohen"
}
```

What on earth is this `SetPartition.to_permutation` function? How is it mathematically defined? `O_o`



---

archive/issue_comments_267907.json:
```json
{
    "body": "Okay I see. Findstat.",
    "created_at": "2015-12-17T12:17:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267907",
    "user": "ncohen"
}
```

Okay I see. Findstat.



---

archive/issue_comments_267908.json:
```json
{
    "body": "I just wrote to sage-devel. I do not see how `to_permutation` can be properly defined on this class of objects. In particular it raises an exception whenever the ground set of the `SetPartition` object is not a set of integers.\n\nhttps://groups.google.com/d/topic/sage-devel/OpwJoAza5OY/discussion\n\nNathann",
    "created_at": "2015-12-17T12:25:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267908",
    "user": "ncohen"
}
```

I just wrote to sage-devel. I do not see how `to_permutation` can be properly defined on this class of objects. In particular it raises an exception whenever the ground set of the `SetPartition` object is not a set of integers.

https://groups.google.com/d/topic/sage-devel/OpwJoAza5OY/discussion

Nathann



---

archive/issue_comments_267909.json:
```json
{
    "body": "Replying to [comment:5 ncohen]:\n> Okay I see. Findstat.\n\nNo, this has nothing to do with FindStat (except for both being about combinatorics).",
    "created_at": "2015-12-17T13:14:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267909",
    "user": "mantepse"
}
```

Replying to [comment:5 ncohen]:
> Okay I see. Findstat.

No, this has nothing to do with FindStat (except for both being about combinatorics).



---

archive/issue_comments_267910.json:
```json
{
    "body": "A function which is named `to_permutation` and decorated from its origin with a `combinatorial_map` decorator? I say that's for FindStat. And you are free to not believe me `:-P`",
    "created_at": "2015-12-17T13:15:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267910",
    "user": "ncohen"
}
```

A function which is named `to_permutation` and decorated from its origin with a `combinatorial_map` decorator? I say that's for FindStat. And you are free to not believe me `:-P`



---

archive/issue_comments_267911.json:
```json
{
    "body": "\n```\nsage: s=SetPartition([[0,1,2],[3,4]])\nsage: s.to_permutation()\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n...\nValueError: All elements should be strictly positive integers, and I just found a negative one.\n```\n\n\neven 0 is negative in this code...",
    "created_at": "2015-12-18T09:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267911",
    "user": "dimpase"
}
```


```
sage: s=SetPartition([[0,1,2],[3,4]])
sage: s.to_permutation()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
...
ValueError: All elements should be strictly positive integers, and I just found a negative one.
```


even 0 is negative in this code...



---

archive/issue_comments_267912.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-12-18T09:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267912",
    "user": "dimpase"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_267913.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-12-18T10:37:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267913",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_267914.json:
```json
{
    "body": "Replying to [comment:9 dimpase]:\n> {{{\n> sage: s=SetPartition([[0,1,2],[3,4]])\n> sage: s.to_permutation()\n> ---------------------------------------------------------------------------\n> ValueError                                Traceback (most recent call last)\n> ...\n> ValueError: All elements should be strictly positive integers, and I just found a negative one.\n> }}}\n> \n> even 0 is negative in this code...\n\nPlease open another ticket for this, since it is a problem with the Permutation code:\n\n```\nsage: Permutation(((0,1),))\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-22-0bc8d0916c3c> in <module>()\n----> 1 Permutation(((Integer(0),Integer(1)),))\n\n/home/martin/sage-master/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/home/martin/sage-master/src/build/cythonized/sage/misc/classcall_metaclass.c:1239)()\n    324         \"\"\"\n    325         if cls.classcall is not None:\n--> 326             return cls.classcall(cls, *args, **kwds)\n    327         else:\n    328             # Fast version of type.__call__(cls, *args, **kwds)\n\n/home/martin/sage-master/local/lib/python2.7/site-packages/sage/combinat/permutation.pyc in __classcall_private__(cls, l, check_input)\n    530                 if isinstance(l[0], tuple):\n    531                     n = max(max(x) for x in l)\n--> 532                     return from_cycles(n, [list(x) for x in l])\n    533                 else:\n    534                     n = max(l)\n\n/home/martin/sage-master/local/lib/python2.7/site-packages/sage/combinat/permutation.pyc in from_cycles(n, cycles, parent)\n   6652     # Only positive elements\n   6653     if int(flattened_and_sorted[0]) < 1:\n-> 6654         raise ValueError(\"All elements should be strictly positive \"\n   6655                          \"integers, and I just found a negative one.\")\n   6656 \n\nValueError: All elements should be strictly positive integers, and I just found a negative one.\n\n```\n",
    "created_at": "2015-12-18T10:42:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267914",
    "user": "mantepse"
}
```

Replying to [comment:9 dimpase]:
> {{{
> sage: s=SetPartition([[0,1,2],[3,4]])
> sage: s.to_permutation()
> ---------------------------------------------------------------------------
> ValueError                                Traceback (most recent call last)
> ...
> ValueError: All elements should be strictly positive integers, and I just found a negative one.
> }}}
> 
> even 0 is negative in this code...

Please open another ticket for this, since it is a problem with the Permutation code:

```
sage: Permutation(((0,1),))
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-22-0bc8d0916c3c> in <module>()
----> 1 Permutation(((Integer(0),Integer(1)),))

/home/martin/sage-master/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/home/martin/sage-master/src/build/cythonized/sage/misc/classcall_metaclass.c:1239)()
    324         """
    325         if cls.classcall is not None:
--> 326             return cls.classcall(cls, *args, **kwds)
    327         else:
    328             # Fast version of type.__call__(cls, *args, **kwds)

/home/martin/sage-master/local/lib/python2.7/site-packages/sage/combinat/permutation.pyc in __classcall_private__(cls, l, check_input)
    530                 if isinstance(l[0], tuple):
    531                     n = max(max(x) for x in l)
--> 532                     return from_cycles(n, [list(x) for x in l])
    533                 else:
    534                     n = max(l)

/home/martin/sage-master/local/lib/python2.7/site-packages/sage/combinat/permutation.pyc in from_cycles(n, cycles, parent)
   6652     # Only positive elements
   6653     if int(flattened_and_sorted[0]) < 1:
-> 6654         raise ValueError("All elements should be strictly positive "
   6655                          "integers, and I just found a negative one.")
   6656 

ValueError: All elements should be strictly positive integers, and I just found a negative one.

```




---

archive/issue_comments_267915.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-12-18T10:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267915",
    "user": "mantepse"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_267916.json:
```json
{
    "body": "The requirement is not that the ground set be totally ordered. The requirement is that the ground set should be `{1,...,n}`.",
    "created_at": "2015-12-18T10:44:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267916",
    "user": "ncohen"
}
```

The requirement is not that the ground set be totally ordered. The requirement is that the ground set should be `{1,...,n}`.



---

archive/issue_comments_267917.json:
```json
{
    "body": "Replying to [comment:13 ncohen]:\n> The requirement is not that the ground set be totally ordered. The requirement is that the ground set should be `{1,...,n}`.\n\nOh, I missed that, I thought that Permutation would handle bijections, not just Permutations of `{1,...,n}`.  That's really strange, I must say.\n\nHm, now I'm not sure what should be done.  I guess, the only reasonable thing then is to fail when the ground set is not of this form.  Well, that might make sense anyway.",
    "created_at": "2015-12-18T10:57:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267917",
    "user": "mantepse"
}
```

Replying to [comment:13 ncohen]:
> The requirement is not that the ground set be totally ordered. The requirement is that the ground set should be `{1,...,n}`.

Oh, I missed that, I thought that Permutation would handle bijections, not just Permutations of `{1,...,n}`.  That's really strange, I must say.

Hm, now I'm not sure what should be done.  I guess, the only reasonable thing then is to fail when the ground set is not of this form.  Well, that might make sense anyway.



---

archive/issue_comments_267918.json:
```json
{
    "body": "> Oh, I missed that, I thought that Permutation would handle bijections, not just Permutations of `{1,...,n}`.  That's really strange, I must say.\n> \n> Hm, now I'm not sure what should be done.  I guess, the only reasonable thing then is to fail when the ground set is not of this form.  Well, that might make sense anyway.\n\nOn the sage-devel thread I opened (se [comment:6]) I proposed to rename the class (or to create a new one) which checks from the start that its ground set is 1...n. This way, one could write methods like `to_permutation` without having to check it manually, each time.\n\nThere is a usage from a `SetPartition` class with arbitrary ground set (I do have examples in mind) and usage for a specific `IntegerSetPartition` class restricted to those 1...n integers, which is the only case many seem to be interested in.\n\nMixing the two, as it is done in this class, is a bad idea.\n\nNathann",
    "created_at": "2015-12-18T11:02:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267918",
    "user": "ncohen"
}
```

> Oh, I missed that, I thought that Permutation would handle bijections, not just Permutations of `{1,...,n}`.  That's really strange, I must say.
> 
> Hm, now I'm not sure what should be done.  I guess, the only reasonable thing then is to fail when the ground set is not of this form.  Well, that might make sense anyway.

On the sage-devel thread I opened (se [comment:6]) I proposed to rename the class (or to create a new one) which checks from the start that its ground set is 1...n. This way, one could write methods like `to_permutation` without having to check it manually, each time.

There is a usage from a `SetPartition` class with arbitrary ground set (I do have examples in mind) and usage for a specific `IntegerSetPartition` class restricted to those 1...n integers, which is the only case many seem to be interested in.

Mixing the two, as it is done in this class, is a bad idea.

Nathann



---

archive/issue_comments_267919.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-12-18T11:06:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267919",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_267920.json:
```json
{
    "body": "A bit unrelated, but just for fun:\n\n\n```\nsage: X = map(GF(13),range(1,13))\nsage: SetPartition([X])\n{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}}\nsage: SetPartition([X]).to_permutation()\nTypeError: 'sage.rings.finite_rings.integer_mod.IntegerMod_int' object is not iterable\n```\n",
    "created_at": "2015-12-18T11:10:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267920",
    "user": "ncohen"
}
```

A bit unrelated, but just for fun:


```
sage: X = map(GF(13),range(1,13))
sage: SetPartition([X])
{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}}
sage: SetPartition([X]).to_permutation()
TypeError: 'sage.rings.finite_rings.integer_mod.IntegerMod_int' object is not iterable
```




---

archive/issue_comments_267921.json:
```json
{
    "body": "Replying to [comment:15 ncohen]:\n> > Oh, I missed that, I thought that Permutation would handle bijections, not just Permutations of `{1,...,n}`.  That's really strange, I must say.\n> > \n> > Hm, now I'm not sure what should be done.  I guess, the only reasonable thing then is to fail when the ground set is not of this form.  Well, that might make sense anyway.\n> \n> On the sage-devel thread I opened (se [comment:6]) I proposed to rename the class (or to create a new one) which checks from the start that its ground set is 1...n. This way, one could write methods like `to_permutation` without having to check it manually, each time.\n> \n> There is a usage from a `SetPartition` class with arbitrary ground set (I do have examples in mind) and usage for a specific `IntegerSetPartition` class restricted to those 1...n integers, which is the only case many seem to be interested in.\n> \n> Mixing the two, as it is done in this class, is a bad idea.\n\nI am not quite convinced that this is true.  But if you are convinced, is there an easy way to do it?  Can I simply do\n\n```\nclass IntegerSetPartition(SetPartition):\n\n    def to_permutation(self):\n        ....\n\n```\n\n\nwhere should I put the check that the ground set is {1,...,n}?",
    "created_at": "2015-12-18T11:35:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267921",
    "user": "mantepse"
}
```

Replying to [comment:15 ncohen]:
> > Oh, I missed that, I thought that Permutation would handle bijections, not just Permutations of `{1,...,n}`.  That's really strange, I must say.
> > 
> > Hm, now I'm not sure what should be done.  I guess, the only reasonable thing then is to fail when the ground set is not of this form.  Well, that might make sense anyway.
> 
> On the sage-devel thread I opened (se [comment:6]) I proposed to rename the class (or to create a new one) which checks from the start that its ground set is 1...n. This way, one could write methods like `to_permutation` without having to check it manually, each time.
> 
> There is a usage from a `SetPartition` class with arbitrary ground set (I do have examples in mind) and usage for a specific `IntegerSetPartition` class restricted to those 1...n integers, which is the only case many seem to be interested in.
> 
> Mixing the two, as it is done in this class, is a bad idea.

I am not quite convinced that this is true.  But if you are convinced, is there an easy way to do it?  Can I simply do

```
class IntegerSetPartition(SetPartition):

    def to_permutation(self):
        ....

```


where should I put the check that the ground set is {1,...,n}?



---

archive/issue_comments_267922.json:
```json
{
    "body": "Hello,\n\n> I am not quite convinced that this is true.  But if you are convinced, is there an easy way to do it?  Can I simply do\n> {{{\n> class IntegerSetPartition(SetPartition):\n> \n>     def to_permutation(self):\n>         ....\n> \n> }}}\n\nTo me such a design would work nicely. And the check that is needed by all those functions can be performed there:\n\n\n```\nclass IntegerSetPartition(SetPartition):\n    def __init__(self, **kwargs):\n        SetPartition.__init__(self,**kwargs)\n        assert set(self.base_set()) == set(range(self.base_set_cardinality()))\n```\n\n\nOr something nicer, which would yield a clearer error message when the input is wrong.\n\nI believe that this is the way to go. Really, look at the functions of `SetPartition`: how many are defined for integer partitions *only*? I don't know much about this kind of combinatorics, but `is_noncrossing` seems to be of that kind. Hell, I'd even be surprised if less than half of the methods of `SetPartition` should not be there, or is plain broken (.N(), .base_extend(), .base_ring(), .count(), db(), .n(), .numerical_approx(), .rename(), .reset_name(), .subs(), .substitute(), .version()).\n\nNathann",
    "created_at": "2015-12-18T12:22:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267922",
    "user": "ncohen"
}
```

Hello,

> I am not quite convinced that this is true.  But if you are convinced, is there an easy way to do it?  Can I simply do
> {{{
> class IntegerSetPartition(SetPartition):
> 
>     def to_permutation(self):
>         ....
> 
> }}}

To me such a design would work nicely. And the check that is needed by all those functions can be performed there:


```
class IntegerSetPartition(SetPartition):
    def __init__(self, **kwargs):
        SetPartition.__init__(self,**kwargs)
        assert set(self.base_set()) == set(range(self.base_set_cardinality()))
```


Or something nicer, which would yield a clearer error message when the input is wrong.

I believe that this is the way to go. Really, look at the functions of `SetPartition`: how many are defined for integer partitions *only*? I don't know much about this kind of combinatorics, but `is_noncrossing` seems to be of that kind. Hell, I'd even be surprised if less than half of the methods of `SetPartition` should not be there, or is plain broken (.N(), .base_extend(), .base_ring(), .count(), db(), .n(), .numerical_approx(), .rename(), .reset_name(), .subs(), .substitute(), .version()).

Nathann



---

archive/issue_comments_267923.json:
```json
{
    "body": "I just tried exactly what you suggested, but it does not work:\n\n\n```\nsage: IntegerSetPartition([[1,2],[3]])\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-1-406bd8f08b79> in <module>()\n----> 1 IntegerSetPartition([[Integer(1),Integer(2)],[Integer(3)]])\n\n/home/martin/sage-master/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/home/martin/sage-master/src/build/cythonized/sage/misc/classcall_metaclass.c:1264)()\n    327         else:\n    328             # Fast version of type.__call__(cls, *args, **kwds)\n--> 329             return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n    330 \n    331     def __get__(cls, instance, owner):\n\nTypeError: __init__() takes exactly 1 argument (2 given)\n```\n\n\nI'm guessing this is because `SetPartition` uses `__metaclass__ = InheritComparisonClasscallMetaclass`, whatever that is.\n\nAlso, I have to remark that none of `.N(), .base_extend(), .base_ring(), .count(), db(), .n(), .numerical_approx(), .rename(), .reset_name(), .subs(), .substitute(), .version())` are defined in `SetPartition`.  Eg., `.N()` is from `Element`.",
    "created_at": "2016-01-07T10:27:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267923",
    "user": "mantepse"
}
```

I just tried exactly what you suggested, but it does not work:


```
sage: IntegerSetPartition([[1,2],[3]])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-1-406bd8f08b79> in <module>()
----> 1 IntegerSetPartition([[Integer(1),Integer(2)],[Integer(3)]])

/home/martin/sage-master/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/home/martin/sage-master/src/build/cythonized/sage/misc/classcall_metaclass.c:1264)()
    327         else:
    328             # Fast version of type.__call__(cls, *args, **kwds)
--> 329             return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    330 
    331     def __get__(cls, instance, owner):

TypeError: __init__() takes exactly 1 argument (2 given)
```


I'm guessing this is because `SetPartition` uses `__metaclass__ = InheritComparisonClasscallMetaclass`, whatever that is.

Also, I have to remark that none of `.N(), .base_extend(), .base_ring(), .count(), db(), .n(), .numerical_approx(), .rename(), .reset_name(), .subs(), .substitute(), .version())` are defined in `SetPartition`.  Eg., `.N()` is from `Element`.



---

archive/issue_comments_267924.json:
```json
{
    "body": "I half-got it, but it looks more complicated.  Apparently, it is not possible to use the same parent.  Currently, there is a parent `SetPartitions` with element class `SetPartition`.  Of course, it would be desirable to make an instance of `IntegerSetPartition` also have parent `SetPartitions`, but I do not know how to do this yet.",
    "created_at": "2016-01-07T11:53:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267924",
    "user": "mantepse"
}
```

I half-got it, but it looks more complicated.  Apparently, it is not possible to use the same parent.  Currently, there is a parent `SetPartitions` with element class `SetPartition`.  Of course, it would be desirable to make an instance of `IntegerSetPartition` also have parent `SetPartitions`, but I do not know how to do this yet.



---

archive/issue_comments_267925.json:
```json
{
    "body": "OK, I think I have it.",
    "created_at": "2016-01-07T12:00:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267925",
    "user": "mantepse"
}
```

OK, I think I have it.



---

archive/issue_comments_267926.json:
```json
{
    "body": "I now put\n\n\n```\nclass IntegerSetPartition(SetPartition):\n\n    def __init__(self, parts):\n        SetPartition.__init__(self, SetPartitions(), parts)\n        assert set(self.base_set()) == set(range(1, 1+self.base_set_cardinality()))\n\n    def to_permutation(self):\n    ...\n```\n\n\nbut that's not really satisfying.  What we really want is that `SetPartition([[1,2],[3]])` creates an `IntegerSetPartition`.  I hate python.",
    "created_at": "2016-01-07T12:09:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267926",
    "user": "mantepse"
}
```

I now put


```
class IntegerSetPartition(SetPartition):

    def __init__(self, parts):
        SetPartition.__init__(self, SetPartitions(), parts)
        assert set(self.base_set()) == set(range(1, 1+self.base_set_cardinality()))

    def to_permutation(self):
    ...
```


but that's not really satisfying.  What we really want is that `SetPartition([[1,2],[3]])` creates an `IntegerSetPartition`.  I hate python.



---

archive/issue_comments_267927.json:
```json
{
    "body": "HMmmmmmmmm `O_o`\n\nThat seems hard to achieve indeed. The only way I've seen those things done in combinat/ code is to make SetPartition a *function*, which then calls `SetPartition_class` or `IntegerSetPartition_class`. Can't say I am in love with that design, though.\n\nNathann",
    "created_at": "2016-01-07T12:12:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267927",
    "user": "ncohen"
}
```

HMmmmmmmmm `O_o`

That seems hard to achieve indeed. The only way I've seen those things done in combinat/ code is to make SetPartition a *function*, which then calls `SetPartition_class` or `IntegerSetPartition_class`. Can't say I am in love with that design, though.

Nathann



---

archive/issue_comments_267928.json:
```json
{
    "body": "OK, then I would suggest to just have the easy fix.  At least it's less surprising than what we currently have.\n\nTurning `SetPartition` into a function would really be a completely new design.  Out of curiosity: why would you dislike this solution, too?",
    "created_at": "2016-01-07T12:36:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267928",
    "user": "mantepse"
}
```

OK, then I would suggest to just have the easy fix.  At least it's less surprising than what we currently have.

Turning `SetPartition` into a function would really be a completely new design.  Out of curiosity: why would you dislike this solution, too?



---

archive/issue_comments_267929.json:
```json
{
    "body": "> Turning `SetPartition` into a function would really be a completely new design.  Out of curiosity: why would you dislike this solution, too?\n\nBecause I love simple things. From time to time I have to touch combinat code, and from time to time I have to use 'isinstance'. And, well, `isinstance(my_object,IncidenceStructure)` works but `isinstance(my_object,Poset)` does not, because the first is a class while the other is not.\n\nUsually in Sage we have a way to tell whether something is a function or a class: MyClass is a class, and `my_function` is a function.\n\nBut well, what is true in Sage and what is true in the combinat/ folder are different things.\n\nNathann",
    "created_at": "2016-01-07T12:57:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267929",
    "user": "ncohen"
}
```

> Turning `SetPartition` into a function would really be a completely new design.  Out of curiosity: why would you dislike this solution, too?

Because I love simple things. From time to time I have to touch combinat code, and from time to time I have to use 'isinstance'. And, well, `isinstance(my_object,IncidenceStructure)` works but `isinstance(my_object,Poset)` does not, because the first is a class while the other is not.

Usually in Sage we have a way to tell whether something is a function or a class: MyClass is a class, and `my_function` is a function.

But well, what is true in Sage and what is true in the combinat/ folder are different things.

Nathann



---

archive/issue_comments_267930.json:
```json
{
    "body": "Well, that's why I hate python.  A better solution (in my opinion) would be to have conditionally exported methods.  Or, lacking this, the possibility to have a function and a class of the same name, eg., `SetPartition` would be a function that return an instance of a class of the *same* name, or an instance of `IntegerSetPartition`.\n\nIn fact, that's sort of doable, but it seems to involve a fair bit of work: I can have a class that is simultaneously a function, using `__classcall_private__`.  And it seems to be working hard against python.\n\nCan you give this ticket positive review now?",
    "created_at": "2016-01-07T13:12:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267930",
    "user": "mantepse"
}
```

Well, that's why I hate python.  A better solution (in my opinion) would be to have conditionally exported methods.  Or, lacking this, the possibility to have a function and a class of the same name, eg., `SetPartition` would be a function that return an instance of a class of the *same* name, or an instance of `IntegerSetPartition`.

In fact, that's sort of doable, but it seems to involve a fair bit of work: I can have a class that is simultaneously a function, using `__classcall_private__`.  And it seems to be working hard against python.

Can you give this ticket positive review now?



---

archive/issue_comments_267931.json:
```json
{
    "body": "> Well, that's why I hate python.\n\nYou hate Python because the combinat folks break name conventions? `O_o`\n\n> A better solution (in my opinion) would be to have conditionally exported methods.\n\nWhat do you mean by that? Can you give an example?\n\n> Or, lacking this, the possibility to have a function and a class of the same name, eg., `SetPartition` would be a function that return an instance of a class of the *same* name, or an instance of `IntegerSetPartition`.\n\nThat's what I call making things complicated. Can't people live with classes that return instances of themselves?\n\n> Can you give this ticket positive review now?\n\nI added a small commit at public/19737. If you agree with it, please add it to this ticket and set the status to `positive_review`.\n\nNathann",
    "created_at": "2016-01-07T14:23:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267931",
    "user": "ncohen"
}
```

> Well, that's why I hate python.

You hate Python because the combinat folks break name conventions? `O_o`

> A better solution (in my opinion) would be to have conditionally exported methods.

What do you mean by that? Can you give an example?

> Or, lacking this, the possibility to have a function and a class of the same name, eg., `SetPartition` would be a function that return an instance of a class of the *same* name, or an instance of `IntegerSetPartition`.

That's what I call making things complicated. Can't people live with classes that return instances of themselves?

> Can you give this ticket positive review now?

I added a small commit at public/19737. If you agree with it, please add it to this ticket and set the status to `positive_review`.

Nathann



---

archive/issue_comments_267932.json:
```json
{
    "body": "No, I hate python because, in my opinion, it lacks a lot of functionality and it is very complicated at the same time.\n\nFor example, in Aldor I can simply say: if the parameters are the integers from 1 to n, then export the method \"to_permutation\" (i.e., make it visible to the user).  Otherwise, do not export this method.\n\n> Or, lacking this, the possibility to have a function and a class of the same name, eg., `SetPartition` would be a function that return an instance of a class of the *same* name, or an instance of `IntegerSetPartition`.\n\nThat's what I call making things complicated. Can't people live with classes that return instances of themselves?\n\nOK, but you said you don't like `SetPartition` having methods that do not apply to all its instances.  Or would you prefer to type `IntegerSetPartition` all the time, and make `SetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` and `IntegerSetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` different objects?\n\n> I added a small commit at public/19737. If you agree with it, please add it to this ticket and set the status to positive_review.\n\nI do not have proper access to git from this computer.  Your change is of course OK, so if you don't want to wait until tomorrow, please merge and set it to positive review.\n\nThanks!",
    "created_at": "2016-01-07T16:27:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267932",
    "user": "mantepse"
}
```

No, I hate python because, in my opinion, it lacks a lot of functionality and it is very complicated at the same time.

For example, in Aldor I can simply say: if the parameters are the integers from 1 to n, then export the method "to_permutation" (i.e., make it visible to the user).  Otherwise, do not export this method.

> Or, lacking this, the possibility to have a function and a class of the same name, eg., `SetPartition` would be a function that return an instance of a class of the *same* name, or an instance of `IntegerSetPartition`.

That's what I call making things complicated. Can't people live with classes that return instances of themselves?

OK, but you said you don't like `SetPartition` having methods that do not apply to all its instances.  Or would you prefer to type `IntegerSetPartition` all the time, and make `SetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` and `IntegerSetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` different objects?

> I added a small commit at public/19737. If you agree with it, please add it to this ticket and set the status to positive_review.

I do not have proper access to git from this computer.  Your change is of course OK, so if you don't want to wait until tomorrow, please merge and set it to positive review.

Thanks!



---

archive/issue_comments_267933.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-01-07T17:28:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267933",
    "user": "ncohen"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_267934.json:
```json
{
    "body": "Hellooooo,\n\n> For example, in Aldor I can simply say: if the parameters are the integers from 1 to n, then export the method \"to_permutation\" (i.e., make it visible to the user). Otherwise, do not export this method.\n\nSounds hard to write documentation for something like that. To me it sounds like the other approach \"Have every method available, but check that the data is what you expect before running the computation and raise a *clear* error message if it is not\".\n\nYou would have all methods available, some of which would raise an exception. Not ideal, but at least you don't wonder where the method is. Well, this being said I can totally hear that when one is used to this behaviour, one expects this kind of situation too.\n\n> OK, but you said you don't like `SetPartition` having methods that do not apply to all its instances.  Or would you prefer to type `IntegerSetPartition` all the time, and make `SetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` and `IntegerSetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` different objects?\n\nThat's indeed how I would have implemented it. Two classes, one which inherits from the other.\n\n> I do not have proper access to git from this computer.  Your change is of course OK, so if you don't want to wait until tomorrow, please merge and set it to positive review.\n\nDone!\n\nThanks,\n\nNathann\n----\nNew commits:",
    "created_at": "2016-01-07T17:28:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267934",
    "user": "ncohen"
}
```

Hellooooo,

> For example, in Aldor I can simply say: if the parameters are the integers from 1 to n, then export the method "to_permutation" (i.e., make it visible to the user). Otherwise, do not export this method.

Sounds hard to write documentation for something like that. To me it sounds like the other approach "Have every method available, but check that the data is what you expect before running the computation and raise a *clear* error message if it is not".

You would have all methods available, some of which would raise an exception. Not ideal, but at least you don't wonder where the method is. Well, this being said I can totally hear that when one is used to this behaviour, one expects this kind of situation too.

> OK, but you said you don't like `SetPartition` having methods that do not apply to all its instances.  Or would you prefer to type `IntegerSetPartition` all the time, and make `SetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` and `IntegerSetPartition([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` different objects?

That's indeed how I would have implemented it. Two classes, one which inherits from the other.

> I do not have proper access to git from this computer.  Your change is of course OK, so if you don't want to wait until tomorrow, please merge and set it to positive review.

Done!

Thanks,

Nathann
----
New commits:



---

archive/issue_comments_267935.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-01-07T22:41:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19500#issuecomment-267935",
    "user": "vbraun"
}
```

Resolution: fixed
