# Issue 20031: memory leak in Polynomial.__call__

Issue created by migration from https://trac.sagemath.org/ticket/20268

Original creator: vdelecroix

Original creation time: 2016-03-23 20:25:12

CC:  nbruin jdemeyer vbraun

See the following reports

  - [thread on cython-users](https://groups.google.com/forum/#!topic/cython-users/g10b0911qq0)
  - [thread on sage-devel](https://groups.google.com/forum/#!topic/sage-devel/W0c5zCbgt0Q)


---

Comment by vdelecroix created at 2016-03-24 12:36:22

New commits:


---

Comment by vdelecroix created at 2016-03-24 12:36:22

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2016-03-24 12:40:07

I propose to deal with this in #20192 instead.

In any case, if you want the fix to be applied, you need to increase the Cython version number.


---

Comment by jdemeyer created at 2016-03-24 12:40:13

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-03-24 12:50:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-03-24 12:59:02

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-03-24 12:59:02

Since the stable cython release is about to be delivered, I guess it would be better to use #20192...


---

Comment by jdemeyer created at 2016-03-27 07:37:41

Robert Bradshaw says that Cython 0.24 will be delivered "Likely in the next week"


---

Comment by vdelecroix created at 2016-03-28 02:04:29

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2016-03-28 02:04:29

I would like to add a doctest for that. Do you think that the following is strong enough

```
sage: p = polygen(ZZ)
sage: import resource 
sage: mem0 = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss 
sage: for _ in range(10000):
....:     t = Polynomial.__call__(p, 1)
sage: assert resource.getrusage(resource.RUSAGE_SELF).ru_maxrss < mem0 + 1000
```

If not, do you have a better idea?


---

Comment by nbruin created at 2016-03-31 00:21:32

Perhaps staying closer to python's own memory management routines and pick an example that produces stuff that is tracked by gc:


```
sage: import gc
sage: p=polygen(ZZ)
sage: gc.collect()
0
sage: N=len(gc.get_objects())
sage: for _ in range(10000): t = Polynomial.__call__(p,p)
sage: assert len(gc.get_objects())-N < 1000
```



---

Comment by vdelecroix created at 2016-03-31 02:34:39

Replying to [comment:8 nbruin]:
> Perhaps staying closer to python's own memory management routines and pick an example that produces stuff that is tracked by gc:
> 
> {{{
> sage: import gc
> sage: p=polygen(ZZ)
> sage: gc.collect()
> 0
> sage: N=len(gc.get_objects())
> sage: for _ in range(10000): t = Polynomial.__call__(p,p)
> sage: assert len(gc.get_objects())-N < 1000
> }}}

It will not work. The leak was not seen at Python level.


---

Comment by nbruin created at 2016-03-31 04:15:01

Replying to [comment:9 vdelecroix]:
> It will not work. The leak was not seen at Python level.

Did you try the example? The leak causes dangling objects on the python heap. However, `gc.get_objects()` will only find tracked objects, and tuples with too simple ingredients aren't tracked. However, when you put sufficiently complicated objects in there (such as `p`) then it is tracked. So the test does work. So should the rusage of course, modulo unpredictable memory allocation strategies, or unusual circumstances that cause the rss to remain small in the presence of large memory usage.


---

Comment by jdemeyer created at 2016-05-05 07:56:29

Changing status from needs_work to positive_review.


---

Comment by jdemeyer created at 2016-05-05 07:56:29

I guess this is superseded by the Cython upgrade.


---

Comment by vbraun created at 2016-05-11 20:09:41

Resolution: fixed
