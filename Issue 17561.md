# Issue 17561: Create a class for Coxeter matrices and types

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-02-18 03:16:50

Assignee: sage-combinat

CC:  sage-combinat darij chapoton jipilab vripoll jmichel nthiery kdilks

Keywords: Coxeter, groups, matrices, types

This is a partial step towards #16126, but carries the necessary information to speed up #16630 when the input is given as a finite Cartan/Coxeter type.


---

Comment by tscrim created at 2015-02-27 02:51:33

Changing status from new to needs_review.


---

Comment by tscrim created at 2015-02-27 02:51:33

Here's a working version that implements a class `CoxeterMatrix` and a generic `CoxeterType` coming from a `CartanType`. I also removed some deprecated code.
----
New commits:


---

Comment by darij created at 2015-03-02 05:15:18

Some armchair reviewing (I am not sure if I am up to the actual job): You replaced the `coxeter_matrix` method on `CartanType_abstract` by a call to the `CoxeterMatrix` constructor, which is heavily ducktyped; you also removed the caching. Have you checked for speed regressions? I am also unhappy with the ducktyping since it is hard to debug. Does it makes sense to build a custom `from_cartan_type` constructor for `CoxeterMatrix` that bypasses most of the duckery?


---

Comment by tscrim created at 2015-03-02 06:57:20

Actually, I will re-enable that caching; there was a time when I was considering the `CoxeterMatrix` to be a `UniqueRepresentation`, but it was easier to make it a usual class. However, for (better or) worse, pythonic code is ducktyped code since it is a weakly-typed language. Yet I tried to make case-by-case as much as possible (following what I did for `CartanMatrix`). There is some indirection done in `CoxeterMatrix` by converting the Cartan type to a Coxeter type, but I felt this was the best way to do things (at least with the current implementation). Yet this part isn't ducktyped. So what my long-winded reply is saying is I'm open to suggestions, but this is the local optimal code I'm at.


---

Comment by git created at 2015-03-02 07:20:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-03-02 07:39:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2015-03-09 18:52:06

I fear I cannot be of much help with this ticket, as I don't even know the difference between a Coxeter and a Cartan type... But please simplify that `CoxeterMatrix.__init__`. It is so complicated it is not pythonic in any good sense of this word. Python's the weak type system should not keep us from writing constructors (e.g., `from_cartan_type`) tailored to specific input data. I have no idea why catch-all constructors have become a standard in Sage, but this kind of programming gave us #17124 and probably some more ugliness I don't remember.


---

Comment by jipilab created at 2015-03-17 22:47:10

In view of the tickets #15703, #16126, tt would be very good to include the possibility to have "generalized" Coxeter matrices.

The "generalized" means that for the infinite labels, we can put a real number <= -1 in the matrix.

Of course, this may be not so natural to have Coxeter matrices with such entries, but this will make life much much easier for the other tickets: being able to start with a matrix which encodes the "geometry" behind the matrix.

Ticket #16126 should be kind of parallel to this one.

If you think it is a good idea, I would try take the patch from here and make it possible to into such values.


---

Comment by tscrim created at 2015-03-19 19:26:25

You can work around #17990 by explicitly specifying the base ring, but they only ring which has `oo` and the integers is the symbolic ring AFAIK. I think the best/long-term fix for allowing matrices with say `ZZ[oo]` is to construct a general parent for the _ordered set_ `R[oo]` where `R` is any other ring (well ordered set where all things become less than infinity). Actually...you could probably use `TropicalSemiring(ZZ)` which does this (plus a bit more structure):

```
sage: T.zero()
+infinity
sage: T(2) < T.zero()
True
sage: T(2) > T.zero()
False
```

But the matrix space constructor requires a proper ring...which is where the real trouble probably is... I'm done rambling now.


---

Comment by git created at 2015-03-20 00:50:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-03-20 00:59:24

This is a dirty version so that you may have a look.

It includes now a classification of the affine types. I do not know exactly if this recognition algorithm was coded before. Anyways, I wrote it, it was a good exercise.

The code should be a cleaned and fully tested. Therefore I change the status to "needs_work".

If you have any suggestions, comments, I'm totally open!


---

Comment by jipilab created at 2015-03-20 00:59:24

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-03-20 18:14:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-03-21 01:50:24

Changing keywords from "Coxeter, groups, matrices, types" to "Coxeter, groups, matrices, types, days64".


---

Comment by git created at 2015-03-21 04:46:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-03-21 15:36:51

Since we are now wrapping a matrix, I think instead we should just make this either a list of lists or a dict of `(i,j): val` (where undefined entries are 2). That way we don't have to worry about the base ring or anything like that and we can (easily in the former case) pass that to the matrix constructor for those that want to do matrix operations. I'm actually leaning towards doing the dict method since most entires of a Coxeter matrix that people will use are 2 (at least, that's my current imagination). Thoughts?


---

Comment by jipilab created at 2015-03-21 16:04:32

Probably a dictionary would be good. Though, we would have to write an appropriate string representation, this is not a big deal.

Adding a matrix method to Coxeter matrix may sound a bit absurd, but since the CoxeterMatrix are more or less only to stock data, I believe it is ok. We may also make it cached...


---

Comment by tscrim created at 2015-03-21 17:11:33

I doubt it's worth it to cache it...

Anyways, the string representation would probably be something like this (untested):

```
def _repr_(self):
    w = max(len(str(v)) for row in self for v in row)
    fstr = '{:>' + str(w) + '}' # should result in something like '{:>30}'
    return '\n'.join('[' + ' '.join(fstr.format(v) for v in row) + ']' for row in self)
```



---

Comment by git created at 2015-03-30 12:54:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-03-30 12:56:16

Changing keywords from "Coxeter, groups, matrices, types, days64" to "Coxeter groups, matrices, types, days64".


---

Comment by jipilab created at 2015-04-13 13:07:07

Hi,

While having a look at the diff of the current patch, I saw that in CoxeterMatrixGroup the method coxeter_graph is renamed by coxeter_diagram.

I'm having thoughts about this for a while.

I would be tempted to have a clear distinction between dynkin diagram and coxeter graphs. Especially considering #16126 coming.

I guess eventually, there could be a common class on top of dynkin diagrams and coxeter graphs from which they inherit. But right now, it makes more sense to me to try to keep the convention coxeter graph vs dynkin diagram.

What do you think?


---

Comment by tscrim created at 2015-04-13 14:12:40

There's some danger with calling it a Coxeter graph, as this was the first entry I got when Googling: http://en.wikipedia.org/wiki/Coxeter_graph. I don't believe this is what we want, and I believe the more common terminology is Coxeter diagram. This was my mistake in calling that method Coxeter graph, which I did without thinking/looking too much because it returns a `Graph` instance.

+1 for refactoring out common code between Coxeter and Dynkin diagrams, but IMO it doesn't need to be done here as we have #16126.


---

Comment by jipilab created at 2015-04-13 14:38:12

Yes... It is a bummer that Coxeter does have a graph with its actual name tagged to it!

In the end, it is just a name, I guess we should try to be consistent in the naming convention since we are at it, and I'd like to know how to proceed...

As far as I know, Humphreys is careful not to give the graphs a name. On p.1 of Bjoerner&Brenti, they call it a "Coxeter graph (or Coxeter diagram)".

I would vote for Coxeter graph and Dynkin diagram since it emphasizes the difference between the two structures. About the confusion with the actual Coxeter graph, I believe it is not a so dreadful danger of confusion.

I think that the Coxeter graph is not so commonly used as to need it directly from the sage prompt, right?

Agreed with refactor common code later.


---

Comment by git created at 2015-04-30 14:03:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-04-30 14:09:42

Hi,

So I pushed some commits I did today.

There is still a lot to do, but it's progressing.

I tested the files and there were many tests that failed. I noticed that many of them fail because we removed the inheritance from matrices that was providing with equality tests.

I continue the coding... Don't hesitated if you have comments or suggestions!


---

Comment by jipilab created at 2015-04-30 15:21:57

Hi,

Where should the function samples be placed?

If I put it in the abstract class CoxeterType, it complains that it should be called on an instance.

JP


---

Comment by nthiery created at 2015-04-30 16:33:33

Replying to [comment:27 jipilab]:
> Where should the function samples be placed?
> 
> If I put it in the abstract class CoxeterType, it complains that it should be called on an instance.

It should be a `staticmethod` or `classmethod`..


---

Comment by git created at 2015-05-07 14:09:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-05-07 14:17:16

Hi,

Now all test passes on the file coxeter_matrix, not on coxeter_type (3 failure caused by the old UCF implementation, I did not bother trying to correct them because of the new implementation in #18152). When it is going to be merged in a beta, I'll verify again.

The sample is supposed to contain all finite and affine coxeter types plus some more infinite types which are not affine.

I believe now the next step would be to go through the methods to double check that tests verify well the code.

About the renaming of the CoxeterType file to type_coxeter, I believe it is better to keep it as it is now since it is similar to cartan_type.py


---

Comment by git created at 2015-06-04 15:39:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-06-04 15:45:42

All tests pass on sage-6.8.beta2.

I would say that this version is ready for review.


---

Comment by jipilab created at 2015-06-04 15:45:42

Changing status from needs_work to needs_review.


---

Comment by jipilab created at 2015-06-04 15:55:04

Test fails in /sage/src/sage/groups/matrix_gps/coxeter_group.py


---

Comment by jipilab created at 2015-06-04 15:55:04

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-06-04 17:06:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-06-04 17:08:34

There were some failing tests in the Coxeter groups as Matrix groups. They are solved now.


---

Comment by jipilab created at 2015-06-04 17:08:34

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2015-06-05 07:42:40

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2015-06-05 07:42:40

doc does not build

maybe because you need to use `r"""` when using latex command such as `\infty` or `\ZZ`


---

Comment by git created at 2015-06-07 08:50:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-06-07 08:53:45

Changing status from needs_work to needs_review.


---

Comment by jipilab created at 2015-06-07 08:53:45

Should be fine now...


---

Comment by jipilab created at 2015-06-07 10:46:04

There seems to be a test failing in the Coxeter group Category. I'll take care of that.


---

Comment by git created at 2015-06-07 11:47:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-07 13:08:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-19 22:28:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-19 23:04:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-06-19 23:06:51

I've made my round of changes. If your happy with my changes, then we can set a positive review (since we've done a cross-review, unless of course someone has any objections).


---

Comment by jipilab created at 2015-06-25 13:35:46

Hi Travis,

Thanks for the recent changes! They look good to me.

The patchbot should check if everything is ok and then we could set it to positive review.


---

Comment by jipilab created at 2015-06-28 09:02:29

Hi,

I have difficulty reading what the failure in "startup-module" really is.

What is wrong?


---

Comment by tscrim created at 2015-06-28 14:47:52

So it is saying that we are importing 5 new modules at startup. I think we should lazily import the `coxeter_matrix` and `coxeter_type`. The other option is to change this to a lazy import: `from sage.graphs.generators.basic import CycleGraph`.

Also the test failures in `src/sage/interfaces/psage.py` are due to an old version of #18743, but we have to figure why the `CoxeterGroup` element doesn't work properly. It might be an issue with comparisons, but it might be with the pickling...


---

Comment by tscrim created at 2015-07-05 07:28:51

So the problem is that the type recognition does not support relabelings:

```
sage: M = CoxeterMatrix([[1,3,2],[3,1,6],[2,6,1]])
sage: M
[1 3 2]
[3 1 6]
[2 6 1]
sage: M.coxeter_type()
Coxeter type of ['G', 2, 1]
sage: loads(dumps(M))
[1 2 3]
[2 1 6]
[3 6 1]
```

The type should be relabeled to (1, 2, 3) and does not necessarily correspond to (0, 1, 2).


---

Comment by tscrim created at 2015-07-05 07:28:51

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-07-13 04:13:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-07-13 04:17:33

As per my discussion with Jean-Philippe at FPSAC, I've implemented type-checking using graph isomorphism testing, which fixes the relabeling issue (it feels more efficient). Just needs a quick check (and the remaining dependency should be a trivial review, but it needs a reviewer).


---

Comment by tscrim created at 2015-07-13 04:17:33

Changing status from needs_work to needs_review.


---

Comment by jipilab created at 2015-07-14 15:21:20

It seems that there was an error when building sage.

I looked at the crash report and there is an ImportError:

"ImportError: No module named inherit_comparison"

Which seems to be the source of the problem.

Any idea?


---

Comment by tscrim created at 2015-07-15 01:11:55

I don't get this error, and I have no idea what's going on with your build (the error occurs before startup, right?). You only get it with this patch? What is the output of `git diff --name-status develop`?


---

Comment by jipilab created at 2015-07-15 08:12:39

I pulled the latest version of develop and it compiled fine. (make distclean && make). Then, I checked out the branch and pulled the latest changes and then built.

The output of git diff --name-status develop gives my a relatively long list of (python, rst, txt, etc.) files. Are you looking for something in particular? It may be difficult to track.

I'll just make distclean and compile again.

I'll report about the latest changes in the ticket then.


---

Comment by tscrim created at 2015-07-15 12:04:12

`git diff --name-status develop` shows the files which are different compared to `develop`, so assuming you have merged in the latest `develop` to both branches, it should give a comprehensive list of changes.

However I'm not quite sure what you're saying. Did you already merge in the latest `develop` and tested this branch on top of that and it didn't work?


---

Comment by jipilab created at 2015-07-15 13:26:36

I just went directly on the branch (without merging the very latest version of develop) and compiled. Now I get an error in building the doc, because some folder does not exist.

I will just do a merge with the latest develop and compile again. This seems to be a reasonable option now.


---

Comment by git created at 2015-07-20 12:11:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2015-07-20 12:20:25

All test passed on sage6.8.rc0

If the bot is happy I would set the patch to positive review. I am satisfied with the changes in the type recognition algorithm.


---

Comment by tscrim created at 2015-07-20 12:58:29

Thank you for your work on this. The bot seems to be down for the time being, but it did pass on the previous version. Do you think you could also give a quick review of the dependency too?

Let me know when the followups are ready for review.


---

Comment by kdilks created at 2015-10-12 00:51:08

Patchbot says this code now causes some sort of infinite recursion on crystals.


---

Comment by jipilab created at 2015-10-12 14:44:48

Dear Kevin,

Could you give some minimal not-working example of the problem?


---

Comment by git created at 2015-10-12 14:55:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-12 15:00:53

Kevin and I tried it out and couldn't reproduce the patchbot results.


---

Comment by jipilab created at 2015-10-12 15:02:19

All tests seem to pass on sage-6.9 on my computer right now...

There were two tests failing on 6.9 that I fixed in the last commit.


---

Comment by kdilks created at 2015-10-12 16:01:45

Tests on the files you changed pass, but it's causing some sort of infinite recursion on crystals. It's also causing some doctests to fail in `cluster_seed()`.


```
sage -t --long src/sage/combinat/rigged_configurations/kr_tableaux.py  # 5 doctests failed
sage -t --long src/sage/combinat/rigged_configurations/rigged_configurations.py  # 7 doctests failed
sage -t --long src/sage/combinat/crystals/littelmann_path.py  # 3 doctests failed
sage -t --long src/sage/combinat/crystals/kirillov_reshetikhin.py  # 34 doctests failed
sage -t --long src/sage/combinat/cluster_algebra_quiver/cluster_seed.py  # 3 doctests failed
sage -t --long src/sage/combinat/rigged_configurations/rigged_configuration_element.py  # 1 doctest failed
sage -t --long src/sage/combinat/crystals/kyoto_path_model.py  # 3 doctests failed
sage -t --long src/sage/combinat/crystals/tensor_product.py  # 6 doctests failed
sage -t --long src/doc/en/thematic_tutorials/lie/affine_finite_crystals.rst  # 9 doctests failed
sage -t --long src/sage/combinat/root_system/cartan_type.py  # 1 doctest failed
sage -t --long src/sage/combinat/root_system/dynkin_diagram.py  # 1 doctest failed
sage -t --long src/sage/combinat/crystals/subcrystal.py  # 2 doctests failed
sage -t --long src/sage/combinat/crystals/virtual_crystal.py  # 4 doctests failed
```


You can ignore two failing doctests in root system, since I believe you just fixed those.


---

Comment by jipilab created at 2015-10-12 16:22:32

Excellent! On it...!


---

Comment by kdilks created at 2015-10-12 16:27:00

Travis is working on the issue with crystals now.

The tests that are failing in `cluster_seed.py` are under `universal_extension()`, which mentions that it gets the almost positive co-roots in a non-elegant way and non-standard order, so it may have to be rewritten.


---

Comment by git created at 2015-10-12 16:34:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-12 16:38:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-12 16:43:35

Okay, so the issue which caused the crystals to infinitely recurse is that the type recognition via `subtype()` did not pass along the appropriate labels (I'm not 100% sure what was calling `subtype()`...). In particular, classical types got relabeled by `[0, 1, ...]`, and KR crystals were sensitive to the labellings. I fixed this (which was indicated by the fact that we now had to add the relabel to the `subtype` test) and in a separate commit I made the KR crystals less sensitive to relabellings (but fixing them altogether is an entirely different issue and would deserve a separate ticket). What had changed from our previous version was that our type recognition system did not support relabelling, but now using Dynkin diagrams it does.

Unfortunately this did not fix the issue for cluster seeds.


---

Comment by git created at 2015-10-12 16:45:56

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2015-10-12 20:29:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-12 20:33:55

The fix was that the cluster seed code was assuming the indexing set of a Cartan matrix constructed from a matrix that was of finite type had the standard finite type indexing set of `[1, 2, ..., n]`. I fixed this by explicitly specifying this to be the index set of the Cartan matrix.

This brings up a point that might need a discussion: Should the index set of a matrix representing a finite type Cartan matrix be by default 1-based or 0-based? The argument for being 1-based is above, a natural assumption on index sets of finite type. Why we should have 0-based is consistency with the rest for default labellings and it agrees with the indexing set of the given matrix (and everything in python is 0-based). Thoughts?


---

Comment by git created at 2015-10-12 22:46:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-12 22:47:33

This should at least get rid of the startup imports of the graph generators stuff.


---

Comment by jipilab created at 2015-10-13 08:00:51

Replying to [comment:74 tscrim]:
> The fix was that the cluster seed code was assuming the indexing set of a Cartan matrix constructed from a matrix that was of finite type had the standard finite type indexing set of `[1, 2, ..., n]`. I fixed this by explicitly specifying this to be the index set of the Cartan matrix.

Is my last edition to make test pass consistent with this change?

> 
> This brings up a point that might need a discussion: Should the index set of a matrix representing a finite type Cartan matrix be by default 1-based or 0-based? The argument for being 1-based is above, a natural assumption on index sets of finite type. Why we should have 0-based is consistency with the rest for default labellings and it agrees with the indexing set of the given matrix (and everything in python is 0-based). Thoughts?

I would say 1-based for finite type since they probably have a labeling hardcoded when dealing with them through Cartan matrices and Coxeter Types.

I would say 0-based whenever there is no labels specified and it comes through a CoxeterMatrix type, eventhough the type is finite.

But this probably causes trouble?

In a sense, having a "relabel" method somehow means that we have a canonical way of doing and then whenever it is not that one, it means that it was relabeled.

Does that make sense?


---

Comment by tscrim created at 2015-10-13 13:08:50

Replying to [comment:77 jipilab]:
> Replying to [comment:74 tscrim]:
> > The fix was that the cluster seed code was assuming the indexing set of a Cartan matrix constructed from a matrix that was of finite type had the standard finite type indexing set of `[1, 2, ..., n]`. I fixed this by explicitly specifying this to be the index set of the Cartan matrix.
> 
> Is my last edition to make test pass consistent with this change?

One of the trivial doctest failures because of `subtype` actually was the one indicating the problem, but that was because I wasn't passing the indexing set as I should have been. We should check for `CoxeterMatrix` and `CoxeterType` that labelings work as they should.

> > This brings up a point that might need a discussion: Should the index set of a matrix representing a finite type Cartan matrix be by default 1-based or 0-based? The argument for being 1-based is above, a natural assumption on index sets of finite type. Why we should have 0-based is consistency with the rest for default labellings and it agrees with the indexing set of the given matrix (and everything in python is 0-based). Thoughts?
> 
> I would say 1-based for finite type since they probably have a labeling hardcoded when dealing with them through Cartan matrices and Coxeter Types.
> 
> I would say 0-based whenever there is no labels specified and it comes through a CoxeterMatrix type, eventhough the type is finite.
> 
> But this probably causes trouble?

I was talking about when no labels are given, and it sounds like we are in agreement. However there is some code that doesn't use the indexing set, but instead a range under the assumption that the indexing set is `(1, 2, ..., n)`. I'm still partially debating whether or not to change the cluster seed code as well to help make it robust (although it is somewhat moot because we now specify the indexing set).

In short, it causes trouble for people's code that had made an assumption about the indexing set before.

> In a sense, having a "relabel" method somehow means that we have a canonical way of doing and then whenever it is not that one, it means that it was relabeled.
> 
> Does that make sense?

Yes it makes sense. In a way, I agree with you. However, we must define a canonical way of labeling in order to implement the database of Cartan types. Also we can relabel relabeled types.


---

Comment by nthiery created at 2015-10-14 11:47:04

For whatever it's worth, the strategy I followed in the root system
code was to never make any assumption on the indexing set `I`.

For Cartan matrices, the situation is similar with that of matrices of
module morphisms. Ideally they would be indexed by I; however we don't
really have yet a good matrix class supporting arbitrary indexing (or
do we? Panda's DataFrame class [1] could be an interesting starting
point!). That's in particular why I avoided using the Cartan matrix as
much as possible in computations, preferring instead the Dynkin
diagram.

Until we have a class for matrices with arbitrary indexing, I believe
we should stick to what has been done so far: index the matrix by
`0,...,|I|-1` with row/column i corresponding to the i-th element of
the indexing set `I` (following Python's convention: i=0 gives the
first element).

Cheers,
                              Nicolas

[1] http://www.gregreda.com/2013/10/26/working-with-pandas-dataframes/


---

Comment by tscrim created at 2015-10-15 19:39:48

Replying to [comment:79 nthiery]:
> Until we have a class for matrices with arbitrary indexing, I believe
> we should stick to what has been done so far: index the matrix by
> `0,...,|I|-1` with row/column i corresponding to the i-th element of
> the indexing set `I` (following Python's convention: i=0 gives the
> first element).

So my takeaway from what you're saying is that you also agree that the default indexing set for Cartan matrices should be `0, 1, ..., |I|-1`. Is that correct? We aren't changing the actual `__getitem__` in this ticket (which always uses `0, 1, ...., |I|-1`). The failures in cluster seed was caused by the root system having the "wrong" indexing set.


---

Comment by jipilab created at 2015-10-21 13:05:17

All tests now pass on my sage-6.9 version (root_system, rigged_configuration, cluster_algebra_quiver, crystals folders)

Now, what is this startup module error in the patchbot??


---

Comment by tscrim created at 2015-10-21 14:54:31

Replying to [comment:81 jipilab]:
> All tests now pass on my sage-6.9 version (root_system, rigged_configuration, cluster_algebra_quiver, crystals folders)

That's good.

> Now, what is this startup module error in the patchbot??

It is because we have an extra module (the one for Coxeter matices) that gets imported when Sage starts. This is there as a very mild warning to try to not increase statup time, but it's somewhat of a necessary (very small) evil for us to do here.


---

Comment by jipilab created at 2015-10-22 16:34:51

Changing status from needs_review to positive_review.


---

Comment by jipilab created at 2015-10-22 16:34:51

As all tests are passed and the labeling issues were solved, I set the ticket to positive review.


---

Comment by tscrim created at 2015-10-22 16:56:13

Thank you for your work on this.


---

Comment by vbraun created at 2015-10-23 08:12:32

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2015-10-23 08:12:32

PDF docs don't build


---

Comment by git created at 2015-10-23 15:03:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-23 15:04:39

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2015-10-24 10:22:21

Resolution: fixed


---

Comment by slabbe created at 2015-11-01 19:03:48

Replying to [comment:81 jipilab]: 
> Now, what is this startup module error in the patchbot??

It is because the new imports in the sage namespaces done in the file `# file /src/sage/combinat/root_system/all.py` :


```
from coxeter_matrix import CoxeterMatrix
from coxeter_type import CoxeterType
```


which automatically loads all this from `src/sage/combinat/root_system/coxeter_matrix.py` file:


```
+from sage.misc.cachefunc import cached_method
+from sage.matrix.constructor import matrix
+from sage.matrix.matrix_space import MatrixSpace
+from sage.misc.classcall_metaclass import ClasscallMetaclass, typecall
+from sage.matrix.matrix_generic_dense import Matrix_generic_dense
+from sage.graphs.graph import Graph
+from sage.rings.all import ZZ, QQ, RR
+from sage.rings.infinity import infinity
+from sage.combinat.root_system.cartan_type import CartanType
+from sage.combinat.root_system.coxeter_type import CoxeterType
```


and this from `src/sage/combinat/root_system/coxeter_type.py` file:


```
+from sage.misc.abstract_method import abstract_method
+from sage.misc.cachefunc import cached_method
+from sage.misc.classcall_metaclass import ClasscallMetaclass
+from sage.combinat.root_system.cartan_type import CartanType
+from sage.matrix.all import MatrixSpace
+from sage.symbolic.ring import SR
+from sage.structure.unique_representation import UniqueRepresentation
+from sage.structure.sage_object import SageObject
```


which explains why the patchbot was saying that Sage now takes 6 seconds instead of 5 to start. You may think about the following questions:

 - Do all of these imports really need to be done at the top level of those two modules?
 - Do you really need to import `CoxeterMatrix` and `CoxeterType` in the Sage namespace? I mean, it is usefull for you, for me. But, maybe that 99% of people will not use those two things while using Sage. So I think you do not have to import them in the global Sage namespace.

Anyhow, since this ticket is closed, this discussion should be moved to another ticket if it is worthwhile to continue that discussion.


---

Comment by tscrim created at 2015-11-01 19:36:11

You are not being fair. All of those are already imported, so they contribute so marginally to startup time that they are essentially non-existent. This can be seen by the startup time plugin which says there _might_ have been a 1.6 millisecond increase in startup time out of 2.6 second average startup.

Also, how many things in the Sage namespace are really useful to most users of Sage? Most of the things that are there are not useful to 99% of the users. So let's advocate removing them from the global namespace, and then nothing except basic calculus will be easily discoverable.

I agree that we do need to be somewhat careful about startup time. However to do that, we need better resolution of lazy imports and large chunks of combinat to be changed to be lazily imported (see #15293). But let us keep this in perspective.


---

Comment by slabbe created at 2015-11-02 10:48:42

Replying to [comment:90 tscrim]:
> This can be seen by the startup time plugin which says there _might_ have been a 1.6 millisecond increase in startup time out of 2.6 second average startup.

Sorry, I think the 5->6 seconds was only the time being spent by the plugin itself. Where do you read the "1.6 ms" information?


---

Comment by tscrim created at 2015-11-02 14:05:57

Replying to [comment:91 slabbe]:
> Replying to [comment:90 tscrim]:
> > This can be seen by the startup time plugin which says there _might_ have been a 1.6 millisecond increase in startup time out of 2.6 second average startup.
> 
> Sorry, I think the 5->6 seconds was only the time being spent by the plugin itself. Where do you read the "1.6 ms" information?

See the `plugins.startup_time` link in the patchbot report.
