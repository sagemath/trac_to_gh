# Issue 7124: affine cipher and its cryptanalysis

archive/issues_007124.json:
```json
{
    "body": "Depends on #7123.\n\n**CC:**  @rbeezer\n\n**Keywords:** affine cipher\n\n**Resolution:** fixed\n\n**Author:** Minh Van Nguyen\n\n**Reviewer:** Rob Beezer\n\n**Merged:** sage-4.2.1.alpha0\n\nIssue created by migration from https://trac.sagemath.org/ticket/7124\n\n",
    "closed_at": "2009-10-31T15:39:33Z",
    "created_at": "2009-10-05T16:13:43Z",
    "labels": [
        "component: cryptography"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-4.2.1",
    "title": "affine cipher and its cryptanalysis",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/7124",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```
Depends on #7123.

**CC:**  @rbeezer

**Keywords:** affine cipher

**Resolution:** fixed

**Author:** Minh Van Nguyen

**Reviewer:** Rob Beezer

**Merged:** sage-4.2.1.alpha0

Issue created by migration from https://trac.sagemath.org/ticket/7124





---

archive/issue_comments_074544.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1 +1 @@\n-\n+Depends on #7123.\n``````\n",
    "created_at": "2009-10-05T16:15:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74544",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1 +1 @@
-
+Depends on #7123.
``````




---

archive/issue_comments_074545.json:
```json
{
    "body": "**Author:** Minh Van Nguyen",
    "created_at": "2009-10-10T00:09:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74545",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Author:** Minh Van Nguyen



---

archive/issue_comments_074546.json:
```json
{
    "body": "**Changing keywords** from \"\" to \"affine cipher\".",
    "created_at": "2009-10-10T00:09:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74546",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing keywords** from "" to "affine cipher".



---

archive/issue_comments_074547.json:
```json
{
    "body": "**Changing status** from new to needs_work.",
    "created_at": "2009-10-10T00:09:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74547",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from new to needs_work.



---

archive/issue_comments_074548.json:
```json
{
    "body": "<a id='comment:2'></a>\nThe patch `trac_7124-affine.patch` implements the affine cryptosystem.",
    "created_at": "2009-10-10T00:09:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74548",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:2'></a>
The patch `trac_7124-affine.patch` implements the affine cryptosystem.



---

archive/issue_comments_074549.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2009-10-13T01:47:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74549",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_074550.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2009-10-15T00:38:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74550",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_074551.json:
```json
{
    "body": "<a id='comment:5'></a>\nIn light of rbeezer's comments at #7123, I need to update the patches on this ticket since they depend on #7123. Also, I would like to add some more stuff to the patches for the affine cipher.",
    "created_at": "2009-10-15T00:38:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74551",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:5'></a>
In light of rbeezer's comments at #7123, I need to update the patches on this ticket since they depend on #7123. Also, I would like to add some more stuff to the patches for the affine cipher.



---

archive/issue_comments_074552.json:
```json
{
    "body": "Attachment [trac_7124_brute_force_output.txt](tarball://root/attachments/some-uuid/ticket7124/trac_7124_brute_force_output.txt) by @rbeezer created at 2009-10-15 01:07:11\n\nSample output for odd behavior of `brute_force()`",
    "created_at": "2009-10-15T01:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74552",
    "user": "https://github.com/rbeezer"
}
```

Attachment [trac_7124_brute_force_output.txt](tarball://root/attachments/some-uuid/ticket7124/trac_7124_brute_force_output.txt) by @rbeezer created at 2009-10-15 01:07:11

Sample output for odd behavior of `brute_force()`



---

archive/issue_comments_074553.json:
```json
{
    "body": "<a id='comment:6'></a>\nMinh,\n\nOutput of plain `brute_force()` looks suspicious, and when a ranking is suggested, errors are raised.  Tests are failing as well.  See attached.\n\nInside `brute_force()` method, should the `L` list be so empty?\n\nRob",
    "created_at": "2009-10-15T01:07:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74553",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:6'></a>
Minh,

Output of plain `brute_force()` looks suspicious, and when a ranking is suggested, errors are raised.  Tests are failing as well.  See attached.

Inside `brute_force()` method, should the `L` list be so empty?

Rob



---

archive/issue_comments_074554.json:
```json
{
    "body": "<a id='comment:7'></a>\nPlease try the latest patches based on Sage 4.1.2.rc2.",
    "created_at": "2009-10-15T01:17:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74554",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:7'></a>
Please try the latest patches based on Sage 4.1.2.rc2.



---

archive/issue_comments_074555.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2009-10-15T01:21:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74555",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_074556.json:
```json
{
    "body": "<a id='comment:8'></a>\n\n```\n18:13 < mvngu> rbeezer: The output of brute_force() is all the 312 possible\n               dicipherments.\n18:14 < mvngu> rbeezer: It uses a list of list for an indexing scheme that's\n               meant for readability.\n18:14 < rbeezer> but I'm not getting the keys that achieves them\n18:14 < rbeezer> the L list is a list of empty lists??\n18:14 < mvngu> rbeezer: Let me upload my recent patches....\n18:14 < rbeezer> aah, that'd help  ;-) ;-)\n18:18 < mvngu> rbeezer: Uploaded patches.\n18:18 < mvngu> rbeezer: Note the ticket dependency.\n18:19 < rbeezer> thanks - do they include whatever prompted you to take the \n                 ticket back to \"needs work\"\n18:19 < mvngu> rbeezer: yes\n18:19 < rbeezer> In other words, should I attempt a full review in the next 6 \n                 hours, or no?\n18:19 < mvngu> rbeezer: I fixed some documentation typos, add an example on the \n               decimation cipher.\n18:20 < mvngu> rbeezer: And yes, I think it's ready for a full review.\n18:20 < mvngu> rbeezer: Thank you very much for spending time on these crypto \n               stuff!\n```",
    "created_at": "2009-10-15T01:21:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74556",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:8'></a>

```
18:13 < mvngu> rbeezer: The output of brute_force() is all the 312 possible
               dicipherments.
18:14 < mvngu> rbeezer: It uses a list of list for an indexing scheme that's
               meant for readability.
18:14 < rbeezer> but I'm not getting the keys that achieves them
18:14 < rbeezer> the L list is a list of empty lists??
18:14 < mvngu> rbeezer: Let me upload my recent patches....
18:14 < rbeezer> aah, that'd help  ;-) ;-)
18:18 < mvngu> rbeezer: Uploaded patches.
18:18 < mvngu> rbeezer: Note the ticket dependency.
18:19 < rbeezer> thanks - do they include whatever prompted you to take the 
                 ticket back to "needs work"
18:19 < mvngu> rbeezer: yes
18:19 < rbeezer> In other words, should I attempt a full review in the next 6 
                 hours, or no?
18:19 < mvngu> rbeezer: I fixed some documentation typos, add an example on the 
               decimation cipher.
18:20 < mvngu> rbeezer: And yes, I think it's ready for a full review.
18:20 < mvngu> rbeezer: Thank you very much for spending time on these crypto 
               stuff!
```



---

archive/issue_comments_074557.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2009-10-15T01:52:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74557",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_074558.json:
```json
{
    "body": "<a id='comment:9'></a>\nAt present, here's what happening with the method `brute_force()`: it returns a list of lists `L` that contains all the possible decipherments. And that's it, not even the key that results in a candidate decipherment. If you think the present behaviour is confusing, yes, I agree with that. Here's a sample session.\n\n```\nsage: A = AffineCryptosystem(AlphabeticStrings())\nsage: cipher = A(11, 4)\nsage: P = A.encoding(\"Have a nice day at the seashore.\")\nsage: C = cipher(P); C\nDEBWEROAWLEIEFFDWUWEUDCJW\nsage: candidates = A.brute_force(C)\nsage: candidates[1]\n\n[DEBWEROAWLEIEFFDWUWEUDCJW,\n CDAVDQNZVKDHDEECVTVDTCBIV,\n BCZUCPMYUJCGCDDBUSUCSBAHU,\n ABYTBOLXTIBFBCCATRTBRAZGT,\n ZAXSANKWSHAEABBZSQSAQZYFS,\n YZWRZMJVRGZDZAAYRPRZPYXER,\n XYVQYLIUQFYCYZZXQOQYOXWDQ,\n WXUPXKHTPEXBXYYWPNPXNWVCP,\n VWTOWJGSODWAWXXVOMOWMVUBO,\n UVSNVIFRNCVZVWWUNLNVLUTAN,\n TURMUHEQMBUYUVVTMKMUKTSZM,\n STQLTGDPLATXTUUSLJLTJSRYL,\n RSPKSFCOKZSWSTTRKIKSIRQXK,\n QROJREBNJYRVRSSQJHJRHQPWJ,\n PQNIQDAMIXQUQRRPIGIQGPOVI,\n OPMHPCZLHWPTPQQOHFHPFONUH,\n NOLGOBYKGVOSOPPNGEGOENMTG,\n MNKFNAXJFUNRNOOMFDFNDMLSF,\n LMJEMZWIETMQMNNLECEMCLKRE,\n KLIDLYVHDSLPLMMKDBDLBKJQD,\n JKHCKXUGCRKOKLLJCACKAJIPC,\n IJGBJWTFBQJNJKKIBZBJZIHOB,\n HIFAIVSEAPIMIJJHAYAIYHGNA,\n GHEZHURDZOHLHIIGZXZHXGFMZ,\n FGDYGTQCYNGKGHHFYWYGWFELY,\n EFCXFSPBXMFJFGGEXVXFVEDKX]\n```\nI think this is perhaps why you said the output of `brute_force()` is odd. In the method `brute_force()` of the shift cipher from #7123, it provides both the key together with the corresponding candidate decipherment. In the current affine cipher implementation, I forgot about the output of the brute force method in #7123. OK, move to \"needs work\" again.",
    "created_at": "2009-10-15T01:52:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74558",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:9'></a>
At present, here's what happening with the method `brute_force()`: it returns a list of lists `L` that contains all the possible decipherments. And that's it, not even the key that results in a candidate decipherment. If you think the present behaviour is confusing, yes, I agree with that. Here's a sample session.

```
sage: A = AffineCryptosystem(AlphabeticStrings())
sage: cipher = A(11, 4)
sage: P = A.encoding("Have a nice day at the seashore.")
sage: C = cipher(P); C
DEBWEROAWLEIEFFDWUWEUDCJW
sage: candidates = A.brute_force(C)
sage: candidates[1]

[DEBWEROAWLEIEFFDWUWEUDCJW,
 CDAVDQNZVKDHDEECVTVDTCBIV,
 BCZUCPMYUJCGCDDBUSUCSBAHU,
 ABYTBOLXTIBFBCCATRTBRAZGT,
 ZAXSANKWSHAEABBZSQSAQZYFS,
 YZWRZMJVRGZDZAAYRPRZPYXER,
 XYVQYLIUQFYCYZZXQOQYOXWDQ,
 WXUPXKHTPEXBXYYWPNPXNWVCP,
 VWTOWJGSODWAWXXVOMOWMVUBO,
 UVSNVIFRNCVZVWWUNLNVLUTAN,
 TURMUHEQMBUYUVVTMKMUKTSZM,
 STQLTGDPLATXTUUSLJLTJSRYL,
 RSPKSFCOKZSWSTTRKIKSIRQXK,
 QROJREBNJYRVRSSQJHJRHQPWJ,
 PQNIQDAMIXQUQRRPIGIQGPOVI,
 OPMHPCZLHWPTPQQOHFHPFONUH,
 NOLGOBYKGVOSOPPNGEGOENMTG,
 MNKFNAXJFUNRNOOMFDFNDMLSF,
 LMJEMZWIETMQMNNLECEMCLKRE,
 KLIDLYVHDSLPLMMKDBDLBKJQD,
 JKHCKXUGCRKOKLLJCACKAJIPC,
 IJGBJWTFBQJNJKKIBZBJZIHOB,
 HIFAIVSEAPIMIJJHAYAIYHGNA,
 GHEZHURDZOHLHIIGZXZHXGFMZ,
 FGDYGTQCYNGKGHHFYWYGWFELY,
 EFCXFSPBXMFJFGGEXVXFVEDKX]
```
I think this is perhaps why you said the output of `brute_force()` is odd. In the method `brute_force()` of the shift cipher from #7123, it provides both the key together with the corresponding candidate decipherment. In the current affine cipher implementation, I forgot about the output of the brute force method in #7123. OK, move to "needs work" again.



---

archive/issue_comments_074559.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2009-10-15T21:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74559",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_074560.json:
```json
{
    "body": "<a id='comment:10'></a>\nrbeezer --- I think I have addressed your comment about the output of `brute_force()` being odd. Please use the latest version of the patches.",
    "created_at": "2009-10-15T21:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74560",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:10'></a>
rbeezer --- I think I have addressed your comment about the output of `brute_force()` being odd. Please use the latest version of the patches.



---

archive/issue_comments_074561.json:
```json
{
    "body": "<a id='comment:11'></a>\nHi Minh,\n\nTwo comments:\n\n1.  I think `inverse_key()` is broken.  The constant term is always identical, for example, run\n\n```\nx=S.random_key(); print x, S.inverse_key(*x)}}} \n\nrepeatedly.\n\nThis shouldn't happen even for a=1 as is written in the doctests, since when a=1 it is a shift system.  For testing, the inverse of (a,b)=(5,7) should be (21,9).  You can test this by enchipering with one key and deciphering with the other, results should be the same (this might be good thing to do in the doctests).\n\nMaybe you just need subtraction someplace where you have a addition, or...\n\n2.  Would it make sense to build the list {{{A}}} of invertible linear coefficients in the {{{brute_force}}} method as part of {{{__init__}}} for the cryptosystem?  Then you could skip some of the gcd-stuff.  For example when building a random key, you could just grab a linear coefficient, instead of repeatedly testing.  Or when checking validity for a new key, you could just test on the list.  Done right, the generation of {{{A}}} could easily generalize to a new alphabet length for a new monoid as the alphabet.\n\nRob",
    "created_at": "2009-10-16T05:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74561",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:11'></a>
Hi Minh,

Two comments:

1.  I think `inverse_key()` is broken.  The constant term is always identical, for example, run

```
x=S.random_key(); print x, S.inverse_key(*x)}}} 

repeatedly.

This shouldn't happen even for a=1 as is written in the doctests, since when a=1 it is a shift system.  For testing, the inverse of (a,b)=(5,7) should be (21,9).  You can test this by enchipering with one key and deciphering with the other, results should be the same (this might be good thing to do in the doctests).

Maybe you just need subtraction someplace where you have a addition, or...

2.  Would it make sense to build the list {{{A}}} of invertible linear coefficients in the {{{brute_force}}} method as part of {{{__init__}}} for the cryptosystem?  Then you could skip some of the gcd-stuff.  For example when building a random key, you could just grab a linear coefficient, instead of repeatedly testing.  Or when checking validity for a new key, you could just test on the list.  Done right, the generation of {{{A}}} could easily generalize to a new alphabet length for a new monoid as the alphabet.

Rob



---

archive/issue_comments_074562.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2009-10-16T05:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74562",
    "user": "https://github.com/rbeezer"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_074563.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [rbeezer](#comment%3A11):\n> 1.  I think `inverse_key()` is broken.  The constant term is always identical, for example, run\n\n\n```\nx=S.random_key(); print x, S.inverse_key(*x)\n```\n> repeatedly. This shouldn't happen even for a=1 as is written in the doctests, since when a=1 it is a shift system.  For testing, the inverse of (a,b)=(5,7) should be (21,9).  You can test this by enchipering with one key and deciphering with the other, results should be the same (this might be good thing to do in the doctests).\n\n\nI may be misunderstanding your comment here, so please tell me if that's the case. Any key `(a,b) in ZZ/nZZ x ZZ/nZZ` of the affine cipher is such that `gcd(a,n) = 1`. So you're saying that the inverse key corresponding to `(a, b)` is `(a^{-1}, -b)` where `a^{-1}` is the multiplicative inverse of `a` modulo `n`? If that is the case, then the current implementation of `inverse_key()` is clearly broken:\n\n```\n        try:\n            from copy import copy\n            from sage.rings.arith import inverse_mod\n            n = self.alphabet_size()\n            return (inverse_mod(a, n), copy(b))\n        except:\n            raise ValueError(\"(a, b) = (%s, %s) is outside the range of acceptable values for a key of this affine cipher.\" % (a, b))\n```\n\nHow then would one use the above defined inverse key to decrypt a ciphertext? The current implementation of the method `deciphering()` follows this Wikipedia description of the encryption and decryption functions of the affine cipher:\n\nhttp://en.wikipedia.org/wiki/Affine_cipher\n\nThis agrees with the following text that I have access to:\n\n* Doug Stinson. \"Cryptography: Theory and Practice\" 3rd edition.\n* Wade Trappe and Lawrence C. Washington. \"Introduction to Cryptography with Coding Theory\"\n\n\n\n\n\n> Maybe you just need subtraction someplace where you have a addition, or...\n\n\nI don't quite understand this comment. Can you please explain it?\n\n\n\n\n\n> 2.  Would it make sense to build the list `A` of invertible linear coefficients in the `brute_force` method as part of `__init__` for the cryptosystem? \n\n\nYes it does make sense to do so, and I have implemented this in response to your suggestion. The resulting code of the affine crypto module looks less \"ugly\" from my point of view. Thank you, Rob. Please see the latest version of the patches.\n\n\n\n\n\n> Then you could skip some of the gcd-stuff.\n\n\nAnd I have skipped some of the GCD computation with the above implementation of a list of invertible elements in the multiplicative group of `ZZ/nZZ`.\n\n\n\n\n\n> For example when building a random key, you could just grab a linear coefficient, instead of repeatedly testing. \n\n\nDone according to your suggestion.\n\n\n\n\n\n> Or when checking validity for a new key, you could just test on the list. \n\n\nDone according to your suggestion.\n\n\n\n\n\n>  Done right, the generation of `A` could easily generalize to a new alphabet length for a new monoid as the alphabet.\n\n\nI can see in my mind how to implement this based on the implementation of generating invertible elements in the multiplicative group of `ZZ/nZZ`. I think this would entail changing the implementation of the class(es) that implement say, the hexadecimal monoid. Getting the affine cipher to support the hexadecimal and radix-64 monoids should be another ticket in itself.",
    "created_at": "2009-10-16T20:09:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74563",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:12'></a>
Replying to [rbeezer](#comment%3A11):
> 1.  I think `inverse_key()` is broken.  The constant term is always identical, for example, run


```
x=S.random_key(); print x, S.inverse_key(*x)
```
> repeatedly. This shouldn't happen even for a=1 as is written in the doctests, since when a=1 it is a shift system.  For testing, the inverse of (a,b)=(5,7) should be (21,9).  You can test this by enchipering with one key and deciphering with the other, results should be the same (this might be good thing to do in the doctests).


I may be misunderstanding your comment here, so please tell me if that's the case. Any key `(a,b) in ZZ/nZZ x ZZ/nZZ` of the affine cipher is such that `gcd(a,n) = 1`. So you're saying that the inverse key corresponding to `(a, b)` is `(a^{-1}, -b)` where `a^{-1}` is the multiplicative inverse of `a` modulo `n`? If that is the case, then the current implementation of `inverse_key()` is clearly broken:

```
        try:
            from copy import copy
            from sage.rings.arith import inverse_mod
            n = self.alphabet_size()
            return (inverse_mod(a, n), copy(b))
        except:
            raise ValueError("(a, b) = (%s, %s) is outside the range of acceptable values for a key of this affine cipher." % (a, b))
```

How then would one use the above defined inverse key to decrypt a ciphertext? The current implementation of the method `deciphering()` follows this Wikipedia description of the encryption and decryption functions of the affine cipher:

http://en.wikipedia.org/wiki/Affine_cipher

This agrees with the following text that I have access to:

* Doug Stinson. "Cryptography: Theory and Practice" 3rd edition.
* Wade Trappe and Lawrence C. Washington. "Introduction to Cryptography with Coding Theory"





> Maybe you just need subtraction someplace where you have a addition, or...


I don't quite understand this comment. Can you please explain it?





> 2.  Would it make sense to build the list `A` of invertible linear coefficients in the `brute_force` method as part of `__init__` for the cryptosystem? 


Yes it does make sense to do so, and I have implemented this in response to your suggestion. The resulting code of the affine crypto module looks less "ugly" from my point of view. Thank you, Rob. Please see the latest version of the patches.





> Then you could skip some of the gcd-stuff.


And I have skipped some of the GCD computation with the above implementation of a list of invertible elements in the multiplicative group of `ZZ/nZZ`.





> For example when building a random key, you could just grab a linear coefficient, instead of repeatedly testing. 


Done according to your suggestion.





> Or when checking validity for a new key, you could just test on the list. 


Done according to your suggestion.





>  Done right, the generation of `A` could easily generalize to a new alphabet length for a new monoid as the alphabet.


I can see in my mind how to implement this based on the implementation of generating invertible elements in the multiplicative group of `ZZ/nZZ`. I think this would entail changing the implementation of the class(es) that implement say, the hexadecimal monoid. Getting the affine cipher to support the hexadecimal and radix-64 monoids should be another ticket in itself.



---

archive/issue_comments_074564.json:
```json
{
    "body": "<a id='comment:13'></a>\nReplying to [mvngu](#comment%3A12):\n\nWell, I didn't really say exactly what `inverse_key()` should be on purpose - figuring it was your thesis and I shouldn't have all the fun.\n\nWikipedia is right on this one and it's what you have implemented in the deciphering routine.\n\nIf enciphering is accomplished by  x -> ax+b  (ie key is (a,b)) then \n\ndeciphering is accomplished by  `x -> a^{-1}(x-b) = a^{-1}x - a^{-1}b`\n\nso the inverse key would be the pair `(a^{-1}, -a^{-1}b)`\n\nNote the constant term.  In other words, the inverse key should be what you use for the same algorithm (linear function mod 26) to reverse the process, ie create the inverse function.\n\nTry the following: start with plain text P, encipher with key (a,b) to get ciphertext C.  Now encipher C with the inverse key, and you should get P back.  This would be a good doctest someplace, maybe for `inverse_key()`, to demonstrate its intent.\n\n1.  Consider the `enciphering()` and `deciphering()` routines in `AffineCipher` - they could each call some helper function that does the linear function, but to decipher, you just pass the inverse key rather than the key.\n\n2.  Its not clear to me why this won't all generalize easily to other alphabets?  You just need to know the size of the alphabet (n) and then construct the invertible elements in `A`}, and you need some kind of correspondence between the alphabet and the integers 0 through n-1.  But I haven't studied the monoid implementations to say for sure.",
    "created_at": "2009-10-16T23:45:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74564",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:13'></a>
Replying to [mvngu](#comment%3A12):

Well, I didn't really say exactly what `inverse_key()` should be on purpose - figuring it was your thesis and I shouldn't have all the fun.

Wikipedia is right on this one and it's what you have implemented in the deciphering routine.

If enciphering is accomplished by  x -> ax+b  (ie key is (a,b)) then 

deciphering is accomplished by  `x -> a^{-1}(x-b) = a^{-1}x - a^{-1}b`

so the inverse key would be the pair `(a^{-1}, -a^{-1}b)`

Note the constant term.  In other words, the inverse key should be what you use for the same algorithm (linear function mod 26) to reverse the process, ie create the inverse function.

Try the following: start with plain text P, encipher with key (a,b) to get ciphertext C.  Now encipher C with the inverse key, and you should get P back.  This would be a good doctest someplace, maybe for `inverse_key()`, to demonstrate its intent.

1.  Consider the `enciphering()` and `deciphering()` routines in `AffineCipher` - they could each call some helper function that does the linear function, but to decipher, you just pass the inverse key rather than the key.

2.  Its not clear to me why this won't all generalize easily to other alphabets?  You just need to know the size of the alphabet (n) and then construct the invertible elements in `A`}, and you need some kind of correspondence between the alphabet and the integers 0 through n-1.  But I haven't studied the monoid implementations to say for sure.



---

archive/issue_comments_074565.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2009-10-17T02:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74565",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_074566.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [rbeezer](#comment%3A13):\n> Try the following: start with plain text P, encipher with key (a,b) to get ciphertext C.  Now encipher C with the inverse key, and you should get P back.  This would be a good doctest someplace, maybe for `inverse_key()`, to demonstrate its intent.\n\n\nI have added this doctest.\n\n\n\n\n\n> 1.  Consider the `enciphering()` and `deciphering()` routines in `AffineCipher` - they could each call some helper function that does the linear function, but to decipher, you just pass the inverse key rather than the key.\n\n\nDone.\n\n\n\n\n\n> 2.  Its not clear to me why this won't all generalize easily to other alphabets?  You just need to know the size of the alphabet (n) and then construct the invertible elements in `A`}, and you need some kind of correspondence between the alphabet and the integers 0 through n-1.  But I haven't studied the monoid implementations to say for sure.\n\n\nIt can be generalized to other non-empty alphabets with more than 2 elements. An alphabet with 2 elements is not interesting enough to use for studying the affine cipher. In fact, I think that with the current implementation of the affine cipher, one can extend it to support alphabets such as the octal and hexadecimal number systems, radix-64 alphabet, and even the ASCII alphabet itself. It's just that doing so is tedious work for which I don't currently have time for. The same can be said for the shift cipher as well.",
    "created_at": "2009-10-17T02:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74566",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:14'></a>
Replying to [rbeezer](#comment%3A13):
> Try the following: start with plain text P, encipher with key (a,b) to get ciphertext C.  Now encipher C with the inverse key, and you should get P back.  This would be a good doctest someplace, maybe for `inverse_key()`, to demonstrate its intent.


I have added this doctest.





> 1.  Consider the `enciphering()` and `deciphering()` routines in `AffineCipher` - they could each call some helper function that does the linear function, but to decipher, you just pass the inverse key rather than the key.


Done.





> 2.  Its not clear to me why this won't all generalize easily to other alphabets?  You just need to know the size of the alphabet (n) and then construct the invertible elements in `A`}, and you need some kind of correspondence between the alphabet and the integers 0 through n-1.  But I haven't studied the monoid implementations to say for sure.


It can be generalized to other non-empty alphabets with more than 2 elements. An alphabet with 2 elements is not interesting enough to use for studying the affine cipher. In fact, I think that with the current implementation of the affine cipher, one can extend it to support alphabets such as the octal and hexadecimal number systems, radix-64 alphabet, and even the ASCII alphabet itself. It's just that doing so is tedious work for which I don't currently have time for. The same can be said for the shift cipher as well.



---

archive/issue_comments_074567.json:
```json
{
    "body": "<a id='comment:15'></a>\nMinh,\n\nSome specific comments:\n\n1.  In `AffineCryptoSystem` there are comments about the list L which can probably be deleted.\n\n2.  In `__call__` the sanity check computes d and checks d == 1.  This could be removed if you trust your `_invertible` list.\n\n3.  Docstring on `inverse_key` has an odd test about euler_phi=12, a list of invertibles is computed, etc.  Not sure this is really germane.\n\nRob",
    "created_at": "2009-10-17T05:45:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74567",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:15'></a>
Minh,

Some specific comments:

1.  In `AffineCryptoSystem` there are comments about the list L which can probably be deleted.

2.  In `__call__` the sanity check computes d and checks d == 1.  This could be removed if you trust your `_invertible` list.

3.  Docstring on `inverse_key` has an odd test about euler_phi=12, a list of invertibles is computed, etc.  Not sure this is really germane.

Rob



---

archive/issue_comments_074568.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2009-10-17T05:45:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74568",
    "user": "https://github.com/rbeezer"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_074569.json:
```json
{
    "body": "based on Sage 4.1.2.rc2 and #7123",
    "created_at": "2009-10-17T06:31:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74569",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

based on Sage 4.1.2.rc2 and #7123



---

archive/issue_comments_074570.json:
```json
{
    "body": "Attachment [trac_7124-affine.patch](tarball://root/attachments/some-uuid/ticket7124/trac_7124-affine.patch) by mvngu created at 2009-10-17 06:31:45\n\napply on top of previous",
    "created_at": "2009-10-17T06:31:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74570",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

Attachment [trac_7124-affine.patch](tarball://root/attachments/some-uuid/ticket7124/trac_7124-affine.patch) by mvngu created at 2009-10-17 06:31:45

apply on top of previous



---

archive/issue_comments_074571.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2009-10-17T06:36:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74571",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_074572.json:
```json
{
    "body": "<a id='comment:16'></a>\nAttachment [trac_7124-cryptanalysis.patch](tarball://root/attachments/some-uuid/ticket7124/trac_7124-cryptanalysis.patch) by mvngu created at 2009-10-17 06:36:45\n\nReplying to [rbeezer](#comment%3A15):\n> 1.  In `AffineCryptoSystem` there are comments about the list L which can probably be deleted.\n\n\nFixed.\n\n\n\n\n\n> 2.  In `__call__` the sanity check computes d and checks d == 1.  This could be removed if you trust your `_invertible` list.\n\n\nI have removed the test. In its place, I added some comments explaining why we don't need to test that each `a` is coprime to `n`, the alphabet size.\n\n\n\n\n\n> 3.  Docstring on `inverse_key` has an odd test about euler_phi=12, a list of invertibles is computed, etc.  Not sure this is really germane.\n\n\nThat doctest is meant to explain what sort of values that `a` can take on if `(a,b)` is to be a secret key. I have rewritten the doctest to explain this.",
    "created_at": "2009-10-17T06:36:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74572",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:16'></a>
Attachment [trac_7124-cryptanalysis.patch](tarball://root/attachments/some-uuid/ticket7124/trac_7124-cryptanalysis.patch) by mvngu created at 2009-10-17 06:36:45

Replying to [rbeezer](#comment%3A15):
> 1.  In `AffineCryptoSystem` there are comments about the list L which can probably be deleted.


Fixed.





> 2.  In `__call__` the sanity check computes d and checks d == 1.  This could be removed if you trust your `_invertible` list.


I have removed the test. In its place, I added some comments explaining why we don't need to test that each `a` is coprime to `n`, the alphabet size.





> 3.  Docstring on `inverse_key` has an odd test about euler_phi=12, a list of invertibles is computed, etc.  Not sure this is really germane.


That doctest is meant to explain what sort of values that `a` can take on if `(a,b)` is to be a secret key. I have rewritten the doctest to explain this.



---

archive/issue_comments_074573.json:
```json
{
    "body": "<a id='comment:17'></a>\nThis should be pretty much read to go now, but I've got a six errors being raised in the doctests.  They all seem to be due to lines 2912 and 3158 of  classical.py  which are identical\n\n```\nOM.setdefault(e, 0.0)}}}\n\nThe error is\n\n{{{AttributeError: 'DiscreteProbabilitySpace' object has no attribute 'setdefault'}}}",
    "created_at": "2009-10-19T02:31:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74573",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:17'></a>
This should be pretty much read to go now, but I've got a six errors being raised in the doctests.  They all seem to be due to lines 2912 and 3158 of  classical.py  which are identical

```
OM.setdefault(e, 0.0)}}}

The error is

{{{AttributeError: 'DiscreteProbabilitySpace' object has no attribute 'setdefault'}}}



---

archive/issue_comments_074574.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2009-10-19T02:31:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74574",
    "user": "https://github.com/rbeezer"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_074575.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [rbeezer](#comment%3A17):\n> The error is\n> \n> \n> ```\n> AttributeError: 'DiscreteProbabilitySpace' object has no attribute 'setdefault'}}}\n\n\nI took Sage 4.2 and successfully applied the attached two patches. The reference manual rebuilt successfully. Doctesting the whole Sage library didn't show up the error you reported. Can you please try using Sage 4.2? Please tell me if I've misunderstood your comments.",
    "created_at": "2009-10-28T12:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74575",
    "user": "https://trac.sagemath.org/admin/accounts/users/mvngu"
}
```

<a id='comment:18'></a>
Replying to [rbeezer](#comment%3A17):
> The error is
> 
> 
> ```
> AttributeError: 'DiscreteProbabilitySpace' object has no attribute 'setdefault'}}}


I took Sage 4.2 and successfully applied the attached two patches. The reference manual rebuilt successfully. Doctesting the whole Sage library didn't show up the error you reported. Can you please try using Sage 4.2? Please tell me if I've misunderstood your comments.



---

archive/issue_comments_074576.json:
```json
{
    "body": "<a id='comment:19'></a>\nAlright, against 4.2 there are no doctest errors in sage/crypto, so this is done.\n\nPositive review.\n\nRelease manager: apply two patches - first \"affine\" then \"cryptanalysis.\"",
    "created_at": "2009-10-30T04:53:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74576",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:19'></a>
Alright, against 4.2 there are no doctest errors in sage/crypto, so this is done.

Positive review.

Release manager: apply two patches - first "affine" then "cryptanalysis."



---

archive/issue_comments_074577.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2009-10-30T04:53:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74577",
    "user": "https://github.com/rbeezer"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_074578.json:
```json
{
    "body": "**Reviewer:** Rob Beezer",
    "created_at": "2009-10-30T04:53:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74578",
    "user": "https://github.com/rbeezer"
}
```

**Reviewer:** Rob Beezer



---

archive/issue_comments_074579.json:
```json
{
    "body": "**Changing status** from needs_review to positive_review.",
    "created_at": "2009-10-30T04:53:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74579",
    "user": "https://github.com/rbeezer"
}
```

**Changing status** from needs_review to positive_review.



---

archive/issue_events_021475.json:
```json
{
    "actor": "https://github.com/mwhansen",
    "created_at": "2009-10-31T15:39:33Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/7124#event-21475"
}
```



---

archive/issue_comments_074580.json:
```json
{
    "body": "**Merged:** sage-4.2.1.alpha0",
    "created_at": "2009-10-31T15:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74580",
    "user": "https://github.com/mwhansen"
}
```

**Merged:** sage-4.2.1.alpha0



---

archive/issue_comments_074581.json:
```json
{
    "body": "**Resolution:** fixed",
    "created_at": "2009-10-31T15:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/7124",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/7124#issuecomment-74581",
    "user": "https://github.com/mwhansen"
}
```

**Resolution:** fixed
