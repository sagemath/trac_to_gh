# Issue 16446: fast gray code for integer vectors

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2014-07-19 11:34:29

CC:  ncohen

For even more efficient generation of integer vectors... use Gray codes.


---

Comment by vdelecroix created at 2014-07-19 11:35:48

New commits:


---

Comment by vdelecroix created at 2014-07-19 11:35:48

Changing status from new to needs_review.


---

Comment by ncohen created at 2014-07-19 11:53:06

Hellooooo !!

Sorry for being unpleasant, but I've got two design questions `:-P`

1) I guess that you wrote all this as a class because you need a malloc and that you can't call "free" whenever you need in an iterator function. This being said, do you think that using a `int *` is much better than a `cdef list` in this case ?

2) Also, I wonder about the need of a gray iterator in the case of a cartesian product. If you do it naively (let's say like a addition in base 50 if you compute the cartesian product of k sets of size 50) then in 49/50 of the cases you will only do a +1 on the last element, and nothing else. And in 1/50*49/50 you will only need to change 2 elements. And in (1/50)^2(49/50) you will need to change 3.. I mean: the normal algorithm does not seem that far from the performances of a gray iterator. So you probably would not waste much if you do the normal operations of addition, and only update the coordinates of the current vector which changed. Most of the time, that will be very very few.

Nathann


---

Comment by vdelecroix created at 2014-07-19 12:04:06

Hi Nathan,

Thanks for having a look!

For 1), what do you mean? There are plenty of `int *`. Actually I do not care at this stuff as a Cython class. With enough motivation I would write a pure C file. In concrete situation I have in mind, this will mostly be call through `set_next_switch` which gives me a pair of integers `(pos,incr)`.

For 2), I guess that the answer is no. The objective is *not* to iterate naively over integer vectors but to use it where the datastructure is complicated or huge and you want to minimize the number of changes (using the lexicographic enumeration would be a nightmare as you need to care about which entries did change). A concrete examples is given by echelon matrices:
 - you enumerate pivots (shoud be a gray code to)
 - for choice of pivots you iterate over all possibilities for certain entries. For that step, changing one entry at a time instead of all of them is definitely a gain!

Vincent


---

Comment by vdelecroix created at 2014-07-19 14:30:23

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2014-07-19 14:30:23

I guess you are right... this does not need cythonisation.


---

Comment by git created at 2014-07-19 14:34:21

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2014-07-19 14:35:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2014-07-19 14:37:39

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2014-07-19 14:53:14

If I make no mistake : 

With a gray code that makes you change two coordinates for each vector, you need to do `2n^k` to enumerate the elements of `n^k`

If you just have an integer written on `k` digits and you want to go from 0000... to k-1,k-1,...,k-1 by adding 1 one it, how many changes occur ?

The leftmost coordinate is changed `n` times. The second is changed `n^2` times. The last is changed `n^k` times. What is the total ?

`k+k<sup>2+...+k</sup>n=(1-k^n+1)/(1-k)-1`

Result :


```
sage: 2*n^k # number of changes with a gray code
1620000
sage: (1-n^(k+1))/(1-n)-1 # number of changes with addition
837930
```


Thus if you really care about those changes, may you should build a function which outputs the changes that must be performed at each run, based on stupid addition ? Or did I make a mistake somewhere ?

Nathann


---

Comment by vdelecroix created at 2014-07-19 15:00:17

Replying to [comment:8 ncohen]:
> If I make no mistake : 

You did.
 
> With a gray code that makes you change two coordinates for each vector, you need to do `2n^k` to enumerate the elements of `n^k`

It is only one change at a time. So it is `n^k`.

Result : 

```
sage: n^k # number of changes with a gray code
810000
sage: (1-n^(k+1))/(1-n)-1 # number of changes with addition
837930
```


> Thus if you really care about those changes, may you should build a function which outputs the changes that must be performed at each run, based on stupid addition ? Or did I make a mistake somewhere ?

The point is not really the gain in the number of changes but rather the simplicity with which you can adapt more complicated stuff. If you have to iterate through the number of changes you need a for loop. With a gray code, you need nothing, just do your change!

Vincent


---

Comment by ncohen created at 2014-07-19 15:02:51

Yo !

> You did.

Okay, that's fair `:-D`

Nathann


---

Comment by git created at 2014-07-21 07:45:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2014-07-21 07:45:54

Changes as we discussed:
 - simplify the name of functions
 - make the doc clearer

And bonus:
 - combinations work with n=infinity

Vincent


---

Comment by ncohen created at 2014-07-21 08:59:33

Hellooooooooooooooooooo !!

If the commit at public/16683 is okay for you, you can set this ticket to `positive_review` !

Nathann


---

Comment by vdelecroix created at 2014-07-21 10:28:58

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2014-07-21 10:28:58

Thanks. Great!

Vincent
----
New commits:


---

Comment by vbraun created at 2014-07-22 16:33:56

Resolution: fixed
