# Issue 20432: LatticePoset: add function to get all sublattices

archive/issues_020432.json:
```json
{
    "body": "CC:  @tscrim\n\nKeywords: latticeposet\n\nThis patch will add a function that gives all sublattices of a lattice.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/20669\n\n",
    "created_at": "2016-05-24T08:47:51Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.3",
    "title": "LatticePoset: add function to get all sublattices",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20432",
    "user": "https://github.com/jm58660"
}
```
CC:  @tscrim

Keywords: latticeposet

This patch will add a function that gives all sublattices of a lattice.


Issue created by migration from https://trac.sagemath.org/ticket/20669





---

archive/issue_comments_281226.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-05-24T08:52:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281226",
    "user": "https://github.com/jm58660"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_281227.json:
```json
{
    "body": "Travis selected as a random victim for review.\n\n---\nNew commits:",
    "created_at": "2016-05-24T08:52:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281227",
    "user": "https://github.com/jm58660"
}
```

Travis selected as a random victim for review.

---
New commits:



---

archive/issue_comments_281228.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-05-24T13:12:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281228",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_281229.json:
```json
{
    "body": "I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).",
    "created_at": "2016-05-24T13:12:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281229",
    "user": "https://github.com/tscrim"
}
```

I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).



---

archive/issue_comments_281230.json:
```json
{
    "body": "Replying to [comment:3 tscrim]:\n> I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).\n\n\nMaximun recursion limit is 999 by default, and that is too small only if we have a `ChainPoset(n)` with `n > 999`; recursion stack will have at most as many steps as the lattice has elements. And it will have `2^999` sublattices anyway, so this is not valid argument.\n\nFor example after `B4 = Posets.BooleanLattice(4)` it takes 0,02 seconds to count 732 sublattices with `len(list(B4._hasse_diagram.sublattices_iterator(set(), 0)))`, whereas it took 1,13 seconds with `len(B4.sublattices())`. So if one wants to optimize lattices, then bottleneck is usually not in `hasse_diagram.py` but in `lattices.py`.\n\nOf course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?",
    "created_at": "2016-05-24T13:40:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281230",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:3 tscrim]:
> I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).


Maximun recursion limit is 999 by default, and that is too small only if we have a `ChainPoset(n)` with `n > 999`; recursion stack will have at most as many steps as the lattice has elements. And it will have `2^999` sublattices anyway, so this is not valid argument.

For example after `B4 = Posets.BooleanLattice(4)` it takes 0,02 seconds to count 732 sublattices with `len(list(B4._hasse_diagram.sublattices_iterator(set(), 0)))`, whereas it took 1,13 seconds with `len(B4.sublattices())`. So if one wants to optimize lattices, then bottleneck is usually not in `hasse_diagram.py` but in `lattices.py`.

Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?



---

archive/issue_comments_281231.json:
```json
{
    "body": "Replying to [comment:4 jmantysalo]:\n> Replying to [comment:3 tscrim]:\n> > I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).\n\n> \n> Maximun recursion limit is 999 by default, and that is too small only if we have a `ChainPoset(n)` with `n > 999`; recursion stack will have at most as many steps as the lattice has elements. And it will have `2^999` sublattices anyway, so this is not valid argument.\n\n\nPeople could want to do some partial tests on some really big example of a lattice or wanted to run a month-long-type computation on a big lattice (of which, there are a number of examples of finite exceptional cases that I come across in my research where the easiest way to prove things can be to do long computations). \n\n> For example after `B4 = Posets.BooleanLattice(4)` it takes 0,02 seconds to count 732 sublattices with `len(list(B4._hasse_diagram.sublattices_iterator(set(), 0)))`, whereas it took 1,13 seconds with `len(B4.sublattices())`. So if one wants to optimize lattices, then bottleneck is usually not in `hasse_diagram.py` but in `lattices.py`.\n\n\nI don't disagree with this, but you should not be creating the lattice by using the `LatticePoset` but directly creating the necessary data and passing it to `FiniteLatticePoset`. This avoids the extra overhead and checks that is in the `Poset` code.\n\n> Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?\n\n\nI have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?",
    "created_at": "2016-05-24T13:58:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281231",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:4 jmantysalo]:
> Replying to [comment:3 tscrim]:
> > I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).

> 
> Maximun recursion limit is 999 by default, and that is too small only if we have a `ChainPoset(n)` with `n > 999`; recursion stack will have at most as many steps as the lattice has elements. And it will have `2^999` sublattices anyway, so this is not valid argument.


People could want to do some partial tests on some really big example of a lattice or wanted to run a month-long-type computation on a big lattice (of which, there are a number of examples of finite exceptional cases that I come across in my research where the easiest way to prove things can be to do long computations). 

> For example after `B4 = Posets.BooleanLattice(4)` it takes 0,02 seconds to count 732 sublattices with `len(list(B4._hasse_diagram.sublattices_iterator(set(), 0)))`, whereas it took 1,13 seconds with `len(B4.sublattices())`. So if one wants to optimize lattices, then bottleneck is usually not in `hasse_diagram.py` but in `lattices.py`.


I don't disagree with this, but you should not be creating the lattice by using the `LatticePoset` but directly creating the necessary data and passing it to `FiniteLatticePoset`. This avoids the extra overhead and checks that is in the `Poset` code.

> Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?


I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?



---

archive/issue_comments_281232.json:
```json
{
    "body": "Replying to [comment:5 tscrim]:\n> Replying to [comment:4 jmantysalo]:\n> > Replying to [comment:3 tscrim]:\n> > > I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).\n\n> > \n> > Maximun recursion limit is 999 by default, and that is too small only if we have a `ChainPoset(n)` with `n > 999`; recursion stack will have at most as many steps as the lattice has elements. And it will have `2^999` sublattices anyway, so this is not valid argument.\n\n\n> People could want to do some partial tests on some really big example of a lattice or wanted to run a month-long-type computation on a big lattice (of which, there are a number of examples of finite exceptional cases that I come across in my research where the easiest way to prove things can be to do long computations). \n\n\nWell, now it took only 20 seconds to make `ChainPoset(1000)`. So yes, it is theoretically possible to run this kind of computations. But then, recursion limit can be changed.\n\n> > Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?\n\n> \n> I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?\n\n\nNo, but that could be added. Or actually copied from current file. For Frattini sublattices that would actually make sense.\n\n---\n\nBasic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?",
    "created_at": "2016-05-24T14:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281232",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:5 tscrim]:
> Replying to [comment:4 jmantysalo]:
> > Replying to [comment:3 tscrim]:
> > > I think you should use a backtracking algorithm instead of a recursion. It will be faster (and you don't have to constantly get things like `self.cardinality()`), never run up against the Python maximum recursion limit, and have better input (which `set()` and `0` should be defaults anyways).

> > 
> > Maximun recursion limit is 999 by default, and that is too small only if we have a `ChainPoset(n)` with `n > 999`; recursion stack will have at most as many steps as the lattice has elements. And it will have `2^999` sublattices anyway, so this is not valid argument.


> People could want to do some partial tests on some really big example of a lattice or wanted to run a month-long-type computation on a big lattice (of which, there are a number of examples of finite exceptional cases that I come across in my research where the easiest way to prove things can be to do long computations). 


Well, now it took only 20 seconds to make `ChainPoset(1000)`. So yes, it is theoretically possible to run this kind of computations. But then, recursion limit can be changed.

> > Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?

> 
> I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?


No, but that could be added. Or actually copied from current file. For Frattini sublattices that would actually make sense.

---

Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?



---

archive/issue_comments_281233.json:
```json
{
    "body": "Replying to [comment:6 jmantysalo]:\n> Replying to [comment:5 tscrim]:\n> > Replying to [comment:4 jmantysalo]:\n> > > Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?\n\n> > \n> > I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?\n\n> \n> No, but that could be added. Or actually copied from current file. For Frattini sublattices that would actually make sense.\n\n\nHowever, meet and join doesn't quite make sense to have it there mathematically AFAIK. Although by cythonizing `hasse_diagram.py`, we should get most of possible speed without doing really much in the way of changes.\n\n> Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?\n\n\nI am going to treat this as you telling me *your* process for reviewing. Otherwise I would take that a very insulting comment to me which you are telling me how to do *my* review.",
    "created_at": "2016-05-24T20:03:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281233",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:6 jmantysalo]:
> Replying to [comment:5 tscrim]:
> > Replying to [comment:4 jmantysalo]:
> > > Of course I can change this to use backtracking, but... Then why not move this to static sparce graphs class, if we really want as fast code as possible?

> > 
> > I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?

> 
> No, but that could be added. Or actually copied from current file. For Frattini sublattices that would actually make sense.


However, meet and join doesn't quite make sense to have it there mathematically AFAIK. Although by cythonizing `hasse_diagram.py`, we should get most of possible speed without doing really much in the way of changes.

> Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?


I am going to treat this as you telling me *your* process for reviewing. Otherwise I would take that a very insulting comment to me which you are telling me how to do *my* review.



---

archive/issue_comments_281234.json:
```json
{
    "body": "Replying to [comment:7 tscrim]:\n\n> > > I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?\n\n\n> > No, but that could be added.\n\n\n> However, meet and join doesn't quite make sense to have it there mathematically AFAIK.  Although by cythonizing `hasse_diagram.py`, we should get most of possible speed without doing really much in the way of changes.\n\n\nTrue, but I think that there was obstackle for cythonizing. Something with inheritance, I think; I discussed about this with Nathann Cohen maybe a two years ago.\n\n\n> > Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?\n\n> \n> I am going to treat this as you telling me *your* process for reviewing. Otherwise I would take that a very insulting comment to me which you are telling me how to do *my* review.\n\n\nSorry. I don't intend to insult. (But also I does not so much english words to make my expressions smoother.)\n\nI was just trying to say what developer guide says: \"Please refrain from additional feature requests or open-ended discussion about alternative implementations.\"",
    "created_at": "2016-05-25T05:13:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281234",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:7 tscrim]:

> > > I have no inherent objects to this, but does the static sparse digraph code have the capacity to do the meet and joins?


> > No, but that could be added.


> However, meet and join doesn't quite make sense to have it there mathematically AFAIK.  Although by cythonizing `hasse_diagram.py`, we should get most of possible speed without doing really much in the way of changes.


True, but I think that there was obstackle for cythonizing. Something with inheritance, I think; I discussed about this with Nathann Cohen maybe a two years ago.


> > Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?

> 
> I am going to treat this as you telling me *your* process for reviewing. Otherwise I would take that a very insulting comment to me which you are telling me how to do *my* review.


Sorry. I don't intend to insult. (But also I does not so much english words to make my expressions smoother.)

I was just trying to say what developer guide says: "Please refrain from additional feature requests or open-ended discussion about alternative implementations."



---

archive/issue_comments_281235.json:
```json
{
    "body": "Replying to [comment:8 jmantysalo]:\n> Replying to [comment:7 tscrim]:\n> > However, meet and join doesn't quite make sense to have it there mathematically AFAIK.  Although by cythonizing `hasse_diagram.py`, we should get most of possible speed without doing really much in the way of changes.\n\n> \n> True, but I think that there was obstackle for cythonizing. Something with inheritance, I think; I discussed about this with Nathann Cohen maybe a two years ago.\n\n\nI don't see anything that would prevent a cythonization; the `HasseDiagram` class only has single inheritance (and cython probably has improved since when you discussed this).\n\n> > > Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?\n\n> > \n> > I am going to treat this as you telling me *your* process for reviewing. Otherwise I would take that a very insulting comment to me which you are telling me how to do *my* review.\n\n> \n> Sorry. I don't intend to insult. (But also I does not so much english words to make my expressions smoother.)\n\n\nI know you didn't, but it first seemed like you were trying to tell me how to review this. My reply was condescending, to which I apologize as well.\n\n> I was just trying to say what developer guide says: \"Please refrain from additional feature requests or open-ended discussion about alternative implementations.\"\n\n\nI don't think we are in an open-ended discussion because I am proposing a (single) concrete/explicit alternative implementation. While I am not strictly opposed to the current implementation, I think there is a relatively easy way to improve it. I might have some time to change the algorithm today, if you're okay with it (I'm on French time for this week and the next).",
    "created_at": "2016-05-25T06:32:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281235",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:8 jmantysalo]:
> Replying to [comment:7 tscrim]:
> > However, meet and join doesn't quite make sense to have it there mathematically AFAIK.  Although by cythonizing `hasse_diagram.py`, we should get most of possible speed without doing really much in the way of changes.

> 
> True, but I think that there was obstackle for cythonizing. Something with inheritance, I think; I discussed about this with Nathann Cohen maybe a two years ago.


I don't see anything that would prevent a cythonization; the `HasseDiagram` class only has single inheritance (and cython probably has improved since when you discussed this).

> > > Basic questions about all reviews: 1) Is Sage better with this or without? 2) If with, is there some *easy* steps to make it still better?

> > 
> > I am going to treat this as you telling me *your* process for reviewing. Otherwise I would take that a very insulting comment to me which you are telling me how to do *my* review.

> 
> Sorry. I don't intend to insult. (But also I does not so much english words to make my expressions smoother.)


I know you didn't, but it first seemed like you were trying to tell me how to review this. My reply was condescending, to which I apologize as well.

> I was just trying to say what developer guide says: "Please refrain from additional feature requests or open-ended discussion about alternative implementations."


I don't think we are in an open-ended discussion because I am proposing a (single) concrete/explicit alternative implementation. While I am not strictly opposed to the current implementation, I think there is a relatively easy way to improve it. I might have some time to change the algorithm today, if you're okay with it (I'm on French time for this week and the next).



---

archive/issue_comments_281236.json:
```json
{
    "body": "Replying to [comment:9 tscrim]:\n\n>I might have some time to change the algorithm today, if you're okay with it (I'm on French time for this week and the next).\n\n\nOf course. I can review it then, and hopefully you can check docstrings I wrote.\n\nBtw, I plan to add `lattice_of_sublattices()`. Hence the function in `hasse_diagram.py` should return something like sets, tuples etc.",
    "created_at": "2016-05-25T06:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281236",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:9 tscrim]:

>I might have some time to change the algorithm today, if you're okay with it (I'm on French time for this week and the next).


Of course. I can review it then, and hopefully you can check docstrings I wrote.

Btw, I plan to add `lattice_of_sublattices()`. Hence the function in `hasse_diagram.py` should return something like sets, tuples etc.



---

archive/issue_comments_281237.json:
```json
{
    "body": "Just pinging...",
    "created_at": "2016-06-04T09:24:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281237",
    "user": "https://github.com/jm58660"
}
```

Just pinging...



---

archive/issue_comments_281238.json:
```json
{
    "body": "`ping`.",
    "created_at": "2016-07-01T20:21:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281238",
    "user": "https://github.com/jm58660"
}
```

`ping`.



---

archive/issue_comments_281239.json:
```json
{
    "body": "So, I just haven't had time to do the algorithm change that I wanted. This works as claimed (although I was not able to completely prove its correctness). Thus this works as a first implementation, and so positive review (I can change it to a backtrak on a follow-up ticket if and when I have more time).\n\nPS - Sorry it took so long.",
    "created_at": "2016-07-02T00:05:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281239",
    "user": "https://github.com/tscrim"
}
```

So, I just haven't had time to do the algorithm change that I wanted. This works as claimed (although I was not able to completely prove its correctness). Thus this works as a first implementation, and so positive review (I can change it to a backtrak on a follow-up ticket if and when I have more time).

PS - Sorry it took so long.



---

archive/issue_comments_281240.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2016-07-02T00:05:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281240",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_281241.json:
```json
{
    "body": "Thanks Travis!\n\nHere is the followup: #20921.",
    "created_at": "2016-07-02T05:43:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281241",
    "user": "https://github.com/jm58660"
}
```

Thanks Travis!

Here is the followup: #20921.



---

archive/issue_comments_281242.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-07-02T12:07:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281242",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_055633.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-07-02T12:07:28Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/20432#event-55633"
}
```



---

archive/issue_comments_281243.json:
```json
{
    "body": "Changing keywords from \"latticeposet\" to \"lattice poset, days78\".",
    "created_at": "2016-07-02T14:56:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20432",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20432#issuecomment-281243",
    "user": "https://github.com/tscrim"
}
```

Changing keywords from "latticeposet" to "lattice poset, days78".
