# Issue 24299: FastFloatConverter fails to convert complex I

Issue created by migration from Trac.

Original creator: rws

Original creation time: 2018-01-14 07:02:56

CC:  mjo


```
sage: from sage.symbolic.expression_conversions import FastFloatConverter
sage: f = FastFloatConverter(I)
/home/ralf/sage/src/bin/sage-ipython:1: DeprecationWarning: Substitution using function-call syntax and unnamed arguments is deprecated and will be removed from a future release of Sage; you can use named arguments instead, like EXPR(x=..., y=...)
See http://trac.sagemath.org/5930 for details.
  #!/usr/bin/env python
<sage.symbolic.expression_conversions.FastFloatConverter object at 0x7fdec25cf110>
sage: f()
/home/ralf/sage/local/lib/python2.7/site-packages/sage/symbolic/expression_conversions.pyc in __call__(self, ex)
    206         except TypeError as err:
    207             if 'self must be a numeric expression' not in err.args:
--> 208                 raise err
    209 
    210         operator = ex.operator()

TypeError: unable to coerce to a real number
```



---

Comment by rws created at 2018-01-14 07:25:37

Apparently "Float" literally means Python (real) "float" not floating-point. Of course then expressions containing `I` raise errors, even if the outcome is real. The original case was the usage by `find_local_maximum`---so that never worked, and the restriction was undocumented.


---

Comment by rws created at 2018-01-14 07:43:04

The documentation of `fast_float` states

```
def fast_float(ex, *vars):
    """
    Returns an object which provides fast floating point evaluation of
    the symbolic expression *ex*.
```

but

```
sage: from sage.symbolic.expression_conversions import fast_float
sage: ff = fast_float(abs(x+I))
/home/ralf/sage/local/lib/python2.7/site-packages/sage/symbolic/expression_conversions.py:1574: DeprecationWarning: Substitution using function-call syntax and unnamed arguments is deprecated and will be removed from a future release of Sage; you can use named arguments instead, like EXPR(x=..., y=...)
See http://trac.sagemath.org/5930 for details.
  return FastFloatConverter(ex, *vars)()
```

gives the ticket error.


---

Comment by rws created at 2018-01-14 07:57:35

Relevant: #5572. Somewhat related: #13559, #16899.


---

Comment by jsrn created at 2019-02-13 14:39:12

Note that changing the call from `find_local_maximum(abs(x+I),-1,1)` to


```
find_local_maximum(lambda x: abs(x+I),-1,1)
```


Then everything works fine.


---

Comment by mkoeppe created at 2021-07-22 00:52:29

Changing status from new to needs_info.


---

Comment by mjo created at 2021-07-29 13:19:58

The fix for this will be similar to the one in #8450. After #32234, we're using `fast_callable()` on these expressions with `domain=float`, which converts all _intermediate_ expression-evaluation results to `float`. Obviously that causes problems with the `x+I` in `abs(x+I)`. To work around that, we can probably just run the computation with `domain=CDF` and then convert the answer to `float` if its imaginary part is small enough. (But we don't want to return NaN if the end result has a nontrivial imaginary part, like we do when plotting.)


---

Comment by mjo created at 2021-07-29 13:23:47

Set assignee to mjo.


---

Comment by mjo created at 2021-07-29 13:23:47

I'll deal with it once the prereqs start to settle.


---

Comment by mjo created at 2021-07-29 13:24:15

Changing status from needs_info to needs_work.


---

Comment by mjo created at 2022-02-24 17:17:16

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2022-02-24 17:17:16

As promised, I've factored out a superclass of the `FastCallablePlotWrapper` that won't ignore complex results and will instead raise an error. This is more suitable for functions like `find_root()` and `find_local_minimum()` where a complex result can't really be ignored.

Those two functions (and the "maximum" alias) have been updated, but I'm sure there are others where the same strategy can easily be applied.
----
New commits:


---

Comment by mkoeppe created at 2022-02-24 18:38:27


```
+      * ``CDF`` has none of the other issues, because ``CDF`` has its
+        own specialized interpreter, a lexicographic ordering (for
+        min/max),
```


Should we (in a separate ticket) get rid of this ordering? It's in contrast to python3's built-in `complex`:

```
sage: CDF(1+2*I) < CDF(1-2*I)
False
sage: complex(1+2*I) < complex(1-2*I)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-5-3575b3aa8341> in <module>
----> 1 complex(Integer(1)+Integer(2)*I) < complex(Integer(1)-Integer(2)*I)

TypeError: '<' not supported between instances of 'complex' and 'complex'
```



---

Comment by mjo created at 2022-02-24 18:54:08

Replying to [comment:14 mkoeppe]:
> 
> Should we (in a separate ticket) get rid of this ordering? It's in contrast to python3's built-in `complex`:

I wonder why it was added? Someone had to go to the trouble. In any case, we'd have to find some other solution for these wrappers if the ordering was removed. Right now we're fortunate that CDF reasonably handles everything that people want to do with real numbers, so long as the imaginary parts are small.


---

Comment by mkoeppe created at 2022-02-24 18:56:01

I think it's just a leftover of python 2 semantics in which everything could be compared with everything


---

Comment by mkoeppe created at 2022-02-25 06:34:05

Similar issue for number field elements - in ticket #20028


---

Comment by mkoeppe created at 2022-02-25 18:26:12

I've opened #33417


---

Comment by git created at 2022-02-25 22:22:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-02-26 17:49:59

Maybe a better name can be found for `FastCallablePlotWrapper` that expresses better what it does?


---

Comment by mkoeppe created at 2022-02-26 17:52:03

I haven't looked at the code in much detail yet, but `FastCallablePlotWrapper` inherits from `FastCallableFloatWrapper`, but also you are double-wrapping `var` here:

```
+        from sage.ext.fast_callable import FastCallableFloatWrapper
+        f = self._plot_fast_callable(var)
+        ff = FastCallableFloatWrapper(f, imag_tol=imaginary_tolerance)
```

Is this needed?


---

Comment by mjo created at 2022-02-26 21:30:44

Replying to [comment:21 mkoeppe]:
> I haven't looked at the code in much detail yet, but `FastCallablePlotWrapper` inherits from `FastCallableFloatWrapper`, but also you are double-wrapping `var` here:
> {{{
> +        from sage.ext.fast_callable import FastCallableFloatWrapper
> +        f = self._plot_fast_callable(var)
> +        ff = FastCallableFloatWrapper(f, imag_tol=imaginary_tolerance)
> }}}
> Is this needed?

The `_plot_fast_callable()` method returns only a fast-callable over CDF, not a wrapper. When plotting, the wrapper is added during `setup_for_eval_on_grid()` to support fast-callables that don't arise from `expr.plot()`. Given that, if `_plot_fast_callable()` returned a wrapper, 'we would eventually try to wrap it twice during `expr.plot()`.


---

Comment by mjo created at 2022-02-26 21:42:41

Replying to [comment:20 mkoeppe]:
> Maybe a better name can be found for `FastCallablePlotWrapper` that expresses better what it does?

So you're not satisfied with solving easy problems all day? =)

It's awkward, and I'm open to suggestions.

I think the original name that I chose for the plotting wrapper was `FastCallableOutputWrapper`, which is more or less what it does. It wraps a fast-callable, and converts its output to... something else. But I was already aware that this ticket was going to require a different wrapping behavior. Since the behavior of the plot wrapper (returning `NaN` when it gets a complex answer) is so unique to plotting, I settled on `FastCallablePlotWrapper`.

The class for this ticket then sits beneath an abstract `FastCallableOutputWrapper` in my head. Unlike the plot wrapper, it doesn't do anything unusual during conversion, so it would rightly sit beside sibling classes such as `FastCallableComplexWrapper` or `FastCallableIntWrapper`.

I thought about naming this class `FastCallableFloatOutputWrapper`, and maybe that's a better choice, since "Plot" isn't what the "Plot" wrapper outputs. It's just so looooooooong.


---

Comment by mkoeppe created at 2022-02-26 22:06:05

In the implementation of `FastCallableFloatWrapper` I don't really see anything that is specific to using a fast callable. Perhaps it would make sense to generalize the concept, to get to a more manageable naming scheme?


---

Comment by mjo created at 2022-02-27 15:24:13

Replying to [comment:24 mkoeppe]:
> In the implementation of `FastCallableFloatWrapper` I don't really see anything that is specific to using a fast callable. Perhaps it would make sense to generalize the concept, to get to a more manageable naming scheme?

How about `UnembedFloatFromCDF` and `UnembedPlotFloatFromCDF`?

For now we could also do `UnembedFloatFromCDF(nan_on_error=<bool>)` to cover both cases, but then if the class hierarchy is ever extended upwards or laterally, the `nan_on_error` parameter isn't going to be consistent.


---

Comment by mkoeppe created at 2022-02-27 17:55:31

So this should be `CDF.coerce_map_from(float).section()`?


---

Comment by mkoeppe created at 2022-02-27 18:20:37

NumPy has https://numpy.org/doc/stable/reference/generated/numpy.real_if_close.html


---

Comment by mjo created at 2022-02-27 18:24:02

Replying to [comment:26 mkoeppe]:
> So this should be `CDF.coerce_map_from(float).section()`?

In spirit, but with a tolerance, so that the the underlying routine doesn't crash when numerical issues cause a `0.0000000000001*I` to appear. Additionally, in the plotting class, we choose to return `nan` upon encountering a complex result so that the corresponding point is "skipped."


---

Comment by mkoeppe created at 2022-02-27 18:27:03

Yes, so we would have a signaling and a non-signaling version of it


---

Comment by mkoeppe created at 2022-02-27 18:27:20

Some more random facts:

```
sage: numpy.real(complex(CDF(1,1)))
1.0
sage: numpy.real(CDF(1,1))
<built-in method real of sage.rings.complex_double.ComplexDoubleElement object at 0x1526bc8c0>
```

:(


---

Comment by mjo created at 2022-02-27 18:29:32

Replying to [comment:27 mkoeppe]:
> NumPy has https://numpy.org/doc/stable/reference/generated/numpy.real_if_close.html

That would basically work here, although I think it might be slower to go from CDF through numpy and back. The main downside to that though is that the error message will be thrown deep in some plotting or optimization routine when it receives a complex number. In the current branch I've chosen to raise an error immediately, in the wrapper, "ValueError: complex fast-callable function result..." that is usually going to better explain the problem.


---

Comment by mkoeppe created at 2022-02-27 18:44:21

I didn't mean to say that we should use this numpy function. Just collecting existing idioms and interfaces.

I was looking for a name for this operation ("convert to float if close to a real number, NaN otherwise) - and so far haven't found anything in Python, NumPy, C++ reference, ...


---

Comment by mkoeppe created at 2022-02-27 18:46:11

I guess one would need to figure out what complex infinities should convert to.


---

Comment by mkoeppe created at 2022-02-27 18:50:54

Also relevant: https://docs.python.org/3/library/cmath.html#cmath.isclose (which accepts both `rel_tol` and `abs_tol`). "The IEEE 754 special values of NaN, inf, and -inf will be handled according to IEEE rules. Specifically, [...] inf and -inf are only considered close to themselves." - this forgets to talk about complex infinities.


---

Comment by mkoeppe created at 2022-02-27 18:54:04

Not sure how well developed the built-in `complex` type is:

```
sage: cmath.inf + float(1e-16)*cmath.infj
(nan+infj)
```

??


---

Comment by mkoeppe created at 2022-02-27 19:10:42

OK that's https://bugs.python.org/issue25453, open since 2015


---

Comment by mkoeppe created at 2022-02-27 19:21:45

Here's another one:

```
sage: cmath.rect(math.inf, 0)
(inf+0j)
sage: cmath.rect(1, math.pi/4)
(0.7071067811865476+0.7071067811865475j)
sage: cmath.rect(math.inf, math.pi/4)
(inf+infj)
sage: cmath.rect(math.inf, pi/2)
(inf+infj)                             # What?
sage: cmath.rect(math.inf, 2*pi)
(inf-infj)                             # Help?!
```

https://docs.python.org/3/library/cmath.html#cmath.rect


---

Comment by git created at 2022-02-28 15:06:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-03-03 06:38:36

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2022-03-03 06:38:36

Replying to [comment:23 mjo]:
> Replying to [comment:20 mkoeppe]:
> > Maybe a better name can be found for `FastCallablePlotWrapper` that expresses better what it does?
> 
> So you're not satisfied with solving easy problems all day? =)
> 
> It's awkward, and I'm open to suggestions.

Let's postpone this to another ticket. The current branch certainly does what it promises, the implementation looks fine, and tests pass.


---

Comment by vbraun created at 2022-03-06 23:35:04

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2022-03-06 23:35:04

On OSX:

```
**********************************************************************
File "src/doc/de/thematische_anleitungen/sage_gymnasium.rst", line 534, in doc.de.thematische_anleitungen.sage_gymnasium
Failed example:
    find_root(f, 0.5, 5)
Expected:
    0.6299605249475858
Got:
    0.6299605249475857
**********************************************************************
1 item had failures:
   1 of 294 in doc.de.thematische_anleitungen.sage_gymnasium
    [207 tests, 1 failure, 5.86 s]
**********************************************************************
```



---

Comment by git created at 2022-03-08 23:36:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2022-03-08 23:38:10

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2022-03-08 23:38:10

Untested (no macOS), but that should take care of it.


---

Comment by mkoeppe created at 2022-03-08 23:55:30

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-03-12 15:11:19

Resolution: fixed
