# Issue 31800: Upgrade to lcalc-2.0.0

Issue created by migration from https://trac.sagemath.org/ticket/32037

Original creator: mjo

Original creation time: 2021-06-23 03:11:42

CC:  cremona arojas fbissey dimpase

I've just tagged a 2.0.0 release of lcalc: https://gitlab.com/sagemath/lcalc/-/tags/2.0.0

There are a few issues that need to be addressed during the upgrade.

1. The build system is now sane. This should make life easier in the long run, but means that spkg-* need to be rewritten. `./configure --with-pari` should suffice.

2. The lcalc spkg shouldn't depend on mpfr (I'm not sure why it ever did).

3. spkg-configure.m4 should be modified to find the new version, for example...


```patch
diff --git a/build/pkgs/lcalc/spkg-configure.m4 b/build/pkgs/lcalc/spkg-configure.m4
index 19a87c8d30..b332294eae 100644
--- a/build/pkgs/lcalc/spkg-configure.m4
+++ b/build/pkgs/lcalc/spkg-configure.m4
@@ -1,20 +1,20 @@
 SAGE_SPKG_CONFIGURE([lcalc], [
-    m4_pushdef([SAGE_LCALC_MINVER],["1.22"])
-    SAGE_SPKG_DEPCHECK([pari mpfr], [
+    m4_pushdef([SAGE_LCALC_MINVER],["2.0.0"])
+    SAGE_SPKG_DEPCHECK([pari], [
         AC_PATH_PROG([LCALC], [lcalc])
         AS_IF([test x$LCALC = x], [
            AC_MSG_NOTICE([lcalc not found. Installing lcalc])
            sage_spkg_install_lcalc=yes], [
            AC_MSG_CHECKING([is lcalc's version good enough? ])
-           lcalc_ver=`$LCALC --version 2>>/dev/null | $SED -e 's/lcalc\ //' | $SED -e 's/\ .*//g'`
+           lcalc_ver=$($LCALC --version 2>>/dev/null | $SED -e 's/lcalc\ //' | cut -d' ' -f2)
            AX_COMPARE_VERSION([$lcalc_ver], [ge], [$SAGE_LCALC_MINVER], [
                AC_MSG_RESULT([yes.])
-               AC_CHECK_HEADER([Lfunction/L.h], [], [sage_spkg_install_lcalc=yes])
+               AC_CHECK_HEADER([lcalc/L.h], [], [sage_spkg_install_lcalc=yes])
           AC_MSG_CHECKING([whether we can link and run a program using libLfunction])
           LCALC_SAVED_LIBS=$LIBS
           LIBS="$LIBS -lLfunction"
           AC_RUN_IFELSE([
-            AC_LANG_PROGRAM([[#include <Lfunction/L.h>]],
+            AC_LANG_PROGRAM([[#include <lcalc/L.h>]],
                       [[initialize_globals();
                         Complex x;
                         x = Pi*I;
```


However, lcalc-2.0.0 comes with a pkg-config file, so we could greatly simplify that.

4. The public API header has moved to `lcalc/L.h`:


```patch
diff --git a/src/sage/libs/lcalc/lcalc_sage.h b/src/sage/libs/lcalc/lcalc_sage.h
index 498528917f..18e5232cbe 100644
--- a/src/sage/libs/lcalc/lcalc_sage.h
+++ b/src/sage/libs/lcalc/lcalc_sage.h
@@ -1,4 +1,4 @@
-#include "Lfunction/L.h"
+#include "lcalc/L.h"
 int *new_ints(int l)
 {
     return new int[l];

```


5. The `find_zeros_via_N_v()` function was removed, and replaced by `find_zeros()`. Here's a patch:


```patch
diff --git a/src/sage/libs/lcalc/lcalc_Lfunction.pxd b/src/sage/libs/lcalc/lcalc_Lfunction.pxd
index d1dbb5d95d..5edf0844f3 100644
--- a/src/sage/libs/lcalc/lcalc_Lfunction.pxd
+++ b/src/sage/libs/lcalc/lcalc_Lfunction.pxd
@@ -21,7 +21,7 @@ cdef extern from "lcalc_sage.h":
         int (* compute_rank) ()
         double (* N) (double T)
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*print_data_L)()
 
         #Constructor and destructor
@@ -38,7 +38,7 @@ cdef extern from "lcalc_sage.h":
         double (* N) (double T)
         double *dirichlet_coefficient
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*print_data_L)()
 
         #Constructor and destructor
@@ -54,7 +54,7 @@ cdef extern from "lcalc_sage.h":
         int (* compute_rank) ()
         double (* N) (double T)
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*print_data_L)()
 
         #Constructor and destructor
@@ -70,7 +70,7 @@ cdef extern from "lcalc_sage.h":
         int (* compute_rank) ()
         double (* N) (double T)
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)#puts result in vector<double> result
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*find_zeros_via_N)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, char *filename) #puts result in filename
 
         #Constructor and destructor
@@ -111,7 +111,7 @@ cdef class Lfunction:
     #strange bug, replacing Double with double gives me a compile error
     cdef Double __typedN(self, double T)
     cdef void __find_zeros_v(self, double T1, double T2, double stepsize,doublevec *result)
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula,doublevec *result)
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
 
     cdef str _repr

```



```patch
diff --git a/src/sage/libs/lcalc/lcalc_Lfunction.pyx b/src/sage/libs/lcalc/lcalc_Lfunction.pyx
index 7e54d7e78d..409987c5d0 100644
--- a/src/sage/libs/lcalc/lcalc_Lfunction.pyx
+++ b/src/sage/libs/lcalc/lcalc_Lfunction.pyx
@@ -307,8 +307,7 @@ cdef class Lfunction:
         return returnvalue
 
     #The default values are from L.h. See L.h
-    def find_zeros_via_N(self, count=0, do_negative=False, max_refine=1025,
-                         rank=-1, test_explicit_formula=0):
+    def find_zeros_via_N(self, count=0, start=0, max_refine=1025, rank=-1):
         """
         Finds ``count`` number of zeros with positive imaginary part
         starting at real axis. This function also verifies that all
@@ -317,8 +316,7 @@ cdef class Lfunction:
         INPUT:
 
         - ``count`` - number of zeros to be found
-        - ``do_negative`` - (default: False) False to ignore zeros below the
-          real axis.
+        - ``start`` - (default: 0) how many initial zeros to skip
         - ``max_refine`` - when some zeros are found to be missing, the step
           size used to find zeros is refined. max_refine gives an upper limit
           on when lcalc should give up. Use default value unless you know
@@ -326,13 +324,9 @@ cdef class Lfunction:
         - ``rank`` - integer (default: -1) analytic rank of the L-function.
           If -1 is passed, then we attempt to compute it. (Use default if in
           doubt)
-        - ``test_explicit_formula`` - integer (default: 0) If nonzero, test
-          the explicit formula for additional confidence that all the zeros
-          have been found and are accurate. This is still being tested, so
-          using the default is recommended.
 
         OUTPUT:
-        
+
         list -- A list of the imaginary parts of the zeros that have been found
 
         EXAMPLES::
@@ -356,14 +350,10 @@ cdef class Lfunction:
             sage: L.find_zeros_via_N(3)
             [14.1347251417..., 21.0220396387..., 25.0108575801...]
         """
-        cdef Integer count_I = Integer(count)
-        cdef Integer do_negative_I = Integer(do_negative)
-        cdef RealNumber max_refine_R = RRR(max_refine)
-        cdef Integer rank_I = Integer(rank)
-        cdef Integer test_explicit_I = Integer(test_explicit_formula)
+        cdef const char *message_stamp = ""
         cdef doublevec result
         sig_on()
-        self.__find_zeros_via_N_v(mpz_get_si(count_I.value), mpz_get_si(do_negative_I.value), mpfr_get_d(max_refine_R.value, MPFR_RNDN), mpz_get_si(rank_I.value), mpz_get_si(test_explicit_I.value), &result)
+        self.__find_zeros(count, start, max_refine, rank, message_stamp, &result)
         sig_off()
         returnvalue = []
         for i in range(result.size()):
@@ -390,7 +380,7 @@ cdef class Lfunction:
     cdef void __find_zeros_v(self,double T1, double T2, double stepsize, doublevec *result):
         raise NotImplementedError
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
         raise NotImplementedError
 
 ##############################################################################
@@ -486,8 +476,8 @@ cdef class Lfunction_I(Lfunction):
     cdef double __typedN(self, double T):
         return (<c_Lfunction_I *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_I *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_I *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     # debug tools
     def _print_data_to_standard_output(self):
@@ -624,8 +614,8 @@ cdef class Lfunction_D(Lfunction):
     cdef double __typedN(self, double T):
         return (<c_Lfunction_D *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_D *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start,double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_D *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     # debug tools
     def _print_data_to_standard_output(self):
@@ -769,8 +759,8 @@ cdef class Lfunction_C:
     cdef double __typedN(self, double T):
         return (<c_Lfunction_C *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_C *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_C *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     # debug tools
     def _print_data_to_standard_output(self):
@@ -854,8 +844,8 @@ cdef class Lfunction_Zeta(Lfunction):
     cdef double __typedN(self, double T):
         return (<c_Lfunction_Zeta *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_Zeta *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_Zeta *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     def __dealloc__(self):
         """
```


6. Some tests need tolerance updates because the answers have changed slightly.

7. Two tests give different answers entirely and require help from someone who knows what an L-function is. These are discussed on #24820 as well:


```
**********************************************************************
File "src/sage/libs/lcalc/lcalc_Lfunction.pyx", line 194, in sage.libs.lcalc.lcalc_Lfunction.Lfunction.hardy_z_function
Failed example:
    L.hardy_z_function(.4+.3*I)
Expected:
    0.2166144222685... - 0.00408187127850...*I
Got:
    0.0240947990422036 + 0.215308871779581*I
**********************************************************************
File "src/sage/libs/lcalc/lcalc_Lfunction.pyx", line 350, in sage.libs.lcalc.lcalc_Lfunction.Lfunction.find_zeros_via_N
Failed example:
    L.find_zeros_via_N(3)
Expected:
    [6.18357819545..., 8.45722917442..., 12.6749464170...]
Got:
    [-4.13290370521286, 6.18357819545086, 8.45722917442320]
**********************************************************************
```



---

Comment by mkoeppe created at 2021-06-23 05:23:48

Uh, a branch please?


---

Comment by dimpase created at 2021-06-23 08:30:39

John, L-functions question here...


---

Comment by chapoton created at 2021-06-23 10:20:26

For the first doctest, the PARI implementation (only available for real input) gives a different answer at 0:

```
sage: chi = DirichletGroup(5)[2]                                                
sage: chi.lfunction().hardy(0)                                                  
0.793597201093544
```


***EDIT***

but Pari doc of "lfunhardy" says this gives a "Variant of the Hardy Z-function"


---

Comment by chapoton created at 2021-06-23 11:21:27

For the second doctest, the values are indeed zeroes, according to pari :

```
sage: chi = DirichletGroup(5)[1]                                               
sage: f = chi.lfunction() 
sage: f(1/2+6.18357819545086*I)                                                 
2.61452836816118e-15 + 6.48370608217824e-15*I
sage: f(1/2+8.45722917442320*I)                                                 
3.51419504210656e-14 - 3.69407271406328e-14*I
sage: f(1/2-4.13290370521286*I)       
-4.69010768657543e-15 - 8.53389710587884e-15*I
```



***EDIT***

But that doc says that "L.find_zeros_via_N(3)" is supposed to find 3 zeroes, ignoring negative ones !


---

Comment by mjo created at 2021-06-23 23:55:43

Replying to [comment:1 mkoeppe]:
> Uh, a branch please?

I hacked together the minimal changes needed to get this to compile (bonus: it doesn't crash), but all of the patches in the description should be viewed with great suspicion. It will take some more time to sort out the right things to do here.


---

Comment by mjo created at 2021-06-24 00:06:23

Replying to [comment:5 chapoton]:
> ***EDIT***
> 
> But that doc says that "L.find_zeros_via_N(3)" is supposed to find 3 zeroes, ignoring negative ones !

There used to be a parameter called `do_negative` that made it look for zeros with a negative imaginary part, but the new libLfunction computes `do_negative` on its own:


```C++
bool do_negative=is_complex();
...
template <class ttype>
bool L_function <ttype>::
is_complex(){

    if(my_verbose>2) cout << "#            start is_complex()" << endl;

    bool do_negative=false;

    int n=0;
    if(what_type_L!=-1) //if not the zeta function, check if self dual. If so, do_negative stays false                                                     
    do{
        n++;
        if(abs(imag(Complex(dirichlet_coefficient[n])))>.00001){
            do_negative=true;
	    if(my_verbose>2) cout << "#            is_complex: Dirichlet co\
eff " << n << " " << setprecision(DIGITS) << dirichlet_coefficient[n] << endl;
        }
	}while(n<number_of_dirichlet_coefficients&&!do_negative);
    if(my_verbose>2) cout << "#            is_complex() = " << do_negative<\
< endl;

    return do_negative;

}
```


So maybe it's just the documentation that needs to be updated. I don't know what self-dual means, or what it's ultimately checking to make that decision in this case.


---

Comment by @DaveWitteMorris created at 2021-06-24 02:26:09

FWIW, here is my reading of this code: If all of the coefficients of the Dirichlet series are real (up to a tolerance of `.00001`), then the conjugate of any root is also a root.  (This is what "self-dual" must mean.) We do not need to look for roots below the real axis in this case (because they are conjugates of roots that are above the real axis), so `do_negative` is set to `False`. Otherwise, `do_negative` is set to `True`.

Replying to [comment:7 mjo]:
> Replying to [comment:5 chapoton]:
> ...
> So maybe it's just the documentation that needs to be updated. I don't know what self-dual means, or what it's ultimately checking to make that decision in this case.


---

Comment by chapoton created at 2021-06-24 07:18:18

here is a first branch, just changing version, checksums and lcalc_sage.h
----
New commits:


---

Comment by chapoton created at 2021-06-24 07:20:55

should we remove all the old patches ?


---

Comment by mjo created at 2021-06-24 12:28:50

Replying to [comment:10 chapoton]:
> should we remove all the old patches ?

Yep, all patches are obsolete. The spkg-install.in should now be,


```
sdh_configure --with-pari
sdh_make_install
```


and we can add an spkg-check.in containing,


```
sdh_make_check
```



---

Comment by git created at 2021-06-24 15:07:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-24 15:10:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-24 16:32:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2021-06-24 17:52:15

should we "cd src" in spkg-install ?

I have not managed to install so far with the current branch, "sage -i lcalc" complains as follows

```
[lcalc-2.0.0] Uninstalling 'lcalc' with legacy uninstaller
[lcalc-2.0.0] Package 'lcalc' is currently not installed
[lcalc-2.0.0] Now building lcalc, example programs and the shared library...
[lcalc-2.0.0] Building lcalc-2.0.0
[lcalc-2.0.0] make[3]: *** No targets specified and no makefile found.  Stop.
```



---

Comment by @DaveWitteMorris created at 2021-06-24 18:40:29

I don't understand anything about the build system, so it's likely that this is noise (in which case I apologize), but [dimpase says](https://groups.google.com/g/sage-devel/c/euE9MJnfjAo/m/XOB7X1TxBQAJ) not to use "sage -i":

```
we are trying to switch to a sane building scheme:

./bootstrap
./configure
make build
make pynormaliz

sage -i is an old hack noone should use...
```

So maybe you are supposed to try "make lcalc" ?


---

Comment by mkoeppe created at 2021-06-24 18:43:14

Replying to [comment:15 chapoton]:
> should we "cd src" in spkg-install ?
yes


---

Comment by git created at 2021-06-24 22:26:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by slelievre created at 2021-06-24 23:13:49

Should .m4 files mix tabs and spaces?


---

Comment by git created at 2021-06-24 23:16:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2021-06-24 23:18:31

Replying to [comment:19 slelievre]:
> Should .m4 files mix tabs and spaces?

According to me, no. According to emacs, at every opportunity.


---

Comment by chapoton created at 2021-06-25 09:31:10

Using "make lcalc", I am still not able to build, with or without "cd src".

Complains of missing makefile, as in comment:17


---

Comment by mjo created at 2021-06-25 14:40:05

Replying to [comment:22 chapoton]:
> Using "make lcalc", I am still not able to build, with or without "cd src".
> 
> Complains of missing makefile, as in comment:17

I think you have to get rid of `spkg-build.in`, too.


---

Comment by git created at 2021-06-25 15:49:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2021-06-25 15:50:22

ok, now "make lcalc" starts doing something and stops at

```
[lcalc-2.0.0] Thread model: posix
[lcalc-2.0.0] gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) 
...
[lcalc-2.0.0] checking for gengetopt... no
[lcalc-2.0.0] configure: error: GNU gengetopt is required
```



---

Comment by mjo created at 2021-06-25 17:15:36

Well the good news is that it's supposed to do that, but the bad news is that we'll have to add another gengetopt SPKG for lcalc to depend on.


---

Comment by mjo created at 2021-06-25 18:09:23

I posted a branch for review on #32061 to add the missing dependency.


---

Comment by mjo created at 2021-06-26 00:14:57

I figured out how to fix the build scripts... and then found a typo in the upstream configure.ac that I had to release a 2.0.1 to fix. I think this will actually work now.


---

Comment by mjo created at 2021-06-26 00:18:31

Replying to [comment:8 gh-DaveWitteMorris]:
> FWIW, here is my reading of this code: If all of the coefficients of the Dirichlet series are real (up to a tolerance of `.00001`), then the conjugate of any root is also a root.  (This is what "self-dual" must mean.) We do not need to look for roots below the real axis in this case (because they are conjugates of roots that are above the real axis), so `do_negative` is set to `False`. Otherwise, `do_negative` is set to `True`.

These functions are supposed to "return the first `n` zeros." That's vague, but scrutable if you're starting from the real axis and moving up: basically, the numbers (imaginary parts) it outputs get bigger. I guess when `do_negative` is true, we output the first `n` zeros in _magnitude_?


---

Comment by git created at 2021-06-26 13:07:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2021-06-28 02:52:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DaveWitteMorris created at 2021-06-29 00:59:08

Replying to [comment:29 mjo]:
> Replying to [comment:8 gh-DaveWitteMorris]:
>> ... I guess when `do_negative` is true, we output the first `n` zeros in _magnitude_?

Yes, I'm pretty sure that is correct. For example, a comment introducing the `find_zeros` function says "Finds zeros of L(1/2+It) or of L(1/2+It)*L(1/2-It) (depending on whether self dual or not)". (The second form will combine the zeros with negative imaginary into the ones with positive imaginary part.) And a comment in the code of the function says "in the self dual case we only count half the zeros with |t|<T".


---

Comment by git created at 2021-07-01 19:01:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-02 23:08:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-03 12:13:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-03 12:43:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-03 12:44:22

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2021-07-03 12:46:55

Changing status from new to needs_review.


---

Comment by mjo created at 2021-07-03 12:46:55

I've fixed all of the problems I know about, and deleted the one remaining failing doctest that no one knows what to do with. Pending a ptestlong, I think it's ready for a serious look.


---

Comment by @DaveWitteMorris created at 2021-07-03 18:28:09

The branch is red. Is there a merge conflict?


---

Comment by mjo created at 2021-07-03 18:32:18

Replying to [comment:41 gh-DaveWitteMorris]:
> The branch is red. Is there a merge conflict?

Probably the gcc-11 patch that was added for the lcalc SPKG before sage-9.4. I can rebase after my ptestlong finishes.


---

Comment by git created at 2021-07-03 21:28:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-03 21:42:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by arojas created at 2021-07-04 08:34:48

Changing status from needs_review to needs_work.


---

Comment by arojas created at 2021-07-04 08:34:48

Doesn't merge cleanly on current develop, please rebase


---

Comment by git created at 2021-07-04 12:24:32

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2021-07-04 12:26:48

should be ok now


---

Comment by arojas created at 2021-07-04 13:13:13

This breaks build of sagelib with GCC 11, which worked fine with 1.23 (will all patches on top)


```
In file included from /usr/include/lcalc/Lglobals.h:70,
                 from /usr/include/lcalc/L.h:43,
                 from build/cythonized/sage/libs/lcalc/lcalc_sage.h:1,
                 from build/cythonized/sage/libs/lcalc/lcalc_Lfunction.cpp:676:
/usr/include/c++/11.1.0/limits: In static member function ‘static constexpr double std::numeric_limits<double>::min()’:
/usr/include/c++/11.1.0/limits:1748:44: error: call to non-‘constexpr’ function ‘double lcalc_to_double(const long double&)’
 1748 |       min() _GLIBCXX_USE_NOEXCEPT { return __DBL_MIN__; }
      |                                            ^~~~~~~~~~~
/usr/include/lcalc/Lcommon.h:35:15: note: ‘double lcalc_to_double(const long double&)’ declared here
   35 | inline double lcalc_to_double(const long double& x) { return x; }
      |               ^~~~~~~~~~~~~~~
```



---

Comment by mjo created at 2021-07-04 13:40:52

Ok, thanks, I'll have to investigate after the holiday (it would take more than a day to build gcc-11 on my laptop). The absence of `constexpr` in lcalc is "correct," since lcalc can use MPFR for its double type and the MPFR type is not a constexpr.


---

Comment by dimpase created at 2021-07-04 16:21:39

we can add archlinux, or some other way to get gcc 11, on  lcalc CI.

https://stackoverflow.com/a/67406788/557937


we can make a macro expanding to constexpr or to "", and set it up at configure time.


---

Comment by mjo created at 2021-07-05 13:05:10

I'm still not 100% sure what's going on, but this is a `-std=c++11` problem and not a gcc-11 problem. If you let gcc-11 pick the standard, everything works. But if you specify `-std=c++11`, then even the following trivial program will fail,


```C
#include <lcalc/L.h>
```


The errors suggest that somehow `lcalc_to_double()` from lcalc is being invoked in the C++ standard library's `min()` function that's just trying to return a constant:


```
In file included from /usr/include/lcalc/Lglobals.h:70,
                 from /usr/include/lcalc/L.h:43,
                 from conftest.cpp:1:
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include/g++-v11/limits: In static member function 'static constexpr double std::numeric_limits<double>::min()':
/usr/lib/gcc/x86_64-pc-linux-gnu/11.1.0/include/g++-v11/limits:1748:44: error: call to non-'constexpr' function 'double lcalc_to_double(const long double&)'
 1748 |       min() _GLIBCXX_USE_NOEXCEPT { return __DBL_MIN__; }
```



---

Comment by git created at 2021-07-05 14:52:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2021-07-05 14:54:49

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2021-07-05 14:54:49

There was a recent change that started adding `-std=gnu++11` to our `CXXFLAGS` and broke lcalc. I released lcalc-2.0.2 which should work again.


---

Comment by arojas created at 2021-07-05 15:17:31

I confirm sagelib builds fine again with GCC 11


---

Comment by dimpase created at 2021-07-05 15:52:48

what change was adding the -std=gnu++11 ?

it is certainly important that all the Sage  C++ libs are compatible wrt to C++ ABI.


---

Comment by mkoeppe created at 2021-07-05 16:59:51

I haven't followed the discussion on the ticket, but if a specific C++ standard is needed to use the headers, then it is best to declare it in the `.pxd` file using `distutils: extra_compile_args=-std=c++11`.

`sage_setup.command.sage_build_cython` does set this as a default - but I consider this only legacy behavior of our homegrown build system for sagelib. 

It will have to be tested with `./configure --enable-editable`, which switches the sagelib build to a simpler build system.


---

Comment by mjo created at 2021-07-06 15:47:20

Replying to [comment:55 dimpase]:
> what change was adding the -std=gnu++11 ?

The switch to c++11 is actually pretty old (see e.g. 370c03505f290f). What must have changed is that `-std=gnu++11` started being added earlier in the build process, before we try to detect lcalc (I know _something_ changed because detecting lcalc-2.0.1 used to work before I rebased onto develop). Regardless, adding the flag early is the right thing to do if we're ultimately going to be compiling code against these libraries with `-std=gnu++11` in `CXXFLAGS`.

For me now, that flag gets added while detecting GCC.


---

Comment by mjo created at 2021-07-06 15:48:05

Replying to [comment:56 mkoeppe]:
> I haven't followed the discussion on the ticket, but if a specific C++ standard is needed to use the headers, then it is best to declare it in the `.pxd` file using `distutils: extra_compile_args=-std=c++11`.

No special flags are needed. The latest lcalc-2.0.2 will work with any of the 11, 14, or 17 standards.


---

Comment by arojas created at 2021-07-07 06:14:40

With my distro packages, getting one test failure only

```
File "/usr/lib/python3.9/site-packages/sage/lfunctions/zero_sums.pyx", line 832, in sage.lfunctions.zero_sums.LFunctionZeroSum_abstract._zerosum_cauchy
Failed example:
    E.lseries().zeros(2)
Expected:
    [6.36261389, 8.60353962]
Got:
    [6.36261390, 8.60353962]
**********************************************************************
```



---

Comment by git created at 2021-07-07 11:57:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2021-07-07 22:50:26

tests run on https://github.com/sagemath/sagetrac-mirror/actions/runs/1009717554


---

Comment by git created at 2021-07-13 18:48:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2021-07-13 18:50:48

I accidentally broke the soname in the last version, so here's v2.0.3 to fix it. Also rebased onto the latest gengetopt branch.


---

Comment by git created at 2021-07-19 12:15:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by arojas created at 2021-10-29 06:24:38

Changing status from needs_review to positive_review.


---

Comment by arojas created at 2021-10-29 06:24:38

I've been shipping this downstream for 3 months without issues


---

Comment by mkoeppe created at 2021-10-29 06:32:28

Ticket description should be cleaned up


---

Comment by slelievre created at 2021-10-29 15:18:17

I tried to reduce the ticket description to a digest.

Not sure what the conclusion was on item 7, so I left that out.

The ticket description from before my edit is reproduced below.

-----

I've just tagged a 2.0.3 release of lcalc: https://gitlab.com/sagemath/lcalc/-/tags/2.0.3

There are a few issues that need to be addressed during the upgrade.

0. The build requires GNU gengetopt, so we'll need a new gengetopt SPKG for lcalc to depend on. (It doesn't need to go in the DEPCHECK macro though, since it's a build-only dependency.)
1. The build system is now sane. This should make life easier in the long run, but means that spkg-* need to be rewritten. `./configure --with-pari` should suffice.

2. The lcalc spkg shouldn't depend on mpfr (I'm not sure why it ever did).

3. spkg-configure.m4 should be modified to find the new version, for example...


```patch
diff --git a/build/pkgs/lcalc/spkg-configure.m4 b/build/pkgs/lcalc/spkg-configure.m4
index 19a87c8d30..b332294eae 100644
--- a/build/pkgs/lcalc/spkg-configure.m4
+++ b/build/pkgs/lcalc/spkg-configure.m4
@@ -1,20 +1,20 @@
 SAGE_SPKG_CONFIGURE([lcalc], [
-    m4_pushdef([SAGE_LCALC_MINVER],["1.22"])
-    SAGE_SPKG_DEPCHECK([pari mpfr], [
+    m4_pushdef([SAGE_LCALC_MINVER],["2.0.0"])
+    SAGE_SPKG_DEPCHECK([pari], [
         AC_PATH_PROG([LCALC], [lcalc])
         AS_IF([test x$LCALC = x], [
            AC_MSG_NOTICE([lcalc not found. Installing lcalc])
            sage_spkg_install_lcalc=yes], [
            AC_MSG_CHECKING([is lcalc's version good enough? ])
-           lcalc_ver=`$LCALC --version 2>>/dev/null | $SED -e 's/lcalc\ //' | $SED -e 's/\ .*//g'`
+           lcalc_ver=$($LCALC --version 2>>/dev/null | $SED -e 's/lcalc\ //' | cut -d' ' -f2)
            AX_COMPARE_VERSION([$lcalc_ver], [ge], [$SAGE_LCALC_MINVER], [
                AC_MSG_RESULT([yes.])
-               AC_CHECK_HEADER([Lfunction/L.h], [], [sage_spkg_install_lcalc=yes])
+               AC_CHECK_HEADER([lcalc/L.h], [], [sage_spkg_install_lcalc=yes])
           AC_MSG_CHECKING([whether we can link and run a program using libLfunction])
           LCALC_SAVED_LIBS=$LIBS
           LIBS="$LIBS -lLfunction"
           AC_RUN_IFELSE([
-            AC_LANG_PROGRAM([[#include <Lfunction/L.h>]],
+            AC_LANG_PROGRAM([[#include <lcalc/L.h>]],
                       [[initialize_globals();
                         Complex x;
                         x = Pi*I;
```


However, lcalc-2.0.0 comes with a pkg-config file, so we could greatly simplify that.

4. The public API header has moved to `lcalc/L.h`:


```patch
diff --git a/src/sage/libs/lcalc/lcalc_sage.h b/src/sage/libs/lcalc/lcalc_sage.h
index 498528917f..18e5232cbe 100644
--- a/src/sage/libs/lcalc/lcalc_sage.h
+++ b/src/sage/libs/lcalc/lcalc_sage.h
@@ -1,4 +1,4 @@
-#include "Lfunction/L.h"
+#include "lcalc/L.h"
 int *new_ints(int l)
 {
     return new int[l];

```


5. The `find_zeros_via_N_v()` function was removed, and replaced by `find_zeros()`. Here's a patch:


```patch
diff --git a/src/sage/libs/lcalc/lcalc_Lfunction.pxd b/src/sage/libs/lcalc/lcalc_Lfunction.pxd
index d1dbb5d95d..5edf0844f3 100644
--- a/src/sage/libs/lcalc/lcalc_Lfunction.pxd
+++ b/src/sage/libs/lcalc/lcalc_Lfunction.pxd
@@ -21,7 +21,7 @@ cdef extern from "lcalc_sage.h":
         int (* compute_rank) ()
         double (* N) (double T)
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*print_data_L)()
 
         #Constructor and destructor
@@ -38,7 +38,7 @@ cdef extern from "lcalc_sage.h":
         double (* N) (double T)
         double *dirichlet_coefficient
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*print_data_L)()
 
         #Constructor and destructor
@@ -54,7 +54,7 @@ cdef extern from "lcalc_sage.h":
         int (* compute_rank) ()
         double (* N) (double T)
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*print_data_L)()
 
         #Constructor and destructor
@@ -70,7 +70,7 @@ cdef extern from "lcalc_sage.h":
         int (* compute_rank) ()
         double (* N) (double T)
         void  (* find_zeros_v)(double T1, double T2, double stepsize, doublevec result )
-        void (*find_zeros_via_N_v)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec result)#puts result in vector<double> result
+        int (*find_zeros)(long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
         void (*find_zeros_via_N)(long count,int do_negative,double max_refine, int rank, int test_explicit_formula, char *filename) #puts result in filename
 
         #Constructor and destructor
@@ -111,7 +111,7 @@ cdef class Lfunction:
     #strange bug, replacing Double with double gives me a compile error
     cdef Double __typedN(self, double T)
     cdef void __find_zeros_v(self, double T1, double T2, double stepsize,doublevec *result)
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula,doublevec *result)
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec* result)
 
     cdef str _repr

```



```patch
diff --git a/src/sage/libs/lcalc/lcalc_Lfunction.pyx b/src/sage/libs/lcalc/lcalc_Lfunction.pyx
index 7e54d7e78d..409987c5d0 100644
--- a/src/sage/libs/lcalc/lcalc_Lfunction.pyx
+++ b/src/sage/libs/lcalc/lcalc_Lfunction.pyx
@@ -307,8 +307,7 @@ cdef class Lfunction:
         return returnvalue
 
     #The default values are from L.h. See L.h
-    def find_zeros_via_N(self, count=0, do_negative=False, max_refine=1025,
-                         rank=-1, test_explicit_formula=0):
+    def find_zeros_via_N(self, count=0, start=0, max_refine=1025, rank=-1):
         """
         Finds ``count`` number of zeros with positive imaginary part
         starting at real axis. This function also verifies that all
@@ -317,8 +316,7 @@ cdef class Lfunction:
         INPUT:
 
         - ``count`` - number of zeros to be found
-        - ``do_negative`` - (default: False) False to ignore zeros below the
-          real axis.
+        - ``start`` - (default: 0) how many initial zeros to skip
         - ``max_refine`` - when some zeros are found to be missing, the step
           size used to find zeros is refined. max_refine gives an upper limit
           on when lcalc should give up. Use default value unless you know
@@ -326,13 +324,9 @@ cdef class Lfunction:
         - ``rank`` - integer (default: -1) analytic rank of the L-function.
           If -1 is passed, then we attempt to compute it. (Use default if in
           doubt)
-        - ``test_explicit_formula`` - integer (default: 0) If nonzero, test
-          the explicit formula for additional confidence that all the zeros
-          have been found and are accurate. This is still being tested, so
-          using the default is recommended.
 
         OUTPUT:
-        
+
         list -- A list of the imaginary parts of the zeros that have been found
 
         EXAMPLES::
@@ -356,14 +350,10 @@ cdef class Lfunction:
             sage: L.find_zeros_via_N(3)
             [14.1347251417..., 21.0220396387..., 25.0108575801...]
         """
-        cdef Integer count_I = Integer(count)
-        cdef Integer do_negative_I = Integer(do_negative)
-        cdef RealNumber max_refine_R = RRR(max_refine)
-        cdef Integer rank_I = Integer(rank)
-        cdef Integer test_explicit_I = Integer(test_explicit_formula)
+        cdef const char *message_stamp = ""
         cdef doublevec result
         sig_on()
-        self.__find_zeros_via_N_v(mpz_get_si(count_I.value), mpz_get_si(do_negative_I.value), mpfr_get_d(max_refine_R.value, MPFR_RNDN), mpz_get_si(rank_I.value), mpz_get_si(test_explicit_I.value), &result)
+        self.__find_zeros(count, start, max_refine, rank, message_stamp, &result)
         sig_off()
         returnvalue = []
         for i in range(result.size()):
@@ -390,7 +380,7 @@ cdef class Lfunction:
     cdef void __find_zeros_v(self,double T1, double T2, double stepsize, doublevec *result):
         raise NotImplementedError
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
         raise NotImplementedError
 
 ##############################################################################
@@ -486,8 +476,8 @@ cdef class Lfunction_I(Lfunction):
     cdef double __typedN(self, double T):
         return (<c_Lfunction_I *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_I *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_I *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     # debug tools
     def _print_data_to_standard_output(self):
@@ -624,8 +614,8 @@ cdef class Lfunction_D(Lfunction):
     cdef double __typedN(self, double T):
         return (<c_Lfunction_D *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_D *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start,double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_D *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     # debug tools
     def _print_data_to_standard_output(self):
@@ -769,8 +759,8 @@ cdef class Lfunction_C:
     cdef double __typedN(self, double T):
         return (<c_Lfunction_C *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_C *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_C *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     # debug tools
     def _print_data_to_standard_output(self):
@@ -854,8 +844,8 @@ cdef class Lfunction_Zeta(Lfunction):
     cdef double __typedN(self, double T):
         return (<c_Lfunction_Zeta *>self.thisptr).N(T)
 
-    cdef void __find_zeros_via_N_v(self, long count,int do_negative,double max_refine, int rank, int test_explicit_formula, doublevec *result):
-        (<c_Lfunction_Zeta *>self.thisptr).find_zeros_via_N_v(count, do_negative, max_refine, rank, test_explicit_formula, result[0])
+    cdef int __find_zeros(self, long count, long start, double max_refine, int rank, const char* message_stamp, doublevec *result):
+        (<c_Lfunction_Zeta *>self.thisptr).find_zeros(count, start, max_refine, rank, message_stamp, result)
 
     def __dealloc__(self):
         """
```


6. Some tests need tolerance updates because the answers have changed slightly.

7. Two tests give different answers entirely and require help from someone who knows what an L-function is. These are discussed on #24820 as well:


```
**********************************************************************
File "src/sage/libs/lcalc/lcalc_Lfunction.pyx", line 194, in sage.libs.lcalc.lcalc_Lfunction.Lfunction.hardy_z_function
Failed example:
    L.hardy_z_function(.4+.3*I)
Expected:
    0.2166144222685... - 0.00408187127850...*I
Got:
    0.0240947990422036 + 0.215308871779581*I
**********************************************************************
File "src/sage/libs/lcalc/lcalc_Lfunction.pyx", line 350, in sage.libs.lcalc.lcalc_Lfunction.Lfunction.find_zeros_via_N
Failed example:
    L.find_zeros_via_N(3)
Expected:
    [6.18357819545..., 8.45722917442..., 12.6749464170...]
Got:
    [-4.13290370521286, 6.18357819545086, 8.45722917442320]
**********************************************************************
```



---

Comment by mjo created at 2021-10-29 17:49:22

Replying to [comment:69 slelievre]:
> I tried to reduce the ticket description to a digest.
> 
> Not sure what the conclusion was on item 7, so I left that out.
> 

Thanks. One of those doctests was updated for the new output, an expected change now that the API automatically determines that the L-function is complex:

https://git.sagemath.org/sage.git/commit/?h=8d1221a4

The other was ultimately deleted, because no one can explain either the old or new output:

https://git.sagemath.org/sage.git/commit/?h=b642382d

> add gengetopt as a new standard SPKG 

This is actually still open as a dependency in #32061.

(Edit: link to the correct commits.)


---

Comment by dimpase created at 2021-11-01 13:02:47

should be good to go now.


---

Comment by mkoeppe created at 2021-11-06 23:24:17

Needs to be rebased on top of #31837, which brings a patch that does not apply to the new version


---

Comment by mkoeppe created at 2021-11-06 23:24:17

Changing status from positive_review to needs_work.


---

Comment by mkoeppe created at 2021-11-06 23:25:40

... as seen in https://github.com/mkoeppe/sage/runs/4127380314?check_suite_focus=true


---

Comment by git created at 2021-11-07 13:28:43

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2021-11-07 13:30:54

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2021-11-07 13:30:54

Rebased cleanly onto develop, and added one additional commit to remove the new patch.


---

Comment by chapoton created at 2021-11-14 09:13:50

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2021-11-14 09:13:50

red branch => needs work


---

Comment by git created at 2021-11-14 20:00:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2021-11-14 20:01:30

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2021-11-14 20:01:30

Not sure why, it merged cleanly with beta6 for me. Here it is again rebased onto develop.


---

Comment by dimpase created at 2021-11-16 14:45:49

lgtm


---

Comment by dimpase created at 2021-11-16 14:45:49

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-11-20 10:46:08

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2021-11-20 10:46:08


```
Using cached file /home/release/Sage/upstream/lcalc-2.0.1.tar.xz
lcalc-2.0.1
====================================================
Setting up build directory for lcalc-2.0.1
Finished extraction
Applying patches from ../patches...
Applying ../patches/lcalc-1.23-gcc11.patch
can't find file to patch at input line 5
Perhaps you used the wrong -p or --strip option?
The text leading up to this was:
--------------------------
--------------------------
File to patch: 
Skip this patch? [y] 
Skipping patch.
2 out of 2 hunks ignored
Error applying '../patches/lcalc-1.23-gcc11.patch'
************************************************************************
Error applying patches
************************************************************************
```



---

Comment by git created at 2021-11-20 12:38:19

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2021-11-20 12:40:52

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2021-11-23 21:34:00

stil same error?


---

Comment by vbraun created at 2021-11-23 21:34:00

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2021-11-23 21:35:56

nevermind...


---

Comment by vbraun created at 2021-11-23 21:35:56

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2021-11-25 00:22:01

On Debian 9 x86_64:

```
**********************************************************************
File "src/sage/libs/lcalc/lcalc_Lfunction.pyx", line 194, in sage.libs.lcalc.lcalc_Lfunction.Lfunction.hardy_z_function
Failed example:
    L.hardy_z_function(0) # abs tol 1e-8
Expected:
    0.793967590477 + 0.0*I
Got:
    0.793967590477090
**********************************************************************
1 item had failures:
   1 of  14 in sage.libs.lcalc.lcalc_Lfunction.Lfunction.hardy_z_function
    [105 tests, 1 failure, 0.76 s]
----------------------------------------------------------------------
sage -t --long --random-seed=234205826713938282410851315937822845647 src/sage/libs/lcalc/lcalc_Lfunction.pyx  # 1 doctest failed
----------------------------------------------------------------------
```

on OSX Big Sur:

```
In file included from ../../src/libLfunction/L.h:43:
In file included from ../../src/libLfunction/Lglobals.h:55:
../../src/libLfunction/Lcomplex.h:48:10: fatal error: 'bits/c++config.h' file not found
#include <bits/c++config.h>
         ^~~~~~~~~~~~~~~~~~
1 error generated.
make[6]: *** [Lcommandline.o] Error 1
make[6]: Target `all' not remade because of errors.
Making all in tests
Making all in lib
make[7]: Nothing to be done for `all'.
make[7]: Nothing to be done for `all-am'.
make[6]: Nothing to be done for `all-am'.
make[5]: *** [all-recursive] Error 1
make[5]: Target `all' not remade because of errors.
********************************************************************************
Error building lcalc-2.0.3
********************************************************************************
```



---

Comment by vbraun created at 2021-11-25 00:22:01

Changing status from positive_review to needs_work.


---

Comment by mjo created at 2021-11-25 02:06:15

Replying to [comment:85 vbraun]:
> On Debian 9 x86_64:
> {{{
> **********************************************************************
> File "src/sage/libs/lcalc/lcalc_Lfunction.pyx", line 194, in sage.libs.lcalc.lcalc_Lfunction.Lfunction.hardy_z_function
> Failed example:
>     L.hardy_z_function(0) # abs tol 1e-8
> Expected:
>     0.793967590477 + 0.0*I
> Got:
>     0.793967590477090
> **********************************************************************

Well... all of these `abs_tol` tests involving complex numbers are wrong. I was naively assuming that our doctest framework would do the obvious thing here, but it's using regexps to find strings that look like floating point numbers and then e.g. deciding that the lists `["0.793967590477", " + 0.0"]` and  `["0.793967590477090"]` cannot be equivalent because they are of different lengths.

I'll redo all of the tests to compare the real and imaginary parts separately I guess.

> on OSX Big Sur:
> {{{
> In file included from ../../src/libLfunction/L.h:43:
> In file included from ../../src/libLfunction/Lglobals.h:55:
> ../../src/libLfunction/Lcomplex.h:48:10: fatal error: 'bits/c++config.h' file not found
> #include <bits/c++config.h>
>          ^~~~~~~~~~~~~~~~~~
> }}}

I don't know what to do about this. That's a standard C++ header, and I don't have access to OSX to debug. The full build log _might_ help, if something is very obviously wrong.


---

Comment by fbissey created at 2021-11-25 03:14:07

Seen that kind of stuff before when porting to clang. I don't think anything in `bits` should be included directly because they are implementation specific functions. Would have to check what exactly was needed from there.

From the file itself

```
/** @file bits/c++config.h
  *  This is an internal header file, included by other library headers.
  *  Do not attempt to use it directly. @headername{iosfwd}
  */
```



---

Comment by fbissey created at 2021-11-25 09:19:10

For gcc, this particular header is included in `<cmath>` which is also included later. So, I'd recommend removing that include altogether.


---

Comment by git created at 2021-11-25 16:29:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2021-11-25 16:51:30

Replying to [comment:88 fbissey]:
> For gcc, this particular header is included in `<cmath>` which is also included later. So, I'd recommend removing that include altogether.

This works well with both clang and gcc on linux... but can anyone confirm that it works on OSX before I make a whole new release and upgrade again?


---

Comment by mkoeppe created at 2021-11-25 18:25:20

If the repo was on GH, I'd send you a PR for portability/integration testing.

Looks like GitLab is also starting to provide macOS testing? https://docs.gitlab.com/ee/ci/runners/saas/macos_saas_runner.html


---

Comment by fbissey created at 2021-11-25 18:47:46

Replying to [comment:90 mjo]:
> Replying to [comment:88 fbissey]:
> > For gcc, this particular header is included in `<cmath>` which is also included later. So, I'd recommend removing that include altogether.
> 
> This works well with both clang and gcc on linux... but can anyone confirm that it works on OSX before I make a whole new release and upgrade again?

Could have mentioned that. But clang on linux is not a good test unless you build clang's libstdc++ and make use of it. However, if you do it almost a sure deal. But I couldn't test on mac os because I am not properly set and was missing dependencies.


---

Comment by dimpase created at 2021-11-25 19:46:43

clang's C++ library is libc++, not libstdc++

I'll try checking on macOS 12 now.


---

Comment by dimpase created at 2021-11-25 20:08:44


```
libtool: compile:  clang++ -std=gnu++11 -DHAVE_CONFIG_H -I. -I../../src -g -O2 -c Lriemannsiegel.cc  -fno-common -DPIC -o .libs/Lriemannsiegel.o
In file included from Lmisc.cc:24:
In file included from ./Lmisc.h:27:
In file included from ./Lglobals.h:55:
./Lcomplex.h:48:10: fatal error: 'bits/c++config.h' file not found
In file included from Lgamma.cc:24:
In file included from ./Lgamma.h:#include <bits/c++config.h>
         ^~~~~~~~~~~~~~~~~~
28:
In file included from ./Lglobals.h:55:
./Lcomplex.h:48:10: fatal error: 'bits/c++config.h' file not found
#include <bits/c++config.h>
         ^~~~~~~~~~~~~~~~~~
In file included from Lglobals.cc:24:
In file included from ./Lglobals.h:55:
./Lcomplex.h:48:10: fatal error: 'bits/c++config.h' file not found
#include <bits/c++config.h>
         ^~~~~~~~~~~~~~~~~~
1 error generated.
In file included from Lnumbertheory.cc:24:
In file included from ./Lnumbertheory.h:32:
In file included from ./Lglobals.h:55:
./Lcomplex.h:48:10: fatal error: 'bits/c++config.h' file not found
#include <bits/c++config.h>
         ^~~~~~~~~~~~~~~~~~
make[6]: *** [Lmisc.lo] Error 1
make[6]: *** Waiting for unfinished jobs....
```


removing the offending #include, i.e.


```diff
diff --git a/src/libLfunction/Lcomplex.h b/src/libLfunction/Lcomplex.h
index 639dbfa..be29aab 100644
--- a/src/libLfunction/Lcomplex.h
+++ b/src/libLfunction/Lcomplex.h
@@ -45,7 +45,7 @@
 
 #pragma GCC system_header
 
-#include <bits/c++config.h>
+// #include <bits/c++config.h>
 
 //no longer include:
 //#include <bits/cpp_type_traits.h>  only thing used was is_floating... 
```


makes it build


---

Comment by mjo created at 2021-11-25 20:35:12

Thanks, release/upgrade incoming.


---

Comment by mjo created at 2021-11-25 21:03:28

Replying to [comment:92 fbissey]:
> 
> Could have mentioned that. But clang on linux is not a good test unless you build clang's libstdc++ and make use of it.

Argh, TIL about `USE=default-libcxx` on sys-devel/clang.


---

Comment by git created at 2021-11-26 00:45:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2021-11-26 00:47:08

Certain (non-sage) builds were failing with newer clangs anyway so I guess this was timely.


---

Comment by mjo created at 2021-11-26 00:47:08

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2021-11-27 18:59:58

maybe you can drop all the `register` things, as

```
 warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register]
```

is all over there on macOS.


---

Comment by dimpase created at 2021-11-27 21:00:05

lgtm, otherwise


---

Comment by mjo created at 2021-11-28 23:31:40

Replying to [comment:99 dimpase]:
> maybe you can drop all the `register` things, as
> {{{
>  warning: 'register' storage class specifier is deprecated and incompatible with C++17 [-Wdeprecated-register]
> }}}
> is all over there on macOS.

Are you sure this was with v2.0.4? I already fixed a warning like that, and there's no more _register_ in the lcalc repo.


---

Comment by dimpase created at 2021-11-29 00:10:19

Ah, these came from the included pari headers /usr/local/include/pari/pari.h.
All good.


---

Comment by dimpase created at 2021-11-29 00:10:19

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-12-12 15:08:56

Resolution: fixed


---

Comment by mkoeppe created at 2021-12-18 18:12:04

This broke cygwin: #33043
