# Issue 19593: Classification of finite and affine Coxeter groups

Issue created by migration from Trac.

Original creator: stumpc5

Original creation time: 2016-01-04 13:01:34

CC:  tscrim chapoton nthiery darij

Keywords: coxeter system, root system

The bug here is two-fold:

1. The roots for a `CoxeterGroup` are constructed as in Humphreys "in the Coxeter sense, that all have the same norm". Therefore it seems more natural to not at all introduce a type C and to follow Humphrey's classification of finite Coxeter groups given on page 32.

2. The current implementation of types B/C (which I suggest to remove and to only keep type B) is also broken:

* First Sage start

```
sage: W = CoxeterGroup(['B',4])
sage: W.coxeter_matrix().coxeter_type()
Coxeter type of ['B', 4]
sage: W = CoxeterGroup(['C',4])
sage: W.coxeter_matrix().coxeter_type()
Coxeter type of ['B', 4]
```

* Second Sage start

```
sage: W = CoxeterGroup(['C',4])
sage: W.coxeter_matrix().coxeter_type()
Coxeter type of ['C', 4]
sage: W = CoxeterGroup(['B',4])
sage: W.coxeter_matrix().coxeter_type()
Coxeter type of ['C', 4]
```



---

Comment by stumpc5 created at 2016-01-04 13:15:21

And what to do with

```
sage: CoxeterGroup(CoxeterType(['B',2],['B',2]).coxeter_matrix()).coxeter_matrix().coxeter_type()
Coxeter type of G2xG2 relabelled by {1: 3, 2: 4}
```



---

Comment by tscrim created at 2016-01-04 13:21:40

With `7.0.beta1`, I get:

```
sage: CoxeterGroup(CoxeterType(['B',2],['B',2]).coxeter_matrix()).coxeter_matrix().coxeter_type()
Coxeter type of B2xB2
```

What are you using when you tested that? Although, that you got that in any situation is very frightening to me.


---

Comment by stumpc5 created at 2016-01-04 14:29:55

Hm, after restarting with `7.0.beta2` I also get this result, and I wasn't able to reproduce the bug even after retyping all comments that seemed to be related. So let's leave this aside for now.


---

Comment by stumpc5 created at 2016-01-04 14:33:23

At some point during that session I accidentally copied almost the complete source of `subword_complex.py` into the terminal. So it might also be that this caused the issue, though I wouldn't know how.)


---

Comment by stumpc5 created at 2016-01-04 15:40:24

`@`tscrim: And what to do with

```
sage: sage: W = CoxeterGroup(['B',3],index_set=['A','b','XX'])
sage: sage: W.index_set()
(1, 2, 3)
```



---

Comment by stumpc5 created at 2016-01-05 15:12:28

Sorry for adding more and more questions here: The documentation of the method `roots` states 

```
These are roots in the Coxeter sense, that all have the
same norm. They are given by their coefficients in the
base of simple roots, also taken to have all the same
norm.
```

How is this true if the sum of the coefficients is not one? As in

```
sage: W = CoxeterGroup(['A',2])
sage: W.roots()
[(1, 0), (1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1)]
```



---

Comment by chapoton created at 2016-01-05 15:17:20

What ? Type A2 is simply laced, so the roots are just the roots in the Weyl sense..

The scalar product is the one that is invariant by the group, of course..


---

Comment by tscrim created at 2016-01-05 15:26:10

I am working on trying to fix the norm index set issue, which uncovered some other bugs/isues with the relabelling. I was somewhat inclined to say that passing a Coxeter (or Cartan) type and an index set was essentially double info, but after some more thought, I think it is a nice API to support.


---

Comment by stumpc5 created at 2016-01-05 15:30:39

`@`chapoton: My last comment on the root lengths was too quick, please forget about it and sorry for the noise!


---

Comment by nthiery created at 2016-01-05 20:51:12

Replying to [comment:6 stumpc5]:
> Sorry for adding more and more questions here: The documentation of the method `roots` states 
> {{{
> These are roots in the Coxeter sense, that all have the
> same norm. They are given by their coefficients in the
> base of simple roots, also taken to have all the same
> norm.
> }}}
> How is this true if the sum of the coefficients is not one? As in
> {{{
> sage: W = CoxeterGroup(['A',2])
> sage: W.roots()
> [(1, 0), (1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1)]
> }}}

Isn't this just that the basis of the simple roots is not orthonormal? So one can't read of the norm of vectors expressed there right away.


---

Comment by nthiery created at 2016-01-05 20:52:49

Oops, I was too quick and did not see your last comment :-)


---

Comment by tscrim created at 2016-01-30 01:20:01

Here is a fix for relabelling issues that I came across. Although I think this might be better on a separate ticket.

`@`darij the previous test for checking for relabelled types gave false negatives. Consider F<sub>4</sub> under cyclic shift and under interchanging 1 and 3. These are the _same_ type and our relabelling check does not distinguish between them (nor can any algorithm).

How do we want to handle Coxeter vs Dynkin classification of the affine types or the general case? I'm guessing for the affine types, we just use the untwisted types. Do we even want to consider the general case at this point?
----
New commits:


---

Comment by darij created at 2016-01-30 01:25:11

Oh gosh, I have literally no idea about anything beyond the classical types. Is this a bug in the algorithm I wrote? I thought very little of that algorithm is still in Sage?


---

Comment by tscrim created at 2016-01-30 01:44:05

Replying to [comment:13 darij]:
> Oh gosh, I have literally no idea about anything beyond the classical types. Is this a bug in the algorithm I wrote? I thought very little of that algorithm is still in Sage?

Sorry, I meant the B/C issue in the ticket description.


---

Comment by darij created at 2016-01-30 01:55:29

Oh, that!

I have to admit I don't know what the current recognition code is doing (the path-dependent output suggests some caching is going on), but my original code in #16630 never outputted a C_n. Maybe we should do the same?


---

Comment by tscrim created at 2016-01-30 02:06:40

The B/C issue isn't so much having to do with type recognition (which won't result in a C<sub>n</sub>), but instead what to do when we do things like `CoxeterType(['C', 5])`.
