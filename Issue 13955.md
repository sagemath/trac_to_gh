# Issue 13955: Don't install callbacks on values of TripleDict, MonoDict

archive/issues_013955.json:
```json
{
    "body": "Assignee: tbd\n\nCC:  simonking jpflori\n\nIn #11521 [trac_11521_callback.patch](http://trac.sagemath.org/sage_trac/attachment/ticket/11521/trac_11521_callback.patch) a callback was installed on a weakref *value* of a TripleDict:\n\n```\n _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))\n```\nThat's not safe: If the value under that key gets changed while the value remains in memory, the callback will be executed and remove an entry that now has an unrelated value!\n\nSo: Either prove that the value under this key will not change for the lifetime of H (keep in mind that cyclic references can extend the lifetime of an otherwise unreachable object essentially indefinitely, so the proof needs to include that all key components survive H, otherwise those ids could get reused) or provide a more selective callback (for instance, ensure that the value is still as expected before deleting).\n\nAnother point is that the API of `_cache.eraser` isn't really published, so this behaviour is probably better encapsulated in a method on the dict itself.\n\nSee [#12313 comment 317](http://trac.sagemath.org/sage_trac/ticket/12313#comment:317) for a situation that likely implicates these callbacks (someone has to hold strong references to these keys in order to set the dict, so the absence of the keys suggests a spurious execution of this kind of callback)\n\nIssue created by migration from https://trac.sagemath.org/ticket/14159\n\n",
    "created_at": "2013-02-22T02:25:32Z",
    "labels": [],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.10",
    "title": "Don't install callbacks on values of TripleDict, MonoDict",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13955",
    "user": "https://github.com/nbruin"
}
```
Assignee: tbd

CC:  simonking jpflori

In #11521 [trac_11521_callback.patch](http://trac.sagemath.org/sage_trac/attachment/ticket/11521/trac_11521_callback.patch) a callback was installed on a weakref *value* of a TripleDict:

```
 _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))
```
That's not safe: If the value under that key gets changed while the value remains in memory, the callback will be executed and remove an entry that now has an unrelated value!

So: Either prove that the value under this key will not change for the lifetime of H (keep in mind that cyclic references can extend the lifetime of an otherwise unreachable object essentially indefinitely, so the proof needs to include that all key components survive H, otherwise those ids could get reused) or provide a more selective callback (for instance, ensure that the value is still as expected before deleting).

Another point is that the API of `_cache.eraser` isn't really published, so this behaviour is probably better encapsulated in a method on the dict itself.

See [#12313 comment 317](http://trac.sagemath.org/sage_trac/ticket/12313#comment:317) for a situation that likely implicates these callbacks (someone has to hold strong references to these keys in order to set the dict, so the absence of the keys suggests a spurious execution of this kind of callback)

Issue created by migration from https://trac.sagemath.org/ticket/14159





---

archive/issue_comments_173866.json:
```json
{
    "body": "What do you mean by \"value under that key\"?\n\nAh! You mean this situation: `T[a,b,c]=v` and later `T[a,b,c]=w`. Then v might become garbage collected and its callback would remove w from the dictionary.\n\nIndeed, this would be bad.\n\nPotential solutions (two alternatives):\n\n1. The callback shall test whether the value in the entry to be deleted coincides with the value that is being garbage collected.\n\n2. If an existing entry is overwritten by `__setitem__` then its callback will be removed.",
    "created_at": "2013-02-22T08:33:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173866",
    "user": "https://github.com/simon-king-jena"
}
```

What do you mean by "value under that key"?

Ah! You mean this situation: `T[a,b,c]=v` and later `T[a,b,c]=w`. Then v might become garbage collected and its callback would remove w from the dictionary.

Indeed, this would be bad.

Potential solutions (two alternatives):

1. The callback shall test whether the value in the entry to be deleted coincides with the value that is being garbage collected.

2. If an existing entry is overwritten by `__setitem__` then its callback will be removed.



---

archive/issue_comments_173867.json:
```json
{
    "body": "Replying to [comment:1 SimonKing]:\n> 2. If an existing entry is overwritten by `__setitem__` then its callback will be removed.\n  \nI guess you could reach into the `KeyedRef` object and invalidate the key to prevent action on callback. Doing so would complicate all our dict setting and deleting, so I think that is not an attractive option.\n\nJust deleting the `KeyedRef` object won't guarantee it will go away: someone else may be holding a reference to the `KeyedRef` object as well.\n\nSo probably there needs to be an additional option on `...DictEraser` objects to check that the value is as expected (or write yet another callback class, but that sounds like a waste).\n\nAnd then `...Dict` would grow an extra `set_weak_value` to install the appropriate KeyedRef on the value, because letting other code instantiate eraser objects is scary.\n\nIt feels like horrible feature creep, but I guess you have a good use case (can you come up with an alternative solution?)",
    "created_at": "2013-02-22T09:43:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173867",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:1 SimonKing]:
> 2. If an existing entry is overwritten by `__setitem__` then its callback will be removed.
  
I guess you could reach into the `KeyedRef` object and invalidate the key to prevent action on callback. Doing so would complicate all our dict setting and deleting, so I think that is not an attractive option.

Just deleting the `KeyedRef` object won't guarantee it will go away: someone else may be holding a reference to the `KeyedRef` object as well.

So probably there needs to be an additional option on `...DictEraser` objects to check that the value is as expected (or write yet another callback class, but that sounds like a waste).

And then `...Dict` would grow an extra `set_weak_value` to install the appropriate KeyedRef on the value, because letting other code instantiate eraser objects is scary.

It feels like horrible feature creep, but I guess you have a good use case (can you come up with an alternative solution?)



---

archive/issue_comments_173868.json:
```json
{
    "body": "Replying to [comment:2 nbruin]:\n> Replying to [comment:1 SimonKing]:\n> > 2. If an existing entry is overwritten by `__setitem__` then its callback will be removed.\n  \n> I guess you could reach into the `KeyedRef` object and invalidate the key to prevent action on callback. Doing so would complicate all our dict setting and deleting, so I think that is not an attractive option.\n\nSo, what about the first option? It would make sure that an entry will only be deleted if the value is identical with the object whose callback is being called.",
    "created_at": "2013-02-22T09:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173868",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:2 nbruin]:
> Replying to [comment:1 SimonKing]:
> > 2. If an existing entry is overwritten by `__setitem__` then its callback will be removed.
  
> I guess you could reach into the `KeyedRef` object and invalidate the key to prevent action on callback. Doing so would complicate all our dict setting and deleting, so I think that is not an attractive option.

So, what about the first option? It would make sure that an entry will only be deleted if the value is identical with the object whose callback is being called.



---

archive/issue_comments_173869.json:
```json
{
    "body": "Replying to [comment:3 SimonKing]:\n> So, what about the first option? It would make sure that an entry will only be deleted if the value is identical with the object whose callback is being called.\n\nYes, sorry for not being clear about it. That's what the second part of the reply expands on.",
    "created_at": "2013-02-22T09:49:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173869",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:3 SimonKing]:
> So, what about the first option? It would make sure that an entry will only be deleted if the value is identical with the object whose callback is being called.

Yes, sorry for not being clear about it. That's what the second part of the reply expands on.



---

archive/issue_comments_173870.json:
```json
{
    "body": "Replying to [comment:4 nbruin]:\n> Replying to [comment:3 SimonKing]:\n> > So, what about the first option? It would make sure that an entry will only be deleted if the value is identical with the object whose callback is being called.\n\n> Yes, sorry for not being clear about it. That's what the second part of the reply expands on.\n\n\nSorry, I don't see the relation with suggestion 1.\n\n> So probably there needs to be an additional option on ...DictEraser objects to check that the value \n> is as expected \n\n\nWhy? The callback would be checking that the value is identical with the object pointed to by the weak reference. This should be cheap enough to be done by default.",
    "created_at": "2013-02-22T09:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173870",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:4 nbruin]:
> Replying to [comment:3 SimonKing]:
> > So, what about the first option? It would make sure that an entry will only be deleted if the value is identical with the object whose callback is being called.

> Yes, sorry for not being clear about it. That's what the second part of the reply expands on.


Sorry, I don't see the relation with suggestion 1.

> So probably there needs to be an additional option on ...DictEraser objects to check that the value 
> is as expected 


Why? The callback would be checking that the value is identical with the object pointed to by the weak reference. This should be cheap enough to be done by default.



---

archive/issue_comments_173871.json:
```json
{
    "body": "I thought that the following would expose the problem, but it doesn't:\n\n```\nsage: from sage.structure.coerce_dict import TripleDict\nsage: import gc\nsage: class Foo: pass\nsage: \nsage: a = 1\nsage: b = 2\nsage: c = 3\nsage: v = Foo()\nsage: w = Foo()\nsage: T = TripleDict(13)\nsage: T[a,b,c] = v\nsage: T[a,b,c] = w\nsage: del v\nsage: _ = gc.collect()\nsage: len([x for x in gc.get_objects() if isinstance(x,Foo)])\n1\n```\nSo, v got collected and thus the callback was executed. However:\n\n```\nsage: id(T[a,b,c])\n85762632\nsage: id(w)\n85762632\n```\nThe entry that was previously holding v did *not* get deleted when v's callback was called.\n\nSo, are we really in trouble?",
    "created_at": "2013-02-22T10:09:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173871",
    "user": "https://github.com/simon-king-jena"
}
```

I thought that the following would expose the problem, but it doesn't:

```
sage: from sage.structure.coerce_dict import TripleDict
sage: import gc
sage: class Foo: pass
sage: 
sage: a = 1
sage: b = 2
sage: c = 3
sage: v = Foo()
sage: w = Foo()
sage: T = TripleDict(13)
sage: T[a,b,c] = v
sage: T[a,b,c] = w
sage: del v
sage: _ = gc.collect()
sage: len([x for x in gc.get_objects() if isinstance(x,Foo)])
1
```
So, v got collected and thus the callback was executed. However:

```
sage: id(T[a,b,c])
85762632
sage: id(w)
85762632
```
The entry that was previously holding v did *not* get deleted when v's callback was called.

So, are we really in trouble?



---

archive/issue_comments_173872.json:
```json
{
    "body": "You have to make sure that the weakref object lives to see the death of v (and ensure that you make such a weakref in the first place!)\n\n```\nsage: from sage.structure.coerce_dict import TripleDict\nsage: import gc\nsage: import weakref\nsage: class Foo: pass\nsage: \nsage: a = 1\nsage: b = 2\nsage: c = 3\nsage: v = Foo()\nsage: w = Foo()\nsage: T = TripleDict(13)\nsage: T[a,b,c] = weakref.KeyedRef(v,T.eraser,(id(a),id(b),id(c)))\nsage: h=T[a,b,c]\nsage: T[a,b,c] = w\nsage: del v\nsage: _ = gc.collect()\nsage: len([x for x in gc.get_objects() if isinstance(x,Foo)])\n1\nsage: T[a,b,c] == w\nKeyError: (1, 2, 3)\n```\nI admit, the weakref surviving outside the dict is not a terribly likely event, but from your code at #11521 it wasn't entirely clear to me that you can absolutely rule it out.",
    "created_at": "2013-02-22T10:29:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173872",
    "user": "https://github.com/nbruin"
}
```

You have to make sure that the weakref object lives to see the death of v (and ensure that you make such a weakref in the first place!)

```
sage: from sage.structure.coerce_dict import TripleDict
sage: import gc
sage: import weakref
sage: class Foo: pass
sage: 
sage: a = 1
sage: b = 2
sage: c = 3
sage: v = Foo()
sage: w = Foo()
sage: T = TripleDict(13)
sage: T[a,b,c] = weakref.KeyedRef(v,T.eraser,(id(a),id(b),id(c)))
sage: h=T[a,b,c]
sage: T[a,b,c] = w
sage: del v
sage: _ = gc.collect()
sage: len([x for x in gc.get_objects() if isinstance(x,Foo)])
1
sage: T[a,b,c] == w
KeyError: (1, 2, 3)
```
I admit, the weakref surviving outside the dict is not a terribly likely event, but from your code at #11521 it wasn't entirely clear to me that you can absolutely rule it out.



---

archive/issue_comments_173873.json:
```json
{
    "body": "Replying to [comment:7 nbruin]:\n> You have to make sure that the weakref object lives to see the death of v (and ensure that you make such a weakref in the first place!)\n\n\nApparently I had wrong memories about my code, then. I had in mind that the `TripleDict` has a weak reference with callback to the value.\n\n\n> {{{\n> sage: from sage.structure.coerce_dict import TripleDict\n> sage: import gc\n> sage: import weakref\n> sage: class Foo: pass\n> sage: \n> sage: a = 1\n> sage: b = 2\n> sage: c = 3\n> sage: v = Foo()\n> sage: w = Foo()\n> sage: T = TripleDict(13)\n> sage: T[a,b,c] = weakref.KeyedRef(v,T.eraser,(id(a),id(b),id(c)))\n> sage: h=T[a,b,c]\n> sage: T[a,b,c] = w\n> sage: del v\n> sage: _ = gc.collect()\n> sage: len([x for x in gc.get_objects() if isinstance(x,Foo)])\n> 1\n> sage: T[a,b,c] == w\n> KeyError: (1, 2, 3)\n> }}}\n> I admit, the weakref surviving outside the dict is not a terribly likely event, but from your code at #11521 it wasn't entirely clear to me that you can absolutely rule it out.\n\n\nHm. This particular `TripleDict` is only used by hom, and hom doe not override an existing entry. So, this particular case should be safe. However, it still seems reasonable to me to let the callback check whether the to-be-deleted value did not change.",
    "created_at": "2013-02-22T11:48:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173873",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:7 nbruin]:
> You have to make sure that the weakref object lives to see the death of v (and ensure that you make such a weakref in the first place!)


Apparently I had wrong memories about my code, then. I had in mind that the `TripleDict` has a weak reference with callback to the value.


> {{{
> sage: from sage.structure.coerce_dict import TripleDict
> sage: import gc
> sage: import weakref
> sage: class Foo: pass
> sage: 
> sage: a = 1
> sage: b = 2
> sage: c = 3
> sage: v = Foo()
> sage: w = Foo()
> sage: T = TripleDict(13)
> sage: T[a,b,c] = weakref.KeyedRef(v,T.eraser,(id(a),id(b),id(c)))
> sage: h=T[a,b,c]
> sage: T[a,b,c] = w
> sage: del v
> sage: _ = gc.collect()
> sage: len([x for x in gc.get_objects() if isinstance(x,Foo)])
> 1
> sage: T[a,b,c] == w
> KeyError: (1, 2, 3)
> }}}
> I admit, the weakref surviving outside the dict is not a terribly likely event, but from your code at #11521 it wasn't entirely clear to me that you can absolutely rule it out.


Hm. This particular `TripleDict` is only used by hom, and hom doe not override an existing entry. So, this particular case should be safe. However, it still seems reasonable to me to let the callback check whether the to-be-deleted value did not change.



---

archive/issue_comments_173874.json:
```json
{
    "body": "Replying to [comment:8 SimonKing]:\n> Hm. This particular `TripleDict` is only used by hom, and hom doe not override an existing entry. So, this particular case should be safe. However, it still seems reasonable to me to let the callback check whether the to-be-deleted value did not change.\n\n\nI was fully expecting that to be true, but I could not come up with an explanation for the bug Jeroen reported at #12313, where the line in\n\n```\n _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))\n```\nleads to a key error in `TripleDict.set` in the line:\n\n```\nr1,r2,r3 = <tuple>(self._refcache[h1,h2,h3])\n```\nThe only thing I could think of for that line to fail is:\n- This `KeyedRef` object `W` is constructed\n- `_cache.set(k1,k2,k3,W)` is called with `k1=id(X),k2=id(Y),k3=id(category)`. Note that the caller is holding strong references to `(X,Y,category)`.\n- In order to end up in the line `r1,r2,r3 = <tuple>(self._refcache[h1,h2,h3])`, the key triple `(k1,k2,k3)` must be present in this `TripleDict` and hence in `self._refcache`\n- Yet, we get a `KeyError`. Calling `self._refcache[h1,h2,h3]` requires the construction of a new tuple `(h1,h2,h3)`, which could trigger a `GC` and hence a callback that would remove entries. So the only explanation I see is that we're getting a callback with key `(k1,k2,k3)` due to a GC triggered by this tuple allocation.\n- However, this callback cannot result from any of `X,Y,category` getting collected, because someone is holding strong references to them. Hence such a callback must be coming from somewhere else.\n- The code pointed to (ironically the same code that triggers this `TripleDict` operation) is an example of code that installs such callbacks. So a possible scenario is that a statement\n`_cache.set(k1,k2,k3,Wold)`\nwas executed before, that Wold is still hanging around in memory and that it finally gets removed due to this poorly timed garbage collection and consequently that the keytriple `(k1,k2,k3)` receives a callback, even though they are pointing to (or are about to be pointing to -- we don't know what happened in between) another, unrelated value.\n\nIn this scenario, values in this `Hom` dictionary do get changed.\n\nWe need to ensure that `TripleDict` cannot trigger `GC` at that point anyway (and that is what #13387 does as a side-effect), because all kinds of other bad things could happen as well. However, given that it needs such a complicated explanation, I would hope we can verify my assumptions, because otherwise my fix might not be sufficient.\n\nHence the formulation of the ticket: If you can prove that installing this callback is safe, I have no problem with it.",
    "created_at": "2013-02-22T17:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173874",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:8 SimonKing]:
> Hm. This particular `TripleDict` is only used by hom, and hom doe not override an existing entry. So, this particular case should be safe. However, it still seems reasonable to me to let the callback check whether the to-be-deleted value did not change.


I was fully expecting that to be true, but I could not come up with an explanation for the bug Jeroen reported at #12313, where the line in

```
 _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))
```
leads to a key error in `TripleDict.set` in the line:

```
r1,r2,r3 = <tuple>(self._refcache[h1,h2,h3])
```
The only thing I could think of for that line to fail is:
- This `KeyedRef` object `W` is constructed
- `_cache.set(k1,k2,k3,W)` is called with `k1=id(X),k2=id(Y),k3=id(category)`. Note that the caller is holding strong references to `(X,Y,category)`.
- In order to end up in the line `r1,r2,r3 = <tuple>(self._refcache[h1,h2,h3])`, the key triple `(k1,k2,k3)` must be present in this `TripleDict` and hence in `self._refcache`
- Yet, we get a `KeyError`. Calling `self._refcache[h1,h2,h3]` requires the construction of a new tuple `(h1,h2,h3)`, which could trigger a `GC` and hence a callback that would remove entries. So the only explanation I see is that we're getting a callback with key `(k1,k2,k3)` due to a GC triggered by this tuple allocation.
- However, this callback cannot result from any of `X,Y,category` getting collected, because someone is holding strong references to them. Hence such a callback must be coming from somewhere else.
- The code pointed to (ironically the same code that triggers this `TripleDict` operation) is an example of code that installs such callbacks. So a possible scenario is that a statement
`_cache.set(k1,k2,k3,Wold)`
was executed before, that Wold is still hanging around in memory and that it finally gets removed due to this poorly timed garbage collection and consequently that the keytriple `(k1,k2,k3)` receives a callback, even though they are pointing to (or are about to be pointing to -- we don't know what happened in between) another, unrelated value.

In this scenario, values in this `Hom` dictionary do get changed.

We need to ensure that `TripleDict` cannot trigger `GC` at that point anyway (and that is what #13387 does as a side-effect), because all kinds of other bad things could happen as well. However, given that it needs such a complicated explanation, I would hope we can verify my assumptions, because otherwise my fix might not be sufficient.

Hence the formulation of the ticket: If you can prove that installing this callback is safe, I have no problem with it.



---

archive/issue_comments_173875.json:
```json
{
    "body": "Ouch, I looked at that code and you're correct: That doesn't overwrite the value at all (it's really a cache). Incidentally, at that code:\n\n```\n    try:\n        H = _cache[key]()\n    except KeyError:\n        H = None\n    if H is not None:\n        # Are domain or codomain breaking the unique parent condition?\n        if H.domain() is X and H.codomain() is Y:\n            return H\n```\nSince `X,Y` are part of key, which is looked up by identity, the \"domain\" and \"codomain\" test should really be superfluous. So perhaps we want\n\n```\nif H is not None:\n   assert H.domain() is X and H.codomain() is Y\n   return H\n```\nsince something is going very wrong if this is not the case! (H would not be allowed to sit there in the dict).\n\nFurthermore, `H` has strong references to `X,Y,category` in the form of `H.domain()`, `H.codomain()` and `H.homset_category()`, so if H is alive then so must the keys. Which means that the callback on H must happen (or be purged) before those on `X,Y` etc., or at least in the same GC.\nso their `id`s can't get reused until their callbacks have happened or have been discarded.\n\nI think that only leaves the possibility that `_cache` got silently corrupted due to a GC at an inopportune time before this particular error. We cannot rule that out, but it's extremely unlikely: It requires a bucket to be rather full and buckets are typically not full at all (ideally only one entry). \n\nOn the other hand, since this is a global _cache, it does get to hold quite a few keys, so it's quite likely that it underwent a `resize` operation, where a corruption was much more likely to happen.\n\nIt's rather difficult to do an accurate postmortem with so little data.",
    "created_at": "2013-02-22T21:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173875",
    "user": "https://github.com/nbruin"
}
```

Ouch, I looked at that code and you're correct: That doesn't overwrite the value at all (it's really a cache). Incidentally, at that code:

```
    try:
        H = _cache[key]()
    except KeyError:
        H = None
    if H is not None:
        # Are domain or codomain breaking the unique parent condition?
        if H.domain() is X and H.codomain() is Y:
            return H
```
Since `X,Y` are part of key, which is looked up by identity, the "domain" and "codomain" test should really be superfluous. So perhaps we want

```
if H is not None:
   assert H.domain() is X and H.codomain() is Y
   return H
```
since something is going very wrong if this is not the case! (H would not be allowed to sit there in the dict).

Furthermore, `H` has strong references to `X,Y,category` in the form of `H.domain()`, `H.codomain()` and `H.homset_category()`, so if H is alive then so must the keys. Which means that the callback on H must happen (or be purged) before those on `X,Y` etc., or at least in the same GC.
so their `id`s can't get reused until their callbacks have happened or have been discarded.

I think that only leaves the possibility that `_cache` got silently corrupted due to a GC at an inopportune time before this particular error. We cannot rule that out, but it's extremely unlikely: It requires a bucket to be rather full and buckets are typically not full at all (ideally only one entry). 

On the other hand, since this is a global _cache, it does get to hold quite a few keys, so it's quite likely that it underwent a `resize` operation, where a corruption was much more likely to happen.

It's rather difficult to do an accurate postmortem with so little data.



---

archive/issue_comments_173876.json:
```json
{
    "body": "patch that got misplaced on #12313",
    "created_at": "2013-02-24T03:13:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173876",
    "user": "https://github.com/nbruin"
}
```

patch that got misplaced on #12313



---

archive/issue_comments_173877.json:
```json
{
    "body": "Attachment [trac_12313-revert_callback_from_11521.patch](tarball://root/attachments/some-uuid/ticket14159/trac_12313-revert_callback_from_11521.patch) by @simon-king-jena created at 2013-02-24 08:32:00\n\nThank you for moving the patch to the right location (I forgot about the existence of this ticket...).",
    "created_at": "2013-02-24T08:32:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173877",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_12313-revert_callback_from_11521.patch](tarball://root/attachments/some-uuid/ticket14159/trac_12313-revert_callback_from_11521.patch) by @simon-king-jena created at 2013-02-24 08:32:00

Thank you for moving the patch to the right location (I forgot about the existence of this ticket...).



---

archive/issue_comments_173878.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-02-24T08:32:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173878",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_173879.json:
```json
{
    "body": "Documentation to explain the problem (and possible future problems)",
    "created_at": "2013-02-24T23:46:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173879",
    "user": "https://github.com/nbruin"
}
```

Documentation to explain the problem (and possible future problems)



---

archive/issue_comments_173880.json:
```json
{
    "body": "Attachment [trac_14159-document_callback_issue.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159-document_callback_issue.patch) by @nbruin created at 2013-02-25 00:01:47\n\n\"Reviewer\" patch to provide some doc and pointers if this ever proves to be a problem. An example of the kind of situation where this could lead to quadratic memory use (relative to what is required):\n\n```\nR=[ZZ.quo(3^n) for n in [1..100]]\nfor i in range(100):\n    for j in range(i,100):\n        H = Hom(R[j],R[i])\n```\n\nThis leaves `100*101/2` entries with (eventually) dead weakrefs in the dictionary.\n\nI think we should leave ample documentation of this leak in the code, including the strategy to fix it, should it become necessary.\n\n(for posterity: The KeyedRef alternative is *probably* OK, because it seems that H can never outlive its domain and codomain X and Y, so I don't see how their id's could get reused before the callback on H has happened or got purged. I'm just very cautious with anything that has to do with GC and callback orders after the problems we encountered with it elsewhere. In any case, the incantation would have to documented \"DO NOT COPY THIS WITHOUT UNDERSTANDING THE CONSEQUENCES FULLY\", because it's a bad pattern to use elsewhere, unless you prove a whole bunch of extra conditions.)\n\nSimon, are you OK with the doc? If so we can put this to positive review (doctests passed for me)",
    "created_at": "2013-02-25T00:01:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173880",
    "user": "https://github.com/nbruin"
}
```

Attachment [trac_14159-document_callback_issue.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159-document_callback_issue.patch) by @nbruin created at 2013-02-25 00:01:47

"Reviewer" patch to provide some doc and pointers if this ever proves to be a problem. An example of the kind of situation where this could lead to quadratic memory use (relative to what is required):

```
R=[ZZ.quo(3^n) for n in [1..100]]
for i in range(100):
    for j in range(i,100):
        H = Hom(R[j],R[i])
```

This leaves `100*101/2` entries with (eventually) dead weakrefs in the dictionary.

I think we should leave ample documentation of this leak in the code, including the strategy to fix it, should it become necessary.

(for posterity: The KeyedRef alternative is *probably* OK, because it seems that H can never outlive its domain and codomain X and Y, so I don't see how their id's could get reused before the callback on H has happened or got purged. I'm just very cautious with anything that has to do with GC and callback orders after the problems we encountered with it elsewhere. In any case, the incantation would have to documented "DO NOT COPY THIS WITHOUT UNDERSTANDING THE CONSEQUENCES FULLY", because it's a bad pattern to use elsewhere, unless you prove a whole bunch of extra conditions.)

Simon, are you OK with the doc? If so we can put this to positive review (doctests passed for me)



---

archive/issue_comments_173881.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to memleak.",
    "created_at": "2013-02-25T00:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173881",
    "user": "https://github.com/nbruin"
}
```

Changing component from PLEASE CHANGE to memleak.



---

archive/issue_comments_173882.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2013-02-25T00:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173882",
    "user": "https://github.com/nbruin"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_173883.json:
```json
{
    "body": "Since your patch changes code (by inserting assert statements) I better run the doc tests with #14159, #12313 and #13387, before changing it to positive review.\n\nNote, however, that the error reported by the patchbot probably is unrelated:\n\n```\nsage -t  -force_lib devel/sage-14159/doc/en/constructions/calculus.rst\n**********************************************************************\nFile \"/mnt/storage2TB/patchbot/Sage/sage-5.8.beta0/devel/sage-14159/doc/en/constructions/calculus.rst\", line 102:\n    sage: maxima(g).powerseries('x',0)\nExpected:\n    16*f0*('sum((2^(2*i1-1)-1)*bern(2*i1)*k^(2*i1-1)*x^(2*i1-1)/(2*i1)!,i1,0,inf))^4\nGot:\n    Maxima crashed -- automatically restarting.\n    16*f0*('sum((2^(2*i1-1)-1)*bern(2*i1)*k^(2*i1-1)*x^(2*i1-1)/(2*i1)!,i1,0,inf))^4\n**********************************************************************\n1 items had failures:\n   1 of   7 in __main__.example_3\n***Test Failed*** 1 failures.\n```",
    "created_at": "2013-02-25T06:27:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173883",
    "user": "https://github.com/simon-king-jena"
}
```

Since your patch changes code (by inserting assert statements) I better run the doc tests with #14159, #12313 and #13387, before changing it to positive review.

Note, however, that the error reported by the patchbot probably is unrelated:

```
sage -t  -force_lib devel/sage-14159/doc/en/constructions/calculus.rst
**********************************************************************
File "/mnt/storage2TB/patchbot/Sage/sage-5.8.beta0/devel/sage-14159/doc/en/constructions/calculus.rst", line 102:
    sage: maxima(g).powerseries('x',0)
Expected:
    16*f0*('sum((2^(2*i1-1)-1)*bern(2*i1)*k^(2*i1-1)*x^(2*i1-1)/(2*i1)!,i1,0,inf))^4
Got:
    Maxima crashed -- automatically restarting.
    16*f0*('sum((2^(2*i1-1)-1)*bern(2*i1)*k^(2*i1-1)*x^(2*i1-1)/(2*i1)!,i1,0,inf))^4
**********************************************************************
1 items had failures:
   1 of   7 in __main__.example_3
***Test Failed*** 1 failures.
```



---

archive/issue_comments_173884.json:
```json
{
    "body": "A little data point for how this change might adversely affect memory and speed performance. Running\n\n```\nimport resource\nR=[ZZ.quo(3^n) for n in [1..1000]]\ndef test(R):\n    for i in range(len(R)):\n        print i\n        for j in range(i,len(R)):\n            H=Hom(R[j],R[i])\n\n%time test(R)\nresource.getrusage(resource.RUSAGE_SELF)\n```\nReference:\n\n```\nresource.struct_rusage(ru_utime=50.020395, ru_stime=0.16497399999999998,\nru_maxrss=130108, ru_ixrss=0, ru_idrss=0, ru_isrss=0, ru_minflt=42660,\nru_majflt=1, ru_nswap=0, ru_inblock=600, ru_oublock=240, ru_msgsnd=0,\nru_msgrcv=0, ru_nsignals=0, ru_nvcsw=8669, ru_nivcsw=7514)\n```\nWith this patch:\n\n```\nresource.struct_rusage(ru_utime=54.220757, ru_stime=0.35794499999999996,\nru_maxrss=703824, ru_ixrss=0, ru_idrss=0, ru_isrss=0, ru_minflt=187662,\nru_majflt=1, ru_nswap=0, ru_inblock=584, ru_oublock=240, ru_msgsnd=0,\nru_msgrcv=0, ru_nsignals=0, ru_nvcsw=12759, ru_nivcsw=7940)\n```\nThis of course is an example that tries to expose exactly the flaw. We're finding:\n- about 10% runtime penalty. That seems to be the garbage collections that are happening.\n- a lot more memory usage (without the patch memory usage is flat. With the patch you can run out of memory)\n\nI'm not sure how serious this is. It's making me a little hesitant on whether we should be \"fixing\" this at all, though!",
    "created_at": "2013-02-25T08:24:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173884",
    "user": "https://github.com/nbruin"
}
```

A little data point for how this change might adversely affect memory and speed performance. Running

```
import resource
R=[ZZ.quo(3^n) for n in [1..1000]]
def test(R):
    for i in range(len(R)):
        print i
        for j in range(i,len(R)):
            H=Hom(R[j],R[i])

%time test(R)
resource.getrusage(resource.RUSAGE_SELF)
```
Reference:

```
resource.struct_rusage(ru_utime=50.020395, ru_stime=0.16497399999999998,
ru_maxrss=130108, ru_ixrss=0, ru_idrss=0, ru_isrss=0, ru_minflt=42660,
ru_majflt=1, ru_nswap=0, ru_inblock=600, ru_oublock=240, ru_msgsnd=0,
ru_msgrcv=0, ru_nsignals=0, ru_nvcsw=8669, ru_nivcsw=7514)
```
With this patch:

```
resource.struct_rusage(ru_utime=54.220757, ru_stime=0.35794499999999996,
ru_maxrss=703824, ru_ixrss=0, ru_idrss=0, ru_isrss=0, ru_minflt=187662,
ru_majflt=1, ru_nswap=0, ru_inblock=584, ru_oublock=240, ru_msgsnd=0,
ru_msgrcv=0, ru_nsignals=0, ru_nvcsw=12759, ru_nivcsw=7940)
```
This of course is an example that tries to expose exactly the flaw. We're finding:
- about 10% runtime penalty. That seems to be the garbage collections that are happening.
- a lot more memory usage (without the patch memory usage is flat. With the patch you can run out of memory)

I'm not sure how serious this is. It's making me a little hesitant on whether we should be "fixing" this at all, though!



---

archive/issue_comments_173885.json:
```json
{
    "body": "Idea: We could add a callback---but a new one. Namely a callback, that will only remove the entry from the `TripleDict` if the value is the weak reference for which this callback is called.",
    "created_at": "2013-02-25T08:33:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173885",
    "user": "https://github.com/simon-king-jena"
}
```

Idea: We could add a callback---but a new one. Namely a callback, that will only remove the entry from the `TripleDict` if the value is the weak reference for which this callback is called.



---

archive/issue_comments_173886.json:
```json
{
    "body": "Attachment [trac_14159_safer_callback.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159_safer_callback.patch) by @simon-king-jena created at 2013-02-25 11:56:54\n\nA safe callback for weak values of a `TripleDict`",
    "created_at": "2013-02-25T11:56:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173886",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_14159_safer_callback.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159_safer_callback.patch) by @simon-king-jena created at 2013-02-25 11:56:54

A safe callback for weak values of a `TripleDict`



---

archive/issue_comments_173887.json:
```json
{
    "body": "I did not run the full tests yet, but I think the new patch can be reviewed.\n\nI introduce a variant of `TripleDictEraser` dedicated for use on the values of a `TripleDict` (if we use a callback for the values of `MonoDict` then we need to do the same). It will only erase an item if the value is the originally stored weak reference.\n\nThe patch contains tests demonstrating that `TripleDictEraser` is unsafe but `TripleDictEraserOnValue` is safe on values, and it contains a test demonstrating that homsets can still be garbage collected.\n\nApply trac_14159_safer_callback.patch",
    "created_at": "2013-02-25T12:01:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173887",
    "user": "https://github.com/simon-king-jena"
}
```

I did not run the full tests yet, but I think the new patch can be reviewed.

I introduce a variant of `TripleDictEraser` dedicated for use on the values of a `TripleDict` (if we use a callback for the values of `MonoDict` then we need to do the same). It will only erase an item if the value is the originally stored weak reference.

The patch contains tests demonstrating that `TripleDictEraser` is unsafe but `TripleDictEraserOnValue` is safe on values, and it contains a test demonstrating that homsets can still be garbage collected.

Apply trac_14159_safer_callback.patch



---

archive/issue_comments_173888.json:
```json
{
    "body": "PS: I worked on top of #13387, so, that's a dependency.\n\nApply trac_14159_safer_callback.patch",
    "created_at": "2013-02-25T12:02:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173888",
    "user": "https://github.com/simon-king-jena"
}
```

PS: I worked on top of #13387, so, that's a dependency.

Apply trac_14159_safer_callback.patch



---

archive/issue_comments_173889.json:
```json
{
    "body": "tests OK for me. One tiny nitpick:\n- You're claiming that this fixes an extremely rare race condition wrt. to GC. I'm actually not sure that it CAN occur for our particular use (because our value has a strong reference to a key component). I think your example on `TripleDictEraserOnValue` illustrates why we should prefer checking this anyway. I hope we don't have to be this paranoid in the future.\n\nThere's another one, that the `_cache[X,Y,category]=KeyedRef(...)` statement is very fragile: If you make a mistake in typing the `(id(X),id(Y),id(category))` you'll have a very hard to trace (and possibly disastrous!) bug in your program. One solution would be to encapsulate it in `TripleDict`, but the instantiation of the `TripleDictEraserOnValue` would complicate the logic in `TripleDict`,\nso let's just keep it this way.",
    "created_at": "2013-02-25T22:34:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173889",
    "user": "https://github.com/nbruin"
}
```

tests OK for me. One tiny nitpick:
- You're claiming that this fixes an extremely rare race condition wrt. to GC. I'm actually not sure that it CAN occur for our particular use (because our value has a strong reference to a key component). I think your example on `TripleDictEraserOnValue` illustrates why we should prefer checking this anyway. I hope we don't have to be this paranoid in the future.

There's another one, that the `_cache[X,Y,category]=KeyedRef(...)` statement is very fragile: If you make a mistake in typing the `(id(X),id(Y),id(category))` you'll have a very hard to trace (and possibly disastrous!) bug in your program. One solution would be to encapsulate it in `TripleDict`, but the instantiation of the `TripleDictEraserOnValue` would complicate the logic in `TripleDict`,
so let's just keep it this way.



---

archive/issue_comments_173890.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-02-26T12:10:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173890",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_173891.json:
```json
{
    "body": "The coverage script rightfully complains that I didn't add a test to the `__call__` method of the new `TripleDictEraserOnValue`.\n\nDo we need to worry about startup time? How to interpret the data?",
    "created_at": "2013-02-26T12:10:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173891",
    "user": "https://github.com/simon-king-jena"
}
```

The coverage script rightfully complains that I didn't add a test to the `__call__` method of the new `TripleDictEraserOnValue`.

Do we need to worry about startup time? How to interpret the data?



---

archive/issue_comments_173892.json:
```json
{
    "body": "The startup_modules script complains that sage.structure.gc was added. But that has happened in #13387! So, why is the patchbot complaining here, too?",
    "created_at": "2013-02-26T12:29:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173892",
    "user": "https://github.com/simon-king-jena"
}
```

The startup_modules script complains that sage.structure.gc was added. But that has happened in #13387! So, why is the patchbot complaining here, too?



---

archive/issue_comments_173893.json:
```json
{
    "body": "Replying to [comment:19 nbruin]:\n> tests OK for me. One tiny nitpick:\n> - You're claiming that this fixes an extremely rare race condition wrt. to GC. I'm actually not sure that it CAN occur for our particular use (because our value has a strong reference to a key component). I think your example on `TripleDictEraserOnValue` illustrates why we should prefer checking this anyway. I hope we don't have to be this paranoid in the future.\n\n\nI thought you diagnosed that this was the cause of one problem we saw? Such as:\n\n1. Some parent X, Y give rise to a homset H, in a category C.\n2. H and X get deleted, but the callbacks are not performed yet. A new parent X2 is created, and by mere coincidence we have id(X)==id(X2).\n3. The homset H2 with respect to X2, Y and C is created. It thus overrides H in the cache.\n4. Finally, the callback of H is performed, erasing H2 from the cache. Boom\n\nThis is what I meant by a \"rare racing condition\".\n\nDo you prefer that I erase this statement?\n\nThinking of it: Suppose we are now considering the callback of X, which, in the above scenario, has not been called prior to the creation of X2. Would it not delete the new item, too? So, shouldn't we add a test in `TripleDictEraser.__call__(self, r)`, so that an item is deleted only if one of the references from the keys of this item is identical with r?\n\n> There's another one, that the `_cache[X,Y,category]=KeyedRef(...)` statement is very fragile: If you make a mistake in typing the `(id(X),id(Y),id(category))` you'll have a very hard to trace (and possibly disastrous!) bug in your program. One solution would be to encapsulate it in `TripleDict`, but the instantiation of the `TripleDictEraserOnValue` would complicate the logic in `TripleDict`,\n\n\nI wouldn't like to put this into `TripleDict`. After all, it is impossible to prevent all thinkable typing mistakes.",
    "created_at": "2013-02-26T12:39:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173893",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:19 nbruin]:
> tests OK for me. One tiny nitpick:
> - You're claiming that this fixes an extremely rare race condition wrt. to GC. I'm actually not sure that it CAN occur for our particular use (because our value has a strong reference to a key component). I think your example on `TripleDictEraserOnValue` illustrates why we should prefer checking this anyway. I hope we don't have to be this paranoid in the future.


I thought you diagnosed that this was the cause of one problem we saw? Such as:

1. Some parent X, Y give rise to a homset H, in a category C.
2. H and X get deleted, but the callbacks are not performed yet. A new parent X2 is created, and by mere coincidence we have id(X)==id(X2).
3. The homset H2 with respect to X2, Y and C is created. It thus overrides H in the cache.
4. Finally, the callback of H is performed, erasing H2 from the cache. Boom

This is what I meant by a "rare racing condition".

Do you prefer that I erase this statement?

Thinking of it: Suppose we are now considering the callback of X, which, in the above scenario, has not been called prior to the creation of X2. Would it not delete the new item, too? So, shouldn't we add a test in `TripleDictEraser.__call__(self, r)`, so that an item is deleted only if one of the references from the keys of this item is identical with r?

> There's another one, that the `_cache[X,Y,category]=KeyedRef(...)` statement is very fragile: If you make a mistake in typing the `(id(X),id(Y),id(category))` you'll have a very hard to trace (and possibly disastrous!) bug in your program. One solution would be to encapsulate it in `TripleDict`, but the instantiation of the `TripleDictEraserOnValue` would complicate the logic in `TripleDict`,


I wouldn't like to put this into `TripleDict`. After all, it is impossible to prevent all thinkable typing mistakes.



---

archive/issue_comments_173894.json:
```json
{
    "body": "I am just thinking: Perhaps one should enrich the key of the `KeyedReference`, so that it states *where* we are supposed to find the reference that caused the callback. I am thinking of an additional int, that is 1, 3 or 5 if the reference is in the first, second or third part of the key (1,3,5 give the relative position in the bucket), and 6 if the reference belongs to the value of the item.\n\nIn that way, we would avoid the racing condition I described in the previous comment, *and* we would not need to create a separate class `TripleDictEraserOnValue`.",
    "created_at": "2013-02-26T13:04:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173894",
    "user": "https://github.com/simon-king-jena"
}
```

I am just thinking: Perhaps one should enrich the key of the `KeyedReference`, so that it states *where* we are supposed to find the reference that caused the callback. I am thinking of an additional int, that is 1, 3 or 5 if the reference is in the first, second or third part of the key (1,3,5 give the relative position in the bucket), and 6 if the reference belongs to the value of the item.

In that way, we would avoid the racing condition I described in the previous comment, *and* we would not need to create a separate class `TripleDictEraserOnValue`.



---

archive/issue_comments_173895.json:
```json
{
    "body": "Additional idea: We could create `TripleDict` with an optional parameter `weak_values`. If this parameter is True, then the set/get methods would automatically use a weak reference on the value, with the correct key for the callback. Hence, we do not need to exploit implementation details when we apply a triple dict with weak values in sage.categories.homset\n\nDoes that sound like a good idea?",
    "created_at": "2013-02-26T13:07:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173895",
    "user": "https://github.com/simon-king-jena"
}
```

Additional idea: We could create `TripleDict` with an optional parameter `weak_values`. If this parameter is True, then the set/get methods would automatically use a weak reference on the value, with the correct key for the callback. Hence, we do not need to exploit implementation details when we apply a triple dict with weak values in sage.categories.homset

Does that sound like a good idea?



---

archive/issue_comments_173896.json:
```json
{
    "body": "What I suggest is the following:\n\n```\n        sage: from sage.structure.coerce_dict import MonoDict\n        sage: import gc\n        sage: M = MonoDict(13)\n        sage: MW = MonoDict(13, weak_values=True)\n        sage: class Foo: pass\n        sage: a = Foo()\n        sage: b = Foo()\n        sage: k = 1\n        sage: M[k] = a\n        sage: MW[k] = b\n        sage: M[k] is a\n        True\n        sage: MW[k] is b\n        True\n        sage: k in M\n        True\n        sage: k in MW\n        True\n        sage: import gc\n        sage: del a,b\n        sage: _ = gc.collect()\n        sage: k in M\n        True\n        sage: k in MW\n        False\n        sage: len(MW)\n        0\n        sage: len(M)\n        1\n        sage: MW[k] = int(5)\n        sage: MW[k]\n        5\n```\n\nHence, we have the option to use weak values, but even in that case we would accept non-weakrefable values, too.\n\nAnd, similarly, for `TripleDict`, with using `weak_values` for the homset cache.",
    "created_at": "2013-02-26T17:17:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173896",
    "user": "https://github.com/simon-king-jena"
}
```

What I suggest is the following:

```
        sage: from sage.structure.coerce_dict import MonoDict
        sage: import gc
        sage: M = MonoDict(13)
        sage: MW = MonoDict(13, weak_values=True)
        sage: class Foo: pass
        sage: a = Foo()
        sage: b = Foo()
        sage: k = 1
        sage: M[k] = a
        sage: MW[k] = b
        sage: M[k] is a
        True
        sage: MW[k] is b
        True
        sage: k in M
        True
        sage: k in MW
        True
        sage: import gc
        sage: del a,b
        sage: _ = gc.collect()
        sage: k in M
        True
        sage: k in MW
        False
        sage: len(MW)
        0
        sage: len(M)
        1
        sage: MW[k] = int(5)
        sage: MW[k]
        5
```

Hence, we have the option to use weak values, but even in that case we would accept non-weakrefable values, too.

And, similarly, for `TripleDict`, with using `weak_values` for the homset cache.



---

archive/issue_comments_173897.json:
```json
{
    "body": "Replying to [comment:22 SimonKing]:\n\n(just saw your new post. Definitely an option. If you see merit I'm fine with that. Below response I wrote to your earlier message)\n\n> I thought you diagnosed that this was the cause of one problem we saw?\n\nNo, what I'm pretty sure we saw at some point was GC *happening* during dictionary value setting. While looking at the code I noticed this callback without proof that it's safe.\n\n> 1. Some parent X, Y give rise to a homset H, in a category C.\n> 2. H and X get deleted, but the callbacks are not performed yet. A new parent X2 is created, and by mere coincidence we have id(X)==id(X2).\n> 3. The homset H2 with respect to X2, Y and C is created. It thus overrides H in the cache.\n> 4. Finally, the callback of H is performed, erasing H2 from the cache. Boom\n\n\nYes, that's exactly the scenario I envisaged. I don't have a proof that this is theoretically possible, though.\n\nThe weakref to X is referenced by this dictionary that is still in use, so it's not garbage. I think that means the callback to X is guaranteed to happen before deallocation of X (and hence before the creation of X2). Furthermore X can only be found to be garbage if H is found to be garbage (because of the strong `domain` reference), so the callback on H has to happen in the same GC as the deallocation of X. So as long as we're not creating parents during callbacks, I think that also means X2 cannot be created in the same memory location as X while the callback on H hasn't happened yet.\n\nSo we have a choice:\n- make a very involved argument, carefully reasoning about the specifics of python's GC system (for which we don't actually have a formal axiom system)\n- be on the safe side and just put in a cheap test.\n\n> Do you prefer that I erase this statement?\n\n\nperhaps \"race condition we couldn't quite rule out\"\n\n> Thinking of it: Suppose we are now considering the callback of X, which, in the above scenario, has not been called prior to the creation of X2. Would it not delete the new item, too? So, shouldn't we add a test in `TripleDictEraser.__call__(self, r)`, so that an item is deleted only if one of the references from the keys of this item is identical with r?\n\n\nNo, in order to set the value, the caller must be holding strong references to the keys. As far as I know, weakref callback and deallocation only get separated inside GC. So as long as we're not calling set in callbacks, I think we're prevented from it (note that for H we needed, in addition, that H holds a reference to X AND that key triples do not get reassigned.)\n\n> I wouldn't like to put this into `TripleDict`. After all, it is impossible to prevent all thinkable typing mistakes.\n\n\nWell, this is one where you have to type the same data *twice*. But I agree: We have only one use case. Should we get more I think it's worth reconsidering.\n\n> Additional idea: We could create TripleDict with an optional parameter weak_values. If this parameter is True, then the set/get methods would automatically use a weak reference on the value, with the correct key for the callback. Hence, we do not need to exploit implementation details when we apply a triple dict with weak values in sage.categories.homset\n\n\nWell, conceptually that's a different concept. Whether we want to implement that in the same structure (advantage: code reuse, disadvantage: increased complexity, possibly efficiency loss) is an engineering call. Again, for one use case I think it's not worth it. Should we find the need more often for such \"fully weak associations\" (we found the coercion system has tables that are a bit like this) we can reconsider.\n\nAt the moment I'm getting a feeling we're entering the realm of overengineering.",
    "created_at": "2013-02-26T17:33:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173897",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:22 SimonKing]:

(just saw your new post. Definitely an option. If you see merit I'm fine with that. Below response I wrote to your earlier message)

> I thought you diagnosed that this was the cause of one problem we saw?

No, what I'm pretty sure we saw at some point was GC *happening* during dictionary value setting. While looking at the code I noticed this callback without proof that it's safe.

> 1. Some parent X, Y give rise to a homset H, in a category C.
> 2. H and X get deleted, but the callbacks are not performed yet. A new parent X2 is created, and by mere coincidence we have id(X)==id(X2).
> 3. The homset H2 with respect to X2, Y and C is created. It thus overrides H in the cache.
> 4. Finally, the callback of H is performed, erasing H2 from the cache. Boom


Yes, that's exactly the scenario I envisaged. I don't have a proof that this is theoretically possible, though.

The weakref to X is referenced by this dictionary that is still in use, so it's not garbage. I think that means the callback to X is guaranteed to happen before deallocation of X (and hence before the creation of X2). Furthermore X can only be found to be garbage if H is found to be garbage (because of the strong `domain` reference), so the callback on H has to happen in the same GC as the deallocation of X. So as long as we're not creating parents during callbacks, I think that also means X2 cannot be created in the same memory location as X while the callback on H hasn't happened yet.

So we have a choice:
- make a very involved argument, carefully reasoning about the specifics of python's GC system (for which we don't actually have a formal axiom system)
- be on the safe side and just put in a cheap test.

> Do you prefer that I erase this statement?


perhaps "race condition we couldn't quite rule out"

> Thinking of it: Suppose we are now considering the callback of X, which, in the above scenario, has not been called prior to the creation of X2. Would it not delete the new item, too? So, shouldn't we add a test in `TripleDictEraser.__call__(self, r)`, so that an item is deleted only if one of the references from the keys of this item is identical with r?


No, in order to set the value, the caller must be holding strong references to the keys. As far as I know, weakref callback and deallocation only get separated inside GC. So as long as we're not calling set in callbacks, I think we're prevented from it (note that for H we needed, in addition, that H holds a reference to X AND that key triples do not get reassigned.)

> I wouldn't like to put this into `TripleDict`. After all, it is impossible to prevent all thinkable typing mistakes.


Well, this is one where you have to type the same data *twice*. But I agree: We have only one use case. Should we get more I think it's worth reconsidering.

> Additional idea: We could create TripleDict with an optional parameter weak_values. If this parameter is True, then the set/get methods would automatically use a weak reference on the value, with the correct key for the callback. Hence, we do not need to exploit implementation details when we apply a triple dict with weak values in sage.categories.homset


Well, conceptually that's a different concept. Whether we want to implement that in the same structure (advantage: code reuse, disadvantage: increased complexity, possibly efficiency loss) is an engineering call. Again, for one use case I think it's not worth it. Should we find the need more often for such "fully weak associations" (we found the coercion system has tables that are a bit like this) we can reconsider.

At the moment I'm getting a feeling we're entering the realm of overengineering.



---

archive/issue_comments_173898.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-02-26T17:49:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173898",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_173899.json:
```json
{
    "body": "Replying to [comment:26 nbruin]:\n> At the moment I'm getting a feeling we're entering the realm of overengineering.\n\n\nThat's quite possible. But the changes were rather mild, and so I am submitting my patch anyway.\n\nDo you think it is overengineered? We should of course test if the performance drops too much.\n\nAnd we need to run the test suite (I didn't, yet).\n\nApply trac_14159_weak_value_triple_dict.patch",
    "created_at": "2013-02-26T17:49:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173899",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:26 nbruin]:
> At the moment I'm getting a feeling we're entering the realm of overengineering.


That's quite possible. But the changes were rather mild, and so I am submitting my patch anyway.

Do you think it is overengineered? We should of course test if the performance drops too much.

And we need to run the test suite (I didn't, yet).

Apply trac_14159_weak_value_triple_dict.patch



---

archive/issue_comments_173900.json:
```json
{
    "body": "I was just wondering whether a `MonoDict  with weak values really makes sense. After all, it means: If you do `M[a]=b`, then this item will be deleted, unless you keep a strong reference to both a and b. But then you probably don't need a dictionary.\n\nAnyway, I think the implementation for the `TripleDict` case makes sense.",
    "created_at": "2013-02-26T18:55:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173900",
    "user": "https://github.com/simon-king-jena"
}
```

I was just wondering whether a `MonoDict  with weak values really makes sense. After all, it means: If you do `M[a]=b`, then this item will be deleted, unless you keep a strong reference to both a and b. But then you probably don't need a dictionary.

Anyway, I think the implementation for the `TripleDict` case makes sense.



---

archive/issue_comments_173901.json:
```json
{
    "body": "Replying to [comment:28 SimonKing]:\n> I was just wondering whether a `MonoDict  with weak values really makes sense. After all, it means: If you do `M[a]=b`, then this item will be deleted, unless you keep a strong reference to both a and b.\n\n\nNot so much because of the requirement for strong references (with weak caching, the idea is that *unknown* entities are still holding references), but more because in that case you might as well spell it\n\n```\na.M=weakref(b)\n```\nIncidentally, see #14058 for another use case where weakrefs (without callbacks there!) get stored in a `TripleDict`. So that seems to be a strong indication that supporting weak values is indeed a reasonable think for it. I would propose to amend the solution there to use the facilities here and make #14058 depend on #14159. Provided the code here all checks out to work as expected and perform well, of course.",
    "created_at": "2013-02-26T19:31:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173901",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:28 SimonKing]:
> I was just wondering whether a `MonoDict  with weak values really makes sense. After all, it means: If you do `M[a]=b`, then this item will be deleted, unless you keep a strong reference to both a and b.


Not so much because of the requirement for strong references (with weak caching, the idea is that *unknown* entities are still holding references), but more because in that case you might as well spell it

```
a.M=weakref(b)
```
Incidentally, see #14058 for another use case where weakrefs (without callbacks there!) get stored in a `TripleDict`. So that seems to be a strong indication that supporting weak values is indeed a reasonable think for it. I would propose to amend the solution there to use the facilities here and make #14058 depend on #14159. Provided the code here all checks out to work as expected and perform well, of course.



---

archive/issue_comments_173902.json:
```json
{
    "body": "I still have not the faintest idea how to interpret the results of the startup_time plugin. Can someone please give me a pointer?",
    "created_at": "2013-02-26T21:13:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173902",
    "user": "https://github.com/simon-king-jena"
}
```

I still have not the faintest idea how to interpret the results of the startup_time plugin. Can someone please give me a pointer?



---

archive/issue_comments_173903.json:
```json
{
    "body": "Replying to [comment:30 SimonKing]:\n> I still have not the faintest idea how to interpret the results of the startup_time plugin. Can someone please give me a pointer?\n\n\nWhile it's probably measuring something significant, I don't think the process properly controls for other factors. I've seen significant (consistent) timing differences between different *compiles* of exactly the same sage (i.e., after `hg qpop; sage -b; hg qpush; sage -b`) on the same computer. The only thing I can think of for something like that is getting lucky/unlucky how certain libraries get laid out in memory. The differences it's reporting are so small that I think one cannot rule out such factors (the reference build being \"lucky\" and the patch build being \"unlucky\").",
    "created_at": "2013-02-26T21:23:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173903",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:30 SimonKing]:
> I still have not the faintest idea how to interpret the results of the startup_time plugin. Can someone please give me a pointer?


While it's probably measuring something significant, I don't think the process properly controls for other factors. I've seen significant (consistent) timing differences between different *compiles* of exactly the same sage (i.e., after `hg qpop; sage -b; hg qpush; sage -b`) on the same computer. The only thing I can think of for something like that is getting lucky/unlucky how certain libraries get laid out in memory. The differences it's reporting are so small that I think one cannot rule out such factors (the reference build being "lucky" and the patch build being "unlucky").



---

archive/issue_comments_173904.json:
```json
{
    "body": "I could get the meaning if it would say: \"With 98% confidence, the startup time of sage-5.8.beta1+#14159 is at least 0.1% bigger than the startup time of sage-5.8.beta1.\" But the plugin does not seem to make such statements.\n\nInstead, looking at the diff, one sees\n\n```\n--- 5.8.beta1 \n\n+++ 5.8.beta1 + #14159 \n...\n-Main:   0.70703 sec (30 samples, std_dev=0.0174)\n-Ticket: 0.71392 sec (30 samples, std_dev=0.0296)\n+Main:   0.66585 sec (30 samples, std_dev=0.00636)\n+Ticket: 0.67404 sec (30 samples, std_dev=0.0354)\n\n-Average increase of 0.0069 secs or 0.97%.\n+Average increase of 0.0082 secs or 1.2%.\n\n-With 52% confidence, startup time increased by at least 0.5%\n-With 72% confidence, startup time increased by at least 0.25%\n-With 83% confidence, startup time increased by at least 0.1%\n+With 36% confidence, startup time increased by at least 0.5%\n+With 86% confidence, startup time increased by at least 0.25%\n+With 98% confidence, startup time increased by at least 0.1%\n```\nSo, in vanilla sage, one has 83% confidence of getting an increase of startup time by at least 0.1%---but increase with respect to what? This is what I don't understand.",
    "created_at": "2013-02-26T21:36:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173904",
    "user": "https://github.com/simon-king-jena"
}
```

I could get the meaning if it would say: "With 98% confidence, the startup time of sage-5.8.beta1+#14159 is at least 0.1% bigger than the startup time of sage-5.8.beta1." But the plugin does not seem to make such statements.

Instead, looking at the diff, one sees

```
--- 5.8.beta1 

+++ 5.8.beta1 + #14159 
...
-Main:   0.70703 sec (30 samples, std_dev=0.0174)
-Ticket: 0.71392 sec (30 samples, std_dev=0.0296)
+Main:   0.66585 sec (30 samples, std_dev=0.00636)
+Ticket: 0.67404 sec (30 samples, std_dev=0.0354)

-Average increase of 0.0069 secs or 0.97%.
+Average increase of 0.0082 secs or 1.2%.

-With 52% confidence, startup time increased by at least 0.5%
-With 72% confidence, startup time increased by at least 0.25%
-With 83% confidence, startup time increased by at least 0.1%
+With 36% confidence, startup time increased by at least 0.5%
+With 86% confidence, startup time increased by at least 0.25%
+With 98% confidence, startup time increased by at least 0.1%
```
So, in vanilla sage, one has 83% confidence of getting an increase of startup time by at least 0.1%---but increase with respect to what? This is what I don't understand.



---

archive/issue_comments_173905.json:
```json
{
    "body": "I have run `sage -startuptime` both with and without the patch. The strange result:\n\n- Without the patch, the import of `_ssl` is listed with 3.397ms. But with the patch, `_ssl` is not listed.\n- With the patch, the import of `sage.plot.graphics` is listed with 21.036ms. But without the patch, `sage.plot.graphics` is not listed.\n\nI can neither believe that `sage.plot.graphics` is not imported during startup in vanilla sage, nor can I believe that `sage.plot.graphics` is imported just because of changing  the intestines of coercion dictionaries.\n\nBug in the startuptime script?",
    "created_at": "2013-02-27T07:27:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173905",
    "user": "https://github.com/simon-king-jena"
}
```

I have run `sage -startuptime` both with and without the patch. The strange result:

- Without the patch, the import of `_ssl` is listed with 3.397ms. But with the patch, `_ssl` is not listed.
- With the patch, the import of `sage.plot.graphics` is listed with 21.036ms. But without the patch, `sage.plot.graphics` is not listed.

I can neither believe that `sage.plot.graphics` is not imported during startup in vanilla sage, nor can I believe that `sage.plot.graphics` is imported just because of changing  the intestines of coercion dictionaries.

Bug in the startuptime script?



---

archive/issue_comments_173906.json:
```json
{
    "body": "PS: The time spent for including sage.plot.graphics is nearly equal to the difference of the total startup times that I get with and without the patch. Hence, it could explain why the plugin complains.",
    "created_at": "2013-02-27T07:35:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173906",
    "user": "https://github.com/simon-king-jena"
}
```

PS: The time spent for including sage.plot.graphics is nearly equal to the difference of the total startup times that I get with and without the patch. Hence, it could explain why the plugin complains.



---

archive/issue_comments_173907.json:
```json
{
    "body": "For the record, the startuptime patchbot plugin compares ticket vs. no ticket. So the 0.1% increase is relative to not applying the patch on the ticket.",
    "created_at": "2013-02-27T09:54:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173907",
    "user": "https://github.com/vbraun"
}
```

For the record, the startuptime patchbot plugin compares ticket vs. no ticket. So the 0.1% increase is relative to not applying the patch on the ticket.



---

archive/issue_comments_173908.json:
```json
{
    "body": "Replying to [comment:35 vbraun]:\n> For the record, the startuptime patchbot plugin compares ticket vs. no ticket. So the 0.1% increase is relative to not applying the patch on the ticket.\n\n\nSure that should be the case. But, as you see, the plugin provides a diff \"no ticket\" versus \"ticket\". And according to the diff, \"With 83% confidence, startup time increased by at least 0.1%\" **without** ticket. So, is the point that 83% is not significant?\n\nHence, does the plugin state the following?\n\n\"Without the patch, there is no statistical evidence for a 0.1% increase of startup time. With the patch, there *is* statistical evidence for a 0.1% increase.\"?",
    "created_at": "2013-02-27T10:33:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173908",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:35 vbraun]:
> For the record, the startuptime patchbot plugin compares ticket vs. no ticket. So the 0.1% increase is relative to not applying the patch on the ticket.


Sure that should be the case. But, as you see, the plugin provides a diff "no ticket" versus "ticket". And according to the diff, "With 83% confidence, startup time increased by at least 0.1%" **without** ticket. So, is the point that 83% is not significant?

Hence, does the plugin state the following?

"Without the patch, there is no statistical evidence for a 0.1% increase of startup time. With the patch, there *is* statistical evidence for a 0.1% increase."?



---

archive/issue_comments_173909.json:
```json
{
    "body": "Note that in the most recent run, the startup time plugin did actually *not* complain!\n\nNevertheless, I think we should care about speed. I see two approaches to improve the startup time, the second of them would improve the general performance.\n\n1. I found that a dozen of homsets are created *and* deleted during startup. One should find where they are created, and see whether their creation is really needed or whether one can avoid that the get deleted.\n2. `MonoDict` and `TripleDict` have fast cdef set and get methods, but they are not always used. At least in Cython modules, we should try to find all locations which could benefit from replacing `T[a,b,c]` by `T.get(a,b,c)`. And even for Python modules, I think it would make sense to turn the cdef get and set methods into cpdef get and set methods: I guess it would still be faster then `T[a,b,c]`, because one avoids the test\n   {{{\n        try:\n            k1, k2, k3 = k\n        except (TypeError,ValueError):\n            raise KeyError, k\n   }}}",
    "created_at": "2013-02-28T20:54:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173909",
    "user": "https://github.com/simon-king-jena"
}
```

Note that in the most recent run, the startup time plugin did actually *not* complain!

Nevertheless, I think we should care about speed. I see two approaches to improve the startup time, the second of them would improve the general performance.

1. I found that a dozen of homsets are created *and* deleted during startup. One should find where they are created, and see whether their creation is really needed or whether one can avoid that the get deleted.
2. `MonoDict` and `TripleDict` have fast cdef set and get methods, but they are not always used. At least in Cython modules, we should try to find all locations which could benefit from replacing `T[a,b,c]` by `T.get(a,b,c)`. And even for Python modules, I think it would make sense to turn the cdef get and set methods into cpdef get and set methods: I guess it would still be faster then `T[a,b,c]`, because one avoids the test
   {{{
        try:
            k1, k2, k3 = k
        except (TypeError,ValueError):
            raise KeyError, k
   }}}



---

archive/issue_comments_173910.json:
```json
{
    "body": "Replying to [comment:38 SimonKing]:\n> 1. I found that a dozen of homsets are created *and* deleted during startup. One should find where they are created, and see whether their creation is really needed or whether one can avoid that the get deleted.\n\n\n\"Premature optimization is the root of all evil\" [Knuth]. Does their creation and deletion add considerably to the startup time? I would expect that this gets dwarfed by all the work involved in constructing class instances and resizing the globals dictionary.\n\n> 2. `MonoDict` and `TripleDict` have fast cdef set and get methods, but they are not always used. At least in Cython modules, we should try to find all locations which could benefit from replacing `T[a,b,c]` by `T.get(a,b,c)`. And even for Python modules, I think it would make sense to turn the cdef get and set methods into cpdef get and set methods: I guess it would still be faster then `T[a,b,c]`, because one avoids the test\n\n\nProbably not: The `__setitem__` and `__getitem__` lookups in python likely happen faster than normal method lookups in python, because the special methods are stored in slots, whereas normal method lookups have to resort to dictionary lookups. That might well cancel the packing/unpacking that needs to happen for the key (which isn't necessary for `MonoDict` at all, by the way).\n\nI think to do optimizations with best productivity:\n- locate scenarios where `MonoDict` and `TripleDict` access is significant in time usage\n- Find what is creating the worst overhead.\nI'm not sure that the sage startup routine is most representative of that behaviour.\nIf the goal is improving sage startup time, the right way is probably to only import a \"stub\" notebook that offers the limited functionality from other modules (basically capable of answering \"we're not in the notebook\") and make the stub so that starting the notebook, or any other non-trivial access, results in loading and replacing the stub with the real notebook.",
    "created_at": "2013-02-28T22:54:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173910",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:38 SimonKing]:
> 1. I found that a dozen of homsets are created *and* deleted during startup. One should find where they are created, and see whether their creation is really needed or whether one can avoid that the get deleted.


"Premature optimization is the root of all evil" [Knuth]. Does their creation and deletion add considerably to the startup time? I would expect that this gets dwarfed by all the work involved in constructing class instances and resizing the globals dictionary.

> 2. `MonoDict` and `TripleDict` have fast cdef set and get methods, but they are not always used. At least in Cython modules, we should try to find all locations which could benefit from replacing `T[a,b,c]` by `T.get(a,b,c)`. And even for Python modules, I think it would make sense to turn the cdef get and set methods into cpdef get and set methods: I guess it would still be faster then `T[a,b,c]`, because one avoids the test


Probably not: The `__setitem__` and `__getitem__` lookups in python likely happen faster than normal method lookups in python, because the special methods are stored in slots, whereas normal method lookups have to resort to dictionary lookups. That might well cancel the packing/unpacking that needs to happen for the key (which isn't necessary for `MonoDict` at all, by the way).

I think to do optimizations with best productivity:
- locate scenarios where `MonoDict` and `TripleDict` access is significant in time usage
- Find what is creating the worst overhead.
I'm not sure that the sage startup routine is most representative of that behaviour.
If the goal is improving sage startup time, the right way is probably to only import a "stub" notebook that offers the limited functionality from other modules (basically capable of answering "we're not in the notebook") and make the stub so that starting the notebook, or any other non-trivial access, results in loading and replacing the stub with the real notebook.



---

archive/issue_comments_173911.json:
```json
{
    "body": "Replying to [comment:39 nbruin]:\n> \"Premature optimization is the root of all evil\" [Knuth]. Does their creation and deletion add considerably to the startup time?\n\n\nProbably not.\n\n> Probably not: The `__setitem__` and `__getitem__` lookups in python likely happen faster than normal method lookups in python, because the special methods are stored in slots, whereas normal method lookups have to resort to dictionary lookups.\n\n\nOK. That's calling overhead versus avoiding an additional test. That would be easy to test.\n\nBut at least in cython modules, when one uses cdef'd variables of type `MonoDict` or `TripleDict`, using a cdef or cpdef set/get method directly should be faster than calling `__set/getitem__`, isn't it?",
    "created_at": "2013-02-28T23:22:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173911",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:39 nbruin]:
> "Premature optimization is the root of all evil" [Knuth]. Does their creation and deletion add considerably to the startup time?


Probably not.

> Probably not: The `__setitem__` and `__getitem__` lookups in python likely happen faster than normal method lookups in python, because the special methods are stored in slots, whereas normal method lookups have to resort to dictionary lookups.


OK. That's calling overhead versus avoiding an additional test. That would be easy to test.

But at least in cython modules, when one uses cdef'd variables of type `MonoDict` or `TripleDict`, using a cdef or cpdef set/get method directly should be faster than calling `__set/getitem__`, isn't it?



---

archive/issue_comments_173912.json:
```json
{
    "body": "Replying to [comment:40 SimonKing]:\n> But at least in cython modules, when one uses cdef'd variables of type `MonoDict` or `TripleDict`, using a cdef or cpdef set/get method directly should be faster than calling `__set/getitem__`, isn't it?\n\n\nOnly because it's using the `cdef` part then, I think.",
    "created_at": "2013-02-28T23:25:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173912",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:40 SimonKing]:
> But at least in cython modules, when one uses cdef'd variables of type `MonoDict` or `TripleDict`, using a cdef or cpdef set/get method directly should be faster than calling `__set/getitem__`, isn't it?


Only because it's using the `cdef` part then, I think.



---

archive/issue_comments_173913.json:
```json
{
    "body": "Replying to [comment:41 nbruin]:\n> Replying to [comment:40 SimonKing]:\n> > But at least in cython modules, when one uses cdef'd variables of type `MonoDict` or `TripleDict`, using a cdef or cpdef set/get method directly should be faster than calling `__set/getitem__`, isn't it?\n\n> \n> Only because it's using the `cdef` part then, I think.\n\n\n\"Only\" or not: If it is faster then it should be used.\n\nAnd I don't think it is \"only\" cdef. It is also the `set/get` expects a fixed number of arguments, while in `__set/getitem__` the given arguments are put into a tuple, need to be unpacked, the length of the tuple must be checked. So, set/get could be faster anyway.\n\nI am now testing---as soon as half of the Sage library is rebuilt. I hate patches touching coerce_dict.pxd!!!",
    "created_at": "2013-02-28T23:33:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173913",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:41 nbruin]:
> Replying to [comment:40 SimonKing]:
> > But at least in cython modules, when one uses cdef'd variables of type `MonoDict` or `TripleDict`, using a cdef or cpdef set/get method directly should be faster than calling `__set/getitem__`, isn't it?

> 
> Only because it's using the `cdef` part then, I think.


"Only" or not: If it is faster then it should be used.

And I don't think it is "only" cdef. It is also the `set/get` expects a fixed number of arguments, while in `__set/getitem__` the given arguments are put into a tuple, need to be unpacked, the length of the tuple must be checked. So, set/get could be faster anyway.

I am now testing---as soon as half of the Sage library is rebuilt. I hate patches touching coerce_dict.pxd!!!



---

archive/issue_comments_173914.json:
```json
{
    "body": "```\n%cython\ncdef class dictest(object):\n    cpdef get(self,int k1,int k2,int k3):\n        if k1==1 and k2==1 and k3==1:\n            return True\n        else:\n            return False\n    def __getitem__(self,k):\n        cdef int k1,k2,k3\n        try:\n            k1,k2,k3=k\n        except:\n            raise KeyError\n        return self.get(k1,k2,k3)\n```\nregular method call protocol is pretty expensive:\n\n```\nsage: C=dictest()\nsage: timeit(\"C.get(1,1,1)\")\n625 loops, best of 3: 795 ns per loop\nsage: timeit(\"C[1,1,1]\")\n625 loops, best of 3: 717 ns per loop\n```\n(but of course, from cython, one should absolutely use the cdef form)",
    "created_at": "2013-03-01T00:17:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173914",
    "user": "https://github.com/nbruin"
}
```

```
%cython
cdef class dictest(object):
    cpdef get(self,int k1,int k2,int k3):
        if k1==1 and k2==1 and k3==1:
            return True
        else:
            return False
    def __getitem__(self,k):
        cdef int k1,k2,k3
        try:
            k1,k2,k3=k
        except:
            raise KeyError
        return self.get(k1,k2,k3)
```
regular method call protocol is pretty expensive:

```
sage: C=dictest()
sage: timeit("C.get(1,1,1)")
625 loops, best of 3: 795 ns per loop
sage: timeit("C[1,1,1]")
625 loops, best of 3: 717 ns per loop
```
(but of course, from cython, one should absolutely use the cdef form)



---

archive/issue_comments_173915.json:
```json
{
    "body": "Some other timings, making set/get cpdef:\n\n```\nsage: from sage.structure.coerce_dict import TripleDict, MonoDict\nsage: R = [Integers(n) for n in range(1,10^4)]\nsage: T = TripleDict(53)\nsage: M = MonoDict(53)\nsage: def test_py_getitem(T,R):\n    for x in R:\n        T[R,R,R] = 1\n    for x in R:\n        _ = T[R,R,R]\n....:         \nsage: def test_py_get(T,R):\n    for x in R:         \n        T.set(R,R,R, 1)\n    for x in R:\n        _ = T.get(R,R,R)\n....:         \nsage: cython(\"\"\"\nfrom sage.structure.coerce_dict cimport TripleDict\ndef test_cy_getitem(TripleDict T,R):\n    for x in R:\n        T[R,R,R] = 1\n    for x in R:\n        _ = T[R,R,R]\n\"\"\")\n....: \nsage: cython(\"\"\"\nfrom sage.structure.coerce_dict cimport TripleDict\ndef test_cy_get(TripleDict T,R):\n    for x in R:\n        T.set(R,R,R, 1)\n    for x in R:\n        _ = T.get(R,R,R)\n\"\"\")\n....: \nsage: %time test_py_getitem(T,R)\nCPU times: user 0.03 s, sys: 0.01 s, total: 0.04 s\nWall time: 0.04 s\nsage: %timeit test_py_getitem(T,R)\n10 loops, best of 3: 23.9 ms per loop\nsage: %timeit test_py_getitem(T,R)\n10 loops, best of 3: 23.5 ms per loop\nsage: %timeit test_py_getitem(T,R)\n10 loops, best of 3: 23.6 ms per loop\nsage: %timeit test_py_get(T,R)\n10 loops, best of 3: 24.6 ms per loop\nsage: %timeit test_py_get(T,R)\n10 loops, best of 3: 24.3 ms per loop\nsage: %timeit test_py_get(T,R)\n10 loops, best of 3: 24.3 ms per loop\nsage: %timeit test_cy_getitem(T,R)\n10 loops, best of 3: 19.9 ms per loop\nsage: %timeit test_cy_getitem(T,R)\n100 loops, best of 3: 19.9 ms per loop\nsage: %timeit test_cy_getitem(T,R)\n100 loops, best of 3: 19.6 ms per loop\nsage: %timeit test_cy_get(T,R)\n100 loops, best of 3: 17.9 ms per loop\nsage: %timeit test_cy_get(T,R)\n100 loops, best of 3: 18 ms per loop\nsage: %timeit test_cy_get(T,R)\n100 loops, best of 3: 18.3 ms per loop\n```\n\nHence, I can confirm that in Python one better relies on the magical methods, while in cython it is better (but not *much* better!) to use the cpdef methods.\n\nBut in fact, I found some spots in parent_old.pyx that *are* used and call the magical methods.",
    "created_at": "2013-03-01T07:04:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173915",
    "user": "https://github.com/simon-king-jena"
}
```

Some other timings, making set/get cpdef:

```
sage: from sage.structure.coerce_dict import TripleDict, MonoDict
sage: R = [Integers(n) for n in range(1,10^4)]
sage: T = TripleDict(53)
sage: M = MonoDict(53)
sage: def test_py_getitem(T,R):
    for x in R:
        T[R,R,R] = 1
    for x in R:
        _ = T[R,R,R]
....:         
sage: def test_py_get(T,R):
    for x in R:         
        T.set(R,R,R, 1)
    for x in R:
        _ = T.get(R,R,R)
....:         
sage: cython("""
from sage.structure.coerce_dict cimport TripleDict
def test_cy_getitem(TripleDict T,R):
    for x in R:
        T[R,R,R] = 1
    for x in R:
        _ = T[R,R,R]
""")
....: 
sage: cython("""
from sage.structure.coerce_dict cimport TripleDict
def test_cy_get(TripleDict T,R):
    for x in R:
        T.set(R,R,R, 1)
    for x in R:
        _ = T.get(R,R,R)
""")
....: 
sage: %time test_py_getitem(T,R)
CPU times: user 0.03 s, sys: 0.01 s, total: 0.04 s
Wall time: 0.04 s
sage: %timeit test_py_getitem(T,R)
10 loops, best of 3: 23.9 ms per loop
sage: %timeit test_py_getitem(T,R)
10 loops, best of 3: 23.5 ms per loop
sage: %timeit test_py_getitem(T,R)
10 loops, best of 3: 23.6 ms per loop
sage: %timeit test_py_get(T,R)
10 loops, best of 3: 24.6 ms per loop
sage: %timeit test_py_get(T,R)
10 loops, best of 3: 24.3 ms per loop
sage: %timeit test_py_get(T,R)
10 loops, best of 3: 24.3 ms per loop
sage: %timeit test_cy_getitem(T,R)
10 loops, best of 3: 19.9 ms per loop
sage: %timeit test_cy_getitem(T,R)
100 loops, best of 3: 19.9 ms per loop
sage: %timeit test_cy_getitem(T,R)
100 loops, best of 3: 19.6 ms per loop
sage: %timeit test_cy_get(T,R)
100 loops, best of 3: 17.9 ms per loop
sage: %timeit test_cy_get(T,R)
100 loops, best of 3: 18 ms per loop
sage: %timeit test_cy_get(T,R)
100 loops, best of 3: 18.3 ms per loop
```

Hence, I can confirm that in Python one better relies on the magical methods, while in cython it is better (but not *much* better!) to use the cpdef methods.

But in fact, I found some spots in parent_old.pyx that *are* used and call the magical methods.



---

archive/issue_comments_173916.json:
```json
{
    "body": "I have added a new patch, that will hopefully make Sage a little faster. This is by using the cdef set/get methods everywhere in cython. The only spot that is using the magical methods i sage/categories/homset, which currently is python. Perhaps it should be cythoned? Since homsets are in the background for every conversion and coercion, this could be of some benefit.\n\nApply trac_14159_weak_value_triple_dict.patch trac_14159_use_cdef_get.patch",
    "created_at": "2013-03-01T07:41:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173916",
    "user": "https://github.com/simon-king-jena"
}
```

I have added a new patch, that will hopefully make Sage a little faster. This is by using the cdef set/get methods everywhere in cython. The only spot that is using the magical methods i sage/categories/homset, which currently is python. Perhaps it should be cythoned? Since homsets are in the background for every conversion and coercion, this could be of some benefit.

Apply trac_14159_weak_value_triple_dict.patch trac_14159_use_cdef_get.patch



---

archive/issue_comments_173917.json:
```json
{
    "body": "PS: In any case, cythoning sage.categories.homset should be on a different ticket.",
    "created_at": "2013-03-01T07:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173917",
    "user": "https://github.com/simon-king-jena"
}
```

PS: In any case, cythoning sage.categories.homset should be on a different ticket.



---

archive/issue_comments_173918.json:
```json
{
    "body": "Note that different patchbots show different results for the plugins: One patchbot, running sage-5.8.beta2, does not complain at all. Another one, running sage-5.8.beta1, complains both for startup_modules and startup_time.",
    "created_at": "2013-03-01T09:44:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173918",
    "user": "https://github.com/simon-king-jena"
}
```

Note that different patchbots show different results for the plugins: One patchbot, running sage-5.8.beta2, does not complain at all. Another one, running sage-5.8.beta1, complains both for startup_modules and startup_time.



---

archive/issue_comments_173919.json:
```json
{
    "body": "Replying to [comment:47 SimonKing]:\n> Note that different patchbots show different results for the plugins: One patchbot, running sage-5.8.beta2, does not complain at all.\n\nFor the startup module I think that's because 5.8b2 has #13387 merged (for now at least).",
    "created_at": "2013-03-01T17:27:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173919",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:47 SimonKing]:
> Note that different patchbots show different results for the plugins: One patchbot, running sage-5.8.beta2, does not complain at all.

For the startup module I think that's because 5.8b2 has #13387 merged (for now at least).



---

archive/issue_comments_173920.json:
```json
{
    "body": "#14254 is a blocker that will likely to be merged before this ticket here is positively reviewed. Hence, it will be a dependency.\n\nQuestion: Shall we remove the new function signed_id introduced in #14254? It is not needed with the approach that we take here. Alternatively, we could apply it. How much is the overhead of calling a cpdef inline function doing `<Py_ssize_t><void *>(x)`, compared without doing it directly?",
    "created_at": "2013-03-11T16:34:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173920",
    "user": "https://github.com/simon-king-jena"
}
```

#14254 is a blocker that will likely to be merged before this ticket here is positively reviewed. Hence, it will be a dependency.

Question: Shall we remove the new function signed_id introduced in #14254? It is not needed with the approach that we take here. Alternatively, we could apply it. How much is the overhead of calling a cpdef inline function doing `<Py_ssize_t><void *>(x)`, compared without doing it directly?



---

archive/issue_comments_173921.json:
```json
{
    "body": "Apparently there is no significant difference:\n\n```\nsage: cython(\"\"\"\ncdef inline Py_ssize_t signed_id(object X):\n    <Py_ssize_t><void *>(X)\nfrom sage.all import srange\ndef testcall():\n    cdef object i\n    for i in srange(10^6):\n        a = signed_id(i)\ndef testdirect():\n    cdef object i\n    for i in srange(10^6):\n        a = <Py_ssize_t><void *>(i)\n\"\"\")\nsage: %timeit testcall()\n10000 loops, best of 3: 87.2 us per loop\nsage: %timeit testdirect()\n10000 loops, best of 3: 87 us per loop\n```",
    "created_at": "2013-03-11T16:38:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173921",
    "user": "https://github.com/simon-king-jena"
}
```

Apparently there is no significant difference:

```
sage: cython("""
cdef inline Py_ssize_t signed_id(object X):
    <Py_ssize_t><void *>(X)
from sage.all import srange
def testcall():
    cdef object i
    for i in srange(10^6):
        a = signed_id(i)
def testdirect():
    cdef object i
    for i in srange(10^6):
        a = <Py_ssize_t><void *>(i)
""")
sage: %timeit testcall()
10000 loops, best of 3: 87.2 us per loop
sage: %timeit testdirect()
10000 loops, best of 3: 87 us per loop
```



---

archive/issue_comments_173922.json:
```json
{
    "body": "Replying to [comment:49 SimonKing]:\n> Question: Shall we remove the new function signed_id introduced in #14254? It is not needed with the approach that we take here. Alternatively, we could apply it. How much is the overhead of calling a cpdef inline function doing `<Py_ssize_t><void *>(x)`, compared without doing it directly?\n\n\nIt's `inline`, so using it in a place where the `cdef` part is used should be 0 overhead. The `inline` should get expanded before the optimizer even looks at the code. The whole point of `inline` is to get the performance of `#define` macros without the headaches.\n\nIf the function is not really in the way, it may be worth keeping around. I have found it immensely useful for debugging `cython` code if as much features as possible are also exposed in python. In particular, the `cdef` only data attributes can be a real pain.",
    "created_at": "2013-03-11T16:42:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173922",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:49 SimonKing]:
> Question: Shall we remove the new function signed_id introduced in #14254? It is not needed with the approach that we take here. Alternatively, we could apply it. How much is the overhead of calling a cpdef inline function doing `<Py_ssize_t><void *>(x)`, compared without doing it directly?


It's `inline`, so using it in a place where the `cdef` part is used should be 0 overhead. The `inline` should get expanded before the optimizer even looks at the code. The whole point of `inline` is to get the performance of `#define` macros without the headaches.

If the function is not really in the way, it may be worth keeping around. I have found it immensely useful for debugging `cython` code if as much features as possible are also exposed in python. In particular, the `cdef` only data attributes can be a real pain.



---

archive/issue_comments_173923.json:
```json
{
    "body": "Replying to [comment:51 nbruin]:\n> If the function is not really in the way, it may be worth keeping around. I have found it immensely useful for debugging `cython` code if as much features as possible are also exposed in python. In particular, the `cdef` only data attributes can be a real pain.\n\n\n+5\n\nSo, let's keep it (it is cpdef anyway, hence, can be used from Python as well), and apparently it is fast enough (in the example above I had \"cdef inline\", but \"cpdef inline\" gives the same timings).",
    "created_at": "2013-03-11T16:59:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173923",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:51 nbruin]:
> If the function is not really in the way, it may be worth keeping around. I have found it immensely useful for debugging `cython` code if as much features as possible are also exposed in python. In particular, the `cdef` only data attributes can be a real pain.


+5

So, let's keep it (it is cpdef anyway, hence, can be used from Python as well), and apparently it is fast enough (in the example above I had "cdef inline", but "cpdef inline" gives the same timings).



---

archive/issue_comments_173924.json:
```json
{
    "body": "The first patch needed to be rebased, the second was still fine.\n\nApply trac_14159_weak_value_triple_dict.patch trac_14159_use_cdef_get.patch",
    "created_at": "2013-03-11T18:13:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173924",
    "user": "https://github.com/simon-king-jena"
}
```

The first patch needed to be rebased, the second was still fine.

Apply trac_14159_weak_value_triple_dict.patch trac_14159_use_cdef_get.patch



---

archive/issue_comments_173925.json:
```json
{
    "body": "Optional weak values for mono- and tripledict",
    "created_at": "2013-03-11T18:19:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173925",
    "user": "https://github.com/simon-king-jena"
}
```

Optional weak values for mono- and tripledict



---

archive/issue_comments_173926.json:
```json
{
    "body": "Attachment [trac_14159_weak_value_triple_dict.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159_weak_value_triple_dict.patch) by @simon-king-jena created at 2013-03-11 18:20:31\n\nI needed another update of the patch: #14254 has introduced signed_id, which is imported in homset.py, but with the approach from here, we do not need to import signed_id. Hence, I removed the import statement in the current version of the patch.\n\nApply trac_14159_weak_value_triple_dict.patch trac_14159_use_cdef_get.patch",
    "created_at": "2013-03-11T18:20:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173926",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_14159_weak_value_triple_dict.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159_weak_value_triple_dict.patch) by @simon-king-jena created at 2013-03-11 18:20:31

I needed another update of the patch: #14254 has introduced signed_id, which is imported in homset.py, but with the approach from here, we do not need to import signed_id. Hence, I removed the import statement in the current version of the patch.

Apply trac_14159_weak_value_triple_dict.patch trac_14159_use_cdef_get.patch



---

archive/issue_comments_173927.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-04-04T18:28:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173927",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_173928.json:
```json
{
    "body": "Good stuff! Much cleaner. Patchbot is happy and effectively this patch consolidates some use of `TripleDict` that was already in ad-hoc use, so there is not too much chance for unexpected failures. The solution here does solve the \"manual\" installation of callbacks that was dangerous before and in includes a sanity check that the object on which the callback is happening is indeed still referring to the (now dead) weakref that is causing the callback.",
    "created_at": "2013-04-04T18:28:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173928",
    "user": "https://github.com/nbruin"
}
```

Good stuff! Much cleaner. Patchbot is happy and effectively this patch consolidates some use of `TripleDict` that was already in ad-hoc use, so there is not too much chance for unexpected failures. The solution here does solve the "manual" installation of callbacks that was dangerous before and in includes a sanity check that the object on which the callback is happening is indeed still referring to the (now dead) weakref that is causing the callback.



---

archive/issue_comments_173929.json:
```json
{
    "body": "Replying to [comment:51 nbruin]:\n> The `inline` should get expanded before the optimizer even looks at the code.\n\nThat's not entirely true, at least not with GCC. The `inline` keyword is just one of the things that GCC considers to decide whether or not to inline a function. Very simple functions like `signed_id()` might very will be always inlined at higher optimization levels, while complicated functions might never be inlined (even if marked `inline`).",
    "created_at": "2013-04-04T18:59:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173929",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:51 nbruin]:
> The `inline` should get expanded before the optimizer even looks at the code.

That's not entirely true, at least not with GCC. The `inline` keyword is just one of the things that GCC considers to decide whether or not to inline a function. Very simple functions like `signed_id()` might very will be always inlined at higher optimization levels, while complicated functions might never be inlined (even if marked `inline`).



---

archive/issue_events_039960.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-05T13:35:19Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "milestone": "sage-5.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13955#event-39960"
}
```



---

archive/issue_comments_173930.json:
```json
{
    "body": "[attachment:trac_14159_use_cdef_get.patch] needs a proper commit message",
    "created_at": "2013-04-08T07:10:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173930",
    "user": "https://github.com/jdemeyer"
}
```

[attachment:trac_14159_use_cdef_get.patch] needs a proper commit message



---

archive/issue_comments_173931.json:
```json
{
    "body": "Use cdef get/set methods of `MonoDict` and `TripleDict` in cython modules",
    "created_at": "2013-04-08T08:08:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173931",
    "user": "https://github.com/simon-king-jena"
}
```

Use cdef get/set methods of `MonoDict` and `TripleDict` in cython modules



---

archive/issue_comments_173932.json:
```json
{
    "body": "Attachment [trac_14159_use_cdef_get.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159_use_cdef_get.patch) by @simon-king-jena created at 2013-04-08 08:09:15\n\nMessage added.",
    "created_at": "2013-04-08T08:09:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173932",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_14159_use_cdef_get.patch](tarball://root/attachments/some-uuid/ticket14159/trac_14159_use_cdef_get.patch) by @simon-king-jena created at 2013-04-08 08:09:15

Message added.



---

archive/issue_events_039961.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-13T13:49:43Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13955#event-39961"
}
```



---

archive/issue_comments_173933.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-04-13T13:49:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13955",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13955#issuecomment-173933",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed
