# Issue 33090: variable name '@c' is not alphanumeric

Issue created by migration from https://trac.sagemath.org/ticket/33327

Original creator: mmezzarobba

Original creation time: 2022-02-12 13:58:14

CC:  slelievre

Keywords: singular

An issue reported by Anne Vaugon:

```
sage: A.<a,b,c,x,y,S> = QQbar[]
....: p = (a-x)**2+y**2-b**2
....: q = x**2 + y**2 - c**2
....: r = a*y-2*S
....: r1 = p.resultant(q,x)
....: r2 = r.resultant(r1,y)
....: factor(r2-a**2*16*S**2)
....: 
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-1-525e0b5a9cef> in <module>
      5 r1 = p.resultant(q,x)
      6 r2 = r.resultant(r1,y)
----> 7 factor(r2-a**Integer(2)*Integer(16)*S**Integer(2))

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/arith/misc.py in factor(n, proof, int_, algorithm, verbose, **kwds)
   2611     # Polynomial or other factorable object
   2612     try:
-> 2613         return m(proof=proof, **kwds)
   2614     except TypeError:
   2615         # Maybe the factor() method does not have a proof option

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/polynomial/multi_polynomial_element.py in factor(self, proof)
   1873         base_ring = self.base_ring()
   1874         if hasattr(base_ring, '_factor_multivariate_polynomial'):
-> 1875             return base_ring._factor_multivariate_polynomial(self, proof=proof)
   1876 
   1877         # try to use univariate factoring

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/qqbar.py in _factor_multivariate_polynomial(self, f, proof)
    951 
    952         for i in range(2, len(L[1])+1):
--> 953             factor = L[1][i].sage()
    954             #multiplicity = L[2][i].sage()
    955             minpoly = L[3][i].sage()

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/interfaces/interface.py in sage(self, *args, **kwds)
   1104             [0 0]
   1105         """
-> 1106         return self._sage_(*args, **kwds)
   1107 
   1108     def __repr__(self):

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/interfaces/singular.py in _sage_(self, R)
   2000         typ = self.type()
   2001         if typ=='poly':
-> 2002             return self.sage_poly(R)
   2003         elif typ=='int':
   2004             return sage.rings.integer.Integer(repr(self))

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/interfaces/singular.py in sage_poly(self, R, kcache)
   1769         if R is None:
   1770             ring_is_fine = True
-> 1771             R = self.sage_global_ring()
   1772 
   1773         if isinstance(R, QuotientRing_generic) and (ring_is_fine or can_convert_to_singular(R)):

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/interfaces/singular.py in sage_global_ring(self)
   1644             if minpoly == '0':
   1645                 from sage.all import Frac
-> 1646                 BR = Frac(br[charstr[1]])
   1647             else:
   1648                 is_short = singular.eval('short')

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__getitem__ (build/cythonized/sage/structure/parent.c:11472)()
   1274             except AttributeError:
   1275                 return self.list()[n]
-> 1276         return meth(n)
   1277 
   1278     #########################################################################

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/categories/rings.py in __getitem__(self, arg)
   1175 
   1176             from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
-> 1177             return PolynomialRing(self, elts)
   1178 
   1179         def free_module(self, base=None, basis=None, map=True):

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/polynomial/polynomial_ring_constructor.py in PolynomialRing(base_ring, *args, **kwds)
    630             raise TypeError("you must specify the names of the variables")
    631 
--> 632     names = normalize_names(n, names)
    633 
    634     # At this point, we have only handled the "names" keyword if it was

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:8565)()
    898         return dir_with_other_class(self, self.category().parent_class)
    899 
--> 900 cpdef normalize_names(Py_ssize_t ngens, names):
    901     r"""
    902     Return a tuple of strings of variable names of length ngens given

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:8407)()
   1012                 names = sage.misc.defaults.variable_names(ngens, names)
   1013 
-> 1014     certify_names(names)
   1015     if ngens >= 0 and len(names) != ngens:
   1016        raise IndexError("the number of names must equal the number of generators")

~/co/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/structure/category_object.pyx in sage.structure.category_object.certify_names (build/cythonized/sage/structure/category_object.c:8851)()
   1062         if not N.replace("_", "").isalnum():
   1063             # We must be alphanumeric, but we make an exception for non-leading '_' characters.
-> 1064             raise ValueError("variable name {!r} is not alphanumeric".format(N))
   1065         if not N[0].isalpha():
   1066             raise ValueError("variable name {!r} does not start with a letter".format(N))

ValueError: variable name '@c' is not alphanumeric
```



---

Comment by mmezzarobba created at 2022-02-12 13:58:31

Changing type from PLEASE CHANGE to defect.


---

Comment by @DaveWitteMorris created at 2022-02-13 06:07:01

Here is a minimal example:

```
sage: A.<a,c> = QQbar[]
sage: factor(a^2)
    ...
ValueError: variable name '@c' is not alphanumeric
```

I reproduced the error all the way back to 9.1 (on `CoCalc`), which is as far as I could go, so this is not a new bug.

Interestingly, there seems to be something special about the variable name `c`, because there is no error if we use a different letter (or, at least, some other letters):

```
sage: A.<a,b> = QQbar[]
sage: factor(a^2)
a^2
```

So changing `c` to a different variable name seems to be a workaround (in 9.5 on `CoCalc`, at least):

```
sage: A.<a,b,c1,x,y,S> = QQbar[]
....: p = (a-x)**2+y**2-b**2
....: q = x**2 + y**2 - c1**2
....: r = a*y-2*S
....: r1 = p.resultant(q,x)
....: r2 = r.resultant(r1,y)
....: factor(r2-a**2*16*S**2)
(a - b - c1) * (a - b + c1) * (a + b - c1) * (a + b + c1) * a^2
```



---

Comment by @DaveWitteMorris created at 2022-02-13 08:45:27

Correction: that "minimal" example isn't actually minimal, because replacing `a^2` with `a` still gives the error.

```
sage: A.<a,c> = QQbar[]
sage: factor(a)
    ...
ValueError: variable name '@c' is not alphanumeric
```



---

Comment by slelievre created at 2022-05-16 13:47:38

An even smaller reproducer:

```
sage: A.<c> = PolynomialRing(QQbar, 1)
sage: factor(c)
Traceback (most recent call last):
...
ValueError: variable name '@c' is not alphanumeric
```



---

Comment by nbruin created at 2022-05-16 16:16:30

I think it happens at
[interfaces/singular.py/1607](https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage/interfaces/singular.py?id=d3204606ecb5b0e462cc755a9b1d287a6cdf2784#n1607)
In the traceback that leads to the error, we have:

```
debug> p singular.eval('basering')
ipdb> p singular.eval('basering')
// coefficients: QQ(@c)
// number of vars : 1
//        block   1 : ordering dp
//                  : names    c
//        block   2 : ordering C'
```

so the variable does seem to have the _name_ c, but somehow it prints as ``@`c`. So unless there is some strange encoding happening on the sage side when this ring is created, it's probably some singular escape mechanism because ... perhaps c has a special meaning in singular?

I think what happens is that ``@`` is a singular escape mechanism for duplicate names. Note the following in singular:

```
> ring r = 0,(c), dp; r;
// ** redefining r (ring r = 0,(c), dp; r;)
// coefficients: QQ
// number of vars : 1
//        block   1 : ordering dp
//                  : names    c
//        block   2 : ordering C
> ring r = 0,(c,c), dp; r;
// ** name conflict var(1) and var(2): `c`, rename to `@c`in >>ring r = 0,(c,c), dp; r;<<
in STDIN:14
// ** redefining r (ring r = 0,(c,c), dp; r;)
// coefficients: QQ
// number of vars : 2
//        block   1 : ordering dp
//                  : names    c @c
//        block   2 : ordering C
```


Note how the repeated c has grown an ``@``?

In the ring that seems to happen in this example, the *coefficients* are `QQ(`@`c)` and then we have a polynomial ring in `c` over it. So I suspect the real problem is in the sage code, where a function field in `c` is made, which then later forces singular to escape one of the variables when the ring `QQ(c)[c]` gets created.

So I suspect that in the factoring code over QQbar, there will be a hardcoded `c` somewhere.


---

Comment by nbruin created at 2022-05-16 20:37:04

Unfortunately, the problem is the absfact singular library itself:

```
> LIB "absfact.lib";
// ** loaded /usr/local/sage/sage-git/local/bin/../share/singular/LIB/absfact.lib (4.1.2.0,Feb_2019)
> ring R = (0), (c), lp;
> poly p = c^2+1;
> def S = absFactorize(p);

// 'absFactorize' created a ring, in which a list absolute_factors (the
// absolute factors) is stored.
// To access the list of absolute factors, type (if the name S was assigned
// to the return value):
//        setring(S); absolute_factors;
  
> setring(S);
> absolute_factors;
[1]:
   _[1]=1
   _[2]=c+(-@c)
[2]:
   1,1
[3]:
   _[1]=(@c)
   _[2]=(@c^2+1)
[4]:
   2
> S;
// coefficients: QQ(@c)
// number of vars : 1
//        block   1 : ordering lp
//                  : names    c
//        block   2 : ordering C

```

so apparently, it chooses the name "c" for the algebraic element it thinks it needs to make an extension where the polynomial fully factors. To compare:

```
> ring R = (0), (x,y), lp;
// ** redefining R (ring R = (0), (x,y), lp;)
> poly p = x^2+y^2;
> def S = absFactorize(p);
// ** redefining S (def S = absFactorize(p);)

// 'absFactorize' created a ring, in which a list absolute_factors (the
// absolute factors) is stored.
// To access the list of absolute factors, type (if the name S was assigned
// to the return value):
//        setring(S); absolute_factors;
  
> setring(S);
> absolute_factors;
[1]:
   _[1]=1
   _[2]=(a)*x-y
[2]:
   1,1
[3]:
   _[1]=(a)
   _[2]=(a2+1)
[4]:
   2
```

[note that here `a` is chosen as name!]

and

```
> ring R = (0), (a,b), lp;
// ** redefining R (ring R = (0), (a,b), lp;)
> poly p = a^2+b^2;
> def S= absFactorize(p);
// ** redefining S (def S= absFactorize(p);)

// 'absFactorize' created a ring, in which a list absolute_factors (the
// absolute factors) is stored.
// To access the list of absolute factors, type (if the name S was assigned
// to the return value):
//        setring(S); absolute_factors;
  
> setring(S);
> absolute_factors;
[1]:
   _[1]=1
   _[2]=(c)*a-b
[2]:
   1,1
[3]:
   _[1]=(c)
   _[2]=(c2+1)
[4]:
   2
```

[it seems to avoid the clash here by going to `c`]

Then, if we step up to `ring = (0), (a,b,c), lp;` it indeed cops out with ``@`c` as name for the algebraic element. So for now it seems ``@`c` might just be filtered for and substituted with `__SAGE_CRAZY_ALGEBRAIC_ELEMENT_NAME_` or something like that.
