# Issue 18210: Implement dual-quasi-Schur basis in NCSF

Issue created by migration from Trac.

Original creator: zabrocki

Original creation time: 2015-05-19 02:26:50

CC:  sage-combinat tscrim darij

Keywords: ncsf, qsym, quasiSchur

One of the TODOs that remains in the documentation for ncsf_qsym is to implement a short list of bases from the literature.  One of those bases is the dual basis to the quasi-Schur basis of QSym.  We should be able to use the transition coefficients that are implemented in qsym.py to compute the dual quasi-Schur basis.  This may mean factoring out the methods from qsym.py to combinatorics.py or perhaps just accessing those methods where they are.


---

Comment by zabrocki created at 2015-05-19 12:35:22

I am looking at how the quasisymmetric Schur basis was implemented and I think that there is work that should be done.  I would suggest that it is better implemented through the monomial basis (right now it is implemented in the fundamental basis).

It also seems that the notion of `CompositionTableau(x)` is too restrictive since it doesn't allow for general fillings of composition diagrams (which would be quite useful for the definitions of immaculate tableaux).  There is no documentation that indicates that the definition of `CompositionTableau` comes from [QSCHUR] Haglund, Luoto, Mason, van Willigenburg, *Quasisymmetric Schur functions*, J. Comb. Theory Ser. A 118 (2011), 463-490.

I think that the original implementation in #13505 was made with the intention that one day it would be improved.

Here is a down and dirty implementation of the dual basis.
----
Last 10 new commits:


---

Comment by git created at 2015-05-20 11:07:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-22 01:46:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-22 02:34:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-05-22 02:42:20

This last commit makes the basis change from the complete basis rather than the ribbon basis using the new `number_of_SSRCT` method.  My speed test for this change was `timeit('dQS[1,2,1]*dQS[2,2]',number=1,repeat=1)`
On commit 8cbcc9b it takes about 45 seconds and on commit f72162f it takes a little more than 1 second.

I think that what this means is that the Quasisymmetric_Schur basis should use a similar expansion using the monomial basis rather than the fundamental basis.


---

Comment by git created at 2015-05-22 03:17:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-05-22 04:09:11

I did another timing test on that shows that the improvement is less impressive if we need to compute a large example from the `dQS` basis to another basis.  I computed `timeit('dQS[2,2,2,2].coproduct()',number=1,repeat=1)` and on branch 8cbcc9b it took 53 seconds but on the current branch it takes 52 seconds.  I also checked on f7162f and it took 51 seconds.  It might be that we want to continue to use the to ribbon basis from the QS transition matrices.  I'll see if I can continue to improve the current branch.


---

Comment by git created at 2015-05-22 12:28:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-22 20:42:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-05-22 20:57:08

I am slightly concerned that what we call `CompositionTableaux` in Sage are 'semi-standard reverse composition tableaux' in the literature on quasisymmetric Schur functions. Moreover, the documentation for `CompositionTableaux` does not mention the origin of the mathematics of these objects.  As a class in Sage I think that we should have a definition of a class of objects that one would call composition tableaux (which would consist of all weakly increasing or decreasing fillings of composition diagrams) and that SSRCTs are a subclass of this set.

My modification in commit 0ba7a67 makes the change of basis done by inverting the `_from_complete_on_basis` morphism by triangularity.  It isn't lightening fast, but my test `timeit('dQS[2,2,2,2].coproduct()',number=1,repeat=1)` that was running at 50 some odd seconds now runs in about 19 seconds.

There is still work to be done to speed up the `Quasisymmetric_Schur` basis by using `number_of_SSRCT` for the `_to_monomial_on_basis` method and the inversion method by triangularity that I used for the dual to implement `_from_monomial_by_triangularity`.


---

Comment by git created at 2015-05-23 11:29:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-23 12:22:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-05-23 12:42:01

Time tests on branch 943f817

```
sage: timeit('QS[2,2,2,1].coproduct()',number=1,repeat=1)
1 loops, best of 1: 6.69 s per loop
sage: timeit('QS[2,2,2,2].coproduct()',number=1,repeat=1)
1 loops, best of 1: 56.2 s per loop
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 23.5 s per loop
sage: timeit('QS[2,2,2].internal_coproduct()',number=1,repeat=1)
1 loops, best of 1: 5.23 s per loop
```

Time tests on current branch

```
sage: timeit('QS[2,2,2,1].coproduct()',number=1,repeat=1)
1 loops, best of 1: 5.33 s per loop
sage: timeit('QS[2,2,2,2].coproduct()',number=1,repeat=1)
1 loops, best of 1: 27.8 s per loop
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 18.1 s per loop
sage: timeit('QS[2,2,2].internal_coproduct()',number=1,repeat=1)
1 loops, best of 1: 42.5 s per loop
```

The last example is perhaps telling.  It takes advantage of the cache more than the other calculations and in the new branch the conversion from the monomial basis is not cached.  On branch 943f817, the whole transition matrix at a given degree is calculated at the same time (in this case n=6) and this is used as many times as needed in order to convert to the QS basis.


---

Comment by zabrocki created at 2015-05-23 13:36:21

It occurs to me that in a typical session that one is likely to be doing many calculations with a basis at a given degree.  For this reason branch b8cefb8 works better with these tests doing many loops (NB: with a `@`cached_method before the _to_monomial_on_basis) .  The change in branch 1091d7a is faster for a single change of basis calculation from monomial to QS but normally we do many in one session.

It is possible that I want to undo the edits in commit 0ba7a67 for the same reason.  That will make a single change of basis calculation from the dQS to the complete basis run faster (as my timing tests indicated in comment 11), but many calculations from dQS to complete/ribbon might run faster with the previous code because the change of basis matrix is calculated once for a given degree.


---

Comment by git created at 2015-05-23 17:26:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-05-23 17:53:48

I have restored the coercions `_on_basis` (rather than `_by_triangularity`) using transition matrices.  The main difference in the `QS` basis is that the coercion is to/from the monomial basis instead of the fundamental basis and the `_from_monomial_transition_matrix` calls `number_of_SSRCT`.  This is significantly faster than creating the `_from_fundmental_transition_matrix` using `CompositionTableaux`.

Comparing to branch ​b8cefb8 (with a `@`cached_method in from of `_to_monomial_on_basis`)

```
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 46.3 s per loop
sage: timeit('QS[1,2,1]*QS[2,3]',number=1,repeat=1)
1 loops, best of 1: 421 s per loop
```


Same calculation on current branch

```
sage: timeit('QS[1,2,1]*QS[2,2]',number=1,repeat=1)
1 loops, best of 1: 18.7 s per loop
sage: timeit('QS[1,2,1]*QS[2,3]',number=1,repeat=1)
1 loops, best of 1: 90.7 s per loop
```


I've optimized here the single calculation, but subsequent calculations are all cached and will be faster (and faster than my `_to/from_*_by_triangularity` methods).


---

Comment by git created at 2015-05-24 10:55:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-05-24 11:24:25

Changing keywords from "ncsf, qsym, quasiSchur" to "ncsf, qsym, quasiSchur, quasisymmetric".


---

Comment by zabrocki created at 2015-05-24 11:24:25

Changing status from new to needs_review.


---

Comment by git created at 2015-06-02 07:12:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-06-02 07:26:54

Those are some nice timing improvements Mike.

I made a couple of changes which should result in a speedup to the multiplication. I cached the output of `composition_order` in the matrix function so that it doesn't get recomputed every time a multiplication is done. I also did some other optimizations where I got a good speed reduction in some of my testings.

Did you test to see what the change in timings going from the Quasisymmetric-Schur to the Fundamental basis is? Mainly I'm wondering if we should leave that in as a direct coercion (instead of going through the Monomial basis) and implement an iterator over standard composition tableaux.


---

Comment by git created at 2015-06-02 12:20:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-06-02 12:24:45

I'll work on the timing.  6.8.beta1 doesn't compile for me but 6.8.beta2 does.  I should be that QS -> M -> F is faster than QS -> F but I'll try to get evidence.


---

Comment by zabrocki created at 2015-06-02 14:38:09

The old path of QS to and from the fundamental basis is significantly slower than the current branch which passes through the monomial basis and then to the fundamental basis.

Current branch:

```
F(QS[3,2,1]) - once : 53.8 ms / many : 5.34 ms
F(QS[4,2,1]) - once : 72.2 ms / many : 16.9 ms
F(QS[4,3,1]) - once : 226 ms / many : 60.4 ms
F(QS[4,3,1,1]) - once : 705 ms / many : 68.9 ms
F(QS[4,3,2,1]) - once : 2.09 s / many : 314 ms
F(QS[4,3,2,1,1]) - once : 5.85 s / many : 358 ms

QS(F[3,2,1]) - once : 798 ms / many : 958 µs
QS(F[4,2,1]) - once : 3.05 s / many : 1.81 ms
QS(F[4,3,1]) - once : 14.3 s / many : 3.61 ms
QS(F[4,3,1,1]) - once : 63.8 s / many : 4.91 ms
QS(F[4,3,2,1]) - once : 309 s / many : 8.74 ms
QS(F[4,3,2,1,1]) - once : too long!
```


On master:

```
F(QS[3,2,1]) - once : 28.6 ms / many : 25.1 ms
F(QS[4,2,1]) - once : 124 ms / many : 116 ms
F(QS[4,3,1]) - once : 741 ms / many : 722 ms
F(QS[4,3,1,1]) - once : 2.14 s / many : 2.1 s
F(QS[4,3,2,1]) - once : 15.4 s / many : 16 s
F(QS[4,3,2,1,1]) - once : 50.1 s / many : too long!

QS(F[3,2,1]) - once : 748 ms / many : 1.14 ms
QS(F[4,2,1]) - once : 5.66 s / many : 2.38 ms
QS(F[4,3,1]) - once : 47.5 s / many : 4.65 ms
QS(F[4,3,1,1]) - once : 433 s / many : 10 ms
QS(F[4,3,2,1]) & QS(F[4,3,2,1,1]) - too long!
```



---

Comment by tscrim created at 2015-06-02 16:34:53

That's quite a difference. Thanks for checking.

If you could add a `# long time` to line 4770 (the test `s(dQS([2,1,3,1]).to_symmetric_function())`), and once you've done and are okay with my changes, then you can set this to a positive review.


---

Comment by git created at 2015-06-02 18:41:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-06-02 18:51:27

Please recheck.  I noticed that Elementary, Psi, Phi all do not have `to_symmetric_function_on_basis` implemented and probably should.  Maybe the default implementation of `to_symmetric_function` should be "check if `_on_basis` is implemented, if so, figure `_on_basis` by linearity, otherwise coerce to complete and do the `to_symmetric_function` there"  Would you agree?  If so, I can implement that.


---

Comment by tscrim created at 2015-06-02 23:18:16

I think we should also do the multiplication in the homogeneous symmetric functions (so do the conversion to the the Complete basis, an then immediately convert that to Sym before doing the multiplication, this will likely be a small lambda function for the coercion map). Otherwise I agree.


---

Comment by git created at 2015-06-03 15:05:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-06-03 15:14:39

I am not entirely sure I understood your comment, but I think that I implemented it by adding `to_symmetric_function_on_generators` and an algebra morphism in `to_symmetric_function` in `MultiplicativeBases`.

One thing that I am a bit confused about that I would like you to check carefully.  I had to re-implement `to_symmetric_function` in the ribbon basis.  Why?  It should be inherited from Bases, but for some reason if I remove it, there is no method.  Why just the ribbon basis?  It works fine in `dQS` or any of the other bases.

Also I am still trying to track down a slow-down in the immaculate basis `to_symmetric_function`.  They are implemented exactly the same way in `​02d585f` and the current branch and yet that basis (and only that one) is slower to compute this map.


---

Comment by tscrim created at 2015-06-06 19:34:26

It looks like you did what my comment was, where we did as much multiplication in Sym as possible (which is essentially what algebra morphisms are doing).

So the reason why it might be returning an `AttributeError` is that when a ``@`lazy_attribute` gets called and an error occurs, it generally (i.e., not all errors) catches that error and instead sends the `AttributeError` along. I'll take a look at this.


---

Comment by git created at 2015-06-07 12:26:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-06-07 12:32:01

Your hint helped me find the issue.  That was frustrating me to no end.


---

Comment by tscrim created at 2015-06-07 16:54:55

The slowdown is not from the Immaculate basis, but from the Complete basis to symmetric functions.

```
sage: NCSF = NonCommutativeSymmetricFunctions(QQ)
sage: I = NCSF.Immaculate()
sage: C = NCSF.Complete()
sage: x = C(I[4,1,4,6,3,8])
sage: %prun x.to_symmetric_function()
```

Current branch

```
         352005 function calls (351848 primitive calls) in 1.726 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     3340    0.218    0.000    0.854    0.000 algebras_with_basis.py:128(_product_from_combinatorial_algebra_multiply)
     3341    0.154    0.000    0.595    0.000 classical.py:94(_element_constructor_)
    10024    0.134    0.000    0.268    0.000 partition.py:5064(__contains__)
     6683    0.115    0.000    0.311    0.000 partition.py:604(__init__)
     6681    0.103    0.000    0.693    0.000 partition.py:548(__classcall_private__)
    56381    0.084    0.000    0.084    0.000 {isinstance}
    28447    0.083    0.000    0.083    0.000 non_negative_integers.py:94(__contains__)
     3341    0.079    0.000    0.748    0.000 ncsf.py:2876(to_symmetric_function_on_generators)
     3340    0.073    0.000    0.508    0.000 multiplicative.py:39(_multiply_basis)
     6683    0.067    0.000    0.100    0.000 combinat.py:1251(__init__)
     3349    0.065    0.000    0.089    0.000 free_module.py:2030(_from_dict)
     6683    0.064    0.000    0.574    0.000 partition.py:5045(_element_constructor_)
    15894    0.035    0.000    0.050    0.000 partition.py:5096(<genexpr>)
    12553    0.032    0.000    0.047    0.000 partition.py:627(<genexpr>)
     6683    0.032    0.000    0.032    0.000 partition.py:638(__hash__)
     6683    0.031    0.000    0.031    0.000 combinat.py:822(__init__)
    16727    0.027    0.000    0.125    0.000 {all}
     6690    0.025    0.000    0.025    0.000 free_module.py:36(__init__)
     3361    0.024    0.000    0.026    0.000 partition.py:4914(__classcall_private__)
      596    0.024    0.000    1.613    0.003 {sage.misc.misc_c.prod}
     3340    0.022    0.000    0.877    0.000 magmas.py:927(_mul_parent)
    50388    0.021    0.000    0.021    0.000 {len}
        2    0.018    0.009    1.655    0.827 {sage.combinat.dict_addition.dict_linear_combination}
     3340    0.015    0.000    0.015    0.000 {method 'sort' of 'list' objects}
     3349    0.015    0.000    0.017    0.000 sf.py:883(complete)
     7276    0.014    0.000    0.014    0.000 combinat.py:1172(__iter__)
     3340    0.014    0.000    0.901    0.000 magmas.py:875(__mul__)
6781/6780    0.013    0.000    0.016    0.000 {hasattr}
       30    0.012    0.000    0.012    0.000 dynamic_class.py:324(dynamic_class_internal)
     3936    0.010    0.000    0.688    0.000 generic_basis_code.py:1110(<genexpr>)
     6680    0.010    0.000    0.010    0.000 combinat.py:1146(__len__)
    13361    0.008    0.000    0.008    0.000 {method 'iteritems' of 'dict' objects}
     6680    0.008    0.000    0.008    0.000 free_module.py:2084(<genexpr>)
```

With 02d585f:

```
         55438 function calls (55282 primitive calls) in 0.461 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      597    0.087    0.000    0.127    0.000 family.py:852(__init__)
  698/697    0.027    0.000    0.031    0.000 {hasattr}
      597    0.024    0.000    0.422    0.001 ncsf.py:2815(to_symmetric_function_on_basis)
     6680    0.022    0.000    0.022    0.000 non_negative_integers.py:94(__contains__)
      598    0.021    0.000    0.032    0.000 free_module.py:1895(_monomial)
        2    0.021    0.010    0.394    0.197 {sage.combinat.dict_addition.dict_linear_combination}
     3340    0.016    0.000    0.024    0.000 partition.py:5096(<genexpr>)
     9531    0.015    0.000    0.015    0.000 {isinstance}
     3340    0.015    0.000    0.023    0.000 partition.py:627(<genexpr>)
      611    0.012    0.000    0.016    0.000 {sorted}
       31    0.012    0.000    0.012    0.000 dynamic_class.py:324(dynamic_class_internal)
      598    0.012    0.000    0.051    0.000 partition.py:604(__init__)
      598    0.012    0.000    0.050    0.000 partition.py:5064(__contains__)
      597    0.011    0.000    0.147    0.000 graded_modules_with_basis.py:42(basis)
      597    0.011    0.000    0.122    0.000 partition.py:548(__classcall_private__)
      597    0.011    0.000    0.193    0.000 sfa.py:1459(__getitem__)
      718    0.008    0.000    0.021    0.000 dynamic_class.py:122(dynamic_class)
     1323    0.008    0.000    0.010    0.000 combinat.py:961(__eq__)
      598    0.007    0.000    0.010    0.000 combinat.py:1251(__init__)
      598    0.007    0.000    0.109    0.000 partition.py:5045(_element_constructor_)
      597    0.006    0.000    0.136    0.000 family.py:44(Family)
      597    0.005    0.000    0.006    0.000 copy.py:66(copy)
       28    0.005    0.000    0.007    0.000 homset.py:546(__init__)
     1217    0.004    0.000    0.052    0.000 {all}
      597    0.004    0.000    0.361    0.001 morphism.py:384(<genexpr>)
      605    0.004    0.000    0.007    0.000 free_module.py:2030(_from_dict)
      598    0.004    0.000    0.004    0.000 partition.py:638(__hash__)
      605    0.004    0.000    0.006    0.000 sf.py:883(complete)
      598    0.003    0.000    0.003    0.000 combinat.py:822(__init__)
       28    0.003    0.000    0.019    0.001 homset.py:86(Hom)
      605    0.003    0.000    0.003    0.000 free_module.py:36(__init__)
      597    0.003    0.000    0.364    0.001 free_module.py:1870(<genexpr>)
       21    0.002    0.000    0.026    0.001 morphism.py:159(__init__)
```

It seems that going from the Complete basis is faster to be a module morphism rather than an algebra morphism (which for this, makes sense because we are just sorting the composition and we don't need to multiply non-monomial elements). More specifically, you can look at the number of calls to `Partition.__init__`, and it's all of these additional small function calls that adds up.


---

Comment by git created at 2015-06-07 18:02:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-06-07 18:06:29

That fixes the slow-down.  Thanks.  I'm now seeing better speeds on all bases with significant speedups on the multiplicative bases.


---

Comment by tscrim created at 2015-06-07 18:29:24

Then I believe we are at a positive review, right?


---

Comment by zabrocki created at 2015-06-07 18:42:58

Changing status from needs_review to positive_review.


---

Comment by zabrocki created at 2015-06-07 18:42:58

I think it looks good at this point.  There are speedups on a number of features from this ticket.  Thanks for the review.


---

Comment by tscrim created at 2015-06-07 18:55:33

Thanks for your work.


---

Comment by vbraun created at 2015-06-08 20:28:37

Resolution: fixed
