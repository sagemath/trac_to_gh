# Issue 33476: Implementation of finite Drinfeld modules

Issue created by migration from https://trac.sagemath.org/ticket/33713

Original creator: antoine-leudiere

Original creation time: 2022-04-15 09:20:59

CC:  caruso @mbombar zimmerma @davidayotte @spaenlehauer

Keywords: Drinfeld modules, Ore polynomials, Function fields

I would like to propose an implementation for _finite Drinfeld modules_. I
opened this ticket to discuss this idea and have feedback on implementation
directions, in order to comply with Sage's guidelines. Please do feel free to express any doubt or criticism, or give ideas! I very much value the collaborative aspect of the [SageMath](SageMath) community.

# Motivation

A finite Drinfeld module is defined as follows. Let `Fq` be a finite fields
with `q` elements, let `L` be a finite extension of `Fq`. Consider the
`\Fqbar`-linear endomorphism `\tau: x \mapsto x^q`, and define `L\{\tau\}` as
the ring of Ore polynomials in `\tau` with coefficients in `L` (see [ticket: 29629]). Also fix `\omega` a non zero element of
`L`. An `\Fq`-Drinfeld module defined over `L` is, by definition, an
`\Fq`-algebra morphism `\phi: \Fq[X]\toL\{\tau\}` such that:
* `\phi(X)` as constant coefficient `\omega`,
* `phi` is not contained in `L`.

At the moment, there exists no such implementation in Sage.

Drinfeld modules are standard arithmetic tools in the theory of function
fields. See [Goss, Basic structures of function field arithmetic, 1998],
[Rosen, Number theory in function fields, 2002]. Good resources are also
[Gekeler, On finite Drinfeld modules, 1991], [Hayes, A brief introduction to
Drinfeld modules, 1991] and [Caranay, Greenberg, Scheidler, Computing modular
polynomials and isogenies of rank two Drinfeld modules, 2020]. The author of
this ticket got interested in Drinfeld modules with isogeny-based cryptographic
applications in mind; see https://arxiv.org/abs/2203.06970.

I am a first-year PhD student working with
[P.-J. Spaenlehauer](https://members.loria.fr/PJSpaenlehauer/index.html) and
[E. Thomé](https://members.loria.fr/EThome/).

# Implementation details

I propose three classes: `FiniteDrinfeldModule`, `FiniteDrinfeldModulesRankSet`
and `FiniteDrinfeldModulesSet`.

## The `FiniteDrinfeldModule` class

This is the class for representing finite Drinfeld modules. It must be
instantiated with a polynomial ring and an Ore polynomial ring:


```
sage: Fq = GF(2)
sage: L = Fq.extension(2)
sage: FqX.<X> = Fq[]
sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism())
sage: omega = L.gen()
sage: phi_X = omega + t + t^2
sage: phi = FiniteDrinfeldModule(FqX, Ltau, phi_X)  # phi is only defined by the image of X
```


Here are the methods that I wish to add in the first version:


```
sage: phi.generator()  # phi_X
t^2 + t + z2
sage: phi(X^2)  # Magic method __call__
t^4 + t^2 + t + z2 + 1
sage: phi.polynomial_ring  # Property, reference to FqX
Univariate Polynomial Ring in X over Finite Field of size 2 (using GF2X)
sage: phi.ore_polynomial_ring  # Property, reference to Ltau
Ore Polynomial Ring in t over Finite Field in z2 of size 2^2 twisted by z2 |--> z2^2
sage: phi.rank  # Property, rank of phi
2
sage: phi.frobenius  # Property, returns t
t
sage: phi.omega  # Property, returns omega
z2
sage: phi.Fq  # Property, reference to Fq
Finite Field of size 2
sage: phi.definition_field  # Property, reference to L
Finite Field in z2 of size 2^2
sage: phi.j_invariant  # Only if rank is 2, returns j-invariant
1
```


A crucial feature of finite Drinfeld module is that they endow the algebraic
closure `\Fqbar` with a structure of left-`\Fq[X]`-module. I think the most
appropriate mechanism is to have a method `algebraic_closure_action` return a
`LeftModuleAction` (see
https://doc.sagemath.org/html/en/reference/coercion/sage/structure/coerce_actions.html#sage.structure.coerce_actions.LeftModuleAction).
I am not yet sure if it is the best way to do it.

On top of this, the first version should be well doctested and include Sage's
own magic method (`_repr_`, `_latex`, etc).

In further versions, I wish to include:
* methods in isogenies of Drinfeld modules (esp. Vélu's formula for Drinfeld
* modules);
* methods on the torsion of Drinfeld modules (module law and vector space law);
* class methods (instanciate a random Drinfeld module, or from a j-invariant);
* methods on the well-definition of a Drinfeld module on some sub-field of L.

Naturally, any input (especially negative) is more than welcomed!

## The `FiniteDrinfeldModulesRankSet` and `FiniteDrinfeldModulesSet` classes

To comply with the coercion model (see
https://doc.sagemath.org/html/en/developer/coding_in_python.html#the-sage-coercion-model,
https://doc.sagemath.org/html/en/reference/coercion/index.html), any instance
of `FiniteDrinfeldModule` must have a parent. I was thinking about creating a
class `FiniteDrinfeldModulesRankSet`, representing the set of all finite
Drinfeld modules (with `FqX`, `Ltau` and `omega` fixed) with a prescribed rank.
The class `FiniteDrinfeldModulesSet` is the same, except the rank can be
arbitrary.

The details are not clear to me at this point.

# Development environment

It is not clear to me yet in which environment I should work: tox virtual
environment, Docker ?.. Any advice is more than welcome.


---

Comment by caruso created at 2022-04-16 06:32:09

Some quick comments:
- I'm not completely sure that Drinfeld modules should be elements of some parent; maybe, actually, they could parents themselves (e.g. elliptic curves are parents) but it is also not that nice because it breaks the construction `phi(X^2)`; I do not know if having something outside this hierarchy is relevant here.
- usually in Sage, we do not expose properties but methods, *e.g.* `phi.polynomial_ring()` is more appropriate than `phi.polynomial_ring`, etc.
- for the development environment, to start with, I think you can simply create a new git branch on your local repository, work on it and push it here on trac when you're ready.


---

Comment by antoine-leudiere created at 2022-04-19 11:04:49

Hi Xavier, thank you for your input. Ok for the methods instead of properties. For the parent/coercion, the paragraph [_Parents and Elements_](https://doc.sagemath.org/html/en/reference/coercion/index.html#parents-and-elements) states
  Most things in Sage are either parents or have a parent.

I think it is quite nice, when in doubt about something, to be able to call `parent(phi)` and have the set of Drinfeld modules in which `phi` was defined. Of course, this is a bit redundant with `_repr_`.

Anyway, the most important thing is `FiniteDrinfeldModule`, and this is where I start.


---

Comment by chapoton created at 2022-04-19 18:37:45

* la case Author (ici plus haut) doit contenir le nom complet, c'est tout

* il suffit de donner le nom de la branche, pas besoin de remplir la case commit


---

Comment by chapoton created at 2022-04-19 18:43:01

Il existe une hiérarchie : catégorie > parent > élément.

Moralement, chaque parent est un ensemble.

Par exemple, la catégorie "Groups", dans laquelle se placent les parents qui sont des groupes, ces parents ayant eux mêmes des éléments. Pour un parent donné, on peut demander sa catégorie par la méthode `.category()` et aussi `.categories()`.

Peut-être qu'il n'est pas nécessaire de créer la catégorie "DrinfeldModules" maintenant.


---

Comment by antoine-leudiere created at 2022-04-20 08:44:22

Replying to [comment:7 chapoton]:
> Il existe une hiérarchie : catégorie > parent > élément.
> 
> Moralement, chaque parent est un ensemble.
> 
> Par exemple, la catégorie "Groups", dans laquelle se placent les parents qui sont des groupes, ces parents ayant eux mêmes des éléments. Pour un parent donné, on peut demander sa catégorie par la méthode `.category()` et aussi `.categories()`.
> 
> Peut-être qu'il n'est pas nécessaire de créer la catégorie "DrinfeldModules" maintenant.

Merci Frédéric ; c'est entendu, nous verrons plus tard.


---

Comment by caruso created at 2022-04-23 08:27:31

Ah tiens, on parle français maintenant ici ?
I switch to english because I think that other people might be interested.

The difficulty, I think, with Drinfeld modules is that they exhibit as the same time aspects of elements and parents.
By definition, they are ring homomorphisms from `Fq[X]` to some Ore polynomial ring. In this sense, they should be considered as elements of some hom space. However, in practice, my understanding is that we often view them as spaces (in general `Fqbar`) endowed with a semi-linear action of the algebra `Fq[X]`. As such, it makes sense to consider the category of Drinfeld modules and define methods which are usually related to parents (e.g. `rank`, `definition_field`, etc.).

IMO, the situation is quite similar to what we have for group representations, which can be viewed either as group morphisms `G -> GLn(K)` or as `K`-vector spaces endowed with a linear action of `G`. In sage, the latter point of view is privilegied but I'm not sure we should follow the same pattern here because the most standard definition of Drinfeld modules are in terms of ring homomorphisms.


---

Comment by antoine-leudiere created at 2022-04-25 06:32:34

This is a good synthethis of the problem. It is true that most interesting
properties of Drinfeld modules come from the Fq[X]-algebra structure on Fqbar.
However, the structure of ring homomorphism is richer and we should not forget
it. For exemple, it is with it that we can easily define the rank or the
characteristic polynomial. But in the meantime, talking about Drinfeld module
as only ring homomorphisms kinda misses the point of those objects, as we are
primilarly interested in their action on Fqbar.

That's why my initial idea was to make drinfeld modules children of some
`DrinfeldModuleSet` or `DrinfeldModuleCategory` (not too familiar with
conventions here). I believe with this I can still make the class
`FiniteDrinfeldModule` inherit `RingHomomorphism`.

I plan on soon pushing a first draft of `FiniteDrinfeldModule` that inherits
`RingHomomorphism`.


---

Comment by git created at 2022-04-26 16:49:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-04-26 18:59:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-04-26 19:23:00

Hi guys.

I commited and pushed an elementary _draft_ for `FiniteDrinfeldModule` (the
class representing Drinfeld modules) and `FiniteDrinfeldModuleAction` (the
class representing the `\Fq[X]`-action given by a Drinfeld module).

You can try them now. The (incomplete and rudimentary) doctest gives you usage
examples.

Any feedback would be greatly appreciated, so that I do not go in the wrong
direction.

Summary:

* `FiniteDrinfeldModule` inherits `sage.rings.morphism.RingHomomorphism_im_gens`.
* `FiniteDrinfeldModuleAction` inherits `sage.categories.action.Action`.
* I tried to systematically check the validity of the user inputs. I still have
  corner cases to cover though.
* The computation of the action is done in
  `FiniteDrinfeldModuleAction._act_`, but I really do not know if this is the
  right place. The documentation was not clear to me so I chose this option via
  trial and error and by looking at the code of `Action`.
* Similarly, the method of `FiniteDrinfeldModule` used to get the associated
  action is `_get_action_`, which seems wrong considering the `_` prefix.
* I put those two classes in a single file, located in
  `$SAGE_ROOT/src/sage/modules`. As discussed below, this may be misleading
  considering that, _technically_ a Drinfeld module is not a module but a
  morphism. Furthermore, may be the two classes should be in separate files.


---

Comment by git created at 2022-04-27 12:47:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-12 16:21:39

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by chapoton created at 2022-05-12 19:20:07

le linter (qui vérifie certains détails dans le code) est pas content:

```
sage/rings/function_field/finite_drinfeld_module.py:295:12: E713 test for membership should be 'not in'
16
sage/rings/function_field/finite_drinfeld_module.py:389:12: E713 test for membership should be 'not in'
17
sage/rings/function_field/finite_drinfeld_module.py:411:12: E713 test for membership should be 'not in'
18
sage/rings/function_field/finite_drinfeld_module.py:420:12: E713 test for membership should be 'not in'
19
sage/rings/function_field/finite_drinfeld_module.py:453:12: E713 test for membership should be 'not in'
```



---

Comment by antoine-leudiere created at 2022-05-13 09:22:15

Thank you Frédéric for the reminder. I'll be sure to check that out.

Replying to [comment:16 chapoton]:
> le linter (qui vérifie certains détails dans le code) est pas content:
> {{{
> sage/rings/function_field/finite_drinfeld_module.py:295:12: E713 test for membership should be 'not in'
> 16
> sage/rings/function_field/finite_drinfeld_module.py:389:12: E713 test for membership should be 'not in'
> 17
> sage/rings/function_field/finite_drinfeld_module.py:411:12: E713 test for membership should be 'not in'
> 18
> sage/rings/function_field/finite_drinfeld_module.py:420:12: E713 test for membership should be 'not in'
> 19
> sage/rings/function_field/finite_drinfeld_module.py:453:12: E713 test for membership should be 'not in'
> }}}


---

Comment by @DavidAyotte created at 2022-05-13 21:14:24

Hello Antoine, 
thank you for this new feature, it looks very well done! Is there a reason why you only consider Drinfeld modules over finite fields? Some times ago I did a basic implementation of Drinfeld modules over A = Fq[T] (see https://github.com/DavidAyotte/drinfeld_modules) (still unfinished, my end goal is to work with Drinfeld modular forms). Also, do you plan to implement a constructor for your Drinfeld module class? For example, given a finite list of element in a finite field `[a_0, a_1,... , a_r]`, the constructor could create a Drinfeld module of rank r defined by 

`T |---> a_0 + a_1*tau + ... + a_r*tau^r`   (tau = frobenius endomorphism).

I think that this would improve the usage of this implementation for the end-user. Anyhow, I will be looking forward to this ticket and I will be glad to help you if you have any questions!


---

Comment by antoine-leudiere created at 2022-05-16 10:56:07

David,

It is very nice to have somebody else interested in Drinfeld modules, thank you for reaching out!

Replying to [comment:19 gh-DavidAyotte]:
> Hello Antoine, 
> thank you for this new feature, it looks very well done! Is there a reason why you only consider Drinfeld modules over finite fields? Some times ago I did a basic implementation of Drinfeld modules over A = Fq[T] (see https://github.com/DavidAyotte/drinfeld_modules) (still unfinished, my end goal is to work with Drinfeld modular forms).

The main reason I only consider _finite_ Drinfeld modules is practical. I am not too familiar with general Drinfeld modules at the moment (for our cryptographic purposes we mainly worked with rank two finite Drinfeld modules), and I have an incremental vision of development (I would rather begin with a small but well-understood module than with a giant monolithic monster). In the long term I would very much want to implement more general Drinfeld modules, even though they are harder to work with.


> Also, do you plan to implement a constructor for your Drinfeld module class? For example, given a finite list of element in a finite field `[a_0, a_1,... , a_r]`, the constructor could create a Drinfeld module of rank r defined by 
> 
> `T |---> a_0 + a_1*tau + ... + a_r*tau^r`   (tau = frobenius endomorphism).
> 
> I think that this would improve the usage of this implementation for the end-user. Anyhow, I will be looking forward to this ticket and I will be glad to help you if you have any questions!

This is a nice suggestion. If I am not mistaken, the idiomatic way to do this is to call the parent category of the objects. With Ore polynomials, one would do (see penultimate line):


```
sage: Fq = GF(3^2)
sage: z2 = Fq.gen()
sage: FqX.<X> = Fq[]
sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5
sage: L = Fq.extension(6)
sage: frob = L.frobenius_endomorphism(2)
sage: Ltau.<t> = OrePolynomialRing(L, frob)
sage: omega = p.roots(L, multiplicities=False)[0]
sage: phi_X = Ltau([omega, 1, 1])
sage: phi = FiniteDrinfeldModule(FqX, phi_X, p)
```


As my implementation requires multiple arguments for `__init__`, and that at some point either the user or the code in `__init__` needs to access the Ore polynomial ring, I think it is best not to bloat the code and to let the user use the "list constructor" of `OrePolynomialRing` if they want. Consequently, at the moment, I do not think that I should add this constructor to `FiniteDrinfeldModule`.

Another possibility however, is to create the category of finite Drinfeld modules (with respect to those fixed `FqX` and `Ltau`), and to use the list constructor on them:


```
sage: parent = phi.parent()
Category of finite Drinfeld modules from ... to ...
sage: psi = parent([omega, 1, 1])
```


I hope this is clear; tell me if it is not. Feel free to continue the discussion!

Antoine

_EDIT_.: The possibility of creating a class representing the category of Drinfeld modules was already discussed in this thread. It is not clear yet if we should add this feature.


---

Comment by git created at 2022-05-16 11:05:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DavidAyotte created at 2022-05-16 13:05:57

> at some point either the user or the code in __init__ needs to access the Ore polynomial ring.

Yes indeed that makes very much sense. I had in mind a much simpler example, but for the example you gave you indeed need to create all these objects. As you said, let's not bloat to much this ticket.


---

Comment by antoine-leudiere created at 2022-05-16 13:15:18

Replying to [comment:22 gh-DavidAyotte]:
> As you said, let's not bloat to much this ticket.

Oh I was talking about not bloating the _code_, this ticket is the best place to discuss! I literally opened it for this purpose. By all means, feel free to post here!

Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.


---

Comment by @DavidAyotte created at 2022-05-16 13:18:20

> Furthermore, I do not like the fact that instantiating a FiniteDrinfeldModule currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.

This is also my concern and my idea was this "list constructor", but it is not as simple as that. Let's think of it and we'll surely come up with something.


---

Comment by caruso created at 2022-05-16 18:19:21

Replying to [comment:23 antoine-leudiere]:
> Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.

The same in 6 lines:


```
sage: Fq.<z2> = GF(3^2)
sage: FqX.<X> = Fq[]
sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5
sage: L.<omega> = Fq.extension(p)
sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2, p)
```


and I assume that you can further reduce to 5 lines by making optimal the argument `characteristic`:


```
sage: Fq.<z2> = GF(3^2)
sage: FqX.<X> = Fq[]
sage: L.<omega> = Fq.extension(X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5)
sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2)
```


I agree that it will be a little be slower because `L` is here a "quotient polynomial ring" and not a "finite field". However, this should be fixed after ticket #28485 (if merged one day).


---

Comment by antoine-leudiere created at 2022-05-17 15:23:01

Hi Xavier and thanks a lot for the input. Yeah, with those tricks we can shorten those lines. Some details:

- At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...

- However I believe there is a mistake in your snippet. In my example, `L` is _not_ the extension of `Fq` with modulus `p`. It is a larger extension, which contains `Fq[X]/p = Fq(omega)`. Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...

By the way, better support for relative field extensions would indeed make things so much easier. 


Replying to [comment:25 caruso]:
> Replying to [comment:23 antoine-leudiere]:
> > Furthermore, I do not like the fact that instantiating a `FiniteDrinfeldModule` currently takes so much lines (about ten in the above example). It is boilerplatish, and any idea to shorten this would be welcome.
> 
> The same in 6 lines:
> 
> {{{
> sage: Fq.<z2> = GF(3^2)
> sage: FqX.<X> = Fq[]
> sage: p = X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5
> sage: L.<omega> = Fq.extension(p)
> sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
> sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2, p)
> }}}
> 
> and I assume that you can further reduce to 5 lines by making optimal the argument `characteristic`:
> 
> {{{
> sage: Fq.<z2> = GF(3^2)
> sage: FqX.<X> = Fq[]
> sage: L.<omega> = Fq.extension(X^3 + (z2 + 2)*X^2 + (6*z2 + 1)*X + 3*z2 + 5)
> sage: Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(2))
> sage: phi = FiniteDrinfeldModule(FqX, omega + t + t^2)
> }}}
> 
> I agree that it will be a little be slower because `L` is here a "quotient polynomial ring" and not a "finite field". However, this should be fixed after ticket #28485 (if merged one day).


---

Comment by caruso created at 2022-05-17 20:16:57

Replying to [comment:26 antoine-leudiere]:
> - At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...

Maybe, you should consider using `has_coerce_map_from` instead?

> - However I believe there is a mistake in your snippet. In my example, `L` is _not_ the extension of `Fq` with modulus `p`. It is a larger extension, which contains `Fq[X]/p = Fq(omega)`.

Ah okay. I actually thought that there was a typo in your code :-/.
But then, you need to construct `L` and `omega` separately and it is normal that the code becomes longer...

> Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...

It is. But in which situation do you really need this construction?


---

Comment by antoine-leudiere created at 2022-05-18 09:52:18

Replying to [comment:27 caruso]:
> Replying to [comment:26 antoine-leudiere]:
> > - At the moment, I cannot use the syntax `Fq.<z2> = GF(3^2)`. It is because of ticket:33807 and the fact that I need `is_subring` in the method `FiniteDrinfeldModule.change_ring`. This is a bit unstable...
> 
> Maybe, you should consider using `has_coerce_map_from` instead?

Thanks for the suggestion. Apparently, nope. The method `is_subring` (method of class `Ring`) is defined in `src/sage/rings/ring.pyx`, and it is roughly defined like this:


```
def is_subring(self, other):
    if self is other:
        return True
    try:
        return self.Hom(other).natural_map().is_injective()
    except (TypeError, AttributeError):
        return False
```


Since we have this `(version `SageMath version 9.6, Release Date: 2022-05-15`):


```
sage: Fq.<z2> = GF(3^2)
sage: L = Fq.extension(6)
sage: M = L.extension(2)
sage: Fq.is_subring(M)
False
sage: Hom(Fq, M).natural_map()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-5-4531a212934e> in <module>
----> 1 Hom(Fq, M).natural_map()

~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/homset.py in natural_map(self)
    209         f = self.codomain().coerce_map_from(self.domain())
    210         if f is None:
--> 211             raise TypeError("natural coercion morphism from %s to %s not defined"%(self.domain(), self.codomain()))
    212         return f
    213 

TypeError: natural coercion morphism from Finite Field in z2 of size 3^2 to Finite Field in z24 of size 3^24 not defined
sage: 
```


I seems that we really need a fix. For the moment I don't feel like making it myself: the class `Ring` is the base of so many things, and I do not want to break anything. 


> > Long story short I need to know the polynomial that generates `Fq(omega)`, where `omega` is the constant coefficient of `phi_X` (see e.g. `frobenius_norm`). But `omega` does not need to generate `L`. I discussed about this in [this thread](https://ask.sagemath.org/question/62312/subextension-over-non-prime-subfield-as-a-quotient/). Hope this is clear...
> 
> It is. But in which situation do you really need this construction?

The constant term `omega` is used to calculate the images under the Drinfeld module (seen as a morphism).

The prime polynomial `characteristic` is mainly used to gather information on complex multiplication. More precisely, the Frobenius norm a rank two Drinfeld module is (up to multiplying by a constant) a power of `characteristic` ([Gekeler, Th. 2.11](https://www.ams.org/journals/tran/2008-360-04/S0002-9947-07-04558-8/S0002-9947-07-04558-8.pdf); see also [Schost-Mussleh, Prop. 3](https://arxiv.org/pdf/1907.12731.pdf)). With this information, we can compute the characteristic polynomial and decide if the D.m. is supersingular.

Note however that I do not need to built the relative / intermediate extensions as I first (wrongly) thought. It seems that I can do anything with just the constant term `omega` and the characteristic `characteristic`.


---

Comment by tscrim created at 2022-06-08 06:13:41

There is a generic `Representation` class that was implemented within the past few years as an attempt by me to figure out what a good framework for representation theory would be in Sage. So I am open to alternatives for how to do these implementations.

That being said, a representation is not a morphism, nor do I think it should be implemented as one. Strictly speaking it is a pair `(V, f)`, where `V` is a (always? free) module and `f: A -> End(V)` a homomorphism (of objects in whatever category `A` is). What is typical in my area of representation theory is to equate the pair with the module, which we can think of it as an `A`-module when `A` is an algebra. Consequently, I think the way to model this in Sage: have a module with an action of `A` (which Sage, sometimes secretly, treats as a morphism). Consequently, representations should be parents.

Note that there is also the `_acted_upon_` and `_act_on_` methods for implementing actions. Although if you are interested in properties tied to `f`, then your current implementation might be best.


---

Comment by @DavidAyotte created at 2022-06-08 13:48:14

Hello Travis, I allow myself to add to this conversation because Drinfeld module plays a central role in my research. Personnally, I think that this is a tricky problem because most people who works with Drinfeld modules (me included) do not see them as representation. They are mostly objects with a _geometric_ flavor rather than algebraic. In fact, they are analogues of elliptic curves in the finite characteristic function field setting. I believe that it would be non-standard for [SageMath](SageMath) to implement Drinfeld modules as actual modules with an action of a ring instead of a morphism.

I also think that Drinfeld modules should be their own parent and category (this was already discussed at the beginning of this thread). One problem here would be the question of "elements". This is because we don't really work with elements of the object, but more with the properties of the object. In other words, people works with the _object and its properties_ rather than with the _object and its elements_.


---

Comment by antoine-leudiere created at 2022-06-08 15:01:40

Thanks Travis and David for the input. Like David, I never thought of Drinfeld
modules as representations, but I will consider it.


---

Comment by antoine-leudiere created at 2022-06-08 15:05:20

A quick status report. I had a lot to do in the last few weeks and I did not really work on
the code. That being said, there are three main things left to do:

1. Write doctests.

2. Add an option to the constructor `OrePolynomialRing` so that `F2tau.<t> = OrePolynomialRing(GF(2), GF(2).frobenius_endomorphism())` builds a real Ore algebra and not a regular polynomial ring.

3. Implement a _smart_ mechanism so that the constructor of `FiniteDrinfeldModule` autonomously decides (depending on the input) to instantiate `FiniteDrinfeldModule` or `FiniteDrinfeldModule_rank_two`. Like this:


```
sage: psi = FiniteDrinfeldModule(FqX, omega + t^5, characteristic)
sage: type(psi)
<class 'sage.rings.function_field.finite_drinfeld_module.FiniteDrinfeldModule'>
sage: phi = FiniteDrinfeldModule(FqX, omega + t^2, characteristic)
sage: type(phi)
<class 'sage.rings.function_field.finite_drinfeld_module.FiniteDrinfeldModule_rank_two'>
```


Goal 1) is straightforward. 

Goal 2) should be OK; I discussed this with Xavier.

Goal 3), however, is tricky. One way to do this is to make `FiniteDrinfeldModule` inherit [`CachedRepresentation` or `UniqueRepresentation`](https://doc.sagemath.org/html/en/reference/structure/sage/structure/unique_representation.html), and to implement `__classcall_private__`. The drawback is that two instances with same parameters (`polring`, `gen`, `characteristic`) will always be references to one another. This prevents users from doing deep copies, which limits their abilities. I discussed this (with David and Travis) in [this sage-devel thread](https://groups.google.com/g/sage-devel/c/PaUReuoxEXI). I am still not decided on what to do. Any other suggestion would be welcome.


Antoine


---

Comment by caruso created at 2022-06-08 15:20:13

For 3), another option is to use the class `Factory`; however, I know that Travis prefers `__classcall_private__`.


---

Comment by @DavidAyotte created at 2022-06-08 18:30:47

Hello Antoine, may I ask why do you want to seperate the rank 2 case with that of the general rank case? My guess here is that some methods are proper to the rank 2 case that aren't yet known for the general rank case. For such methods, do you think that simply adding a rank verification would work? For example, if someone ask for the j-invariant of a rank 3 Drinfeld module, an error would be returned saying that it is not yet implemented. To me, this leaves open the question to the user: "do such method exists in the higher rank case?" which is an interesting question to ask when studying Drinfeld modules. By the way, theory of J-invariants are known in the higher rank case, which I think could be interesting to implement.


---

Comment by antoine-leudiere created at 2022-06-09 08:59:28

I think this is a relevant question. To me, sane coding practices dictate the
answer.

It is true that the rank two methods may one day become general rank methods.
For example, the characteristic polynomial of the Frobenius endomorphism is
defined for any rank. And the j-invariant is also defined for some rank one
Drinfeld modules.

However, we are not there yet. It is way cleaner (for the developer _and_ the
user) to have class inheritance. It is ugly to check if if the rank is 2 and to
raise an exception at the begining of each rank two method. Furthermore,
historically, rank two Drinfeld modules are of special interest when it comes
to computation, and they deserve their own class. See
[Schost, Musleh, 2019](https://arxiv.org/abs/1907.12731) or
[Caranay, Greenberg, Scheidler, 2019](https://people.ucalgary.ca/~rscheidl/Papers/DMVolcanos.pdf). And, if in the future we build algorithms for general ranks (which I hope!),
we will easily be able to implement them as methods of the general class.


---

Comment by tscrim created at 2022-06-09 09:26:58

Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused). That parent belongs in the category of certain homsets. I might have

Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.

As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements). The `__classcall__` mechanism is also independent of `UniqueRepresentation`.


---

Comment by antoine-leudiere created at 2022-06-09 13:53:25

Replying to [comment:37 tscrim]:
> Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused).

Hahahaha, no worries, I totally understand. A general principle for Drinfeld
modules is that what they do is more important as what they are. And what they
do is endow `Fqbar` with this `Fq[X]`-module law. However I still believe that
they should be implemented as morphisms.


> That parent belongs in the category of certain homsets. I might have
> 
> Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.

Sure. The prime goal of this implementation is to provide researchers with a
toolbox with which they can manipulate objects. A fun example is the CGL hash
function.

1. You take a message that you want to hash.
2. You somehow convert this message to a j-invariant of a rank two _supersingular_ finite Drinfeld module (method `is_supersingular`).
3. You make a random walk in the tree whose nodes are isomorphism classes (represented by j-invariants) and whose vertices are isogenies between those classes. The random walk is realized with Vélu's formula (method `velu`).
4. The j-invariant on which you stop is, by definition, the hash of the message.

A quick and dirty implementation is the following:


```
def cgl_hash(j):
    # Do 100 random walks
    for _ in range(100):
        # phi has j-invariant j
        phi = FiniteDrinfeldModule_rank_two(FqX, omega + t + t^2/j, characteristic)
        is_isogeny = False
        while not is_isogeny:
            # Ideally, m should rather be an isogeny of small fixed-degree
            m = Ltau.random_element()
            if phi.is_isogeny(m):
                phi = phi.velu(m)
                phi = FiniteDrinfeldModule_rank_two(FqX, phi(X), characteristic)  # Ugly, I know
                is_isogeny = True
    return phi.j()

if __name__ == '__main__':
    Fq = GF(2)
    z2 = Fq.gen()
    FqX.<X> = Fq[]
    characteristic = X^6 + X^4 + X^3 + X + 1
    L.<z6> = Fq.extension(6)
    Ltau.<t> = OrePolynomialRing(L, L.frobenius_endomorphism(1))
    omega = characteristic.roots(L, multiplicities=False)[0]
    phi = FiniteDrinfeldModule_rank_two(FqX, t^2 + (z6^5 + z6)*t + z6, characteristic)
    assert phi.is_supersingular()
    j = phi.j()
    hash_ = cgl_hash(j)
```


You see that the goal is not to perform one specific case but to provide simple
methods that are easy to use. This [SageMath](SageMath) module (`;)`) is nothing more than
a calculator with Drinfeld modules.

I genuinely do not know if this is useful for you, feel free to ask more
questions.


> 
> As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements).

Ok so I was not clear on this. My bad. I do not have a specific use case where
the user would want to make deep copies. I however try to follow the general
principle of not imposing technical constraints to the user. If at some point a
user needs to deep copy, I want them to be able to. As simple as that.


> The `__classcall__` mechanism is also independent of `UniqueRepresentation`.

Fair enough, this meens that I am a bit confused on all of this. I will try to
get my head around this (and on the `Factory` stuff).

By the way, thanks a *lot* for taking so much time and genuine interest on
this.


---

Comment by git created at 2022-06-09 13:54:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DavidAyotte created at 2022-06-09 17:20:22

Replying to [comment:36 antoine-leudiere]:

> And the j-invariant is also defined for some rank one Drinfeld modules.

J-invariants are also defined for higher rank Drinfeld modules (see this [paper](https://link.springer.com/article/10.1023/A:1009724323513)).

> However, we are not there yet.

This is the thing. Your code will very likely evolve in the future as people might gain interest in it and want to contribute to it. My *main concern* here is that your rank two specific class might become superfluous in the future. You mention that you don't want to "bloat" the code, but code repetition is a form of bloating.

> It is ugly to check if if the rank is 2 and to raise an exception at the begining of each rank two method.

I'm sorry, I'm not conviced by this very subjective argument :-) Your code currently have eight rank two specific methods. When I look briefly, four of them could be generalized to higher rank (`j`, `delta`, `g` and `characteristic_polynomial` as you said) and maybe more. Do you have any other rank two specific methods you want to implement? 

Historically, I believe that the main reasons people restricted themselves to the rank 2 specific case is because it simplifies the computations. Nowadays, the higher rank generalizations is getting some interests.

However, don't get me wrong, I don't want to stop you in your implementation and I'm very enthusiastic in having Drinfeld modules in [SageMath](SageMath). Thank you for doing this and I already have plenty of ideas of new enhancements for this implementation! Good job on your work!


---

Comment by tscrim created at 2022-06-13 09:39:54

Replying to [comment:38 antoine-leudiere]:
> Replying to [comment:37 tscrim]:
> > Okay, so based on the definition given in the description (reading is very useful `:)`), I see why they should be functions. Which means there is a parent of all such modules (I will probably cringe every time this terminology appears since it is so different than what I am used to calling a module, please excuse anytime I get confused).
> 
> Hahahaha, no worries, I totally understand. A general principle for Drinfeld
> modules is that what they do is more important as what they are. And what they
> do is endow `Fqbar` with this `Fq[X]`-module law. However I still believe that
> they should be implemented as morphisms.

I am not sure that `Fqbar` with an action should be the object you want. It will potentially have multiple action of the same `Fq[X]` acting on it. So I would want this to be a different class (which could be a subclass of `Representation`) that takes in a `DrinfeldModule` and the underlying space. This way you would have no ambiguity about the action.

I would think a bit about how you want the user to interact with your code. What are the main entry points? I don't want all of the main classes to be imported into the global namespace (in particular, the rank two case should it survive refactoring). I would guess that mathematically it should be the method of some (relatively general) parent that we already have (with possibly raising a `NotImplementedError` on some cases your code does not yet cover).

From the example you gave and from a quick look at the code, it looks like the most natural object to add a hook to is the `OrePolynomialRing` or possibly its elements.

> > Perhaps you can give me some samples with what you want to do (either as (pseudo)code or mathematically)? I feel like I need a little bit more to help me get my bearings.
> 
> Sure. A fun example is the CGL hash function.

Thank you for the example. It is helpful to see the usage.

What (natural) structure(s) exists on the set of Drinfeld modules? Is it a module (in the linear algebra sense)? Ring? This could be useful in determining if we want a special subclass of the homset for Drinfeld modules.

> > As I mentioned on sage-devel, you need to explain why you want deep copies (seems fishy as you should not be modifying internal data; usually we don't do this because we would quickly eat up memory caching lots of elements).
> 
> Ok so I was not clear on this. My bad. I do not have a specific use case where
> the user would want to make deep copies. I however try to follow the general
> principle of not imposing technical constraints to the user. If at some point a
> user needs to deep copy, I want them to be able to. As simple as that.

To be polite, this is not a valid argument. Your objects are (functionally) immutable. Thus, if you do not expect a lot of them to be constructed (which from my understanding you do not), then there are strong benefits for having uniqueness (e.g., free hash and equality checks). Someone doing a deep copy and mutating your object not only would likely violate some of the internal assumptions of Sage's code (e.g., hashing) but is a code smell that an inconsistent object could result.

Some other quick comments:

- This is not a full C/C++ library where everything needs to be perfectly encapsulated and accessed with getter (or setter) methods. For example, it might be better to store `_Fq` as an attribute than get it as a function. This can have a big impact on speed in Python.
- I agree with David about the rank two case. All of those methods that (should) have a well-defined generalization should be there and raise a `NotImplementedError` where appropriate. The rank two class might still be useful for doing specialized computations, but sometimes a simple `if` statement in the appropriate methods makes the code more maintainable (this is a subjective decision though).
- I am very worried about the `is_morphism()` method considering the base class.
- The signature of `_get_action_()` is not correct for a parent, but it does not make sense for a morphism.
- We follow Python's convention for error messages of starting with a lower case letter and no punctuation at the end.
- Please avoid the double underscore name mangling. It generally makes things more complicated for subclasses to work with unless you have a really good reason to keep the data protected.


---

Comment by antoine-leudiere created at 2022-06-16 17:42:50

I had a lot of work this week, sorry for the delay! Quick heads up.

*Rank two situation*

Fair enough, let's use `NotImplementedError`. I will delete the class
`FiniteDrinfeldModule_rank_two`.

`@`Travis. There indeed are benefits to unique representations. However, this is
not something that is fundamentally necessary from a mathematical point of
view. And, for this reason, I do not want to limit the users. It's not my
business to tell what users can or cannot do. My job is to provide them with a
safe and well-built library.

*Base class*

A finite Drinfeld `FqX`-module is *not* a module. Blame Drinfeld for this. A finite Drinfeld `FqX`-module
*is* a morphism, which induces an `FqX`-module law on `Fqbar`. See my original comment.
Drinfeld modules `\Fq[X] \to L\{\tau\}`, however, are the objects of a category
whose morphisms `i: \phi \to \psi` are, by definition, Ore polynomials `i` such
that `i*phi(X) = psi(X)*i`.

We've been thinking about this with Xavier (who I visited this week), and we
wrote a different implementation that inherits `CategoryObject` instead of
`RingHomomorphism_im_gens`. We created the category `DrinfeldModules` and we
will create homspaces for Drinfeld modules. We pushed a quick, dirty,
undocumented and untested code on the branch
[u/antoine-leudiere/finite_drinfeld_modules-category-object](https://git.sagemath.org/sage.git/log/?h=u/antoine-leudiere/finite_drinfeld_modules-category_object).

This makes much sense from cryptography perspectives, for example, as in this
context we mainly manipulate morphisms of Drinfeld modules.
The code is cleaner when having `Hom(phi, psi)`, and we could probably
implement methods like `random_element`, `supersingular_element` or
`ordinary_element` on the category.


We overloaded `__call__` for convenience.

Furthermore, we could remove some of the boilerplate code, and the
`characteristic` is now an attribute of the category which is _not_ necessary
anymore when instantiating `FiniteDrinfeldModule`.

Demo:


```
sage: # Create Drinfeld modules
sage: Fq = GF(7^2)
sage: FqX.<X> = Fq[]
sage: L.<w> = GF(7^6)
sage: phi = FiniteDrinfeldModule(FqX, [w, 1, 1])
sage: phi
Finite Drinfeld module:
  Polring:        Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2
  Ore polring:    Ore Polynomial Ring in t over Finite Field in z6 of size 7^6 twisted by z6 |--> z6^(7^2)
  Generator:      t^2 + t + z6
sage: psi = FiniteDrinfeldModule(FqX, phi(X))
sage: phi == psi
True
sage: # Category of Drinfeld modules
sage: dr = phi.category()
sage: dr
Category of Drinfeld modules defined by Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2
  To:   Finite Field in z6 of size 7^6
  Defn: X |--> z6
sage: dr(phi(X))
Finite Drinfeld module:
  Polring:        Univariate Polynomial Ring in X over Finite Field in z2 of size 7^2
  Ore polring:    Ore Polynomial Ring in t over Finite Field in z6 of size 7^6 twisted by z6 |--> z6^(7^2)
  Generator:      t^2 + t + z6
sage: dr(phi(X)) == phi
True
sage: dr.characteristic()
x^3 + (6*z2 + 4)*x^2 + (4*z2 + 5)*x + 6*z2
sage: dr.characteristic()(phi(X)[0])
0
sage: # Some methods
sage: phi.characteristic_polynomial()
T^2 + (3*X + 6*z2 + 5)*T + 6*X^3 + (z2 + 3)*X^2 + (3*z2 + 2)*X + z2
sage: t = phi.ore_variable()
sage: phi.characteristic_polynomial()(t^3, phi(X))
0
sage: phi.j()
1
```


By the way, David will be happy with the constructor!

*Misc*

* For the getters, why is it a problem to use methods as everything is already
  stored somewhoere?
* I agree, names `is_morphism`, etc, are shitty. Hopefully we will get rid of
  those by using syntax like `i in Hom(phi, psi)`. In the meantime, I can
  replace `is_` to `has_`.
* Ok for `_get_action_`. I really was not sure about it, as mentioned it
  earlier.


---

Comment by @DavidAyotte created at 2022-06-16 19:02:13

Hello Antoine, thanks for the heads up! It looks a lot more convenient now to create a Drinfeld module (I am indeed happy with the constructor `:)`). Did you opened a ticket for the implementation of the category of Drinfeld modules?


---

Comment by tscrim created at 2022-06-17 09:38:33

Replying to [comment:42 antoine-leudiere]:
> `@`Travis. There indeed are benefits to unique representations. However, this is
> not something that is fundamentally necessary from a mathematical point of
> view. And, for this reason, I do not want to limit the users. It's not my
> business to tell what users can or cannot do. My job is to provide them with a
> safe and well-built library.

Having just seen another ticket that has issues with non-uniqueness, you are making a point for me with a "well-built library." You need to interact with the broader Sage library as well and fit into that framework. Your reasoning about not wanting to impose technical limitations on users is, again, invalid once you have immutable data. There is no reason anyone should be making a deep copy. As soon as you want to change something, then your object has changed and so it will be different. There is no reason to have `X == X` but not `X is X` beyond not wanting to pollute the cache (which includes creating lots of elements that cannot be garbage collected for a long time), the input not distinguishing `X` (up to some relatively simple normalization), or normalization is a time-consuming process. Programming is not mathematics (something I often have to remind myself of).

> *Base class*
> 
> A finite Drinfeld `FqX`-module is *not* a module. Blame Drinfeld for this. A finite Drinfeld `FqX`-module
> *is* a morphism, which induces an `FqX`-module law on `Fqbar`. See my original comment.
> Drinfeld modules `\Fq[X] \to L\{\tau\}`, however, are the objects of a category
> whose morphisms `i: \phi \to \psi` are, by definition, Ore polynomials `i` such
> that `i*phi(X) = psi(X)*i`.

You have fixed `\Fq[X]` and `L\{\tau\}`, right? So the category is just the parent `H = \Hom(\Fq[X], L\{\tau})`. Then the set of morphisms is a subalgebra(?) of the Ore polynomials. So it would make sense to implement the set of morphisms using the corresponding Ore polynomial ring.

Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?

> We've been thinking about this with Xavier (who I visited this week), and we
> wrote a different implementation that inherits `CategoryObject` instead of
> `RingHomomorphism_im_gens`.

Can you explain a bit more of your reasoning/overall design?

> We created the category `DrinfeldModules` and we
> will create homspaces for Drinfeld modules.

I don't think it makes sense to implement this as a category in Sage given your code and examples since Sage categories are not quite like mathematical categories. I am not against this though (making them `CategoryObject`s reinforces that they should also be `UniqueRepresentation`s). See above and below for alternative constructions based on what you have told me.

> Demo:

You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.

> *Misc*
> 
> * For the getters, why is it a problem to use methods as everything is already
>   stored somewhere?

Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.

> * I agree, names `is_morphism`, etc, are shitty. Hopefully we will get rid of
>   those by using syntax like `i in Hom(phi, psi)`. In the meantime, I can
>   replace `is_` to `has_`.

The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.

> * Ok for `_get_action_`. I really was not sure about it, as mentioned it
>   earlier.

For this, the code is telling me that you want to have a `Representation` object that takes in the `Fqbar` space and the Drinfeld module. Then this object would have a natural `get_action()` method.

Perhaps we cannot get out of having something in the global namespace. Although I get the feeling that there is a natural place to hook this into as a method.


---

Comment by antoine-leudiere created at 2022-06-17 12:57:46

Replying to [comment:44 tscrim]:

> There is no reason anyone should be making a deep copy.

My whole point is that we do not know that. Let us move on.

> You have fixed `\Fq[X]` and `L\{\tau\}`, right? So the category is just the parent `H = \Hom(\Fq[X], L\{\tau})`.

`\Fq[X]` and `L\{\tau\}` indeed are fixed; do not forget also to fix `\omega \in L^\times`. There are other conditions to be fulfilled for an element of your `H` to be a Drinfeld module, you may refer to the definition I gave in my original post.

> Then the set of morphisms is a subalgebra(?) of the Ore polynomials.

No. You can add morphisms, you can compose them with endomorphisms, but you cannot multiply them. The set of morphisms `\phi \to \psi` is a left `\End(\psi)`-submodule (or a right `\End(\phi)`-submodule) of `L\{\tau\}`. This implies that it is an `\Fq[X]`-left (or right) module whose elements live in `\L\{\tau\}`.

> Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?

I did --- they form a category. I have not heard of any other (meaningful) structure.

> Can you explain a bit more of your reasoning/overall design?

As I said, the idea is that we manipulate Drinfeld modules as much as we manipulate their morphisms (isogenies) and endomorphisms. When defining the category `DrinfeldModules` and making `FiniteDrinfeldModule` inheriting `CategoryObject`, we achieve basically two things:
* we can manipulate morphisms and isogenies using nice syntax like `Hom(phi, psi)`;
* we can delegate the management of the fixed objects (esp. the characteristic, which originally was the cause of long boilerplate code) to the category.

> You are using the category like a parent and the parents like elements.

It seems OK to overload `__call__`, which seems to be the only parent-like behavior.

> Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.

Getters are safer. I don't think the cost of calling 


```python
def polring(self):
    return self._polring
```


is that bad.

> The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.

Yeah, that's why Xavier and I thought about implementing the category and the homspaces. The syntax `i in Hom(phi, psi)` to test if `i` is a morphism is neat. It literally was in the part of the post you replied to.

> For this, the code is telling me that you want to have a `Representation` object that takes in the `Fqbar` space and the Drinfeld module. Then this object would have a natural `get_action()` method.

Ok I will think about it.


---

Comment by caruso created at 2022-06-17 19:35:24

Replying to [comment:44 tscrim]:
> > We've been thinking about this with Xavier (who I visited this week), and we
> > wrote a different implementation that inherits `CategoryObject` instead of
> > `RingHomomorphism_im_gens`.
> 
> Can you explain a bit more of your reasoning/overall design?

As I tried to argue before, the overall idea is that, although Drinfeld modules are defined as ring homomorphisms, we usually treat them more as parents than as elements. In particular, the category of Drinfeld modules is quite meaningful while adding/multiplying Drinfeld modules does not make sense. On the other hand, Drinfeld modules do not have elements (as Antoine underlined, they are not modules in the usual sense). This is the main abstract reason why we believe that implementing them as category objects is a nice solution. Besides, in practice, we realized that this framework is also convenient (e.g. it makes easier the creation of Drinfeld modules).

Previously, I clumsily compared Drinfeld modules with representations; it's certainly better to compare them with elliptic curves (which are the objects they are supposed to mimic in the context of function fields). By definition, an elliptic curve is the datum of a Weierstrass equation (i.e. an equation of the form `y^2 = x^3 + a*x + b`, at least in characteristic different from 2 and 3); however, nobody considers seriously to implement them as elements in the ring of bivariate polynomials. One reason is that adding/multiplying Weierstrass equations is not meaningful.

Besides, we do not really want an abstract elliptic curve to have elements. (Of course, their sets of points over some fields have elements; one can maybe argue that, when considered as a scheme, the elements of an elliptic curve are the prime ideals of the quotient ring `K[x,y]/(y^2 - x^3 - a*x - b)` but this is probably not really what is expected by the user.)

In [SageMath](SageMath), elliptic curves are parents:


```
sage: E = EllipticCurve(u'389a')
sage: E
Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
sage: isinstance(E, Parent)
True
```


However, `E` does not have elements:


```
sage: E._element_constructor_
Traceback (most recent call last):
...
AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute '_element_constructor_'

sage: E.element_class
Traceback (most recent call last):
...
AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute 'element_class'
```


and the method `__call__` has been overriden to create set of points:


```
sage: E(QQ)
Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
```


We somehow decided to follow the same pattern for Drinfeld modules, except that, given that they do have not elements, we found that `CategoryObject` was better suited. (I assume that the class `CategoryObject` was not already introduced when elliptic curves were first implemented in [SageMath](SageMath).)

> You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.

I don't have that feeling.

For instance, we have a constructor for directly creating Drinfeld modules without passing through the parent/category. (I agree that such constructors exist elsewhere in sage, e.g. `matrix`, but they are not that common.) Also, as Antoine already said, we plan to implement `Hom(phi, psi)` when `phi` and `psi` are Drinfeld modules.

We override `__call__` for the convenience of the user, but if you don't like this, we can probably just get rid of this.


---

Comment by tscrim created at 2022-06-18 05:27:21

Replying to [comment:45 antoine-leudiere]:
> Replying to [comment:44 tscrim]:
> 
> > There is no reason anyone should be making a deep copy.
> 
> My whole point is that we do not know that. Let us move on.

Yes, we do. See my comments above. I also have a little bit of experience with this that tells me this is the right thing to do.

> > You have fixed `\Fq[X]` and `L\{\tau\}`, right? So the category is just the parent `H = \Hom(\Fq[X], L\{\tau})`.
> 
> `\Fq[X]` and `L\{\tau\}` indeed are fixed; do not forget also to fix `\omega \in L^\times`. There are other conditions to be fulfilled for an element of your `H` to be a Drinfeld module, you may refer to the definition I gave in my original post.
> 
> > Then the set of morphisms is a subalgebra(?) of the Ore polynomials.
> 
> No. You can add morphisms, you can compose them with endomorphisms, but you cannot multiply them. The set of morphisms `\phi \to \psi` is a left `\End(\psi)`-submodule (or a right `\End(\phi)`-submodule) of `L\{\tau\}`. This implies that it is an `\Fq[X]`-left (or right) module whose elements live in `\L\{\tau\}`.

Okay, thank you for the explanation. I am guessing there isn’t anything known about the dimension or generators/basis?

> > Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?
> 
> I did --- they form a category.

That is not a structure of the objects. Essentially anything can be objects in a category, just like anything can be in a set. The elements of a ring form a perfectly nice category with on the identity morphism on each object (a discrete category).

> I have not heard of any other (meaningful) structure.

That is what I wanted to know.

> > Can you explain a bit more of your reasoning/overall design?
> 
> As I said, the idea is that we manipulate Drinfeld modules as much as we manipulate their morphisms (isogenies) and endomorphisms. When defining the category `DrinfeldModules` and making `FiniteDrinfeldModule` inheriting `CategoryObject`, we achieve basically two things:
> * we can manipulate morphisms and isogenies using nice syntax like `Hom(phi, psi)`;
> * we can delegate the management of the fixed objects (esp. the characteristic, which originally was the cause of long boilerplate code) to the category.

I am going to respond to Xavier’s post for this. However, I am skeptical of the second point.

> > Speed, speed, and speed. When you are working internally, even in subclasses, I think it is better to use the attributes.
> 
> Getters are safer. I don't think the cost of calling 
> {{{
> #!python
> def polring(self):
>     return self._polring
> }}}
> is that bad.

It adds up quite a lot, much more than you think it does. Python is slow compared to C.

> > The code might be trying to speak to you a bit here. It isn't quite a matter of syntax, but of overall design.
> 
> Yeah, that's why Xavier and I thought about implementing the category and the homspaces. The syntax `i in Hom(phi, psi)` to test if `i` is a morphism is neat.

I also read your post very carefully and responded with that in mind to make a point. Indeed, I am agreeing with you that there does need to be an object for the set of morphisms. It is not the syntax, but the object that is the important point to me.

> It literally was in the part of the post you replied to.

I am trying to not be snarky in my replies, but I don’t appreciate the tone of your comment here.


---

Comment by tscrim created at 2022-06-18 06:01:18

Replying to [comment:46 caruso]:
> Replying to [comment:44 tscrim]:
> > > We've been thinking about this with Xavier (who I visited this week), and we
> > > wrote a different implementation that inherits `CategoryObject` instead of
> > > `RingHomomorphism_im_gens`.
> > 
> > Can you explain a bit more of your reasoning/overall design?
> 
> As I tried to argue before, the overall idea is that, although Drinfeld modules are defined as ring homomorphisms, we usually treat them more as parents than as elements. In particular, the category of Drinfeld modules is quite meaningful while adding/multiplying Drinfeld modules does not make sense. On the other hand, Drinfeld modules do not have elements (as Antoine underlined, they are not modules in the usual sense). This is the main abstract reason why we believe that implementing them as category objects is a solution. Besides, in practice, we realized that the framework is also convenient (e.g. it makes easier the creation of Drinfeld modules).

I don’t really see how this makes the creation any easier, at least from a user point of view. The input is the input. There is perhaps one less parent that you need to create when implementing them. Although if there is truly less data (other than the homset), then I would suspect you are treating them as very different objects than ring morphisms. Or am I missing something?

To that effect, one big disadvantage of them not being a ring morphism is that you cannot use them as such. If you overrode the `__call__` to have them act as a morphism, that is basically the point I was making that they are behaving like elements.

Also, ideals are something in the other direction: parent like objects that are also elements.

> Previously, I clumsily compared Drinfeld modules with representations; it's certainly better to compare them with elliptic curves (which are the objects they are supposed in mimic in the context of function fields). By definition, an elliptic curve is the datum of a Weierstrass equation (i.e. an equation of the form `y^2 = x^3 + a*x + b`, at least in characteristic different from 2 and 3); however, nobody considers seriously to implement them as elements in the ring of bivariate polynomials. One reason is that adding/multiplying Weierstrass equations is not meaningful.

I am guessing you mean as an ideal of bivariate polynomials since polynomials themselves cannot have equality? However, this doesn’t have a choice of base ring fixed, right? If so, then the parallel is lost a bit on me.

> Besides, we do not really want an abstract elliptic curve to have elements. (Of course, their sets of points over some fields have elements; one can maybe argue that, when considered as a scheme, the elements of an elliptic curve are the prime ideals of the quotient ring `K[x,y]/(y^2 - x^3 - a*x - b)` but this is probably not really what is expected by the user.)
> 
> In [SageMath](SageMath), elliptic curves are parents:
> 
> {{{
> sage: E = EllipticCurve(u'389a')
> sage: E
> Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
> sage: isinstance(E, Parent)
> True
> }}}
> 
> However, `E` does not have elements:
> 
> {{{
> sage: E._element_constructor_
> Traceback (most recent call last):
> ...
> AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute '_element_constructor_'
> 
> sage: E.element_class
> Traceback (most recent call last):
> ...
> AttributeError: 'EllipticCurve_rational_field_with_category' object has no attribute 'element_class'
> }}}
> 
> and the method `__call__` has been overriden to create set of points:
> 
> {{{
> sage: E(QQ)
> Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
> }}}
> 
> We somehow decided to follow the same pattern for Drinfeld modules, except that, given that they do have not elements, we found that `CategoryObject` was better suited. (I assume that the class `CategoryObject` was not already introduced when elliptic curves were first implemented in [SageMath](SageMath).)

Although that suggests that an elliptic curve might be better considered as a functor from Rings to Sets would you say?

I am a little more convinced that this could be reasonable, but it seems a bit like you have to ignore some of the fundamental mathematical definition to make this fit.

> > You are using the category like a parent and the parents like elements. Your code also reflects this with implementing methods that you were expected to overload with non-generic versions.
> 
> I don't have that feeling.
> 
> For instance, we have a constructor for directly creating Drinfeld modules without passing through the parent/category. (I agree that such constructors exist elsewhere in sage, e.g. `matrix`, but they are not that common.) Also, as Antoine already said, we plan to implement `Hom(phi, psi)` when `phi` and `psi` are Drinfeld modules.

It actually is somewhat common as another example is `polygen` and is done a lot in the combinatorics code. Having it be a `CategoryObject` instead of a subclass of `Element` doesn’t make a difference to me for the main entry point. It is equivalent to rebranding something in my mind.

> We override `__call__` for the convenience of the user, but if you don't like this, we can probably just get rid of this.

I think there will have to be some overriding of things to make it convenient.

I am slightly worried that convenience (say, not getting the Ore polynomial ring for constructing the morphisms) is being prioritized at the sake of the mathematical description. It starts making things a little less flexible.

I should also state for the record I am not opposed to using `CategoryObject`, nor do I have too much stake in this as it is (clearly) outside of my main mathematical areas. I am just trying to see if there is a better framework for this implementation.


---

Comment by caruso created at 2022-06-19 13:15:08

Replying to [comment:48 tscrim]:
> I don’t really see how this makes the creation any easier, at least from a user point of view. The input is the input. There is perhaps one less parent that you need to create when implementing them. Although if there is truly less data (other than the homset), then I would suspect you are treating them as very different objects than ring morphisms. Or am I missing something?

You're right, the data are always the same.

However, the standard way to define a morphism in sage is first to create the domain (here `Fq[X]`) and the codomain (here `L{tau}` which is a skew polynomial ring) and then to give the image of the generator (namely `X`). And, it is indeed the approach which was originally followed by Antoine.
Then David complains, saying that it was maybe too complicated for the user.

At first, I rather disagreed but then I realized that the twisting morphism `tau` is entirely determined by the other data: it is the Frobenius map `x |-> x^q` (where q is the cardinality of `Fq`). So one can actually let the software build the codomain `L{tau}`, which is a huge simplification regarding the interface: the user only has to construct `Fq[X]`, `L` and then to pass in the coefficients of the image of `X`.

Of course, I agree that it is not a strong argument because the above simplification can be equally 
implemented in both models (morphism and category object). However, I would say that it looks less natural in the first case because it somehow "breaks" the classical method to define morphisms in sage.

> To that effect, one big disadvantage of them not being a ring morphism is that you cannot use them as such. If you overrode the `__call__` to have them act as a morphism, that is basically the point I was making that they are behaving like elements.

I agree that it is a disadvantage.
But I think that there are (maybe more) similar disadvantages in the other direction. I've mentioned for instance the creation of hom spaces between Drinfeld modules, which might look a bit weird if Drinfeld modules are themselves morphisms (and not parents). In a similar fashion, the methods `rank`, `characteristic`, `frobenius_charpoly`, etc. belong to the lexical field of modules and not to that of ring homomorphisms. Actually, I do not blame Drinfeld for choosing the word module for designing those object; I believe that calling them Drinfeld morphisms would cause more confusion.

> I am guessing you mean as an ideal of bivariate polynomials since polynomials themselves cannot have equality?

Actually, I was thinking of the difference `y^2 - x^3 - a*x - b` but, you're right, ideals are better here.

> However, this doesn’t have a choice of base ring fixed, right? If so, then the parallel is lost a bit on me.

I'm not sure to understand your point. In general, a base ring is fixed when we talk about an elliptic curve (this is a ring containing the parameters `a` and `b`), even though we then allows ourselves to look at points over extensions. We have the same behaviour for polynomials: they have coefficients in a fixed base, but we allow ourselves to consider roots in extensions. And the same is true for Drinfeld modules: the coefficients defining them lie in a base field `L` but we let it act not only on `L` but on its extensions as well.

> Although that suggests that an elliptic curve might be better considered as a functor from Rings to Sets would you say?

There are (at least) three different points of view on ellptic curves (or, more generally, on algebraic varieties) which are, I think, equally good (or, depending on your philosophy, equally bad because they all only capture one portion of the complexity of the situation):
- a defining polynomial (or a defining ideal),
- a scheme, *i.e.* a space endowed with the Zariski topology (and maybe additional structures like a sheaf),
- a functor from the category of `A`-algebras (if `A` is the base ring over which the elliptic curve is defined) to the category of sets.

I don't think we have to favor one of this point of view in the implementation. On the contrary, one option is to implement elliptic curves as abstract objects in some category and provide general categorical methods together with more specific methods related to the viewpoints listed above.

> I am a little more convinced that this could be reasonable, but it seems a bit like you have to ignore some of the fundamental mathematical definition to make this fit.

In my understanding, the fact that Drinfeld modules are defined as homomorphisms between some rings in a kind of accidents (I'm not sure but I think, for instance, that they could also be defined as actions of a certain type `Fq[X]` on `Fqbar`). What is important is that they exhibit many similar properties to elliptic curves.

> I should also state for the record I am not opposed to using `CategoryObject`, nor do I have too much stake in this as it is (clearly) outside of my main mathematical areas. I am just trying to see if there is a better framework for this implementation.

Well, I don't know either what is the best solution for this implementation. And I'm clearly very happy to discuss this with you who has a different understanding of the mathematical background.


---

Comment by antoine-leudiere created at 2022-06-20 22:09:53

Replying to [comment:47 tscrim]:

> Yes, we do. See my comments above. I also have a little bit of experience with this that tells me this is the right thing to do.

> Okay, thank you for the explanation. I am guessing there isn’t anything known about the dimension or generators/basis?

Actually, we might have some results on this. The easy case is when isogenies
are endomorphisms. Here, Drinfeld modules would behave as elliptic curves, and
the theory of complex multiplications provides us with many results regarding
the structure of endomorphisms as free modules. See [Goss 1998, ''Basic
structures of function field arithmetic'', Section 4.7].

If the isogenies are not endomorphisms, we can look at isogenies that have
fixed `\tau`-degree. There is only a finite number of those, which makes them a
finite `\Fq`-vector space. We have not looked at anything here, but it is
plausible that one could find some structure.



> > > Also, you haven't answered my question about the structure of all Drinfeld modules? Can I add two together? Take scalar multiples? Is there a well-defined notion of product?
> > 
> > I did --- they form a category.
> 
> That is not a structure of the objects. Essentially anything can be objects in a category, just like anything can be in a set. The elements of a ring form a perfectly nice category with on the identity morphism on each object (a discrete category).
> 
> > I have not heard of any other (meaningful) structure.
> 
> That is what I wanted to know.

Thank you for letting me know. As I have trouble precisely understanding what
you have in mind, could you next time be more precise? As I think many answers
were already given in my previous posts, this is probably the best way not to
waste both our time, wouldn't you agree?


> > It literally was in the part of the post you replied to.
> 
> I am trying to not be snarky in my replies, but I don’t appreciate the tone of your comment here.

Apologies for this. Rereading the discussion I acknowledge that my phrasing
made me sound more cutting than diplomatically acceptable. Next time let us ask
questions with more details, as to avoid those miscommunications.


---

Comment by antoine-leudiere created at 2022-06-20 22:13:50

Replying to [comment:49 caruso]:

> 
> You're right, the data are always the same.
> 
> However, the standard way to define a morphism in sage is first to create the domain (here `Fq[X]`) and the codomain (here `L{tau}` which is a skew polynomial ring) and then to give the image of the generator (namely `X`). And, it is indeed the approach which was originally followed by Antoine.
> Then David complains, saying that it was maybe too complicated for the user.
> 
> At first, I rather disagreed but then I realized that the twisting morphism `tau` is entirely determined by the other data: it is the Frobenius map `x |-> x^q` (where q is the cardinality of `Fq`). So one can actually let the software build the codomain `L{tau}`, which is a huge simplification regarding the interface: the user only has to construct `Fq[X]`, `L` and then to pass in the coefficients of the image of `X`.

I would also add that, in fact, we do not even need to build `\Fq[X]`. Its
construction (as is the one of `L\{\tau\}`) can be delegated to the constructor
of the Drinfeld module. We would come to something like this:


```python
sage: Fq = GF(5^2)
sage: L.<omega> = GF(5^6)
sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])
```


What would be your opinion on this?

> I don't think we have to favor one of this point of view in the implementation. On the contrary, one option is to implement elliptic curves as abstract objects in some category and provide general categorical methods together with more specific methods related to the viewpoints listed above.

To add up to the discussion regarding the creation of a category and
implementing the Drinfeld modules as `CategoryObject`, I think that the example
of the `\Fq[X]`-characteristic is quite relevant.

Let us recall the general analogy of finite `\Fq[X]`-Drinfeld modules and
elliptic curves defined other finite fields. Finite fields have a
characteristic, which is an integer `p \in \N`. This object does not depend on
any elliptic curve; it is intrinsic to the finite field. However, the
characteristic of the finite field _does_ have strong implications on
elliptic curves defined on the field. The most famous example is the fact that
the `p`-torsion is either trivial or `(\Z/p\Z)^\times`.

It turns out that the _characteristic_ associated to Drinfeld modules (which
I will now be referring to as the _`\Fq[X]`-characteristic_) I mentioned many
times earlier is exactly the analogue, for Drinfeld modules, of the standard
characteristic in finite fields. In fact, it is a polynomial in `\Fq[X]` that
is intrinsic to the setting, which is given by `Fq`, `L`, and `omega`. In this
context, the `\Fq[X]-characteristic` can exactly be defined as the minimal
polynomial of `omega` over `Fq`, where `\omega` is the constant term of
`\phi(X)` for any Drinfeld module `\phi` in the category. See [Goss, Definition
3.6.1].

I believe you would never make the characteristic of a finite field a property
of an elliptic curve. Therefore, we should not make the `\Fq[X}`-characteristic
a property of the Drinfeld modules. It is a mistake on my side for doing it
earlier, and I am sorry if this led to misunderstandings.

Xavier was right to suggest the creation of the category, as it would
encapsulate all those fixed parameters: `\Fq[X]`, `L\{\tau\}` and `omega`/the
`\Fq[X]`-characteristic.


---

Comment by caruso created at 2022-06-21 07:31:52

Replying to [comment:51 antoine-leudiere]:
> I would also add that, in fact, we do not even need to build `\Fq[X]`. Its
> construction (as is the one of `L\{\tau\}`) can be delegated to the constructor
> of the Drinfeld module. We would come to something like this:
> 
> {{{
> #!python
> sage: Fq = GF(5^2)
> sage: L.<omega> = GF(5^6)
> sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])
> }}}
> 
> What would be your opinion on this?

I'm not sure because, in full generality, Drinfeld modules are "defined" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would cause much trouble.


---

Comment by antoine-leudiere created at 2022-06-21 08:48:58

Replying to [comment:52 caruso]:
> Replying to [comment:51 antoine-leudiere]:
> > I would also add that, in fact, we do not even need to build `\Fq[X]`. Its
> > construction (as is the one of `L\{\tau\}`) can be delegated to the constructor
> > of the Drinfeld module. We would come to something like this:
> > 
> > {{{
> > #!python
> > sage: Fq = GF(5^2)
> > sage: L.<omega> = GF(5^6)
> > sage: phi = FiniteDrinfeldModule(Fq, [omega, 1, 1])
> > }}}
> > 
> > What would be your opinion on this?
> 
> I'm not sure because, in full generality, Drinfeld modules are "defined" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would can much trouble.

Ok, that's fine for me.


---

Comment by caruso created at 2022-06-21 09:07:52

Other small comments:
- I think that your constructor should not be `FiniteDrinfeldModule` but just `DrinfeldModule`; it can decide by itself if the Drinfeld module is finite or not (and then instantiate the correct class accordingly).
- IMHO, your `_repr_` method is a bit too verbose; I think that `Drinfeld module X |--> t^2 + t + w` is enough.
- I'm not sure that `sage.rings.function_field` is the right place for your module; indeed, Drinfeld modules are not function fields, and even rings. (However, I don't know where it should go instead.)


---

Comment by @DavidAyotte created at 2022-06-21 18:14:15

Replying to [comment:54 caruso]:
> I'm not sure because, in full generality, Drinfeld modules are "defined" over more general rings that `Fq[x]`. Thus, if in the future, we want to implement more general Drinfeld, I think that making the confusion now between `Fq` and `Fq[x]` would cause much trouble.

I also agree. I think that it is important to note that Drinfeld module are usually defined over two things: a ring a functions (denoted here by `A`) regular outside a closed point of some smooth curve over `Fq` AND a `A`-field `L` (a field with a fixed morphism `A --> L`). In FULL generality, a Drinfeld module is defined over a `A`-scheme `S`, and this implementation focus on the special case `S = Spec(L)`. `A` here plays the same role as the integers `Z` and `L` would play the role of the field of definition of an elliptic curve. However, in the function field setting, we have more rings representing the ring of integers.

> - I think that your constructor should not be `FiniteDrinfeldModule` but just `DrinfeldModule`; it can decide by itself if the Drinfeld module is finite or not (and then instantiate the correct class accordingly).

+1

> - IMHO, your `_repr_` method is a bit too verbose; I think that `Drinfeld module X |--> t^2 + t + w` is enough.

Suggestion:

`Drinfeld Module defined by X |--> t^2 + t + w over Finite Field in w of size 5^6`

This would, in my opinion, agree with most string representation of multiple objects in [SageMath](SageMath). For example, for an elliptic curve we have:

`Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field`


> - I'm not sure that `sage.rings.function_field` is the right place for your module; indeed, Drinfeld modules are not function fields, and even rings. (However, I don't know where it should go instead.)

I don't know too, but maybe it would be better to simply place it in a new directory: `sage.drinfeld_modules`. The other closest directory in my opinion would be `sage.schemes`, but this would be wrong because Drinfeld modules are not schemes.


---

Comment by @DavidAyotte created at 2022-06-21 18:31:59

Also: should this implementation use the function field functionalities already implemented in [SageMath](SageMath)? For example, we have:


```
sage: K.<X> = FunctionField(GF(5**3)); K
Rational function field in X over Finite Field in z3 of size 5^3
sage: O = K.order(1/X); O
Order in Rational function field in X over Finite Field in z3 of size 5^3
sage: X in O
True
sage: 1/X in O
False
```


I have to admit that I'm a little bit on the fence on this, because this would, in my opinion, be a little bit more mathematically precise, however, I don't think that it would be good for computational purpose. What do you all think of this?


---

Comment by tscrim created at 2022-06-22 03:30:27

Thank you all for your comments and explanations.

----

This is a picture of my understanding (using `t = \tau`) of the mathematics.

The main object/category we are considering is

```
DM <=  Hom(Fq[x], L{t})
```

where `DM` is the set of Drinfeld modules, `<=` is subset`, and `L{t}` is the ring of Ore polynomials.
Then taking the `Hom(f,g)` of two elements/objects in `DM`, we get a subset `S` of `L{t}` that has the structure of an `End(g)`-module and `End(g)` is the centralizer of `g(X)` in `L{t}`.

Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.

No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).

----

It is perfectly reasonable to have an entry point `DrinfeldModule` that constructs the `DM` and other associated objects, along with convenience methods to not have the user get these intermediate objects. There are lots of examples of this in the Sage library. Basically `DM` would store the relevant information, such as `Fq[X]` and `L{t}`, which is more aligned with the mathematics. This is what you are calling a category, but it would be just as natural to be a `Parent` IMO.

The biggest justification for using `CategoryObject` to implement Drinfeld modules is that it plugs in naturally with the Sage code `Hom(f, g)`, which you cannot do with ring morphisms. Although this can be worked around with `f.Hom(g)` or something similar. The counterpoint would be it loses the ring morphism knowledge, the data for which you are creating anyways. Also, categories in Sage are not really meant to be used as a substitute `Parent` with a special type of object (i.e., element) class. They are flexible enough to handle this I think, but the general principle is any information they provide should work for generic implementations of the objects.

It might also be possible to trick `Hom` into working (via ducktyping) with setting the right methods to make a `Parent` `DM` behave like a category and the individual Drinfeld modules behave like a `CategoryObject`.

I guess what I am asking is what do you see as the programming/implementation benefits to using `CategoryObject`? I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code. I guess I am arguing above that the code and design of `Parent` and `Element` match more of your actual implementation.

----

I am a strong +1 on having the main entry point `DrinfeldModule` for future code.

I am -1 on a new top-level folder at this point. Given that they are ring morphisms, `rings.drinfeld_modules` (possibly with that as a subfolder) would be a natural place to me. I don't like the precedent of "it is kind of like this but not quite so we put just a few things in a new top-level directory." It could lead to making our source tree very wide. Another option might be `sets`. If we want to think of them as `Fq[X]`-representations on `Fqbar`, then `modules` would also be natural (even if they are not implemented as such). From what I understand, one of the big things you are after is the set of morphisms between Drinfeld modules, which has a module structure.


---

Comment by antoine-leudiere created at 2022-06-22 11:04:44

----
*Constructor name*

Ok for `DrinfeldModule` instead of `FiniteDrinfeldModule`.

----
*`_repr_` output*

I do not have a strong opinion on this. I always prefer to have all the
information, so I would encline to use David's suggestion.

----
*Directory in `sage/`*

I agree with Travis. Although `rings.drinfeld_modules` is not ideal, Drinfeld
modules will probably interest a few only. In this sense, they probably do not
deserve their own directory.

That being said, L-functions have their own top directory (which can be the
precedent that Travis rightfully fears).

----
*`Parent` vs `CategoryObject` vs something else*

Being a novice when it comes to [SageMath](SageMath) development, some of your
considerations are a bit far of reach for me at the moment. In particular, I do
not have a strong opinion on `Parent` vs `CategoryObject`, and I won't help
much with Travis' interrogation:

> I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code.

One thing is sure, as the main maintener and author of the code, I want to
avoid tricks and workarounds as much as possible. I am not (nor will I ever be)
working full time on the code, and I need the codebase to be as straightforward
as possible to maintain and enrich it.

It seems to me however that `CategoryObject` (or `Parent`) might be better than
inheriting `RingHomomorphism`. As Travis pointed out, it plugs naturally with
`Hom` and `Category`. Creating the morphism, keeping it as an attribute, and
overloading `__call__` looks reasonable. Double inheritance is also an option,
even though we all know that it can get tricky.

----

Replying to [comment:56 gh-DavidAyotte]:
> 
> I have to admit that I'm a little bit on the fence on this, because this would, in my opinion, be a little bit more mathematically precise, however, I don't think that it would be good for computational purpose. What do you all think of this?

At some point we will want to use them, if only to extend capabilities of
`DrinfeldModule`. At the moment, I feel like we should stick to basics (i.e.
finite Drinfeld modules over `\Fq[X]`) and finish this first version (I still
have the documentation to write, and probably the `Hom` class to write from
scratch). Those capabilities, even if basics, will surely come out as very
helpful when extending from finite fields to, say, extensions of `\Fq(X)`.

I realize that I forgot to reply to your comment [comment:43]. My bad, David.
To answer: no, I was not planning to open a ticket for the category. As of now,
the discussion is centralized and already attracted some people.


----
Replying to [comment:57 tscrim]:
> 
> This is a picture of my understanding (using `t = \tau`) of the mathematics.
> 
> The main object/category we are considering is
> {{{
> DM <=  Hom(Fq[x], L{t})
> }}}
> where `DM` is the set of Drinfeld modules, `<=` is subset`, and `L{t}` is the ring of Ore polynomials.
> Then taking the `Hom(f,g)` of two elements/objects in `DM`, we get a subset `S` of `L{t}` that has the structure of an `End(g)`-module and `End(g)` is the centralizer of `g(X)` in `L{t}`.

Your understanding is correct.

> Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.

I am not sure to understand what you mean by 'non-generic implementation'.
  
> No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).

Why would `S` be a `Hom` subclass? It looks as being just a subset of `L{t}`
(which itself can be seen as a `Hom(Fqbar, Fqbar)` for the structure of
`Fq`-vector space).


---

Comment by @DavidAyotte created at 2022-06-22 14:43:30

About the directory: I would be okay with `sage.modules.drinfeld_modules`. After some thought, this would be the most natural choice for Drinfeld modules. If we really want to think far ahead, the directory name could be `sage.modules.t_modules.drinfeld_modules`. In short, a _t-module_ is the higher dimensional theory of Drinfeld modules (just like what abelian variety is for elliptic curves). If someone in the future wants such object in [SageMath](SageMath), the name would already be there without the need of renaming and deprecating any imports. But, again I guess that I'm thinking very far ahead and I don't know how likely someone will implement this...

EDIT: a _t-module_ is sometime called an _Anderson t-motive_ in the litterature.


---

Comment by antoine-leudiere created at 2022-06-22 17:36:08

Replying to [comment:59 gh-DavidAyotte]:
> About the directory: I would be okay with `sage.modules.drinfeld_modules`. After some thought, this would be the most natural choice for Drinfeld modules. If we really want to think far ahead, the directory name could be `sage.modules.t_modules.drinfeld_modules`. In short, a _t-module_ is the higher dimensional theory of Drinfeld modules (just like what abelian variety is for elliptic curves). If someone in the future wants such object in [SageMath](SageMath), the name would already be there without the need of renaming and deprecating any imports. But, again I guess that I'm thinking very far ahead and I don't know how likely someone will implement this...
> 
> EDIT: a _t-module_ is sometime called an _Anderson t-motive_ in the litterature.

I fear that putting it in `sage.modules.t_modules.drinfeld_modules` could be very premature. That being said, I do not have a strong opinion on where the class should be defined.


---

Comment by @DavidAyotte created at 2022-06-22 17:40:35

> I fear that putting it in sage.modules.t_modules.drinfeld_modules could be very premature. That being said, I do not have a strong opinion on where the class should be defined.

I have the same feeling, let's forget that and see how this implementation first evolves in the future.


---

Comment by antoine-leudiere created at 2022-06-22 17:48:15

I implemented `Hom` stuff for our Drinfeld modules. Reminder, this is done on
branch `u/antoine-leudiere/finite_drinfeld_modules-category_object`. I think we
can now merge it to the main branch.

*Warning.* _I really do not know what I'm doing_. It is highly possible that I made something not the way it should be done. If so, please correct me, and explain how I should proceed.

Briefly, I created the class `DrinfeldModuleHomset`, that inherits
`sage.categories.homset`. To have the `Hom(phi, psi)` syntax (somehow) working,
I defined methods `Homsets` and `Endsets` for the category `DrinfeldModules`
(they both return the category `Homsets`) — really no idea if this is sound
or not. I also defined methods `Hom` and `End` for `DrinfeldModule`.

Finally, I did some clean up on the code, which is now less ugly.

See the `git log` for more information.


---

Comment by @DavidAyotte created at 2022-06-22 17:57:06

> *Warning.* I really do not know what I'm doing. It is highly possible that I made something not the way it should be done. If so, please correct me, explain explain how I should proceed.

I think that you should start pushing some code to this ticket. Remember, not everything is perfect the first time and a lot of learning is done through trial and errors.


---

Comment by antoine-leudiere created at 2022-06-22 18:05:21

Replying to [comment:63 gh-DavidAyotte]:
> > *Warning.* I really do not know what I'm doing. It is highly possible that I made something not the way it should be done. If so, please correct me, explain explain how I should proceed.
> 
> I think that you should start pushing some code to this ticket. Remember, not everything is perfect the first time and a lot of learning is done through trial and errors.

Hahaha thank you David. Fair enough. I'll do it tomorrow or the day after tomorrow if nobody objects to it.


---

Comment by caruso created at 2022-06-22 18:53:40

My preferences at the moment:
- I still have a clear preference for `CategoryObject` because I think that it is more meaningful mathematically (and I do not see a clear benefit with using `Parent`) but I'm also fine with using `Parent` and I will not complain if we retain this solution at the end.
- For the location, I like `sage.modules.drinfeld_modules.drinfeld_modules`, i.e. creating a directory `sage/modules/drinfeld_modules` and put a file `drinfeld_modules.py` in it. (I think it was not proposed so far.)


---

Comment by antoine-leudiere created at 2022-06-23 08:34:16

Replying to [comment:65 caruso]:
> My preferences at the moment:
> - I still have a clear preference for `CategoryObject` because I think that it is more meaningful mathematically (and I do not see a clear benefit with using `Parent`) but I'm also fine with using `Parent` and I will not complain if we retain this solution at the end.
> - For the location, I like `sage.modules.drinfeld_modules.drinfeld_modules`, i.e. creating a directory `sage/modules/drinfeld_modules` and put a file `drinfeld_modules.py` in it. (I think it was not proposed so far.)

Noted.


---

Comment by caruso created at 2022-06-23 10:06:45

I've splitted the code into several files and add a method `__classcall_private__` for distinguishing between general Drinfeld modules and finite ones.

So far, all the files are in `sage/rings/functions_field/drinfeld_modules` but this can be changed easily.

Finally, for hom sets, I think we need to create a class for morphisms as well. I'll try to do it next week if you haven't done it before.


---

Comment by antoine-leudiere created at 2022-06-23 11:44:49

Last 10 new commits:


---

Comment by antoine-leudiere created at 2022-06-23 11:57:45

Thank you Xavier for your work.

Replying to [comment:68 caruso]:
> Finally, for hom sets, I think to create a class for morphisms as well. I'll try to do it next week if you haven't done it before.

I would very much like to do it at the beginning of next week (I am in doctoral school training today and tomorrow).

Besides this, we should soon after focus on polishing and doctesting the code, so as to submit a first version for review.


---

Comment by caruso created at 2022-06-23 12:59:15

Replying to [comment:71 antoine-leudiere]:
> I would very much like to do it at the beginning of next week (I am in doctoral school training today and tomorrow).

Great!


---

Comment by antoine-leudiere created at 2022-06-23 19:09:34

Running into some trouble. It seems that instantiating `Morphism(phi, psi)` requies `phi`
and `psi` to be parents.


```python
sage: from sage.categories.morphism import Morphism
sage: Fq = GF(3^2)
sage: FqX.<X> = Fq[]
sage: L = Fq.extension(6)
sage: phi = DrinfeldModule(FqX, [L.gen(), 1, 1])
sage: Morphism(phi, phi)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/all_cmdline.py in <module>
----> 1 Morphism(phi, phi)

~/pro/code/finite_drinfeld_modules-sage/source/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/categories/map.pyx in sage.categories.map.Map.__init__ (build/cythonized/sage/categories/map.c:3942)()
    130         C = parent.codomain()
    131         self._category_for = parent.homset_category()
--> 132         self._codomain = C
    133         self.domain    = ConstantFunction(D)
    134         self.codomain  = ConstantFunction(C)

TypeError: Cannot convert FiniteDrinfeldModule to sage.structure.parent.Parent
```


This is not surprising. `Morphism` inherits `Map`. The first parameter of the
`Map` constructor must be a parent. Is this a reason to use `Parent` instead of
`CategoryObject`?


---

Comment by git created at 2022-06-23 19:59:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DavidAyotte created at 2022-06-23 20:37:07

Hello Antoine, you probably already have plenty other stuff to do, but what do you think about implementing a `coefficient` method? This is what I have in mind:

```python
def coefficient(n, a=None):
    """
    Return the `n`-th coefficient of the `\tau`-polynomial `\phi_a(\tau)`.

    INPUT:

    - ``n`` (Integer)
    - ``a`` (polynomial, default: ``None``) -- if ``a`` is set to ``None``, this method
      returns the `n`-th coefficient of `\phi_T(\tau)`
    """
```

(the docstring I wrote is not definitive, feel free to change it however you prefer)


I believe that this method could replace your `g` and `delta` methods.
 
Similarly, you could have a `coefficients(a=None)` (observe the plural form) which would return a _list_ of all the coefficients. If you don't have time for this, I can jump in and implement it, I'll be glad to do it.


Also, I created a stream on the official [SageMath](SageMath) Zulip platform: [drinfeld modules](https://sagemath.zulipchat.com/#narrow/stream/328988-drinfeld-modules). For people interested, I invite you to join it, it might faciliate communications!


---

Comment by tscrim created at 2022-06-24 07:00:53

Replying to [comment:58 antoine-leudiere]:
> ----
> *`_repr_` output*
> 
> I do not have a strong opinion on this. I always prefer to have all the
> information, so I would encline to use David's suggestion.

This is generally a bad philosophy. See large matrices, graphs, and other things that could require significant amount of information. The user can access some of the related attributes they want to distinguish between objects.

> ----
> *Directory in `sage/`*
> 
> That being said, L-functions have their own top directory (which can be the
> precedent that Travis rightfully fears).

This is also probably original code to Sage. `:)`

> ----
> *`Parent` vs `CategoryObject` vs something else*
> 
> Being a novice when it comes to [SageMath](SageMath) development, some of your
> considerations are a bit far of reach for me at the moment. In particular, I do
> not have a strong opinion on `Parent` vs `CategoryObject`, and I won't help
> much with Travis' interrogation:
> 
> > I am not looking for something with the API or that it is closer to how you mathematically think about it, but the underlying code.
> 
> One thing is sure, as the main maintainer and author of the code, I want to
> avoid tricks and workarounds as much as possible. I am not (nor will I ever be)
> working full time on the code,

I don't think anyone here is either. `;)`

> and I need the codebase to be as straightforward as possible to maintain and enrich it.

You are trying to make object of type `X` also be the same as (a fundamentally incompatible) type `Y`. This does not work really well in programming. This is basically what duck-typing in Python in for, and it is a very standard technique in the language. So something has to give.

> It seems to me however that `CategoryObject` (or `Parent`) might be better than
> inheriting `RingHomomorphism`.

I am not suggesting that Drinfeld module should inherit from `Parent` (as it has no elements AFAICS). It is the _set_ of all Drinfeld modules that I am advocating for to be a subclass of `Parent` rather than a subclass of `Category` as it has a natural set of elements.

> As Travis pointed out, it plugs naturally with
> `Hom` and `Category`. Creating the morphism, keeping it as an attribute, and
> overloading `__call__` looks reasonable.

I should point out that Sage also has a category for elements:

```
sage: 2.category()
Category of elements of Integer Ring
sage: type(_)
<class 'sage.categories.category_types.Elements_with_category'>
```

So we might be able to get the best of both worlds for this if you want to think of the Drinfeld modules as objects in a category. I actually had thought you had tried `Hom` on a pair of elements and got errors. In fact, this works:

```
sage: Hom(2, 3)
Set of Morphisms from 2 to 3 in Category of elements of Integer Ring
```

Hence, nothing outside of the normal idioms in Sage should be needed, unlike what I thought in my previous post.
Based on this, I am actually going to be a bit more forceful about having Drinfeld modules be ring homomorphisms rather than a subclass of `CategoryObject` as the infrastructure to have them be objects in a category is already handled by Sage.

`@`caruso Thinking a little bit more about advantages, beyond the technical one of having a specific element class associated to `DM` (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model), I have some others:

You can implement functors (say, by changing the finite field or the Ore polynomial ring) as morphisms from `DM` to `DM'`, which you could naturally compose as morphisms. While functors in Sage can do this, it would not be possible to have this set as a coercion. You actually lose all possibility of using the coercion framework by having `DM` be a category. This also means you can do pushouts:

```
sage: R.<x> = QQ[]
sage: S.<x,y> = ZZ[]
sage: R.has_coerce_map_from(S)
False
sage: S.has_coerce_map_from(R)
False
sage: coercion_model.common_parent(R, S)
Multivariate Polynomial Ring in x, y over Rational Field
```


Anyways, other than this message strongly recommending using `Parent` for `DM` instead of a category, I will stop my advocating now as I am not doing the implementation. If you still disagree that it is the right path forward, then I will defer to your judgement.

> ----
> Replying to [comment:57 tscrim]:
> > Now we don't really know that much about what is in `DM` or `S`. So it doesn't make so much sense to non-generic implementations for them.
> 
> I am not sure to understand what you mean by 'non-generic implementation'.

There are generic implementation of homsets and (sub)sets in Sage.

```
sage: Hom(ZZ, Partitions())
Set of Morphisms from Integer Ring to Partitions in Category of infinite enumerated sets
sage: type(_)
<class 'sage.categories.homset.Homset_with_category'>
```


> > No matter if you think of `DM` as a category or as a `Parent`, the set `S` would still be a `Hom` subclass with a natural coercion to `L{t}` since `S <= L{t}` (as `End(g)`-modules).
> 
> Why would `S` be a `Hom` subclass? It looks as being just a subset of `L{t}`
> (which itself can be seen as a `Hom(Fqbar, Fqbar)` for the structure of
> `Fq`-vector space).

Because it is a set of Drinfeld module morphisms from `f` to `g`. It comes with some default parameters that you would want, more so than `Parent` that you would use as a base class to model `S`.

----

For comment:75, that isn't right. You should be using `Hom`. `Morphism` is the base class for a morphism, the element in a homset. (See also `End`.) If you want a particular morphism, you need to create the homset (a parent) of `phi -> phi` and then pass the necessary data to construct the particular morphism you want.


---

Comment by git created at 2022-07-04 14:40:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-08 22:00:20

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2022-08-08 22:40:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DavidAyotte created at 2022-08-09 14:01:31

Thanks for the updates! Some comments and suggestions:

* A small rephrasing suggestion:

```diff
     .. NOTE::
 
         Drinfeld modules are defined in a larger setting, in which
         `\Fq[X]` is replaced by a more general ring: the ring of
         functions in `k` that are regular outside `\infty`, where `k` is
+        a function field over `\Fq` with transcendance degree `1`
+        and `\infty` is a fixed place of `k`. This is out of the scope
+        of this implementation.
-        a function field whose constant field is `\Fq` and with
-        transcendance degree `1`, and `\infty` is a fixed place of `k`.
-        This is out of the scope of this implementation.
```

* A typo:

```diff
     .. RUBRIC:: Morphisms, isogenies
 
     A *morphism of Drinfeld modules `\phi \to \psi`* is an Ore
     polynomial `f \in K\{\tau\}` such that `f \phi_a = \psi_a f` for
+    every `a \in \Fq[X]`. In our case, this is equivalent to verifying
-    every $a \in \Fq[X]`. In our case, this is equivalent to verifying
```

* In order to be consistent with your notation:

```diff
+    Given an Ore polynomial that equals `\phi_a` for some `a \in
-    Given an Ore polynomial that equals `\phi(a)` for some `a \in
     \Fq[X]`, we can retrieve `a` (as a morphism, a Drinfeld
     module is injective, see [Gos1998]_, cor. 4.5.2.)::
```

* In commit a77f850, you made the following change:

```diff

diff --git a/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py b/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py
index 337f507..52fceff 100644
--- a/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py
+++ b/src/sage/rings/function_field/drinfeld_modules/drinfeld_module.py
@@ -44,8 +44,9 @@ class DrinfeldModule(UniqueRepresentation, CategoryObject):
             ore_polring = None
             ore_polring_base = Sequence(gen).universe()
         else:
-            raise TypeError('generator must be a list of coefficients '\
-                    'or an Ore polynomial')
+
+            raise TypeError('generator must be list of coefficients or an ' \
+                    'Ore polynomial')
```

   I think the original phrasing is the correct way of writting this.

* Some docstrings of some methods should start with `Return...`. For example:

```diff
     def j(self):
         r"""
+        Return the j-invariant of the Drinfeld module; if the rank
+        is not two, raise an exception.
-        If the rank is two, return the j-invariant of the Drinfeld
-        module; if the rank is not two, raise an exception.
```

* The two rank 2 specific methods `g` and `delta` could be generalized to higher ranks in only one method (see my comment:75 ). Therefore, I would suggest to not include `g` and `delta` (so that they wont have to be deprecated in the future).


---

Comment by tscrim created at 2022-08-10 00:21:39

Some quick comments about equality checking:

It is very dangerous to implement an `__eq__` without a `__ne__`. This can lead to _very_ subtle bugs. I have had `x == y` and `x != y` both be `True` and both be `False` because of not doing this.

However, subclasses of `Element` have an easier mechanism for implementing comparisons: `_richcmp_(self, other, op)`, where `op` is an integer telling which type of comparison is being done (there is also an `enum` (effectively) somewhere that you can import that makes it human-readable).

If you want to use `UniqueRepresentation`, then the inputs must uniquely distinguish the object for how to want to define equality (this doesn't have to mean isomorphic).


---

Comment by git created at 2022-08-16 17:02:31

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by antoine-leudiere created at 2022-08-16 17:14:26

Thanks to both of you. I implemented David's suggestions.

Replying to [comment:81 tscrim]:
> If you want to use `UniqueRepresentation`, then the inputs must uniquely distinguish the object for how to want to define equality (this doesn't have to mean isomorphic).

Noted. I think `DrinfeldModuleMorphism` should inherit `UniqueRepresentation`, but my code doesn't work. More in Zulip.


---

Comment by tscrim created at 2022-08-16 23:53:35

I replied in Zulip. Although as much as possible, I would like to have just one centralized place for coding issues (mainly here).


---

Comment by git created at 2022-08-19 15:29:47

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by antoine-leudiere created at 2022-08-19 15:31:00

Many thanks Travis for the help, this was useful.

The work is progressing. I think the docstrings of `DrinfeldModule` can now be reviewed, even though they lack some `TESTS::` fields. I wrote many of the other docstrings as well, even though I did not re-read them.

Some comments:
- David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.
- I renamed the method `DrinfeldModule._get_action_` to `DrinfeldModule.action`. Using representations does not seem appropriate nor standard when it comes to the study of Drinfeld modules.
- I am not too qualified to work with metaclasses. If you review the code, be extra attentive with this aspect.


---

Comment by @DavidAyotte created at 2022-08-19 17:00:32

> David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.

At this point I don't really know if a `DrinfeldModule.coefficient` would be useful or not. Did you had any intention behind the methods `g` and `delta` in the rank two case?

* Small suggestion: I don't think you need to reference the class you are currently documenting inside its own documentation. To me, it is clear enough that we are creating an instance of this class. 


```diff
+    A Drinfeld module object is constructed as follows::
-    A Drinfeld module object (class
-    :class:`sage.rings.function_field.drinfeld_module.drinfeld_module.DrinfeldModule`)
-    is constructed as follows::
```


* Reformulation:

```diff
         sage: ore_polring = phi.ore_polring()
+        sage: t = phi.ore_variable()  # same as ore_polring.gen()
-        sage: t = phi.ore_variable()  # Is ore_polring.gen()
```


* Personnal opinion, but I don't think this remark is really important:

```
     Naturally, the input is checked, and exceptions are raised when the
     input is invalid.
```


* Some rephrasing:

```diff
+    The function ring must be a univariate polynomial ring over `\Fq`::
-    The function ring must be an `\Fq[X]`::

         sage: DrinfeldModule(K, [z, 1, 1])
         Traceback (most recent call last):
         ...
         NotImplementedError: function ring must be a polynomial ring
 
         sage: FqXY.<Y> = FqX[]
         sage: DrinfeldModule(FqXY, [z, 1, 1])
         Traceback (most recent call last):
         ...
+        TypeError: the base ring of the function ring must be a finite field
-        TypeError: function ring base must be a finite field
```


* The methods `DrinfeldModule._repr_`, `DrinfeldModule._latex_` and `DrinfeldModule.action` are still not documented.

* For the `OUTPUT` field, I don't think you need to put a hyphen everytime, since there is generally only one output.

I haven't read everything yet, but I will continue at a later time.


---

Comment by @DavidAyotte created at 2022-08-19 20:30:51

* On lines 471-474, I don't think that this `if` statement is necessary:

```
        # Check gen as Ore polynomial
        if ore_polring not in (None, category.ore_polring()):
            raise ValueError(f'generator must lie in {category.ore_polring()}')
        ore_polring = category.ore_polring()  # Sanity cast
```

    However, the "sanity cast" at line 474 is necessary (otherwise `ore_polring` could be `None`)

* Typo on line 1163, col. 54:

```diff
+                1. The degree of the characteristic divides the height
-                1. The degree of the characteristic devides the height
```


* For the method `DrinfeldModule.velu`, why do you choose return `None` instead of raising an exception ("not an isogeny")?


---

Comment by caruso created at 2022-08-21 15:46:54

Replying to [comment:86 antoine-leudiere]:

> - David, I don't think implementing the method `DrinfeldModule.coefficient` is useful, as the syntax `phi(X)[n]` is shorter and already there. I included all your other suggestions.

I would say that having both is okay; for instance, it is what we have for polynomials.


---

Comment by tscrim created at 2022-08-22 03:36:33

I basically agree with all of David's suggestions. Although I would actually change the "sanity cast":

```diff
         # Check gen as Ore polynomial
-        if ore_polring not in (None, category.ore_polring()):
+        if ore_polring is not None and ore_polring != category.ore_polring():
             raise ValueError(f'generator must lie in {category.ore_polring()}')
         ore_polring = category.ore_polring()  # Sanity cast
```

since you are checking user input.

Personal opinion, but I prefer

```diff
         # Instantiate the appropriate class
         if ore_polring_base.is_finite():
             from sage.rings.function_field.drinfeld_modules.finite_drinfeld_module import FiniteDrinfeldModule
             return FiniteDrinfeldModule(gen, category)
-        else:
-            return cls.__classcall__(cls, gen, category)
+        return cls.__classcall__(cls, gen, category)
```


I would probably rename the very generic name `j()` to `j_invariant()` for Drinfeld modules.

Note also that categories do not have "elements" but "objects," so `random_element()` should be `random_object()` (although, being a broken record, this suggests you are treating it as a `Parent`).


---

Comment by @DavidAyotte created at 2022-08-22 14:45:01

* +1 for renaming `DrinfeldModule.j` into `DrinfeldModule.j_invariant`

Some minor corrections: 

* A duplicate word at line 779:

```diff
    def gen(self):
        r"""
        Return the generator of the Drinfeld module, i.e. `\phi_X`.

        This method makes sense because, in our case, the function ring
+       `\Fq[X]`, which is `\Fq`-generated by a single element whose,
+       image characterizes the Drinfeld module.
-       `\Fq[X]`, which is `\Fq`-generated by a single element element,
-       whose image characterizes the Drinfeld module.
```

* Line 822:

```diff
+    Return the preimage of the input under the Drinfeld module;
-    Return the pre-image of the input under the Drinfeld module;
```

* Small suggestion:

```diff
    def is_finite(self):
        r"""
+       Return ``True`` whether the Drinfeld module is finite.
-       Return ``True`` if the Drinfeld module is finite; return
-       ``False`` otherwise.
```

* Lines 316-317:

```diff
+    Use the ``in`` syntax to test if an Ore polynomial defines a
+    morphism::
-    Use the ``in`` syntax to test if an Ore polynomial defines an
-    isogeny::
```

* Line 380:

```diff
+    Let ``ore_pol`` be a non-zero Ore polynomial. For
-    Let ``ore_pol`` be a non-zero Ore polynomial ``ore_pol``. For
```



---

Comment by git created at 2022-08-22 18:00:49

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by antoine-leudiere created at 2022-08-22 18:01:18

Many thanks to all of you for the quality feedback.

All documentation is basically written; I will write further tests tomorrow. After your review, I will perform a final proofread, lint the code and mark it as experimental. Then, the code will be ready for 'official' review.

I am still a bit skeptical about `rings.function_field.drinfeld_modules`, even though I don't have any better proposal.

I basically added all suggestions, except this one:

> * Some rephrasing:
> {{{
> #!diff
> +    The function ring must be a univariate polynomial ring over `\Fq`::
> -    The function ring must be an `\Fq[X]`::
> 
>          sage: DrinfeldModule(K, [z, 1, 1])
>          Traceback (most recent call last):
>          ...
>          NotImplementedError: function ring must be a polynomial ring
>  
>          sage: FqXY.<Y> = FqX[]
>          sage: DrinfeldModule(FqXY, [z, 1, 1])
>          Traceback (most recent call last):
>          ...
> +        TypeError: the base ring of the function ring must be a finite field
> -        TypeError: function ring base must be a finite field
> }}}

The first proposal is hard to parse; the second does not seem easier, yet it is longer.

> Note also that categories do not have "elements" but "objects," so `random_element()` should be `random_object()` (although, being a broken record, this suggests you are treating it as a `Parent`).

I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects. As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.


---

Comment by @DavidAyotte created at 2022-08-22 18:45:11

I'm not sure to understand what you mean by "hard to parse". 

Also, why do you want to mark the code as experimental?


---

Comment by caruso created at 2022-08-22 19:08:46

Replying to [comment:93 antoine-leudiere]:
> I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects. As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.

Travis' suggestion was just to rename `random_element` to `random_object` and I think he's right.

Also, like David, I think that your code does not need to be marked as experimental. The experimental decorator allows for changing the interface without a decrecation delay; however, in this particular case, I think that we are all more or less satisfied with the current interface and that there is no reason that it will change in a near future.


---

Comment by @DavidAyotte created at 2022-08-22 21:08:23

Also, quick comment, in many places in your docstrings you write `\Fq[X]`, for example:

```
OUTPUT: a polynomial in `\Fq[X]`
```

However, I might be picky with this, but I'm don't think that it's the best formulation as someone might use an other variable name for the `\Fq`-generator of the function ring (for example `"T"`), making most of these docstrings misleading. In particular, this is why I proposed before to change the structure of some sentences into something a little bit more "wordy".


---

Comment by tscrim created at 2022-08-23 02:25:55

Replying to [comment:95 caruso]:
> Replying to [comment:93 antoine-leudiere]:
> > I feel that Xavier now has a solid math. understanding of Drinfeld modules, as I gave him a talk on the subject and we have been working on some computational aspects.
> 
> Travis' suggestion was just to rename `random_element` to `random_object` and I think he's right.

Indeed, that was my suggestion.

However, I would like to know what Xavier thinks about comment:76. The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).

> As he furthermore is a proven [SageMath](SageMath) dev., I am more enclined to following his advice of using `CategoryObject`.

This rankled me a bit since David and I are both "proven [SageMath](SageMath) developers" in any sense of the phrase.

> Also, like David, I think that your code does not need to be marked as experimental. The experimental decorator allows for changing the interface without a decrecation delay; however, in this particular case, I think that we are all more or less satisfied with the current interface and that there is no reason that it will change in a near future.

I also agree with this.


---

Comment by git created at 2022-08-25 14:27:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-08-25 14:28:14

I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so". The way I see it, there are almost no benefits in not using it, but we may on the other hand end up very relieved.

Btw, `random_element` was changed to `random_object` before my reply.


---

Comment by @DavidAyotte created at 2022-08-25 14:52:13

>I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so".

I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).

From a quick glance, I found a small typo:


```diff
+    The constant coefficient must be non zero::
-    The constant coefficient mudt be non zero::
```

I'll check the rest later.


---

Comment by caruso created at 2022-08-25 14:58:27

Replying to [comment:97 tscrim]:
> However, I would like to know what Xavier thinks about comment:76. The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).

Sorry, because of the holidays, I missed your message.

I'm actually not sure that allowing for implicit coercion is desirable here (and, in any case, it won't probably be useful because we have no addition/multiplication on Drinfeld modules). On the other hand, according to me, it is quite important that the implementation reflects as well as possible the mathematical nature/properties of the objects. So I'm still in favour of using `CategoryObject` and not `Parent`.
But, as I said, if there is a clear preference for the other option, it will be okay with me.

Btw, I'm not sure to understand this argument:
>beyond the technical one of having a specific element class associated to DM (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model),


---

Comment by antoine-leudiere created at 2022-08-25 16:21:44

Replying to [comment:100 gh-DavidAyotte]:
> >I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so".
> 
> I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).


I apologize for omitting this: the tag would be temporary (e.g. up to a year).
We agree on the goal; I want to make sure that the first version is as robust
and scalable as we think it is, which is quite tricky to judge without having
tested the module in real life for a few months.


---

Comment by tscrim created at 2022-08-26 02:24:01

Replying to [comment:101 caruso]:
> Replying to [comment:97 tscrim]:
> > However, I would like to know what Xavier thinks about comment:76. The more I see and understand the code, the more I am convinced that you should follow the standard `Parent`-`Element` framework (instead of `Category`-`CategoryObject`). Briefly rereading the above discussion, I am not sure there are any advantages of the current approach other than mathematically the set is generally considered to be a category (which I don't think should play too heavily on the implementation details).
> 
> Sorry, because of the holidays, I missed your message.

No problem.

> I'm actually not sure that allowing for implicit coercion is desirable here (and, in any case, it won't probably be useful because we have no addition/multiplication on Drinfeld modules).

It can help for things like equality (perhaps there is a canonical way to extend something between sets of Drinfeld modules; although I am not sure how this exactly plays with the `UniqueRepresentation`) and conversion (like if it input to a function).

> On the other hand, according to me, it is quite important that the implementation reflects as well as possible the mathematical nature/properties of the objects. So I'm still in favour of using `CategoryObject` and not `Parent`.

I find this argument to be fairly weak overall as you can also think of them as ring homomorphisms (which is the preference of the current documentation), there is a clear set (yes, a small category) of such objects as a subset of another, and there is a category of elements implemented in Sage too. However, I tend to defer to what the code is saying. To me, DrinfeldModule is saying "I want to be an `Element` subclass that belongs to a `Parent` of `DrinfeldModules`" because it is not implementing any of the usual stuff that a category implements but has pushed it up. For example, the comment `# Somehow required for the class definition` is telling. Basically all other `Category` subclasses in Sage are very lightweight objects (in terms of user implementation), but yours is significantly heavier (like a `Parent`) with lots of attributes and getter methods, a fairly distinguished object (i.e. `Element`) class, and lots of references to properties of the category from the object to name some.

> But, as I said, if there is a clear preference for the other option, it will be okay with me.

Anyways, if you aren't convinced, as I promised, I will (try really hard to) stop pushing for it. I just feel it really doesn't reflect what the code is meant to model.

> Btw, I'm not sure to understand this argument:
> >beyond the technical one of having a specific element class associated to DM (in particular, you won't have to write code that works if I come along with my own implementation of Drinfeld modules using a different programming model),

By being a category, it should allow for me to come along with my own implementation of a Drinfeld module and put it in the category and everything in the category should just work. In other words, there should be no dependency on the implementation of the objects of the category (with the necessary prerequisite implementations be marked as ``@`abstract_method`).


---

Comment by tscrim created at 2022-08-26 02:30:30

Replying to [comment:102 antoine-leudiere]:
> Replying to [comment:100 gh-DavidAyotte]:
> > >I spent a long time developing the code and not using it: it is conceivable to me that I (or somebody else) would later want to change some aspects of the end product. The experimental tag tells users: "Ok, this is new, this may change, and the author wants complete freedom for doing so".
> > 
> > I believe that this would be a bad practice for [SageMath](SageMath) and, more generally, for software development. Our common goal here is to develop a robust end product that the general user can conveniently use. Moreover we want that so called end product to be scalable and last over the time (if not, what's the point?).
> 
> 
> I apologize for omitting this: the tag would be temporary (e.g. up to a year).
> We agree on the goal; I want to make sure that the first version is as robust
> and scalable as we think it is, which is quite tricky to judge without having
> tested the module in real life for a few months.

I also very strongly agree with David on this. These tags, even if temporary (experience tells me people's memory is not that good), is a very bad programming practice. We have standard practices within the community here to deal with API changes to the code. Internal changes can just be changed without warning (all software development basically follows this). If you still feel to need complete freedom to change stuff after a long time developing it, then your development process has a deficiency somewhere.

TL;DR I think one needs a extremely good reason for having production code marked as experimental. You have not provided any justification other than "it needs to be tested" (which it is our job, both developers and reviewers, to do so).


---

Comment by antoine-leudiere created at 2022-08-26 16:55:36

Alright.


---

Comment by git created at 2022-08-30 10:35:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-08-30 10:36:59

Proofreading, linting and testing are done. Unless further developments on the `Parent` vs `Category` discussion, I think the code can now be reviewed.


---

Comment by mkoeppe created at 2022-08-30 15:54:24

I only had a chance to take a brief look at the code, but I agree with Travis that this should be `Parent`/`Element`. Nothing much to add to what he explains in comment:103, except to emphasize that `Category` in Sage is a technical framework for managing dynamic `Parent` and `Element` classes. `CategoryObject` is just a low-level technical class - an object that has the notion of a distinguished category and delegates attribute look ups (as in method calls) to that category. Sage is not prepared for `Category` to take on the role of general mathematical categories.


---

Comment by caruso created at 2022-08-30 21:26:25

Replying to [comment:103 tscrim]:
> It can help for things like equality (perhaps there is a canonical way to extend something between sets of Drinfeld modules; although I am not sure how this exactly plays with the `UniqueRepresentation`) and conversion (like if it input to a function).

Again, I'm not sure that having automatic coercion for equality is a good idea here, in a similar fashion that we don't want to implicitely identify an elliptic curve over `QQ` with its scalar extension to some number field.

But, as I said, if you all believe that `Parent`/`Element` is better, let switch back to this, I won't argue more.


---

Comment by antoine-leudiere created at 2022-08-31 16:32:44

`Parent`s and `Element`s usually stand for a set and an element in the set; to manipulate an element (`Element`) of the set, one would _first_ instantiate the set (`Parent`), and then create elements from the set. This is what the average user expects.

This is not the way to appreciate Drinfeld modules. In fact, this would be the opposite: Drinfeld modules are instantiated without their category. In most cases, the user will never care about the category. I am sorry if the big list of getters in the category led you to believe otherwise; and the method `__call__` is meant to be for convenience, nothing else. And, we never consider _the set of Drinfeld modules_. This "set" is always _the category of Drinfeld modules_. Plus we don't want `phi.category()` to be any category (e.g. a category of ring morphisms); we want it to be the category of Drinfeld modules.

It is the same for elliptic curves: they are `Parent`s, not `Element`s. Drinfeld modules however do not have elements, hence `CategoryObject`. Many think about Drinfeld modules the same they think about elliptic curves, and rightfully so.

To me, the `Parent`-`Element` framework does not reflect the mathematical reality.


---

Comment by mkoeppe created at 2022-08-31 16:38:43

In Sage, a `Polyhedron` is also an `Element`, and their parent is only set up behind the scenes and never touched by users.


---

Comment by @DavidAyotte created at 2022-08-31 16:51:14

Replying to [comment:110 antoine-leudiere]:
> `Parent`s and `Element`s usually stand for a set and an element in the set; to manipulate an element (`Element`) of the set, one would _first_ instantiate the set (`Parent`), and then create elements from the set. This is what the average user expects.

As Matthias mentionned, there are examples in Sage where you can directly create an element. An other would be the function `Newform` which creates a modular form element:

```
sage: f = Newform('67a', names='a'); f
q + 2*q^2 - 2*q^3 + 2*q^4 + 2*q^5 + O(q^6)
sage: f.parent()
Cuspidal subspace of dimension 5 of Modular Forms space of dimension 6 for Congruence Subgroup Gamma0(67) of weight 2 over Rational Field
```

I would be in favor in using the already implemented `Parent`/`Element` framework, especially knowing that there is a category of elements in Sage (as mentionned by Travis in comment:76). Moreover, as Antoine pointed out, the user will probably never care about the category, so I don't see the advantages of implementing it.

I think that the parent should be the set of all Drinfeld A-modules of rank r over a field F, where A is the function ring and F is an A-field.


---

Comment by mkoeppe created at 2022-08-31 17:42:02

Replying to [comment:110 antoine-leudiere]:
> [...] hence `CategoryObject`. 

I've explained in comment:108 - `CategoryObject` is just a low-level implementation class, and despite its mathematical-sounding name, it does not model the notion of an "object in a category".
 
If you look for its uses in the Sage library, you'll see that there are exactly 2 direct uses of it (`IntegrableRepresentation`, `TopologicalVectorBundle`)... and both are mistakes.


---

Comment by antoine-leudiere created at 2022-09-01 09:38:12

Alright. `Parent`-`Element` still looks very inadequate; a mathematicians never consider the _category_ of Drinfeld modules as a simple set, and would expect the category of Drinfeld modules to be represented as such. Further, having `phi.category()` being the category of elements (or anything else that is not the category of Drinfeld modules) would be quite poor. The adequation between the interface and the mathematical reality must remain a top priority.

For this reason, I propose `Category` for `DrinfeldModules` and `Parent` for `DrinfeldModule`; like for elliptic curves. I believe this helps with your technical concerns, and we end up with a framework that is representative of the mathematical reality.

For reference, this is what [SageMath](SageMath) does for elliptic curves:


```
sage: E = EllipticCurve(QQ, [1, 1])
sage: E.category()
Category of schemes over Rational Field
sage: isinstance(E.category(), Category)
True
sage: isinstance(E, Parent)
True
```



---

Comment by tscrim created at 2022-09-01 10:00:00

As I have said previously, every set can be made into a category (basically this is the category of elements in the specific `Parent`). Nothing is preventing you from adding stuff to the `Parent` (including in its documentation) to make it act like a category (what would that even be?), but IIRC, none of the actual operations/methods you implemented have it act like a `Category`. Moreover, by your own admission, nobody will likely directly manipulate the category, and thus I think the technical implementation aspects should dominate which base classes to use. As Matthias points out in comment:108, the implementation of `Category` in Sage is not designed to model a general mathematical category.  There are also many things in Sage that play multiple roles; ideals come to mind as they are both `Parent`-like and `Element`-like; it is the latter one the following being an element in the monoid of ideals.

The combinatorics code also has lots of examples where you can directly create elements.

The category of elements **is** the category of Drinfeld modules (just with a funny default name). You will still have `isinstance(phi.category(), Category)` return `True`.

Elliptic curves is not something you should rely too much on as an example of what to do. IIRC, that is very old code when a lot of the structures that we have nowadays were not there (including categories).


---

Comment by @DavidAyotte created at 2022-09-01 12:57:01

Replying to [comment:115 tscrim]:
> As Matthias points out in comment:108, the implementation of `Category` in Sage is not designed to model a general mathematical category.

However, to be fair here, the Sage reference manual:

https://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html

explicitely state:

> The purpose of categories in Sage is to translate the mathematical concept of categories (category of groups, of vector spaces, …) into a concrete software [...]

and

> A category is a Python instance modelling a mathematical category.

Not that it necessarily change my opinion on this discussion, I would be curious in knowing why Sage is not prepared for `Category` to take the role of general mathematical categories. Also, should the reference manual be updated with more accurate information?


---

Comment by tscrim created at 2022-09-01 13:11:12

Be careful about the difference between a general paradigm (lowercase “categories”) and a specific implementation (the class `Category`). In this case, the framework is built around dealing with requisite properties and constructions, not about setting a class (in the mathematical sense of large categories) of objects and their morphisms explicitly, as well as more larger scale properties (e.g., the billion adjectives a category theorist knows such as triangulated). We can model a mathematical category using other implementations that are better equipped for their purpose (such as a diagrammatic category using the partition algebra).

I should also point out that you have cherry-picked your first quote and left off the rest of it that provides some really important context that changes the intent within Sage. They are designed for reducing code duplication and to carry some generic mathematical information (such as what operations should be there with what axioms). Note also in your second quote, it is lower case and says these are examples, not that everything modeling a category needs to be a subclass of `Category`. These are somewhat subtle points though.


---

Comment by @DavidAyotte created at 2022-09-01 13:25:43

Replying to [comment:117 tscrim]:

Okay, I understand the nuance. As you said it is subtle, but it is still there. Thank you very much for the explanations!


---

Comment by git created at 2022-09-09 10:58:47

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by antoine-leudiere created at 2022-09-09 11:00:20

Summary of the changes:
- `DrinfeldModule` is a `Parent`.
- `DrinfeldModules` is a `Category_over_base` (used to be `CategoryWithParameters`).
- `DrinfeldModuleMorphism` now inherits `Morphism`, which is possible because `DrinfeldModule` is a `Parent`.
- I removed the method `__call__` in `DrinfeldModules` to emphasize that this class should not be a `Parent`.
- The base of the category is not a field `K` anymore, but rather the ring morphism `\gamma: \Fq[X] \to K`. The former was misleading and ambiguous.
- I removed the method `change_ring` in `DrinfeldModule`, as the new paradigm is to consider a base morphism and not a base ring.
- Getters of `DrinfeldModule` that corresponded to getters of the category were moved to the `class ParentMethods` part of the category.
- I removed some useless getters like `ore_variable`.

Doc is updated and tests pass. I am happy with the code, it is ready for review.


---

Comment by antoine-leudiere created at 2022-09-09 11:03:40

Changing status from new to needs_review.


---

Comment by @DavidAyotte created at 2022-09-09 15:15:44

I'm still reviewing the file `drinfeld_module.py`:

* In the documentation of `DrinfeldModule`, you mention the terminology "function ring" before defining it:

```
    A *Drinfeld `\Fq[X]`-module over the base `\gamma`* is an
    `\Fq`-algebra morphism `\phi: \Fq[X] \to K\{\tau\}` such that:

        1. The image of `\phi` contains non-constant Ore polynomials.
        2. For every element `a` in the function ring, the constant
           coefficient `\phi(a)` is `\gamma(a)`.

    For `a` in the function ring, `\phi(a)` is denoted `\phi_a`.

    The Drinfeld module `\phi` is uniquely determined by the image
    `\phi_X` of `X`, which is an input of the class.

    We say that `\Fq[X]` is the *function ring of `\phi`*; *K\{\tau\}*
    is the *Ore polynomial ring of `\phi`*.
```


* Suggestion + typo, lines 205 - 206:

```diff
+     The Drinfeld modules `\phi` and `\rho` have different base. That of
+    `\phi` is surjective while that of `\rho` is not::
-     Drinfeld modules `\phi` and `\rho` have different based. That of
-    `\phi` is surjective while that of `\rho` is note::
```

* Typo, line 430 of `drinfeld_module.py`:

```diff
    .. NOTE::

+        In this implementation, `L` is `K`.
-        In this implementation, `L` is `L`.
```

* On comment:88, I mentionned that I don't think that this `if` statement (lines 520 - 522) is necessary:

```python
        # Check gen as Ore polynomial
        if ore_polring is not None and \
                ore_polring != category.ore_polring():
            raise ValueError(f'generator must lie in {category.ore_polring()}')
```

    You still haven't addressed that, even though you made the change proposed by Travis in comment:90. After testing  bit your code, I wasn't able to recreate the `ValueError` you raise. However, if this `if` statement is really necessary, you should make a doctest in order to test it. Also, looking at your code, I hardly see why the test `ore_polring != category.ore_polring()` could be true as `category` is constructed using `ore_polring`.

* Small latex suggestion, line 712:

```diff
+    Return the `n`-th coefficient of the generator.
-    Return the n-th coefficient of the generator.
```


* Whenever you have a private class attribute with an associated method, instead of calling the method, you can directly access the attribute:

    Line 1053

```diff
+        return self._gen.degree()
-        return self.gen().degree()
```


* Suggestion: a lot of your examples and tests are made using Drinfeld modules over a `Fq[X]`-field of finite characteristic. I think, for better coverage, it would be good to add some examples of Drinfeld modules over `Fq[X]`-fields of generic characteristic. In my opinion, this would better emphasize the fact that your implementation does not only work for finite Drinfeld modules.


---

Comment by tscrim created at 2022-09-10 01:06:03

All you’ve done is put lipstick on a pig with your changes, and like that mental image suggests, things are worse and scarier than before without make any fundamental changes:

- You have a `Parent` without an `Element` and the category is still acting like a parent.
- A morphism is not a ring. So the category is the wrong base class.
- `DrinfeldModules` should have a way to build its elements through `DrinfeldModules(foo)`.
- You are significantly abusing the input of the morphism parent with it not being a homset (both mathematically (as I understand it) and practically).

What I think would be the way forward:

- `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).
- `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).
- There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.
- You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.

Even if you are insistent on using `CategoryObject`, you have a number of issues to fix to get the hog ready for sale at the market.

(PS - I am not meaning to use swine as a negative, it just fit the idiom. They are delicious, an important commodity, and can be quite cute.)


---

Comment by @DavidAyotte created at 2022-09-10 03:04:31

Strong **+1** to everything Travis said. 

Our mathematician minds likes to think that a parent is the same as an object in a category (me included, especially with Drinfeld modules), however, the Python programming reality is that one should use the framework which is best suited for the situation. The `Parent/Element` framework should always come as pair: a **parent** which contains **elements**. Therefore, if you only implement a parent without any elements, you are using the wrong framework.

On an unrelated note, I'm pretty sure this deleted line is not intentional:

```diff
diff --git a/src/sage/rings/function_field/all.py b/src/sage/rings/function_field/all.py
index b6bba33..6904f3e 100644
--- a/src/sage/rings/function_field/all.py
+++ b/src/sage/rings/function_field/all.py
@@ -1 +1 @@
-from .constructor import FunctionField
+from .drinfeld_modules.all import *
```


This removes the class `FunctionField` from the global namespace and it is probably why there are so many failed [doctests](https://github.com/sagemath/sagetrac-mirror/runs/8268621152?check_suite_focus=true).


---

Comment by caruso created at 2022-09-10 07:30:54

Replying to [comment:124 Travis Scrimshaw]:
> What I think would be the way forward:
> - `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).
> - `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).
> - There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.
> - You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.

I agree that, if we move to the `Parent`/`Element` paradigm, we should define a parent (the set of Drinfeld modules) having elements (the Drinfeld modules).

However, what is the category (and I strongly believe that there should be a category because we want to handle morphisms)? Of course, it has to be the category of Drinfeld modules. But it is redundant with the parent (btw, should the constructor of the category just take the parent as input?). Besides, regarding notations, all the categories in `sage.categories` are called `Foobars` and never `FoobarsCategory`.

To be honest, I'm a bit embarassed with this because it will certainly cause confusion. Probably not so much, actually, because the user will basically never see the parent, nor the category. However, the sword of Damocles is here.

In a previous comment, I remember that David suggested to include the rank of the Drinfeld module in the parent. I'm not in favor of this because if we insist on viewing Drinfeld modules as morphisms `phi : Fq[X] -> L{tau}`, I can't see why it could be relevant to have different parents according to the degree of `phi(X)`. (We don't have specific parents for Ore polynomials of given degrees.)


---

Comment by tscrim created at 2022-09-10 08:16:44

Replying to [comment:126 Xavier Caruso]:
> Replying to [comment:124 Travis Scrimshaw]:
> > What I think would be the way forward:
> > - `DrinfeldModules` should be a `Parent` (possibly of a `Homset`).
> > - `DrinfeldModule` should be a subclass of `Element` (possibly of a `RingHomomorphism`).
> > - There is a new category of `DrinfeldModulesCategory` that is returned by the `category()`.
> > - You want a new parent that is a subclass of `Homset` for the Drinfeld module morphisms.
> 
> I agree that, if we move to the `Parent`/`Element` paradigm, we should define a parent (the set of Drinfeld modules) having elements (the Drinfeld modules).
> 
> However, what is the category (and I strongly believe that there should be a category because we want to handle morphisms)? Of course, it has to be the category of Drinfeld modules. But it is redundant with the parent (btw, should the constructor of the category just take the parent as input?).

I can make a category out of any set (Sage even lets me do this and even create morphisms between them too!). Moreover, you do not have to implement anything here (most likely): There is a default class for categories of elements. You're wanting to break a lot of established coding paradigms in Sage for the mathematical purity of one particular viewpoint.

> Besides, regarding notations, all the categories in `sage.categories` are called `Foobars` and never `FoobarsCategory`.

I should have made it clear this was a placeholder name and may not have to be implemented so that there wouldn't be confusion. I was running out the door as I was finishing my post. Sorry about that.

> To be honest, I'm a bit embarassed with this because it will certainly cause confusion. Probably not so much, actually, because the user will basically never see the parent, nor the category. However, the sword of Damocles is here.

We have this actually all over Sage and it has never caused confusion. Many objects carry multiple ways of looking at them, and those sometimes carry different implementations. An example would be matrices/linear maps. To bring in another weapon, I think you're tiling at windmills here.

EDIT - Another example is the category of bases of an algebra, e.g., symmetric functions. In contrast to the case here, (IMO) most people actually just think of this as a set and don't think of the equality of elements as being morphisms, but they are because we have a distinguished basis (this would be like a change of basepoint for homotopoy groups). Furthermore, those parents actually have elements as well.


---

Comment by caruso created at 2022-09-10 09:58:19

Replying to [comment:127 Travis Scrimshaw]:
> I can make a category out of any set (Sage even lets me do this and even create morphisms between them too!). Moreover, you do not have to implement anything here (most likely): There is a default class for categories of elements.

Ah okay.


---

Comment by @DavidAyotte created at 2022-09-10 14:09:35

Replying to [comment:126 Xavier Caruso]:
> In a previous comment, I remember that David suggested to include the rank of the Drinfeld module in the parent. I'm not in favor of this because if we insist on viewing Drinfeld modules as morphisms `phi : Fq[X] -> L{tau}`, I can't see why it could be relevant to have different parents according to the degree of `phi(X)`. (We don't have specific parents for Ore polynomials of given degrees.)

From the literature, people usually consider the category of Drinfeld modules of fixed rank with morphism being the isogenies (isogenous Drinfeld modules must have the same rank). This is the reason why I mentioned this, and, honestly, I don't have a very strong opinion about this, except that it would be closer to the maths. Thus, I don't think it would be much of a problem to consider the parent of all Drinfeld modules of arbitrary ranks and I would be in favor of using any approach which is better from a programming viewpoint. I'm guessing here that if we don't include the rank in the parent, there would probably be less unecessary creation of different parents (with only the ranks varying).


---

Comment by caruso created at 2022-09-13 16:18:34

I'm trying to re-implement this ticket along the lines proposed by Travis.

And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).

The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).

In order to go ahead, I see two options:
- either we stay with the current implement and let Drinfeld modules be parents,
- or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).

What's your opinion? (Or do you see another solution?)


---

Comment by @spaenlehauer created at 2022-09-13 17:04:41

Replying to [comment:124 Travis Scrimshaw]:
> All you’ve done is put lipstick on a pig with your changes, and like that
> mental image suggests, things are worse and scarier than before without make
> any fundamental changes: 

No, you are wrong, all Antoine has done is not just "put lipstick on a pig".

> What I think would be the way forward:
>
>   - `DrinfeldModules` should be a Parent (possibly of a Homset).
>   - `DrinfeldModule` should be a subclass of Element (possibly of a `RingHomomorphism`).
>   - There is a new category of `DrinfeldModulesCategory` that is returned by the category().
>   - You want a new parent that is a subclass of Homset for the Drinfeld module morphisms. 

I disagree with Travis' suggestions. The main reason is that I believe
that a class implementing Drinfeld modules should not be a subclass of a class
implementing ring morphisms, because this fails to capture correctly the notion
of morphisms of Drinfeld modules.

To be a bit clearer, let's look at a similar situation for elliptic curves.
Elliptic curves are most often constructed from a bivariate polynomial
`y<sup>2-x</sup>3-a*x-b` and this is how they are often stored and manipulated. However,
it would be misleading to say that an elliptic curve *is* a bivariate
polynomial. More precisely, an elliptic curve should not be seen as an element
of the ring of bivariate polynomials; it is just a way to construct and to
manipulate it. This is why it is often said that an elliptic curve *is defined
by* such a polynomial, but not that it *is* such a polynomial.

The reason for this is that polynomials fail to capture correctly the notion of
morphisms of elliptic curves. And this is why implementing elliptic curves as a
subclass of a class implementing bivariate polynomials would be very confusing.

The situation is similar for Drinfeld modules. In maths, it is said that a
Drinfeld module *is* a ring morphism, but I believe that it would be less
confusing to say that it *is defined by* a ring morphism, as in the case of
elliptic curves.

This is not only an abstract issue.  If Drinfeld modules are represented via a
subclass of ring morphisms as Travis suggests, then a user who would like to
access morphisms of Drinfeld modules via Hom(phi, psi) (where phi, psi are
Drinfeld modules) would get an erroneous result, and this seems problematic to
me.
We should consider that these ring morphisms are just a way to represent
objects in the category of Drinfeld modules, but they are not enough to
represent the morphisms of Drinfeld modules.

I believe that this problem does not arise with Antoine's current code.
This is why I prefer the structure of Antoine's current code to Travis'
suggestions.

Also, I should say that I agree with Xavier's remarks and concerns, and I do
not believe that he is "tiling at windmills" (and no need to bring in "another
weapon", nor any other pejorative/agressive metaphor; please let this public
space remain a non-hostile environment; please check https://github.com/sagemath/sage/blob/develop/CODE_OF_CONDUCT.md).

Concerning the question of the Parent vs Element framework, I believe that the
implementation of elliptic curves is very nice and they are parents without
elements. This is consistent with the fact they are objects in a non-concrete
category (objects have no underlying set). I don't see why using a similar
framework for Drinfeld modules would pose any problem. 

Travis, could you please elaborate on the reason why you think that using a
structure similar to that of the implementation of elliptic curves would be bad?

In summary, I believe that Antoine's code is in good shape, and that following
Travis' suggestions would introduce problems related to the fact that
inheriting from ring morphisms would not capture well the category of Drinfeld
modules (and in particular their morphisms, which are very important for
practitioners), and which would lead to erroneous and confusing behaviours (for instance `Hom(phi,psi)`, or `phi.category()` would be wrong).


---

Comment by @spaenlehauer created at 2022-09-13 17:08:54

Replying to [comment:130 Xavier Caruso]:
> I'm trying to re-implement this ticket along the lines proposed by Travis.
> 
> And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).
> 
> The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).
> 
> In order to go ahead, I see two options:
> - either we stay with the current implement and let Drinfeld modules be parents,
> - or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).
> 
> What's your opinion? (Or do you see another solution?)

Many thanks Xavier for trying to implement Travis' suggestions. As I mention above, I agree with you that his suggestions create problems with morphisms. My opinion is that Antoine's current code is fine and that we can stay with it.


---

Comment by @DavidAyotte created at 2022-09-13 18:47:23

Replying to comment:131
> Concerning the question of the Parent vs Element framework, I believe that the implementation of elliptic curves is very nice and they are parents without elements. This is consistent with the fact they are objects in a non-concrete category (objects have no underlying set). I don't see why using a similar framework for Drinfeld modules would pose any problem.

According to the Sage reference manual:

> Parents are the Sage/mathematical analogues of container objects in computer science.

As you know, a big difference between Drinfeld modules and elliptic curves is that the latter has points. For example, in Sage we can do


```
sage: E = EllipticCurve([0,0,1,-1,0])
sage: E.an_element()
(0 : -1 : 1)
sage: E.point_set()
Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 - x over Rational Field
```


Hence, even though elliptic curves does not have a dedicated elements class, they still do want to act like a "container objects". In the case of Drinfeld modules, there is no analogues to this, because they don't have points. It's not even a variety, it just "acts" like one by its properties. However, I do have a suggestion:

* `DrinfeldModule` inherits from parent
* New Category `DrinfeldModules`
* New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\phi(a) = \phi_a` for `a \in A = Fq[T]`

One could create a Drinfeld module `\phi` in the same way that Antoine nicely implemented. Then, calling the element constructor method `\phi(a)` for any element `a \in Fq[T]` would return a "Drinfeld module action element" represented by the Ore polynomial `\phi_a(\tau)` where `\tau` is the `q`-frobenius. We would therefore have something like:

```
sage: A = GF(5)['T'], K.<T> = Frac(A)
sage: phi = DrinfeldModule(A, [T, K.one()])
sage: phi
Drinfeld module defined by T |--> t + T over [...]
sage: s = phi(T^2); s
t^2 + (T^5 + T)*t + T^2
sage: s.parent()
Drinfeld module defined by T |--> t + T over [...]
```


This is one way that I would see to "artificially" consider an element class for a Drinfeld module, however one downside that I see from my proposition is that we would not directly manipulate Ore polynomials when we manipulate "Drinfeld module action element", hence the need to reimplement some Ore polynomial-specific methods. However, I know that if I was a user and I wanted to do computations in a CAS with Drinfeld modules, then I would probably want to manipulates objects like `\phi_a(\tau)` and recover the mathematical information they give. Therefore, I think that the implemention definitely should focus on this aspect.

---

Replying to comment:130:
>In order to go ahead, I see two options:
>
> * either we stay with the current implement and let Drinfeld modules be parents,
> * or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).

In the case of option 2 do you think it would be a lot work to reimplement the methods related to composition?


---

Comment by caruso created at 2022-09-13 19:19:36

Replying to [comment:133 David Ayotte]:
> As you know, a big difference between Drinfeld modules and elliptic curves is that the latter has points.

I actually don't think that it's a problem to have a parent without elements.

But, if you do think that it's indeed a problem, my opinion is that using the class `CategoryObject` is (theoretically) a right way to solve this. Okay, maybe, this class was not designed for this use case at first, and it has lost all meaning in the current version of sage... but then, why not revive it today?
I think that Drinfeld modules (and maybe elliptic curves) are the perfect situation in which it can make a lot of sense.

> However, I do have a suggestion:
> 
> * `DrinfeldModule` inherits from parent
> * New Category `DrinfeldModules`
> * New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\phi(a) = \phi_a` for `a \in A = Fq[T]`

I'm not sure to understand the benefit of this.

*If we really want to have elements* (but I insist that I think that it is not needed), I would define an element of a Drinfeld module `phi` as an element of the algebraic closure of `K` (or maybe, more generally, any element lying in a `K`-algebra), this set being equipped with the action of `Fq[X]` given by `phi`.

> >In order to go ahead, I see two options:
> >
> > * either we stay with the current implement and let Drinfeld modules be parents,
> > * or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).
> 
> In the case of option 2 do you think it would be a lot work to reimplement the methods related to composition?

Honestly, I don't know; my feeling is that it will basically consist in rewriting the code in `sage.categories.morphism`, but not assuming that `domain` and `codomain` are parents, though some simplifications should be possible if you restrict ourselves to Drinfeld modules.


---

Comment by @DavidAyotte created at 2022-09-13 20:08:25

Replying to [comment:134 Xavier Caruso]:
> > However, I do have a suggestion:
> > 
> > * `DrinfeldModule` inherits from parent
> > * New Category `DrinfeldModules`
> > * New element class `DrinfeldModuleActionElement` (or any other name) being the set of all `\phi(a) = \phi_a` for `a \in A = Fq[T]`
> 
> I'm not sure to understand the benefit of this.
> 
> *If we really want to have elements* (but I insist that I think that it is not needed), I would define an element of a Drinfeld module `phi` as an element of the algebraic closure of `K` (or maybe, more generally, any element lying in a `K`-algebra), this set being equipped with the action of `Fq[X]` given by `phi`.

(*If we really want to have elements*) I also thought about your definition of an "element". As much as it could makes sense mathematically, I don't think that, as a user, I would want to directly manipulate elements of K with an induced action of `Fq[T]`. I would be more interested in the information given by the Ore polynomial `\phi_a`. There are indeed interesting objects that we can compute using the `\phi_a` (for example: computing logarithms and exponential associated to `\phi`). My suggestion was a quick naive attempt to make a potential element class more "centered around" these specific Ore polynomials that the user would probably want to manipulate (I hope I'm clear). But again, this is if we absolutely want to have an element class, otherwise we can scrap this idea!

Before my main concerns were more centered about future of the code, but now I am more centered around the user and I don't think that wether `DrinfeldModule` is a parent or not would change anything for the user. According to your implementation (thank you for that!), there definitely seems to be some technical benefit in keeping the current implementation (thank you Antoine for all your work!).


---

Comment by tscrim created at 2022-09-14 00:27:19

Replying to [comment:130 Xavier Caruso]:
> I'm trying to re-implement this ticket along the lines proposed by Travis.
> 
> And I realized that the fact that a Drinfeld module is not a parent causes a lot of headache when we are coming to morphisms between Drinfeld modules; indeed, this roughly prevents from inheriting from `Morphism` becomes this class implicity assumes everywhere that the domain and the codomain are parents (typically, the cython attributes `_domain` and `_codomain` are declared to be parents).

This remains a problem even if you revert back to `CategoryObject`. I am very strongly opposed to having a `Parent` that does not have elements as the code, mathematical model, and documentation explicitly are based upon this.

> The right solution would probably be to have a general class for morphisms in a category (whose elements are not parents and which cannot be necessarily callable). However, it does not exist (correct me if I'm wrong) and it's not the purpose of this ticket to implement it (and btw, I don't really have the courage to do it now).

No, it doesn't exist. There are some technical challenges and larger organizational things to be done to get this to work. It should be possible with actually somewhat minimal changes, but it will require some thought on the design (and likely some political discussions).

> In order to go ahead, I see two options:
> - either we stay with the current implement and let Drinfeld modules be parents,
> - or we let `DrinfeldModulesMorphism` just derive from `Element` and reimplement all the methods related to composition (`_mul_`, `pre_compose`, `post_compose`, etc.).
> 
> What's your opinion? (Or do you see another solution?)

Unfortunately, I think you are stuck with the second option. This is basically what `Functor` does.


---

Comment by tscrim created at 2022-09-14 00:32:56

Actually, let me explain a bit of my idea to get `Map` to work more generally:

- We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.
- We downgrade `Parent _codomain` to `CategoryObject _codomain`.

Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.


---

Comment by tscrim created at 2022-09-14 02:32:28

Replying to [comment:131 gh-spaenlehauer]:
> Replying to [comment:124 Travis Scrimshaw]:
> > All you’ve done is put lipstick on a pig with your changes, and like that
> > mental image suggests, things are worse and scarier than before without make
> > any fundamental changes: 
> 
> No, you are wrong, all Antoine has done is not just "put lipstick on a pig".

You should actually provide evidence instead of just simply stating it. I mentioned a number of reasons why it is basically the same implementation.

> > What I think would be the way forward:
> >
> >   - `DrinfeldModules` should be a Parent (possibly of a Homset).
> >   - `DrinfeldModule` should be a subclass of Element (possibly of a `RingHomomorphism`).
> >   - There is a new category of `DrinfeldModulesCategory` that is returned by the category().
> >   - You want a new parent that is a subclass of Homset for the Drinfeld module morphisms. 
> 
> I disagree with Travis' suggestions. The main reason is that I believe
> that a class implementing Drinfeld modules should not be a subclass of a class
> implementing ring morphisms, because this fails to capture correctly the notion
> of morphisms of Drinfeld modules.

This is exactly what subclasses are for: To extend functionality that does not exist at a more general level.

> To be a bit clearer, let's look at a similar situation for elliptic curves.
> Elliptic curves are most often constructed from a bivariate polynomial
> `y<sup>2-x</sup>3-a*x-b` and this is how they are often stored and manipulated. However,
> it would be misleading to say that an elliptic curve *is* a bivariate
> polynomial. More precisely, an elliptic curve should not be seen as an element
> of the ring of bivariate polynomials; it is just a way to construct and to
> manipulate it. This is why it is often said that an elliptic curve *is defined
> by* such a polynomial, but not that it *is* such a polynomial.
>
> The reason for this is that polynomials fail to capture correctly the notion of
> morphisms of elliptic curves. And this is why implementing elliptic curves as a
> subclass of a class implementing bivariate polynomials would be very confusing.

Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.

> The situation is similar for Drinfeld modules. In maths, it is said that a
> Drinfeld module *is* a ring morphism, but I believe that it would be less
> confusing to say that it *is defined by* a ring morphism, as in the case of
> elliptic curves.

Is your point that the mathematics is wrong? The definition as given says it is a certain subset of ring morphisms defined by a particular property.

> This is not only an abstract issue.  If Drinfeld modules are represented via a
> subclass of ring morphisms as Travis suggests, then a user who would like to
> access morphisms of Drinfeld modules via Hom(phi, psi) (where phi, psi are
> Drinfeld modules) would get an erroneous result, and this seems problematic to
> me.

This makes no sense to me. You still have a set of morphisms between the objects, which is the `Parent` for any such morphism. You should not get anything different, that would be a bug due to the implementer of the specific behavior. What would be wrong with the returned homset? To get non-generic behavior, you need to implement something.

> We should consider that these ring morphisms are just a way to represent
> objects in the category of Drinfeld modules, but they are not enough to
> represent the morphisms of Drinfeld modules.

I see this argument akin to saying we shouldn't implement an algebra as a subclass of a module implementation (see all the subclasses of `CombinatorialFreeModule`). Furthermore, the morphisms are a completely separate implementation.

> I believe that this problem does not arise with Antoine's current code.
> This is why I prefer the structure of Antoine's current code to Travis'
> suggestions.

You haven't said anything specific or exact to justify your claims. You have used vague words such as "enough" without saying what it means to have it represent something. Can you be more precise here with what you want?

> Also, I should say that I agree with Xavier's remarks and concerns, and I do
> not believe that he is "tiling at windmills" (and no need to bring in "another
> weapon", nor any other pejorative/agressive metaphor; please let this public
> space remain a non-hostile environment; please check https://github.com/sagemath/sage/blob/develop/CODE_OF_CONDUCT.md).

First, if you want to claim such violations, please attempt to do so evenly and fairly. Second, you should understand the idiom of "tilting at windmills" (sorry for the typo in my post) means going after something that is not an actual problem. There is no violation by pointing out that I think the issue raise there is not a problem.

> Concerning the question of the Parent vs Element framework, I believe that the
> implementation of elliptic curves is very nice and they are parents without
> elements. This is consistent with the fact they are objects in a non-concrete
> category (objects have no underlying set). I don't see why using a similar
> framework for Drinfeld modules would pose any problem. 
> 
> Travis, could you please elaborate on the reason why you think that using a
> structure similar to that of the implementation of elliptic curves would be bad?

In addition to the mathematical differences I pointed to above, you need to let the code speak to you. In particular, the implementation details will give you a good guide. If you implement all of the methods and behaviors of class `Foo`, you should almost always inherit from class `Foo` or have a common ABC. As I have said repeatedly, everything that is in the category is doing what a `Parent` does and not a `Category`, everything in the `DrinfeldModule` is doing what an `Element` does, not a `CategoryObject`.

From what Xavier did, it seems we have hit a limitation/assumption in the implementation of `Map`.

> In summary, I believe that Antoine's code is in good shape, and that following
> Travis' suggestions would introduce problems related to the fact that
> inheriting from ring morphisms would not capture well the category of Drinfeld
> modules (and in particular their morphisms, which are very important for
> practitioners),

> and which would lead to erroneous and confusing behaviours (for instance `Hom(phi,psi)`, or `phi.category()` would be wrong).

This is claim is demonstratively false. You get a homset and you get a category of all Drinfeld modules with certain parameters (albeit stored indirectly in the parent class, which is more of the object you want to use anyways).

```
sage: x = 2
sage: y = 3
sage: H = Hom(x, y)
sage: H
Set of Morphisms from 2 to 3 in Category of elements of Integer Ring
sage: x.category()
Category of elements of Integer Ring
```



---

Comment by caruso created at 2022-09-14 04:43:46

(Combined answer.)

Replying to [comment:136 Travis Scrimshaw]:
> This remains a problem even if you revert back to `CategoryObject`.

That's correct.

But since I definitely think that it is a better solution, I feel more motivation to make it work :-). However, as we both said, this needs more discussion as it touches at the core of Sage.

That's why my proposal for now would be to stay with `Parent` (i.e. to allow parents without elements) and to remember that we have the plan to move to `CategoryObject` in the future.

I actually do not see the problem with having temporarily one parent without elements, i.e. for which `_element_constructor_` raises an error. Would this break something? (I think it wouldn't because we already have one such parent, namely `EllipticCurve`.)

Replying to [comment:137 Travis Scrimshaw]:
> Actually, let me explain a bit of my idea to get `Map` to work more generally:
> 
> - We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.
> - We downgrade `Parent _codomain` to `CategoryObject _codomain`.
> 
> Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.

I basically agree with this, except that I do not believe that `Element` should derive from `CategoryObject`. Okay, maybe, at some point, it can be convenient to form the category of elements of some parent (btw, is this construction currently used somewhere in sage?) but I definitely think that we do not have to encourage this behaviour.

Replying to [comment:138 Travis Scrimshaw]:
> Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.

No, that's not correct! This works maybe over an algebraically closed field (of characteristic zero?) but this does not work in full generality. In full generality, it is better to say that the elliptic curve is just the datum of the (Weierstrass) equation defining it (or, equivalenty, the ideal generated by this equation, or the quotient ring by this ideal, or the scheme associated to this ring...). In any case, it is not clear what is an element of an elliptic curve.


---

Comment by mkoeppe created at 2022-09-14 05:40:14

Replying to [comment:139 Xavier Caruso]:
> I actually do not see the problem with having temporarily one parent without element, i.e. for which `_element_constructor_` raises an error. Would this break something?

I think this is perfectly fine. 

Another example of parents that don't have (proper) elements are facade parents.
You can still have meaningful morphisms between parents that don't have elements.
In fact, in #34461 I introduce such "pointless" morphisms.


---

Comment by tscrim created at 2022-09-14 05:50:28

Replying to [comment:140 Matthias Köppe]:
> Replying to [comment:139 Xavier Caruso]:
> > I actually do not see the problem with having temporarily one parent without element, i.e. for which `_element_constructor_` raises an error. Would this break something?
> 
> I think this is perfectly fine. 
> 
> Another example of parents that don't have (proper) elements are facade parents.
> You can still have meaningful morphisms between parents that don't have elements.
> In fact, in #34461 I introduce such "pointless" morphisms.

They do not have proper elements, but they still are modeling a set with elements with the corresponding properties such as containment and an `_element_constructor_`. So this is not an example.


---

Comment by mkoeppe created at 2022-09-14 06:08:01

I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.


---

Comment by tscrim created at 2022-09-14 06:26:35

Replying to [comment:139 Xavier Caruso]:
> (Combined answer.)
> 
> Replying to [comment:136 Travis Scrimshaw]:
> > This remains a problem even if you revert back to `CategoryObject`.
> 
> That's correct.
> 
> But since I definitely think that it is a better solution, I feel more motivation in make it work :-). However, as we both said, this needs more discussion as it touches at the core of Sage.
> 
> That's why my proposal for now would be to stay with `Parent` (i.e. to allow parents without elements) and to remember that we have the plan to move to `CategoryObject` in the future.

I think this would be taking on a large amount of technical debt and would set some bad precedents. I can settle for `CategoryObject`, as much as I strongly disagree with using `Category` instead of `Parent`, as a compromise, but not with using `Parent`.

The good news is that because you don't have any algebraic operations, you don't have to implement all of the morphism stuff based around coercion. You will probably want to do custom compositions anyways, right? (Currently, composing two of them will not have an `ore_polynomial` method I believe.) Plus things like injective and surjective no longer make sense, correct? This is probably better for the API, and I don't think there are too many things that will need to be duplicated.

> I actually do not see the problem with having temporarily one parent without elementd, i.e. for which `_element_constructor_` raises an error. Would this break something? (I think it wouldn't because we already have one such parent, namely `EllipticCurve`.)

Your proposal is quite different than what `EllipticCurve` does:

```
sage: E = EllipticCurve([0,0,1,-1,0])
sage: E.gens()
[(0 : -1 : 1)]
sage: E.an_element()
(0 : -1 : 1)
```

Although I don't know anything about the Mordell-Weil group, but it not registered as an element in `E`. `E` also implements a `__contains__` method.

My understanding is that the `EllipticCurve` setup is fairly old code to Sage, predating categories, coercion, etc. that have been around for a long time. So that gives it less weight as a precedent, and I doubt anyone has a desire to spend lots of time rewriting it as it currently works.

Let me restate again that a `Parent` is suppose to model a set of elements. Breaking the fundamental model of a class is an evil practice. Thus, I think it is not behavior to be encouraged.

> Replying to [comment:137 Travis Scrimshaw]:
> > Actually, let me explain a bit of my idea to get `Map` to work more generally:
> > 
> > - We strip many of the set/`Parent`-like operations from `CategoryObject` (perhaps as a new intermediate class) and make `Element` a subclass of `CategoryObject`.
> > - We downgrade `Parent _codomain` to `CategoryObject _codomain`.
> > 
> > Note that it makes sense to have `Element` as `CategoryObject` since they have a category. It also makes a distinction between more general `SageObject`s and things in a category. This would fit better with the mathematics. Finally, there is no major refactoring that would need to be done.
> 
> I basically agree with this, except that I do not believe that `Element` should derive from `CategoryObject`. Okay, maybe, at some point, it can be convenient to form the category of elements of some parents (btw, is this construction currently used somewhere in sage?) but I definitely think that we do not have to encourage this behaviour.

Why? It is an object in a category. The category of elements is essentially just a different implementation of the set to make it fit with some of the other infrastructure within Sage.

In fact, the behavior that you want in this ticket is basically already there within Sage too. There is just a technical limitation due to an assumption that all things that want morphisms are subclasses of `Parent` (well, just their codomain I think).

> Replying to [comment:138 Travis Scrimshaw]:
> > Indeed, because an elliptic curve is the zero set of the polynomial as I understand it (from a quick look at the Wikipedia page). So this is a non-sequitur.
> 
> No, that's not correct! This works maybe over an algebraically closed field (of characteristic zero?) but this does not work in full generality. In full generality, it is better to say that the elliptic curve is just the datum of the (Weierstrass) equation defining it (or, equivalenty, the ideal generated by this equation, or the quotient ring by this ideal, or the scheme associated to this ring...). In any case, it is not clear what is an element of an elliptic curve.

Ah, yea, what I said is too simplistic of a perspective. However, it is still not the polynomial but a related object.


---

Comment by tscrim created at 2022-09-14 06:30:30

Replying to [comment:142 Matthias Köppe]:
> I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.

One can, but it is far less than ideal. A `NotImplementedError` (possibly a `AttributeError` if called directly) sends a very different signal than an `EmptySetError` or a `ValueError`. Its message also contains relevant information to the user too. I would be hunting for a bug if I got:

```
sage: class Foo(Parent):
....:     pass
....:     
sage: F = Foo()
sage: F(2)
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
Input In [7], in <cell line: 1>()
----> 1 F(Integer(2))

File ~/sage-build/src/sage/structure/parent.pyx:878, in sage.structure.parent.Parent.__call__()
    876 """
    877 if self._element_constructor is None:
--> 878     raise NotImplementedError(f"cannot construct elements of {self}")
    879 cdef Py_ssize_t i
    880 cdef R = parent(x)

NotImplementedError: cannot construct elements of <__main__.Foo object at 0x7fbdbd537a60>
```



---

Comment by tscrim created at 2022-09-14 06:31:44

I am not versed in scheme theory. Are there many different empty-as-set schemes?


---

Comment by mkoeppe created at 2022-09-14 06:40:40

Replying to [comment:144 Travis Scrimshaw]:
> Replying to [comment:142 Matthias Köppe]:
> > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> > Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.
> 
> One can, but it is far less than ideal. 

I disagree. 

In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. 

All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.

Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). 
You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.


---

Comment by tscrim created at 2022-09-14 06:48:11

Replying to [comment:146 Matthias Köppe]:
> Replying to [comment:144 Travis Scrimshaw]:
> > Replying to [comment:142 Matthias Köppe]:
> > > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> > > Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.
> > 
> > One can, but it is far less than ideal. 
> 
> I disagree. 
> 
> In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. 

I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).

> All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.

True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.

> Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). 
> You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.

They should both be `Parent`s. One of which is just an empty set (plus some additional structure).


---

Comment by mkoeppe created at 2022-09-14 06:56:07

Replying to [comment:147 Travis Scrimshaw]:
> Replying to [comment:146 Matthias Köppe]:
> > I disagree. 
> > 
> > In my opinion, the best way to think about what a `Parent` is, is something that makes sense as domain and codomain of morphisms. 
> 
> I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).

No, I disagree with retrofitting such an interpretation to `CategoryObject`. I've explained my view in comment:108. `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.

> > All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.
> 
> True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.

No, it's not established at all that `Parent` defines `__contains__` to mean the set-theoretic "element-of" relation. That's only true for a `Parent` in the category of `Sets`.


---

Comment by tscrim created at 2022-09-14 07:07:12

Replying to [comment:148 Matthias Köppe]:
> Replying to [comment:147 Travis Scrimshaw]:
> > I think this is what `CategoryObject` should become. There are some vestiges of this, but it isn't supported (yet).
> 
> No, I disagree with retrofitting such an interpretation to `CategoryObject`. I've explained my view in comment:108. `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.

Currently, it does not. I am also not suggesting we make `Element` a subclass of `CategoryObject` as-in; some refactoring is required. However, its documentation states

```
Base class for objects of a category
```

and elements belong to a category.

I think this would be the least invasive change needed for this ticket that is not being contrary to our current documentation and implementions.

> > > All of that "is like a container" and "models a set" are just didactical simplifications that don't capture the full story.
> > 
> > True, but by being a subclass, the implementation is agreeing to follow the requirements given by the base (`Parent` `:p`) class.
> 
> No, it's not established at all that `Parent` defines `__contains__` to mean the set-theoretic "element-of" relation. That's only true for a `Parent` in the category of `Sets`.

It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage). Is that correct?

Edit - Changed my last question as it was not meant to sound sarcastic.


---

Comment by mkoeppe created at 2022-09-14 07:14:48

Replying to [comment:149 Travis Scrimshaw]:
> Replying to [comment:148 Matthias Köppe]:
> > `CategoryObject` is a technical implementation class. It does not have the mathematical meaning that you are trying to give it.
> 
> Currently, it does not.

Yes, and my point is, don't try to change it on the basis of a narrow theory about what a `Parent` is.


---

Comment by mkoeppe created at 2022-09-14 07:18:06

Replying to [comment:149 Travis Scrimshaw]:
> It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage).

`Parent` probably contains a lot of legacy code that predates the category framework. I'd urge not to put too much weight on such implementation details.


---

Comment by mkoeppe created at 2022-09-14 07:28:37

Replying to [comment:144 Travis Scrimshaw]:
> Replying to [comment:142 Matthias Köppe]:
> > I think you are missing that, to pick up one of the examples further up in this discussion, a `Scheme` can be empty as a set, and leaving `_element_constructor_` unimplemented is a perfectly fine way to model that. 
> > Whether something is "empty as a set" or "in principle doesn't have elements" is probably a distinction that is not important enough to model in our code.
> 
> [...] A `NotImplementedError` (possibly a `AttributeError` if called directly) sends a very different signal than an `EmptySetError` or a `ValueError`. 

You are right; instead of "leaving it unimplemented", I should have said "always raising a `ValueError`".


---

Comment by tscrim created at 2022-09-14 07:45:42

Replying to [comment:151 Matthias Köppe]:
> Replying to [comment:149 Travis Scrimshaw]:
> > It sounds like you are proposing to ignore what is in its documentation and the structure of its implementation (and how it is (near?) universally used within Sage).
> 
> `Parent` probably contains a lot of legacy code that predates the category framework. I'd urge not to put too much weight on such implementation details.

The current design of `Parent` is primarily based around the coercion system. In particular, it is designed to be a set with elements, which is also reflected in its documentation. The legacy parts of it are methods like `base_ring()` that are there in general but need to be fast (and possibly time-consuming to refactor out).

What we are seeing is the need for a different class hierarchy that supports elements actually being objects in a category.

Right now, we have:

```
SageObject  (a generic object in Sage)
+ CategoryObject  (a technical class)
+ Element  (an element of a Parent)
```

I don't actually see the point of having `CategoryObject` being a technical class. It has only one "real" subclass: `Parent` (comment:113). (Note that `SageObject` has other subclasses not listed.)
| + Parent  (a container class for elements)
What I am proposing is something like the following:

```
SageObject (generic object in Sage)
+ CategoryObject (an generic object in a generic category)
  + Element (an element of a parent)
  + Parent (an object in a concrete category)
```

So we would the old `CategoryObject` would merge the elements that treat it like a set with `Parent` (e.g., `gens()`, `base_ring()`). For legacy reasons, we can a class in between `CategoryObject` and `Parent`.

Advantages:

- We have a clear mathematical meaning matching their name and their doc.
- Elements can now easily have morphisms between them (changing the type of `Map._codomain`) without major refactoring.
- Potentially less pollution of the tab-completion name space with unimplemented/unrelated methods.
- It requires very little coding.
- We might even be able to have the result of `Element.category()` return the parent.

Disadvantages:

- Elements might have to have a category initialized when created. Although if the parent becomes the category, then this is moot.
- There are more base classes for `Element`, and it might become a heavier class (I don't think it will though).


---

Comment by caruso created at 2022-09-14 08:12:02

Replying to [comment:153 Travis Scrimshaw]:
> The current design of `Parent` is primarily based around the coercion system.
> In particular, it is designed to be a set with elements, which is also reflected in its documentation. The legacy parts of it are methods like `base_ring()` that are there in general but need to be fast (and possibly time-consuming to refactor out).

I think actually that it would make sense to set up the coercion system at a higher level (if we decide to have one).
Of course, coercion is important for dealing with elements but it is also meaningful for parents themselves, e.g. for dealing with morphisms. For instance if `f : A -> B` and `g : C -> D` are morphisms (in some category) and `B` coerces to `C`, the composite `g*f` could make sense. 

> What we are seeing is the need for a different class hierarchy that supports elements actually being objects in a category.

I don't see this.
For me, Drinfeld modules really live at the level of parents, even though they are modeled by morphisms: a Drinfeld module is defined by a ring homomorphism but it is a different object (e.g. we do not want to apply the same operations on them) and making the confusion may be dangerous.

> Right now, we have:
> {{{
> SageObject  (a generic object in Sage)
> + CategoryObject  (a technical class)
> | + Parent  (a container class for elements)
> + Element  (an element of a Parent)
> }}}
> I don't actually see the point of having `CategoryObject` being a technical class. It has only one "real" subclass: `Parent` (comment:113). (Note that `SageObject` has other subclasses not listed.)

I'm happy with this organization and doesn't want to change it. In particular, I don't want to make `Element` a subclass of `CategoryObject` as you proposed.

In my understanding, `CategoryObject` could be a class for parents without elements (I understand that it is not the case currently, I mean that ideally it could be). But if you say that it's already okay to have parents without elements, I just propose to get rid of this class `CategoryObject` (which is apparently almost not used).


---

Comment by tscrim created at 2022-09-14 08:21:52

It is very clearly documented that a parent has elements:

> Parents are the Sage/mathematical analogues of container objects in computer science.

The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.


---

Comment by caruso created at 2022-09-14 08:29:21

Replying to [comment:155 Travis Scrimshaw]:
> It is very clearly documented that a parent has elements:
> 
> > Parents are the Sage/mathematical analogues of container objects in computer science.

That's true but we can always update the documentation :-).

> The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.

I'm certainly fine with using a new class for this; it could be `CategoryObject` but it could also be something else, I don't really care (though I think that the name `CategoryObject` is very well suited). But if it's not needed, I prefer not reorganizing the complete Sage's classes hierarchy and I still don't understand why simply using `Parent` is not good. Okay, there is no element and it is written in the documentation that `Parent`s have `Element`s but, apart from this, would this be the source of concrete issues?


---

Comment by tscrim created at 2022-09-14 10:07:48

Replying to [comment:156 Xavier Caruso]:
> Replying to [comment:155 Travis Scrimshaw]:
> > It is very clearly documented that a parent has elements:
> > 
> > > Parents are the Sage/mathematical analogues of container objects in computer science.
> 
> That's true but we can always update the documentation :-).

And you can always update the code too. However, the implementation and uses also speaks volumes. `;)`

> > The class is designed for objects that have elements, and the entire implementation supports that. A Drinfeld module is definitely not a `Parent`. You need a new class for something that has morphisms but not elements. The set of such objects is a set (a small category) and the `Category` class is not designed to be used to model such things, but `Parent` is with objects being `Element`.
> 
> I'm certainly fine with using a new class for this; it could be `CategoryObject` but it could also be something else, I don't really care (though I think that the name `CategoryObject` is very well suited). But if it's not needed, I prefer not reorganizing the complete Sage's classes hierarchy and I still don't understand why simply using `Parent` is not good. Okay, there is no element and it is written in the documentation that `Parent`s have `Element`s but, apart from this, would this be the source of concrete issues?

So you don't find any of these to be reasons why it is not good:

- is used contrary to the documentation (and essentially all other uses within Sage),
- many of the methods will not work, including with errors that are saying things should be implemented (see `NotImplementedError` from the element constructor),
- at any given time, `Parent` would be well within its rights to enforce the set-like behavior and break your code,
- it leads to an abuse of the `Category` implementation (the two biggest to me are: there is a distinguished implementation for its objects; it duplicates a lot of what `Parent` does) ,
- it sets a bad precedent that roughly say "because there is one feature we really want, we can use a class however we want".

Let me be clear, I don't see any way I will budge from my position here. I am trying my hardest to give you solutions that are acceptable to me with minimal effort (and I am willing to implement, which I don't think I made clear). If you want to take this to sage-devel for a discussion/vote because you think we will remain at an impasse, we can.


---

Comment by mkoeppe created at 2022-09-14 14:25:19

Replying to [comment:155 Travis Scrimshaw]:
> It is very clearly documented that a parent has elements:
> 
> > Parents are the Sage/mathematical analogues of container objects in computer science.

I have already explained in comment:146 that this is a didactical simplification.


---

Comment by mkoeppe created at 2022-09-14 14:36:28

Replying to [comment:153 Travis Scrimshaw]:
> The current design of `Parent` is primarily based around the coercion system. 

Yes, and the mechanism for discovering coercion morphisms between parents and the way that parents participate in the pushout construction are very important even if the morphisms are never called on an element.

See again #34461.

> In particular, it is designed to be a set with elements, which is also reflected in its documentation. 

Didactical simplification.


---

Comment by mkoeppe created at 2022-09-14 14:48:33

Replying to [comment:153 Travis Scrimshaw]:
> What I am proposing is something like the following:
> {{{
> SageObject (generic object in Sage)
> + CategoryObject (an generic object in a generic category)
>   + Element (an element of a parent)
>   + Parent (an object in a concrete category)
> }}}
> So we would the old `CategoryObject` would merge the elements that treat it like a set with `Parent` (e.g., `gens()`, `base_ring()`). For legacy reasons, we can a class in between `CategoryObject` and `Parent`.
> 
> Advantages:
> [...]
> - Elements can now easily have morphisms between them (changing the type of `Map._codomain`) without major refactoring.

There would indeed be a value in allowing an Element to be the domain or codomain of morphisms.

I actually have a strong use case for this: a `Polyhedron` mathematically clearly is a set, but it is implemented as an `Element`, which is in part motivated by an algebra structure on families of polyhedra.
But we would also like to be able to set up a morphism (say, in the category of topological spaces) from a polyhedron to another polyhedron. This is not possible currently.

But it feels that this is a separate issue. So I think we should have a new ticket where we discuss a design that supports such use cases.


---

Comment by tscrim created at 2022-09-15 00:02:56

Replying to [comment:159 Matthias Köppe]:
> Replying to [comment:153 Travis Scrimshaw]:
> > The current design of `Parent` is primarily based around the coercion system. 
> 
> Yes, and the mechanism for discovering coercion morphisms between parents and the way that parents participate in the pushout construction are very important even if the morphisms are never called on an element.

The pushout constructions are a separate thing as it is built from manipulating functors. It is used by the coercion system to construct a `Parent` `N` that contains two elements in different `Parent`s `X` and `Y`. But it is only evoked when there is no coercion, nor does it create one between the parents `X` and `Y`. All we would really need is the `construction()` method for this to be extended to any object.

> > In particular, it is designed to be a set with elements, which is also reflected in its documentation. 
> 
> Didactical simplification.

Replying to [comment:158 Matthias Köppe]:
> Replying to [comment:155 Travis Scrimshaw]:
> > It is very clearly documented that a parent has elements:
> > 
> > > Parents are the Sage/mathematical analogues of container objects in computer science.
> 
> I have already explained in comment:146 that this is a didactical simplification.

You are not disputing it is correct. By allowing something that is clearly not meant to be a container object would be ignoring this completely (and again, the implementation details of the class). Anytime I hear someone say, "parts of this class can be used in broader generality," this means you should be refactoring things out, not "let's use this class anyways as-is, even if this is a [spacebar](https://xkcd.com/1172/)." (It isn't that extreme here, but that is the underlying logic of the argument.)


---

Comment by mkoeppe created at 2022-09-15 00:26:53

No, Travis, what's not correct is trying to use this didactical explanation as a definition, and pretending that it canonically extends to what your interpretation is.


---

Comment by mkoeppe created at 2022-09-15 00:36:58

Replying to [comment:147 Travis Scrimshaw]:
> > Consider two implementation classes that implement `Scheme`s - one whose instances are schemes that always have points (elements), one that never has points (elements). 
> > You don't want to say that one of them should be a `Parent`, the other one shouldn't be a `Parent`.
> 
> They should both be `Parent`s. One of which is just an empty set (plus some additional structure).

Good that we agree on this; my point is that the empty one does not need an element class, and its element constructor can always raise an error.


---

Comment by tscrim created at 2022-09-15 00:43:20

No, Matthias, you can't just ignore documentation (and the implementation) when it doesn't suit you. All documentation  is didactic; it is teaching you what the class is designed for and to be treated as. I can make an argument for anything to be "a simplification of something more general." Using beyond the documentation is bad practice; this is what subclasses are for.


---

Comment by mkoeppe created at 2022-09-15 00:48:05

Replying to [comment:164 Travis Scrimshaw]:
> No, Matthias, you can't just ignore documentation (and the implementation) when it doesn't suit you.

It's poorly written, which leads you to your mistaken interpretation.


---

Comment by mkoeppe created at 2022-09-15 00:51:56

Replying to [comment:153 Travis Scrimshaw]:
> What I am proposing is something like the following:
> {{{
> SageObject (generic object in Sage)
> + CategoryObject (an generic object in a generic category)
>   + Element (an element of a parent)
>   + Parent (an object in a concrete category)
> }}}

Strong -1 on that. An object that is an `Element` must continue to refer to its parent to get the category if it refers to its role as an element of that parent.

Your proposed change of the design would rule out the possibility that an `Element` can also have the role of a `Parent`. (This is currently not possible, I think, but only because of an implementation restriction due to Cython extension classes.)


---

Comment by mkoeppe created at 2022-09-15 00:57:44

In my example with polyhedra, I would like to have for example
a semigroup (parent) of polyhedra (element), but each polyhedron is also a parent whose element class is a point.
There are 3 separate categories involved: 
- Semigroups
- Join of Topological Spaces, Elements of semigroups 
- Elements of Topological Spaces


---

Comment by mkoeppe created at 2022-09-15 01:08:45

By the way, I haven't recently looked at the branch here on the ticket. In particular, in particular I haven't looked at what it does with `Category`. But I 
- object to your use of these overreaching claims on the illegitimacy of `Parent`s without `Element`s as an argument; and 
- I would urge not to demand that work here can only be done after a refactoring that retrofits `CategoryObject` with a mathematical meaning is done.


---

Comment by mkoeppe created at 2022-09-15 01:20:26

I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in comment:166, comment:167.


---

Comment by tscrim created at 2022-09-15 02:03:20

Replying to [comment:166 Matthias Köppe]:
> Replying to [comment:153 Travis Scrimshaw]:
> > What I am proposing is something like the following:
> > {{{
> > SageObject (generic object in Sage)
> > + CategoryObject (an generic object in a generic category)
> >   + Element (an element of a parent)
> >   + Parent (an object in a concrete category)
> > }}}
> 
> Strong -1 on that. An object that is an `Element` must continue to refer to its parent to get the category if it refers to its role as an element of that parent.

I don't see what is changing other than potentially `Element.category()` returning the parent instead of the `Elements` category (which I am not 100% sold on doing). The category of the parent and the structure is embedded as part of its MRO through dynamic classes. This part doesn't change.

> Your proposed change of the design would rule out the possibility that an `Element` can also have the role of a `Parent`. (This is currently not possible, I think, but only because of an implementation restriction due to Cython extension classes.) 

Perhaps this would be impossible if the category of the element is a `Parent`. This is something that would need to be played around with. I don't see how changing the ABC hierarchy prohibits this.


---

Comment by tscrim created at 2022-09-15 02:16:56

Replying to [comment:168 Matthias Köppe]:
> By the way, I haven't recently looked at the branch here on the ticket. In particular, in particular I haven't looked at what it does with `Category`. But I 
> - object to your use of these overreaching claims on the illegitimacy of `Parent`s without `Element`s as an argument; and 

You can disagree with the legitimacy of it, but it is far from overreaching. It would be a fundamental change and sets a bad precedent.

> - I would urge not to demand that work here can only be done after a refactoring that retrofits `CategoryObject` with a mathematical meaning is done.

While perfect can be the enemy of the good, allowing bad practices is not something that should be taken lightly.

An alternative approach would be to just reimplement the parts of `Map`/`Morphism` for the Drinfeld module morphisms. (I am giving a concession of allowing the use `CategoryObject` too.)


---

Comment by tscrim created at 2022-09-15 02:19:41

Replying to [comment:169 Matthias Köppe]:
> I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in comment:166, comment:167.

We can move the discussion there, but until that is resolved (or a sage-devel vote is done), this ticket cannot be positively reviewed while using `Parent`.


---

Comment by mkoeppe created at 2022-09-15 02:42:44

Replying to [comment:172 Travis Scrimshaw]:
> Replying to [comment:169 Matthias Köppe]:
> > I've opened #34534 for a discussion focused on what a `Parent` is and what refactoring may be necessary to cover use cases that I explain in comment:166, comment:167.
> 
> We can move the discussion there, but until that is resolved (or a sage-devel vote is done), this ticket cannot be positively reviewed while using `Parent`.

Well, this is exactly what I have criticized as improper in comment:168.


---

Comment by mkoeppe created at 2022-09-15 02:45:55

Replying to [comment:171 Travis Scrimshaw]:
> It would be a fundamental change and sets a bad precedent.

I shall presume that this has never been pointed to you: This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.


---

Comment by mkoeppe created at 2022-09-15 02:58:40

Replying to [comment:161 Travis Scrimshaw]:
>  Anytime I hear someone say, "parts of this class can be used in broader generality," this means you should be refactoring things out, not "let's use this class anyways as-is, even if this is [BAD].

That's too generic an argument. Yes, refactoring is good when it is done correctly.
But your analysis is too quick and does not lead to the correct result.
In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK.


---

Comment by tscrim created at 2022-09-15 02:58:58

Replying to [comment:174 Matthias Köppe]:
> Replying to [comment:171 Travis Scrimshaw]:
> > It would be a fundamental change and sets a bad precedent.
> 
> I shall presume that this has never been pointed to you:

You would be wrong, and I also make arguments for why it might be an exceptional circumstance (and do cost/benefit analysis).

> This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.

This isn't a slippery slope, which says "if we allow A, then this will lead to B, which will lead to D, which is BAD". By allowing this, it says "we can break rule A, so everyone can break rule A", and there would be no point in having the rule (here, it is following the current documentation and implementation details). If you want to allow the violation, give justification about what makes this case special.


---

Comment by mkoeppe created at 2022-09-15 03:02:54

Replying to [comment:176 Travis Scrimshaw]:
> Replying to [comment:174 Matthias Köppe]:
> > Replying to [comment:171 Travis Scrimshaw]:
> > > It would be a fundamental change and sets a bad precedent.
> > 
> > I shall presume that this has never been pointed to you:
> 
> You would be wrong, and I also make arguments for why it might be an exceptional circumstance (and do cost/benefit analysis).
> 
> > This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.
> 
> This isn't a slippery slope

I said "akin".


---

Comment by tscrim created at 2022-09-15 03:04:03

Replying to [comment:175 Matthias Köppe]:
> Replying to [comment:161 Travis Scrimshaw]:
> >  Anytime I hear someone say, "parts of this class can be used in broader generality," this means you should be refactoring things out, not "let's use this class anyways as-is, even if this is [BAD].
> 
> That's too generic an argument. Yes, refactoring is good when it is done correctly.
> But your analysis is too quick and does not lead to the correct result.
> In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admits 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 

And I still believe having multiple `Element` classes for a particular parent is a good thing that we want. However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case. If you want to apply a theorem that starts with "assume there exists X", you cannot expect it to hold true when X does not exist.


---

Comment by mkoeppe created at 2022-09-15 03:05:21

Replying to [comment:176 Travis Scrimshaw]:
> there would be no point in having the rule (here, it is following the current documentation and implementation details)

No, Travis, you just did it again. You are trying to prove that it's violating a rule (BAD), so it will lead to more BAD things. But what you are presuming is exactly what I dispute. I have clearly said so in comment:165.


---

Comment by mkoeppe created at 2022-09-15 03:06:13

Replying to [comment:178 Travis Scrimshaw]:
> > In #31247#comment:21, you tried to sell me on the foundational importance of `Parent`s that admit multiple `Element` classes. Well, and I say that in my thickest fake American accent, **I'm buying**. When we implement a `Parent` so that it can admits 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 
> 
> And I still believe having multiple `Element` classes for a particular parent is a good thing that we want.

Yes, so do I, that's why I'm buying it!


---

Comment by mkoeppe created at 2022-09-15 03:07:02

Replying to [comment:178 Travis Scrimshaw]:
> However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case.

Please, Travis.


---

Comment by tscrim created at 2022-09-15 03:11:59

Replying to [comment:177 Matthias Köppe]:
> Replying to [comment:176 Travis Scrimshaw]:
> > Replying to [comment:174 Matthias Köppe]:
> > > This type of argument, akin to the slippery slope fallacy, has zero argumentative value. In order to prove that "Parent with no Element" = BAD, you are presuming that it is BAD and are cautioning that it will lead to more BAD things.
> > 
> > This isn't a slippery slope
> 
> I said "akin".

Then I amend my respond to say "This isn't akin to a slippery slope". Although how strongly do you want to make the association?

Imagine I took a dollar from your wallet (without asking). This is bad (like all stealing), but you say it is okay because I used it to buy a sip of water (I was dying of thirst in the heat and inflation is so bad, that's all I could afford `:P`). Now someone else sees this and steals a dollar from your wallet and says they bought a sip of water. Is that okay?


---

Comment by tscrim created at 2022-09-15 03:13:34

Replying to [comment:181 Matthias Köppe]:
> Replying to [comment:178 Travis Scrimshaw]:
> > However, the positive integers are not nonnegative integers and induction doesn't allow you to go backwards from the base case.
> 
> Please, Travis.

No, really Matthias. That is what your argument is based on: If something is true for `1, 2, 3, ...` it should be true for `0`. If you have another separate argument, please explain.


---

Comment by mkoeppe created at 2022-09-15 03:15:48

You know that I know that you know that I know that induction does not work this way. So I don't buy it that you believe you caught me in a fallacious application of mathematical induction.


---

Comment by mkoeppe created at 2022-09-15 03:17:45

Look Travis, chatting with you is fun, but you are overdoing your argumentative tactics that it's not so amusing any more in the end. For example comment:182 - obviously the discussion of what "akin" means is irrelevant for anything here - and you are using it as a distraction.


---

Comment by tscrim created at 2022-09-15 03:44:53

Replying to [comment:184 Matthias Köppe]:
> You know that I know that you know that I know that induction does not work this way. So I don't buy it that you believe you caught me in a fallacious application of mathematical induction.

Yes, I know you know how induction works. However, I am not able to understand how my argument applies to `0` because my argument is based on the existence of at least one distinguished `Element` and induction (there is nothing special about that one particular `Element` class, so we can add one more). I am pointing out that my argument breaks down and needs to be replaced by another one if you want `0` included.


---

Comment by tscrim created at 2022-09-15 03:50:15

Replying to [comment:185 Matthias Köppe]:
> Look Travis, chatting with you is fun, but you are overdoing your argumentative tactics that it's not so amusing any more in the end. For example comment:182 - obviously the discussion of what "akin" means is irrelevant for anything here - and you are using it as a distraction.

I am not meaning to; I did not know you meant because I was writing my reply before comment:179 and didn't understand what point you were trying to make.

I would then respond by saying all of the tickets you want to enforce strict compliance with the Python `abc.collections` should be allowed too as they are (at best) weaker breaking of abstract behaviors (I still contend those are fundamentally different because of the weakness of the `isinstance` test).


---

Comment by mkoeppe created at 2022-09-15 04:23:34

The solution to the riddle:

Replying to [comment:175 Matthias Köppe]:
> When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 

The context of this was refactoring. Both you and I agree that there must be a class that support 0 `Element` classes (that's your retrofitted `CategoryObject`) and there must be a class that supports 1, 2, 3, ... `Element` classes. Now standard programming wisdoms lead to the conclusion that these "two classes" should actually be the same class, namely one that supports 0, 1, 2, 3, ... `Element` classes. Because "a for loop can also handle 0 iterations".


---

Comment by tscrim created at 2022-09-15 04:37:56

Replying to [comment:188 Matthias Köppe]:
> The solution to the riddle:
> 
> Replying to [comment:175 Matthias Köppe]:
> > When we implement a `Parent` so that it can admit 1, 2, 3, ... `Element` classes, then the correct way to implement is in a way that also 0 `Element` classes are OK. 
> 
> The context of this was refactoring. Both you and I agree that there must be a class that support 0 `Element` classes (that's your retrofitted `CategoryObject`) and there must be a class that supports 1, 2, 3, ... `Element` classes. Now standard programming wisdoms lead to the conclusion that these "two classes" should actually be the same class, namely one that supports 0, 1, 2, 3, ... `Element` classes. Because "a for loop can also handle 0 iterations".

I see what you are saying now. I agree with you here completely. Do you agree that the same wisdom says we should have

```
+ Foo -- handles 0, 1, 2, ... `Element` classes
  + Bar -- has specialized code that assumes >= 1 `Element` classes
```

Furthermore, do you also agree that subclassing `Bar` when something does have 0 `Element` classes is bad?


---

Comment by mkoeppe created at 2022-09-15 04:45:52

No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.


---

Comment by mkoeppe created at 2022-09-15 04:56:16

My final remark before I go to bed: Note that the idea of a category that "does not have an element class" has no mathematical meaning because the category of elements of a category has a general functorial construction. So the whole thing is a distinction on the level of programming - so the programming wisdoms apply.


---

Comment by caruso created at 2022-09-15 05:49:05

Replying to [comment:190 Matthias Köppe]:
> No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.

It looks like there is a misunderstanding here.

Certainly, the class `Foo` (or `Adult` say) should only be used to handle 0 `Element` classes but also certainly `Bar` (or `Parent`) has to inherit for `Foo`.
IMO, the class `Adult` should implement the coercion mecanism whereas the methods `_element_constructor` and `__call__` should be reserved to `Parent`.


---

Comment by tscrim created at 2022-09-15 07:04:41

Replying to [comment:192 Xavier Caruso]:
> Replying to [comment:190 Matthias Köppe]:
> > No, the same wisdoms would say that you would maybe have a specialized subclass for 0 (for optimization purposes), but not one for >= 1.
> 
> It looks like there is a misunderstanding here.
> 
> Certainly, the class `Foo` (or `Adult` say) should only be used to handle 0 `Element` classes but also certainly `Bar` (or `Parent`) has to inherit for `Foo`.
> IMO, the class `Adult` should implement the coercion mecanism whereas the methods `_element_constructor` and `__call__` should be reserved to `Parent`.

I agree with Xavier here. Other examples: We could have `Polytope` (i.e., a bounded polyhedron) as a subclass of `Polyhedron` as it is a specialized version where we could optimize things and have additional special methods (such as the Ehrhart polynomial). Or like the `CommutativeRing` subclass of `Ring`. Subclasses are for things that have additional assumptions, even if they avoid a measure 0 subset.


---

Comment by mkoeppe created at 2022-09-15 20:26:21

Replying to [comment:193 Travis Scrimshaw]:
> Subclasses are for things that have additional assumptions

Exactly, but I have already explained that "admitting >= 1 element class" is not such a situation that warrants a subclass (in particular not one that would add methods).

- comment:140 - Facade parents don't have an element class, but they do have an `_element_constructor_`.

- comment:142 - Whether something is (a) "empty as a set" or (b) "in principle doesn't have elements" is a distinction that is not important enough to model in our code. (This distinction has no standing as a mathematical concept - comment:191.) 

- comment:146, comment:147, comment:152 - Likewise, the distinction between (a) a parent that does not have element class / constructor and (b) a parent that has them but the element constructor always raises a `ValueError`, is not important enough to expose to the outside.

- To add to this, in many cases it is not statically known whether a parent needs an element class (or which element class it needs if it does); it may depend on the input data. We have many classes that make such a dynamic choice of element class. In the running example with (say, affine real) schemes, say you get as input `x^(2d) + 1` vs. `x^(2d) - 1`. For the first one because it is empty as a set, you don't need an element class. For the second one, you want to use a specialized element class for affine varieties over a real closed field.

I'll be happy to expand on all of this if necessary.


---

Comment by mkoeppe created at 2022-09-17 00:08:11

I have opened #34548 for further discussion of `Parent`s with 0, 1, 2, ... element classes


---

Comment by mkoeppe created at 2022-09-17 00:09:59

And I have opened #34540 to improve documentation of `CategoryObject`.


---

Comment by mkoeppe created at 2022-09-17 00:15:48

Replying to [comment:154 Xavier Caruso]:
> But if you say that it's already okay to have parents without elements, I just propose to get rid of this class `CategoryObject` (which is apparently almost not used).

Yes, I think this could make sense.


---

Comment by mkoeppe created at 2022-09-17 00:17:33

Replying to [comment:113 Matthias Köppe]:
> I've explained in comment:108 - `CategoryObject` is just a low-level implementation class, and despite its mathematical-sounding name, it does not model the notion of an "object in a category".
>  
> If you look for its uses in the Sage library, you'll see that there are exactly 2 direct uses of it (`IntegrableRepresentation`, `TopologicalVectorBundle`)... and both are mistakes.

For fixing `IntegrableRepresentation`, see #21387.


---

Comment by caruso created at 2022-09-17 08:13:15

I'm afraid that the discussion on `Parent`/`CategoryObject`/whatever will be still quite long and, actually, I do not want to hold this ticket too much.

Apart from Travis (who is clearly opposed), it seems to me that the current solution (Drinfeld modules are parents without elements) fits with the other participants (Antoine, David, Pierre-Jean, Matthias and myself); correct me if I'm wrong. So, for now, I would propose to accept this and continue the review. We will come back to this later on (in another ticket) once there will be a clear consensus on the structural design choices.

Do you agree?


---

Comment by tscrim created at 2022-09-17 09:43:02

Replying to [comment:199 Xavier Caruso]:
> I'm afraid that the discussion on `Parent`/`CategoryObject`/whatever will be still quite long and, actually, I do not want to hold this ticket too much.
> 
> Apart from Travis (who is clearly opposed), it seems to me that the current solution (Drinfeld modules are parents without elements) fits with the other participants (Antoine, David, Pierre-Jean, Matthias and myself); correct me if I'm wrong. So, for now, I would propose to accept this and continue the review. We will come back to this later on (in another ticket) once there will be a clear consensus on the structural design choices.
> 
> Do you agree?

No, you don’t just get to sideline me like that. That is not how we do things here. If there is an impasse, we go to a sage-devel vote. Because of your suggestion, I am very hesitant to offer a compromise that I think is way more than fair to you.

I am willing to accept this as-is with the current code structure (there are still other issues I mentioned in comment:124) as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`, and `DrinfeldModules` is assuming that its objects are the specific `DrinfeldModule` implementation. You should mention specifically that this was done as a special exception so that morphisms could work between your objects. Furthermore, you will have to open tickets stating that these things will be changed (`DrinfeldModules` becomes a `Parent` with  once the infrastructure is in place, with links in your documentation to these tickets.

Now again, another way out of this is we could also just simply inherit `DrinfeldModuleMorphism` from `Element` instead of `Morphism` (or `Map`) and duplicate the necessary structure. This is something I am more than willing to do myself.

I think there are some other issues with the morphisms that could bite you because you are not implementing a custom composition (since you say that the morphisms are very important). You get a generic composition morphism, which won’t carry the properties of a `DrinfeldModuleMorphism`. I don’t quite see what properties of inheriting from `Map`/`Morphism` that you will use beyond just having some of the fundamental methods we could easily ducktype.


---

Comment by tscrim created at 2022-09-17 09:43:02

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2022-09-17 09:57:53

I can also do a draft proposal if you are open to the idea of having a parallel map class as a bridge until we get the larger change sorted out. In particular, you don't even have to agree to it before I am willing to put in the effort to write the code.


---

Comment by mkoeppe created at 2022-09-17 11:52:52

Replying to [comment:200 Travis Scrimshaw]:
> Now again, another way out of this is we could also just simply inherit `DrinfeldModuleMorphism` from `Element` instead of `Morphism` (or `Map`) and duplicate the necessary structure.

Strong -1 on introducing direct uses of `CategoryObject` and workarounds like  morphisms that do not derive from `Morphism`.


---

Comment by mkoeppe created at 2022-09-17 12:07:31

Replying to [comment:200 Travis Scrimshaw]:
> as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`

The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.


---

Comment by @DavidAyotte created at 2022-09-17 14:26:58

I'd like to thank you three for this extensive discussion which resulted in what I think is a solution for our problem. In particular, I learned that the  `Parent`/`Element` implementation is much more than the didactical description explained in the Sage's manuals. 

As much that I'm **very** eager to see Drinfeld modules in Sage, I think it would be best to wait until the generalization of `Parent` is at least implemented and have it as a dependency for this ticket. I would be willing to help for this solution, however I'm afraid that I would not know what to do. Anyhow, If you have any task for me that could help speed up the process, don't hesitate! I will be following the discussion on the other tickets too.


---

Comment by mkoeppe created at 2022-09-17 15:50:49

Replying to [comment:204 David Ayotte]:
> I think it would be best to wait until the generalization of `Parent` is at least implemented and have it as a dependency for this ticket. I would be willing to help for this solution, however I'm afraid that I would not know what to do.

For `DrinfeldModule` to be a `Parent` without an element class, no work is needed; it already works.

For `DrinfeldModules` to (instead of a `Category`) become a `Parent` whose element class is both an `Element` and a `Parent`, we would need #34534. That ticket could use exploratory programming to see what the precise technical obstacles are.


---

Comment by mkoeppe created at 2022-09-17 17:11:44

Replying to [comment:46 Xavier Caruso]:
> In [SageMath](SageMath), elliptic curves are parents:
> 
> {{{
> sage: E = EllipticCurve(u'389a')
> sage: E
> Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
> sage: isinstance(E, Parent)
> True
> }}}
> 
> However, `E` does not have elements:

I've opened #34550 for this


---

Comment by tscrim created at 2022-09-17 23:53:31

Replying to [comment:203 Matthias Köppe]:
> Replying to [comment:200 Travis Scrimshaw]:
> > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`
> 
> The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.

So are you saying “just ignore the methods in that class that we don’t intend to use because they are broken?” So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its ``@`abstract_method`s? (Actually, I would even have some mathematical justification for this because it is a single integral point in an even bigger polytope.)

While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I’ve made on #34534.

Actually, does pickling work with your implementation? Does `TestSuite` pass? From looking closely at the `Parent` code, I expect this to run into problems.

Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)

Some additional technical review things: This does not have 100% coverage. This includes all (double) underscore methods.


---

Comment by mkoeppe created at 2022-09-18 00:46:55

Replying to [comment:207 Travis Scrimshaw]:
> Replying to [comment:203 Matthias Köppe]:
> > Replying to [comment:200 Travis Scrimshaw]:
> > > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`
> > 
> > The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.
> 
> So are you saying “just ignore the methods in that class that we don’t intend to use because they are broken?” 

No, I'm not saying that. Read it again. You claimed that `Element` and `_element_constructor_` are required. They are not, and I've explained it in detail.

> So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its ``@`abstract_method`s?

No, Travis, I'm not saying that. Invalid argumentative tactics "akin" to those you used earlier. Please use more restraint.

> While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I’ve made on #34534.

I'm quite intrigued with the phrasing "quite implicit". But setting this aside: It's definitely not clear that `Element` is a required. And just in the message that you replied to I explained that `Parent` implements both codepaths. So no, it's just your personal interpretation, and you already know that I disagree.

> Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)

To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.

> Some additional technical review things: This does not have 100% coverage. This includes all (double) underscore methods.

Yes, clearly a lot of documentation/tests are missing.


---

Comment by tscrim created at 2022-09-18 01:35:39

Replying to [comment:208 Matthias Köppe]:
> Replying to [comment:207 Travis Scrimshaw]:
> > Replying to [comment:203 Matthias Köppe]:
> > > Replying to [comment:200 Travis Scrimshaw]:
> > > > as long as you put clear warnings that the user should not expect many things to work because `DrinfeldModule` does not implement many of the requirements of `Parent`, such as `Element` and `_element_constructor_`
> > > 
> > > The class `Parent` does not have such requirements. It has hooks that make parent in the category `Sets()` support such methods. `Parent.element_class` is a lazy attribute that handles both the case that `Element` is defined and `Element` is not defined. `Sets.ParentMethods` defines `_element_constructor_`.
> > 
> > So are you saying “just ignore the methods in that class that we don’t intend to use because they are broken?” 
> 
> No, I'm not saying that. Read it again. You claimed that `Element` and `_element_constructor_` are required. They are not, and I've explained it in detail.

Then what makes them required? Does it need to fail upon instance creation? I do not see where you have made clear what makes something required. All I recall and can quickly see is that you have said in detail is what it should be used for (which I think we agree that we should refactor out parts dealing with `Element`). I am sorry if it has gotten lost in our discussion.

> > So can I use, say, `Polyhedron` to be a base class of `AlternatingSignMatrix` without implementing its ``@`abstract_method`s?
> 
> No, Travis, I'm not saying that. Invalid argumentative tactics "akin" to those you used earlier. Please use more restraint.

This is a legitimate question: Can we subclass something and have some of its methods fail (including with `NotImplementedError`s) because something in the implementation (not the input of the instance) is not provided? That is what happens here with `an_element()` (and possibly pickling, which I haven't checked).

Not for nothing, I expect `_test_category` to fail because the category is not a subcategory of `Sets`.

> > While it is not explicitly documented that `Element` is a required attribute on any subclass, it is quite implicit by the points I’ve made on #34534.
> 
> I'm quite intrigued with the phrasing "quite implicit". But setting this aside: It's definitely not clear that `Element` is a required. And just in the message that you replied to I explained that `Parent` implements both codepaths. So no, it's just your personal interpretation, and you already know that I disagree.

I don't see any code path that explicitly deals with `Element`. Actually, I think you're right about `Element` not being required, thinking about façade parents. However, it does explicitly use `_element_constructor_` and the error types clearly indicate that it is expected to be provided (they just do not appear an instance creation). Note that when it is not an empty set, then IIRC there is a test saying that for Python classes, the elements must be a subclass of the `Parent.category().ElementMethods` (which is created dynamically from the `Parent.Element` attribute and making it required). Coupled with the `_test_category`, which has no indication that it should be moved up to the category, `_element_constructor_` needs to be provided. (Frankly, I don't see it as too much of a difference.)

> > Furthermore, because Drinfeld modules are morphisms, there is further tension with the `Parent.__call__`, where they cannot behave like morphisms because that directly contradicts its documentation and implementation. (This is something we need to figure out with morphisms (which are an `Element` subclass) that are also a proper `Parent` with its own `Element` class.)
> 
> To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.

This is the problem: These are not in `Sets()` but `Parent` requires an `_element_constructor_` and to be an object of `Sets()`. There might be a way to hack around this, but they are still hacks.


---

Comment by mkoeppe created at 2022-09-18 02:52:32

Replying to [comment:209 Travis Scrimshaw]:
> > To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.
> 
> This is the problem: These are not in `Sets()` but `Parent` requires an `_element_constructor_`

No it doesn't.

> and to be an object of `Sets()`. 

No it doesn't.

(Is this the argument clinic or just contradiction?)


---

Comment by mkoeppe created at 2022-09-18 03:00:12

Replying to [comment:209 Travis Scrimshaw]:
> I expect `_test_category` to fail because the category is not a subcategory of `Sets`.

Nice find. I'd propose to modify this one.


---

Comment by mkoeppe created at 2022-09-18 03:04:32

Replying to [comment:209 Travis Scrimshaw]:
> I don't see any code path that explicitly deals with `Element`.

It's here:

```
    # This probably should go into Sets().Parent
    @lazy_attribute
    def element_class(self):
        try:  # if hasattr(self, 'Element'):
            return self.__make_element_class__(self.Element,
                                               name="%s.element_class" % self.__class__.__name__,
                                               module=self.__class__.__module__)
        except AttributeError:  # else:
            return NotImplemented
```


So this implements one of these hooks that I mentioned. `element_class` only shows up as an attribute when `Element` is provided by the subclass or category.


---

Comment by mkoeppe created at 2022-09-18 03:13:08

Replying to [comment:209 Travis Scrimshaw]:
> it does explicitly use `_element_constructor_` and the error types clearly indicate that it is expected to be provided

No, it doesn't. It uses `_element_constructor` (no trailing underscore), which is a cdef and can be `None` (it's set to a callable in `_set_element_constructor`).


---

Comment by tscrim created at 2022-09-18 03:16:36

For pickling

```
sage: Fq.<z2> = GF(3^2)
....: FqX.<X> = Fq[]
....: K.<z> = Fq.extension(6)
....: phi = DrinfeldModule(FqX, [z, 1, 1])
....: phi
Drinfeld module defined by X |--> t^2 + t + z over base Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 3^2
  To:   Finite Field in z of size 3^12
  Defn: X |--> z
sage: loads(dumps(phi)) is phi  # this is not really testing pickling because of UniqueRepresentation
True
```

Now when I explicitly try to load the pickle

```
sage: dumps(phi)
b'x\x9c\x85\x96\x87\x7f\x14E\x14\xc7C(!\x0b\x02\x8a\x15\x1b\xf6\xc3\x12)\x8ab\x8f$\x11\x8c\x1c\xf8\x10=K\\7{s7\x93l\xb9\xdf\x96@\xd0S,\x9bM\xec\x15\xc1\x82\x15{\xef\xbd\xf7\x8a\xbd\xf7\xfe_8\xdb\xcc%!\x1f?\xf9|.3\xdf\xf7\xe6\xcd\xcc\x9bWvM\xbd\xeeje\xd6\xe4z\x8e\xaf{\xbe\xc3\x9a|K\xc0g\xaa\xc3*\x0es\x99\xe5i\x9e\xb0-\xc5\xb7\x1cV\xf4u\xa6\xa0.Y\xe0\x08\xab\xec6\x95|K\x8f\xe4jI0\xa3\xd8T\x94\xb4$\x07\xaai\x17}\x83I\xb9\xb0\x84\xc7\xd4a\\i\x8bqKJ\x97$\x10cj-Wl\xa3\xd7\xb2M\xa1\x19M\xb6\xc3\xd4\xc1\xa9\x1a\xc9\x95\xa5\x0e[\xf6\x1f\xa2\x88\xa0>7\xfc*%M\xf7l\xa7W)3\x8b9BW\xd3\xb9\xea[\x15\xa1wG[\x8e\x1du\x8da\xdb\xdd~E-\x1bv\xa7f(\x18W\x98TWW\x97\x9c\xbb-\xba+\xc6\x07\x98@hholo(\x8c\x952G\x9f\x83\x89!\x1as\xb5\xb7\x10\x96\xc7\xca\xccQL\xad\x9b\xa9\xd9\x04Ja\x9c\\P\x9e\xdf\xc31)\xc0d\xc2\x16\x851\x12\xac\xc6\x94\x00SGqB\x8d\x03VK/\xaa%C\x9aK\xec2\x83\x99\xf2\xa1\x14L\xfb\xff\xb5\x91L\xd5m+\xb9\xb0\xed(\x99/\xd4\xe1\xee\xdc2\xc7\xc7\xe6x\x03o\xccq%>\xde<l\x15`:a\xebx\xb6\n\xdb\x04\xd86\x1f\xdfD\x9e\xc7\xc2v\\\xe1Ra{\xc2\x0e\xe9\x829\x98\x11`G\xc2N\xfd\xf9|\xbe\x7f\xc0\xc3\xceU\xec\xe2aW\xc2L.\x17\xef\x96\x97hw\xc2\x1e\x1d\xd8s\x88\xd3\xd2\xa0\x19\xe2\xc1(r\x14\x19(\n\xf6J\xad\xcf\xc5\xde\x01\xf6!\xe4\x92}g\x11\xf6\xe53C\xecG\xd8\x9fg:\xb3q@\x80&\xc2\x81<\x96\xcd&\xcc\x89d\\\x9ek.a^B\x0f"\x1c\x1cS\xa9;\x9fpHB\x0f%,\xc8t\x0f#\x1c\x9e\xd0#\x08Gf\xf4(\xc2\xd1\t=\x86\xd0\x9c\xd1c\t\x0b\x13\xdaBh\xcd\xec\xb6\x11\x8eK\xe8"\xc2\xe2\x8c\x1eOhO\xe8\t\x84%\x19\xcd\x13\x96&t\x19\xe1\xc4\x8c\x12ayBO"\xac\xc8\xe8\xc9\x84S\x12Z \x9c\x9a\x9d\xe14\xc2\xe9\t=\x83\xd0\xc1\x06\x06B\x9c\xd9\x07\x95pVA\x91^\xa9h\x8ePK2\xf3<h\x89\xf3:\tz\xea2\x1d\xc5\x00\x8cP\x8a\x1f\xad\xdfC\xb9\n\xeeA\x10\xba\x927\xd25\xf9 \xb6#dv\x9bZe0~\xa2\t\xbaG\x7fHn\x9bj\n\xe2b\xa1\xb49v\'\xb3\x84\xef\xb6ZE\xdb\xb4\x9d\n\x17\xee0\x15\x18#\xf6\x94f\\\xe6)\x8blS\x81\x99\xe3]<=\x96)\\]\xea\x19\x86\x12\xfd\xa8&\xf3x\x14-\x16\x1f\xf9W\xb7\x99\x8b\x94M\xcdU5\xab\xa8j\xc5\xa2\xf0DOt\x9f\x88)K\xe2\x7f\xcdV\xb19\x15$@\x81=\xab\x8aJ\x08\x10\x9c\xb86\xa8+\x85\xc7Um\x95\xb0M\xb8\x85\xc9\x92\xb4\x08\x99e\xa2\xd3\x8fV\xc1\x0b\xe1\x13z\xb8[\x98.E\x99\xb1f\xd7\xb5u\xa1\xc5\x1a+C\xac"\xf4\x0e\xd3Xh\x9b\xa6\xef%\x1a\xabC\x9cM8GjL\xa9\xd1X!\x1d\xa6\x19\xa8\x868\x97p\x9e\x14F\xa7\xa95\xbc&\xc4\xf9\x84\x0b\xa4dj\xcd\xb2\xc5V\x0fs\\\x86\x0bC\\D\x08\xa4t\x82\x94\xa6\xc6\xfaB\x84\x84~\t\'\xc6\x17\xe9\x11\xae\xac\xf2\x90\x81t1\xe1\x92t\x8f\xda\xa3]\x1a\xe22\xc2\xe5\xa9\x95\xa4N\xe2\x8a\x10W\x12\xae\x92i~5\xe1\x9a*\xae\xad\xe2\xba\\\xa1!r\x96|qMXX\xcb\xbb\n\x8d\xd1\\\xb7Sr\xbd$\x91\xf3T\xe1J\xc8\x1c=\xdaw\xdd@|\xe3\xb8)\xa9^o\x85\xa9\xd2\xb3X\x9f/\x8c\x8f\xa8!J\x1en\xc8\xc7;\xcbF\xb1\x929\xb8\xb1\xbd\xde\xf7p\x13\xe1\xe68\xa8=l\x08p\x8b<\xc7\xad\x84\xdb:p\xfb\xe8Q\x9a\xd6Ru0G\x06#\xbc\xa6\xfa\xb7\x8eT\xc3\x1d2\x18\xa7\xf4\xe1N\xc2F\x1e\x8dg\xf4\xe1.\xc2\xdd\xd9\xf8\x1e\xc2\xbd,\xc0}\x84\xfb7\x13\x81\xc3;\xa72\xb49\xcax{\x80\x0fM\xae,c\x94\xa8\\\xcbt\x18L!a\xaa\xb2\xe3\xc9%\x0fr\x99!#\xea\xf8\x02<\x14\xe0a\xc2#\x85\xfa\xa8\xe9\xcc\xc5\xa3\x01\x1e\xe3\xd3\xb8\xac\xc3\x8f\xe7\xe2\x12"\x0b\xeb\x13\x84\'\x93\x12\xf2\x14\xe1\xe9\x8c>Cx6\xa1\xcf\x11\x9e\xcf\xca\xcd\x0b\x84\x17\x13\xfa\x12\xe1\xe5\xb8\xdc\xbc\xd2\x87W\t\xaf\xc5OR\x16=\x9ac\xe3\xf5\xa4\xd4\xbcAx31\xf6\x16\xe1\xed\xfe\xa4\x81D\r\n\xef\xf4G\xe5\xe6\xdd*\xde\xf3\xf0>\xe1\x83\xf8\xb0\x05|\x18\xe0\xa3\xa8S|L\xd8$=9\xd2u\xcc\xd7\rQd\x9a\x95\x06\x95\xab\xb4f\xa4%\x05\xf8D&\xeb\xa7!>#|.M}A\xf8\xb2\x8a\xaf\xaa\xf8:\xc7\xd7\xf2M\\\xc6\x1c_7\xc0\xd7\xe7\xb9\x8c\xa28\x1c3\x1f\xe2\x9b\xe1\xdf\x072c|f\xc9\x0f\xa1\xe5\xe9@M\xbf.\x14|\x9b\xeb\xc0w|\xa3\xc6\xbb\x06\xa2n\xf7=\xe1\x87\xc4Z\xa7\xe6\xc6\xf5\x11?\xe6eT\xfeD\xf89\xc0/U\xfc\x1a\xdf\xdd\xd2L\x86\xdf\xf8\x067\xc4\xef\x84?\xfa\xf0g\x15\x7f\x85\xf8\x9b\xf0O\xd3\xbf\xc6\x7f\x89\xd8'
```

in a new Sage session:

```
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File ~/sage-build/src/sage/misc/cachefunc.pyx:985, in sage.misc.cachefunc.CachedFunction.__call__()
    984 try:
--> 985     return self.cache[k]
    986 except TypeError:  # k is not hashable

File ~/sage-build/src/sage/misc/weak_dict.pyx:704, in sage.misc.weak_dict.WeakValueDictionary.__getitem__()
    703 if wr == NULL:
--> 704     raise KeyError(k)
    705 out = PyWeakref_GetObject(wr)

KeyError: ((<class 'sage.categories.drinfeld_modules.DrinfeldModules'>, Ring morphism:
  From: Univariate Polynomial Ring in X over Finite Field in z2 of size 3^2
  To:   Finite Field in z of size 3^12
  Defn: X |--> z), (('name', 't'),))

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
Input In [2], in <cell line: 1>()
----> 1 loads(b'x\x9c\x85\x96\x87\x7f\x14E\x14\xc7C(!\x0b\x02\x8a\x15\x1b\xf6\xc3\x12)\x8ab\x8f$\x11\x8c\x1c\xf8\x10=K\\7{s7\x93l\xb9\xdf\x96@\xd0S,\x9bM\xec\x15\xc1\x82\x15{\xef\xbd\xf7\x8a\xbd\xf7\xfe_8\xdb\xcc%!\x1f?\xf9|.3\xdf\xf7\xe6\xcd\xcc\x9bWvM\xbd\xeeje\xd6\xe4z\x8e\xaf{\xbe\xc3\x9a|K\xc0g\xaa\xc3*\x0es\x99\xe5i\x9e\xb0-\xc5\xb7\x1cV\xf4u\xa6\xa0.Y\xe0\x08\xab\xec6\x95|K\x8f\xe4jI0\xa3\xd8T\x94\xb4$\x07\xaai\x17}\x83I\xb9\xb0\x84\xc7\xd4a\\i\x8bqKJ\x97$\x10cj-Wl\xa3\xd7\xb2M\xa1\x19M\xb6\xc3\xd4\xc1\xa9\x1a\xc9\x95\xa5\x0e[\xf6\x1f\xa2\x88\xa0>7\xfc*%M\xf7l\xa7W)3\x8b9BW\xd3\xb9\xea[\x15\xa1wG[\x8e\x1du\x8da\xdb\xdd~E-\x1bv\xa7f(\x18W\x98TWW\x97\x9c\xbb-\xba+\xc6\x07\x98@hholo(\x8c\x952G\x9f\x83\x89!\x1as\xb5\xb7\x10\x96\xc7\xca\xccQL\xad\x9b\xa9\xd9\x04Ja\x9c\\P\x9e\xdf\xc31)\xc0d\xc2\x16\x851\x12\xac\xc6\x94\x00SGqB\x8d\x03VK/\xaa%C\x9aK\xec2\x83\x99\xf2\xa1\x14L\xfb\xff\xb5\x91L\xd5m+\xb9\xb0\xed(\x99/\xd4\xe1\xee\xdc2\xc7\xc7\xe6x\x03o\xccq%>\xde<l\x15`:a\xebx\xb6\n\xdb\x04\xd86\x1f\xdfD\x9e\xc7\xc2v\\\xe1Ra{\xc2\x0e\xe9\x829\x98\x11`G\xc2N\xfd\xf9|\xbe\x7f\xc0\xc3\xceU\xec\xe2aW\xc2L.\x17\xef\x96\x97hw\xc2\x1e\x1d\xd8s\x88\xd3\xd2\xa0\x19\xe2\xc1(r\x14\x19(\n\xf6J\xad\xcf\xc5\xde\x01\xf6!\xe4\x92}g\x11\xf6\xe53C\xecG\xd8\x9fg:\xb3q@\x80&\xc2\x81<\x96\xcd&\xcc\x89d\\\x9ek.a^B\x0f"\x1c\x1cS\xa9;\x9fpHB\x0f%,\xc8t\x0f#\x1c\x9e\xd0#\x08Gf\xf4(\xc2\xd1\t=\x86\xd0\x9c\xd1c\t\x0b\x13\xdaBh\xcd\xec\xb6\x11\x8eK\xe8"\xc2\xe2\x8c\x1eOhO\xe8\t\x84%\x19\xcd\x13\x96&t\x19\xe1\xc4\x8c\x12ayBO"\xac\xc8\xe8\xc9\x84S\x12Z \x9c\x9a\x9d\xe14\xc2\xe9\t=\x83\xd0\xc1\x06\x06B\x9c\xd9\x07\x95pVA\x91^\xa9h\x8ePK2\xf3<h\x89\xf3:\tz\xea2\x1d\xc5\x00\x8cP\x8a\x1f\xad\xdfC\xb9\n\xeeA\x10\xba\x927\xd25\xf9 \xb6#dv\x9bZe0~\xa2\t\xbaG\x7fHn\x9bj\n\xe2b\xa1\xb49v\'\xb3\x84\xef\xb6ZE\xdb\xb4\x9d\n\x17\xee0\x15\x18#\xf6\x94f\\\xe6)\x8blS\x81\x99\xe3]<=\x96)\\]\xea\x19\x86\x12\xfd\xa8&\xf3x\x14-\x16\x1f\xf9W\xb7\x99\x8b\x94M\xcdU5\xab\xa8j\xc5\xa2\xf0DOt\x9f\x88)K\xe2\x7f\xcdV\xb19\x15$@\x81=\xab\x8aJ\x08\x10\x9c\xb86\xa8+\x85\xc7Um\x95\xb0M\xb8\x85\xc9\x92\xb4\x08\x99e\xa2\xd3\x8fV\xc1\x0b\xe1\x13z\xb8[\x98.E\x99\xb1f\xd7\xb5u\xa1\xc5\x1a+C\xac"\xf4\x0e\xd3Xh\x9b\xa6\xef%\x1a\xabC\x9cM8GjL\xa9\xd1X!\x1d\xa6\x19\xa8\x868\x97p\x9e\x14F\xa7\xa95\xbc&\xc4\xf9\x84\x0b\xa4dj\xcd\xb2\xc5V\x0fs\\\x86\x0bC\\D\x08\xa4t\x82\x94\xa6\xc6\xfaB\x84\x84~\t\'\xc6\x17\xe9\x11\xae\xac\xf2\x90\x81t1\xe1\x92t\x8f\xda\xa3]\x1a\xe22\xc2\xe5\xa9\x95\xa4N\xe2\x8a\x10W\x12\xae\x92i~5\xe1\x9a*\xae\xad\xe2\xba\\\xa1!r\x96|qMXX\xcb\xbb\n\x8d\xd1\\\xb7Sr\xbd$\x91\xf3T\xe1J\xc8\x1c=\xdaw\xdd@|\xe3\xb8)\xa9^o\x85\xa9\xd2\xb3X\x9f/\x8c\x8f\xa8!J\x1en\xc8\xc7;\xcbF\xb1\x929\xb8\xb1\xbd\xde\xf7p\x13\xe1\xe68\xa8=l\x08p\x8b<\xc7\xad\x84\xdb:p\xfb\xe8Q\x9a\xd6Ru0G\x06#\xbc\xa6\xfa\xb7\x8eT\xc3\x1d2\x18\xa7\xf4\xe1N\xc2F\x1e\x8dg\xf4\xe1.\xc2\xdd\xd9\xf8\x1e\xc2\xbd,\xc0}\x84\xfb7\x13\x81\xc3;\xa72\xb49\xcax{\x80\x0fM\xae,c\x94\xa8\\\xcbt\x18L!a\xaa\xb2\xe3\xc9%\x0fr\x99!#\xea\xf8\x02<\x14\xe0a\xc2#\x85\xfa\xa8\xe9\xcc\xc5\xa3\x01\x1e\xe3\xd3\xb8\xac\xc3\x8f\xe7\xe2\x12"\x0b\xeb\x13\x84\'\x93\x12\xf2\x14\xe1\xe9\x8c>Cx6\xa1\xcf\x11\x9e\xcf\xca\xcd\x0b\x84\x17\x13\xfa\x12\xe1\xe5\xb8\xdc\xbc\xd2\x87W\t\xaf\xc5OR\x16=\x9ac\xe3\xf5\xa4\xd4\xbcAx31\xf6\x16\xe1\xed\xfe\xa4\x81D\r\n\xef\xf4G\xe5\xe6\xdd*\xde\xf3\xf0>\xe1\x83\xf8\xb0\x05|\x18\xe0\xa3\xa8S|L\xd8$=9\xd2u\xcc\xd7\rQd\x9a\x95\x06\x95\xab\xb4f\xa4%\x05\xf8D&\xeb\xa7!>#|.M}A\xf8\xb2\x8a\xaf\xaa\xf8:\xc7\xd7\xf2M\\\xc6\x1c_7\xc0\xd7\xe7\xb9\x8c\xa28\x1c3\x1f\xe2\x9b\xe1\xdf\x072c|f\xc9\x0f\xa1\xe5\xe9@M\xbf.\x14|\x9b\xeb\xc0w|\xa3\xc6\xbb\x06\xa2n\xf7=\xe1\x87\xc4Z\xa7\xe6\xc6\xf5\x11?\xe6eT\xfeD\xf89\xc0/U\xfc\x1a\xdf\xdd\xd2L\x86\xdf\xf8\x067\xc4\xef\x84?\xfa\xf0g\x15\x7f\x85\xf8\x9b\xf0O\xd3\xbf\xc6\x7f\x89\xd8')

File ~/sage-build/src/sage/misc/persist.pyx:991, in sage.misc.persist.loads()
    989 unpickler = SageUnpickler(io.BytesIO(s), **kwargs)
    990 global already_unpickled
--> 991 ans = unpickler.load()
    992 already_unpickled = { }
    993 return ans

File ~/sage-build/src/sage/structure/unique_representation.py:1161, in unreduce(cls, args, keywords)
   1149 def unreduce(cls, args, keywords):
   1150     """
   1151     Calls a class on the given arguments::
   1152 
   (...)
   1159 
   1160     """
-> 1161     return cls(*args, **keywords)

File ~/sage-build/src/sage/misc/classcall_metaclass.pyx:320, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__()
    318 """
    319 if cls.classcall is not None:
--> 320     return cls.classcall(cls, *args, **kwds)
    321 else:
    322     # Fast version of type.__call__(cls, *args, **kwds)

File ~/sage-build/src/sage/categories/category.py:447, in Category.__classcall__(cls, *args, **options)
    445 if isinstance(cls, DynamicMetaclass):
    446     cls = cls.__base__
--> 447 return super().__classcall__(cls, *args, **options)

File ~/sage-build/src/sage/misc/cachefunc.pyx:990, in sage.misc.cachefunc.CachedFunction.__call__()
    988         return self.cache[k]
    989 except KeyError:
--> 990     w = self.f(*args, **kwds)
    991     self.cache[k] = w
    992     return w

File ~/sage-build/src/sage/structure/unique_representation.py:1007, in CachedRepresentation.__classcall__(cls, *args, **options)
    992 @weak_cached_function(cache=128)  # automatically a staticmethod
    993 def __classcall__(cls, *args, **options):
    994     """
    995     Construct a new object of this class or reuse an existing one.
    996 
   (...)
   1005         True
   1006     """
-> 1007     instance = typecall(cls, *args, **options)
   1008     assert isinstance( instance, cls )
   1009     if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:

File ~/sage-build/src/sage/misc/classcall_metaclass.pyx:471, in sage.misc.classcall_metaclass.typecall()
    469     2
    470 """
--> 471 return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    472 
    473 

File ~/sage-build/src/sage/categories/drinfeld_modules.py:220, in DrinfeldModules.__init__(self, base, name)
    218     raise TypeError('base codomain must be a field')
    219 # Check base is a non zero morphism
--> 220 if base(X).is_zero():
    221     raise ValueError('base must be a non zero morphism')
    222 # Build K{t}

File ~/sage-build/src/sage/categories/map.pyx:769, in sage.categories.map.Map.__call__()
    767 if P is D: # we certainly want to call _call_/with_args
    768     if not args and not kwds:
--> 769         return self._call_(x)
    770     return self._call_with_args(x, args, kwds)
    771 # Is there coercion?

File ~/sage-build/src/sage/rings/morphism.pyx:2054, in sage.rings.morphism.RingHomomorphism_im_gens._call_()
   2052     2*x + 3*y + 2*z
   2053 """
-> 2054 return x._im_gens_(self.codomain(), self.im_gens(), base_map=self.base_map())
   2055 
   2056 

File ~/sage-build/src/sage/rings/polynomial/polynomial_element.pyx:1305, in sage.rings.polynomial.polynomial_element.Polynomial._im_gens_()
   1303 if base_map is None:
   1304     base_map = codomain.coerce_map_from(self.base_ring())
-> 1305 result = base_map(self.get_unsafe(d))
   1306 i = d - 1
   1307 while i >= 0:

TypeError: 'NoneType' object is not callable
```

I am not even sure what is failing here actually.


---

Comment by mkoeppe created at 2022-09-18 03:19:25

Sage polynomials are involved, won't touch ;)


---

Comment by tscrim created at 2022-09-18 04:05:40

comment:213:

There really isn't much difference between `self._element_constructor_` and `self._element_constructor`. There might be some technical reason for having two, but the use is basically the same.

Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`. Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it. The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.

comment:210, comment:211:

Another point about a `Parent` being a `Sets()` object is in `_init_category_`:

```python
        if can_assign_class(self) and not isinstance(self, Sets_parent_class):
```

This isn't as strong as the `_test_category`, but it is special treatment for `Sets()`.

Yes we can change these things (in addition to the documentation), but we could change anything in these classes to be whatever we want.

----

Here is a proposal that will have a very limited impact on Sage at-large but solve the issues here:

We separate the stuff within `Parent` that deals with all of the set-like stuff (e.g., `_element_constructor`, `Element`, `_element_constructor_` `__contains__`, `__call__`) into a subclass `Bar` that inherits from `Foo` (names to be decided) and change the `Map._codomain` from `Parent` to `Foo`. This will have no impact on downstream classes that continue to inherit from `Bar`.

I would propose `Foo` be `CategoryObject` and `Bar` be `Parent` to make the transition essentially seamless. (For this ticket even, we could just change `Map._codomain` to a `CategoryObject` and then have `DrinfeldModule` inherit from that as I am still willing to accept that.)

That way we make `Parent` something that really should be an object of `Sets()` and `CategoryObject()` work more generally, giving the clarification you want as well.


---

Comment by mkoeppe created at 2022-09-18 04:11:47

You proposed exactly that before, and I have already explained in detail why it's a bad idea. comment:194


---

Comment by mkoeppe created at 2022-09-18 04:33:29

Replying to [comment:216 Travis Scrimshaw]:
> Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.

You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?

> Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it.

No it doesn't. The compile-time warnings are for locals, not for cdef class slots.

> The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.

Nope.


---

Comment by tscrim created at 2022-09-18 04:44:51

Replying to [comment:218 Matthias Köppe]:
> Replying to [comment:216 Travis Scrimshaw]:
> > Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.
> 
> You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?

I said initialization, which includes `__init__`.

> > Which while this has [some documentation](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions) to say it will be `None`, it also says this is a compile-time warning; basically, don't rely on it.
> 
> No it doesn't. The compile-time warnings are for locals, not for cdef class slots.

Then where it is documented that this is something you can rely on and is acceptable? I was taught very early on never to rely on this in C++. I don't see slots as that different than local variables.

> > The fact that it works without an `Element` or `_element_constructor_` looks a lot more like luck; it is definitely very brittle.
> 
> Nope.

Since `_element_constructor_` is not required, I should be free to use that variable as I want, right? I can't simply set it equal to `2`:

```
sage: class Foo(Parent):
....:     def __init__(self):
....:         self._element_constructor_ = 2
....:         super().__init__(category=Objects())
....:         
sage: F = Foo()
...
AssertionError: 
```

The fact that it is raising `NotImplementedError`s also says [this should be implemented](https://docs.python.org/3/library/exceptions.html#NotImplementedError).


---

Comment by mkoeppe created at 2022-09-18 04:50:34

In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.


---

Comment by tscrim created at 2022-09-18 04:50:54

Replying to [comment:217 Matthias Köppe]:
> You proposed exactly that before, and I have already explained in detail why it's a bad idea. comment:194

I think it is clear that there is a reason to model the distinction between an object in `Sets()`, which has a lot of extra infrastructure attached to it, and those that are not.  There is also a big difference between something that might not have elements (based on input) and something that will never have any by design. You also get rid of those pesky methods related to elements from the module that serve as a point of confusion to the user.


---

Comment by tscrim created at 2022-09-18 04:52:14

Replying to [comment:220 Matthias Köppe]:
> In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.

I basically agree, but we do have weak refs. Also what is special about `None`? What if Cython decides to change it to `int(0)`?


---

Comment by mkoeppe created at 2022-09-18 04:53:36

Replying to [comment:219 Travis Scrimshaw]:
> Replying to [comment:218 Matthias Köppe]:
> > Replying to [comment:216 Travis Scrimshaw]:
> > > Note that `_element_constructor` is never set during the initialization of a `Parent` without an `_element_constructor_`.
> > 
> > You're really trying to tell me that `Parent.__cinit__` forgets to initialize all of the slots except for `_action_hash`?
> 
> I said initialization, which includes `__init__`.

Also `Parent.__init__` does not initialize all declared slots.

You're forgetting `__new__`, which does the initialization of all slots.
In the Cython-generated C code (parent.c), you can find it as `__pyx_tp_new_4sage_9structure_6parent_Parent`.


---

Comment by mkoeppe created at 2022-09-18 04:54:50

Replying to [comment:222 Travis Scrimshaw]:
> Replying to [comment:220 Matthias Köppe]:
> > In Python's data model it makes absolutely no sense to have a slot that is typed as a Python object to be uninitialized. Just think about what the garbage collector / refcounting could possibly do with that.
> 
> I basically agree, but we do have weak refs.

This is getting silly.


---

Comment by tscrim created at 2022-09-18 05:26:19

Well, we can continue that discussion on the subsequent tickets.

For here, can you live with this: Change `Map._codomain` to `CategoryObject` and we revert `DrinfeldMorphism` to inherit from `CategoryObject` as it doesn’t use anything else in `Parent` other than to make the morphism code work.

I know you won’t be perfectly happy with this, but it is a fair concession on my part as well and it allows the code to be included without having to settle any contentious issues.


---

Comment by mkoeppe created at 2022-09-18 05:37:25

Replying to [comment:225 Travis Scrimshaw]:
> Change `Map._codomain` to `CategoryObject` 

No, now *that* would be a radical change.

> and we revert `DrinfeldMorphism` to inherit from `CategoryObject`

I have already said in comment:202 that I oppose adding direct uses of `CategoryObject`, for which there's no precedence in the code (other than 2 bad examples - comment:113)


---

Comment by mkoeppe created at 2022-09-18 05:39:28

Replying to [comment:226 Matthias Köppe]:
> Replying to [comment:225 Travis Scrimshaw]:
> > Change `Map._codomain` to `CategoryObject` 
> 
> No, now *that* would be a radical change.

... specifically, it's API-breaking on the Cython level.


---

Comment by tscrim created at 2022-09-18 06:03:58

Replying to [comment:227 Matthias Köppe]:
> Replying to [comment:226 Matthias Köppe]:
> > Replying to [comment:225 Travis Scrimshaw]:
> > > Change `Map._codomain` to `CategoryObject` 
> > 
> > No, now *that* would be a radical change.
> 
> ... specifically, it's API-breaking on the Cython level.

How? It is broadening the definition; it still accepts any `Parent` subclass.

Speaking of #28485, what do we want to do with objects that want to be in `Sets()` but do not want to implement elements (say, because we don’t have a basis and any way to really represent them)? Do we want to have some kind of generic element object (similar to what the manifolds code does)?

There is also even less of a precedent for having a `Parent` without an `_element_constructor_`. You even opened a ticket for dealing with the only other case within Sage as far as I know.

If you’re going to be unwilling to make any compromise, then we need to ask sage-devel and settle this by a group vote.


---

Comment by @spaenlehauer created at 2022-09-18 09:26:05

A quick comment to mention a family of classes in Sage that are widely used, and which (I think) are parents without elements: projective spaces. These are objects which are central mathematical objects, they are parents but they do not support `element_class`, `_element_constructor_`, etc. and they don't have any element class. I believe that there is no problem with their implementation.

Please check this example:

```
sage: E = ProjectiveSpace(2, QQ)
sage: isinstance(E, Parent)
True
sage: E._element_constructor_
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7175)()
    838         try:
--> 839             return self.__cached_methods[name]
    840         except KeyError:

KeyError: '_element_constructor_'

During handling of the above exception, another exception occurred:

AttributeError                            Traceback (most recent call last)
<ipython-input-14-9183d16129b9> in <module>
----> 1 E._element_constructor_

/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.__getattr__ (build/cythonized/sage/structure/category_object.c:7094)()
    831             AttributeError: 'PrimeNumbers_with_category' object has no attribute 'sadfasdf'
    832         """
--> 833         return self.getattr_from_category(name)
    834 
    835     cdef getattr_from_category(self, name):

/usr/lib/python3/dist-packages/sage/structure/category_object.pyx in sage.structure.category_object.CategoryObject.getattr_from_category (build/cythonized/sage/structure/category_object.c:7260)()
    846                 cls = self._category.parent_class
    847 
--> 848             attr = getattr_from_other_class(self, cls, name)
    849             self.__cached_methods[name] = attr
    850             return attr

/usr/lib/python3/dist-packages/sage/cpython/getattr.pyx in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:2653)()
    354         dummy_error_message.cls = type(self)
    355         dummy_error_message.name = name
--> 356         raise AttributeError(dummy_error_message)
    357     cdef PyObject* attr = instance_getattr(cls, name)
    358     if attr is NULL:

AttributeError: 'ProjectiveSpace_rational_field_with_category' object has no attribute '_element_constructor_'
```



---

Comment by caruso created at 2022-09-18 10:09:04

Replying to [comment:208 Matthias Köppe]:
> To my understanding, the domain experts here want the Drinfeld module to be the domain/codomain of morphisms (morphisms *of* Drinfeld modules), and the interpretation that a Drinfeld module itself is a morphism is secondary.

Yes! Personally, it is my main concern: I'm fine with having parents without elements or using `CategoryObject` but I'm more and more convinced that Drinfeld modules should not be elements and inherit from `RingHomomorphism`. For example, many methods of the class `Morphism` (e.g. `is_injective`) are not really relevant for Drinfeld modules, similarly the composing a "Drinfeld module" `phi` with another ring homomorphism is usually not meaningful.

However, following basically David's suggestion (see comment:133), I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):
- we keep the current structure where a Drinfeld module is a parent `phi`,
- we define elements in Drinfeld modules; those will just be skew polynomials (i.e. elements of `L{tau}`) and we even do not need a new class for this (i.e. we simply set `phi.Element = sage.rings.polynomials.skew_polynomial_element.SkewPolynomial_generic_dense` - or possibly a subclass of it, if relevant),
- if `phi` is a Drinfeld module, we set up a **conversion** map `Fq[X] -> phi` and a **coercion** map `L{tau} -> phi`.

This solves the problem that a parent has no element.
This natively allows for the constructions `phi(a)` and `phi(a)*P` (for `a` in `Fq[X]` and `P` in `L{tau}`) without any acrobatics. 
This also makes sense with morphisms: a morphism between Drinfeld modules `f : phi -> psi` induces a mapping `L{tau} -> L{tau}` which is the right multiplication by `F` where `F` is the skew polynomial defining `f`. So we can then just implement morphisms as actual maps.

Moreover, as I realized recently, the set `L{tau}` equipped with the action of `Fq[X]` given by `phi` nicely reflects many properties of the Drinfeld module. Here are a few concrete facts illustrating this:
- `L{tau}`, considered as a module over `L[X]`, is free of finite rank and its rank is equal to the rank of the Drinfeld module (it might also be correct with `Fq[X]` replaced by `A` and `L[X]` replaced by `A (x) L` accordingly but I haven't checked it);
- as I said above, a morphism between Drinfeld modules induces a map on `L{tau}`; this map commutes with the action of the Drinfeld modules (i.e. it satisfies `f(phi(a)*P) = psi(a)*f(P)` for all `a` and `P`) and its determinant gives what is called the norm of `f`;
- for `m` in `Fq[X]`, coprime with the characteristic, the quotient of `L{tau}` by `phi(m)` is directly related to the (dual of the) `m`-torsion of `phi`.

If all of you agree with my proposal, I'll be happy to implement it!


---

Comment by @spaenlehauer created at 2022-09-18 12:30:18

Many thanks for this suggestion, Xavier. It makes complete sense to me and I also believe that this might be a good compromise for everyone.

In fact, to me, elements in `L{tau}` can play the role of functions on elliptic curves. A difficult thing with Drinfeld modules is that `L{tau}` represents at the same time "functions" and morphisms, which can lead to some confusion.

If we want to make a parallel with elliptic curves, I think that a way to look at this is to consider the `Z`-module structure (edit: this is incorrect, it is not a `Z`-module) on the function field of an elliptic curve obtained by composing functions with the endomorphisms of multiplication by integers (which we can see better by using the analytic lattice representation of a complex elliptic curve). This would somehow be the analog of the `L[X]`-module structure on `L{tau}` that you describe. Does this analogy make sense?

I am slightly uncomfortable because functions are not elements of an elliptic curve, and therefore it bothers me a little bit that `L{tau}` is an element class of a Drinfeld module. I would prefer that Drinfeld modules do not have elements at all, but we have to find some compromise and this solution would be fine with me.

Many thanks again!

P.S. 
Replying to [comment:230 Xavier Caruso]:
> (it might also be correct with `Fq[X]` replaced by `A` and `L[X]` replaced by `A (x) L` accordingly but I haven't checked it);

I am not sure, but perhaps the rank-1 Drinfeld modules in Lemma 2.5 in https://arxiv.org/pdf/2203.06970.pdf provide counterexamples (there `A` is the coordinate ring of an imaginary hyperelliptic curve).


---

Comment by @DavidAyotte created at 2022-09-18 14:39:05

Replying to [comment:230 Xavier Caruso]:
> I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):
> - we keep the current structure where a Drinfeld module is a parent `phi`,
> - we define elements in Drinfeld modules; those will just be skew polynomials (i.e. elements of `L{tau}`) and we even do not need a new class for this (i.e. we simply set `phi.Element = sage.rings.polynomials.skew_polynomial_element.SkewPolynomial_generic_dense` - or possibly a subclass of it, if relevant),
> - if `phi` is a Drinfeld module, we set up a **conversion** map `Fq[X] -> phi` and a **coercion** map `L{tau} -> phi`.

This sounds like a good alternative and it fixes what I didn't like from what I proposed: the elements are actual skew polynomial, not a new class.


---

Comment by @spaenlehauer created at 2022-09-18 15:38:13

Replying to [comment:231 gh-spaenlehauer]:
> I am slightly uncomfortable because functions are not elements of an elliptic curve, and therefore it bothers me a little bit that `L{tau}` is an element class of a Drinfeld module. I would prefer that Drinfeld modules do not have elements at all, but we have to find some compromise and this solution would be fine with me.

(P.S. I'd like to mention quickly that I believe that this analogy with functions on elliptic curves has a mathematical formalization via shtukas. In fact, the `L[X]`-module structure of `L{tau}` is described in Goss' book "Basic Structures of Function Field Arithmetic" before Definition 6.2.10. From this module structure, we can build a sheaf of `O_X`-modules (in our case, since `A = Fq[X]`, we have `X = P^1`) which mimics the twisted sheaves `O(n)` in projective geometry, see Definition 6.2.10. So you really have a notion of "functions" from this module structure, and in some sense this makes Drinfeld modules into projective objects.)


---

Comment by git created at 2022-09-20 16:48:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-09-20 16:48:41

In the last commits, I fixed the `height` method of `DrinfeldModule`, which was
completely wrong. My apologies for that.


---

Comment by antoine-leudiere created at 2022-09-20 16:51:49

Replying to [comment:230 Xavier Caruso]:

> Yes! Personally, it is my main concern: I'm fine with having parents without elements or using `CategoryObject` but I'm more and more convinced that Drinfeld modules should not be elements and inherit from `RingHomomorphism`. For example, many methods of the class `Morphism` (e.g. `is_injective`) are not really relevant for Drinfeld modules, similarly the composing a "Drinfeld module" `phi` with another ring homomorphism is usually not meaningful.

Strong agreement.

> However, following basically David's suggestion (see comment:133), I have a new proposal which, I think, could be a good compromise for everyone (including Travis `:-)`):

Thank you very much Xavier for your proposal. I hope that I understand it
correctly, please correct me if I am mistaken.

My understanding is that you propose to have Ore polynomials as elements
because the morphism that characterize the Drinfeld module has codomain
`\Ltau`. It seems to me however that this vision, which is not canonical,
firmly depends on the construction we choose for Drinfeld modules. I am also
afraid that this would convey the misconception that a Drinfeld module is a set
of Ore polynomials. Although this implementation constructs Drinfeld modules as
ring morphisms `\phi: \Fq[X] \to \Ltau` (_algebraic_ construction), let us
recall that Drinfeld modules can be constructed in an _analytic_ fashion, in
which Drinfeld modules and their isogenies, are respectively lattices and
elements in the algebraic closure of a completion of the base field with
respect to the place at infinity [Gos98, Section 4.6]. There is an equivalence
of categories between the _category_ of "algebraic" of Drinfeld modules and
that of "analytic" Drinfeld modules [Gos98, Theorem 4.6.9]. (Another reason why
`DrinfeldModules` should, in my opinion, stay as a `Category` and
`DrinfeldModule` as a `Parent`.)

Despite being vastly different in its very own nature, the analytic
construction proves the same theorems (e.g. the rank can be analytically
defined and it turns out to be the same integer in both cases). It is essential
to me that the implementation is as agnostic of the construction as it can be,
as can be that of elliptic curves.

Consequently, I would disagree with `DrinfeldModule` having those elements.
Even though I appreciate that your proposition aims at satisfying everybody, I
would like to argue once more that Drinfeld modules should not have elements,
and that until now, all propositions in that direction seemed, in my view,
detrimental to what the mathematical image that the implementation should
reflect.

> This also makes sense with morphisms: a morphism between Drinfeld modules `f : phi -> psi` induces a mapping `L{tau} -> L{tau}` which is the right multiplication by `F` where `F` is the skew polynomial defining `f`. So we can then just implement morphisms as actual maps.

I am not convinced however on implementing Drinfeld module morphisms as actual
maps. It is true that Drinfeld module morphisms induce an action from `\Fq[X]`
or `L[X]` on `\Ltau`,  but the _principle of least astonishment_ strongly
advocates for Drinfeld module morphisms to be defined with Ore polynomials,
like in the literature, and not maps. However, the action on `\Ltau` can be
computed and retrieved using new, different methods.


---

Comment by @DavidAyotte created at 2022-09-20 18:05:46

Hello Antoine, I think that my comment:125 got lost in the conversation, but you deleted a line by inadvertence:


```diff
diff --git a/src/sage/rings/function_field/all.py b/src/sage/rings/function_field/all.py
index b6bba33..6904f3e 100644
--- a/src/sage/rings/function_field/all.py
+++ b/src/sage/rings/function_field/all.py
@@ -1 +1 @@
-from .constructor import FunctionField
+from .drinfeld_modules.all import *
```


You should add back the line

```
from .constructor import FunctionField
```

otherwise you are removing `FunctionField` from the global namespace and that's why you have so many failed doctests (this has been bugging me for some times now! `:-)`). Also, you should not import directly from `.all`, but instead import the desired class directly from the right module.

Considering having Ore polynomials as an element class, I'm not sure I understand the link between your disagreement and the analytic uniformization of a Drinfeld module as a `A`-lattice in `\CC_{\infty}`. _If ever_ Drinfeld modules are implemented analytically as `A`-lattices, the new implementation will very likely be different from this one. From a programming point of view, I think that having a Ore polynomials as "elements" could be beneficial in the sense that you would not have to override the double underscore `__call__` method (which don't seems to be advised to do: [ref](https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#outline), is this outdated?) and this would allow the implementation of coercion and conversion as Xavier mentioned.

From a mathematical point of view, I agree with you, Drinfeld does not have elements, but I think that this is something that you could mention in the reference manual. In order words, mention to the user that even thought the class `DrinfeldModule` uses Ore polynomials as an element class, it was implemented purely for programming purposes and that it is important to know that, mathematically, Drinfeld modules **does not** have elements.


---

Comment by caruso created at 2022-09-20 19:57:24

Replying to [comment:237 Antoine Leudière]:
> My understanding is that you propose to have Ore polynomials as elements
> because the morphism that characterize the Drinfeld module has codomain
> `\Ltau`.

That's correct that I'm proposing to have Ore polynomials as elements but the reason is not only the the defining morphism has codomain `Ltau`.

This proposal is actually supported by the "T-motive viewpoint" on Drinfeld modules (which was already quickly mentioned in comment:59 by David). Recall that, in our setting, a T-motive is a module `M` over `L[X]{tau}` which is finitely generated over `L{tau}` and satisfies an extra condition (Definition 5.4.5 in Gos' book). It turns out that one can attach a T-motive to each Drinfeld module `phi : Fq[X] -> L{tau}`: it is actually just `M = L{tau}` on which `X` acts by multiplication by `phi(X)`.

Hence, my proposal roughly consists in deciding to adopt this point of view and use a bivalent representation of Drinfeld module: morphism on the one hand, T-motive on the other hand. In this perspective, having elements is not just a hack for pleasing Travis (`:-)`) but it also has a strong mathematical meaning.


---

Comment by @DavidAyotte created at 2022-09-20 20:46:27

Replying to [comment:239 Xavier Caruso]:
> This proposal is actually supported by the "T-motive viewpoint" on Drinfeld modules (which was already quickly mentioned in comment:59 by David). Recall that, in our setting, a T-motive is a module `M` over `L[X]{tau}` which is finitely generated over `L{tau}` and satisfies an extra condition (Definition 5.4.5 is Gos' book). It turns out that one can attach a T-motive to each Drinfeld module `phi : Fq[X] -> L{tau}`: it is actually just `M = L{tau}` on which `X` acts by multiplication by `phi(X)`.

That is a really nice point of view (that I hadn't thought) and it would fit well in a potential future implementation of t-motives.


---

Comment by @spaenlehauer created at 2022-09-20 21:41:42

It is a really nice viewpoint, but I am a bit confused because I thought that the category of T-motives is actually dual to that of T-modules (which generalize Drinfeld modules) by Thm. 5.4.11 in Goss.

By adopting this viewpoint and by saying that elements in `L{tau}` are elements of Drinfeld modules, aren't we creating confusion between geometric objects (T-modules, Drinfeld modules) and their duals (T-motives, which I think of as functions on T-modules)?

To me, this feels like saying that an elliptic curve and its coordinate ring are the same (a T-module would be the analog of an elliptic curve/abelian variety, and a T-motive would be the analog of its coordinate ring).
Or similarly, it would be like identifying linear forms with vector spaces, or affine schemes with commutative rings. To me, these are distinct categories (but dual/anti-equivalent to each other), so this is why I feel a bit uncomfortable.

Am I misunderstanding something?


---

Comment by caruso created at 2022-09-21 05:55:46

Replying to [comment:241 gh-spaenlehauer]:
> It is a really nice viewpoint, but I am a bit confused because I thought that the category of T-motives is actually dual to that of T-modules (which generalize Drinfeld modules) by Thm. 5.4.11 in Goss.

Oh god, you're right, that's annoying!

Very concretely, the issue is that a morphism of Drinfeld modules `f : phi -> psi` defines a map from the `L{tau}` associated to `psi` to the `L{tau}` associated to `phi` (and not in the other direction as I've been thinking).

An easy fix to this would be to let `a` in `Fq[X]` act on `L{tau}` by **left** multiplication by `phi(a)` (and not right multiplication as we do for T-motives). Doing this, we are moving a little bit from the standards but maybe it could be acceptable, I don't know.


---

Comment by @spaenlehauer created at 2022-09-21 07:56:30

My view on this is that I think that I would prefer to have distinct classes for Drinfeld modules and for T-motives, similarly to the fact that in Sage affine schemes and commutative rings are distinct classes that represent dual objects.

So an easy solution might be to leave the code for Drinfeld modules as it is currently. Actually, I believe that it captures well the mathematical properties that we want for Drinfeld modules, and I actually do not understand what is the problem with its current structure. Then, following Xavier's suggestion, we could create another class for T-motives (whose elements are Ore polynomials (edit: more precisely, elements in a finitely-generated free module over a ring of Ore polynomials)), which could interact with the class of Drinfeld modules in the following way: once this class for T-motives is implemented, we could add a method to the Drinfeld module class which constructs the associated T-motive.

A long term objective might be to implement also the category of T-modules, and why not, a (sub)-category of shtukas (as I understand it, it adds a "sheaf of functions" layer to T-modules and this sheaf is constructed from the dual T-motive, in the same way that affine/projective schemes construct sheaves from a (graded) ring). However, this would probably require a large amount of work, which is probably out of the scope of this trac ticket.

The first step of this would be to integrate Antoine's code for Drinfeld modules in Sage; honestly, at this point I still cannot see the reason why the current code cannot be integrated (of course modulo correcting some small bugs that may be found during the review).


---

Comment by git created at 2022-09-21 17:40:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-09-21 17:41:40

Replying to [comment:238 David Ayotte]:

Many thanks for the reminder.

> You should add back the line
> {{{
> from .constructor import FunctionField
> }}}

Done.

> Also, you should not import directly from `.all`, but instead import the
> desired class directly from the right module.

Why is that? This looks like a standard practice. See `src/sage/all.py` and
`src/sage/rings/all.py`.


---

Comment by antoine-leudiere created at 2022-09-21 17:44:47

Thank you all for the explanations. As a matter of fact I had began looking
into the T-motive viewpoint by reading
[van der Heiden, Weil Pairing for Drinfeld Modules](https://link.springer.com/article/10.1007/s00605-004-0261-4), and it is true that the categories of
T-motives and T-modules are anti-equivalent to one another [Theorem 2.9] (see
also [Proposition 2.11]). I am slightly uncomfortable with mixing the two
representations in this implementation

Replying to [comment:238 David Ayotte]:
> From a programming point of view, I think that having a Ore polynomials as
> "elements" could be beneficial in the sense that you would not have to
> override the double underscore __call__ method (which don't seems to be
> advised to do: ​ref, is this outdated?) and this would allow the
> implementation of coercion and conversion as Xavier mentioned. 

Overriding the `__call__` method seems fine to me. There are multiple instances
of this, and the code is quite lightweight:


```python
    def __call__(self, a):
        return self._morphism(a)
```


Further, could you please ellaborate on the benefits of
having those conversion and coercion maps? I do not recall ever needing them.

Replying to [comment:238 David Ayotte]:
> In order words, mention to the user that even thought the class
> `DrinfeldModule` uses Ore polynomials as an element class, it was implemented
> purely for programming purposes and that it is important to know that,
> mathematically, Drinfeld modules **does not** have elements.

I believe the implementation and the documentation would step out their
prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working
mathematician. Design and documentation should reflect the common mathematical
modeling of Drinfeld modules, in the most "textbook" fashion possible. I also
believe that it is not ours to introduce new notions, such as elements of
Drinfeld modules. I stand by the current implementation, which, in my opinion,
best modelizes Drinfeld modules.


---

Comment by @DavidAyotte created at 2022-09-21 18:58:31

Replying to [comment:245 Antoine Leudière]:
> > Also, you should not import directly from `.all`, but instead import the
> > desired class directly from the right module.
> 
> Why is that? This looks like a standard practice. See `src/sage/all.py` and
> `src/sage/rings/all.py`.

See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)

and: #34201


---

Comment by @DavidAyotte created at 2022-09-21 19:44:21

Replying to [comment:246 Antoine Leudière]:
> I believe the implementation and the documentation would step out their
> prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working
> mathematician. Design and documentation should reflect the common mathematical
> modeling of Drinfeld modules, in the most "textbook" fashion possible. I also
> believe that it is not ours to introduce new notions, such as elements of
> Drinfeld modules. I stand by the current implementation, which, in my opinion,
> best modelizes Drinfeld modules.

I'm trying to distinguish mathematics from programming here. To me, using a Sage element class for Drinfeld modules **does not means** that we are introducing a new mathematical notion, it means that we are making use of a programming framework (hence my comment about adding info on this in the documentation).

Although, I think you are right about the usage of conversion and coercion, I could not find if it could add something. Personally, at this point I don't know what's wrong or right. Your current implementation indeed seems fine.

p.s. thank you for fixing that `FunctionField` import!! `:-)`


---

Comment by git created at 2022-09-22 12:48:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-09-22 12:49:18

Replying to [comment:247 David Ayotte]:
> Replying to [comment:245 Antoine Leudière]:
> > > Also, you should not import directly from `.all`, but instead import the
> > > desired class directly from the right module.
> > 
> > Why is that? This looks like a standard practice. See `src/sage/all.py` and
> > `src/sage/rings/all.py`.
> 
> See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)
> 
> and: #34201

Better?


---

Comment by git created at 2022-09-29 08:39:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-29 09:07:36

Replying to [comment:247 David Ayotte]:
> Replying to [comment:245 Antoine Leudière]:
> > > Also, you should not import directly from `.all`, but instead import the
> > > desired class directly from the right module.
> > 
> > Why is that? This looks like a standard practice. See `src/sage/all.py` and
> > `src/sage/rings/all.py`.
> 
> See: [https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies](https://doc.sagemath.org/html/en/developer/packaging_sage_library.html#module-level-runtime-dependencies)
> 
> and: #34201

Additionally, this can introduce very subtle and hard to find/debug circular imports.


---

Comment by tscrim created at 2022-09-29 09:25:23

Replying to [comment:248 David Ayotte]:
> Replying to [comment:246 Antoine Leudière]:
> > I believe the implementation and the documentation would step out their
> > prerogatives. [SageMath](SageMath) is a high level computing toolbox for the working
> > mathematician. Design and documentation should reflect the common mathematical
> > modeling of Drinfeld modules, in the most "textbook" fashion possible. I also
> > believe that it is not ours to introduce new notions, such as elements of
> > Drinfeld modules. I stand by the current implementation, which, in my opinion,
> > best modelizes Drinfeld modules.
> 
> I'm trying to distinguish mathematics from programming here. To me, using a Sage element class for Drinfeld modules **does not means** that we are introducing a new mathematical notion, it means that we are making use of a programming framework (hence my comment about adding info on this in the documentation).

+1 to what David is saying. Design can diverge from what is in the textbooks (e.g., how did you learn to multiply polynomials?), and subsequently, you should not force things into certain programming frameworks because of the name (not every implementation of something you want to think of as a category should inherit from `Category`). For example, ask yourself what is a representation? Is it a function to some general linear group or a module with an action? In many ways, the latter is also a morphism, but a lot of what I do is really about doing linear algebra on a vector space. So that is more natural for me to just have a vector space plus action, not the morphism even though that is the mathematically correct definition.


---

Comment by @spaenlehauer created at 2022-09-30 19:31:54

> +1 to what David is saying. Design can diverge from what is in the textbooks (e.g., how did you learn to multiply polynomials?), and subsequently, you should not force things into certain programming frameworks because of the name (not every implementation of something you want to think of as a category should inherit from `Category`). For example, ask yourself what is a representation? Is it a function to some general linear group or a module with an action? In many ways, the latter is also a morphism, but a lot of what I do is really about doing linear algebra on a vector space. So that is more natural for me to just have a vector space plus action, not the morphism even though that is the mathematically correct definition.

I agree that many algorithms in computational mathematics ultimately reduce to linear algebra (or other fundamental computational building blocks such as the FFT). I think that at this point, the code both fits correctly the mathematical definition of Drinfeld modules, and it also fits well in the programming framework offered by the class `Category` in Sagemath. Also, I think that the code is quite user-friendly, especially for mathematicians working with Drinfeld modules and their isogenies. I suggest that we go back to the "needs review" status. Doing so might attract other people who might give their opinion, and this would also give some forward momentum to this ticket.


---

Comment by @spaenlehauer created at 2022-09-30 19:32:13

Changing status from needs_work to needs_review.


---

Comment by @DavidAyotte created at 2022-09-30 21:40:03

> Doing so might attract other people who might give their opinion, and this would also give some forward momentum to this ticket.

Usually the need review status of a ticket is simply a way of saying "ok, I think that this is ready and I'd like it to be peer reviewed".

I think that it is not quite ready for a positive review yet, for example I'd like to recall that I reviewed part of the code in my comment:125 which has been lost in the discussion. I'll continue to review it later.

EDIT: I meant comment:123. The issue of comment:125 is already fixed.


---

Comment by @spaenlehauer created at 2022-10-01 07:49:22

Replying to [comment:257 David Ayotte]:
> Usually the need review status of a ticket is simply a way of saying "ok, I think that this is ready and I'd like it to be peer reviewed".
>
> I think that it is not quite ready for a positive review yet, for example I'd like to recall that I reviewed part of the code in my comment:125 which has been lost in the discussion. I'll continue to review it later.

Many thanks David for reviewing the code! I agree that your comment:123 and comment:125 (EDIT: in fact only comment:123, cf. comment:257) have been lost in the discussion, and they should be addressed.


---

Comment by tscrim created at 2022-10-01 13:58:31

Additionally, 100% doctest coverage. I also highly recommend within your `__init__` you run `TestSuite(foo).run()`.


---

Comment by tscrim created at 2022-10-01 13:58:31

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-10-05 13:27:43

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by antoine-leudiere created at 2022-10-05 13:28:43

I apologize, David, for missing comment [comment:123]. I addressed every point.
Some comments:
- I removed the `if` statement. I think you were right in pointing out that it
  was useless, as the Ore polynomial ring has unique representation.
- The code was really made with finite Drinfeld modules in mind. However, I
  agree that the documentation should emphasize that non finite Drinfeld
  modules can be created. What I did is insisting on that as early and clearly
  as possible in the `DrinfeldModule` docstring. Please tell me if you find
  this sufficient, or if you want me to add examples in some methods (which
  ones?) — I'm glad to do it.

Further, a warm and sincere thank you for reviewing the code.

I also thank Travis for insisting on having full doctest coverage;
achieving this made me fix some issues. All tests pass, and I believe I
fixed `make doc` errors, as well as many small cosmetic problems in the
documentation.

It comes as no surprise that `TestSuite(drinfeld_module).run()` fails. One of
the reasons is that those tests require the category `DrinfeldModules` of
Drinfeld modules to be a subcategory of the category `Sets()` of sets. This is
not the case, as objects are not sets and morphisms are not maps. Another
reason is that the tests require the parent class `DrinfeldModule` to have
elements. Even though this generally is not a good practice, I suggest not to
run `TestSuite(drinfeld_module).run()`.


---

Comment by git created at 2022-10-05 15:26:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-10-05 19:25:13

Replying to [comment:261 Antoine Leudière]:
> It comes as no surprise that `TestSuite(drinfeld_module).run()` fails.

You can skip specific tests by passing `skip=['...', '...']` to `run`


---

Comment by @DavidAyotte created at 2022-10-06 04:13:28

>The code was really made with finite Drinfeld modules in mind. However, I agree that the documentation should emphasize that non finite Drinfeld modules can be created. What I did is insisting on that as early and clearly as possible in the `DrinfeldModule` docstring. Please tell me if you find this sufficient, or if you want me to add examples in some methods (which ones?) — I'm glad to do it.

I understand! most of the Drinfeld modules I work with are of generic characteristic, hence my comment. What you did looks good!

Some comments: 

* Small typo in the documentation of `DrinfeldModules`:

```diff
     We say that `\mathbb{F}_q[X]` is the function ring of the category;
+    `K\{\tau\}` is the polynomial ring of the category.
-    `K\{\tau\}` is the re polynomial ring of the category.
```


* At various places you write "non XYZ" or "non-XYZ" (ex.: "non zero", "non-zero" and "non-constant"), but I think that correct wording is "nonXYZ", for example: "nonzero" (no space and no hyphen).

* About this comment:

```
        # FIXME
        # The parent method `base_ring` is defined not here, as it
        # should be, but in `DrinfeldModule`.
        #
        # This is because calling `phi.base_ring()` calls the
        # `base_ring` method of `CategoryObject` and not the one defined
        # here.
        #
        # This works, but any better solution would be welcome.
```

    Here, you are not using `CategoryObject` anymore, so I think that you can remove this comment. Also, you have an other mention of `CategoryObject` in the `base_ring` method of `DrinfeldModule`:

```
    def base_ring(self):
        r"""
        Raise exception ``AttributeError``.

        The base of a Drinfeld module is a ring morphism, not a ring.

        This method is implemented in ``CategoryObject``, of which Parent
        inherits. It returns the base of the category. I overloaded it
        to avoid confusion.
```

    In fact, I think you don't need this method anymore, since you now use `Category_over_base`.

* On the same topic of base ring, I think that this is a bug:

```
sage: A = GF(5)['T']; K = Frac(A)
sage: phi = DrinfeldModule(A, [K(2), K.one()]); phi
Drinfeld module defined by T |--> t + 2 over base Ring morphism:
  From: Univariate Polynomial Ring in T over Finite Field of size 5
  To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
  Defn: T |--> 2
sage: phi.is_finite()
False
```

    Also, this should not be possible:

```
sage: A = GF(5)['T']; K = Frac(A)
sage: DrinfeldModule(A, [K(2), K.gen()])
Drinfeld module defined by T |--> T*t + 2 over base Ring morphism:
  From: Univariate Polynomial Ring in T over Finite Field of size 5
  To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
  Defn: T |--> 2
```

    Indeed, the coefficients of a Drinfeld module should be elements of the image of the base (and `T` is not in the image in the example above). One fix for this would be to try to convert the constant coefficient of the Drinfeld module into an element of a finite field. For example, this works:

```
sage: phi.function_ring().base_ring()(phi.constant_coefficient())
2
```

    even though `phi.constant_coefficient()` is an element of `Frac(A)`. However, there might be a better way of doing this.


---

Comment by @DavidAyotte created at 2022-10-06 12:49:14

Hi, after a good night of sleep, I was thinking about the last example I brought up in my last comment and I think that I was a bit confused. In fact, it should be possible to consider such Drinfeld module even if the characteristic of the chosen `A`-field is finite. The conditions to be a Drinfeld module are imposed only on the constant coefficient. Sorry for this confusion!

Also, if a Drinfeld module defined over `Fq(X)` have its coefficients in `Fq`, should we call it finite?


---

Comment by git created at 2022-10-11 17:01:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-10-11 17:08:02

Replying to [comment:263 Matthias Köppe]:
> Replying to [comment:261 Antoine Leudière]:
> > It comes as no surprise that `TestSuite(drinfeld_module).run()` fails.
> 
> You can skip specific tests by passing `skip=['...', '...']` to `run`

Thanks for the tip; this looks like the way to go.

Replying to [comment:264 David Ayotte]:
> 
> * About this comment:
> {{{
>         # FIXME
>         # The parent method `base_ring` is defined not here, as it
>         # should be, but in `DrinfeldModule`.
>         #
>         # This is because calling `phi.base_ring()` calls the
>         # `base_ring` method of `CategoryObject` and not the one defined
>         # here.
>         #
>         # This works, but any better solution would be welcome.
> }}}
>     Here, you are not using `CategoryObject` anymore, so I think that you can remove this comment. Also, you have an other mention of `CategoryObject` in the `base_ring` method of `DrinfeldModule`:
> {{{
>     def base_ring(self):
>         r"""
>         Raise exception ``AttributeError``.
> 
>         The base of a Drinfeld module is a ring morphism, not a ring.
> 
>         This method is implemented in ``CategoryObject``, of which Parent
>         inherits. It returns the base of the category. I overloaded it
>         to avoid confusion.
> }}}
>     In fact, I think you don't need this method anymore, since you now use `Category_over_base`.

Apologies for not making things clearer.

The problem is the following. In this implementation, the base of a Drinfeld
module category is a _morphism_ `\gamma: A \to K` rather than just the field
`K`. Therefore, the method `base_ring` is misleading (to me at least), and I
don't want it implemented (this is debatable, as a `change_ring` method would
be nice).

However, the class `DrinfeldModule` inherits `Parent`, which inherits
`CategoryObject`. The class `CategoryObject` implements the method `base_ring`,
only to return `self._base` (see
`$SAGE_ROOT/src/sage/structure/category_object.pyx`, line 610). Consequently,
it is always possible to call `phi.base_ring()`. My goal is then to have this
method raise an exception when called, to emphasize that here, Drinfeld modules
do not have base rings. The first thing I tried was to implement `base_ring` in
the `class ParentMethods:` part of `DrinfeldModules`. However, this does not
work, and the solution I found was to define the method in `DrinfeldModule`.

The definition of `base_ring` should in the _parent methods_ of
`DrinfeldModules`, as it is a method that depends on the sole category.

I tried to make the comment clearer, hope that's better.

 
Replying to [comment:264 David Ayotte]:
> * On the same topic of base ring, I think that this is a bug:
> {{{
> sage: A = GF(5)['T']; K = Frac(A)
> sage: phi = DrinfeldModule(A, [K(2), K.one()]); phi
> Drinfeld module defined by T |--> t + 2 over base Ring morphism:
>   From: Univariate Polynomial Ring in T over Finite Field of size 5
>   To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
>   Defn: T |--> 2
> sage: phi.is_finite()
> False
> }}}
>     Also, this should not be possible:
> {{{
> sage: A = GF(5)['T']; K = Frac(A)
> sage: DrinfeldModule(A, [K(2), K.gen()])
> Drinfeld module defined by T |--> T*t + 2 over base Ring morphism:
>   From: Univariate Polynomial Ring in T over Finite Field of size 5
>   To:   Fraction Field of Univariate Polynomial Ring in T over Finite Field of size 5
>   Defn: T |--> 2
> }}}
>     Indeed, the coefficients of a Drinfeld module should be elements of the image of the base (and `T` is not in the image in the example above). One fix for this would be to try to convert the constant coefficient of the Drinfeld module into an element of a finite field. For example, this works:
> {{{
> sage: phi.function_ring().base_ring()(phi.constant_coefficient())
> 2
> }}}
>     even though `phi.constant_coefficient()` is an element of `Frac(A)`. However, there might be a better way of doing this.

Replying to [comment:265 David Ayotte]:
> Hi, after a good night of sleep, I was thinking about the last example I brought up in my last comment and I think that I was a bit confused. In fact, it should be possible to consider such Drinfeld module even if the characteristic of the chosen `A`-field is finite. The conditions to be a Drinfeld module are imposed only on the constant coefficient. Sorry for this confusion!
> 
> Also, if a Drinfeld module defined over `Fq(X)` have its coefficients in `Fq`, should we call it finite? 

I think you are raising a crucial question. It shows that there is ambiguity in
the documentation that must be addressed.

In my view, the ideal solution would be to instantiate a Drinfeld module `phi`
by giving a *morphism* `A \to K\{\tau\}` as the input. We can deduce the
base ring morphism from here as the morphism `\Fq[X] \to K` defined by
`D \circ \phi`, where `D` is the "constant-coefficient function".

As we saw in the early days of this ticket, this requires numerous lines of
code, and we chose a lighter solution: `DrinfeldModule` is defined with the
sole generator; the base morphism is implicitly defined as the ring morphism
`A \to K` that maps `a` to the constant coefficient of `\phi_a`, and where `K`
is the compositum of all the parents of the coefficients.

This means that a Drinfeld module whose coefficients lie in a finite field
(e.g. `\Fq`) but whose parent is a function field (e.g. `\Fq(X)`) would not be
considered finite.

I amended the documentation to make it clearer. What do you think?


---

Comment by @DavidAyotte created at 2022-10-11 19:14:40

Replying to [comment:267 Antoine Leudière]:
> The problem is the following. In this implementation, the base of a Drinfeld module category is a morphism `\gamma: A \to K` rather than just the field `K`. Therefore, the method `base_ring` is misleading (to me at least), and I don't want it implemented (this is debatable, as a `change_ring` method would be nice).

May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?

> In my view, the ideal solution would be to instantiate a Drinfeld module `phi`
> by giving a *morphism* `A \to K\{\tau\}` as the input. We can deduce the
> base ring morphism from here as the morphism `\Fq[X] \to K` defined by
> `D \circ \phi`, where `D` is the "constant-coefficient function".
> 
> As we saw in the early days of this ticket, this requires numerous lines of
> code, and we chose a lighter solution: `DrinfeldModule` is defined with the
> sole generator; the base morphism is implicitly defined as the ring morphism
> `A \to K` that maps `a` to the constant coefficient of `\phi_a`, and where `K`
> is the compositum of all the parents of the coefficients.
> 
> This means that a Drinfeld module whose coefficients lie in a finite field
> (e.g. `\Fq`) but whose parent is a function field (e.g. `\Fq(X)`) would not be
> considered finite.

Unless that I'm confused again, I think that by giving a morphism `A --> K{\tau}` as the input, the same problem could be possible to recreate: we could consider a morphism `A --> \Fq(X){\tau}` sending `X` to a `\tau`-polynomial with coefficient in `\Fq` which are coerced in `\Fq(X)`.

Do you think that the Drinfeld module constructor could parse the coefficients a little bit further by checking if they can be converted into an element of a finite field? For example:

```
sage: A.<X> = GF(5)[]
sage: K.<X> = Frac(A)
sage: a = K(2)
sage: a.parent()
Fraction Field of Univariate Polynomial Ring in X over Finite Field of size 5
sage: b = K.base_ring()(a); b
2
sage: b.parent()
Finite Field of size 5
sage: K.base_ring()(X)
Traceback (most recent call last):
...
ValueError: not constant
```



---

Comment by caruso created at 2022-10-13 09:03:52

Replying to [comment:268 David Ayotte]:
> May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?

I propose to return `F.over(phi.category().base())` which exactly returns what you wants, i.e. `A` considered as an algebra over `Fq[X]` through defining morphism.

Or, maybe even better, let `phi.category().base()` return also the ring extension.


---

Comment by antoine-leudiere created at 2022-10-17 11:16:24

Replying to [comment:268 David Ayotte]:
> Replying to [comment:267 Antoine Leudière]:
> > The problem is the following. In this implementation, the base of a Drinfeld module category is a morphism `\gamma: A \to K` rather than just the field `K`. Therefore, the method `base_ring` is misleading (to me at least), and I don't want it implemented (this is debatable, as a `change_ring` method would be nice).
> 
> May I ask what are the advantages of considering a `A`-field (`A = Fq[X]`) as a morphism? Mathematically, a `A`-field is just a field `F` which is a `A`-algebra `F` via a morphism `Fq[X] ---> F`. Thus, I think that there are two valid points of view for a `A`-field (as a field or as a morphism) in a similar way that there are two valid points of view for a representation (as a module or a group morphism). So, to rephrase my question, what made you choose to consider the morphism point of view?
> 

I think both points of view are very good, and I did not know about
`K.over(gamma)`, which is why I went for the morphism! Thanks Xavier for the
tip. Despite the morphism point of view working and being quite natural, I am
happy to change for the `A`-field point of view! I will refactor the code.


> > In my view, the ideal solution would be to instantiate a Drinfeld module `phi`
> > by giving a *morphism* `A \to K\{\tau\}` as the input. We can deduce the
> > base ring morphism from here as the morphism `\Fq[X] \to K` defined by
> > `D \circ \phi`, where `D` is the "constant-coefficient function".
> > 
> > As we saw in the early days of this ticket, this requires numerous lines of
> > code, and we chose a lighter solution: `DrinfeldModule` is defined with the
> > sole generator; the base morphism is implicitly defined as the ring morphism
> > `A \to K` that maps `a` to the constant coefficient of `\phi_a`, and where `K`
> > is the compositum of all the parents of the coefficients.
> > 
> > This means that a Drinfeld module whose coefficients lie in a finite field
> > (e.g. `\Fq`) but whose parent is a function field (e.g. `\Fq(X)`) would not be
> > considered finite.
> 
> Unless that I'm confused again, I think that by giving a morphism `A --> K{\tau}` as the input, the same problem could be possible to recreate: we could consider a morphism `A --> \Fq(X){\tau}` sending `X` to a `\tau`-polynomial with coefficient in `\Fq` which are coerced in `\Fq(X)`.
> 
> Do you think that the Drinfeld module constructor could parse the coefficients a little bit further by checking if they can be converted into an element of a finite field? For example:
> {{{
> sage: A.<X> = GF(5)[]
> sage: K.<X> = Frac(A)
> sage: a = K(2)
> sage: a.parent()
> Fraction Field of Univariate Polynomial Ring in X over Finite Field of size 5
> sage: b = K.base_ring()(a); b
> 2
> sage: b.parent()
> Finite Field of size 5
> sage: K.base_ring()(X)
> Traceback (most recent call last):
> ...
> ValueError: not constant
> }}}

Please let me know if I misunderstood something.

I think coefficients of the Drinfeld module generator should always be seen as
element of the codomain of the morphism `gamma: A \to K` that defines the
category. Even if the coefficients could be seen in a smaller, finite field.
This makes a clear convention; users can themselves specify the field they
want.

For example, if the Drinfeld module is defined using `[Frac(FqX)(1), Frac(FqX)(1)]`,
I don't consider it finite, because `K` is `Frac(FqX)` and it
is infinite. However, this Drinfeld module canonically corresponds to a finite
Drinfeld module defined over `\Fq`. I suggest that the constructor stays the
same and doesn't try any conversion. We may however create a method that casts
the Drinfeld module to a new one with a smaller field, whenever possible.


---

Comment by @DavidAyotte created at 2022-10-17 13:17:38

> Please let me know if I misunderstood something.

No I don't think that you misunderstood something. In fact, I think you've made some good points. I was seeing this as a problem, but, looking back, I find that it is really just a matter of definition/convention. Therefore, I'm totally fine to leave it as it is.


---

Comment by antoine-leudiere created at 2022-10-17 14:09:18

Replying to [comment:271 David Ayotte]:
> > Please let me know if I misunderstood something.
> 
> No I don't think that you misunderstood something. In fact, I think you've made some good points. I was seeing this as a problem, but, looking back, I find that it is really just a matter of definition/convention. Therefore, I'm totally fine to leave it as it is.

Understood. Thank you for this discussion!


---

Comment by git created at 2022-11-15 15:24:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by antoine-leudiere created at 2022-12-09 14:08:57

After discussing this with Xavier Caruso, we suggest to remove the class `DrinfeldModuleAction` in order to replace it by a new class, representing the _module_ associated to a Drinfeld module. See ticket #34833, which will be worked on later.

Best,

Antoine
