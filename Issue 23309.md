# Issue 23309: two erros in treewidth for non-connected graphs

Issue created by migration from https://trac.sagemath.org/ticket/23546

Original creator: evandomme

Original creation time: 2017-07-27 13:28:35

Keywords: tree decomposition; tree-width

The function treewidth() with the option certificate=True encounters two problems on non-connected graphs.

Firstly, if I run

```div style="font-size: 80%"
  {{{#!python
  g=Graph({0:[1,2], 3:[4,5], 4:[5]})
  g.treewidth(certificate=True)
  }}}
```

I obtain 

![](http://lacim.uqam.ca/~elise.vandomme/treewidth.png) 

which contradicts the fact that the tree-width of the graph is 2.

The problem comes from the part ".edges(labels=False)" in

```div style="font-size: 80%"
  {{{#!python
       # Disconnected cases
        if not g.is_connected():
            if certificate is False:
                if k is None:
                    return max(cc.treewidth() for cc in g.connected_components_subgraphs())
                else:
                    return all(cc.treewidth(k) for cc in g.connected_components_subgraphs())
            else:
                return Graph(sum([cc.treewidth(certificate=True).edges(labels=False)
                                  for cc in g.connected_components_subgraphs()],[]),
                             name="Tree decomposition")
  }}}
```

Indeed, one of the connected components has a tree decomposition that consists of a single vertex. So its list of edges is an empty list and we lose information when we just consider the concatenation of edges list.

Secondly, a tree decomposition is a tree by definition. But when I run 

```div style="font-size: 80%"
  {{{#!python
  g=Graph({0:[1,2], 3:[4,5]})
  g.treewidth(certificate=True)
  }}}
```

the result is two non-connected edges. This minor problem can be corrected by adding an arbitrary edge between the i-th and i+1-th connected components of the result (for all possible i).


---

Comment by dcoudert created at 2017-07-28 08:29:45

You are right and this is what we get when using `tdlib` (optional package)

```
sage: g = Graph({0:[1,2], 3:[4,5], 4:[5]})
sage: T = g.treewidth(algorithm='tdlib', certificate=True)
sage: print T.edges(labels=0)
[({3, 4, 5}, {0, 2}), ({0, 2}, {0, 1})]
```


Are you planing to write the patch ? If so I can review it.


---

Comment by mlapointe created at 2017-08-30 20:50:36

New commits:


---

Comment by mlapointe created at 2017-08-30 20:50:36

Changing status from new to needs_review.


---

Comment by dcoudert created at 2017-08-31 07:57:58

The patch is working well. However, a few minor changes are needed.

-  `:trac:`23546`::`  -> `The decomposition is a tree (:trac:`23546`)::`. This will improve the documentation. 

- You must add an empty line after between the line with `:trac:`23546`` and the line `sage: g = Graph({0:[1,2], 3:[4,5]})`.

- `sage: vertices = set({})` -> `sage: vertices = {}`. 

- `v = T[0].vertices()[0]` -> `v = next(T[0].vertex_iterator())`. There is no need for first building the list of vertices. We can use the iterator to get the first vertex.

- `tree.add_edge([t.vertices()[0],v])` -> `tree.add_edge(t.vertices()[0], v)`. Here also, there is no need for creating a list.

Thank you.


---

Comment by vdelecroix created at 2017-08-31 18:14:14

But... what is an ``erros``!? ;-)


---

Comment by dcoudert created at 2017-08-31 18:47:22

I have corrected the ticket title.


---

Comment by git created at 2017-09-03 20:44:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mlapointe created at 2017-09-03 20:49:01

I have implemented all the suggestion except this one:

sage: vertices = set({}) -> sage: vertices = {}

since the object {} is a dictionary and I want to have an empty set.


---

Comment by dcoudert created at 2017-09-04 07:33:02

In the example, the last test assumes an ordering of the vertices. This is not a good idea (actually, ticket #22349 proposes to remove the sorting).

```
sage: [1,2,3,4] == [4,3,2,1]
False
```


Please change to

```
sage: for s in t.vertices():
....:    vertices.update(s)
sage: vertices == set(g.vertices())
True
```



---

Comment by git created at 2017-09-04 21:31:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mlapointe created at 2017-09-04 21:32:24

Replying to [comment:9 dcoudert]:
> In the example, the last test assumes an ordering of the vertices. This is not a good idea (actually, ticket #22349 proposes to remove the sorting).
> {{{
> sage: [1,2,3,4] == [4,3,2,1]
> False
> }}}
> 
> Please change to
> {{{
> sage: for s in t.vertices():
> ....:    vertices.update(s)
> sage: vertices == set(g.vertices())
> True
> }}}

I agree and I have made the modification.


---

Comment by dcoudert created at 2017-09-05 07:17:49

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2017-09-05 07:17:49

For me this patch is now good to go. Thank you.


---

Comment by vbraun created at 2017-09-10 11:56:27

Resolution: fixed
