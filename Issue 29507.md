# Issue 29507: diameter computation in undirected graphs using certificates

Issue created by migration from https://trac.sagemath.org/ticket/29744

Original creator: @vipul79321

Original creation time: 2020-05-27 17:08:52

CC:  dcoudert

Keywords: gsoc20

This ticket aims to implement diameter computation method for weighted and unweighted undirected graphs, as given in [http://arxiv.org/abs/1803.04660](http://arxiv.org/abs/1803.04660)


---

Comment by git created at 2020-05-27 17:10:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-05-27 17:16:11

Changing status from new to needs_review.


---

Comment by dcoudert created at 2020-05-27 17:43:06

The paper is unclear for the line `Select x such that d(u, x) + e(x) = e(u)`. In fact, this is method minES in the paper.

Since we don't know e(x), we do as follows (a `while True` loop):
1. Select x minimizing e_L(x) and such that d(u, x) + e_L(x) <= e(u).
2. Compute e(x) and update `LB`.
3. If e(x) = e_L(x), then x a good choice. We use it to update eccentricity upper bounds. Then we break from the while loop.
3. Otherwise, x was not a good choice. We use its antipode to update lower bounds. Then, we go to 1.

It might be suitable to maintain the list of vertices from which we have not yet computed a BFS.


Don't forget to add this ticket in the meta ticket. Also, I have not checked if a previously opened ticket was trying to implement the same algorithm...


---

Comment by git created at 2020-05-28 18:43:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-05-28 18:46:30

Replying to [comment:4 dcoudert]:
> The paper is unclear for the line `Select x such that d(u, x) + e(x) = e(u)`. In fact, this is method minES in the paper.
> 
> Since we don't know e(x), we do as follows (a `while True` loop):
> 1. Select x minimizing e_L(x) and such that d(u, x) + e_L(x) <= e(u).
> 2. Compute e(x) and update `LB`.
> 3. If e(x) = e_L(x), then x a good choice. We use it to update eccentricity upper bounds. Then we break from the while loop.
> 3. Otherwise, x was not a good choice. We use its antipode to update lower bounds. Then, we go to 1.
> 
I have added following changes and performance improved a little, but still not comparable to iFUB.

> It might be suitable to maintain the list of vertices from which we have not yet computed a BFS.
It unclear to me, how we should use list of active vertices. Can you explain this part, so I can work on it.


---

Comment by dcoudert created at 2020-05-29 09:38:23

let active be the list of vertices

while True, do:
1. let idx be the index of the vertex in active with largest eccentricity upper bound
2. active[idx], active[-1] = active[-1], active[idx]   # exchange 
3. source = active.pop()   # source is no longer active
4. compute BFS from source, set ecc[source] and update eccentricity lower bounds
5. apply minES as described in #comment:4.
  - Each time you select a vertex x in active, you remove it from active.
  - Warning: when you select the antipode, may be it is no longer active, and so cannot be removed from active. This is something hard to avoid. But you can use it anyway. So check if the antipode is in active and if so remove it.


Hope it helps.


---

Comment by git created at 2020-05-29 18:10:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-05-29 18:19:06

Replying to [comment:7 dcoudert]:
> let active be the list of vertices
> 
> while True, do:
> 1. let idx be the index of the vertex in active with largest eccentricity upper bound
> 2. active[idx], active[-1] = active[-1], active[idx]   # exchange 
> 3. source = active.pop()   # source is no longer active
> 4. compute BFS from source, set ecc[source] and update eccentricity lower bounds
> 5. apply minES as described in #comment:4.
>   - Each time you select a vertex x in active, you remove it from active.
>   - Warning: when you select the antipode, may be it is no longer active, and so cannot be removed from active. This is something hard to avoid. But you can use it anyway. So check if the antipode is in active and if so remove it.
> 
> 
> Hope it helps.
I have update my method as you mentioned. But there is no improvement in performance.\\

One major drawback of our code is that sometimes it never comes out of inner while loop. This happens, because there is no vertex in `active` list which satisfies the condition `distances[v] + ecc_lower_bound[v] <= ecc[source]` and hence the continuous popping from `active` list\\

We have to figure out a way to deal with this situation when there is no such vertex in `active` list

I have following suggestions:
- If intially there is no vertex in `active` list, which satisfies the condition, then we should use `source` as its `delegate certificate`
- If after entering inner while loop there is no vertex in `active` list which satisfies the condition, then we should use last `x` as `delegate certificate`


---

Comment by dcoudert created at 2020-05-30 14:37:53

I pushed a new branch with a different version of the algorithm. For me it's better and it is generally faster than iFUB.
I have also renamed the algorithm as `DHV` instead of `diameter_dragan`. The branch is in public, so you can modify it.
----
New commits:


---

Comment by git created at 2020-05-30 18:22:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-05-30 18:36:29

- First of all, I would like to mention, it is very clean, efficient and simplified code :)

- One problem, I encountered was that it was giving index error as follows

```
sage: from sage.graphs.distances_all_pairs import diameter
sage: G = graphs.RandomGNP(21,0.6)
sage: % time diameter(G, algorithm = 'DHV')
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
IndexError: list index out of range
Exception ignored in: 'sage.graphs.distances_all_pairs.diameter_dragan'
IndexError: list index out of range
CPU times: user 512 µs, sys: 27 µs, total: 539 µs
Wall time: 470 µs
0
```


I have fixed that.
\\
\\
- I agree, it sometimes works faster than iFUB. 
Few examples that I would like to point out, where it perform equivalent to brute are - 


```
sage: G = graphs.RandomGNP(1009,0.6)
sage: % time diameter(G, algorithm = 'standard')
CPU times: user 673 ms, sys: 7.41 ms, total: 681 ms
Wall time: 679 ms
2
sage: % time diameter(G, algorithm = 'DHV')
CPU times: user 648 ms, sys: 0 ns, total: 648 ms
Wall time: 647 ms
2
sage: % time diameter(G)
CPU times: user 346 ms, sys: 0 ns, total: 346 ms
Wall time: 345 ms
2
```




```
sage: G = graphs.BubbleSortGraph(7)
sage: % time diameter(G, algorithm = 'standard')
CPU times: user 530 ms, sys: 0 ns, total: 530 ms
Wall time: 529 ms
21
sage: % time diameter(G, algorithm = 'DHV')
CPU times: user 580 ms, sys: 0 ns, total: 580 ms
Wall time: 580 ms
21
sage: % time diameter(G)
CPU times: user 276 ms, sys: 0 ns, total: 276 ms
Wall time: 276 ms
21
```




```
sage: G = graphs.FoldedCubeGraph(13)
sage: % time diameter(G, algorithm = 'standard')
CPU times: user 359 ms, sys: 0 ns, total: 359 ms
Wall time: 358 ms
6
sage: % time diameter(G, algorithm = 'DHV')
CPU times: user 374 ms, sys: 0 ns, total: 374 ms
Wall time: 373 ms
6
sage: % time diameter(G)
CPU times: user 297 ms, sys: 0 ns, total: 297 ms
Wall time: 296 ms
6
```


Maybe above graphs are the worst cases of this algorithm.


---

Comment by dcoudert created at 2020-05-30 18:57:50

if we need to add `active` in the outer while loop, it means that we are not correctly maintaining LB and UB. Indeed, if active is empty, it means that we have computed BFS from all the vertices. So we must have LB = UB. Can you check that ?

For the performance, try a large sparse graph, or `graphs.RandomBarabasiAlbert(100000, 2)`.


---

Comment by git created at 2020-05-31 17:32:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-05-31 17:36:07

You are right, we need to add `active` as a test of the outer while loop. This is typically the case for a graph with 2 vertices and an edge. I added a dockets for this case.

May be we should rename the method `diameter_DHV` to be consistent, no ?

You can now make this method available from the diameter method in `graph.py`.


---

Comment by @vipul79321 created at 2020-06-01 12:10:05

Replying to [comment:15 dcoudert]:
> You are right, we need to add `active` as a test of the outer while loop. This is typically the case for a graph with 2 vertices and an edge. I added a dockets for this case.
> 
> May be we should rename the method `diameter_DHV` to be consistent, no ?
> 
Yeah, that will be good.
> You can now make this method available from the diameter method in `graph.py`.

Before doing this. I was wondering maybe I should implement the weighted version of this algorithm in `boost_graph.pyx` ? Then we will expose it `graph.py`


---

Comment by dcoudert created at 2020-06-01 13:04:17

Feel free to do it.


---

Comment by git created at 2020-06-02 18:21:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-06-02 18:25:37

Replying to [comment:18 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[7314e0f](https://git.sagemath.org/sage.git/commit/?id=7314e0f202378b224866708ff5d3817e7b189f31)||`trac 29744: method added for weighted graphs and exposed in graph.py`||
> ||[e9798b8](https://git.sagemath.org/sage.git/commit/?id=e9798b8be90c26e8d6d474c8e24e4b030f8a2124)||`documentation updated`||
> ||[0ada585](https://git.sagemath.org/sage.git/commit/?id=0ada5851e8cacae3fcec1325bc9bfb9810c6df13)||`Merge branch 'public/graphs/29744_diameter_DHV' of git://trac.sagemath.org/sage into diameter_DHV`||

added `diameter_DHV` for weighted graph alongwith `check_weight` parameter and exposed both methods in `graph.py`.


---

Comment by dcoudert created at 2020-06-03 09:30:54

You should add a doctest with a weighted graph in boost.


```
sage: from sage.graphs.base.boost_graph import diameter_DHV
sage: G = graphs.CycleGraph(6)
sage: for u, v in G.edges(labels=False):
....:     G.set_edge_label(u, v, 1)
sage: G.set_edge_label(4, 5, -1)
sage: diameter_DHV(G)  # unweighted
3.0
sage: diameter_DHV(G, weight_function=lambda e:e[2])   # weighted 
0.0
```

This last answer is not correct.

Other issues, that were certainly already here.

```
sage: G.diameter(by_weight=True)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-8-a687234a118b> in <module>()
----> 1 G.diameter(by_weight=True)

/Users/dcoudert/sage/local/lib/python3.7/site-packages/sage/graphs/graph.py in diameter(self, by_weight, algorithm, weight_function, check_weight)
   5612             if by_weight:
   5613                 raise ValueError("algorithm '" + algorithm + "' does not work" +
-> 5614                                  " on weighted graphs")
   5615             from sage.graphs.distances_all_pairs import diameter
   5616             return diameter(self, algorithm=algorithm)

ValueError: algorithm 'iFUB' does not work on weighted graphs
sage: G.diameter(by_weight=True, algorithm='Johnson_Boost')
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-10-8e8a8c6456b1> in <module>()
----> 1 G.diameter(by_weight=True, algorithm='Johnson_Boost')

/Users/dcoudert/sage/local/lib/python3.7/site-packages/sage/graphs/graph.py in diameter(self, by_weight, algorithm, weight_function, check_weight)
   5619                                      weight_function=weight_function,
   5620                                      check_weight=check_weight,
-> 5621                                      algorithm=algorithm))
   5622 
   5623     @doc_index("Distances")

/Users/dcoudert/sage/local/lib/python3.7/site-packages/sage/graphs/graph.py in eccentricity(self, v, by_weight, algorithm, weight_function, check_weight, dist_dict, with_labels)
   5387         elif algorithm in ['Floyd-Warshall-Python', 'Floyd-Warshall-Cython', 'Johnson_Boost']:
   5388             raise ValueError("algorithm '" + algorithm + "' works only if all" +
-> 5389                              " eccentricities are needed")
   5390 
   5391         if not isinstance(v, list):

ValueError: algorithm 'Johnson_Boost' works only if all eccentricities are needed
```



---

Comment by dcoudert created at 2020-06-03 09:30:54

Changing status from needs_review to needs_work.


---

Comment by @vipul79321 created at 2020-06-03 11:26:14

Replying to [comment:20 dcoudert]:
> You should add a doctest with a weighted graph in boost.
> 
> {{{
> sage: from sage.graphs.base.boost_graph import diameter_DHV
> sage: G = graphs.CycleGraph(6)
> sage: for u, v in G.edges(labels=False):
> ....:     G.set_edge_label(u, v, 1)
> sage: G.set_edge_label(4, 5, -1)
> sage: diameter_DHV(G)  # unweighted
> 3.0
> sage: diameter_DHV(G, weight_function=lambda e:e[2])   # weighted 
> 0.0
> }}}
> This last answer is not correct.
> 
This happens because instead of detecting negative cycle, `Bellman-Ford` is returning negative distances :(

```
sage: from sage.graphs.base.boost_graph import shortest_paths
sage: G = graphs.CycleGraph(6)
sage: shortest_paths(G,0, weight_function = lambda e:e[2])[0]
{0: -2, 1: -1, 2: 0, 3: -3, 4: -4, 5: -5}
```

Any suggestion on what should I do for this?

> Other issues, that were certainly already here.
> {{{
> sage: G.diameter(by_weight=True)
> ---------------------------------------------------------------------------
> ValueError                                Traceback (most recent call last)
> <ipython-input-8-a687234a118b> in <module>()
> ----> 1 G.diameter(by_weight=True)
> 
> /Users/dcoudert/sage/local/lib/python3.7/site-packages/sage/graphs/graph.py in diameter(self, by_weight, algorithm, weight_function, check_weight)
>    5612             if by_weight:
>    5613                 raise ValueError("algorithm '" + algorithm + "' does not work" +
> -> 5614                                  " on weighted graphs")
>    5615             from sage.graphs.distances_all_pairs import diameter
>    5616             return diameter(self, algorithm=algorithm)
> 
> ValueError: algorithm 'iFUB' does not work on weighted graphs
> sage: G.diameter(by_weight=True, algorithm='Johnson_Boost')
> ---------------------------------------------------------------------------
> ValueError                                Traceback (most recent call last)
> <ipython-input-10-8e8a8c6456b1> in <module>()
> ----> 1 G.diameter(by_weight=True, algorithm='Johnson_Boost')
> 
> /Users/dcoudert/sage/local/lib/python3.7/site-packages/sage/graphs/graph.py in diameter(self, by_weight, algorithm, weight_function, check_weight)
>    5619                                      weight_function=weight_function,
>    5620                                      check_weight=check_weight,
> -> 5621                                      algorithm=algorithm))
>    5622 
>    5623     `@`doc_index("Distances")
> 
> /Users/dcoudert/sage/local/lib/python3.7/site-packages/sage/graphs/graph.py in eccentricity(self, v, by_weight, algorithm, weight_function, check_weight, dist_dict, with_labels)
>    5387         elif algorithm in ['Floyd-Warshall-Python', 'Floyd-Warshall-Cython', 'Johnson_Boost']:
>    5388             raise ValueError("algorithm '" + algorithm + "' works only if all" +
> -> 5389                              " eccentricities are needed")
>    5390 
>    5391         if not isinstance(v, list):
> 
> ValueError: algorithm 'Johnson_Boost' works only if all eccentricities are needed
> }}}
This will be fixed by making changes suggested in last comment:37 in #29715


---

Comment by dcoudert created at 2020-06-03 12:03:10

> This happens because instead of detecting negative cycle, `Bellman-Ford` is returning negative distances :(
> ...
> Any suggestion on what should I do for this?

1) Mention the problem in the meta ticket. 2) Check the documentation of 'Johnson_Boost' in case it can be used to detect negative cycles. Otherwise, we may have to change default algorithm.


---

Comment by @vipul79321 created at 2020-06-03 17:13:26

Replying to [comment:22 dcoudert]:
> > This happens because instead of detecting negative cycle, `Bellman-Ford` is returning negative distances :(
> > ...
> > Any suggestion on what should I do for this?
> 
> 1) Mention the problem in the meta ticket. 
Done.\\

> 2) Check the documentation of 'Johnson_Boost' in case it can be used to detect negative cycles.\\
Yeah it detects negative cycle properly.

But we cant use that in our algorithm. We have to find a way to avoid this, smae problem appears here and in `radius_DHV` in #29715.\\

- 1).I have one solution,  since this methods are restricted to undirected graphs, why dont we exploit that property, since any edge with negative weight will definitely be a cycle. So raise an error in begining while checking for negative edges?

- 2). or We can try the method, I suggested in #29657.

Finally, whichever method we decide, we have to decide what do we want from our method, when `graph contains negative cycle , as well graph is disconnected`.


---

Comment by @vipul79321 created at 2020-06-03 17:16:45

TODO:

- Find a reliable way to detect negative cycle, which can be used in our method.

- Make call to `eccentricity` method from `diameter` method with `v = None`.

- Finally, decide default algorithms.


---

Comment by dcoudert created at 2020-06-04 07:34:59

If I understand well, so far we have no algorithm that can be used for weighted undirected graph with at least 1 edge with negative weight. So I propose for this ticket and for #29715 to:
- raise an error if the graph has an edge with negative weight, and so to remove calls to Bellman-Ford. This way we have a correct implementation for graphs with non-negative weights.
- Indicate in the todo list of  #29657 that we have this issue. If we are able to find a proper fix, then we will be able to update all methods with this issue at once.


---

Comment by @vipul79321 created at 2020-06-04 08:08:06

Replying to [comment:25 dcoudert]:
> If I understand well, so far we have no algorithm that can be used for weighted undirected graph with at least 1 edge with negative weight. 

Yeah,because a negative edge in Undirected graph will automatically a cycle, because we can move in both direction from that edge and hence a cycle. 
Take a look at this, it might help us.
[https://stackoverflow.com/questions/14785413/can-we-apply-the-bellman-ford-algorithm-to-an-undirected-graph](https://stackoverflow.com/questions/14785413/can-we-apply-the-bellman-ford-algorithm-to-an-undirected-graph).


---

Comment by git created at 2020-06-04 18:06:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-06-04 18:07:14

Replying to [comment:25 dcoudert]:
> If I understand well, so far we have no algorithm that can be used for weighted undirected graph with at least 1 edge with negative weight. So I propose for this ticket and for #29715 to:
> - raise an error if the graph has an edge with negative weight, and so to remove calls to Bellman-Ford. This way we have a correct implementation for graphs with non-negative weights.
> - Indicate in the todo list of  #29657 that we have this issue. If we are able to find a proper fix, then we will be able to update all methods with this issue at once.

Done.


---

Comment by @vipul79321 created at 2020-06-04 18:07:47

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2020-06-05 08:24:16

Changing keywords from "gsoc20" to "gsoc2020".


---

Comment by dcoudert created at 2020-06-05 08:24:16

LGTM.


---

Comment by dcoudert created at 2020-06-05 08:24:16

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-06-21 22:42:23

Merge conflict


---

Comment by vbraun created at 2020-06-21 22:42:23

Changing status from positive_review to needs_work.


---

Comment by @vipul79321 created at 2020-06-22 08:11:14

`@`dcoudert, I tried solving the merge conflict using following steps - 

1). Firstly, I pulled branch `public/graphs/29744_diameter_DHV` in my local branch `diameter` of develop.

2). Then, on branch `develop`, I ran `git pull` to pull changes from sage git repository.

3). Then, I checked out `diameter` branch and ran `git merge develop`, hoping to get merge conflicts. But It merged cleanly. And is running without any problem.

Is this the right procedure to find merge conflicts?

Can you suggest me something for this?


---

Comment by dcoudert created at 2020-06-22 08:20:01

We have to wait for the next beta to see the conflict.
Tickets are accepted and merged into the develop branch for next beta in a certain order.
The radius ticket has been merged and it adds the references to Dragan. This might be the issue. So we will have to modify this ticket accordingly. This is for the same reason that we are waiting for the finalization of the eccentricity ticket.


---

Comment by git created at 2020-06-27 17:12:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-06-27 17:14:28

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2020-06-27 17:14:28

I fix merge conflict with 9.2.beta2. Please check that everything is working well.


---

Comment by @vipul79321 created at 2020-06-30 07:25:29

Replying to [comment:35 dcoudert]:
> I fix merge conflict with 9.2.beta2. Please check that everything is working well.

I have checked boundary cases. It looks good to me.


---

Comment by dcoudert created at 2020-06-30 08:32:59

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2020-06-30 08:32:59

LGTM.

the pycodestyle warnings reported by the patchbot are fixed in #29804


---

Comment by vbraun created at 2020-07-04 19:13:49

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2020-07-04 19:13:49

Merge conflict


---

Comment by git created at 2020-07-08 07:08:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-07-08 07:09:31

Replying to [comment:39 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[95d669a](https://git.sagemath.org/sage.git/commit/?id=95d669a09c3272680c08c5029018ec069643a71f)||`Merge branch 'public/graphs/29744_diameter_DHV' of git://trac.sagemath.org/sage into diameter`||
> ||[f2557a8](https://git.sagemath.org/sage.git/commit/?id=f2557a81df67ef5df8133c5784891fe4ee927e35)||`minor documentation change`||

Done some minor change in documentation.

Merge conflict still to be solved in next release


---

Comment by dcoudert created at 2020-07-08 07:18:49

OK, let's wait for next beta to see the issue.


---

Comment by git created at 2020-07-14 16:05:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-07-14 16:06:24

Replying to [comment:42 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[97c2b1b](https://git.sagemath.org/sage.git/commit/?id=97c2b1bf6422f9b1f46d460cce048bb25353c78a)||`fixed merge conflict`||

Fixed merge conflict with 9.2beta5


---

Comment by @vipul79321 created at 2020-07-14 16:06:39

Changing status from needs_work to needs_review.


---

Comment by git created at 2020-07-15 08:20:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-07-15 08:22:56

I did a minor change because in ticket #30145 I'm preparing the deprecation of `edge_iterator`. 

LGTM


---

Comment by dcoudert created at 2020-07-15 08:22:56

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-07-19 07:24:23

Resolution: fixed
