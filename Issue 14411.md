# Issue 14411: cythonize lazy_atrtibute

Issue created by migration from https://trac.sagemath.org/ticket/14615

Original creator: nbruin

Original creation time: 2013-05-19 20:55:50

Assignee: tbd

cythonize `lazy_attribute` so that it provides acceptable performance on cython classes that don't have a `__dict__` but do have a `__cached_methods` dictionary.


---

Comment by nbruin created at 2013-05-19 21:17:34

As a comparison, with

```
cython("""
from sage.misc.lazy_attribute import lazy_attribute
cdef class T(object):
    cdef public __cached_methods
    @lazy_attribute
    def t(self):
        return 10
    def s(self):
        return 10
""")
```

we get

```
sage: t=T()
sage: %timeit t.t
10000000 loops, best of 3: 82.6 ns per loop
```

and with the old `lazy_attribute` we get:

```
1000000 loops, best of 3: 517 ns per loop
```

This puts (cached) lazy attribute access in a factor of 2 of accessing `cdef public` members:

```
sage: %timeit t.__cached_methods
10000000 loops, best of 3: 42 ns per loop
```

Of course, if there's a dictionary available, the code for ``@`lazy_attribute` doesn't matter for cached retrieval. To get a bit of an idea of non-cached access costs with patch:

```
sage: %timeit T()
10000000 loops, best of 3: 78.4 ns per loop
sage: %timeit T().t
1000000 loops, best of 3: 1.15 us per loop
```

versus without patch:

```
sage: %timeit T().t
100000 loops, best of 3: 3.76 us per loop
```

so in this case there is still a reduction in overhead.Incidentally, we have:

```
sage: %timeit t.s()
10000000 loops, best of 3: 59.5 ns per loop
```

so the overhead on calling the wrapped function is really quite small (i.e., we're really just measuring the costs that `lazy_attribute` adds.


---

Comment by nbruin created at 2013-05-20 03:21:59

Changing status from new to needs_review.


---

Attachment

Hey Nils,

I've uploaded a new version of the patch which renames the file instead of an add/delete. I've also moved the doc from `_lazy_attribute` to `lazy_attribute` and brought the doc up to our current standard.

If you're happy with my changes, you can set this to positive review.

Best,

Travis

Here are my timings:

```
sage: %timeit t.t
1000000 loops, best of 3: 365 ns per loop
```

Without the patch:

```
sage: %timeit t.t
1000000 loops, best of 3: 1.59 us per loop
```


PS - As a word of warning to anyone who wants to test this, this basically caused sage to recompile for me.

For patchbot:

Apply: trac_14615-cythonize_lazy_attribute-v2.patch


---

Comment by nbruin created at 2013-05-25 06:51:34

Great! thank you. I tried but failed to coerce hg into producing such a patch. I'm definitely happy with your changes. I'm just not sure that merging this ticket is actually an improvement. The only `*.pyx` file in which I was able to find a use of `lazy_attribute` is for `_element_class` on `Parent`.

On python classes (with a `__dict__`) it will be very hard for the implementation to be critical, since most usage won't use the implementation anyway. I can imagine that loading an extension class has larger overhead than a conventional `*.pyc`, in which case there is actually a _penalty_ for cythonizing, and I'm not sure we're getting a benefit in return.

It's good to have, so that people can use `lazy_attribute` for more time critical applications. Should we be merging this ticket in anticipation of such applications arising?


---

Comment by tscrim created at 2013-05-25 16:40:18

Replying to [comment:5 nbruin]:
> Great! thank you. I tried but failed to coerce hg into producing such a patch. I'm definitely happy with your changes. I'm just not sure that merging this ticket is actually an improvement. The only `*.pyx` file in which I was able to find a use of `lazy_attribute` is for `_element_class` on `Parent`.

Then should we expect this result in a speedup for creating parent objects?

> On python classes (with a `__dict__`) it will be very hard for the implementation to be critical, since most usage won't use the implementation anyway. I can imagine that loading an extension class has larger overhead than a conventional `*.pyc`, in which case there is actually a _penalty_ for cythonizing, and I'm not sure we're getting a benefit in return.
> 
> It's good to have, so that people can use `lazy_attribute` for more time critical applications. Should we be merging this ticket in anticipation of such applications arising?

However `lazy_attribute` isn't an extension class since it isn't `cdef`'ed, correct? In either case, could we do something similar to `cached_method` to get around any penalties (I believe `cached_method` can be/is faster than python attribute lookup)? Or is the penalty you're referring to a loading/startup penalty? Actually, one more question/comment, shouldn't `lazy_attribute` be faster than `chached_method` with no arguements? I'll also look at it and run some tests later today.

I think we should be merging (some version of) this ticket precisely for the reason you stated.

Best,

Travis


---

Comment by nbruin created at 2013-05-25 17:09:09

Replying to [comment:6 tscrim]:
> Then should we expect this result in a speedup for creating parent objects?

No, not for creation. That's the trick of a _lazy_ attribute -- it doesn't incur a cost upon creation (instead it's sitting ready on the type (Parent in this case) to instantiate the attribute when required.

What does get sped up is _first access_ of the attribute. If the object in question has a dict, it doesn't matter which implementation we have afterwards: it's just a regular `__dict__` lookup from then on.

The only case where it really matter is for types that _don't_ have an instance dict, such as cython cdef classes, because the `__cached_method` lookup has to be done every time. We could speed that up even further (at the cost of flexibility) by casting `instance` to `Parent` before fetching `__cached_method`. We'll then get a straight `C struct` access in cython instead of a `getattr`.


> However `lazy_attribute` isn't an extension class since it isn't `cdef`'ed, correct? In either case, could we do something similar to `cached_method` to get around any penalties

Correct, but it inherits the relevant slots from a `cdef` class. That's where the speed increase comes from. The penalties I was thinking of was memory footprint and sage startup cost. I don't know if loading a `.so` is faster or slower than a `.pyc` (my guess is slower).

> (I believe `cached_method` can be/is faster than python attribute lookup)?

No, that's an artifact of cython classes not participating in the attribute lookup cache. That's fixed with cython 0.19.1. That is because many sage objects have very deep MROs and since an instance attribute can be shadowed by a data descriptor _anywhere_ in the MRO, it always had to walk all of it. That's fixed now.

Straight attribute lookup should always be faster than looking up a method and calling the method. because the method lookup has the same cost as looking up an attribute (modulo CPU memory and cache idiosyncrasies of course)

> Or is the penalty you're referring to a loading/startup penalty?

yes, that's what I meant.

> Actually, one more question/comment, shouldn't `lazy_attribute` be faster than `chached_method` with no arguements?

It should, for the reason above, but only with cython >= 0.19.1

> I think we should be merging (some version of) this ticket precisely for the reason you stated.

Your point about `cached_method_noargs` is a good one. However, removing the parentheses in all sage code might prove difficult to accomplish. But yes, I think people should prefer lazy attributes over cached_methods for performance. They are harder to document accessibly, however (the convention now seems to be that you can look up the descriptor on the type rather than the instance so rather than

compare:

```
sage: V.dim_as_cached_method?
//gives doc if it's a method
sage: V.dim_as_cached_method()
//gives the dimension
sage: V.dim_as_attribute?
//gives the doc of an integer object!
sage: V.dim_as_attribute
//because this is the dimension already
sage: type(V).dim_as_attribute?
//would give the doc
```

Can people get used to that? Only if we merge the ticket. I guess we should then.


---

Comment by nbruin created at 2013-05-25 17:09:09

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2013-05-25 19:37:40

Replying to [comment:7 nbruin]:
> Replying to [comment:6 tscrim]:
> > Then should we expect this result in a speedup for creating parent objects?
> 
> No, not for creation. That's the trick of a _lazy_ attribute -- it doesn't incur a cost upon creation (instead it's sitting ready on the type (Parent in this case) to instantiate the attribute when required.

I was thinking of creating elements from parent objects, which I'd imagine does an attribute lookup of `_element_class`. But this would only receive a benefit for cdef parents. Anyways, I'm happy with the way this ticket is. Plus the patchbot says there's no real change in the startup time, and `lazy_attribute` is (typically) loaded/imported then.

> We could speed that up even further (at the cost of flexibility) by casting `instance` to `Parent` before fetching `__cached_method`. We'll then get a straight `C struct` access in cython instead of a `getattr`.

Probably best left to another ticket.

> > I think we should be merging (some version of) this ticket precisely for the reason you stated.
> 
> Your point about `cached_method_noargs` is a good one. However, removing the parentheses in all sage code might prove difficult to accomplish. But yes, I think people should prefer lazy attributes over cached_methods for performance. They are harder to document accessibly, however (the convention now seems to be that you can look up the descriptor on the type rather than the instance so rather than
> 
> compare:
> {{{
> sage: V.dim_as_cached_method?
> //gives doc if it's a method
> sage: V.dim_as_cached_method()
> //gives the dimension
> sage: V.dim_as_attribute?
> //gives the doc of an integer object!
> sage: V.dim_as_attribute
> //because this is the dimension already
> sage: type(V).dim_as_attribute?
> //would give the doc
> }}}
> Can people get used to that? Only if we merge the ticket. I guess we should then.

For the documentation, a good name and a good description in at the class level should be sufficient. (Although in some ways having it as an attribute makes it feel more mutable to me, but I don't want to really open that can of worms.)

Thanks for answering all my questions.


---

Comment by jdemeyer created at 2013-06-06 12:33:30

Resolution: fixed
