# Issue 16895: Perfect Matchings for Graphs

Issue created by migration from Trac.

Original creator: ayyer

Original creation time: 2014-10-11 12:43:15

CC:  tscrim vferay nthiery â€‹dperkinson ncohen

Keywords: perfect matchings, graphs

I would like to implement and use an efficient program for the calculation of perfect matchings (aka 1-factors) of graphs. I know that a class called `PerfectMatchings` has been created, but there does not seem to be any program there to compute perfect matchings of graphs. There also seem to be programs for computing matching polynomials of graphs, but the algorithms for it are very different.

I have written a simple program using induction, but I'm not sure where it should be placed (ie. combinat/ or graphs/). For now, I have placed the file "perfect_matchings.py" in the graphs/ directory, but we can move it somewhere else if needed. 

I need help with certain things since I am new to this.

1. Proper formatting, of course. (I can work on this by looking at other files, but I'll need some supervision.)

2. How do I make sure that tab-completion works? That is, if `G` is a graph, `G.perf<tab>` should auto-fill it?

3. Is it worth treating the output as a member of the `PerfectMatchings` class?


---

Comment by ayyer created at 2014-10-16 09:26:53

I'm stuck trying to fix (2) above. The function `perfect_matchings(G)` works perfectly if I attach the file, like so.


```
sage: G = graphs.GridGraph([3,2])
sage: attach("src/sage/graphs/perfect_matchings.py")
sage: perfect_matchings(G)
[[((1, 1), (2, 1)), ((1, 0), (2, 0)), ((0, 0), (0, 1))],
 [((2, 0), (2, 1)), ((1, 0), (1, 1)), ((0, 0), (0, 1))],
 [((2, 0), (2, 1)), ((0, 1), (1, 1)), ((0, 0), (1, 0))]]
```


But I get funny errors if I try to modify the file _src/sage/graphs/all.py_ in any reasonable way. For example, if I add the line `from sage.graphs.perfect_matchings import *`, I get the following strange error.

```
sage: perfect_matchings(G)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-2-a5bbd0fdbb1c> in <module>()
----> 1 perfect_matchings(G)

/opt/sage/sage-git/local/lib/python2.7/site-packages/sage/graphs/perfect_matchings.pyc in perfect_matchings(G)
     46     PP = []
     47     for h in N:
---> 48         H = copy(G)
     49         H.delete_vertices([g,h])
     50         P = perfect_matchings(H)

NameError: global name 'copy' is not defined
```


On the other hand, if I try `import sage.graphs.perfect_matchings`, I get

```
sage: perfect_matchings(G)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-2-a5bbd0fdbb1c> in <module>()
----> 1 perfect_matchings(G)

NameError: name 'perfect_matchings' is not defined
```

I have no idea what to do at this stage. Could someone help? Thanks a lot.


---

Comment by ncohen created at 2014-10-16 09:32:56

Hello !

You do not need fo create a new file for a function like that. Add it in `graph.py`, it will be easier.

About your bugs

1) When in the console 'copy' is automatically imported, but this is not the case in Sage code. You need either to import it before you use it with "from copy import copy" or else use the 'copy' methods defined on graphs, i.e. `H=G.copy()`

2) What you want to do is `from sage.graphs.perfect_matchings import perfect_matchings`. You want to import the function `perfect_matchings` defined in the module `sage.graphs.perfect_matchings`

Nathann


---

Comment by ayyer created at 2014-10-16 10:00:02

Thanks, Nathann. Your explanation was very helpful. The method works!

The only reason I created a new file because people like _vferay_ might feel it belongs naturally in the _combinat_ directory instead and it will be easier to move it around.

Unfortunately, tab completion still does not work.

Arvind


---

Comment by git created at 2014-10-16 10:01:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2014-10-16 10:15:06

Hello !

> Thanks, Nathann. Your explanation was very helpful. The method works!

Nice ! 

> The only reason I created a new file because people like _vferay_ might feel it belongs naturally in the _combinat_ directory instead and it will be easier to move it around.

A method which enumerates the perfect matchings of a graph is a graph method. You might be right if you think that all graphs belong to the combinat folder, but that's a different issue.

> Unfortunately, tab completion still does not work.

Do you mean `g.perfect_matching` ? If so, that would only work if `perfect_matching` is a graph method.

Nathann


---

Comment by ayyer created at 2014-10-16 11:59:29

> A method which enumerates the perfect matchings of a graph is a graph method. 

Okay, I can move this method to `graph.py` eventually.

> Do you mean `g.perfect_matching`? If so, that would only work if `perfect_matching` is a graph method.

But I thought that since it is the _graphs_ directory, it automatically becomes a graph method. How do I force it to be a graph method? Thanks.

Arvind


---

Comment by ncohen created at 2014-10-16 12:01:13

> But I thought that since it is the _graphs_ directory, it automatically becomes a graph method. How do I force it to be a graph method? Thanks.

By writing it in the `graph.py` file, next to all others, as a method of the `Graph` class.

Nathann


---

Comment by ayyer created at 2014-10-16 12:25:04

> By writing it in the graph.py file, next to all others, as a method of the Graph class.

Damn! I guess I'm forced to do that. But I'm curious. Is there no other (simple) way to include methods of a certain class in a different file?

Arvind


---

Comment by ncohen created at 2014-10-16 12:29:53

> Damn! I guess I'm forced to do that. But I'm curious. Is there no other (simple) way to include methods of a certain class in a different file?

There is. Open `graph.py` and look at the bottom of the file. That's where it happens.

Nathann


---

Comment by ayyer created at 2014-10-16 12:40:38

Got it! For now, I've kept it in a separate file because I want to eventually add more methods. Thanks a lot for your patient answers.

Arvind


---

Comment by git created at 2014-10-16 12:42:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ayyer created at 2014-10-19 17:21:11

Based on email exchanges with _nathann_ and _vferay_, I want to give an option for the output to be treated as an element of the class `PerfectMatchings` (point (3) in the ticket). So I was playing with forcing the conversion.

```
sage: G = graphs.Grid2dGraph(3,2)
sage: PM = G.perfect_matchings()
sage: PM
[[((1, 1), (2, 1)), ((1, 0), (2, 0)), ((0, 0), (0, 1))],
 [((2, 0), (2, 1)), ((1, 0), (1, 1)), ((0, 0), (0, 1))],
 [((2, 0), (2, 1)), ((0, 1), (1, 1)), ((0, 0), (1, 0))]]
```

However, this seems to give some funny errors. If I try to force each list to be an element of the class, I get

```
sage: [PerfectMatching(p) for p in PM]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-13-a4d340e78f6e> in <module>()
----> 1 [PerfectMatching(p) for p in PM]

/Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1282)()

/Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/combinat/perfect_matching.pyc in __classcall_private__(cls, p)
    182             if len(objects) < 2*len(data):
    183                 raise ValueError("%s is not a valid perfect matching:\n"
--> 184                                  "there are some repetitions" % p)
    185         # Second case: p is a permutation or a list of integers, we have to
    186         # check if it is a fix-point-free involution.

ValueError: [((1, 1), (2, 1)), ((1, 0), (2, 0)), ((0, 0), (0, 1))] is not a valid perfect matching:
there are some repetitions
```

If I first force it to be a tuple, I get another error

```
sage: [PerfectMatching(tuple(p)) for p in PM]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-12-a67059f6b75f> in <module>()
----> 1 [PerfectMatching(tuple(p)) for p in PM]

/Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1282)()

/Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/combinat/perfect_matching.pyc in __classcall_private__(cls, p)
    182             if len(objects) < 2*len(data):
    183                 raise ValueError("%s is not a valid perfect matching:\n"
--> 184                                  "there are some repetitions" % p)
    185         # Second case: p is a permutation or a list of integers, we have to
    186         # check if it is a fix-point-free involution.

TypeError: not all arguments converted during string formatting
```

Can someone take a look?


---

Comment by git created at 2014-10-19 17:32:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2014-10-19 18:22:36

You should respect [http://www.sagemath.org/doc/developer/coding_basics.html#headings-of-sage-library-code-files](http://www.sagemath.org/doc/developer/coding_basics.html#headings-of-sage-library-code-files) and [http://www.sagemath.org/doc/developer/coding_basics.html#documentation-strings](http://www.sagemath.org/doc/developer/coding_basics.html#documentation-strings)


---

Comment by vferay created at 2014-10-20 08:32:50

Replying to [comment:13 ayyer]:

> If I first force it to be a tuple, I get another error
> {{{
> sage: [PerfectMatching(tuple(p)) for p in PM]
> ---------------------------------------------------------------------------
> TypeError                                 Traceback (most recent call last)
> <ipython-input-12-a67059f6b75f> in <module>()
> ----> 1 [PerfectMatching(tuple(p)) for p in PM]
>
> /Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1282)()
>
> /Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/combinat/perfect_matching.pyc in __classcall_private__(cls, p)
>     182             if len(objects) < 2*len(data):
>     183                 raise ValueError("%s is not a valid perfect matching:\n"
> --> 184                                  "there are some repetitions" % p)
>     185         # Second case: p is a permutation or a list of integers, we have to
>     186         # check if it is a fix-point-free involution.
>
> TypeError: not all arguments converted during string formatting
> }}}
> Can someone take a look?
Hi Arvind,

the bug comes from the perfect matching library: when elements of the base set are themselves pairs of integers, the function 'flatten' goes too far... I guess that adding the optional argument 'max_level=1' to all 'flatten' functions in the PerfectMatching library should solve the problem.

Now the question is (perhaps for Nathan): should that be a separate post on the trac/patch ?

I have another question : for the moment, you return perfect matchings as a list of pairs. Mathematically, I think it is more logical to treat it as a set of sets (two perfect matchings which differ by a permutations of the pairs are equal). But perhaps turning it into a set in sage would imply unnecessary copies/tests, so I wonder what is the best choice...

Best,
Valentin


---

Comment by ncohen created at 2014-10-20 09:50:03

Hello !

> Now the question is (perhaps for Nathan): should that be a separate post on the trac/patch ?

It can be the same if you think that this patch will quickly be finished and reviewed, it can be an independent one otherwise. You are free to do whatever you like here !

> I have another question : for the moment, you return perfect matchings as a list of pairs. Mathematically, I think it is more logical to treat it as a set of sets (two perfect matchings which differ by a permutations of the pairs are equal). But perhaps turning it into a set in sage would imply unnecessary copies/tests, so I wonder what is the best choice...

Well, edges of a graph are pairs at the moment, so it would not be inconsistent with what we already do. I also prefer simple data structures, but several can be available if you like.

Nathann


---

Comment by ayyer created at 2014-10-20 16:33:48

Replying to [comment:15 jdemeyer]:
> You should respect [http://www.sagemath.org/doc/developer/coding_basics.html#headings-of-sage-library-code-files](http://www.sagemath.org/doc/developer/coding_basics.html#headings-of-sage-library-code-files) and [http://www.sagemath.org/doc/developer/coding_basics.html#documentation-strings](http://www.sagemath.org/doc/developer/coding_basics.html#documentation-strings)

Thanks for the links. As I explained in the ticket, I am a new contributor to Sage. I am happy to respect everyone and everything, but I am not quite clear on what the objection is. Since I cut-pasted this from an existing file, I assumed that I am following the proper protocols. Could you explain what I need to do in more precise terms?

If you mean that I need to add examples, I will certainly do that once I have more methods. Please note that the file is at a very rudimentary stage at this moment.


---

Comment by ayyer created at 2014-10-20 16:47:14

Replying to [comment:16 vferay]:
> the bug comes from the perfect matching library: when elements of the base set are themselves pairs of integers, the function 'flatten' goes too far... I guess that adding the optional argument 'max_level=1' to all 'flatten' functions in the PerfectMatching library should solve the problem.

Oh I see. Let me know if you want me to open a new ticket. I can review it too if you like.
 
> I have another question : for the moment, you return perfect matchings as a list of pairs. Mathematically, I think it is more logical to treat it as a set of sets (two perfect matchings which differ by a permutations of the pairs are equal). But perhaps turning it into a set in sage would imply unnecessary copies/tests, so I wonder what is the best choice...

I am more familiar with Maple, where I would have indeed treated the object as a set of sets. I also find it natural to think of undirected edges as sets and directed ones as lists, but that doesn't seem to be the system followed here. In my short time with Sage, I find lists to be easier to manipulate overall. 

Does the class `PerfectMatchings` treat the object as a set of sets? If so, the user can choose what he/she prefers, once I add the option.


---

Comment by git created at 2014-11-07 03:40:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-11-16 10:56:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2014-11-16 11:34:58

Hello !

I was thinking of this ticket again: instead of creating copies of the graph, it may be cheaper to remove the two vertices before calling the subprocedure, and to add them back when the subprocedure returns. Depends on the actual timings.

Nathann


---

Comment by ayyer created at 2014-11-22 05:06:30

Hi Nathann,

> I was thinking of this ticket again: instead of creating copies of the graph, it may be cheaper to remove the two vertices before calling the subprocedure, and to add them back when the subprocedure returns. Depends on the actual timings.

Here's what I tried. I replaced the three lines

```
H = G.copy()
H.delete_vertices([g,h])
P = perfect_matchings(H)
```

by the single line

```
P = perfect_matchings(G.delete_vertices([g,h]))
```

But that gives me the following error:

```
AttributeError                            Traceback (most recent call last)
<ipython-input-4-7551fac4dada> in <module>()
----> 1 G.perfect_matchings()

/Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/graphs/perfect_matchings.pyc in perfect_matchings(G)
     72 #        H = G.copy()
     73 #        H.delete_vertices([g,h])
---> 74         P = perfect_matchings(G.delete_vertices([g,h]))
     75         for p in P:
     76             p.append((g,h))

/Applications/Sage-6.2.app/Contents/Resources/sage/local/lib/python2.7/site-packages/sage/graphs/perfect_matchings.pyc in perfect_matchings(G)
     59     ValueError: there is no perfect matching for a graph with an odd number of vertices
     60     """
---> 61     n = G.num_verts()
     62 
     63     if n == 0:

AttributeError: 'NoneType' object has no attribute 'num_verts'
```


It looks like it treats `G.delete_vertices([g,h])` as a `NoneType` object. But on the sage command line, `G.delete_vertices([g,h])` actually returns the modified graph. How else can I do this without making a copy? Thanks!


---

Comment by ncohen created at 2014-11-22 05:13:24

Helloooooo !

Well, it is indeed because "delete vertices" modifies the graph in-place. You should:

1) Delete vertices from the graph
2) List its perfect matchings

In particular it is odd that you saw it return anything, as the code of `Graph.delete_vertices` does not even contain a return statement.

Nathann


---

Comment by ayyer created at 2014-11-22 05:27:59

> In particular it is odd that you saw it return anything, as the code of `Graph.delete_vertices` does not even contain a return statement.

Sorry, that was sloppy. I just meant that it `G.delete_vertices()` still leaves G as a graph with some vertices removed. If I set `H = G.delete_vertices()`, then H is of `NoneType`.

> Well, it is indeed because "delete vertices" modifies the graph in-place. You should:
> 
> 1) Delete vertices from the graph
> 2) List its perfect matchings

But since it modifies the graph in-place, I don't want to modify the original `G` since I am running a loop over all neighbours of the vertex `g` in `G` and calling the method recusively. I only want to "temporarily delete" vertices within the loop.

Arvind


---

Comment by ncohen created at 2014-11-22 05:33:17

Hello !

> But since it modifies the graph in-place, I don't want to modify the original `G` since I am running a loop over all neighbours of the vertex `g` in `G` and calling the method recusively. I only want to "temporarily delete" vertices within the loop.

This why the technique is to remove the vertices before calling the subfunction, and to add them back (with their edges) right after the subfunction call. This is a way to avoid having many copies of the whole graph, when all you need is -- as you say -- to have a temporarily smaller graph.

Nathann


---

Comment by ayyer created at 2014-11-22 06:24:09

> This why the technique is to remove the vertices before calling the subfunction, and to add them back (with their edges) right after the subfunction call. This is a way to avoid having many copies of the whole graph, when all you need is -- as you say -- to have a temporarily smaller graph.

Oh, I see now! You want me to create another function which will delete the vertices without creating a copy. Here's what I did, and it seems to work. It seems a bit long though...

```
P = perfect_matchings(Graph([e for e in G.edges() if e[0] != g and e[0] != h and e[1] != g and e[1] != h]))
```

Is this acceptable? It seems that if `G.delete_vertices()` returned the graph instead of removing it in-place, it would have been much easier to return the graph. I suppose there were good reasons for doing it this way. Oh well!

Arvind


---

Comment by ncohen created at 2014-11-22 14:47:43

Hello !

> Oh, I see now! You want me to create another function which will delete the vertices without creating a copy. Here's what I did, and it seems to work. It seems a bit long though...

Ahahah. Well, actually this code creates a copy too, you even call the graph constructor !

I was thinking of this code:

```
def matchings(G):
    if G.order() == 0:
	yield []
	return
    v = G.vertex_iterator().next()
    Nv = G.neighbors(v)
    G.delete_vertex(v)  
    for u in Nv:
	Nu = G.neighbors(u)
	G.delete_vertex(u)
        for partial_matching in matchings(G):
            partial_matching.append((u,v))
            yield partial_matching
        G.add_vertex(u) 
	G.add_edges((u,nu) for nu in Nu)
    G.add_vertex(v)
    G.add_edges((v,nv) for nv in Nv)

sage: abs(graphs.PetersenGraph().matching_polynomial()(0))
6
sage: len(list(matchings(graphs.PetersenGraph())))
6
sage: abs(graphs.ChvatalGraph().matching_polynomial()(0))
52
sage: len(list(matchings(graphs.ChvatalGraph())))
52
```


Note that it can be made more efficient by branching when it is not connected, which would lead to a check that all connected components are of even size, etc, etc...  But then it depends on the size of the graphs that are of interest to you, as those optimization can cost a lot on small instances.

Nathann


---

Comment by dcoudert created at 2021-09-05 17:09:30

Changing status from new to needs_review.


---

Comment by dcoudert created at 2021-09-05 17:09:30

An iterator of perfect matchings for graphs has been added with #20061. So we can close this ticket.

However, using the shape of the algorithm proposed in #comment:28, we are able to speed up the current method. So I'm opening #32475 for this improvement.


---

Comment by dcoudert created at 2021-09-05 17:12:13

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2021-09-10 04:50:10

Resolution: invalid
