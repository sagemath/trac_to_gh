# Issue 12443: sign(integer) is horribly slow

Issue created by migration from Trac.

Original creator: zimmerma

Original creation time: 2012-03-02 08:53:04

Assignee: AlexGhitza

CC:  jpflori was kcrisman robertwb

Noticed in Sage 4.8:

```

sage: a=-17
sage: %timeit s = sign(a)  
125 loops, best of 3: 757 µs per loop
sage: %timeit s = a//abs(a) 
625 loops, best of 3: 246 ns per loop
```

thus computing `sign(a)` with `a//abs(a)` is 3000 faster!!!


---

Comment by dsm created at 2012-03-02 20:08:53

The fall-through into constructing a ComplexIntervalField is expensive.  Maybe it makes sense to give the obvious suspects (ZZ, QQ, RR, etc.) a .sign() method.


---

Comment by kcrisman created at 2012-03-02 20:27:25

Try it out and see what the speedup is.  I'd be happy to review something like that.


---

Comment by dsm created at 2012-03-03 00:28:00

Hmmm.  Well, it helps, but you still lose a lot going from something(sign) to sign(something):


```
# unpatched
sage: %timeit s = sign(2)
5 loops, best of 3: 427 µs per loop
```



```
# with .sign() using mpz_sgn
sage: %timeit s = sign(2)
625 loops, best of 3: 47.4 µs per loop
sage: %timeit s = 2.sign()
625 loops, best of 3: 352 ns per loop

```


Function calls are slow. :-/


---

Comment by dsm created at 2012-03-03 00:35:52

Well, to be clear, it's not function call overhead itself, it's BuiltinFunction-related.


---

Comment by zimmerma created at 2012-03-05 17:01:32

regarding comment [comment:4], I don't understand since for `abs` we get similar
timings, and even abs(something) is faster:

```
sage: %timeit s = abs(2)
625 loops, best of 3: 201 ns per loop
sage: %timeit s = 2.abs() 
625 loops, best of 3: 456 ns per loop
```

Paul


---

Comment by zimmerma created at 2013-01-08 08:39:24

Robert, do you have a hint to solve this?

Paul


---

Comment by robertwb created at 2013-01-09 10:32:55

Attached a patch to add sign() methods to QQ and ZZ. The sign(x) function is still really slow because


```
sage: sign.__call__??
    def __call__(self, *args, coerce=True, hold=False):
        """
        Evaluates this function at the given arguments.
        
        We coerce the arguments into symbolic expressions if coerce=True, then
        call the Pynac evaluation method, which in turn passes the arguments to
        a custom automatic evaluation method if ``_eval_()`` is defined.
```


in other words, it creates SR(x) and a ginac representation of the call before finally calling x.sign(). Ugh, I've filed #13933.


---

Comment by robertwb created at 2013-01-09 10:32:55

Changing status from new to needs_review.


---

Comment by zimmerma created at 2013-01-10 09:12:06

Robert, thanks, I see a speedup of a factor of more than 10 on my example:

```
sage: a=-17
sage: %timeit s = sign(a)  
625 loops, best of 3: 41 µs per loop
sage: %timeit s = a//abs(a) 
625 loops, best of 3: 257 ns per loop
```


However I wonder about the need of the "pool" cache for integers in [-5,100], since the speedup is "only" about 20%:

```
sage: a=100                 
sage: %timeit s = sign(a)   
625 loops, best of 3: 34.7 µs per loop
sage: a=101                 
sage: %timeit s = sign(a)   
625 loops, best of 3: 41.5 µs per loop
```

Paul


---

Comment by zimmerma created at 2013-01-10 09:12:06

Changing status from needs_review to needs_info.


---

Comment by robertwb created at 2013-01-10 20:23:26

Oops, there was an error in this patch. Yeah, the pool doesn't make a big difference here, but it can be used more genrally as well so I think it's worth including.


---

Comment by robertwb created at 2013-01-10 20:23:26

Changing status from needs_info to needs_review.


---

Comment by robertwb created at 2013-01-10 20:28:34

I don't think that sign(x) can be made much faster than in #13933 (vs. abs, which is a builtin function), but a.sign() is *much* faster now. It also scales better :)


```
sage: a = 3^2^20       
sage: %timeit a//abs(a)
 625 loops, best of 3: 129 µs per loop
```



---

Comment by zimmerma created at 2013-01-11 09:07:42

good work, thanks Robert!

Paul


---

Comment by zimmerma created at 2013-01-11 09:07:42

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2013-01-11 09:37:57

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2013-01-11 09:37:57

Replying to [comment:10 robertwb]:
> Yeah, the pool doesn't make a big difference here, but it can be used more genrally as well so I think it's worth including.
Sorry, but allocating 103 integers just because somebody might possibly write a patch in the future to use them is silly.  For this patch, could we stick just with the integers that we actually use?  Your hypothetical futute patch can still enlarge the pool.


---

Comment by robertwb created at 2013-01-22 05:34:10

apply only this patch


---

Attachment

Replying to [comment:13 jdemeyer]:
> Replying to [comment:10 robertwb]:
> > Yeah, the pool doesn't make a big difference here, but it can be used more genrally as well so I think it's worth including.
> Sorry, but allocating 103 integers just because somebody might possibly write a patch in the future to use them is silly.  For this patch, could we stick just with the integers that we actually use?  Your hypothetical futute patch can still enlarge the pool.

Done.


---

Comment by robertwb created at 2013-01-22 05:34:59

Changing status from needs_work to needs_review.


---

Comment by robertwb created at 2013-01-22 06:27:53

See also #13981


---

Comment by zimmerma created at 2013-01-23 08:09:49

thank you Robert for the new patch.

Paul


---

Comment by zimmerma created at 2013-01-23 08:09:49

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2013-01-25 13:07:10

Resolution: fixed
