# Issue 29072: Exact Algorithm for Diameters of Large Real Directed Graphs

Issue created by migration from https://trac.sagemath.org/ticket/29309

Original creator: @tabus

Original creation time: 2020-03-10 11:51:12

Keywords: diameter

Adds an algorithm for computing the diameter of directed graphs as described in [https://doi.org/10.1007/978-3-319-20086-6_5](https://doi.org/10.1007/978-3-319-20086-6_5)


---

Comment by @tabus created at 2020-03-10 21:04:53

New commits:


---

Comment by @tabus created at 2020-03-10 21:04:53

Set assignee to @tabus.


---

Comment by dcoudert created at 2020-03-13 15:23:06

A few comments:
- please document your methods
- use standard notation `n` instead of `V`.
- you can use `UINT32_MAX`
- `range(g.neighbors[v+1]-g.neighbors[v+1])` unless I'm mistaken, this range is empty...
- you can use `bitset_first` and `bitset_next` to iterate over 1s of a bitset. See for instance [https://github.com/sagemath/sagelib/blob/master/sage/misc/bitset.pxi](https://github.com/sagemath/sagelib/blob/master/sage/misc/bitset.pxi)
- `Diferent graph` -> `Different graph`, although I don't understand this comment.


---

Comment by git created at 2020-03-13 22:23:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tabus created at 2020-03-13 23:43:16

Thank you so much for you input.

I have taken care of points 2, 3, 5 (I wasn't aware of the existence of a function like bitwise_next in O(1), thank you!).

Regarding the 6th point (sorry for the typo) the comment refers to the fact that the BFS should be done only on the SCC of the considered node with the inverted edges in order to obtain the backwards distance. Temporarily I had used the given graph because I was considering G as an undirected graph. The comment was only there to remind me to find and efficient way to perform the BFS on the desired graph.


---

Comment by git created at 2020-03-13 23:46:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tabus created at 2020-03-14 17:27:11

Replying to [comment:3 dcoudert]:
> A few comments:
> - please document your methods
> - use standard notation `n` instead of `V`.
> - you can use `UINT32_MAX`
> - `range(g.neighbors[v+1]-g.neighbors[v+1])` unless I'm mistaken, this range is empty...
> - you can use `bitset_first` and `bitset_next` to iterate over 1s of a bitset. See for instance [https://github.com/sagemath/sagelib/blob/master/sage/misc/bitset.pxi](https://github.com/sagemath/sagelib/blob/master/sage/misc/bitset.pxi)
> - `Diferent graph` -> `Different graph`, although I don't understand this comment.

About the 6th point as I commented before, the problem is that I have to consider the graph of reverse edges with vertices in the SCC. One way to do this is to create these graphs, however this seems be very inefficient. One solution I've though of is to create only the revere graph using init_revese, which is already implemented, and to run BFS adding only the vertices on the same SCC to the queue.

The current implementation of simple_BFS does not allow for this. However with a couple of very simple changes and adding an optional list of components to the arguments of the function it could. I am hesitant about this path because I would then have to fix all calls to this function.

Can I get your input on this one? Is it preferred not to mess with the arguments of already implemented functions? Perhaps I should just switch to another graph structure which allows for these operations although a bit less efficient?


---

Comment by git created at 2020-03-14 21:54:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tabus created at 2020-03-15 14:51:09

New commits:


---

Comment by git created at 2020-03-15 15:00:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-15 15:06:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tabus created at 2020-03-15 15:10:43

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2020-03-15 18:08:59

You must add doctests for your algorithms. Also, benchmarks would be welcome.


---

Comment by vdelecroix created at 2020-03-15 18:08:59

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-03-15 19:34:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tabus created at 2020-03-15 20:09:50

I have been experimenting and it seems this method is more efficient when the graph is sparse.
It should happen because the method creates a short_digraph with the reverse edges, something that iFUB does not have to do.

```
sage: G = DiGraph([[1,2]])
....: while not G.is_strongly_connected():
....:     G = digraphs.RandomDirectedGNP(1000, 0.2)
....: 
....: %time G.diameter(algorithm='TYY')
....: %time G.diameter()
....: 
CPU times: user 887 ms, sys: 11.9 ms, total: 899 ms
Wall time: 912 ms
2
CPU times: user 542 ms, sys: 2.96 ms, total: 545 ms
Wall time: 549 ms
2
sage: G = DiGraph([[1,2]])
....: while not G.is_strongly_connected():
....:     G = digraphs.RandomDirectedGNP(1000, 0.1)
....: 
....: %time G.diameter(algorithm='TYY')
....: %time G.diameter()
....: 
CPU times: user 77.5 ms, sys: 0 ns, total: 77.5 ms
Wall time: 78.5 ms
3
CPU times: user 314 ms, sys: 3.66 ms, total: 317 ms
Wall time: 320 ms
3
sage: G = DiGraph([[1,2]])
....: while not G.is_strongly_connected():
....:     G = digraphs.RandomDirectedGNP(1000, 0.01)
....: 
....: %time G.diameter(algorithm='TYY')
....: %time G.diameter()
....: 
CPU times: user 22.5 ms, sys: 0 ns, total: 22.5 ms
Wall time: 31.6 ms
6
CPU times: user 54.6 ms, sys: 196 µs, total: 54.8 ms
Wall time: 63.6 ms
6
sage: G = DiGraph([[1,2]])
....: while not G.is_strongly_connected():
....:     G = digraphs.RandomDirectedGNP(5000, 0.2)
....: 
....: %time G.diameter(algorithm='TYY')
....: %time G.diameter()
....: 
CPU times: user 1min 9s, sys: 218 ms, total: 1min 9s
Wall time: 1min 10s
2
CPU times: user 36.7 s, sys: 232 ms, total: 36.9 s
Wall time: 37.1 s
2
sage: G = DiGraph([[1,2]])
....: while not G.is_strongly_connected():
....:     G = digraphs.RandomDirectedGNP(5000, 0.1)
....: 
....: %time G.diameter(algorithm='TYY')
....: %time G.diameter()
....: 
CPU times: user 30.3 s, sys: 24.1 ms, total: 30.3 s
Wall time: 30.3 s
2
CPU times: user 16.4 s, sys: 64.1 ms, total: 16.4 s
Wall time: 16.4 s
2
sage: G = DiGraph([[1,2]])
....: while not G.is_strongly_connected():
....:     G = digraphs.RandomDirectedGNP(5000, 0.05)
....: 
....: %time G.diameter(algorithm='TYY')
....: %time G.diameter()
....: 
CPU times: user 665 ms, sys: 13 µs, total: 665 ms
Wall time: 665 ms
3
CPU times: user 7.59 s, sys: 4.04 ms, total: 7.6 s
Wall time: 7.6 s
3


---

Comment by git created at 2020-03-15 20:13:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tabus created at 2020-03-15 20:14:42

Changing status from needs_work to needs_review.


---

Comment by git created at 2020-03-16 18:10:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-03-17 19:34:44

FYI, #29346 also proposes an implementation of the same algorithm. Authors could join forces to get a better code.


---

Comment by @tabus created at 2020-03-24 00:12:59

Replying to [comment:19 dcoudert]:
> FYI, #29346 also proposes an implementation of the same algorithm. Authors could join forces to get a better code.
#29346 implements the same algorithm with the modified definition of diameter, where we consider the maximum finite eccentricities only. This seems counter intuitive to have different algorithms giving different answers


---

Comment by dcoudert created at 2020-03-24 10:01:23

May be with a proper documentation and an appropriate parameter, the same method could be used for both definitions, no?


---

Comment by @tabus created at 2020-03-24 10:51:45

Replying to [comment:21 dcoudert]:
> May be with a proper documentation and an appropriate parameter, the same method could be used for both definitions, no?
Absolutely, but in that case the implementation over at #29346 should be used, mine has a lot of simplifications due to the restriction to connected graphs


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by dcoudert created at 2020-06-20 07:22:14

red flag


---

Comment by dcoudert created at 2020-06-20 07:22:14

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.
