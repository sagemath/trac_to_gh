# Issue 31010: Forgetful Functor not working properly

Issue created by migration from https://trac.sagemath.org/ticket/31247

Original creator: @mjungmath

Original creation time: 2021-01-15 13:00:45

CC:  tscrim mkoeppe @tobiasdiez nthiery simonking hivert

We have currently the following bug:


```
sage: from sage.categories.functor import ForgetfulFunctor
sage: F = ForgetfulFunctor(Rings(), Sets())
sage: F(ZZ)
Integer Ring
```


The result should rather be:


```
sage: Set(ZZ)
Set of elements of Integer Ring
```



---

Comment by @mjungmath created at 2021-01-15 13:01:34

Digging into the source code, the forgetful functor `F` calls the following code from its class parent `Functor`:


```python
    def _apply_functor(self, x):
        """
        Apply the functor to an object of ``self``'s domain.

        NOTE:

        Each subclass of :class:`Functor` should overload this method. By default,
        this method coerces into the codomain, without checking whether the
        argument belongs to the domain.

        TESTS::

            sage: from sage.categories.functor import Functor
            sage: F = Functor(FiniteFields(),Fields())
            sage: F._apply_functor(ZZ)
            Rational Field

        """
        return self.__codomain(x)
```


Here, `__codomain` should be the destination category. However, the call function of a category is treated as some kind of coercion/conversion:


```python
    def __call__(self, x, *args, **opts):
        """
        Construct an object in this category from the data in ``x``,
        or throw ``TypeError`` or ``NotImplementedError``.

        If ``x`` is readily in ``self`` it is returned unchanged.
        Categories wishing to extend this minimal behavior should
        implement :meth:`._call_`.

        EXAMPLES::

            sage: Rings()(ZZ)
            Integer Ring
        """
        if x in self:
            return x
        return self._call_(x, *args, **opts)
```


as the following note in `sage/categories/sets_cat.py` indicates, too:


```python
    def _call_(self, X, enumerated_set=False):
        r"""
        Construct an object in this category from the data ``X``.

        INPUT:

        - ``X`` -- an object to be converted into a set

        - ``enumerated_set`` -- if set to ``True`` and the input is either a
          Python tuple or a Python list then the output will be a finite
          enumerated set.

        EXAMPLES::

            sage: Sets()(ZZ)
            Integer Ring
            sage: Sets()([1, 2, 3])
            {1, 2, 3}

            sage: S = Sets()([1, 2, 3]); S.category()
            Category of finite sets
            sage: S = Sets()([1, 2, 3], enumerated_set=True); S.category()
            Category of facade finite enumerated sets

        .. NOTE::

           Using ``Sets()(A)`` used to implement some sort of forgetful functor
           into the ``Sets()`` category. This feature has been removed, because
           it was not consistent with the semantic of :meth:`Category.__call__`.
           Proper forgetful functors will eventually be implemented, with
           another syntax.
        """
        if enumerated_set and type(X) in (tuple, list, range):
            from sage.categories.enumerated_sets import EnumeratedSets
            return EnumeratedSets()(X)
        from sage.sets.set import Set
        return Set(X)
```


_Proper forgetful functors will eventually be implemented, with another syntax._ It seems, this hasn't been done so far.


---

Comment by @mjungmath created at 2021-01-15 13:05:47

One could try the following: overload `_apply_functor` for forgetful functors and call `_call_` directly. That would be a minimal solution, but I am not sure whether it is the most elegant.


---

Comment by tscrim created at 2021-01-17 02:19:22

I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class. I think if you want to change your object, you should call the explicit constructor rather than relying on a functor. Moreover, if it is not going to be the current behavior, then I think you're asking for a solution to an impossible problem.


---

Comment by @mjungmath created at 2021-01-17 09:21:19

Replying to [comment:4 tscrim]:
> I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.

Then, the same would hold for manifolds in #31241. Differentiable manifolds are also in the category of topological manifolds (or at least should be). But we already agreed that it's a bug there. What is the difference then?

> I think if you want to change your object, you should call the explicit constructor rather than relying on a functor. Moreover, if it is not going to be the current behavior, then I think you're asking for a solution to an impossible problem.

Well, the forgetful functor has the purpose to forget imposed structures, and see the object as an object in the super category only. This condition is currently not met:


```
sage: from sage.categories.functor import ForgetfulFunctor 
....: F = ForgetfulFunctor(Rings(), Sets()) 
....: F(ZZ).category()                                                    
Join of Category of euclidean domains and Category of infinite enumerated sets and Category of metric spaces
sage: F(ZZ)(1) + F(ZZ)(2)                                                       
3
```


Usual set operations are not even compatible:


```
sage: Set([1,2,3]).union(F(ZZ))                                                    
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: X (=Integer Ring) must be a Set
```



Of course, different structures need different implementations.

For manifolds, the current stage of behavior is rather bad. Differentiable manifolds can be seen as topological manifolds, however each differentiable manifold comes with a differentiable structure which Sage keeps implicitly track of. This must be dropped after the forgetful functor had been applied. But with the above behavior, this is not possible because the original instance would be returned.


---

Comment by mkoeppe created at 2021-03-24 02:04:25

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-04 05:18:41

Another example:

```
sage: R.<x> = QQ[]
sage: phi = R.hom([x^2]); phi
Ring endomorphism of Univariate Polynomial Ring in x over Rational Field
  Defn: x |--> x^2
sage: phi.category_for()
Join of Category of euclidean domains and Category of commutative algebras over (number fields and quotient fields and metric spaces) and Category of infinite sets
sage: F = ForgetfulFunctor(Rings(), Sets())
sage: F(phi)
Ring endomorphism of Univariate Polynomial Ring in x over Rational Field
  Defn: x |--> x^2
```

I hoped to compute the correct category of an image in #32121 (Replace `MapCombinatorialClass`, add methods `Map.image`, `Map.pushforward`)...


---

Comment by tscrim created at 2021-07-04 12:40:19

This in and of itself is not a bug IMO as per comment:4. However, what is a bug IMO is that

```
sage: F(phi).parent()
Set of Homomorphisms from Univariate Polynomial Ring in x over Rational Field
 to Univariate Polynomial Ring in x over Rational Field
```

which leads to this

```
sage: F(phi).category_for()
Join of Category of euclidean domains
 and Category of commutative algebras over (number fields and quotient fields and metric spaces)
 and Category of infinite sets
```

For morphisms, where the category is part of the homset constructor, we can create the new homset parent and then convert the morphism into that parent. Mostly this just consists of rebuilding the same object but with a different parent. This is meaningful when we want to compose maps (as opposed to manipulating sets).


---

Comment by mkoeppe created at 2022-08-17 18:22:28

Replying to [comment:4 tscrim]:
> I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.

Mathematically one would, of course, say that the forgetful functor should act like the identity on a parent.

But our parents are equipped with a distinguished category.

So the forgetful functor needs to construct a new parent in which the distinguished category is replaced by the codomain.


---

Comment by tscrim created at 2022-08-18 07:57:02

Replying to [comment:14 mkoeppe]:
> Replying to [comment:4 tscrim]:
> > I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.
> 
> Mathematically one would, of course, say that the forgetful functor should act like the identity on a parent.

That strongly depends on how mathematically precise you want to connect a parent to its mathematical model. Strictly speaking, `ZZ` is just a set, but the ring of integers is really `(ZZ, +, *)` with distinguished binary operations `+: ZZ x ZZ -> ZZ` and `*: ZZ x ZZ -> ZZ`. However, the "ring" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. However, if you never add or multiply the elements together, then `1` is just an element of the set `ZZ`.

> But our parents are equipped with a distinguished category.

I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."

> So the forgetful functor needs to construct a new parent in which the distinguished category is replaced by the codomain.

I still contest that the set of objects is still the set of objects. Equality is not always the mathematical equality you are thinking of (which we actually often think of as being "isomorphic to").

Even allowing that we wanted a new parent, this would be an impossible problem to solve as we would either have to have a class for the forgetful functor for each category (a huge number) or we would need to know which methods to remove (any parent can implement their own custom version or ones that only make sense in category `C'` not its super category `C`).

If the user wants to do equality as some other type of object, then we should tell the user to build other type. For example, `Set(ZZ)` to do equality as a `Set` object.

Morphisms already have a hook for specifying the category. This might not be fully implemented, but if we wanted to consider the isomorphism `x |-> 2x` of *Q* as a *Q*-vector space, but it doesn't make sense as a ring morphism. The forgetful functor should change the category of the morphism.


---

Comment by mkoeppe created at 2022-08-18 15:12:21

Replying to [comment:16 tscrim]:
> Even allowing that we wanted a new parent, this would be an impossible problem to solve as we would either have to have a class for the forgetful functor for each category (a huge number) or we would need to know which methods to remove (any parent can implement their own custom version or ones that only make sense in category `C'` not its super category `C`).

I agree that it is impossible to solve in general. 

That should not stop us from implementing it for useful cases. In #34384, I implement it for `codomain=Sets()`.

There's warnings for the rest. We could also raise a `NotImplementedError`.


---

Comment by mkoeppe created at 2022-08-18 15:43:57

Replying to [comment:16 tscrim]:
> Replying to [comment:14 mkoeppe]:
> > our parents are equipped with a distinguished category.

... namely, what the method `category()` returns.

> I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."

... this is ill-defined or tautological


---

Comment by mkoeppe created at 2022-08-18 15:53:57

Replying to [comment:16 tscrim]:
> the "ring" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. 

This distinction is irrelevant because the parent `ZZ` is also equipped with a distinguished element class.


---

Comment by tscrim created at 2022-08-19 05:36:14

Replying to [comment:18 mkoeppe]:
> Replying to [comment:16 tscrim]:
> > Replying to [comment:14 mkoeppe]:
> > > our parents are equipped with a distinguished category.
> 
> ... namely, what the method `category()` returns.

That in no way means that any parent is specifically meant to be associated with that category and no other. If that was true, there would be absolutely no reason to have a `category` option to `Hom`.

> > I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."
> 
> ... this is ill-defined or tautological

No and no. It is well-defined based upon what is implemented. It is not tautological because, e.g., `ZZ` is also in `Sets()`. Furthermore, saying it is tautological makes no sense because then any definition involving "the smallest" would be tautological.


---

Comment by tscrim created at 2022-08-19 05:37:48

Replying to [comment:19 mkoeppe]:
> Replying to [comment:16 tscrim]:
> > the "ring" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. 
> 
> This distinction is irrelevant because the parent `ZZ` is also equipped with a distinguished element class.

In this case, but broadly within Sage, that is completely false. We have many things that have multiple types of element classes. Most (all?) of them are homsets. We don't (yet) have a good system to handle these parents.


---

Comment by mkoeppe created at 2022-08-19 05:47:12

Replying to [comment:21 tscrim]:
> We have many things that have multiple types of element classes. Most (all?) of them are homsets.

The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.


---

Comment by tscrim created at 2022-08-19 05:48:35

Replying to [comment:22 mkoeppe]:
> Replying to [comment:21 tscrim]:
> > We have many things that have multiple types of element classes. Most (all?) of them are homsets.
> 
> The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.

You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.


---

Comment by mkoeppe created at 2022-08-19 05:50:59

Replying to [comment:20 tscrim]:
> Replying to [comment:18 mkoeppe]:
> > Replying to [comment:16 tscrim]:
> > > Replying to [comment:14 mkoeppe]:
> > > > our parents are equipped with a distinguished category.
> > 
> > ... namely, what the method `category()` returns.
> 
> That in no way means that any parent is specifically meant to be associated with that category and no other.

That's not what "distinguished" means.


---

Comment by tscrim created at 2022-08-19 05:53:12

Replying to [comment:24 mkoeppe]:
> Replying to [comment:20 tscrim]:
> > Replying to [comment:18 mkoeppe]:
> > > Replying to [comment:16 tscrim]:
> > > > Replying to [comment:14 mkoeppe]:
> > > > > our parents are equipped with a distinguished category.
> > > 
> > > ... namely, what the method `category()` returns.
> > 
> > That in no way means that any parent is specifically meant to be associated with that category and no other.
> 
> That's not what "distinguished" means.

If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.


---

Comment by mkoeppe created at 2022-08-19 05:58:08

Replying to [comment:23 tscrim]:
> Replying to [comment:22 mkoeppe]:
> > Replying to [comment:21 tscrim]:
> > > We have many things that have multiple types of element classes. Most (all?) of them are homsets.
> > 
> > The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.
> 
> You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.

Whether you have just one element class or multiple element classes -- the parent is still equipped with the *list* of the element classes that can be used with it. 

And therefore, once more, the distinction of whether the operations are carried in the parent or in the elements is irrelevant.


---

Comment by mkoeppe created at 2022-08-19 06:08:26

Replying to [comment:20 tscrim]:
> Replying to [comment:18 mkoeppe]:
> > Replying to [comment:16 tscrim]:
> > > I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."

By smallest, do you mean largest?


---

Comment by mkoeppe created at 2022-08-19 06:10:38

What's ill-defined is the expression "makes sense to belong to".


---

Comment by tscrim created at 2022-08-19 06:11:49

Replying to [comment:26 mkoeppe]:
> Replying to [comment:23 tscrim]:
> > Replying to [comment:22 mkoeppe]:
> > > Replying to [comment:21 tscrim]:
> > > > We have many things that have multiple types of element classes. Most (all?) of them are homsets.
> > > 
> > > The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.
> > 
> > You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.
> 
> Whether you have just one element class or multiple element classes -- the parent is still equipped with the *list* of the element classes that can be used with it. 
> 
> And therefore, once more, the distinction of whether the operations are carried in the parent or in the elements is irrelevant.

It is quite important because you care about the extra structure placed on top of `ZZ` the set. The parent never models the ring operations because they are invoked with, e.g., `__add__` and `__mul__`. It might carry the implementation, but you need to construct elements to do the multiplication of elements. If you do not do any `+` or `*` operations on the elements, you have a set.

Now you are probably going to try and counter with something along the lines of "but equality as rings is different". However, Python/programming equality `==` does not have to be the same as mathematical equality. For example, does `2 == 4 / 2`? I could say no because the `QQ` representation is different (provided I don't normalize). So you could have *ZZ* with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.


---

Comment by mkoeppe created at 2022-08-19 06:12:19

Replying to [comment:25 tscrim]:
> Replying to [comment:24 mkoeppe]:
> > Replying to [comment:20 tscrim]:
> > > Replying to [comment:18 mkoeppe]:
> > > > Replying to [comment:16 tscrim]:
> > > > > Replying to [comment:14 mkoeppe]:
> > > > > > our parents are equipped with a distinguished category.
> > > > 
> > > > ... namely, what the method `category()` returns.
> > > 
> > > That in no way means that any parent is specifically meant to be associated with that category and no other.
> > 
> > That's not what "distinguished" means.
> 
> If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.

Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).


---

Comment by tscrim created at 2022-08-19 06:13:19

Replying to [comment:27 mkoeppe]:
> Replying to [comment:20 tscrim]:
> > Replying to [comment:18 mkoeppe]:
> > > Replying to [comment:16 tscrim]:
> > > > I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."
> 
> By smallest, do you mean largest?

I mean in smallest the sense of super/sub categories as we have defined the terminology in Sage, which is backwards of how we like to think of with forgetful functors.


---

Comment by tscrim created at 2022-08-19 06:14:14

Replying to [comment:28 mkoeppe]:
> What's ill-defined is the expression "makes sense to belong to".

The implementation with the methods required by the category.


---

Comment by mkoeppe created at 2022-08-19 06:16:09

This is exactly what makes it tautological. The category returned `category()` defines exactly those methods that have been mixed into the parent.


---

Comment by tscrim created at 2022-08-19 06:16:26

Replying to [comment:30 mkoeppe]:
> Replying to [comment:25 tscrim]:
> > Replying to [comment:24 mkoeppe]:
> > > Replying to [comment:20 tscrim]:
> > > > Replying to [comment:18 mkoeppe]:
> > > > > Replying to [comment:16 tscrim]:
> > > > > > Replying to [comment:14 mkoeppe]:
> > > > > > > our parents are equipped with a distinguished category.
> > > > > 
> > > > > ... namely, what the method `category()` returns.
> > > > 
> > > > That in no way means that any parent is specifically meant to be associated with that category and no other.
> > > 
> > > That's not what "distinguished" means.
> > 
> > If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.
> 
> Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).

However those are just default implementations to reduce code duplication. There are some methods that are ambiguous, the biggest one I can think of is `gens()`, which is why we are now advocating for `*_generators()`.


---

Comment by tscrim created at 2022-08-19 06:18:22

Replying to [comment:33 mkoeppe]:
> This is exactly what makes it tautological. The category returned `category()` defines exactly those methods that have been mixed into the parent.

If you don't want to consider your object in that category, then you don't call any of those methods. Neither do the methods say what category it belongs to. I could implement `ZZ` as a set with an operation `coproduct` that could have nothing to do with bialgebras. That doesn't mean it should be treated as a bialgebra.


---

Comment by mkoeppe created at 2022-08-19 06:21:47

Replying to [comment:29 tscrim]:
> something along the lines of "but equality as rings is different". 

Yes, because equality as XYZ is a statement about maps in the category XYZ.

Which is why the forgetful functor when applied to a parent with a distinguished category needs to return a parent with the changed category.

Completely unrelated to the "equality of representations" issues that you talked about.


---

Comment by mkoeppe created at 2022-08-19 06:29:08

Replying to [comment:29 tscrim]:
> So you could have *ZZ* with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.

Yes, `Set(...)` is the forgetful functor, sending the parent with a distinguished category `C` to a parent whose distinguished category is a full subcategory of `Sets()`.

#34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all


---

Comment by mkoeppe created at 2022-08-19 06:31:32

Replying to [comment:35 tscrim]:
> If you don't want to consider your object in that category, then you don't call any of those methods. Neither do the methods say what category it belongs to.

Exactly, we declare a distinguished category when we call `Parent(..., category=...)` -- because it would be ill-defined to guess it from the defined methods.


---

Comment by mkoeppe created at 2022-08-19 06:35:20

Replying to [comment:34 tscrim]:
> Replying to [comment:30 mkoeppe]:
> > Replying to [comment:25 tscrim]:
> > > If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.
> > 
> > Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).
> 
> However those are just default implementations to reduce code duplication. 

Hardly. It defines and specifies the required methods and even provides tests for these specifications.


---

Comment by tscrim created at 2022-08-19 06:36:42

Replying to [comment:36 mkoeppe]:
> Replying to [comment:29 tscrim]:
> > something along the lines of "but equality as rings is different". 
> 
> Yes, because equality as XYZ is a statement about maps in the category XYZ.

Isomorphism is not equality. It is very important not to confuse the two. As soon as you start talking about maps, you are talking isomorphism. In fact, I don't think many category theorists even talk about equality (everything is up to isomorphism).

In fact, that is exactly my point, the forgetful functor is about _maps_, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.

> Which is why the forgetful functor when applied to a parent with a distinguished category needs to return a parent with the changed category.

Changing the implementation is not a mathematical operation. It is a programming one. This further reinforces that we should be talking about Python `==`, not mathematical equality. The distinguished category has nothing to do with its mathematical equality statement.

> Completely unrelated to the "equality of representations" issues that you talked about.

So `==` should always be mathematical equality, in some definition that you have not made precise? What about the cases when we want this isomorphic to (this occurs in permutation groups) or when no canonical representative exists (e.g., elements in the symbolic ring or for manifolds). We could go for this, but then should we remove code that doesn't comply or things that do not have canonical representatives? If we allow `==` for non-canoical representatives, then what makes those cases special compared to these parents?


---

Comment by tscrim created at 2022-08-19 06:39:55

Replying to [comment:37 mkoeppe]:
> Replying to [comment:29 tscrim]:
> > So you could have *ZZ* with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.
> 
> Yes, `Set(...)` is the forgetful functor, sending the parent with a distinguished category `C` to a parent whose distinguished category is a full subcategory of `Sets()`.

I can agree with this statement.

> #34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all

We can do this, but that is just some semmantic sugar with making `Set()` a distinguished object in the category `Sets()` for the `ForgetfulFunctor()`. I have no objections. What I do have a strong objection to is saying if it did not do that, then it is a bug.


---

Comment by tscrim created at 2022-08-19 06:42:52

Replying to [comment:39 mkoeppe]:
> Replying to [comment:34 tscrim]:
> > Replying to [comment:30 mkoeppe]:
> > > Replying to [comment:25 tscrim]:
> > > > If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.
> > > 
> > > Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).
> > 
> > However those are just default implementations to reduce code duplication. 
> 
> Hardly. It defines and specifies the required methods and even provides tests for these specifications.

Yes, you're right here. They do provide specifications for those methods. However, they do also (generally) need to be consistent with things in the super categories because those `ParentMethods` will become superclasses. Good programming means we are _generally_ consistent here, but there can be good reason to break that.


---

Comment by mkoeppe created at 2022-08-19 06:48:02

Replying to [comment:40 tscrim]:
> the forgetful functor is about _maps_, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.

But the objects have a distinguished homset (which is determined by the distinguished category).


---

Comment by mkoeppe created at 2022-08-19 06:49:27

Replying to [comment:40 tscrim]:
> Replying to [comment:36 mkoeppe]:
> > Replying to [comment:29 tscrim]:
> > > something along the lines of "but equality as rings is different". 
> > 
> > Yes, because equality as XYZ is a statement about maps in the category XYZ.

... namely the identity map.


---

Comment by mkoeppe created at 2022-08-19 06:51:51

Replying to [comment:40 tscrim]:
> > Completely unrelated to the "equality of representations" issues that you talked about.
> 
> So `==` should always be mathematical equality, in some definition that you have not made precise?

The coercion system is in charge of this, it defines (up to implementation restrictions and bugs) our model of "equality". 

No changes to it are necessary, nor do I propose changes to it.


---

Comment by tscrim created at 2022-08-19 06:54:52

Replying to [comment:43 mkoeppe]:
> Replying to [comment:40 tscrim]:
> > the forgetful functor is about _maps_, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.
> 
> But the objects have a distinguished homset (which is determined by the distinguished category).

No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:

```
sage: Hom(QQ, ZZ)
Set of Homomorphisms from Rational Field to Integer Ring
sage: Hom(QQ, ZZ, category=Sets())
Set of Morphisms from Rational Field to Integer Ring in Category of sets
```



---

Comment by mkoeppe created at 2022-08-19 06:56:08

Replying to [comment:41 tscrim]:
> > #34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all
> 
> We can do this, but that is just some semantic sugar 

... that's a new one, yes, functors do provide semantic sugar which enables composability.


---

Comment by mkoeppe created at 2022-08-19 06:57:38

Replying to [comment:46 tscrim]:
> Replying to [comment:43 mkoeppe]:
> > But the objects have a distinguished homset (which is determined by the distinguished category).
> 
> No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:
> {{{
> sage: Hom(QQ, ZZ)
> Set of Homomorphisms from Rational Field to Integer Ring
> }}}

Here the distinguished category determined the default.


---

Comment by tscrim created at 2022-08-19 06:59:33

Replying to [comment:45 mkoeppe]:
> Replying to [comment:40 tscrim]:
> > > Completely unrelated to the "equality of representations" issues that you talked about.
> > 
> > So `==` should always be mathematical equality, in some definition that you have not made precise?
> 
> The coercion system is in charge of this, it defines (up to implementation restrictions and bugs) our model of "equality". 

Not for elements of the same parent or between different parents.

> No changes to it are necessary, nor do I propose changes to it.

You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).

If I have a new ring structure on *Z*, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set, but you are saying it is a bug.


---

Comment by mkoeppe created at 2022-08-19 07:02:52

Replying to [comment:49 tscrim]:
> You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).

Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254


---

Comment by tscrim created at 2022-08-19 07:10:26

Replying to [comment:48 mkoeppe]:
> Replying to [comment:46 tscrim]:
> > Replying to [comment:43 mkoeppe]:
> > > But the objects have a distinguished homset (which is determined by the distinguished category).
> > 
> > No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:
> > {{{
> > sage: Hom(QQ, ZZ)
> > Set of Homomorphisms from Rational Field to Integer Ring
> > }}}
> 
> Here the distinguished category determined the default.

Mathematically, any homset should also take the category as input. We just usually suppress it from notion as context determines, just like what is done here. Now I will concede that applying the forgetful functor should make it clear what category we want to do it in, but that is just breaking the syntactic (semantic?) sugar. You would rather try to solve an impossible problem than simply telling the user to type fewer characters with a more intuitive semantic?


---

Comment by mkoeppe created at 2022-08-19 07:11:07

Replying to [comment:49 tscrim]:
> If I have a new ring structure on *Z*, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set

I wouldn't say that it's fine and proper; I'd say there is an implementation restriction that stops us from detecting that they are equal. Sage is of course full of such implementation restrictions. 

A proper implementation of the forgetful functor will improve this situation: It removes the implementation restriction.


---

Comment by mkoeppe created at 2022-08-19 07:14:05

Replying to [comment:51 tscrim]:
> Now I will concede that applying the forgetful functor should make it clear what category we want to do it in

Yes, in particular because after applying it, the distinguished category has changed. We can just call the method `.category()` if we want to know it.


---

Comment by tscrim created at 2022-08-19 07:14:20

Replying to [comment:50 mkoeppe]:
> Replying to [comment:49 tscrim]:
> > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).
> 
> Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254

This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.


---

Comment by mkoeppe created at 2022-08-19 07:16:46

Replying to [comment:54 tscrim]:
> Replying to [comment:50 mkoeppe]:
> > Replying to [comment:49 tscrim]:
> > > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).
> > 
> > Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254
> 
> This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.

The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.


---

Comment by tscrim created at 2022-08-19 07:21:57

Replying to [comment:52 mkoeppe]:
> Replying to [comment:49 tscrim]:
> > If I have a new ring structure on *Z*, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set
> 
> I wouldn't say that it's fine and proper; I'd say there is an implementation restriction that stops us from detecting that they are equal. Sage is of course full of such implementation restrictions. 

Then the fact that two "equal" things are not equal is not a bug. Hence, the fact that forgetful functor does not necessarily return a new object, which could lead to a different `==` implementation, is not a bug.

> A proper implementation of the forgetful functor will improve this situation: It removes the implementation restriction.

No it does not. If you want `==` as instances of `Set`, you should explicitly make your objects instances of `Set`. It doesn't matter what the category an object belongs to. The implementation is what carries the meaning of `==`. Let the category decide what it wants to do with `__call__`. That is what the forgetful functor does.


---

Comment by tscrim created at 2022-08-19 07:23:37

Replying to [comment:55 mkoeppe]:
> Replying to [comment:54 tscrim]:
> > Replying to [comment:50 mkoeppe]:
> > > Replying to [comment:49 tscrim]:
> > > > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).
> > > 
> > > Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254
> > 
> > This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.
> 
> The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.

Coercion is not involved:

```python
    Category.__call__(self, x, *args, **opts):
        if x in self:
            return x
        return self._call_(x, *args, **opts)
```



---

Comment by mkoeppe created at 2022-08-19 07:26:32

Replying to [comment:57 tscrim]:
> > The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.
> 
> Coercion is not involved:
> {{{#!python
>     Category.__call__(self, x, *args, **opts):
>         if x in self:
>             return x
>         return self._call_(x, *args, **opts)
> }}}

The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.


---

Comment by tscrim created at 2022-08-19 07:30:48

Replying to [comment:58 mkoeppe]:
> Replying to [comment:57 tscrim]:
> > > The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.
> > 
> > Coercion is not involved:
> > {{{#!python
> >     Category.__call__(self, x, *args, **opts):
> >         if x in self:
> >             return x
> >         return self._call_(x, *args, **opts)
> > }}}
> 
> The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.

The coercion system is not mentioned in the note or in any of the relevant code.

The documentation of `Category__call__` even specifies:

```
        If ``x`` is readily in ``self`` it is returned unchanged.
        Categories wishing to extend this minimal behavior should
        implement :meth:`._call_`.
```

This is further direct documentation evidence that even categories do not want to change objects of subcategories. This is not a bug.


---

Comment by mkoeppe created at 2022-08-19 07:37:22

Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.


---

Comment by mkoeppe created at 2022-08-19 07:38:30

Replying to [comment:59 tscrim]:
> > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> 
> The coercion system is not mentioned in the note or in any of the relevant code.

Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.


---

Comment by tscrim created at 2022-08-19 07:42:07

Replying to [comment:60 mkoeppe]:
> Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.

Right, that is my point. The `ForgetfulFunctor` goes through that for objects. This was clearly the intended behaviour.


---

Comment by tscrim created at 2022-08-19 07:43:42

Replying to [comment:61 mkoeppe]:
> Replying to [comment:59 tscrim]:
> > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> > 
> > The coercion system is not mentioned in the note or in any of the relevant code.
> 
> Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.

This makes no sense to me. The coercion system, which only operates on _elements_, makes no requirements on the syntax nor semantics of `__call__`, much less for things that are not parents (as a way of creating elements).


---

Comment by mkoeppe created at 2022-08-19 07:48:41

Replying to [comment:62 tscrim]:
> Replying to [comment:60 mkoeppe]:
> > Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.
> 
> Right, that is my point. The `ForgetfulFunctor` goes through that for objects. This was clearly the intended behaviour.

No, the `ForgetfulFunctor` is just not fully implemented. 

It does not even have its own `_apply_functor` method, it is just taking the one from `Functor`.

And this code is from 2010, whereas the comment in `sets_cat.py` regarding the lack of "proper forgetful functors" is from 2015.


---

Comment by mkoeppe created at 2022-08-19 07:51:28

Replying to [comment:63 tscrim]:
> Replying to [comment:61 mkoeppe]:
> > Replying to [comment:59 tscrim]:
> > > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> > > 
> > > The coercion system is not mentioned in the note or in any of the relevant code.
> > 
> > Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.
> 
> This makes no sense to me. The coercion system, which only operates on _elements_ [...]

To me the "coercion system" includes the functorial constructions for parents etc. It won't be useful to discuss this terminology.


---

Comment by mkoeppe created at 2022-08-19 07:54:49

Replying to [comment:64 mkoeppe]:
> And this code is from 2010, whereas the comment in `sets_cat.py` regarding the lack of "proper forgetful functors" is from 2015.

I have to take this back, this was very superficial archeology


---

Comment by mkoeppe created at 2022-08-19 07:59:03

The relevant commit is 

```
commit 2187d6d8a9ab3ef08a83225c24107055ba3d43a4
Author: Florent Hivert <Florent.Hivert@univ-rouen.fr>
Date:   Sat Nov 27 19:39:43 2010 +0100

    #8925: add __call__ to categories Sets() and EnumeratedSets().
```



---

Comment by mkoeppe created at 2022-08-19 08:01:54

The `ForgetfulFunctor` predates that. It is from

```
commit d43bc53b7e73b54600ed8df563849dc7817d5d41
Author: Simon King <simon.king@nuigalway.ie>
Date:   Fri Apr 30 14:56:16 2010 +0100

    #8807: Implement induced ring homomorphisms. Extend the functor framework, so that functors can be applied to morphisms.
```

and earlier.


---

Comment by tscrim created at 2022-08-19 08:02:14

Replying to [comment:65 mkoeppe]:
> Replying to [comment:63 tscrim]:
> > Replying to [comment:61 mkoeppe]:
> > > Replying to [comment:59 tscrim]:
> > > > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> > > > 
> > > > The coercion system is not mentioned in the note or in any of the relevant code.
> > > 
> > > Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.
> > 
> > This makes no sense to me. The coercion system, which only operates on _elements_ [...]
> 
> To me the "coercion system" includes the functorial constructions for parents etc. It won't be useful to discuss this terminology.

The term "coercion system" has a clear set meaning within Sage. I agree the terminology you use is not important, but it will cause confusion if it conflicts with something else.

That being said, I don't think there are any set rules like the ones you are trying to invoke. All that is required is the output of any functor is some object that is in the category. Just like applying a morphism only requires that the result is an element the parent codomain, not that it needs to have a specific implementation. Sometimes this can cause some headaches, but those are the things the user needs to be wary of.


---

Comment by mkoeppe created at 2022-08-19 08:04:51

Replying to [comment:69 tscrim]:
> I don't think there are any set rules like the ones you are trying to invoke.

Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit? For reference again:

           Using `Sets()(A)` used to implement some sort of forgetful functor
           into the `Sets()` category. This feature has been removed, because
           it was not consistent with the semantic of `Category.__call__`.
           Proper forgetful functors will eventually be implemented, with
           another syntax.


---

Comment by mkoeppe created at 2022-08-19 08:08:18

And `Category.__call__` is unambiguous:

        If `x` is readily in `self` it is returned unchanged.
        Categories wishing to extend this minimal behavior should
        implement `_call_`.

"extending" this minimal behavior means to do more things when `x` is *not* in `self`.
(`Category._call_` just raises `NotImplementedError`.)


---

Comment by tscrim created at 2022-08-19 08:14:17

Replying to [comment:70 mkoeppe]:
> Replying to [comment:69 tscrim]:
> > I don't think there are any set rules like the ones you are trying to invoke.
> 
> Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?

I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`, where the codomain of the (forgetful) functor `F` is `Sets()`.

I agree fully with the first part; it was inconsistent. I don't know what Florent was intending by the word "proper" for the latter part; in particular the semantics on the result. However, I am very wary of changing current allowed behaviors (and definitions) in ways that says we should try to solve impossible problems with huge maintenance burdens in our code base.


---

Comment by mkoeppe created at 2022-08-19 08:19:45

Replying to [comment:72 tscrim]:
> try to solve impossible problems with huge maintenance burdens in our code base.

I have disputed this.


---

Comment by mkoeppe created at 2022-08-19 08:21:10

Replying to [comment:72 tscrim]:
> Replying to [comment:70 mkoeppe]:
> > Replying to [comment:69 tscrim]:
> > > I don't think there are any set rules like the ones you are trying to invoke.
> > 
> > Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?
> 
> I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`

But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.


---

Comment by mkoeppe created at 2022-08-19 08:22:20

Replying to [comment:72 tscrim]:
> I don't know what Florent was intending by the word "proper" for the latter part

You know, a functor that actually forgets something.


---

Comment by tscrim created at 2022-08-19 08:29:11

Replying to [comment:74 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > Replying to [comment:70 mkoeppe]:
> > > Replying to [comment:69 tscrim]:
> > > > I don't think there are any set rules like the ones you are trying to invoke.
> > > 
> > > Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?
> > 
> > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`
> 
> But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.

Not for the image of functors; that is only the `Category.__call__`. For the implementation of `ForgetfulFunctor`, it was chosen to just do the result of `Category.__call__`. In fact, the `NOTE:` in `Functor._apply_functor` indicates that subclasses are allowed to change the default behavior to suit their needs.


---

Comment by mkoeppe created at 2022-08-19 08:31:17

Replying to [comment:76 tscrim]:
> > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`
> > 
> > But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.
> 
> Not for the image of functors; that is only the `Category.__call__`.

Sorry, I misread what you wrote


---

Comment by mkoeppe created at 2022-08-19 08:40:47

Replying to [comment:72 tscrim]:
> I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 

I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).

Now an actually interesting question is what exactly the new distinguished category should be. It could be just the codomain of the functor, so for `ForgetfulFunctor(..., Sets())` it would be `Sets()`. However, another choice would be a suitable full subcategory of the codomain. This is what I have implemented in #34384.


---

Comment by mkoeppe created at 2022-08-19 08:45:23

it's time for another time zone to chime in


---

Comment by SimonKing created at 2022-08-19 09:39:36

I didn't have time to carefully read the whole discussion, yet. But concerning the discussion about "equality", here are 2 cents:

`2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings. IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).

The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).

And that would indeed be difficult to implement.


---

Comment by mkoeppe created at 2022-08-19 15:53:38

Replying to [comment:81 SimonKing]:
> `2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings. IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category).

I agree. I've opened #34390 for this


---

Comment by tscrim created at 2022-08-20 05:13:48

Replying to [comment:81 SimonKing]:
> I didn't have time to carefully read the whole discussion, yet. But concerning the discussion about "equality", here are 2 cents:
> 
> `2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings.

Of course it is true, but it is about do we require that it _must_ be true for _any_ different representations of the same element in some parent. This is just a very simple example where there can be multiple different ways of writing the same element. In this case, we know what a canonical representation is for fractions. However, this is not true for all objects (e.g., finitely presented groups).

> IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).

How would you deal with sets that are equal but with different implementations that do not have a conversion (much less a coercion) between them? Following your premise, this would be a bug, which would need to be fixed. To make this even more difficult, you would not want a coercion because the parents have fundamentally different structures. How do we fix this?

What about more abstract parents? Should all three dimensional free modules over a field `k` be equal since they all could be considered as `k`<sup>3</sup> (in particular, by the method `to_vector()` in `ModulesWithBasis()`)? How do we even want to decide?

> The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).
> 
> And that would indeed be difficult to implement.

I would say nearly impossible resulting in any ticket with a new feature would basically be introducing bugs. This is making the specification of `==` way too strict.


---

Comment by tscrim created at 2022-08-20 05:19:00

Replying to [comment:78 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 
> 
> I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).

You need to pick your definition of "distinguished" as you are going between "this is an object in this category" and "this category is just considered special to this object" when it suits you. If the category is just special, then no new object needs to be returned because it still is an object in that category.

> Now an actually interesting question is what exactly the new distinguished category should be. It could be just the codomain of the functor, so for `ForgetfulFunctor(..., Sets())` it would be `Sets()`. However, another choice would be a suitable full subcategory of the codomain. This is what I have implemented in #34384.

If we do this (which I continue to remain staunchy opposed to), it must be in the codomain `C`, e.g., `Sets`, not some full subcategory `C'`. Otherwise, strictly speaking, you could not build a natural homset to some other object in `C \ C'`.


---

Comment by tscrim created at 2022-08-20 05:20:09

Replying to [comment:75 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > I don't know what Florent was intending by the word "proper" for the latter part
> 
> You know, a functor that actually forgets something.

Yes, that is what it should do on the morphisms. _That_ is the only bug. Not on the objects.


---

Comment by tscrim created at 2022-08-20 05:24:41

Replying to [comment:73 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > try to solve impossible problems with huge maintenance burdens in our code base.
> 
> I have disputed this.

No, you haven't. You haven't explained why we don't have to implement a new object for every image of every forgetful functor. Or why we don't have to deal with comparisons of elements in each of these new parents. Or why we don't have to make sure that every functor also always returns an object with a distinguished category of the codomain. Or how you will deal with these backwards incompatible changes.


---

Comment by mkoeppe created at 2022-08-20 05:48:55

Sorry, Travis, "you have to implement everything or you are not allowed to implement anything" is a pretty absurd take.


---

Comment by mkoeppe created at 2022-08-20 05:54:31

Replying to [comment:87 tscrim]:
> Or how you will deal with these backwards incompatible changes.

See comment:67, comment:68. `ForgetfulFunctor` was broken in 2010, it has not been forgetting anything since. So I don't think there is a need to worry about scary backwards incompatible changes.


---

Comment by tscrim created at 2022-08-20 05:56:06

I am explaining the maintenance burden you are placing on us by making this change of specification. It's like saying "I don't like how these cars look, so I am going to completely rewrite the traffic laws but not tell you how to comply with them."


---

Comment by mkoeppe created at 2022-08-20 05:57:23

Replying to [comment:85 tscrim]:
> Replying to [comment:78 mkoeppe]:
> > Replying to [comment:72 tscrim]:
> > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 
> > 
> > I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).
> 
> You need to pick your definition of "distinguished" as you are going between "this is an object in this category" and "this category is just considered special to this object" when it suits you.

No, Travis, I have been using my terminology consistently. The distinguished category is the one that `.category()` returns.


---

Comment by tscrim created at 2022-08-20 05:57:33

Replying to [comment:89 mkoeppe]:
> Replying to [comment:87 tscrim]:
> > Or how you will deal with these backwards incompatible changes.
> 
> See comment:67, comment:68. `ForgetfulFunctor` was broken in 2010, it has not been forgetting anything since. So I don't think there is a need to worry about scary backwards incompatible changes.

But they are not broken when acting on objects. You want to change the specifications to make it into a bug.


---

Comment by mkoeppe created at 2022-08-20 05:59:53

Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.


---

Comment by tscrim created at 2022-08-20 06:00:15

Replying to [comment:91 mkoeppe]:
> Replying to [comment:85 tscrim]:
> > Replying to [comment:78 mkoeppe]:
> > > Replying to [comment:72 tscrim]:
> > > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 
> > > 
> > > I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).
> > 
> > You need to pick your definition of "distinguished" as you are going between "this is an object in this category" and "this category is just considered special to this object" when it suits you.
> 
> No, Travis, I have been using my terminology consistently. The distinguished category is the one that `.category()` returns.

If it is just some category that has special meaning for the defaults for some inputs, then there is no bug here with `ForgetfulFunctor(ZZ, codomain=Sets())` returning `ZZ`. You don't have to remember about the structure that puts it into `Rings()`. Everything that depends on the category of the object, such as `Hom` has an input for the user to set the category.


---

Comment by tscrim created at 2022-08-20 06:03:58

Replying to [comment:93 mkoeppe]:
> Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.

Then should every getter method be part of the mathematical definition of the parent? Or every attribute? What makes the category one so special that we need some broad universal rule?

Basically, this leads us right into the absurd. A parent is not modeling this pair.


---

Comment by mkoeppe created at 2022-08-20 06:11:49

Replying to [comment:95 tscrim]:
> Replying to [comment:93 mkoeppe]:
> > Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.
> 
> A parent is not modeling this pair.

What do you mean by that?


---

Comment by tscrim created at 2022-08-20 06:16:08

Replying to [comment:96 mkoeppe]:
> Replying to [comment:95 tscrim]:
> > Replying to [comment:93 mkoeppe]:
> > > Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.
> > 
> > A parent is not modeling this pair.
> 
> What do you mean by that?

A parent is just modeling the set of elements. Nothing more, nothing less. It has some things associated to it, such as having a distinguished category, that tells you things you can do on it. However, it is just meant to be the set.


---

Comment by mkoeppe created at 2022-08-20 06:20:58

How do you "associate" something with a mathematical set?


---

Comment by tscrim created at 2022-08-20 06:26:42

Mathematically, you make a new object as a tuple. However, we are not manipulating such objects. Programmatically, we have attributes that allow us to identify together, e.g., *Z*, (*Z*, `+`), (*Z*, `+`, `*`), (*Z*, `+`, `AdditiveAbelianGroups()`), (*Z*, *Q* via `fraction_field()`), etc. to deal with the ambiguity we very often use because context (and "trivialities" or "well-known facts/identifications") makes it clear.


---

Comment by mkoeppe created at 2022-08-20 06:28:52

So the `Parent` resolves this ambiguity by storing these "attributes" (including the distinguished category), right?


---

Comment by tscrim created at 2022-08-20 06:34:07

Yes, that is how I see it.


---

Comment by mkoeppe created at 2022-08-20 06:37:26

So now a `ForgetfulFunctor` is sneaking around the corner and applies itself to the `Parent`. Do I understand right that you are saying that not only it needs to return the same object, but also that object needs to be equipped with the same unchanged "attributes"?


---

Comment by tscrim created at 2022-08-20 06:44:34

It doesn't have to return the same object, but it can. This is why I have no problem with the change in #34384, but I object to calling it a bug that it does not do it.


---

Comment by mkoeppe created at 2022-08-20 06:55:55

By object, you now mean `Parent`, right? That is object "associated" with extra attributes, yes?


---

Comment by tscrim created at 2022-08-20 07:06:58

Yes, that is correct.


---

Comment by mkoeppe created at 2022-08-20 07:16:29

In #34384, I add the new warning:

```
+            UserWarning: The forgetful functor to Category of commutative additive groups
+             from Category of commutative rings (a non-full subcategory)
+             is not properly implemented; see https://trac.sagemath.org/ticket/31247
```

What's your take on this?


---

Comment by tscrim created at 2022-08-20 07:22:58

I think it should not be there. It is properly implemented (modulo the morphism issue).


---

Comment by mkoeppe created at 2022-08-20 07:25:05

I could change it to `UserWarning: The forgetful functor to Category of commutative additive groups from Category of commutative rings (a non-full subcategory) is technically correct (the best kind of correct), but note that it may be very inconvenient that its result's distinguished category (and hence distinguished homset) has nothing to do with the codomain of the forgetful functor`


---

Comment by tscrim created at 2022-08-20 08:16:23

I am still not happy with it as it is giving a bit strong of an implication that this behavior should be changed. I would rather see it as a documentation warning rather than something invoked when the functor is called. However, I am willing to accept it as a compromise with perhaps some minor tweaks to the wording.

Also, +1.0 on the bureaucratic reference. `;)`


---

Comment by mkoeppe created at 2022-08-21 17:56:58

Replying to [comment:84 tscrim]:
> Replying to [comment:81 SimonKing]:
> > The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).
> > 
> > And that would indeed be difficult to implement.
> 
> I would say nearly impossible resulting in any ticket with a new feature would basically be introducing bugs. This is making the specification of `==` way too strict.

Yes, the problem of deciding whether a given morphism can be lifted to a subcategory is very hard. For morphisms between finite parents, there would probably be a trivial algorithm, but it would depend on the specific categories whether an efficient algorithm is available. For morphisms between infinite parents, this will often be undecidable.

Fortunately, this problem does not need to be solved for this ticket.


---

Comment by mkoeppe created at 2022-08-21 18:23:38

Replying to [comment:84 tscrim]:
> Replying to [comment:81 SimonKing]:
> > IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).
> 
> How would you deal with sets that are equal but with different implementations that do not have a conversion (much less a coercion) between them? Following your premise, this would be a bug, which would need to be fixed. To make this even more difficult, you would not want a coercion because the parents have fundamentally different structures. How do we fix this?

Equality of parents is clearly a very complicated topic that involves multiple issues, at least the following:
- on the programming level, equality (`==`) vs identity (`is`), `UniqueRepresentation`
- on the programming level, the hash/equality contract (both on elements and on parents) and its many violations in Sage
- the semantics of objects "associated" with additional attributes 
- the semantics of mutable objects

A general discussion of this topic will not lead very far. But a key question to answer is:
- What is an identity morphism?

I would say it is at least an injective coercion morphism.
So this example by Travis:
> What about more abstract parents? Should all three dimensional free modules over a field `k` be equal since they all could be considered as `k`<sup>3</sup> (in particular, by the method `to_vector()` in `ModulesWithBasis()`)? How do we even want to decide?

There would be no coercion morphisms between these modules in general, so the answer would be "no". (Yes, the implementation of (ambient) free modules in `sage.modules` does make them `UniqueRepresentation`, so for these there would be a trivial "yes".)


---

Comment by mkoeppe created at 2022-08-21 18:28:37

I'd suggest to start discussing this question in a simpler context than equality of parents, namely the specification of an `is_subset` method for (enumerated) sets (#34398). 

Naively, `S.is_subset(T)` would be equivalent to `all(x in T for x in S)`. But because `x in T` is subject to the discovery of coercion maps, we can ask for a stricter test than this pointwise test.
