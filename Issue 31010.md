# Issue 31010: Forgetful Functor not working properly

archive/issues_031010.json:
```json
{
    "body": "CC:  tscrim mkoeppe @tobiasdiez nthiery simonking hivert\n\nWe have currently the following bug:\n\n\n```\nsage: from sage.categories.functor import ForgetfulFunctor\nsage: F = ForgetfulFunctor(Rings(), Sets())\nsage: F(ZZ)\nInteger Ring\n```\n\n\nThe result should rather be:\n\n\n```\nsage: Set(ZZ)\nSet of elements of Integer Ring\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/31247\n\n",
    "created_at": "2021-01-15T13:00:45Z",
    "labels": [
        "categories",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Forgetful Functor not working properly",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31010",
    "user": "@mjungmath"
}
```
CC:  tscrim mkoeppe @tobiasdiez nthiery simonking hivert

We have currently the following bug:


```
sage: from sage.categories.functor import ForgetfulFunctor
sage: F = ForgetfulFunctor(Rings(), Sets())
sage: F(ZZ)
Integer Ring
```


The result should rather be:


```
sage: Set(ZZ)
Set of elements of Integer Ring
```


Issue created by migration from https://trac.sagemath.org/ticket/31247





---

archive/issue_comments_442920.json:
```json
{
    "body": "Digging into the source code, the forgetful functor `F` calls the following code from its class parent `Functor`:\n\n\n```python\n    def _apply_functor(self, x):\n        \"\"\"\n        Apply the functor to an object of ``self``'s domain.\n\n        NOTE:\n\n        Each subclass of :class:`Functor` should overload this method. By default,\n        this method coerces into the codomain, without checking whether the\n        argument belongs to the domain.\n\n        TESTS::\n\n            sage: from sage.categories.functor import Functor\n            sage: F = Functor(FiniteFields(),Fields())\n            sage: F._apply_functor(ZZ)\n            Rational Field\n\n        \"\"\"\n        return self.__codomain(x)\n```\n\n\nHere, `__codomain` should be the destination category. However, the call function of a category is treated as some kind of coercion/conversion:\n\n\n```python\n    def __call__(self, x, *args, **opts):\n        \"\"\"\n        Construct an object in this category from the data in ``x``,\n        or throw ``TypeError`` or ``NotImplementedError``.\n\n        If ``x`` is readily in ``self`` it is returned unchanged.\n        Categories wishing to extend this minimal behavior should\n        implement :meth:`._call_`.\n\n        EXAMPLES::\n\n            sage: Rings()(ZZ)\n            Integer Ring\n        \"\"\"\n        if x in self:\n            return x\n        return self._call_(x, *args, **opts)\n```\n\n\nas the following note in `sage/categories/sets_cat.py` indicates, too:\n\n\n```python\n    def _call_(self, X, enumerated_set=False):\n        r\"\"\"\n        Construct an object in this category from the data ``X``.\n\n        INPUT:\n\n        - ``X`` -- an object to be converted into a set\n\n        - ``enumerated_set`` -- if set to ``True`` and the input is either a\n          Python tuple or a Python list then the output will be a finite\n          enumerated set.\n\n        EXAMPLES::\n\n            sage: Sets()(ZZ)\n            Integer Ring\n            sage: Sets()([1, 2, 3])\n            {1, 2, 3}\n\n            sage: S = Sets()([1, 2, 3]); S.category()\n            Category of finite sets\n            sage: S = Sets()([1, 2, 3], enumerated_set=True); S.category()\n            Category of facade finite enumerated sets\n\n        .. NOTE::\n\n           Using ``Sets()(A)`` used to implement some sort of forgetful functor\n           into the ``Sets()`` category. This feature has been removed, because\n           it was not consistent with the semantic of :meth:`Category.__call__`.\n           Proper forgetful functors will eventually be implemented, with\n           another syntax.\n        \"\"\"\n        if enumerated_set and type(X) in (tuple, list, range):\n            from sage.categories.enumerated_sets import EnumeratedSets\n            return EnumeratedSets()(X)\n        from sage.sets.set import Set\n        return Set(X)\n```\n\n\n*Proper forgetful functors will eventually be implemented, with another syntax.* It seems, this hasn't been done so far.",
    "created_at": "2021-01-15T13:01:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442920",
    "user": "@mjungmath"
}
```

Digging into the source code, the forgetful functor `F` calls the following code from its class parent `Functor`:


```python
    def _apply_functor(self, x):
        """
        Apply the functor to an object of ``self``'s domain.

        NOTE:

        Each subclass of :class:`Functor` should overload this method. By default,
        this method coerces into the codomain, without checking whether the
        argument belongs to the domain.

        TESTS::

            sage: from sage.categories.functor import Functor
            sage: F = Functor(FiniteFields(),Fields())
            sage: F._apply_functor(ZZ)
            Rational Field

        """
        return self.__codomain(x)
```


Here, `__codomain` should be the destination category. However, the call function of a category is treated as some kind of coercion/conversion:


```python
    def __call__(self, x, *args, **opts):
        """
        Construct an object in this category from the data in ``x``,
        or throw ``TypeError`` or ``NotImplementedError``.

        If ``x`` is readily in ``self`` it is returned unchanged.
        Categories wishing to extend this minimal behavior should
        implement :meth:`._call_`.

        EXAMPLES::

            sage: Rings()(ZZ)
            Integer Ring
        """
        if x in self:
            return x
        return self._call_(x, *args, **opts)
```


as the following note in `sage/categories/sets_cat.py` indicates, too:


```python
    def _call_(self, X, enumerated_set=False):
        r"""
        Construct an object in this category from the data ``X``.

        INPUT:

        - ``X`` -- an object to be converted into a set

        - ``enumerated_set`` -- if set to ``True`` and the input is either a
          Python tuple or a Python list then the output will be a finite
          enumerated set.

        EXAMPLES::

            sage: Sets()(ZZ)
            Integer Ring
            sage: Sets()([1, 2, 3])
            {1, 2, 3}

            sage: S = Sets()([1, 2, 3]); S.category()
            Category of finite sets
            sage: S = Sets()([1, 2, 3], enumerated_set=True); S.category()
            Category of facade finite enumerated sets

        .. NOTE::

           Using ``Sets()(A)`` used to implement some sort of forgetful functor
           into the ``Sets()`` category. This feature has been removed, because
           it was not consistent with the semantic of :meth:`Category.__call__`.
           Proper forgetful functors will eventually be implemented, with
           another syntax.
        """
        if enumerated_set and type(X) in (tuple, list, range):
            from sage.categories.enumerated_sets import EnumeratedSets
            return EnumeratedSets()(X)
        from sage.sets.set import Set
        return Set(X)
```


*Proper forgetful functors will eventually be implemented, with another syntax.* It seems, this hasn't been done so far.



---

archive/issue_comments_442921.json:
```json
{
    "body": "One could try the following: overload `_apply_functor` for forgetful functors and call `_call_` directly. That would be a minimal solution, but I am not sure whether it is the most elegant.",
    "created_at": "2021-01-15T13:05:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442921",
    "user": "@mjungmath"
}
```

One could try the following: overload `_apply_functor` for forgetful functors and call `_call_` directly. That would be a minimal solution, but I am not sure whether it is the most elegant.



---

archive/issue_comments_442922.json:
```json
{
    "body": "I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class. I think if you want to change your object, you should call the explicit constructor rather than relying on a functor. Moreover, if it is not going to be the current behavior, then I think you're asking for a solution to an impossible problem.",
    "created_at": "2021-01-17T02:19:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442922",
    "user": "tscrim"
}
```

I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class. I think if you want to change your object, you should call the explicit constructor rather than relying on a functor. Moreover, if it is not going to be the current behavior, then I think you're asking for a solution to an impossible problem.



---

archive/issue_comments_442923.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n> I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.\n\nThen, the same would hold for manifolds in #31241. Differentiable manifolds are also in the category of topological manifolds (or at least should be). But we already agreed that it's a bug there. What is the difference then?\n\n> I think if you want to change your object, you should call the explicit constructor rather than relying on a functor. Moreover, if it is not going to be the current behavior, then I think you're asking for a solution to an impossible problem.\n\nWell, the forgetful functor has the purpose to forget imposed structures, and see the object as an object in the super category only. This condition is currently not met:\n\n\n```\nsage: from sage.categories.functor import ForgetfulFunctor \n....: F = ForgetfulFunctor(Rings(), Sets()) \n....: F(ZZ).category()                                                    \nJoin of Category of euclidean domains and Category of infinite enumerated sets and Category of metric spaces\nsage: F(ZZ)(1) + F(ZZ)(2)                                                       \n3\n```\n\n\nUsual set operations are not even compatible:\n\n\n```\nsage: Set([1,2,3]).union(F(ZZ))                                                    \n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n...\nTypeError: X (=Integer Ring) must be a Set\n```\n\n\n\nOf course, different structures need different implementations.\n\nFor manifolds, the current stage of behavior is rather bad. Differentiable manifolds can be seen as topological manifolds, however each differentiable manifold comes with a differentiable structure which Sage keeps implicitly track of. This must be dropped after the forgetful functor had been applied. But with the above behavior, this is not possible because the original instance would be returned.",
    "created_at": "2021-01-17T09:21:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442923",
    "user": "@mjungmath"
}
```

Replying to [comment:4 tscrim]:
> I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.

Then, the same would hold for manifolds in #31241. Differentiable manifolds are also in the category of topological manifolds (or at least should be). But we already agreed that it's a bug there. What is the difference then?

> I think if you want to change your object, you should call the explicit constructor rather than relying on a functor. Moreover, if it is not going to be the current behavior, then I think you're asking for a solution to an impossible problem.

Well, the forgetful functor has the purpose to forget imposed structures, and see the object as an object in the super category only. This condition is currently not met:


```
sage: from sage.categories.functor import ForgetfulFunctor 
....: F = ForgetfulFunctor(Rings(), Sets()) 
....: F(ZZ).category()                                                    
Join of Category of euclidean domains and Category of infinite enumerated sets and Category of metric spaces
sage: F(ZZ)(1) + F(ZZ)(2)                                                       
3
```


Usual set operations are not even compatible:


```
sage: Set([1,2,3]).union(F(ZZ))                                                    
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: X (=Integer Ring) must be a Set
```



Of course, different structures need different implementations.

For manifolds, the current stage of behavior is rather bad. Differentiable manifolds can be seen as topological manifolds, however each differentiable manifold comes with a differentiable structure which Sage keeps implicitly track of. This must be dropped after the forgetful functor had been applied. But with the above behavior, this is not possible because the original instance would be returned.



---

archive/issue_comments_442924.json:
```json
{
    "body": "Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-24T02:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442924",
    "user": "mkoeppe"
}
```

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_442925.json:
```json
{
    "body": "Another example:\n\n```\nsage: R.<x> = QQ[]\nsage: phi = R.hom([x^2]); phi\nRing endomorphism of Univariate Polynomial Ring in x over Rational Field\n  Defn: x |--> x^2\nsage: phi.category_for()\nJoin of Category of euclidean domains and Category of commutative algebras over (number fields and quotient fields and metric spaces) and Category of infinite sets\nsage: F = ForgetfulFunctor(Rings(), Sets())\nsage: F(phi)\nRing endomorphism of Univariate Polynomial Ring in x over Rational Field\n  Defn: x |--> x^2\n```\n\nI hoped to compute the correct category of an image in #32121 (Replace `MapCombinatorialClass`, add methods `Map.image`, `Map.pushforward`)...",
    "created_at": "2021-07-04T05:18:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442925",
    "user": "mkoeppe"
}
```

Another example:

```
sage: R.<x> = QQ[]
sage: phi = R.hom([x^2]); phi
Ring endomorphism of Univariate Polynomial Ring in x over Rational Field
  Defn: x |--> x^2
sage: phi.category_for()
Join of Category of euclidean domains and Category of commutative algebras over (number fields and quotient fields and metric spaces) and Category of infinite sets
sage: F = ForgetfulFunctor(Rings(), Sets())
sage: F(phi)
Ring endomorphism of Univariate Polynomial Ring in x over Rational Field
  Defn: x |--> x^2
```

I hoped to compute the correct category of an image in #32121 (Replace `MapCombinatorialClass`, add methods `Map.image`, `Map.pushforward`)...



---

archive/issue_comments_442926.json:
```json
{
    "body": "This in and of itself is not a bug IMO as per comment:4. However, what is a bug IMO is that\n\n```\nsage: F(phi).parent()\nSet of Homomorphisms from Univariate Polynomial Ring in x over Rational Field\n to Univariate Polynomial Ring in x over Rational Field\n```\n\nwhich leads to this\n\n```\nsage: F(phi).category_for()\nJoin of Category of euclidean domains\n and Category of commutative algebras over (number fields and quotient fields and metric spaces)\n and Category of infinite sets\n```\n\nFor morphisms, where the category is part of the homset constructor, we can create the new homset parent and then convert the morphism into that parent. Mostly this just consists of rebuilding the same object but with a different parent. This is meaningful when we want to compose maps (as opposed to manipulating sets).",
    "created_at": "2021-07-04T12:40:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442926",
    "user": "tscrim"
}
```

This in and of itself is not a bug IMO as per comment:4. However, what is a bug IMO is that

```
sage: F(phi).parent()
Set of Homomorphisms from Univariate Polynomial Ring in x over Rational Field
 to Univariate Polynomial Ring in x over Rational Field
```

which leads to this

```
sage: F(phi).category_for()
Join of Category of euclidean domains
 and Category of commutative algebras over (number fields and quotient fields and metric spaces)
 and Category of infinite sets
```

For morphisms, where the category is part of the homset constructor, we can create the new homset parent and then convert the morphism into that parent. Mostly this just consists of rebuilding the same object but with a different parent. This is meaningful when we want to compose maps (as opposed to manipulating sets).



---

archive/issue_comments_442927.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n> I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.\n\nMathematically one would, of course, say that the forgetful functor should act like the identity on a parent.\n\nBut our parents are equipped with a distinguished category.\n\nSo the forgetful functor needs to construct a new parent in which the distinguished category is replaced by the codomain.",
    "created_at": "2022-08-17T18:22:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442927",
    "user": "mkoeppe"
}
```

Replying to [comment:4 tscrim]:
> I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.

Mathematically one would, of course, say that the forgetful functor should act like the identity on a parent.

But our parents are equipped with a distinguished category.

So the forgetful functor needs to construct a new parent in which the distinguished category is replaced by the codomain.



---

archive/issue_comments_442928.json:
```json
{
    "body": "Replying to [comment:14 mkoeppe]:\n> Replying to [comment:4 tscrim]:\n> > I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.\n> \n> Mathematically one would, of course, say that the forgetful functor should act like the identity on a parent.\n\nThat strongly depends on how mathematically precise you want to connect a parent to its mathematical model. Strictly speaking, `ZZ` is just a set, but the ring of integers is really `(ZZ, +, *)` with distinguished binary operations `+: ZZ x ZZ -> ZZ` and `*: ZZ x ZZ -> ZZ`. However, the \"ring\" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. However, if you never add or multiply the elements together, then `1` is just an element of the set `ZZ`.\n\n> But our parents are equipped with a distinguished category.\n\nI think it is better to treat it like \"this is the smallest category where this object (currently) makes sense to belong to.\"\n\n> So the forgetful functor needs to construct a new parent in which the distinguished category is replaced by the codomain.\n\nI still contest that the set of objects is still the set of objects. Equality is not always the mathematical equality you are thinking of (which we actually often think of as being \"isomorphic to\").\n\nEven allowing that we wanted a new parent, this would be an impossible problem to solve as we would either have to have a class for the forgetful functor for each category (a huge number) or we would need to know which methods to remove (any parent can implement their own custom version or ones that only make sense in category `C'` not its super category `C`).\n\nIf the user wants to do equality as some other type of object, then we should tell the user to build other type. For example, `Set(ZZ)` to do equality as a `Set` object.\n\nMorphisms already have a hook for specifying the category. This might not be fully implemented, but if we wanted to consider the isomorphism `x |-> 2x` of **Q** as a **Q**-vector space, but it doesn't make sense as a ring morphism. The forgetful functor should change the category of the morphism.",
    "created_at": "2022-08-18T07:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442928",
    "user": "tscrim"
}
```

Replying to [comment:14 mkoeppe]:
> Replying to [comment:4 tscrim]:
> > I don't think this is a bug. The code is performing as it should because `ZZ` is already in `Sets()`. It doesn't need to create a new object, much less an instance of a different class.
> 
> Mathematically one would, of course, say that the forgetful functor should act like the identity on a parent.

That strongly depends on how mathematically precise you want to connect a parent to its mathematical model. Strictly speaking, `ZZ` is just a set, but the ring of integers is really `(ZZ, +, *)` with distinguished binary operations `+: ZZ x ZZ -> ZZ` and `*: ZZ x ZZ -> ZZ`. However, the "ring" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. However, if you never add or multiply the elements together, then `1` is just an element of the set `ZZ`.

> But our parents are equipped with a distinguished category.

I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."

> So the forgetful functor needs to construct a new parent in which the distinguished category is replaced by the codomain.

I still contest that the set of objects is still the set of objects. Equality is not always the mathematical equality you are thinking of (which we actually often think of as being "isomorphic to").

Even allowing that we wanted a new parent, this would be an impossible problem to solve as we would either have to have a class for the forgetful functor for each category (a huge number) or we would need to know which methods to remove (any parent can implement their own custom version or ones that only make sense in category `C'` not its super category `C`).

If the user wants to do equality as some other type of object, then we should tell the user to build other type. For example, `Set(ZZ)` to do equality as a `Set` object.

Morphisms already have a hook for specifying the category. This might not be fully implemented, but if we wanted to consider the isomorphism `x |-> 2x` of **Q** as a **Q**-vector space, but it doesn't make sense as a ring morphism. The forgetful functor should change the category of the morphism.



---

archive/issue_comments_442929.json:
```json
{
    "body": "Replying to [comment:16 tscrim]:\n> Even allowing that we wanted a new parent, this would be an impossible problem to solve as we would either have to have a class for the forgetful functor for each category (a huge number) or we would need to know which methods to remove (any parent can implement their own custom version or ones that only make sense in category `C'` not its super category `C`).\n\nI agree that it is impossible to solve in general. \n\nThat should not stop us from implementing it for useful cases. In #34384, I implement it for `codomain=Sets()`.\n\nThere's warnings for the rest. We could also raise a `NotImplementedError`.",
    "created_at": "2022-08-18T15:12:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442929",
    "user": "mkoeppe"
}
```

Replying to [comment:16 tscrim]:
> Even allowing that we wanted a new parent, this would be an impossible problem to solve as we would either have to have a class for the forgetful functor for each category (a huge number) or we would need to know which methods to remove (any parent can implement their own custom version or ones that only make sense in category `C'` not its super category `C`).

I agree that it is impossible to solve in general. 

That should not stop us from implementing it for useful cases. In #34384, I implement it for `codomain=Sets()`.

There's warnings for the rest. We could also raise a `NotImplementedError`.



---

archive/issue_comments_442930.json:
```json
{
    "body": "Replying to [comment:16 tscrim]:\n> Replying to [comment:14 mkoeppe]:\n> > our parents are equipped with a distinguished category.\n\n... namely, what the method `category()` returns.\n\n> I think it is better to treat it like \"this is the smallest category where this object (currently) makes sense to belong to.\"\n\n... this is ill-defined or tautological",
    "created_at": "2022-08-18T15:43:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442930",
    "user": "mkoeppe"
}
```

Replying to [comment:16 tscrim]:
> Replying to [comment:14 mkoeppe]:
> > our parents are equipped with a distinguished category.

... namely, what the method `category()` returns.

> I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."

... this is ill-defined or tautological



---

archive/issue_comments_442931.json:
```json
{
    "body": "Replying to [comment:16 tscrim]:\n> the \"ring\" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. \n\nThis distinction is irrelevant because the parent `ZZ` is also equipped with a distinguished element class.",
    "created_at": "2022-08-18T15:53:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442931",
    "user": "mkoeppe"
}
```

Replying to [comment:16 tscrim]:
> the "ring" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. 

This distinction is irrelevant because the parent `ZZ` is also equipped with a distinguished element class.



---

archive/issue_comments_442932.json:
```json
{
    "body": "Replying to [comment:18 mkoeppe]:\n> Replying to [comment:16 tscrim]:\n> > Replying to [comment:14 mkoeppe]:\n> > > our parents are equipped with a distinguished category.\n> \n> ... namely, what the method `category()` returns.\n\nThat in no way means that any parent is specifically meant to be associated with that category and no other. If that was true, there would be absolutely no reason to have a `category` option to `Hom`.\n\n> > I think it is better to treat it like \"this is the smallest category where this object (currently) makes sense to belong to.\"\n> \n> ... this is ill-defined or tautological\n\nNo and no. It is well-defined based upon what is implemented. It is not tautological because, e.g., `ZZ` is also in `Sets()`. Furthermore, saying it is tautological makes no sense because then any definition involving \"the smallest\" would be tautological.",
    "created_at": "2022-08-19T05:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442932",
    "user": "tscrim"
}
```

Replying to [comment:18 mkoeppe]:
> Replying to [comment:16 tscrim]:
> > Replying to [comment:14 mkoeppe]:
> > > our parents are equipped with a distinguished category.
> 
> ... namely, what the method `category()` returns.

That in no way means that any parent is specifically meant to be associated with that category and no other. If that was true, there would be absolutely no reason to have a `category` option to `Hom`.

> > I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."
> 
> ... this is ill-defined or tautological

No and no. It is well-defined based upon what is implemented. It is not tautological because, e.g., `ZZ` is also in `Sets()`. Furthermore, saying it is tautological makes no sense because then any definition involving "the smallest" would be tautological.



---

archive/issue_comments_442933.json:
```json
{
    "body": "Replying to [comment:19 mkoeppe]:\n> Replying to [comment:16 tscrim]:\n> > the \"ring\" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. \n> \n> This distinction is irrelevant because the parent `ZZ` is also equipped with a distinguished element class.\n\nIn this case, but broadly within Sage, that is completely false. We have many things that have multiple types of element classes. Most (all?) of them are homsets. We don't (yet) have a good system to handle these parents.",
    "created_at": "2022-08-19T05:37:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442933",
    "user": "tscrim"
}
```

Replying to [comment:19 mkoeppe]:
> Replying to [comment:16 tscrim]:
> > the "ring" `ZZ` is just modeling the set and it is the implementation of the elements that carry the information of `+` and `*`. 
> 
> This distinction is irrelevant because the parent `ZZ` is also equipped with a distinguished element class.

In this case, but broadly within Sage, that is completely false. We have many things that have multiple types of element classes. Most (all?) of them are homsets. We don't (yet) have a good system to handle these parents.



---

archive/issue_comments_442934.json:
```json
{
    "body": "Replying to [comment:21 tscrim]:\n> We have many things that have multiple types of element classes. Most (all?) of them are homsets.\n\nThe discussion of parents with multiple elements classes is obviously irrelevant for this discussion.",
    "created_at": "2022-08-19T05:47:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442934",
    "user": "mkoeppe"
}
```

Replying to [comment:21 tscrim]:
> We have many things that have multiple types of element classes. Most (all?) of them are homsets.

The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.



---

archive/issue_comments_442935.json:
```json
{
    "body": "Replying to [comment:22 mkoeppe]:\n> Replying to [comment:21 tscrim]:\n> > We have many things that have multiple types of element classes. Most (all?) of them are homsets.\n> \n> The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.\n\nYou just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.",
    "created_at": "2022-08-19T05:48:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442935",
    "user": "tscrim"
}
```

Replying to [comment:22 mkoeppe]:
> Replying to [comment:21 tscrim]:
> > We have many things that have multiple types of element classes. Most (all?) of them are homsets.
> 
> The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.

You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.



---

archive/issue_comments_442936.json:
```json
{
    "body": "Replying to [comment:20 tscrim]:\n> Replying to [comment:18 mkoeppe]:\n> > Replying to [comment:16 tscrim]:\n> > > Replying to [comment:14 mkoeppe]:\n> > > > our parents are equipped with a distinguished category.\n> > \n> > ... namely, what the method `category()` returns.\n> \n> That in no way means that any parent is specifically meant to be associated with that category and no other.\n\nThat's not what \"distinguished\" means.",
    "created_at": "2022-08-19T05:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442936",
    "user": "mkoeppe"
}
```

Replying to [comment:20 tscrim]:
> Replying to [comment:18 mkoeppe]:
> > Replying to [comment:16 tscrim]:
> > > Replying to [comment:14 mkoeppe]:
> > > > our parents are equipped with a distinguished category.
> > 
> > ... namely, what the method `category()` returns.
> 
> That in no way means that any parent is specifically meant to be associated with that category and no other.

That's not what "distinguished" means.



---

archive/issue_comments_442937.json:
```json
{
    "body": "Replying to [comment:24 mkoeppe]:\n> Replying to [comment:20 tscrim]:\n> > Replying to [comment:18 mkoeppe]:\n> > > Replying to [comment:16 tscrim]:\n> > > > Replying to [comment:14 mkoeppe]:\n> > > > > our parents are equipped with a distinguished category.\n> > > \n> > > ... namely, what the method `category()` returns.\n> > \n> > That in no way means that any parent is specifically meant to be associated with that category and no other.\n> \n> That's not what \"distinguished\" means.\n\nIf you do not mean it in that way, which is what typically means by \"distinguished\", then the result of `category()` is irrelevant.",
    "created_at": "2022-08-19T05:53:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442937",
    "user": "tscrim"
}
```

Replying to [comment:24 mkoeppe]:
> Replying to [comment:20 tscrim]:
> > Replying to [comment:18 mkoeppe]:
> > > Replying to [comment:16 tscrim]:
> > > > Replying to [comment:14 mkoeppe]:
> > > > > our parents are equipped with a distinguished category.
> > > 
> > > ... namely, what the method `category()` returns.
> > 
> > That in no way means that any parent is specifically meant to be associated with that category and no other.
> 
> That's not what "distinguished" means.

If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.



---

archive/issue_comments_442938.json:
```json
{
    "body": "Replying to [comment:23 tscrim]:\n> Replying to [comment:22 mkoeppe]:\n> > Replying to [comment:21 tscrim]:\n> > > We have many things that have multiple types of element classes. Most (all?) of them are homsets.\n> > \n> > The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.\n> \n> You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.\n\nWhether you have just one element class or multiple element classes -- the parent is still equipped with the *list* of the element classes that can be used with it. \n\nAnd therefore, once more, the distinction of whether the operations are carried in the parent or in the elements is irrelevant.",
    "created_at": "2022-08-19T05:58:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442938",
    "user": "mkoeppe"
}
```

Replying to [comment:23 tscrim]:
> Replying to [comment:22 mkoeppe]:
> > Replying to [comment:21 tscrim]:
> > > We have many things that have multiple types of element classes. Most (all?) of them are homsets.
> > 
> > The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.
> 
> You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.

Whether you have just one element class or multiple element classes -- the parent is still equipped with the *list* of the element classes that can be used with it. 

And therefore, once more, the distinction of whether the operations are carried in the parent or in the elements is irrelevant.



---

archive/issue_comments_442939.json:
```json
{
    "body": "Replying to [comment:20 tscrim]:\n> Replying to [comment:18 mkoeppe]:\n> > Replying to [comment:16 tscrim]:\n> > > I think it is better to treat it like \"this is the smallest category where this object (currently) makes sense to belong to.\"\n\nBy smallest, do you mean largest?",
    "created_at": "2022-08-19T06:08:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442939",
    "user": "mkoeppe"
}
```

Replying to [comment:20 tscrim]:
> Replying to [comment:18 mkoeppe]:
> > Replying to [comment:16 tscrim]:
> > > I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."

By smallest, do you mean largest?



---

archive/issue_comments_442940.json:
```json
{
    "body": "What's ill-defined is the expression \"makes sense to belong to\".",
    "created_at": "2022-08-19T06:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442940",
    "user": "mkoeppe"
}
```

What's ill-defined is the expression "makes sense to belong to".



---

archive/issue_comments_442941.json:
```json
{
    "body": "Replying to [comment:26 mkoeppe]:\n> Replying to [comment:23 tscrim]:\n> > Replying to [comment:22 mkoeppe]:\n> > > Replying to [comment:21 tscrim]:\n> > > > We have many things that have multiple types of element classes. Most (all?) of them are homsets.\n> > > \n> > > The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.\n> > \n> > You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.\n> \n> Whether you have just one element class or multiple element classes -- the parent is still equipped with the *list* of the element classes that can be used with it. \n> \n> And therefore, once more, the distinction of whether the operations are carried in the parent or in the elements is irrelevant.\n\nIt is quite important because you care about the extra structure placed on top of `ZZ` the set. The parent never models the ring operations because they are invoked with, e.g., `__add__` and `__mul__`. It might carry the implementation, but you need to construct elements to do the multiplication of elements. If you do not do any `+` or `*` operations on the elements, you have a set.\n\nNow you are probably going to try and counter with something along the lines of \"but equality as rings is different\". However, Python/programming equality `==` does not have to be the same as mathematical equality. For example, does `2 == 4 / 2`? I could say no because the `QQ` representation is different (provided I don't normalize). So you could have **ZZ** with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.",
    "created_at": "2022-08-19T06:11:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442941",
    "user": "tscrim"
}
```

Replying to [comment:26 mkoeppe]:
> Replying to [comment:23 tscrim]:
> > Replying to [comment:22 mkoeppe]:
> > > Replying to [comment:21 tscrim]:
> > > > We have many things that have multiple types of element classes. Most (all?) of them are homsets.
> > > 
> > > The discussion of parents with multiple elements classes is obviously irrelevant for this discussion.
> > 
> > You just tried to make a point about it. In fact, having a framework for multiple types of elements has been a wishlist item for a while.
> 
> Whether you have just one element class or multiple element classes -- the parent is still equipped with the *list* of the element classes that can be used with it. 
> 
> And therefore, once more, the distinction of whether the operations are carried in the parent or in the elements is irrelevant.

It is quite important because you care about the extra structure placed on top of `ZZ` the set. The parent never models the ring operations because they are invoked with, e.g., `__add__` and `__mul__`. It might carry the implementation, but you need to construct elements to do the multiplication of elements. If you do not do any `+` or `*` operations on the elements, you have a set.

Now you are probably going to try and counter with something along the lines of "but equality as rings is different". However, Python/programming equality `==` does not have to be the same as mathematical equality. For example, does `2 == 4 / 2`? I could say no because the `QQ` representation is different (provided I don't normalize). So you could have **ZZ** with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.



---

archive/issue_comments_442942.json:
```json
{
    "body": "Replying to [comment:25 tscrim]:\n> Replying to [comment:24 mkoeppe]:\n> > Replying to [comment:20 tscrim]:\n> > > Replying to [comment:18 mkoeppe]:\n> > > > Replying to [comment:16 tscrim]:\n> > > > > Replying to [comment:14 mkoeppe]:\n> > > > > > our parents are equipped with a distinguished category.\n> > > > \n> > > > ... namely, what the method `category()` returns.\n> > > \n> > > That in no way means that any parent is specifically meant to be associated with that category and no other.\n> > \n> > That's not what \"distinguished\" means.\n> \n> If you do not mean it in that way, which is what typically means by \"distinguished\", then the result of `category()` is irrelevant.\n\nWell, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).",
    "created_at": "2022-08-19T06:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442942",
    "user": "mkoeppe"
}
```

Replying to [comment:25 tscrim]:
> Replying to [comment:24 mkoeppe]:
> > Replying to [comment:20 tscrim]:
> > > Replying to [comment:18 mkoeppe]:
> > > > Replying to [comment:16 tscrim]:
> > > > > Replying to [comment:14 mkoeppe]:
> > > > > > our parents are equipped with a distinguished category.
> > > > 
> > > > ... namely, what the method `category()` returns.
> > > 
> > > That in no way means that any parent is specifically meant to be associated with that category and no other.
> > 
> > That's not what "distinguished" means.
> 
> If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.

Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).



---

archive/issue_comments_442943.json:
```json
{
    "body": "Replying to [comment:27 mkoeppe]:\n> Replying to [comment:20 tscrim]:\n> > Replying to [comment:18 mkoeppe]:\n> > > Replying to [comment:16 tscrim]:\n> > > > I think it is better to treat it like \"this is the smallest category where this object (currently) makes sense to belong to.\"\n> \n> By smallest, do you mean largest?\n\nI mean in smallest the sense of super/sub categories as we have defined the terminology in Sage, which is backwards of how we like to think of with forgetful functors.",
    "created_at": "2022-08-19T06:13:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442943",
    "user": "tscrim"
}
```

Replying to [comment:27 mkoeppe]:
> Replying to [comment:20 tscrim]:
> > Replying to [comment:18 mkoeppe]:
> > > Replying to [comment:16 tscrim]:
> > > > I think it is better to treat it like "this is the smallest category where this object (currently) makes sense to belong to."
> 
> By smallest, do you mean largest?

I mean in smallest the sense of super/sub categories as we have defined the terminology in Sage, which is backwards of how we like to think of with forgetful functors.



---

archive/issue_comments_442944.json:
```json
{
    "body": "Replying to [comment:28 mkoeppe]:\n> What's ill-defined is the expression \"makes sense to belong to\".\n\nThe implementation with the methods required by the category.",
    "created_at": "2022-08-19T06:14:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442944",
    "user": "tscrim"
}
```

Replying to [comment:28 mkoeppe]:
> What's ill-defined is the expression "makes sense to belong to".

The implementation with the methods required by the category.



---

archive/issue_comments_442945.json:
```json
{
    "body": "This is exactly what makes it tautological. The category returned `category()` defines exactly those methods that have been mixed into the parent.",
    "created_at": "2022-08-19T06:16:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442945",
    "user": "mkoeppe"
}
```

This is exactly what makes it tautological. The category returned `category()` defines exactly those methods that have been mixed into the parent.



---

archive/issue_comments_442946.json:
```json
{
    "body": "Replying to [comment:30 mkoeppe]:\n> Replying to [comment:25 tscrim]:\n> > Replying to [comment:24 mkoeppe]:\n> > > Replying to [comment:20 tscrim]:\n> > > > Replying to [comment:18 mkoeppe]:\n> > > > > Replying to [comment:16 tscrim]:\n> > > > > > Replying to [comment:14 mkoeppe]:\n> > > > > > > our parents are equipped with a distinguished category.\n> > > > > \n> > > > > ... namely, what the method `category()` returns.\n> > > > \n> > > > That in no way means that any parent is specifically meant to be associated with that category and no other.\n> > > \n> > > That's not what \"distinguished\" means.\n> > \n> > If you do not mean it in that way, which is what typically means by \"distinguished\", then the result of `category()` is irrelevant.\n> \n> Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).\n\nHowever those are just default implementations to reduce code duplication. There are some methods that are ambiguous, the biggest one I can think of is `gens()`, which is why we are now advocating for `*_generators()`.",
    "created_at": "2022-08-19T06:16:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442946",
    "user": "tscrim"
}
```

Replying to [comment:30 mkoeppe]:
> Replying to [comment:25 tscrim]:
> > Replying to [comment:24 mkoeppe]:
> > > Replying to [comment:20 tscrim]:
> > > > Replying to [comment:18 mkoeppe]:
> > > > > Replying to [comment:16 tscrim]:
> > > > > > Replying to [comment:14 mkoeppe]:
> > > > > > > our parents are equipped with a distinguished category.
> > > > > 
> > > > > ... namely, what the method `category()` returns.
> > > > 
> > > > That in no way means that any parent is specifically meant to be associated with that category and no other.
> > > 
> > > That's not what "distinguished" means.
> > 
> > If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.
> 
> Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).

However those are just default implementations to reduce code duplication. There are some methods that are ambiguous, the biggest one I can think of is `gens()`, which is why we are now advocating for `*_generators()`.



---

archive/issue_comments_442947.json:
```json
{
    "body": "Replying to [comment:33 mkoeppe]:\n> This is exactly what makes it tautological. The category returned `category()` defines exactly those methods that have been mixed into the parent.\n\nIf you don't want to consider your object in that category, then you don't call any of those methods. Neither do the methods say what category it belongs to. I could implement `ZZ` as a set with an operation `coproduct` that could have nothing to do with bialgebras. That doesn't mean it should be treated as a bialgebra.",
    "created_at": "2022-08-19T06:18:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442947",
    "user": "tscrim"
}
```

Replying to [comment:33 mkoeppe]:
> This is exactly what makes it tautological. The category returned `category()` defines exactly those methods that have been mixed into the parent.

If you don't want to consider your object in that category, then you don't call any of those methods. Neither do the methods say what category it belongs to. I could implement `ZZ` as a set with an operation `coproduct` that could have nothing to do with bialgebras. That doesn't mean it should be treated as a bialgebra.



---

archive/issue_comments_442948.json:
```json
{
    "body": "Replying to [comment:29 tscrim]:\n> something along the lines of \"but equality as rings is different\". \n\nYes, because equality as XYZ is a statement about maps in the category XYZ.\n\nWhich is why the forgetful functor when applied to a parent with a distinguished category needs to return a parent with the changed category.\n\nCompletely unrelated to the \"equality of representations\" issues that you talked about.",
    "created_at": "2022-08-19T06:21:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442948",
    "user": "mkoeppe"
}
```

Replying to [comment:29 tscrim]:
> something along the lines of "but equality as rings is different". 

Yes, because equality as XYZ is a statement about maps in the category XYZ.

Which is why the forgetful functor when applied to a parent with a distinguished category needs to return a parent with the changed category.

Completely unrelated to the "equality of representations" issues that you talked about.



---

archive/issue_comments_442949.json:
```json
{
    "body": "Replying to [comment:29 tscrim]:\n> So you could have **ZZ** with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.\n\nYes, `Set(...)` is the forgetful functor, sending the parent with a distinguished category `C` to a parent whose distinguished category is a full subcategory of `Sets()`.\n\n#34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all",
    "created_at": "2022-08-19T06:29:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442949",
    "user": "mkoeppe"
}
```

Replying to [comment:29 tscrim]:
> So you could have **ZZ** with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.

Yes, `Set(...)` is the forgetful functor, sending the parent with a distinguished category `C` to a parent whose distinguished category is a full subcategory of `Sets()`.

#34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all



---

archive/issue_comments_442950.json:
```json
{
    "body": "Replying to [comment:35 tscrim]:\n> If you don't want to consider your object in that category, then you don't call any of those methods. Neither do the methods say what category it belongs to.\n\nExactly, we declare a distinguished category when we call `Parent(..., category=...)` -- because it would be ill-defined to guess it from the defined methods.",
    "created_at": "2022-08-19T06:31:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442950",
    "user": "mkoeppe"
}
```

Replying to [comment:35 tscrim]:
> If you don't want to consider your object in that category, then you don't call any of those methods. Neither do the methods say what category it belongs to.

Exactly, we declare a distinguished category when we call `Parent(..., category=...)` -- because it would be ill-defined to guess it from the defined methods.



---

archive/issue_comments_442951.json:
```json
{
    "body": "Replying to [comment:34 tscrim]:\n> Replying to [comment:30 mkoeppe]:\n> > Replying to [comment:25 tscrim]:\n> > > If you do not mean it in that way, which is what typically means by \"distinguished\", then the result of `category()` is irrelevant.\n> > \n> > Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).\n> \n> However those are just default implementations to reduce code duplication. \n\nHardly. It defines and specifies the required methods and even provides tests for these specifications.",
    "created_at": "2022-08-19T06:35:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442951",
    "user": "mkoeppe"
}
```

Replying to [comment:34 tscrim]:
> Replying to [comment:30 mkoeppe]:
> > Replying to [comment:25 tscrim]:
> > > If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.
> > 
> > Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).
> 
> However those are just default implementations to reduce code duplication. 

Hardly. It defines and specifies the required methods and even provides tests for these specifications.



---

archive/issue_comments_442952.json:
```json
{
    "body": "Replying to [comment:36 mkoeppe]:\n> Replying to [comment:29 tscrim]:\n> > something along the lines of \"but equality as rings is different\". \n> \n> Yes, because equality as XYZ is a statement about maps in the category XYZ.\n\nIsomorphism is not equality. It is very important not to confuse the two. As soon as you start talking about maps, you are talking isomorphism. In fact, I don't think many category theorists even talk about equality (everything is up to isomorphism).\n\nIn fact, that is exactly my point, the forgetful functor is about *maps*, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.\n\n> Which is why the forgetful functor when applied to a parent with a distinguished category needs to return a parent with the changed category.\n\nChanging the implementation is not a mathematical operation. It is a programming one. This further reinforces that we should be talking about Python `==`, not mathematical equality. The distinguished category has nothing to do with its mathematical equality statement.\n\n> Completely unrelated to the \"equality of representations\" issues that you talked about.\n\nSo `==` should always be mathematical equality, in some definition that you have not made precise? What about the cases when we want this isomorphic to (this occurs in permutation groups) or when no canonical representative exists (e.g., elements in the symbolic ring or for manifolds). We could go for this, but then should we remove code that doesn't comply or things that do not have canonical representatives? If we allow `==` for non-canoical representatives, then what makes those cases special compared to these parents?",
    "created_at": "2022-08-19T06:36:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442952",
    "user": "tscrim"
}
```

Replying to [comment:36 mkoeppe]:
> Replying to [comment:29 tscrim]:
> > something along the lines of "but equality as rings is different". 
> 
> Yes, because equality as XYZ is a statement about maps in the category XYZ.

Isomorphism is not equality. It is very important not to confuse the two. As soon as you start talking about maps, you are talking isomorphism. In fact, I don't think many category theorists even talk about equality (everything is up to isomorphism).

In fact, that is exactly my point, the forgetful functor is about *maps*, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.

> Which is why the forgetful functor when applied to a parent with a distinguished category needs to return a parent with the changed category.

Changing the implementation is not a mathematical operation. It is a programming one. This further reinforces that we should be talking about Python `==`, not mathematical equality. The distinguished category has nothing to do with its mathematical equality statement.

> Completely unrelated to the "equality of representations" issues that you talked about.

So `==` should always be mathematical equality, in some definition that you have not made precise? What about the cases when we want this isomorphic to (this occurs in permutation groups) or when no canonical representative exists (e.g., elements in the symbolic ring or for manifolds). We could go for this, but then should we remove code that doesn't comply or things that do not have canonical representatives? If we allow `==` for non-canoical representatives, then what makes those cases special compared to these parents?



---

archive/issue_comments_442953.json:
```json
{
    "body": "Replying to [comment:37 mkoeppe]:\n> Replying to [comment:29 tscrim]:\n> > So you could have **ZZ** with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.\n> \n> Yes, `Set(...)` is the forgetful functor, sending the parent with a distinguished category `C` to a parent whose distinguished category is a full subcategory of `Sets()`.\n\nI can agree with this statement.\n\n> #34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all\n\nWe can do this, but that is just some semmantic sugar with making `Set()` a distinguished object in the category `Sets()` for the `ForgetfulFunctor()`. I have no objections. What I do have a strong objection to is saying if it did not do that, then it is a bug.",
    "created_at": "2022-08-19T06:39:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442953",
    "user": "tscrim"
}
```

Replying to [comment:37 mkoeppe]:
> Replying to [comment:29 tscrim]:
> > So you could have **ZZ** with a different ring structure, which does not compare as `==` to `ZZ`. This is fine because its representation within Sage is different. If we want to compare them as sets (for argument's sake here, consider a finite subset), we have `Set` for this.
> 
> Yes, `Set(...)` is the forgetful functor, sending the parent with a distinguished category `C` to a parent whose distinguished category is a full subcategory of `Sets()`.

I can agree with this statement.

> #34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all

We can do this, but that is just some semmantic sugar with making `Set()` a distinguished object in the category `Sets()` for the `ForgetfulFunctor()`. I have no objections. What I do have a strong objection to is saying if it did not do that, then it is a bug.



---

archive/issue_comments_442954.json:
```json
{
    "body": "Replying to [comment:39 mkoeppe]:\n> Replying to [comment:34 tscrim]:\n> > Replying to [comment:30 mkoeppe]:\n> > > Replying to [comment:25 tscrim]:\n> > > > If you do not mean it in that way, which is what typically means by \"distinguished\", then the result of `category()` is irrelevant.\n> > > \n> > > Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).\n> > \n> > However those are just default implementations to reduce code duplication. \n> \n> Hardly. It defines and specifies the required methods and even provides tests for these specifications.\n\nYes, you're right here. They do provide specifications for those methods. However, they do also (generally) need to be consistent with things in the super categories because those `ParentMethods` will become superclasses. Good programming means we are *generally* consistent here, but there can be good reason to break that.",
    "created_at": "2022-08-19T06:42:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442954",
    "user": "tscrim"
}
```

Replying to [comment:39 mkoeppe]:
> Replying to [comment:34 tscrim]:
> > Replying to [comment:30 mkoeppe]:
> > > Replying to [comment:25 tscrim]:
> > > > If you do not mean it in that way, which is what typically means by "distinguished", then the result of `category()` is irrelevant.
> > > 
> > > Well, the category returned by `category()` is certainly not arbitrary. It determines which methods have been mixed into the parent class (and which methods will be mixed into element classes).
> > 
> > However those are just default implementations to reduce code duplication. 
> 
> Hardly. It defines and specifies the required methods and even provides tests for these specifications.

Yes, you're right here. They do provide specifications for those methods. However, they do also (generally) need to be consistent with things in the super categories because those `ParentMethods` will become superclasses. Good programming means we are *generally* consistent here, but there can be good reason to break that.



---

archive/issue_comments_442955.json:
```json
{
    "body": "Replying to [comment:40 tscrim]:\n> the forgetful functor is about *maps*, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.\n\nBut the objects have a distinguished homset (which is determined by the distinguished category).",
    "created_at": "2022-08-19T06:48:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442955",
    "user": "mkoeppe"
}
```

Replying to [comment:40 tscrim]:
> the forgetful functor is about *maps*, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.

But the objects have a distinguished homset (which is determined by the distinguished category).



---

archive/issue_comments_442956.json:
```json
{
    "body": "Replying to [comment:40 tscrim]:\n> Replying to [comment:36 mkoeppe]:\n> > Replying to [comment:29 tscrim]:\n> > > something along the lines of \"but equality as rings is different\". \n> > \n> > Yes, because equality as XYZ is a statement about maps in the category XYZ.\n\n... namely the identity map.",
    "created_at": "2022-08-19T06:49:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442956",
    "user": "mkoeppe"
}
```

Replying to [comment:40 tscrim]:
> Replying to [comment:36 mkoeppe]:
> > Replying to [comment:29 tscrim]:
> > > something along the lines of "but equality as rings is different". 
> > 
> > Yes, because equality as XYZ is a statement about maps in the category XYZ.

... namely the identity map.



---

archive/issue_comments_442957.json:
```json
{
    "body": "Replying to [comment:40 tscrim]:\n> > Completely unrelated to the \"equality of representations\" issues that you talked about.\n> \n> So `==` should always be mathematical equality, in some definition that you have not made precise?\n\nThe coercion system is in charge of this, it defines (up to implementation restrictions and bugs) our model of \"equality\". \n\nNo changes to it are necessary, nor do I propose changes to it.",
    "created_at": "2022-08-19T06:51:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442957",
    "user": "mkoeppe"
}
```

Replying to [comment:40 tscrim]:
> > Completely unrelated to the "equality of representations" issues that you talked about.
> 
> So `==` should always be mathematical equality, in some definition that you have not made precise?

The coercion system is in charge of this, it defines (up to implementation restrictions and bugs) our model of "equality". 

No changes to it are necessary, nor do I propose changes to it.



---

archive/issue_comments_442958.json:
```json
{
    "body": "Replying to [comment:43 mkoeppe]:\n> Replying to [comment:40 tscrim]:\n> > the forgetful functor is about *maps*, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.\n> \n> But the objects have a distinguished homset (which is determined by the distinguished category).\n\nNo, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:\n\n```\nsage: Hom(QQ, ZZ)\nSet of Homomorphisms from Rational Field to Integer Ring\nsage: Hom(QQ, ZZ, category=Sets())\nSet of Morphisms from Rational Field to Integer Ring in Category of sets\n```\n",
    "created_at": "2022-08-19T06:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442958",
    "user": "tscrim"
}
```

Replying to [comment:43 mkoeppe]:
> Replying to [comment:40 tscrim]:
> > the forgetful functor is about *maps*, not the objects. The category for the morphisms should change, but the objects do not need to change. You just no longer want to perform certain operations.
> 
> But the objects have a distinguished homset (which is determined by the distinguished category).

No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:

```
sage: Hom(QQ, ZZ)
Set of Homomorphisms from Rational Field to Integer Ring
sage: Hom(QQ, ZZ, category=Sets())
Set of Morphisms from Rational Field to Integer Ring in Category of sets
```




---

archive/issue_comments_442959.json:
```json
{
    "body": "Replying to [comment:41 tscrim]:\n> > #34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all\n> \n> We can do this, but that is just some semantic sugar \n\n... that's a new one, yes, functors do provide semantic sugar which enables composability.",
    "created_at": "2022-08-19T06:56:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442959",
    "user": "mkoeppe"
}
```

Replying to [comment:41 tscrim]:
> > #34384 makes this functor available systematically as the `ForgetfulFunctor(..., Sets())`. That's all
> 
> We can do this, but that is just some semantic sugar 

... that's a new one, yes, functors do provide semantic sugar which enables composability.



---

archive/issue_comments_442960.json:
```json
{
    "body": "Replying to [comment:46 tscrim]:\n> Replying to [comment:43 mkoeppe]:\n> > But the objects have a distinguished homset (which is determined by the distinguished category).\n> \n> No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:\n> {{{\n> sage: Hom(QQ, ZZ)\n> Set of Homomorphisms from Rational Field to Integer Ring\n> }}}\n\nHere the distinguished category determined the default.",
    "created_at": "2022-08-19T06:57:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442960",
    "user": "mkoeppe"
}
```

Replying to [comment:46 tscrim]:
> Replying to [comment:43 mkoeppe]:
> > But the objects have a distinguished homset (which is determined by the distinguished category).
> 
> No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:
> {{{
> sage: Hom(QQ, ZZ)
> Set of Homomorphisms from Rational Field to Integer Ring
> }}}

Here the distinguished category determined the default.



---

archive/issue_comments_442961.json:
```json
{
    "body": "Replying to [comment:45 mkoeppe]:\n> Replying to [comment:40 tscrim]:\n> > > Completely unrelated to the \"equality of representations\" issues that you talked about.\n> > \n> > So `==` should always be mathematical equality, in some definition that you have not made precise?\n> \n> The coercion system is in charge of this, it defines (up to implementation restrictions and bugs) our model of \"equality\". \n\nNot for elements of the same parent or between different parents.\n\n> No changes to it are necessary, nor do I propose changes to it.\n\nYou are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).\n\nIf I have a new ring structure on **Z**, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set, but you are saying it is a bug.",
    "created_at": "2022-08-19T06:59:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442961",
    "user": "tscrim"
}
```

Replying to [comment:45 mkoeppe]:
> Replying to [comment:40 tscrim]:
> > > Completely unrelated to the "equality of representations" issues that you talked about.
> > 
> > So `==` should always be mathematical equality, in some definition that you have not made precise?
> 
> The coercion system is in charge of this, it defines (up to implementation restrictions and bugs) our model of "equality". 

Not for elements of the same parent or between different parents.

> No changes to it are necessary, nor do I propose changes to it.

You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).

If I have a new ring structure on **Z**, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set, but you are saying it is a bug.



---

archive/issue_comments_442962.json:
```json
{
    "body": "Replying to [comment:49 tscrim]:\n> You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).\n\nRead https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254",
    "created_at": "2022-08-19T07:02:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442962",
    "user": "mkoeppe"
}
```

Replying to [comment:49 tscrim]:
> You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).

Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254



---

archive/issue_comments_442963.json:
```json
{
    "body": "Replying to [comment:48 mkoeppe]:\n> Replying to [comment:46 tscrim]:\n> > Replying to [comment:43 mkoeppe]:\n> > > But the objects have a distinguished homset (which is determined by the distinguished category).\n> > \n> > No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:\n> > {{{\n> > sage: Hom(QQ, ZZ)\n> > Set of Homomorphisms from Rational Field to Integer Ring\n> > }}}\n> \n> Here the distinguished category determined the default.\n\nMathematically, any homset should also take the category as input. We just usually suppress it from notion as context determines, just like what is done here. Now I will concede that applying the forgetful functor should make it clear what category we want to do it in, but that is just breaking the syntactic (semantic?) sugar. You would rather try to solve an impossible problem than simply telling the user to type fewer characters with a more intuitive semantic?",
    "created_at": "2022-08-19T07:10:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442963",
    "user": "tscrim"
}
```

Replying to [comment:48 mkoeppe]:
> Replying to [comment:46 tscrim]:
> > Replying to [comment:43 mkoeppe]:
> > > But the objects have a distinguished homset (which is determined by the distinguished category).
> > 
> > No, they do not. `Hom` takes a `category` argument to specify the category the morphism belongs to:
> > {{{
> > sage: Hom(QQ, ZZ)
> > Set of Homomorphisms from Rational Field to Integer Ring
> > }}}
> 
> Here the distinguished category determined the default.

Mathematically, any homset should also take the category as input. We just usually suppress it from notion as context determines, just like what is done here. Now I will concede that applying the forgetful functor should make it clear what category we want to do it in, but that is just breaking the syntactic (semantic?) sugar. You would rather try to solve an impossible problem than simply telling the user to type fewer characters with a more intuitive semantic?



---

archive/issue_comments_442964.json:
```json
{
    "body": "Replying to [comment:49 tscrim]:\n> If I have a new ring structure on **Z**, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set\n\nI wouldn't say that it's fine and proper; I'd say there is an implementation restriction that stops us from detecting that they are equal. Sage is of course full of such implementation restrictions. \n\nA proper implementation of the forgetful functor will improve this situation: It removes the implementation restriction.",
    "created_at": "2022-08-19T07:11:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442964",
    "user": "mkoeppe"
}
```

Replying to [comment:49 tscrim]:
> If I have a new ring structure on **Z**, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set

I wouldn't say that it's fine and proper; I'd say there is an implementation restriction that stops us from detecting that they are equal. Sage is of course full of such implementation restrictions. 

A proper implementation of the forgetful functor will improve this situation: It removes the implementation restriction.



---

archive/issue_comments_442965.json:
```json
{
    "body": "Replying to [comment:51 tscrim]:\n> Now I will concede that applying the forgetful functor should make it clear what category we want to do it in\n\nYes, in particular because after applying it, the distinguished category has changed. We can just call the method `.category()` if we want to know it.",
    "created_at": "2022-08-19T07:14:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442965",
    "user": "mkoeppe"
}
```

Replying to [comment:51 tscrim]:
> Now I will concede that applying the forgetful functor should make it clear what category we want to do it in

Yes, in particular because after applying it, the distinguished category has changed. We can just call the method `.category()` if we want to know it.



---

archive/issue_comments_442966.json:
```json
{
    "body": "Replying to [comment:50 mkoeppe]:\n> Replying to [comment:49 tscrim]:\n> > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).\n> \n> Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254\n\nThis is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.",
    "created_at": "2022-08-19T07:14:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442966",
    "user": "tscrim"
}
```

Replying to [comment:50 mkoeppe]:
> Replying to [comment:49 tscrim]:
> > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).
> 
> Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254

This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.



---

archive/issue_comments_442967.json:
```json
{
    "body": "Replying to [comment:54 tscrim]:\n> Replying to [comment:50 mkoeppe]:\n> > Replying to [comment:49 tscrim]:\n> > > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).\n> > \n> > Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254\n> \n> This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.\n\nThe comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.",
    "created_at": "2022-08-19T07:16:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442967",
    "user": "mkoeppe"
}
```

Replying to [comment:54 tscrim]:
> Replying to [comment:50 mkoeppe]:
> > Replying to [comment:49 tscrim]:
> > > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).
> > 
> > Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254
> 
> This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.

The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.



---

archive/issue_comments_442968.json:
```json
{
    "body": "Replying to [comment:52 mkoeppe]:\n> Replying to [comment:49 tscrim]:\n> > If I have a new ring structure on **Z**, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set\n> \n> I wouldn't say that it's fine and proper; I'd say there is an implementation restriction that stops us from detecting that they are equal. Sage is of course full of such implementation restrictions. \n\nThen the fact that two \"equal\" things are not equal is not a bug. Hence, the fact that forgetful functor does not necessarily return a new object, which could lead to a different `==` implementation, is not a bug.\n\n> A proper implementation of the forgetful functor will improve this situation: It removes the implementation restriction.\n\nNo it does not. If you want `==` as instances of `Set`, you should explicitly make your objects instances of `Set`. It doesn't matter what the category an object belongs to. The implementation is what carries the meaning of `==`. Let the category decide what it wants to do with `__call__`. That is what the forgetful functor does.",
    "created_at": "2022-08-19T07:21:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442968",
    "user": "tscrim"
}
```

Replying to [comment:52 mkoeppe]:
> Replying to [comment:49 tscrim]:
> > If I have a new ring structure on **Z**, lets call it `TT`, then `ZZ == TT` would be `False`. Now if we apply the forgetful functor to them, they would still be false. I am saying this is fine and proper because they are different representations of the same set
> 
> I wouldn't say that it's fine and proper; I'd say there is an implementation restriction that stops us from detecting that they are equal. Sage is of course full of such implementation restrictions. 

Then the fact that two "equal" things are not equal is not a bug. Hence, the fact that forgetful functor does not necessarily return a new object, which could lead to a different `==` implementation, is not a bug.

> A proper implementation of the forgetful functor will improve this situation: It removes the implementation restriction.

No it does not. If you want `==` as instances of `Set`, you should explicitly make your objects instances of `Set`. It doesn't matter what the category an object belongs to. The implementation is what carries the meaning of `==`. Let the category decide what it wants to do with `__call__`. That is what the forgetful functor does.



---

archive/issue_comments_442969.json:
```json
{
    "body": "Replying to [comment:55 mkoeppe]:\n> Replying to [comment:54 tscrim]:\n> > Replying to [comment:50 mkoeppe]:\n> > > Replying to [comment:49 tscrim]:\n> > > > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).\n> > > \n> > > Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254\n> > \n> > This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.\n> \n> The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.\n\nCoercion is not involved:\n\n```python\n    Category.__call__(self, x, *args, **opts):\n        if x in self:\n            return x\n        return self._call_(x, *args, **opts)\n```\n",
    "created_at": "2022-08-19T07:23:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442969",
    "user": "tscrim"
}
```

Replying to [comment:55 mkoeppe]:
> Replying to [comment:54 tscrim]:
> > Replying to [comment:50 mkoeppe]:
> > > Replying to [comment:49 tscrim]:
> > > > You are implicitly changing the requirements (and hence, the definition) by calling something a bug that IMSO should not be (nor has it previously been considered to be AFAIK).
> > > 
> > > Read https://github.com/sagemath/sage/blob/develop/src/sage/categories/sets_cat.py#L254
> > 
> > This is not evidence of anything about a general bug for `ForgetfulFunctor`. That is about this category's implementation of `__call__`, which is what `ForgetfulFunctor` does. If `F: C -> D`, then `F(X)` is performs `D(x)`. It is up to each category to impose how it wants to perform its `__call__`, which is an implementation detail.
> 
> The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.

Coercion is not involved:

```python
    Category.__call__(self, x, *args, **opts):
        if x in self:
            return x
        return self._call_(x, *args, **opts)
```




---

archive/issue_comments_442970.json:
```json
{
    "body": "Replying to [comment:57 tscrim]:\n> > The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.\n> \n> Coercion is not involved:\n> {{{#!python\n>     Category.__call__(self, x, *args, **opts):\n>         if x in self:\n>             return x\n>         return self._call_(x, *args, **opts)\n> }}}\n\nThe comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.",
    "created_at": "2022-08-19T07:26:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442970",
    "user": "mkoeppe"
}
```

Replying to [comment:57 tscrim]:
> > The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.
> 
> Coercion is not involved:
> {{{#!python
>     Category.__call__(self, x, *args, **opts):
>         if x in self:
>             return x
>         return self._call_(x, *args, **opts)
> }}}

The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.



---

archive/issue_comments_442971.json:
```json
{
    "body": "Replying to [comment:58 mkoeppe]:\n> Replying to [comment:57 tscrim]:\n> > > The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.\n> > \n> > Coercion is not involved:\n> > {{{#!python\n> >     Category.__call__(self, x, *args, **opts):\n> >         if x in self:\n> >             return x\n> >         return self._call_(x, *args, **opts)\n> > }}}\n> \n> The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.\n\nThe coercion system is not mentioned in the note or in any of the relevant code.\n\nThe documentation of `Category__call__` even specifies:\n\n```\n        If ``x`` is readily in ``self`` it is returned unchanged.\n        Categories wishing to extend this minimal behavior should\n        implement :meth:`._call_`.\n```\n\nThis is further direct documentation evidence that even categories do not want to change objects of subcategories. This is not a bug.",
    "created_at": "2022-08-19T07:30:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442971",
    "user": "tscrim"
}
```

Replying to [comment:58 mkoeppe]:
> Replying to [comment:57 tscrim]:
> > > The comment explains that a category does *not* have this choice because the coercion system dictates that `__call__` passes through its input if it is already in the category.
> > 
> > Coercion is not involved:
> > {{{#!python
> >     Category.__call__(self, x, *args, **opts):
> >         if x in self:
> >             return x
> >         return self._call_(x, *args, **opts)
> > }}}
> 
> The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.

The coercion system is not mentioned in the note or in any of the relevant code.

The documentation of `Category__call__` even specifies:

```
        If ``x`` is readily in ``self`` it is returned unchanged.
        Categories wishing to extend this minimal behavior should
        implement :meth:`._call_`.
```

This is further direct documentation evidence that even categories do not want to change objects of subcategories. This is not a bug.



---

archive/issue_comments_442972.json:
```json
{
    "body": "Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.",
    "created_at": "2022-08-19T07:37:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442972",
    "user": "mkoeppe"
}
```

Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.



---

archive/issue_comments_442973.json:
```json
{
    "body": "Replying to [comment:59 tscrim]:\n> > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.\n> \n> The coercion system is not mentioned in the note or in any of the relevant code.\n\nWell, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.",
    "created_at": "2022-08-19T07:38:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442973",
    "user": "mkoeppe"
}
```

Replying to [comment:59 tscrim]:
> > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> 
> The coercion system is not mentioned in the note or in any of the relevant code.

Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.



---

archive/issue_comments_442974.json:
```json
{
    "body": "Replying to [comment:60 mkoeppe]:\n> Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.\n\nRight, that is my point. The `ForgetfulFunctor` goes through that for objects. This was clearly the intended behaviour.",
    "created_at": "2022-08-19T07:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442974",
    "user": "tscrim"
}
```

Replying to [comment:60 mkoeppe]:
> Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.

Right, that is my point. The `ForgetfulFunctor` goes through that for objects. This was clearly the intended behaviour.



---

archive/issue_comments_442975.json:
```json
{
    "body": "Replying to [comment:61 mkoeppe]:\n> Replying to [comment:59 tscrim]:\n> > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.\n> > \n> > The coercion system is not mentioned in the note or in any of the relevant code.\n> \n> Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.\n\nThis makes no sense to me. The coercion system, which only operates on *elements*, makes no requirements on the syntax nor semantics of `__call__`, much less for things that are not parents (as a way of creating elements).",
    "created_at": "2022-08-19T07:43:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442975",
    "user": "tscrim"
}
```

Replying to [comment:61 mkoeppe]:
> Replying to [comment:59 tscrim]:
> > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> > 
> > The coercion system is not mentioned in the note or in any of the relevant code.
> 
> Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.

This makes no sense to me. The coercion system, which only operates on *elements*, makes no requirements on the syntax nor semantics of `__call__`, much less for things that are not parents (as a way of creating elements).



---

archive/issue_comments_442976.json:
```json
{
    "body": "Replying to [comment:62 tscrim]:\n> Replying to [comment:60 mkoeppe]:\n> > Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.\n> \n> Right, that is my point. The `ForgetfulFunctor` goes through that for objects. This was clearly the intended behaviour.\n\nNo, the `ForgetfulFunctor` is just not fully implemented. \n\nIt does not even have its own `_apply_functor` method, it is just taking the one from `Functor`.\n\nAnd this code is from 2010, whereas the comment in `sets_cat.py` regarding the lack of \"proper forgetful functors\" is from 2015.",
    "created_at": "2022-08-19T07:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442976",
    "user": "mkoeppe"
}
```

Replying to [comment:62 tscrim]:
> Replying to [comment:60 mkoeppe]:
> > Note it says `_call_`, not `__call__`. Categories *cannot* override the `if x in self: return x`.
> 
> Right, that is my point. The `ForgetfulFunctor` goes through that for objects. This was clearly the intended behaviour.

No, the `ForgetfulFunctor` is just not fully implemented. 

It does not even have its own `_apply_functor` method, it is just taking the one from `Functor`.

And this code is from 2010, whereas the comment in `sets_cat.py` regarding the lack of "proper forgetful functors" is from 2015.



---

archive/issue_comments_442977.json:
```json
{
    "body": "Replying to [comment:63 tscrim]:\n> Replying to [comment:61 mkoeppe]:\n> > Replying to [comment:59 tscrim]:\n> > > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.\n> > > \n> > > The coercion system is not mentioned in the note or in any of the relevant code.\n> > \n> > Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.\n> \n> This makes no sense to me. The coercion system, which only operates on *elements* [...]\n\nTo me the \"coercion system\" includes the functorial constructions for parents etc. It won't be useful to discuss this terminology.",
    "created_at": "2022-08-19T07:51:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442977",
    "user": "mkoeppe"
}
```

Replying to [comment:63 tscrim]:
> Replying to [comment:61 mkoeppe]:
> > Replying to [comment:59 tscrim]:
> > > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> > > 
> > > The coercion system is not mentioned in the note or in any of the relevant code.
> > 
> > Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.
> 
> This makes no sense to me. The coercion system, which only operates on *elements* [...]

To me the "coercion system" includes the functorial constructions for parents etc. It won't be useful to discuss this terminology.



---

archive/issue_comments_442978.json:
```json
{
    "body": "Replying to [comment:64 mkoeppe]:\n> And this code is from 2010, whereas the comment in `sets_cat.py` regarding the lack of \"proper forgetful functors\" is from 2015.\n\nI have to take this back, this was very superficial archeology",
    "created_at": "2022-08-19T07:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442978",
    "user": "mkoeppe"
}
```

Replying to [comment:64 mkoeppe]:
> And this code is from 2010, whereas the comment in `sets_cat.py` regarding the lack of "proper forgetful functors" is from 2015.

I have to take this back, this was very superficial archeology



---

archive/issue_comments_442979.json:
```json
{
    "body": "The relevant commit is \n\n```\ncommit 2187d6d8a9ab3ef08a83225c24107055ba3d43a4\nAuthor: Florent Hivert <Florent.Hivert@univ-rouen.fr>\nDate:   Sat Nov 27 19:39:43 2010 +0100\n\n    #8925: add __call__ to categories Sets() and EnumeratedSets().\n```\n",
    "created_at": "2022-08-19T07:59:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442979",
    "user": "mkoeppe"
}
```

The relevant commit is 

```
commit 2187d6d8a9ab3ef08a83225c24107055ba3d43a4
Author: Florent Hivert <Florent.Hivert@univ-rouen.fr>
Date:   Sat Nov 27 19:39:43 2010 +0100

    #8925: add __call__ to categories Sets() and EnumeratedSets().
```




---

archive/issue_comments_442980.json:
```json
{
    "body": "The `ForgetfulFunctor` predates that. It is from\n\n```\ncommit d43bc53b7e73b54600ed8df563849dc7817d5d41\nAuthor: Simon King <simon.king@nuigalway.ie>\nDate:   Fri Apr 30 14:56:16 2010 +0100\n\n    #8807: Implement induced ring homomorphisms. Extend the functor framework, so that functors can be applied to morphisms.\n```\n\nand earlier.",
    "created_at": "2022-08-19T08:01:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442980",
    "user": "mkoeppe"
}
```

The `ForgetfulFunctor` predates that. It is from

```
commit d43bc53b7e73b54600ed8df563849dc7817d5d41
Author: Simon King <simon.king@nuigalway.ie>
Date:   Fri Apr 30 14:56:16 2010 +0100

    #8807: Implement induced ring homomorphisms. Extend the functor framework, so that functors can be applied to morphisms.
```

and earlier.



---

archive/issue_comments_442981.json:
```json
{
    "body": "Replying to [comment:65 mkoeppe]:\n> Replying to [comment:63 tscrim]:\n> > Replying to [comment:61 mkoeppe]:\n> > > Replying to [comment:59 tscrim]:\n> > > > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.\n> > > > \n> > > > The coercion system is not mentioned in the note or in any of the relevant code.\n> > > \n> > > Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.\n> > \n> > This makes no sense to me. The coercion system, which only operates on *elements* [...]\n> \n> To me the \"coercion system\" includes the functorial constructions for parents etc. It won't be useful to discuss this terminology.\n\nThe term \"coercion system\" has a clear set meaning within Sage. I agree the terminology you use is not important, but it will cause confusion if it conflicts with something else.\n\nThat being said, I don't think there are any set rules like the ones you are trying to invoke. All that is required is the output of any functor is some object that is in the category. Just like applying a morphism only requires that the result is an element the parent codomain, not that it needs to have a specific implementation. Sometimes this can cause some headaches, but those are the things the user needs to be wary of.",
    "created_at": "2022-08-19T08:02:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442981",
    "user": "tscrim"
}
```

Replying to [comment:65 mkoeppe]:
> Replying to [comment:63 tscrim]:
> > Replying to [comment:61 mkoeppe]:
> > > Replying to [comment:59 tscrim]:
> > > > > The comment is saying that the `__call__` method of a category cannot implement the forgetful behavior. Because that would violate the guarantees of the coercion system.
> > > > 
> > > > The coercion system is not mentioned in the note or in any of the relevant code.
> > > 
> > > Well, `__call__` is in charge of implementing coercion, so it is subject to the guarantees of the coercion system.
> > 
> > This makes no sense to me. The coercion system, which only operates on *elements* [...]
> 
> To me the "coercion system" includes the functorial constructions for parents etc. It won't be useful to discuss this terminology.

The term "coercion system" has a clear set meaning within Sage. I agree the terminology you use is not important, but it will cause confusion if it conflicts with something else.

That being said, I don't think there are any set rules like the ones you are trying to invoke. All that is required is the output of any functor is some object that is in the category. Just like applying a morphism only requires that the result is an element the parent codomain, not that it needs to have a specific implementation. Sometimes this can cause some headaches, but those are the things the user needs to be wary of.



---

archive/issue_comments_442982.json:
```json
{
    "body": "Replying to [comment:69 tscrim]:\n> I don't think there are any set rules like the ones you are trying to invoke.\n\nCan you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit? For reference again:\n\n           Using `Sets()(A)` used to implement some sort of forgetful functor\n           into the `Sets()` category. This feature has been removed, because\n           it was not consistent with the semantic of `Category.__call__`.\n           Proper forgetful functors will eventually be implemented, with\n           another syntax.",
    "created_at": "2022-08-19T08:04:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442982",
    "user": "mkoeppe"
}
```

Replying to [comment:69 tscrim]:
> I don't think there are any set rules like the ones you are trying to invoke.

Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit? For reference again:

           Using `Sets()(A)` used to implement some sort of forgetful functor
           into the `Sets()` category. This feature has been removed, because
           it was not consistent with the semantic of `Category.__call__`.
           Proper forgetful functors will eventually be implemented, with
           another syntax.



---

archive/issue_comments_442983.json:
```json
{
    "body": "And `Category.__call__` is unambiguous:\n\n        If `x` is readily in `self` it is returned unchanged.\n        Categories wishing to extend this minimal behavior should\n        implement `_call_`.\n\n\"extending\" this minimal behavior means to do more things when `x` is *not* in `self`.\n(`Category._call_` just raises `NotImplementedError`.)",
    "created_at": "2022-08-19T08:08:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442983",
    "user": "mkoeppe"
}
```

And `Category.__call__` is unambiguous:

        If `x` is readily in `self` it is returned unchanged.
        Categories wishing to extend this minimal behavior should
        implement `_call_`.

"extending" this minimal behavior means to do more things when `x` is *not* in `self`.
(`Category._call_` just raises `NotImplementedError`.)



---

archive/issue_comments_442984.json:
```json
{
    "body": "Replying to [comment:70 mkoeppe]:\n> Replying to [comment:69 tscrim]:\n> > I don't think there are any set rules like the ones you are trying to invoke.\n> \n> Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?\n\nI don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`, where the codomain of the (forgetful) functor `F` is `Sets()`.\n\nI agree fully with the first part; it was inconsistent. I don't know what Florent was intending by the word \"proper\" for the latter part; in particular the semantics on the result. However, I am very wary of changing current allowed behaviors (and definitions) in ways that says we should try to solve impossible problems with huge maintenance burdens in our code base.",
    "created_at": "2022-08-19T08:14:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442984",
    "user": "tscrim"
}
```

Replying to [comment:70 mkoeppe]:
> Replying to [comment:69 tscrim]:
> > I don't think there are any set rules like the ones you are trying to invoke.
> 
> Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?

I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`, where the codomain of the (forgetful) functor `F` is `Sets()`.

I agree fully with the first part; it was inconsistent. I don't know what Florent was intending by the word "proper" for the latter part; in particular the semantics on the result. However, I am very wary of changing current allowed behaviors (and definitions) in ways that says we should try to solve impossible problems with huge maintenance burdens in our code base.



---

archive/issue_comments_442985.json:
```json
{
    "body": "Replying to [comment:72 tscrim]:\n> try to solve impossible problems with huge maintenance burdens in our code base.\n\nI have disputed this.",
    "created_at": "2022-08-19T08:19:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442985",
    "user": "mkoeppe"
}
```

Replying to [comment:72 tscrim]:
> try to solve impossible problems with huge maintenance burdens in our code base.

I have disputed this.



---

archive/issue_comments_442986.json:
```json
{
    "body": "Replying to [comment:72 tscrim]:\n> Replying to [comment:70 mkoeppe]:\n> > Replying to [comment:69 tscrim]:\n> > > I don't think there are any set rules like the ones you are trying to invoke.\n> > \n> > Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?\n> \n> I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`\n\nBut `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.",
    "created_at": "2022-08-19T08:21:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442986",
    "user": "mkoeppe"
}
```

Replying to [comment:72 tscrim]:
> Replying to [comment:70 mkoeppe]:
> > Replying to [comment:69 tscrim]:
> > > I don't think there are any set rules like the ones you are trying to invoke.
> > 
> > Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?
> 
> I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`

But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.



---

archive/issue_comments_442987.json:
```json
{
    "body": "Replying to [comment:72 tscrim]:\n> I don't know what Florent was intending by the word \"proper\" for the latter part\n\nYou know, a functor that actually forgets something.",
    "created_at": "2022-08-19T08:22:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442987",
    "user": "mkoeppe"
}
```

Replying to [comment:72 tscrim]:
> I don't know what Florent was intending by the word "proper" for the latter part

You know, a functor that actually forgets something.



---

archive/issue_comments_442988.json:
```json
{
    "body": "Replying to [comment:74 mkoeppe]:\n> Replying to [comment:72 tscrim]:\n> > Replying to [comment:70 mkoeppe]:\n> > > Replying to [comment:69 tscrim]:\n> > > > I don't think there are any set rules like the ones you are trying to invoke.\n> > > \n> > > Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?\n> > \n> > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`\n> \n> But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.\n\nNot for the image of functors; that is only the `Category.__call__`. For the implementation of `ForgetfulFunctor`, it was chosen to just do the result of `Category.__call__`. In fact, the `NOTE:` in `Functor._apply_functor` indicates that subclasses are allowed to change the default behavior to suit their needs.",
    "created_at": "2022-08-19T08:29:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442988",
    "user": "tscrim"
}
```

Replying to [comment:74 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > Replying to [comment:70 mkoeppe]:
> > > Replying to [comment:69 tscrim]:
> > > > I don't think there are any set rules like the ones you are trying to invoke.
> > > 
> > > Can you clarify - you are disagreeing with the comment in sets_cat.py from Florent's commit?
> > 
> > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`
> 
> But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.

Not for the image of functors; that is only the `Category.__call__`. For the implementation of `ForgetfulFunctor`, it was chosen to just do the result of `Category.__call__`. In fact, the `NOTE:` in `Functor._apply_functor` indicates that subclasses are allowed to change the default behavior to suit their needs.



---

archive/issue_comments_442989.json:
```json
{
    "body": "Replying to [comment:76 tscrim]:\n> > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`\n> > \n> > But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.\n> \n> Not for the image of functors; that is only the `Category.__call__`.\n\nSorry, I misread what you wrote",
    "created_at": "2022-08-19T08:31:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442989",
    "user": "mkoeppe"
}
```

Replying to [comment:76 tscrim]:
> > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. As far as I know, we don't have any requirements other than `F(X) in Sets()` returns `True`
> > 
> > But `Category.__call__` (comment:71) explicitly indicates the behavior when X is already in Sets(). That's the other requirement.
> 
> Not for the image of functors; that is only the `Category.__call__`.

Sorry, I misread what you wrote



---

archive/issue_comments_442990.json:
```json
{
    "body": "Replying to [comment:72 tscrim]:\n> I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. \n\nI thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).\n\nNow an actually interesting question is what exactly the new distinguished category should be. It could be just the codomain of the functor, so for `ForgetfulFunctor(..., Sets())` it would be `Sets()`. However, another choice would be a suitable full subcategory of the codomain. This is what I have implemented in #34384.",
    "created_at": "2022-08-19T08:40:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442990",
    "user": "mkoeppe"
}
```

Replying to [comment:72 tscrim]:
> I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 

I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).

Now an actually interesting question is what exactly the new distinguished category should be. It could be just the codomain of the functor, so for `ForgetfulFunctor(..., Sets())` it would be `Sets()`. However, another choice would be a suitable full subcategory of the codomain. This is what I have implemented in #34384.



---

archive/issue_comments_442991.json:
```json
{
    "body": "it's time for another time zone to chime in",
    "created_at": "2022-08-19T08:45:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442991",
    "user": "mkoeppe"
}
```

it's time for another time zone to chime in



---

archive/issue_comments_442992.json:
```json
{
    "body": "I didn't have time to carefully read the whole discussion, yet. But concerning the discussion about \"equality\", here are 2 cents:\n\n`2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings. IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).\n\nThe opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).\n\nAnd that would indeed be difficult to implement.",
    "created_at": "2022-08-19T09:39:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442992",
    "user": "SimonKing"
}
```

I didn't have time to carefully read the whole discussion, yet. But concerning the discussion about "equality", here are 2 cents:

`2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings. IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).

The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).

And that would indeed be difficult to implement.



---

archive/issue_comments_442993.json:
```json
{
    "body": "Replying to [comment:81 SimonKing]:\n> `2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings. IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category).\n\nI agree. I've opened #34390 for this",
    "created_at": "2022-08-19T15:53:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442993",
    "user": "mkoeppe"
}
```

Replying to [comment:81 SimonKing]:
> `2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings. IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category).

I agree. I've opened #34390 for this



---

archive/issue_comments_442994.json:
```json
{
    "body": "Replying to [comment:81 SimonKing]:\n> I didn't have time to carefully read the whole discussion, yet. But concerning the discussion about \"equality\", here are 2 cents:\n> \n> `2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings.\n\nOf course it is true, but it is about do we require that it *must* be true for *any* different representations of the same element in some parent. This is just a very simple example where there can be multiple different ways of writing the same element. In this case, we know what a canonical representation is for fractions. However, this is not true for all objects (e.g., finitely presented groups).\n\n> IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).\n\nHow would you deal with sets that are equal but with different implementations that do not have a conversion (much less a coercion) between them? Following your premise, this would be a bug, which would need to be fixed. To make this even more difficult, you would not want a coercion because the parents have fundamentally different structures. How do we fix this?\n\nWhat about more abstract parents? Should all three dimensional free modules over a field `k` be equal since they all could be considered as `k`<sup>3</sup> (in particular, by the method `to_vector()` in `ModulesWithBasis()`)? How do we even want to decide?\n\n> The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).\n> \n> And that would indeed be difficult to implement.\n\nI would say nearly impossible resulting in any ticket with a new feature would basically be introducing bugs. This is making the specification of `==` way too strict.",
    "created_at": "2022-08-20T05:13:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442994",
    "user": "tscrim"
}
```

Replying to [comment:81 SimonKing]:
> I didn't have time to carefully read the whole discussion, yet. But concerning the discussion about "equality", here are 2 cents:
> 
> `2==4/2` is true, when `ZZ` and `QQ` are considered as rings, because there is a coercion from `ZZ` to `QQ` that is a morphism in the category of rings.

Of course it is true, but it is about do we require that it *must* be true for *any* different representations of the same element in some parent. This is just a very simple example where there can be multiple different ways of writing the same element. In this case, we know what a canonical representation is for fractions. However, this is not true for all objects (e.g., finitely presented groups).

> IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).

How would you deal with sets that are equal but with different implementations that do not have a conversion (much less a coercion) between them? Following your premise, this would be a bug, which would need to be fixed. To make this even more difficult, you would not want a coercion because the parents have fundamentally different structures. How do we fix this?

What about more abstract parents? Should all three dimensional free modules over a field `k` be equal since they all could be considered as `k`<sup>3</sup> (in particular, by the method `to_vector()` in `ModulesWithBasis()`)? How do we even want to decide?

> The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).
> 
> And that would indeed be difficult to implement.

I would say nearly impossible resulting in any ticket with a new feature would basically be introducing bugs. This is making the specification of `==` way too strict.



---

archive/issue_comments_442995.json:
```json
{
    "body": "Replying to [comment:78 mkoeppe]:\n> Replying to [comment:72 tscrim]:\n> > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. \n> \n> I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).\n\nYou need to pick your definition of \"distinguished\" as you are going between \"this is an object in this category\" and \"this category is just considered special to this object\" when it suits you. If the category is just special, then no new object needs to be returned because it still is an object in that category.\n\n> Now an actually interesting question is what exactly the new distinguished category should be. It could be just the codomain of the functor, so for `ForgetfulFunctor(..., Sets())` it would be `Sets()`. However, another choice would be a suitable full subcategory of the codomain. This is what I have implemented in #34384.\n\nIf we do this (which I continue to remain staunchy opposed to), it must be in the codomain `C`, e.g., `Sets`, not some full subcategory `C'`. Otherwise, strictly speaking, you could not build a natural homset to some other object in `C \\ C'`.",
    "created_at": "2022-08-20T05:19:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442995",
    "user": "tscrim"
}
```

Replying to [comment:78 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 
> 
> I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).

You need to pick your definition of "distinguished" as you are going between "this is an object in this category" and "this category is just considered special to this object" when it suits you. If the category is just special, then no new object needs to be returned because it still is an object in that category.

> Now an actually interesting question is what exactly the new distinguished category should be. It could be just the codomain of the functor, so for `ForgetfulFunctor(..., Sets())` it would be `Sets()`. However, another choice would be a suitable full subcategory of the codomain. This is what I have implemented in #34384.

If we do this (which I continue to remain staunchy opposed to), it must be in the codomain `C`, e.g., `Sets`, not some full subcategory `C'`. Otherwise, strictly speaking, you could not build a natural homset to some other object in `C \ C'`.



---

archive/issue_comments_442996.json:
```json
{
    "body": "Replying to [comment:75 mkoeppe]:\n> Replying to [comment:72 tscrim]:\n> > I don't know what Florent was intending by the word \"proper\" for the latter part\n> \n> You know, a functor that actually forgets something.\n\nYes, that is what it should do on the morphisms. *That* is the only bug. Not on the objects.",
    "created_at": "2022-08-20T05:20:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442996",
    "user": "tscrim"
}
```

Replying to [comment:75 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > I don't know what Florent was intending by the word "proper" for the latter part
> 
> You know, a functor that actually forgets something.

Yes, that is what it should do on the morphisms. *That* is the only bug. Not on the objects.



---

archive/issue_comments_442997.json:
```json
{
    "body": "Replying to [comment:73 mkoeppe]:\n> Replying to [comment:72 tscrim]:\n> > try to solve impossible problems with huge maintenance burdens in our code base.\n> \n> I have disputed this.\n\nNo, you haven't. You haven't explained why we don't have to implement a new object for every image of every forgetful functor. Or why we don't have to deal with comparisons of elements in each of these new parents. Or why we don't have to make sure that every functor also always returns an object with a distinguished category of the codomain. Or how you will deal with these backwards incompatible changes.",
    "created_at": "2022-08-20T05:24:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442997",
    "user": "tscrim"
}
```

Replying to [comment:73 mkoeppe]:
> Replying to [comment:72 tscrim]:
> > try to solve impossible problems with huge maintenance burdens in our code base.
> 
> I have disputed this.

No, you haven't. You haven't explained why we don't have to implement a new object for every image of every forgetful functor. Or why we don't have to deal with comparisons of elements in each of these new parents. Or why we don't have to make sure that every functor also always returns an object with a distinguished category of the codomain. Or how you will deal with these backwards incompatible changes.



---

archive/issue_comments_442998.json:
```json
{
    "body": "Sorry, Travis, \"you have to implement everything or you are not allowed to implement anything\" is a pretty absurd take.",
    "created_at": "2022-08-20T05:48:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442998",
    "user": "mkoeppe"
}
```

Sorry, Travis, "you have to implement everything or you are not allowed to implement anything" is a pretty absurd take.



---

archive/issue_comments_442999.json:
```json
{
    "body": "Replying to [comment:87 tscrim]:\n> Or how you will deal with these backwards incompatible changes.\n\nSee comment:67, comment:68. `ForgetfulFunctor` was broken in 2010, it has not been forgetting anything since. So I don't think there is a need to worry about scary backwards incompatible changes.",
    "created_at": "2022-08-20T05:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-442999",
    "user": "mkoeppe"
}
```

Replying to [comment:87 tscrim]:
> Or how you will deal with these backwards incompatible changes.

See comment:67, comment:68. `ForgetfulFunctor` was broken in 2010, it has not been forgetting anything since. So I don't think there is a need to worry about scary backwards incompatible changes.



---

archive/issue_comments_443000.json:
```json
{
    "body": "I am explaining the maintenance burden you are placing on us by making this change of specification. It's like saying \"I don't like how these cars look, so I am going to completely rewrite the traffic laws but not tell you how to comply with them.\"",
    "created_at": "2022-08-20T05:56:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443000",
    "user": "tscrim"
}
```

I am explaining the maintenance burden you are placing on us by making this change of specification. It's like saying "I don't like how these cars look, so I am going to completely rewrite the traffic laws but not tell you how to comply with them."



---

archive/issue_comments_443001.json:
```json
{
    "body": "Replying to [comment:85 tscrim]:\n> Replying to [comment:78 mkoeppe]:\n> > Replying to [comment:72 tscrim]:\n> > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. \n> > \n> > I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).\n> \n> You need to pick your definition of \"distinguished\" as you are going between \"this is an object in this category\" and \"this category is just considered special to this object\" when it suits you.\n\nNo, Travis, I have been using my terminology consistently. The distinguished category is the one that `.category()` returns.",
    "created_at": "2022-08-20T05:57:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443001",
    "user": "mkoeppe"
}
```

Replying to [comment:85 tscrim]:
> Replying to [comment:78 mkoeppe]:
> > Replying to [comment:72 tscrim]:
> > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 
> > 
> > I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).
> 
> You need to pick your definition of "distinguished" as you are going between "this is an object in this category" and "this category is just considered special to this object" when it suits you.

No, Travis, I have been using my terminology consistently. The distinguished category is the one that `.category()` returns.



---

archive/issue_comments_443002.json:
```json
{
    "body": "Replying to [comment:89 mkoeppe]:\n> Replying to [comment:87 tscrim]:\n> > Or how you will deal with these backwards incompatible changes.\n> \n> See comment:67, comment:68. `ForgetfulFunctor` was broken in 2010, it has not been forgetting anything since. So I don't think there is a need to worry about scary backwards incompatible changes.\n\nBut they are not broken when acting on objects. You want to change the specifications to make it into a bug.",
    "created_at": "2022-08-20T05:57:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443002",
    "user": "tscrim"
}
```

Replying to [comment:89 mkoeppe]:
> Replying to [comment:87 tscrim]:
> > Or how you will deal with these backwards incompatible changes.
> 
> See comment:67, comment:68. `ForgetfulFunctor` was broken in 2010, it has not been forgetting anything since. So I don't think there is a need to worry about scary backwards incompatible changes.

But they are not broken when acting on objects. You want to change the specifications to make it into a bug.



---

archive/issue_comments_443003.json:
```json
{
    "body": "Our `Parent`s (or any `CategoryObject`s are not just \"objects in a category\". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.",
    "created_at": "2022-08-20T05:59:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443003",
    "user": "mkoeppe"
}
```

Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.



---

archive/issue_comments_443004.json:
```json
{
    "body": "Replying to [comment:91 mkoeppe]:\n> Replying to [comment:85 tscrim]:\n> > Replying to [comment:78 mkoeppe]:\n> > > Replying to [comment:72 tscrim]:\n> > > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. \n> > > \n> > > I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).\n> > \n> > You need to pick your definition of \"distinguished\" as you are going between \"this is an object in this category\" and \"this category is just considered special to this object\" when it suits you.\n> \n> No, Travis, I have been using my terminology consistently. The distinguished category is the one that `.category()` returns.\n\nIf it is just some category that has special meaning for the defaults for some inputs, then there is no bug here with `ForgetfulFunctor(ZZ, codomain=Sets())` returning `ZZ`. You don't have to remember about the structure that puts it into `Rings()`. Everything that depends on the category of the object, such as `Hom` has an input for the user to set the category.",
    "created_at": "2022-08-20T06:00:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443004",
    "user": "tscrim"
}
```

Replying to [comment:91 mkoeppe]:
> Replying to [comment:85 tscrim]:
> > Replying to [comment:78 mkoeppe]:
> > > Replying to [comment:72 tscrim]:
> > > > I don't know of any consistency rule you want with the result of `ForgetfulFunctor`. 
> > > 
> > > I thought I explained it. Because our parents are equipped with a distinguished category (i.e., mathematically they are pair of: (1) an object in the category of objects and (2) a category in the category of categories)), when we apply the `ForgetfulFunctor`, we need to return a new parent with a new distinguished category (i.e., mathematically, a pair of (1) new object, (2) new category).
> > 
> > You need to pick your definition of "distinguished" as you are going between "this is an object in this category" and "this category is just considered special to this object" when it suits you.
> 
> No, Travis, I have been using my terminology consistently. The distinguished category is the one that `.category()` returns.

If it is just some category that has special meaning for the defaults for some inputs, then there is no bug here with `ForgetfulFunctor(ZZ, codomain=Sets())` returning `ZZ`. You don't have to remember about the structure that puts it into `Rings()`. Everything that depends on the category of the object, such as `Hom` has an input for the user to set the category.



---

archive/issue_comments_443005.json:
```json
{
    "body": "Replying to [comment:93 mkoeppe]:\n> Our `Parent`s (or any `CategoryObject`s are not just \"objects in a category\". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.\n\nThen should every getter method be part of the mathematical definition of the parent? Or every attribute? What makes the category one so special that we need some broad universal rule?\n\nBasically, this leads us right into the absurd. A parent is not modeling this pair.",
    "created_at": "2022-08-20T06:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443005",
    "user": "tscrim"
}
```

Replying to [comment:93 mkoeppe]:
> Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.

Then should every getter method be part of the mathematical definition of the parent? Or every attribute? What makes the category one so special that we need some broad universal rule?

Basically, this leads us right into the absurd. A parent is not modeling this pair.



---

archive/issue_comments_443006.json:
```json
{
    "body": "Replying to [comment:95 tscrim]:\n> Replying to [comment:93 mkoeppe]:\n> > Our `Parent`s (or any `CategoryObject`s are not just \"objects in a category\". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.\n> \n> A parent is not modeling this pair.\n\nWhat do you mean by that?",
    "created_at": "2022-08-20T06:11:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443006",
    "user": "mkoeppe"
}
```

Replying to [comment:95 tscrim]:
> Replying to [comment:93 mkoeppe]:
> > Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.
> 
> A parent is not modeling this pair.

What do you mean by that?



---

archive/issue_comments_443007.json:
```json
{
    "body": "Replying to [comment:96 mkoeppe]:\n> Replying to [comment:95 tscrim]:\n> > Replying to [comment:93 mkoeppe]:\n> > > Our `Parent`s (or any `CategoryObject`s are not just \"objects in a category\". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.\n> > \n> > A parent is not modeling this pair.\n> \n> What do you mean by that?\n\nA parent is just modeling the set of elements. Nothing more, nothing less. It has some things associated to it, such as having a distinguished category, that tells you things you can do on it. However, it is just meant to be the set.",
    "created_at": "2022-08-20T06:16:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443007",
    "user": "tscrim"
}
```

Replying to [comment:96 mkoeppe]:
> Replying to [comment:95 tscrim]:
> > Replying to [comment:93 mkoeppe]:
> > > Our `Parent`s (or any `CategoryObject`s are not just "objects in a category". They are mathematically a pair `(object, category)`. Otherwise, the method `category()` could not exist.
> > 
> > A parent is not modeling this pair.
> 
> What do you mean by that?

A parent is just modeling the set of elements. Nothing more, nothing less. It has some things associated to it, such as having a distinguished category, that tells you things you can do on it. However, it is just meant to be the set.



---

archive/issue_comments_443008.json:
```json
{
    "body": "How do you \"associate\" something with a mathematical set?",
    "created_at": "2022-08-20T06:20:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443008",
    "user": "mkoeppe"
}
```

How do you "associate" something with a mathematical set?



---

archive/issue_comments_443009.json:
```json
{
    "body": "Mathematically, you make a new object as a tuple. However, we are not manipulating such objects. Programmatically, we have attributes that allow us to identify together, e.g., **Z**, (**Z**, `+`), (**Z**, `+`, `*`), (**Z**, `+`, `AdditiveAbelianGroups()`), (**Z**, **Q** via `fraction_field()`), etc. to deal with the ambiguity we very often use because context (and \"trivialities\" or \"well-known facts/identifications\") makes it clear.",
    "created_at": "2022-08-20T06:26:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443009",
    "user": "tscrim"
}
```

Mathematically, you make a new object as a tuple. However, we are not manipulating such objects. Programmatically, we have attributes that allow us to identify together, e.g., **Z**, (**Z**, `+`), (**Z**, `+`, `*`), (**Z**, `+`, `AdditiveAbelianGroups()`), (**Z**, **Q** via `fraction_field()`), etc. to deal with the ambiguity we very often use because context (and "trivialities" or "well-known facts/identifications") makes it clear.



---

archive/issue_comments_443010.json:
```json
{
    "body": "So the `Parent` resolves this ambiguity by storing these \"attributes\" (including the distinguished category), right?",
    "created_at": "2022-08-20T06:28:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443010",
    "user": "mkoeppe"
}
```

So the `Parent` resolves this ambiguity by storing these "attributes" (including the distinguished category), right?



---

archive/issue_comments_443011.json:
```json
{
    "body": "Yes, that is how I see it.",
    "created_at": "2022-08-20T06:34:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443011",
    "user": "tscrim"
}
```

Yes, that is how I see it.



---

archive/issue_comments_443012.json:
```json
{
    "body": "So now a `ForgetfulFunctor` is sneaking around the corner and applies itself to the `Parent`. Do I understand right that you are saying that not only it needs to return the same object, but also that object needs to be equipped with the same unchanged \"attributes\"?",
    "created_at": "2022-08-20T06:37:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443012",
    "user": "mkoeppe"
}
```

So now a `ForgetfulFunctor` is sneaking around the corner and applies itself to the `Parent`. Do I understand right that you are saying that not only it needs to return the same object, but also that object needs to be equipped with the same unchanged "attributes"?



---

archive/issue_comments_443013.json:
```json
{
    "body": "It doesn't have to return the same object, but it can. This is why I have no problem with the change in #34384, but I object to calling it a bug that it does not do it.",
    "created_at": "2022-08-20T06:44:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443013",
    "user": "tscrim"
}
```

It doesn't have to return the same object, but it can. This is why I have no problem with the change in #34384, but I object to calling it a bug that it does not do it.



---

archive/issue_comments_443014.json:
```json
{
    "body": "By object, you now mean `Parent`, right? That is object \"associated\" with extra attributes, yes?",
    "created_at": "2022-08-20T06:55:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443014",
    "user": "mkoeppe"
}
```

By object, you now mean `Parent`, right? That is object "associated" with extra attributes, yes?



---

archive/issue_comments_443015.json:
```json
{
    "body": "Yes, that is correct.",
    "created_at": "2022-08-20T07:06:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443015",
    "user": "tscrim"
}
```

Yes, that is correct.



---

archive/issue_comments_443016.json:
```json
{
    "body": "In #34384, I add the new warning:\n\n```\n+            UserWarning: The forgetful functor to Category of commutative additive groups\n+             from Category of commutative rings (a non-full subcategory)\n+             is not properly implemented; see https://trac.sagemath.org/ticket/31247\n```\n\nWhat's your take on this?",
    "created_at": "2022-08-20T07:16:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443016",
    "user": "mkoeppe"
}
```

In #34384, I add the new warning:

```
+            UserWarning: The forgetful functor to Category of commutative additive groups
+             from Category of commutative rings (a non-full subcategory)
+             is not properly implemented; see https://trac.sagemath.org/ticket/31247
```

What's your take on this?



---

archive/issue_comments_443017.json:
```json
{
    "body": "I think it should not be there. It is properly implemented (modulo the morphism issue).",
    "created_at": "2022-08-20T07:22:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443017",
    "user": "tscrim"
}
```

I think it should not be there. It is properly implemented (modulo the morphism issue).



---

archive/issue_comments_443018.json:
```json
{
    "body": "I could change it to `UserWarning: The forgetful functor to Category of commutative additive groups from Category of commutative rings (a non-full subcategory) is technically correct (the best kind of correct), but note that it may be very inconvenient that its result's distinguished category (and hence distinguished homset) has nothing to do with the codomain of the forgetful functor`",
    "created_at": "2022-08-20T07:25:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443018",
    "user": "mkoeppe"
}
```

I could change it to `UserWarning: The forgetful functor to Category of commutative additive groups from Category of commutative rings (a non-full subcategory) is technically correct (the best kind of correct), but note that it may be very inconvenient that its result's distinguished category (and hence distinguished homset) has nothing to do with the codomain of the forgetful functor`



---

archive/issue_comments_443019.json:
```json
{
    "body": "I am still not happy with it as it is giving a bit strong of an implication that this behavior should be changed. I would rather see it as a documentation warning rather than something invoked when the functor is called. However, I am willing to accept it as a compromise with perhaps some minor tweaks to the wording.\n\nAlso, +1.0 on the bureaucratic reference. `;)`",
    "created_at": "2022-08-20T08:16:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443019",
    "user": "tscrim"
}
```

I am still not happy with it as it is giving a bit strong of an implication that this behavior should be changed. I would rather see it as a documentation warning rather than something invoked when the functor is called. However, I am willing to accept it as a compromise with perhaps some minor tweaks to the wording.

Also, +1.0 on the bureaucratic reference. `;)`



---

archive/issue_comments_443020.json:
```json
{
    "body": "Replying to [comment:84 tscrim]:\n> Replying to [comment:81 SimonKing]:\n> > The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).\n> > \n> > And that would indeed be difficult to implement.\n> \n> I would say nearly impossible resulting in any ticket with a new feature would basically be introducing bugs. This is making the specification of `==` way too strict.\n\nYes, the problem of deciding whether a given morphism can be lifted to a subcategory is very hard. For morphisms between finite parents, there would probably be a trivial algorithm, but it would depend on the specific categories whether an efficient algorithm is available. For morphisms between infinite parents, this will often be undecidable.\n\nFortunately, this problem does not need to be solved for this ticket.",
    "created_at": "2022-08-21T17:56:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443020",
    "user": "mkoeppe"
}
```

Replying to [comment:84 tscrim]:
> Replying to [comment:81 SimonKing]:
> > The opposite problem is more tricky. I have no concise example, but I could imagine that there are two rings `(R,+,*)` and `(S,+,*)` such that there is a meaningful coercion map between abelian groups `(R,+)` and `(S,+)` that is not a ring morphism. Hence, if `F` is the forgetful functor from `Rings()` to `AbelianGroups()`, it may very well be possible that there is `a in R` and `b in S` such that `F(R)(a) == F(S)(b)` should evaluate as true (because `a,b` can be coerced as elements of abelian groups), but `a == b` should evaluate as false (because there is no coercion of rings).
> > 
> > And that would indeed be difficult to implement.
> 
> I would say nearly impossible resulting in any ticket with a new feature would basically be introducing bugs. This is making the specification of `==` way too strict.

Yes, the problem of deciding whether a given morphism can be lifted to a subcategory is very hard. For morphisms between finite parents, there would probably be a trivial algorithm, but it would depend on the specific categories whether an efficient algorithm is available. For morphisms between infinite parents, this will often be undecidable.

Fortunately, this problem does not need to be solved for this ticket.



---

archive/issue_comments_443021.json:
```json
{
    "body": "Replying to [comment:84 tscrim]:\n> Replying to [comment:81 SimonKing]:\n> > IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).\n> \n> How would you deal with sets that are equal but with different implementations that do not have a conversion (much less a coercion) between them? Following your premise, this would be a bug, which would need to be fixed. To make this even more difficult, you would not want a coercion because the parents have fundamentally different structures. How do we fix this?\n\nEquality of parents is clearly a very complicated topic that involves multiple issues, at least the following:\n- on the programming level, equality (`==`) vs identity (`is`), `UniqueRepresentation`\n- on the programming level, the hash/equality contract (both on elements and on parents) and its many violations in Sage\n- the semantics of objects \"associated\" with additional attributes \n- the semantics of mutable objects\n\nA general discussion of this topic will not lead very far. But a key question to answer is:\n- What is an identity morphism?\n\nI would say it is at least an injective coercion morphism.\nSo this example by Travis:\n> What about more abstract parents? Should all three dimensional free modules over a field `k` be equal since they all could be considered as `k`<sup>3</sup> (in particular, by the method `to_vector()` in `ModulesWithBasis()`)? How do we even want to decide?\n\nThere would be no coercion morphisms between these modules in general, so the answer would be \"no\". (Yes, the implementation of (ambient) free modules in `sage.modules` does make them `UniqueRepresentation`, so for these there would be a trivial \"yes\".)",
    "created_at": "2022-08-21T18:23:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443021",
    "user": "mkoeppe"
}
```

Replying to [comment:84 tscrim]:
> Replying to [comment:81 SimonKing]:
> > IMHO, it makes sense to request that applying the forgetful functor to a coercion morphism (in a smaller category) yields a coercion morphism (in a larger category). Hence, `2==4/2` should be true also in the category of sets (the usual coercion morphism of rings would be applied as a coercion morphism of sets).
> 
> How would you deal with sets that are equal but with different implementations that do not have a conversion (much less a coercion) between them? Following your premise, this would be a bug, which would need to be fixed. To make this even more difficult, you would not want a coercion because the parents have fundamentally different structures. How do we fix this?

Equality of parents is clearly a very complicated topic that involves multiple issues, at least the following:
- on the programming level, equality (`==`) vs identity (`is`), `UniqueRepresentation`
- on the programming level, the hash/equality contract (both on elements and on parents) and its many violations in Sage
- the semantics of objects "associated" with additional attributes 
- the semantics of mutable objects

A general discussion of this topic will not lead very far. But a key question to answer is:
- What is an identity morphism?

I would say it is at least an injective coercion morphism.
So this example by Travis:
> What about more abstract parents? Should all three dimensional free modules over a field `k` be equal since they all could be considered as `k`<sup>3</sup> (in particular, by the method `to_vector()` in `ModulesWithBasis()`)? How do we even want to decide?

There would be no coercion morphisms between these modules in general, so the answer would be "no". (Yes, the implementation of (ambient) free modules in `sage.modules` does make them `UniqueRepresentation`, so for these there would be a trivial "yes".)



---

archive/issue_comments_443022.json:
```json
{
    "body": "I'd suggest to start discussing this question in a simpler context than equality of parents, namely the specification of an `is_subset` method for (enumerated) sets (#34398). \n\nNaively, `S.is_subset(T)` would be equivalent to `all(x in T for x in S)`. But because `x in T` is subject to the discovery of coercion maps, we can ask for a stricter test than this pointwise test.",
    "created_at": "2022-08-21T18:28:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31010",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31010#issuecomment-443022",
    "user": "mkoeppe"
}
```

I'd suggest to start discussing this question in a simpler context than equality of parents, namely the specification of an `is_subset` method for (enumerated) sets (#34398). 

Naively, `S.is_subset(T)` would be equivalent to `all(x in T for x in S)`. But because `x in T` is subject to the discovery of coercion maps, we can ask for a stricter test than this pointwise test.
