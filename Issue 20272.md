# Issue 20272: khovanov homology of links

Issue created by migration from Trac.

Original creator: mmarco

Original creation time: 2016-04-27 18:44:05

CC:  kcrisman tscrim amitjamadagni jhpalmieri fuglede




---

Comment by mmarco created at 2016-04-27 18:50:12

Changing keywords from "" to "knots".


---

Comment by mmarco created at 2016-04-27 18:50:12

Changing component from PLEASE CHANGE to algebraic topology.


---

Comment by mmarco created at 2016-04-27 18:50:12

Changing status from new to needs_review.


---

Comment by mmarco created at 2016-04-27 18:50:12

New commits:


---

Comment by mmarco created at 2016-04-27 18:50:12

Changing type from PLEASE CHANGE to enhancement.


---

Comment by tscrim created at 2016-04-27 23:05:40

Some comments:

- I don't see the point of having attributes `_smoothing` and `_enhanced_states`, these should be separated out into ``@`cached_method`. Although it seems like `_enhanced_states` is all you really need.
- Instead of `type(_) == tuple`, use `isinstance(_, tuple)`.
- Instead of
  {{{#!python
difs = [_ for _ in range(len(V1[0])) if V1[0][_] != V2[0][_] ]
  }}}
  you can do
  {{{#!python
V20 = V2[0]
difs = [index for index,value in enumerate(V1[0]) if value != V20[index] ]
  }}}
- The output of `khovanov_homology` is mutable, so it should not be cached.


---

Comment by git created at 2016-04-28 08:56:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2016-04-28 09:00:07

I made the suggested changes. I am not entirely happy with the format of the output, but i guess it is the price to pay for caching it.

Also, I would like to have a smarter way to take advantage of caching (for instance, if the whole homology has been computed, don't compute again the smaller pieces, and vice-versa: don't compute the pieces already computed when we compute the whole picture).

Is there a way to get which input values have already been cached?


---

Comment by tscrim created at 2016-04-28 14:52:00

I was thinking the value of `bases` is what should be cached since `states` is just a transient variable.

To get around this recomputing issue, you could have another (private) cached method that computes it on a by-degree basis (perhaps also taking the `height` as input. Thus we can make the user-level accessible function is not cached (and can thus return a `dict` for better usability). Eh...I might have to think a little more on this. I agree that the format is bad. (Another option would be `Family`.)

Also, you can make this change:

```diff
-m[ii,jj] = (-1)**sum([V2[0][_] for _ in range(difs[0]+1, ncross)])
+m[ii,jj] = (-1)**sum(V2[0][difs[0]+1:ncross])
```



---

Comment by mmarco created at 2016-04-28 15:00:35

Indeed, it is the value of "bases" what we reuse, but that is a dictionary, and hence mutable. Again, we could have it in a tuple format and convert it to dictionary each time we recover it.

In general, what to compute and cache each time is quite tricky here. Now we are computing all the bases of the chain complexes once and caching it. So if the user just asks for a given height, we compute a lot that we don't need. Anyways, my experience is that the biggest part of the computation is taken by computing the cohomology of the complexes, so it is not so bad.


---

Comment by jhpalmieri created at 2016-04-28 15:11:46

You could also create a separate class for Khovanov homology, at which point you would have complete control over its output format.


---

Comment by tscrim created at 2016-04-28 16:04:29

Replying to [comment:7 mmarco]:
> Indeed, it is the value of "bases" what we reuse, but that is a dictionary, and hence mutable. Again, we could have it in a tuple format and convert it to dictionary each time we recover it.

In this case, I would say that is okay because user does not see it (but we should put a big warning to any developers to not mutate nor expose it).

> In general, what to compute and cache each time is quite tricky here. Now we are computing all the bases of the chain complexes once and caching it. So if the user just asks for a given height, we compute a lot that we don't need. Anyways, my experience is that the biggest part of the computation is taken by computing the cohomology of the complexes, so it is not so bad.

It is probably worthwhile to see what `%prun` tells us.

However, [comment:8 John's suggestion] of creating a dedicated class for Khovanov homology is probably best because this allows us to (potentially) give it a module structure, have full control over output, better localization of code/caching, and make it more functor-like.


---

Comment by git created at 2016-05-01 13:02:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2016-05-01 13:04:58

I moved the cached part to a private method, that stores only the different heights, and returns tuples. The (now non cached) public method calls this private method to return dictionaries.


---

Comment by tscrim created at 2016-05-05 19:24:38

I did some fixes, simplifications, and cleanup. I think this will work for now, unless you think we should spend a little time now to create a class for the Khovanov homology (mainly a question to John)? Otherwise, if you are okay with my changes, then you can set a positive review.
----
New commits:


---

Comment by jhpalmieri created at 2016-05-05 19:31:19

I don't have strong feelings about a separate class for the homology. I was just suggesting it as an option to give control over the output while allowing caching for the results. So I think it can wait.


---

Comment by mmarco created at 2016-05-06 06:13:53

Thanks for the cleanup. I am ok with the changes.


---

Comment by mmarco created at 2016-05-06 06:14:44

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-05-18 18:21:04

Resolution: fixed
