# Issue 19792: Implement quantum matrix coordinate algebras

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2016-02-09 21:58:59

Assignee: tscrim

CC:  bump buciumas

Keywords: quantum, coordinate ring

We provide a basic implementation of quantum matrix coordinate algebras.


---

Comment by tscrim created at 2016-02-09 21:59:33

New commits:


---

Comment by tscrim created at 2016-02-09 21:59:33

Changing status from new to needs_review.


---

Comment by bump created at 2016-02-23 00:57:08

This bialgebra (if m=n) has a natural comodule, namely the quantum affine space.

Would it be hard to implement that, too? It seems plausible that this could be useful.


---

Comment by bump created at 2016-02-23 01:15:02

Perhaps it would be good to add a reference to Faddeev, Reshetikhin and Takhtajan, Quantization of Lie Groups and Lie Algebras, Leningrad Math. J. vol. 1 no. 1 (1990).

The quantum determinant is described in this paper and there are also bialgebras/Hopf algebras constructed for the other classical types.


---

Comment by buciumas created at 2016-02-23 02:03:37

I looked over the document and it looks good!

I would suggest adding a note saying what q-convention you are using. For example the q squared in your document would be just a q in Chari and Pressley or in Kassel (or FRT for that matter). I think this would save some confusion for people that don't now about this.

Certain things that could be implemented going forward could be an antipode map for GL_q(n) and maybe the same construction for other classical types (see FRT). The quantum determinant is then replaced by the quantum similitude.


---

Comment by tscrim created at 2016-02-23 06:11:15

Thank you both for looking at this!

It's not hard to implement the quantum affine space, but I don't think we currently have a framework for comodules. We do have the basic infrastructure to do this though. However, I agree that this would be a good thing to implement; perhaps on a follow up ticket.

I will add the reference and a note about the q-convention. Does the antipode extend to GL<sub>q</sub>(n)? From FRT (well, at least [Ram's version](http://www.ms.unimelb.edu.au/~ram/Resources/Reshetikhin/QuantizationOfLieGroupsAndLieAlgebras.html)), it is only given for SL<sub>q</sub>(n). Just to let you know, one of my main motivations for implementing this was to look at the crystal basis (see http://arxiv.org/abs/math/0509651).


---

Comment by git created at 2016-02-27 06:18:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-02-27 06:23:54

I've added the FRT reference and the note about the q convention, and I also had come across a small bug with how I was implementing the unique representation behavior that I fixed (and now it takes more general input too). I also added commented code for the antipode once we implement SL<sub>q</sub>(n) (well, really, quantum Gröbner bases). However, considering the antipode is coming from "q-inverting the matrix", I don't think we get an antipode map for generic q and the quantum determinant is not an invertible element in the algebra (in general). Or is there a different Hopf structure/antipode?


---

Comment by bump created at 2016-03-03 00:43:55

The FRT version at the above web page does not seem to be the whole paper. Both `SL_q(n)` and `GL_q(n)` have antipodes. For `GL_q(n)` the q-determinant (needed for the antipode) is invertible, and for `SL_q(n)` the q-determinant is 1.


---

Comment by tscrim created at 2016-03-03 00:55:30

Can you tell me a formula for the inverse of the q-determinant for `GL_q(n)` is or point me to a reference which has it?

Addendum - At least the FRT article is not on MathSciNet; just a description/reference information.


---

Comment by buciumas created at 2016-03-03 02:31:43

I don't think there is a formula for the inverse of the q-determinant in GL_q(n). I think GL_q(n) is defined as the bialgebra generated by the regular generators plus a generator c that is central mod the relation c * qdet = 1. So you can write the antipode in GL_q(n) as a sum of products of the x_{ij}'s and multiply everything by the inverse of the qdet. In the case of SL_q(n) qdet is set to 1. In the case of the quantum coordinate ring which you implemented you can't write a formula for the antipode because qdet is not invertible or equal to 1. 

Formulas for the antipode and qdet (which I think you already know) for SL_q(n) can be found (among many places) here : http://arxiv.org/abs/1602.04262 (page 16 last formula and page 17 first formula).


---

Comment by tscrim created at 2016-03-03 07:03:01

Thank you. I will see if I can implement this over the weekend (I'm flying to Seoul tomorrow).


---

Comment by git created at 2016-03-06 07:50:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-06 07:59:03

I've added a class for GL<sub>q</sub>(n), but it currently fails the antipode test. I've also changed the convention from `q^2` to `q`. I just ran another test and it says that it is failing associativity, so the bug is probably in the multiplication code.

However, can you check to make sure the following data is correct?

```
sage: O = algebras.QuantumGL(2)
sage: O.quantum_determinant()
x[1,1]*x[2,2] - q*x[1,2]*x[2,1]
sage: for g in O.algebra_generators():
....:     print "{:>8}{:>33}{:>35}{:>2}".format(g, g.antipode(),
....:                                           g.coproduct(), g.counit())
  x[1,1]                         c*x[2,2]  x[1,1] # x[1,1] + x[1,2] # x[2,1] 1
  x[1,2]                 -(q^-1)*c*x[2,1]  x[1,1] # x[1,2] + x[1,2] # x[2,2] 0
  x[2,1]                      -q*c*x[1,2]  x[2,1] # x[1,1] + x[2,2] # x[2,1] 0
  x[2,2]                         c*x[1,1]  x[2,1] # x[1,2] + x[2,2] # x[2,2] 1
       c  x[1,1]*x[2,2] - q*x[1,2]*x[2,1]                              c # c 1
```

This agrees with Valentin's paper if `c = 1`.


---

Comment by tscrim created at 2016-03-06 07:59:03

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2016-03-06 08:13:13

I know what the problem is: I need to do some commuting in order to do the cancellation I want to do.


---

Comment by git created at 2016-03-06 09:12:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-06 09:15:30

Okay, I fixed the issue with multiplication not be associative by a slightly hacky Gröbner basis like process, but I left a little outline/proof of the method as a comment. I also forgot that it is the _transpose_ of the cofactor matrix when doing the inverse (and hence the antipode).

Now just to do a little bit of cleanup and get back to full doctest coverage.


---

Comment by git created at 2016-03-06 11:34:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-06 11:35:57

Back to needing review.


---

Comment by tscrim created at 2016-03-06 11:35:57

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-03-11 00:15:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-29 18:46:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-11-20 19:52:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-12-14 20:18:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2017-01-05 14:15:34

doctest failures (cf. patchbot).


---

Comment by cheuberg created at 2017-01-05 14:15:34

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-01-08 05:40:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-01-08 05:41:45

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2017-01-09 09:16:53

could you remove gcmp, which seems not to be used anywhere ?


---

Comment by git created at 2017-01-10 07:52:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-01-10 07:53:51

I've removed it, and instead I replaced it with a key for sorting since I don't think there is a guaranteed sorting order between strings and tuples.


---

Comment by chapoton created at 2017-01-26 18:15:20

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2017-01-26 18:15:20

does not apply


---

Comment by git created at 2017-01-26 18:43:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-01-26 18:43:29

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2017-06-17 05:59:49

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2017-06-17 05:59:49

does not apply


---

Comment by git created at 2017-06-17 23:04:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-06-17 23:05:07

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2017-06-18 14:32:17

ok, let it be


---

Comment by chapoton created at 2017-06-18 14:32:17

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2017-06-18 14:44:31

Thank you.


---

Comment by vbraun created at 2017-06-22 07:24:48

Resolution: fixed
