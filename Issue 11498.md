# Issue 11498: fix number fields being unique parents -- this got broken over the years

archive/issues_011498.json:
```json
{
    "body": "Assignee: davidloeffler\n\nFor example, these are all wrong:\n\n```\nsage: K.<a> = NumberField(x^2 - x - 1)\nsage: loads(dumps(K)) is K\nFalse\nsage: K.<a> = NumberField(x^3 - x - 1)\nsage: loads(dumps(K)) is K\nFalse\nsage: K.<a> = CyclotomicField(7)\nsage: loads(dumps(K)) is K\nFalse\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/11670\n\n",
    "created_at": "2011-08-09T00:19:58Z",
    "labels": [
        "number fields",
        "major",
        "bug"
    ],
    "title": "fix number fields being unique parents -- this got broken over the years",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11498",
    "user": "was"
}
```
Assignee: davidloeffler

For example, these are all wrong:

```
sage: K.<a> = NumberField(x^2 - x - 1)
sage: loads(dumps(K)) is K
False
sage: K.<a> = NumberField(x^3 - x - 1)
sage: loads(dumps(K)) is K
False
sage: K.<a> = CyclotomicField(7)
sage: loads(dumps(K)) is K
False
```


Issue created by migration from https://trac.sagemath.org/ticket/11670





---

archive/issue_comments_128561.json:
```json
{
    "body": "When working on this ticket, I also found a potentially serious bug, which is that the parameters `assume_disc_small` and `maximize_at_primes` of a number field were both lost upon pickling and unpickling. This ticket fixes that.   We used to have this bug:\n\n```\nsage: K.<a> = NumberField(x^3-2, assume_disc_small=True, maximize_at_primes=[2], latex_name='\\\\alpha', embedding=2^(1/3))\nsage: K._assume_disc_small\nTrue\nsage: K._maximize_at_primes\n[2]\nsage: L = loads(dumps(K))\nsage: L._assume_disc_small\nFalse\nsage: L._maximize_at_primes  # None\n```\n\n\nAttached patch fixes that.",
    "created_at": "2011-08-09T16:30:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128561",
    "user": "was"
}
```

When working on this ticket, I also found a potentially serious bug, which is that the parameters `assume_disc_small` and `maximize_at_primes` of a number field were both lost upon pickling and unpickling. This ticket fixes that.   We used to have this bug:

```
sage: K.<a> = NumberField(x^3-2, assume_disc_small=True, maximize_at_primes=[2], latex_name='\\alpha', embedding=2^(1/3))
sage: K._assume_disc_small
True
sage: K._maximize_at_primes
[2]
sage: L = loads(dumps(K))
sage: L._assume_disc_small
False
sage: L._maximize_at_primes  # None
```


Attached patch fixes that.



---

archive/issue_comments_128562.json:
```json
{
    "body": "Attachment",
    "created_at": "2011-08-09T17:12:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128562",
    "user": "was"
}
```

Attachment



---

archive/issue_comments_128563.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2011-08-09T17:13:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128563",
    "user": "was"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_128564.json:
```json
{
    "body": "I should comment on UniqueFactory and UniqueRepresentation (from sage.structure.unique*).   I made some attempt to use it, but decided against it for *this patch*.   The main reason is that I want to fully maintain backward compatibility with old pickled objects, since there are a lot of pickled number field elements in the wild, and that is really opaque using UniqueRepresentation.   (Also, I am concerned using UniqueRepresentation has some efficiency issues in terms of size and later changing how pickling works, since every time you pickle an object it wraps it in its own wrapper around other stuff, leading to another level of abstraction.)  I don't claim that the current approach is the easiest to maintain in the long run -- in fact, it got broke before by bad patches.  But in this new patch, I've added a ton of comments and a big warning to help prevent this in the future.",
    "created_at": "2011-08-09T17:22:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128564",
    "user": "was"
}
```

I should comment on UniqueFactory and UniqueRepresentation (from sage.structure.unique*).   I made some attempt to use it, but decided against it for *this patch*.   The main reason is that I want to fully maintain backward compatibility with old pickled objects, since there are a lot of pickled number field elements in the wild, and that is really opaque using UniqueRepresentation.   (Also, I am concerned using UniqueRepresentation has some efficiency issues in terms of size and later changing how pickling works, since every time you pickle an object it wraps it in its own wrapper around other stuff, leading to another level of abstraction.)  I don't claim that the current approach is the easiest to maintain in the long run -- in fact, it got broke before by bad patches.  But in this new patch, I've added a ton of comments and a big warning to help prevent this in the future.



---

archive/issue_comments_128565.json:
```json
{
    "body": "I also applied the patch to sage-4.7.2.alpha1 and ran \"make ptestlong\" with complete success.",
    "created_at": "2011-08-09T17:58:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128565",
    "user": "was"
}
```

I also applied the patch to sage-4.7.2.alpha1 and ran "make ptestlong" with complete success.



---

archive/issue_comments_128566.json:
```json
{
    "body": "Does that fix the issues discussed on #10448 as well?\n\nThere, I tried to fix the missing uniqueness of maximal orders in number fields using cached_method decorators. However, the most recent post on #10448 (five months ago) also mentions the problem that number fields aren't unique, and thus the maximal orders can only be as unique as the umber fields they are contained in.",
    "created_at": "2011-08-09T19:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128566",
    "user": "SimonKing"
}
```

Does that fix the issues discussed on #10448 as well?

There, I tried to fix the missing uniqueness of maximal orders in number fields using cached_method decorators. However, the most recent post on #10448 (five months ago) also mentions the problem that number fields aren't unique, and thus the maximal orders can only be as unique as the umber fields they are contained in.



---

archive/issue_comments_128567.json:
```json
{
    "body": "It turns out that this ticket is also related with #10667. Since #10667 (among other things) extends caching of homsets, the non-uniqueness of number fields then yields actual coercion errors.",
    "created_at": "2011-09-06T06:29:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128567",
    "user": "SimonKing"
}
```

It turns out that this ticket is also related with #10667. Since #10667 (among other things) extends caching of homsets, the non-uniqueness of number fields then yields actual coercion errors.



---

archive/issue_comments_128568.json:
```json
{
    "body": "Some brief remarks:\n\n* In the test for `NumberField_absolute_v2`, you use `NumberField_absolute_v1` (should be v2, not v1). The same for `NumberField_cyclotomic_v2` and `NumberField_quadratic_v2`.\n\n* The format, if I am not mistaken, should be\n {{{\n        OUTPUT:\n\n- tuple of parameters that define this field; used in \n  caching and pickling \n }}}\n not\n {{{\n        OUTPUT: \n- tuple of parameters that define this field; used in \n  caching and pickling \n }}}",
    "created_at": "2011-09-06T06:36:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128568",
    "user": "SimonKing"
}
```

Some brief remarks:

* In the test for `NumberField_absolute_v2`, you use `NumberField_absolute_v1` (should be v2, not v1). The same for `NumberField_cyclotomic_v2` and `NumberField_quadratic_v2`.

* The format, if I am not mistaken, should be
 {{{
        OUTPUT:

- tuple of parameters that define this field; used in 
  caching and pickling 
 }}}
 not
 {{{
        OUTPUT: 
- tuple of parameters that define this field; used in 
  caching and pickling 
 }}}



---

archive/issue_comments_128569.json:
```json
{
    "body": "One problem bugging me at #10667 remains: If one calls the method `point_exact` from sage.schemes.elliptic_curves.heegner with the option `optimize=True` then a non-unique absolute number field (namely `Number Field in a with defining polynomial x^12 + 4*x^11 + 56*x^10 + 170*x^9 + 1130*x^8 + 2564*x^7 + 10791*x^6 + 18054*x^5 + 51340*x^4 + 57530*x^3 + 102986*x^2 + 53724*x + 35001`) emerges.\n\nIf I can fix it then I'll post a patch here, not at #10667.",
    "created_at": "2011-09-06T07:01:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128569",
    "user": "SimonKing"
}
```

One problem bugging me at #10667 remains: If one calls the method `point_exact` from sage.schemes.elliptic_curves.heegner with the option `optimize=True` then a non-unique absolute number field (namely `Number Field in a with defining polynomial x^12 + 4*x^11 + 56*x^10 + 170*x^9 + 1130*x^8 + 2564*x^7 + 10791*x^6 + 18054*x^5 + 51340*x^4 + 57530*x^3 + 102986*x^2 + 53724*x + 35001`) emerges.

If I can fix it then I'll post a patch here, not at #10667.



---

archive/issue_comments_128570.json:
```json
{
    "body": "Yep. Here is an explicit example exposing the missing uniqueness:\n\n```\nsage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a')\nsage: M = N.optimized_representation()[0]\nsage: M\nNumber Field in a6 with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1\nsage: N is M.change_names(names='a')\nFalse\nsage: N == M.change_names(names='a')\nTrue\n```\n\n\nI guess it can be fixed in the `change_names` method.",
    "created_at": "2011-09-06T07:07:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128570",
    "user": "SimonKing"
}
```

Yep. Here is an explicit example exposing the missing uniqueness:

```
sage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a')
sage: M = N.optimized_representation()[0]
sage: M
Number Field in a6 with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1
sage: N is M.change_names(names='a')
False
sage: N == M.change_names(names='a')
True
```


I guess it can be fixed in the `change_names` method.



---

archive/issue_comments_128571.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2011-09-06T07:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128571",
    "user": "SimonKing"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_128572.json:
```json
{
    "body": "Aha, it boils down to one line in `N.absolute_field`:\n\n```python\n        try:\n            return self.__absolute_field[names]\n        except KeyError:\n            pass\n        except AttributeError:\n            self.__absolute_field = {}\n        K = NumberField(self.defining_polynomial(), names, cache=False)\n        K._set_structure(maps.NameChangeMap(K, self), maps.NameChangeMap(self, K))\n        self.__absolute_field[names] = K\n        return K\n```\n\n\nWhy is the option `cache=False` used in that method?",
    "created_at": "2011-09-06T07:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128572",
    "user": "SimonKing"
}
```

Aha, it boils down to one line in `N.absolute_field`:

```python
        try:
            return self.__absolute_field[names]
        except KeyError:
            pass
        except AttributeError:
            self.__absolute_field = {}
        K = NumberField(self.defining_polynomial(), names, cache=False)
        K._set_structure(maps.NameChangeMap(K, self), maps.NameChangeMap(self, K))
        self.__absolute_field[names] = K
        return K
```


Why is the option `cache=False` used in that method?



---

archive/issue_comments_128573.json:
```json
{
    "body": "I read the comment\n\n```\n        # Note -- never call this on a cached number field, since\n        # that could eventually lead to problems.\n```\n\nin `N._set_structure`. That might be a show stopper. But what actually happens if one applies it to a cached number field?",
    "created_at": "2011-09-06T07:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128573",
    "user": "SimonKing"
}
```

I read the comment

```
        # Note -- never call this on a cached number field, since
        # that could eventually lead to problems.
```

in `N._set_structure`. That might be a show stopper. But what actually happens if one applies it to a cached number field?



---

archive/issue_comments_128574.json:
```json
{
    "body": "I see a potential work-around. In my example, we have\n\n```\nsage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a')\nsage: M = N.optimized_representation()[0]\nsage: K = M.change_names(names='a')\nsage: N == K\nTrue\nsage: N is K\nFalse\nsage: N.structure()\n(Ring Coercion endomorphism of Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, Ring Coercion endomorphism of Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1)\nsage: K.structure()\n(Isomorphism given by variable name change map:\n  From: Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1\n  To:   Number Field in a6 with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, Isomorphism given by variable name change map:\n  From: Number Field in a6 with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1\n  To:   Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1)\n```\n\n\nWould it make sense to declare two number fields different if they have different `structure()`?",
    "created_at": "2011-09-06T07:21:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128574",
    "user": "SimonKing"
}
```

I see a potential work-around. In my example, we have

```
sage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a')
sage: M = N.optimized_representation()[0]
sage: K = M.change_names(names='a')
sage: N == K
True
sage: N is K
False
sage: N.structure()
(Ring Coercion endomorphism of Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, Ring Coercion endomorphism of Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1)
sage: K.structure()
(Isomorphism given by variable name change map:
  From: Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1
  To:   Number Field in a6 with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, Isomorphism given by variable name change map:
  From: Number Field in a6 with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1
  To:   Number Field in a with defining polynomial x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1)
```


Would it make sense to declare two number fields different if they have different `structure()`?



---

archive/issue_comments_128575.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2011-09-27T01:28:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128575",
    "user": "was"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_128576.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-09-27T01:29:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128576",
    "user": "was"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_128577.json:
```json
{
    "body": "With the branch I just pushed, I got rid of ``_set_structure``. The structure of a number field is now always set when it is created. I know that unpickling of old objects is currently broken, I'm working on a fix. Anyway, maybe somebody already wants to have a look at what I have done so far? Any comments would be appreciated.\n\nShould I now add old number field pickles to the pickle jar? I could not find out how to do this from the reference manual. Or is this somehow done automagically?\n----\nNew commits:",
    "created_at": "2014-04-08T09:14:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128577",
    "user": "saraedum"
}
```

With the branch I just pushed, I got rid of ``_set_structure``. The structure of a number field is now always set when it is created. I know that unpickling of old objects is currently broken, I'm working on a fix. Anyway, maybe somebody already wants to have a look at what I have done so far? Any comments would be appreciated.

Should I now add old number field pickles to the pickle jar? I could not find out how to do this from the reference manual. Or is this somehow done automagically?
----
New commits:



---

archive/issue_comments_128578.json:
```json
{
    "body": "Pickling of old and new number fields should work now. I found these issues though.\n\nAbsolute number fields used to forget about their structure, this is fixed now (of course the structure can not be recovered for old pickles):\n\n```\nsage: K.<a> = QuadraticField(2)\nsage: L.<b> = K.change_names()\nsage: M=loads(dumps(L))\nsage: M.structure() # old behaviour\n(Ring Coercion endomorphism of Number Field in b with defining polynomial x^2 - 2,\n Ring Coercion endomorphism of Number Field in b with defining polynomial x^2 - 2)\nsage: L.structure() # this is what M.structure() returns now\n(Isomorphism given by variable name change map:\n  From: Number Field in b with defining polynomial x^2 - 2\n  To:   Number Field in a with defining polynomial x^2 - 2,\n Isomorphism given by variable name change map:\n  From: Number Field in a with defining polynomial x^2 - 2\n  To:   Number Field in b with defining polynomial x^2 - 2)\n```\n\n\nRelative number fields also used to forget about their structure. Since I have not touched the pickling of relative number fields, I would rather put this into a separate ticket:\n\n```\nsage:             sage: Z = var('Z')\nsage:             sage: K.<w> = NumberField(Z^3 + Z + 1)\nsage:             sage: L.<z> = K.extension(Z^3 + 2)\nsage:             sage: M.<u,v> = L.change_names()\nsage:             sage: M.structure()\n(Isomorphism given by variable name change map:\n  From: Number Field in u with defining polynomial x^3 + 2 over its base field\n  To:   Number Field in z with defining polynomial Z^3 + 2 over its base field,\n Isomorphism given by variable name change map:\n  From: Number Field in z with defining polynomial Z^3 + 2 over its base field\n  To:   Number Field in u with defining polynomial x^3 + 2 over its base field)\nsage:             sage: M = loads(dumps(M))\nsage:             sage: M.structure()\n(Ring Coercion endomorphism of Number Field in u with defining polynomial x^3 + 2 over its base field,\n Ring Coercion endomorphism of Number Field in u with defining polynomial x^3 + 2 over its base field)\n```\n",
    "created_at": "2014-04-09T12:20:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128578",
    "user": "saraedum"
}
```

Pickling of old and new number fields should work now. I found these issues though.

Absolute number fields used to forget about their structure, this is fixed now (of course the structure can not be recovered for old pickles):

```
sage: K.<a> = QuadraticField(2)
sage: L.<b> = K.change_names()
sage: M=loads(dumps(L))
sage: M.structure() # old behaviour
(Ring Coercion endomorphism of Number Field in b with defining polynomial x^2 - 2,
 Ring Coercion endomorphism of Number Field in b with defining polynomial x^2 - 2)
sage: L.structure() # this is what M.structure() returns now
(Isomorphism given by variable name change map:
  From: Number Field in b with defining polynomial x^2 - 2
  To:   Number Field in a with defining polynomial x^2 - 2,
 Isomorphism given by variable name change map:
  From: Number Field in a with defining polynomial x^2 - 2
  To:   Number Field in b with defining polynomial x^2 - 2)
```


Relative number fields also used to forget about their structure. Since I have not touched the pickling of relative number fields, I would rather put this into a separate ticket:

```
sage:             sage: Z = var('Z')
sage:             sage: K.<w> = NumberField(Z^3 + Z + 1)
sage:             sage: L.<z> = K.extension(Z^3 + 2)
sage:             sage: M.<u,v> = L.change_names()
sage:             sage: M.structure()
(Isomorphism given by variable name change map:
  From: Number Field in u with defining polynomial x^3 + 2 over its base field
  To:   Number Field in z with defining polynomial Z^3 + 2 over its base field,
 Isomorphism given by variable name change map:
  From: Number Field in z with defining polynomial Z^3 + 2 over its base field
  To:   Number Field in u with defining polynomial x^3 + 2 over its base field)
sage:             sage: M = loads(dumps(M))
sage:             sage: M.structure()
(Ring Coercion endomorphism of Number Field in u with defining polynomial x^3 + 2 over its base field,
 Ring Coercion endomorphism of Number Field in u with defining polynomial x^3 + 2 over its base field)
```




---

archive/issue_comments_128579.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-04-09T12:20:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128579",
    "user": "saraedum"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_128580.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-04-09T12:25:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128580",
    "user": "saraedum"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_128581.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-09T14:52:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128581",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_128582.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-04-09T14:52:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128582",
    "user": "saraedum"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_128583.json:
```json
{
    "body": "I think it is indeed important that if one considers fields equipped with a `structure` (in the sense of this ticket), then (1) the `structure` should be fixed once and for all at the time of construction, and (2) no two fields with a different `structure` should be considered as equal.  Given (1), it would be good to to have a clear picture of what sort of things one can specify as a `structure`, and I would be interested in finding out how flexible this concept of `structure` is.\n\nFor example, it would be nice to be able to equip a number field *K* with an additional \"piece of structure\" *z* such that there is a category (in the mathematical sense) in which the objects are such pairs (*K*, *z*) and in which there exists at most one morphism between any two objects.  Then (a suitable finite representation of) *z* could be taken as an especially nice type of `structure` in the above sense.\n\nOne particular \"piece of structure\" that comes to mind is an embedding *z* of *K* into a fixed algebraic closure of **Q**.  In Sage, this means an embedding into `QQbar`.  Since `QQbar` encodes field elements (roughly speaking) by a polynomial and a complex root, represented by a sufficiently small complex region to determine the root uniquely, specifying *z* really means giving a small complex region representing a root of the defining polynomial of *K*.\n\nNow it is already the case that one can specify an `embedding` parameter when creating a number field.  Hence (finally) the following question: does the concept of a `structure` in the sense of this ticket allow the existing `embedding` parameter to be implemented as a special case of a `structure`?",
    "created_at": "2014-04-09T17:51:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128583",
    "user": "pbruin"
}
```

I think it is indeed important that if one considers fields equipped with a `structure` (in the sense of this ticket), then (1) the `structure` should be fixed once and for all at the time of construction, and (2) no two fields with a different `structure` should be considered as equal.  Given (1), it would be good to to have a clear picture of what sort of things one can specify as a `structure`, and I would be interested in finding out how flexible this concept of `structure` is.

For example, it would be nice to be able to equip a number field *K* with an additional "piece of structure" *z* such that there is a category (in the mathematical sense) in which the objects are such pairs (*K*, *z*) and in which there exists at most one morphism between any two objects.  Then (a suitable finite representation of) *z* could be taken as an especially nice type of `structure` in the above sense.

One particular "piece of structure" that comes to mind is an embedding *z* of *K* into a fixed algebraic closure of **Q**.  In Sage, this means an embedding into `QQbar`.  Since `QQbar` encodes field elements (roughly speaking) by a polynomial and a complex root, represented by a sufficiently small complex region to determine the root uniquely, specifying *z* really means giving a small complex region representing a root of the defining polynomial of *K*.

Now it is already the case that one can specify an `embedding` parameter when creating a number field.  Hence (finally) the following question: does the concept of a `structure` in the sense of this ticket allow the existing `embedding` parameter to be implemented as a special case of a `structure`?



---

archive/issue_comments_128584.json:
```json
{
    "body": "Replying to [comment:25 pbruin]: \n> Now it is already the case that one can specify an `embedding` parameter when creating a number field.  Hence (finally) the following question: does the concept of a `structure` in the sense of this ticket allow the existing `embedding` parameter to be implemented as a special case of a `structure`?\n\nNot really. One difference is that two fields with different `embedding` are not considered equal, but two fields with different `structure` are. I think this makes sense since `structure` currently tells you how a field has been created (e.g. as the absolute field of a relative field.) However, treating two number fields with different complex embedding as being the same would most probably lead to nasty bugs. \n\nThere might be a more general concept that `structure` and `embedding` are special cases of but I would not try to abuse one of them for this (right now). There is probably too much code that expects these two attributes to have a specific format to make such a change. It could be the content of a followup ticket.",
    "created_at": "2014-04-09T18:05:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128584",
    "user": "saraedum"
}
```

Replying to [comment:25 pbruin]: 
> Now it is already the case that one can specify an `embedding` parameter when creating a number field.  Hence (finally) the following question: does the concept of a `structure` in the sense of this ticket allow the existing `embedding` parameter to be implemented as a special case of a `structure`?

Not really. One difference is that two fields with different `embedding` are not considered equal, but two fields with different `structure` are. I think this makes sense since `structure` currently tells you how a field has been created (e.g. as the absolute field of a relative field.) However, treating two number fields with different complex embedding as being the same would most probably lead to nasty bugs. 

There might be a more general concept that `structure` and `embedding` are special cases of but I would not try to abuse one of them for this (right now). There is probably too much code that expects these two attributes to have a specific format to make such a change. It could be the content of a followup ticket.



---

archive/issue_comments_128585.json:
```json
{
    "body": "Replying to [comment:26 saraedum]:\n> Not really. One difference is that two fields with different `embedding` are not considered equal, but two fields with different `structure` are.\nOK, I misunderstood the discussion on this ticket so far (I did not yet look at the code carefully); I somehow concluded that your implementation answered Simon's question from comment:13 with \"yes\".  So do I understand correctly that two number fields are explicitly allowed to be equal but not identical?  Is this really desirable?  From the [manual page](http://sagemath.org/doc/reference/structure/sage/structure/unique_representation.html) on unique representation:\n\n\"Instances of a class have a unique representation behavior when instances evaluate equal if and only if they are identical (i.e., share the same memory representation), if and only if they were created using equal arguments. [...]  This behaviour is typically desirable for parents and categories.\"",
    "created_at": "2014-04-09T18:32:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128585",
    "user": "pbruin"
}
```

Replying to [comment:26 saraedum]:
> Not really. One difference is that two fields with different `embedding` are not considered equal, but two fields with different `structure` are.
OK, I misunderstood the discussion on this ticket so far (I did not yet look at the code carefully); I somehow concluded that your implementation answered Simon's question from comment:13 with "yes".  So do I understand correctly that two number fields are explicitly allowed to be equal but not identical?  Is this really desirable?  From the [manual page](http://sagemath.org/doc/reference/structure/sage/structure/unique_representation.html) on unique representation:

"Instances of a class have a unique representation behavior when instances evaluate equal if and only if they are identical (i.e., share the same memory representation), if and only if they were created using equal arguments. [...]  This behaviour is typically desirable for parents and categories."



---

archive/issue_comments_128586.json:
```json
{
    "body": "Replying to [comment:27 pbruin]:\n> OK, I misunderstood the discussion on this ticket so far (I did not yet look at the code carefully); I somehow concluded that your implementation answered Simon's question from comment:13 with \"yes\".\nI agree that it makes sense that two number fields are different if they have a different structure. I had a feeling that this would break too much existing code, though. I think it is a natural first step to rewrite number fields to use a factory and make them unique parents (this ticket).\n\nI could certainly imagine helping on a followup ticket which tries to make `==` and `is` the same for number fields.",
    "created_at": "2014-04-09T18:42:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128586",
    "user": "saraedum"
}
```

Replying to [comment:27 pbruin]:
> OK, I misunderstood the discussion on this ticket so far (I did not yet look at the code carefully); I somehow concluded that your implementation answered Simon's question from comment:13 with "yes".
I agree that it makes sense that two number fields are different if they have a different structure. I had a feeling that this would break too much existing code, though. I think it is a natural first step to rewrite number fields to use a factory and make them unique parents (this ticket).

I could certainly imagine helping on a followup ticket which tries to make `==` and `is` the same for number fields.



---

archive/issue_comments_128587.json:
```json
{
    "body": "Replying to [comment:28 saraedum]:\n> I agree that it makes sense that two number fields are different if they have a different structure. I had a feeling that this would break too much existing code, though.\nHmm, I wonder if one could test easily if this would indeed be a problem (within the Sage library, say).\n> I think it is a natural first step to rewrite number fields to use a factory and make them unique parents (this ticket).\nDoesn't \"unique parents\" mean precisely that parents are equal if and only if they are identical (see the third paragraph of [this page](http://www.sagemath.org/doc/thematic_tutorials/coercion_and_categories.html))?\n\n(I'm only starting to understand the finer points of all this; I thought understanding the situation for number fields would be a good first step towards the similar problem for elliptic curves in #11474.)",
    "created_at": "2014-04-09T18:55:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128587",
    "user": "pbruin"
}
```

Replying to [comment:28 saraedum]:
> I agree that it makes sense that two number fields are different if they have a different structure. I had a feeling that this would break too much existing code, though.
Hmm, I wonder if one could test easily if this would indeed be a problem (within the Sage library, say).
> I think it is a natural first step to rewrite number fields to use a factory and make them unique parents (this ticket).
Doesn't "unique parents" mean precisely that parents are equal if and only if they are identical (see the third paragraph of [this page](http://www.sagemath.org/doc/thematic_tutorials/coercion_and_categories.html))?

(I'm only starting to understand the finer points of all this; I thought understanding the situation for number fields would be a good first step towards the similar problem for elliptic curves in #11474.)



---

archive/issue_comments_128588.json:
```json
{
    "body": "Replying to [comment:29 pbruin]:\n> Replying to [comment:28 saraedum]:\n> > I agree that it makes sense that two number fields are different if they have a different structure. I had a feeling that this would break too much existing code, though.\n> Hmm, I wonder if one could test easily if this would indeed be a problem (within the Sage library, say).\n> > I think it is a natural first step to rewrite number fields to use a factory and make them unique parents (this ticket).\n> Doesn't \"unique parents\" mean precisely that parents are equal if and only if they are identical (see the third paragraph of [this page](http://www.sagemath.org/doc/thematic_tutorials/coercion_and_categories.html))?\nOk. Maybe I am using the wrong vocabulary here. I meant, \"uniue\" as in \"two fields generated from the same arguments are identical\", not as in \"unique representation\".",
    "created_at": "2014-04-09T19:01:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128588",
    "user": "saraedum"
}
```

Replying to [comment:29 pbruin]:
> Replying to [comment:28 saraedum]:
> > I agree that it makes sense that two number fields are different if they have a different structure. I had a feeling that this would break too much existing code, though.
> Hmm, I wonder if one could test easily if this would indeed be a problem (within the Sage library, say).
> > I think it is a natural first step to rewrite number fields to use a factory and make them unique parents (this ticket).
> Doesn't "unique parents" mean precisely that parents are equal if and only if they are identical (see the third paragraph of [this page](http://www.sagemath.org/doc/thematic_tutorials/coercion_and_categories.html))?
Ok. Maybe I am using the wrong vocabulary here. I meant, "uniue" as in "two fields generated from the same arguments are identical", not as in "unique representation".



---

archive/issue_comments_128589.json:
```json
{
    "body": "I see what you mean.  Maybe one could try to formalise the notion of \"unique parents\" more precisely as follows.\n\nWe have some Python callable `NumberField()` that takes as input some key (defining datum) `d` and outputs some Python object `K` depending on `d` and representing a number field.  This `NumberField()` uses (implicitly) some algorithm, say `same(d, e)`, that given two keys `d` and `e` decides whether `d` and `e` define the same number field.  (The meaning of \"the same\" is a bit vague; one could either use a mathematical definition involving extra structure on the number field, or one could take \"the same\" to mean by definition that `same(d, e)` returns True.)\n\nOf course, `same` should behave like an equivalence relation (`same(d, d) == True`, `same(d, e) == same(e, d)`, and transitivity holds).  I think that \"`K` and `L` were created using the same arguments\" should be interpreted as `K` and `L` being names assigned to the objects returned by `NumberField(d)` and `NumberField(e)` for some `d` and `e` for which `same(d, e)` is True.  I'm not sure if we have to assume any implication between `same(d, e)` and `d == e`; it is possible that `same(d, e)` is actually implemented as `d == e`.\n\nNow consider the following boolean-valued statements about possible keys `d` and `e`:\n1. `d is e`\n2. `same(d, e)`\n3. `NumberField(d) is NumberField(e)`\n4. `NumberField(d) == NumberField(e)`\nClearly, the implications 1 => 2 and 3 => 4 are automatic, and 2 => 4 probably holds already.  It seems that saying \"number fields are unique parents\" is the same as saying that the implementation of `NumberField()` ensures that the implications 2 => 3 (hence 2 => 4) and 4 => 3 both hold, and maybe even 3 => 2.\n\nIf I understand correctly, this ticket makes sure that 2 => 3 holds, but not necessarily 4 => 3.  From that perspective it makes sense to have a separate ticket to implement the \"other half\" of the unique parents property.",
    "created_at": "2014-04-09T20:08:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128589",
    "user": "pbruin"
}
```

I see what you mean.  Maybe one could try to formalise the notion of "unique parents" more precisely as follows.

We have some Python callable `NumberField()` that takes as input some key (defining datum) `d` and outputs some Python object `K` depending on `d` and representing a number field.  This `NumberField()` uses (implicitly) some algorithm, say `same(d, e)`, that given two keys `d` and `e` decides whether `d` and `e` define the same number field.  (The meaning of "the same" is a bit vague; one could either use a mathematical definition involving extra structure on the number field, or one could take "the same" to mean by definition that `same(d, e)` returns True.)

Of course, `same` should behave like an equivalence relation (`same(d, d) == True`, `same(d, e) == same(e, d)`, and transitivity holds).  I think that "`K` and `L` were created using the same arguments" should be interpreted as `K` and `L` being names assigned to the objects returned by `NumberField(d)` and `NumberField(e)` for some `d` and `e` for which `same(d, e)` is True.  I'm not sure if we have to assume any implication between `same(d, e)` and `d == e`; it is possible that `same(d, e)` is actually implemented as `d == e`.

Now consider the following boolean-valued statements about possible keys `d` and `e`:
1. `d is e`
2. `same(d, e)`
3. `NumberField(d) is NumberField(e)`
4. `NumberField(d) == NumberField(e)`
Clearly, the implications 1 => 2 and 3 => 4 are automatic, and 2 => 4 probably holds already.  It seems that saying "number fields are unique parents" is the same as saying that the implementation of `NumberField()` ensures that the implications 2 => 3 (hence 2 => 4) and 4 => 3 both hold, and maybe even 3 => 2.

If I understand correctly, this ticket makes sure that 2 => 3 holds, but not necessarily 4 => 3.  From that perspective it makes sense to have a separate ticket to implement the "other half" of the unique parents property.



---

archive/issue_comments_128590.json:
```json
{
    "body": "Replying to [comment:30 saraedum]:\n> Ok. Maybe I am using the wrong vocabulary here. I meant, \"uniue\" as in \"two fields generated from the same arguments are identical\", not as in \"unique representation\".\n\nIf you want two fields generated from the same arguments to be identical, then you can either use `CachedRepresentation` or `UniqueFactory`.\n\nIf you additionally want unique parent behaviour (which means you cannot have two distinct instance of your class that evaluate equal), you can use `UniqueRepresentation`, or you can add `WithEqualityById` (it could be that I wrongly remember the name, but it is something similar to this) as a base class.",
    "created_at": "2014-04-10T05:51:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128590",
    "user": "SimonKing"
}
```

Replying to [comment:30 saraedum]:
> Ok. Maybe I am using the wrong vocabulary here. I meant, "uniue" as in "two fields generated from the same arguments are identical", not as in "unique representation".

If you want two fields generated from the same arguments to be identical, then you can either use `CachedRepresentation` or `UniqueFactory`.

If you additionally want unique parent behaviour (which means you cannot have two distinct instance of your class that evaluate equal), you can use `UniqueRepresentation`, or you can add `WithEqualityById` (it could be that I wrongly remember the name, but it is something similar to this) as a base class.



---

archive/issue_comments_128591.json:
```json
{
    "body": "With your changes, Sage doesn't complain anymore if the user does not specify the name of the generator, but silently names it \"a\":\n\n```\nsage: K = NumberField(x^2 + 1); K\nNumber Field in a with defining polynomial x^2 + 1\n```\n\nI don't like this; since the name is part of the defining data, I think we should insist on the user specifying the name.  If you think this should be changed, I think it is better to create a new ticket so this interface issue can be discussed separately from the technical changes made in this ticket.",
    "created_at": "2014-04-10T11:31:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128591",
    "user": "pbruin"
}
```

With your changes, Sage doesn't complain anymore if the user does not specify the name of the generator, but silently names it "a":

```
sage: K = NumberField(x^2 + 1); K
Number Field in a with defining polynomial x^2 + 1
```

I don't like this; since the name is part of the defining data, I think we should insist on the user specifying the name.  If you think this should be changed, I think it is better to create a new ticket so this interface issue can be discussed separately from the technical changes made in this ticket.



---

archive/issue_comments_128592.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-10T11:56:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128592",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_128593.json:
```json
{
    "body": "Replying to [comment:33 pbruin]:\n> With your changes, Sage doesn't complain anymore if the user does not specify the name of the generator, but silently names it \"a\":\nYou are right. I just implemented what the docstring used to say. I fixed the implementation and the docstring.",
    "created_at": "2014-04-10T11:57:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128593",
    "user": "saraedum"
}
```

Replying to [comment:33 pbruin]:
> With your changes, Sage doesn't complain anymore if the user does not specify the name of the generator, but silently names it "a":
You are right. I just implemented what the docstring used to say. I fixed the implementation and the docstring.



---

archive/issue_comments_128594.json:
```json
{
    "body": "Thanks.  I made a reviewer patch to fix some typos, formatting and Python 3 compatibility things; I changed the error message for `name=None` back to what it was to fix one failing doctest.\n\nI would be happy give this a positive review, but I think it is better if Simon or someone else with expertise in this area takes a quick look at it as well.",
    "created_at": "2014-04-10T17:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128594",
    "user": "pbruin"
}
```

Thanks.  I made a reviewer patch to fix some typos, formatting and Python 3 compatibility things; I changed the error message for `name=None` back to what it was to fix one failing doctest.

I would be happy give this a positive review, but I think it is better if Simon or someone else with expertise in this area takes a quick look at it as well.



---

archive/issue_comments_128595.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-04-15T08:31:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128595",
    "user": "mmezzarobba"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_128596.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-22T16:08:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128596",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_128597.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-04-22T16:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128597",
    "user": "pbruin"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_128598.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-04-22T16:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128598",
    "user": "pbruin"
}
```

New commits:



---

archive/issue_comments_128599.json:
```json
{
    "body": "OK, let's not leave this to bitrot.  As an additional test, I checked that #11669 (which depends on this ticket) still works correctly, and it does.",
    "created_at": "2014-05-02T13:57:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128599",
    "user": "pbruin"
}
```

OK, let's not leave this to bitrot.  As an additional test, I checked that #11669 (which depends on this ticket) still works correctly, and it does.



---

archive/issue_comments_128600.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-02T13:57:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128600",
    "user": "pbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_128601.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-05-06T22:02:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11498",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11498#issuecomment-128601",
    "user": "vbraun"
}
```

Resolution: fixed
