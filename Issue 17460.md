# Issue 17460: incorrect usage of Singular's factorize() in special rings

Issue created by migration from https://trac.sagemath.org/ticket/17697

Original creator: jakobkroeker

Original creation time: 2015-01-30 14:47:10

CC:  jpflori simonking

Keywords: Singular factorize interface

Background: Singular behaves unexpectedly(?) in quotient rings; 
Example (in Singular):

```
ring rng = 0,(x,b),lp;
short = 0;
qring qr = b^2-2;
poly f = x^2-2;
factorize(f); // expecting: (x-b)*(x+b) ?
//[1]:
//   _[1]=1
//   _[2]=x^2-2
//[2]:
//   1,1 
```


This is (currently) by intention and is now documented upstream.
( https://github.com/Singular/Sources/commit/d0a684deae0e95680bb1a9034bac826e37c75368 ) 


However, there are implications for interfacing to Singular's factory:
Imagine, a user would try to factorize the polynomial f as below:

```
sage: K0=GF(11)
sage: #K0=QQ
sage: R0.<b>=K0[]
sage: K.<b>=K0.extension(b^5+4)
sage: R1.<zzz>=K[]
sage: L=FractionField(R1)
sage: R.<x>=L[]
sage: f=x^4+1/(b*zzz)
sage: f.parent()._singular_()
//   characteristic : 11
//   1 parameter    : zzz 
//   minpoly        : 0
//   number of vars : 2
//        block   1 : ordering lp
//                  : names    b x
//        block   2 : ordering C
// quotient ring from ideal
_[1]=b^5+4
sage: f.factor()
```


Since the called factor() routine ends in a Singular fallback (check! see polynomial_element.pyx), factoring is done in Singular's quotient ring and
hence the obtained result will be unexpected

Related post at asksage:
http://ask.sagemath.org/question/25083/bug-in-roots/

In addition, f is incorrectly translated to Singular,
see 
http://trac.sagemath.org/ticket/17696
so the result will be wrong anyway



