# Issue 14946: x in IntegralDomains() should refine category

Issue created by migration from https://trac.sagemath.org/ticket/15183

Original creator: saraedum

Original creation time: 2013-09-10 19:23:55

CC:  simonking nthiery

Currently, ``IntegerModRing`` refines its category if asked for membership in ``Fields()``:

```
sage: M = IntegerModRing(3)
sage: M.category()
Join of Category of commutative rings ...
sage: M in Fields()
True
sage: M.category()
Join of Category of fields ...
```


The same does not happen for ``IntegralDomains()``:

```
sage: M = IntegerModRing(5)
sage: M.category()
Join of Category of commutative rings ...
sage: M in IntegralDomains()
False
sage: M.category()
Join of Category of commutative rings ...
```


The changes on this ticket copy the logic from fields over to integral domains.


---

Comment by saraedum created at 2013-09-10 19:53:31

Changing status from new to needs_review.


---

Comment by saraedum created at 2013-09-10 19:55:05

Simon, I believe I mostly adapted your code from Fields. Do mind having a look at this?


---

Comment by git created at 2013-09-10 21:29:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2013-09-10 21:57:52

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:


---

Comment by saraedum created at 2013-09-10 21:58:37

Sorry, I uploaded the wrong branch to this ticket. Should be fixed now.


---

Comment by SimonKing created at 2013-09-10 22:08:57

The main problem for me is that it uses git, and as much as I know, the "master" branch in the trac-git version of Sage does not pass tests.

Hence, I currently have no version of Sage which I could use to test your changes. And besides, my knowledge of git is too little to really understand what has changed and what happened in a dependency.

In any case, are you really sure that `IntegralDomains()` needs the refinement? The reason for introducing the refinement in testing containment in `Fields()` was the fact that `Fields.__contains__` does some pretty custom things, that are really slow, unless the objects's category is properly initialised. Hence, the idea was to "cache" the result of the slow test by refining the category, so that next time the slow test will be avoided.

But `IntegralDomains` has no custom implementation of `__contains__`. So, could you elaborate a bit more on the reason of your suggestion?


---

Comment by nbruin created at 2013-09-10 22:20:29

Really, by the time you've established that `Z/nZ` is an integral domain, you can refine it to field anyway (which is an integral domain).


---

Comment by saraedum created at 2013-09-11 10:41:21

Replying to [comment:11 SimonKing]:
> The main problem for me is that it uses git, and as much as I know, the "master" branch in the trac-git version of Sage does not pass tests.
I see.

> Hence, I currently have no version of Sage which I could use to test your changes. And besides, my knowledge of git is too little to really understand what has changed and what happened in a dependency.
You could use `./sage --dev diff --base=dependencies` to see the changes introduced on the ticket itself. (with a recent version of #14482, like the one on this ticket, i.e., do `sage -b` before using this command)

> In any case, are you really sure that `IntegralDomains()` needs the refinement? The reason for introducing the refinement in testing containment in `Fields()` was the fact that `Fields.__contains__` does some pretty custom things, that are really slow, unless the objects's category is properly initialised. Hence, the idea was to "cache" the result of the slow test by refining the category, so that next time the slow test will be avoided.
What does `Fields.__contains__` do? It calls `.is_field()` which might be expensive (e.g. in the case Z/nZ). Integral domains should do the same, call `.is_integral_domain()` which is as expensive.

> But `IntegralDomains` has no custom implementation of `__contains__`. So, could you elaborate a bit more on the reason of your suggestion?
I believe that's why the check `IntegerModRing(2) in IntegralDomains()` failed, right?


---

Comment by saraedum created at 2013-09-11 10:44:13

Replying to [comment:12 nbruin]:
> Really, by the time you've established that `Z/nZ` is an integral domain, you can refine it to field anyway (which is an integral domain).
Sure, in the case of Z/nZ this is true. However, I tried to implement this on the level of categories, and I don't think that `IntegralDomains()` should try to refine to `Fields()`. One could of course implement this in `IntegerModRing` but I believe it is cleaner like this.


---

Comment by SimonKing created at 2013-09-11 10:48:35

Replying to [comment:13 saraedum]:
> What does `Fields.__contains__` do? It calls `.is_field()`

No, it calls `sage.rings.ring._is_Field`, and this is where `.is_field()` might be called and the refinement might happen.

> Integral domains should do the same, call `.is_integral_domain()` which is as expensive.
> 
> > But `IntegralDomains` has no custom implementation of `__contains__`. So, could you elaborate a bit more on the reason of your suggestion?
> I believe that's why the check `IntegerModRing(2) in IntegralDomains()` failed, right?

Do you suggest to introduce a custom `IntegralDomains.__contains__`?


---

Comment by saraedum created at 2013-09-11 10:59:00

Replying to [comment:15 SimonKing]:
> Replying to [comment:13 saraedum]:
> > What does `Fields.__contains__` do? It calls `.is_field()`
> 
> No, it calls `sage.rings.ring._is_Field`, and this is where `.is_field()` might be called and the refinement might happen.
Sorry, that's what I meant.

> > Integral domains should do the same, call `.is_integral_domain()` which is as expensive.
> > 
> > > But `IntegralDomains` has no custom implementation of `__contains__`. So, could you elaborate a bit more on the reason of your suggestion?
> > I believe that's why the check `IntegerModRing(2) in IntegralDomains()` failed, right?
> 
> Do you suggest to introduce a custom `IntegralDomains.__contains__`?
Yes. This is what my patch does. Here is the diff: changeset:2282a39


---

Comment by SimonKing created at 2013-09-11 11:06:56

Can you tell me why the patchbot only found errors in TWO files, namely

```
sage -t --long src/sage/dev/sagedev.py  # 1 doctest failed
sage -t --long src/sage/dev/patch.py  # 2 doctests failed
```

??

On my machine, I got many more errors. Or perhaps I am on the wrong branch. I currently have

```
$ git branch
* master
  public/sage-git/master
  ticket/15120
```

where #15120 is supposed to fix some remaining tests. But I am not sure, perhaps one of the two branches above is not the sage-trac master. How can I find out whether my current branch pulls from github or from trac?


---

Comment by saraedum created at 2013-09-11 11:15:23

Replying to [comment:17 SimonKing]:
> Can you tell me why the patchbot only found errors in TWO files, namely
> {{{
> sage -t --long src/sage/dev/sagedev.py  # 1 doctest failed
> sage -t --long src/sage/dev/patch.py  # 2 doctests failed
> }}}
> ??
I'm not sure what the patchbot does. It might merge in a few changes for the doctests but I don't know.

> On my machine, I got many more errors. Or perhaps I am on the wrong branch. I currently have
> {{{
> $ git branch
> * master
>   public/sage-git/master
>   ticket/15120
> }}}
> where #15120 is supposed to fix some remaining tests. But I am not sure, perhaps one of the two branches above is not the sage-trac master. How can I find out whether my current branch pulls from github or from trac?
`git branch -vv` shows where the branches pull from. You can of course also pull explicitely: `git pull http://trac.sagemath.org/sage.git public/sage-git/master`.


---

Comment by SimonKing created at 2013-09-11 12:02:35

Replying to [comment:18 saraedum]:
> `git branch -vv` shows where the branches pull from.

Not really.

```
$ git branch -vv
* master                 b890215 [origin/public/sage-git/master] Merge branch 'ticket/14482' into public/sage-git/master
  public/sage-git/master cf14c84 [origin/public/sage-git/master: behind 562] Merge branch 'ticket/14482' into public/sage-git/master
  ticket/15120           6912669 Fix --new option for doctests.
```


Neither trac nor github are mentioned...

> You can of course also pull explicitely: `git pull http://trac.sagemath.org/sage.git public/sage-git/master`.

Am I correct that this would pull into my "public/sage-git/master" branch, but would not affect the other branch called "master"?

I am sure that one branch was obtained from github and the other from trac, and it is a shame that it can't clearly (at least to my understanding) tell which is which.


---

Comment by saraedum created at 2013-09-11 12:17:46

Replying to [comment:19 SimonKing]:
> Replying to [comment:18 saraedum]:
> > `git branch -vv` shows where the branches pull from.
> 
> Not really.
> {{{
> $ git branch -vv
> * master                 b890215 [origin/public/sage-git/master] Merge branch 'ticket/14482' into public/sage-git/master
>   public/sage-git/master cf14c84 [origin/public/sage-git/master: behind 562] Merge branch 'ticket/14482' into public/sage-git/master
>   ticket/15120           6912669 Fix --new option for doctests.
> }}}
So, `master` and `public/sage-git/master` pull from origin. To find out what is `origin`, type `git remote -v`.

> > You can of course also pull explicitely: `git pull http://trac.sagemath.org/sage.git public/sage-git/master`.
> 
> Am I correct that this would pull into my "public/sage-git/master" branch, but would not affect the other branch called "master"?
This would pull into the current branch, the one with the asterisk in `git branch`.

> I am sure that one branch was obtained from github and the other from trac, and it is a shame that it can't clearly (at least to my understanding) tell which is which.
It seems that they both came from trac. At least their latest version does. It does not really matter where they originally came from.


---

Comment by SimonKing created at 2013-09-11 12:37:27

Replying to [comment:20 saraedum]:
> So, `master` and `public/sage-git/master` pull from origin. To find out what is `origin`, type `git remote -v`.


```
git remote -v
origin  ssh://git@trac.sagemath.org:2222/sage.git (fetch)
origin  ssh://git@trac.sagemath.org:2222/sage.git (push)
```

So, to my surprise, there is no github in it.


---

Comment by ncohen created at 2013-12-26 19:00:51

Okay guys, it looks like Nicolas says that category containment should *not* refine the category, and on the other hand Fields already do it. What do you decide ?

Nathann


---

Comment by ncohen created at 2013-12-26 19:03:36

Just in case...

Nathann


---

Comment by SimonKing created at 2013-12-26 19:55:28

Replying to [comment:23 ncohen]:
> Okay guys, it looks like Nicolas says that category containment should *not* refine the category,

For good reason! Category refinement involves changing the *class* of an object after creation, and actually after *usage*! Python lets you do those things, but really it is a dangerous hack.

We have seen cases in which the hash of a parent depends on the class of the parent. Hence, if a category refinement happens after (or while) using a parent P as key of a dictionary, it used to be possible that P was put in the wrong hash bucket of the dictionary. Fortunately, someone (I think it was Volker) added a security layer, so that now changing the class results in an error if it changes the hash.

But apart from hash, one often sees the following in `__cmp__` methods:

```python
def __cmp__(self, other):
    c = cmp(type(self),type(other))
    if c:
        return c
    return cmp(<data for self>,<data for other>)
```

Hence, if you add category refinement, comparison could break: Imagine you originally had `cmp(self,other)==0` and then did `self in IntegralDomains()` (triggering a category refinement) but didn't `other in IntegralDomains()`. Now, ask `cmp(self,other)`: The result will _not_ be zero any more!

Mathematically, a category refinement should be fine, and one may think that the category framework is designed to be stable against category refinement ("if you refine the category of P, then P may inherit different methods from the category framework than before, but these new methods will fit better."). However, some of these methods do caching. Hence, if P originally belongs to category C1 and it got some method `meth()` which did some caching, and then you refine P's category to be C2, so that P now inherits a _different_ version of `meth()` that uses a different cache, then you have a mess.

One could argue that it is a bug if you _do_ get a mess upon category refinement. But perhaps it is wise to not consciously ask for trouble...

> and on the other hand Fields already do it.

Yes, I know, I have to take the full blame...

But the situation was different than the situation here!

When I introduced category refinement for fields, `Fields.__contains__` used to be custom since a long time. This custom method was very very slow, but the default `__contains__` method couldn't be used unless all parents' categories were fully initialised. But then, the initialisation took too much time. Hence, I went for a compromise: Keep initialisation fast, and accept that the _first_ `Fields()` containment test is slow; but in case of success, make sure that all further containment test will be quick.

I was motivated by a concrete example that was important to a "powerful" Sage sub-community (you know, elliptic curves and so on): This example became way too slow after implementing the category framework for all rings. Reason: Initialisation of these rings took way too long, since for each ring it was needed to test whether the modulus is a prime number. Guided by this example (and a similar example for matrix spaces) I found that a "lazy" category initialisation can avoid certain severe regressions.

However, here, things are different: As much as I understand, the suggestion is to let `IntegralDomains()` have a custom `__contains__` method, just because `Fields()` has a custom `__contains__` method too. But since `Category_singleton.__contains__` is very very fast, it should not be overridden by a custom `__contains__` without a very very good and compelling reason. It could actually be that some examples will become _slower_ when the containment test will regress.

Put differently: I haven't seen any concrete "real world" example that shows that we need lazy category initialisation for (some) integral domains. Without such example, I'd say we should better not open Pandora's box again.


---

Comment by mmezzarobba created at 2014-02-11 16:35:12

So, does this ticket still need review? Should it be closed as wontfix?


---

Comment by saraedum created at 2014-02-11 16:45:39

Simon made a good point. I did this for consistency with Fields. I see now that it is better not to introduce this change.


---

Comment by ncohen created at 2014-02-11 16:46:41

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-02-11 21:23:08

Resolution: wontfix
