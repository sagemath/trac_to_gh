# Issue 16230: Unhiding in a fully hidden Doubly-Linked List

archive/issues_016230.json:
```json
{
    "body": "CC:  rudi jakobkroeker\n\nKeywords: doubly linked list unhide empty\n\nAn error occurs when in a fully hidden Doubly-Linked List an element is unhidden. All elements that come after it will also be unhidden.\n\n\n```\nl = sage.combinat.misc.DoublyLinkedList(xrange(5))\nl.hide(0)\nl.hide(1)\nl.hide(2)\nl.hide(3)\nl.hide(4)\nprint l\nl.unhide(1)\nprint l\nl.hide(1)\nprint l\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/16467\n\n",
    "created_at": "2014-06-11T09:30:15Z",
    "labels": [
        "combinatorics",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Unhiding in a fully hidden Doubly-Linked List",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16230",
    "user": "foosterhof"
}
```
CC:  rudi jakobkroeker

Keywords: doubly linked list unhide empty

An error occurs when in a fully hidden Doubly-Linked List an element is unhidden. All elements that come after it will also be unhidden.


```
l = sage.combinat.misc.DoublyLinkedList(xrange(5))
l.hide(0)
l.hide(1)
l.hide(2)
l.hide(3)
l.hide(4)
print l
l.unhide(1)
print l
l.hide(1)
print l
```


Issue created by migration from https://trac.sagemath.org/ticket/16467





---

archive/issue_comments_212256.json:
```json
{
    "body": "This proposal is a revamp of the internal storage, to become an actual doubly linked list, in which elements that have not been defined at initialization can also be inserted and removed. A side effect that occurs, but that in my opinion should not be a problem, is that the order of the elements may change upon removal and re-insertion now.\n\nI do not see this as a problem, as the Doubly Linked List abstract data type has no concept of maintenance of order.\n\nNew commits:",
    "created_at": "2014-06-11T12:55:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212256",
    "user": "foosterhof"
}
```

This proposal is a revamp of the internal storage, to become an actual doubly linked list, in which elements that have not been defined at initialization can also be inserted and removed. A side effect that occurs, but that in my opinion should not be a problem, is that the order of the elements may change upon removal and re-insertion now.

I do not see this as a problem, as the Doubly Linked List abstract data type has no concept of maintenance of order.

New commits:



---

archive/issue_comments_212257.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-06-11T12:55:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212257",
    "user": "foosterhof"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_212258.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-11T15:31:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212258",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_212259.json:
```json
{
    "body": "The following hangs:\n\n```\nl = sage.combinat.misc.DoublyLinkedList(xrange(5))\nl.insert(0)\nl\n```\n",
    "created_at": "2014-06-27T09:03:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212259",
    "user": "Rudi"
}
```

The following hangs:

```
l = sage.combinat.misc.DoublyLinkedList(xrange(5))
l.insert(0)
l
```




---

archive/issue_comments_212260.json:
```json
{
    "body": "This poses a useful question:\n- Should an object be able to be in the list multiple times?\n\nIf so, the data storage plan used now will not work, and a structure using actual Node objects should be used. However, this will either break compatibility, as remove() now takes the object to remove, while then it would require the node containing the object, or it will increase the complexity of remove() from O(1) to O(n) by searching for the node to be removed. Both cases seem highly undesirable to me.\n\nIf objects cannot be represented multiple times, this can quite easily be fixed by creating some sort of 'has' dictionary, checking whether an element is already in the list.\n\nWhat would be most desirable for Sage?",
    "created_at": "2014-06-27T18:04:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212260",
    "user": "foosterhof"
}
```

This poses a useful question:
- Should an object be able to be in the list multiple times?

If so, the data storage plan used now will not work, and a structure using actual Node objects should be used. However, this will either break compatibility, as remove() now takes the object to remove, while then it would require the node containing the object, or it will increase the complexity of remove() from O(1) to O(n) by searching for the node to be removed. Both cases seem highly undesirable to me.

If objects cannot be represented multiple times, this can quite easily be fixed by creating some sort of 'has' dictionary, checking whether an element is already in the list.

What would be most desirable for Sage?



---

archive/issue_comments_212261.json:
```json
{
    "body": "I'd say double entries should be possible, a DLL should really be able to store any sequence. \n\nHow is `remove' currently implemented? I really do not see how it can take O(1) time right now. To remove in O(1) time you must take away the trouble of finding the node (or at least the pointers to next\\previous object). Just passing the object still leaves you with that work.\n\nThis doubly linked list has hide/unhide, which in my book means that there should be two doubly linked lists in there, one storing a subsequence of the other.\n\nBut perhaps it's not all cast in stone and there are more schools of thought on this. I was brought up with the c++ STL implementation of a list, as here http://www.cplusplus.com/reference/list/list/",
    "created_at": "2014-06-27T18:53:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212261",
    "user": "Rudi"
}
```

I'd say double entries should be possible, a DLL should really be able to store any sequence. 

How is `remove' currently implemented? I really do not see how it can take O(1) time right now. To remove in O(1) time you must take away the trouble of finding the node (or at least the pointers to next\previous object). Just passing the object still leaves you with that work.

This doubly linked list has hide/unhide, which in my book means that there should be two doubly linked lists in there, one storing a subsequence of the other.

But perhaps it's not all cast in stone and there are more schools of thought on this. I was brought up with the c++ STL implementation of a list, as here http://www.cplusplus.com/reference/list/list/



---

archive/issue_comments_212262.json:
```json
{
    "body": "I forgot for a moment that I could simply take a look at the code :) . Anyway, the implementation of remove() takes O(log n) time, not O(1) as advertised in the docstring, since next_value and prev_value are dictionaries.",
    "created_at": "2014-06-28T07:43:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212262",
    "user": "Rudi"
}
```

I forgot for a moment that I could simply take a look at the code :) . Anyway, the implementation of remove() takes O(log n) time, not O(1) as advertised in the docstring, since next_value and prev_value are dictionaries.



---

archive/issue_comments_212263.json:
```json
{
    "body": "tests do not pass",
    "created_at": "2015-08-09T12:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212263",
    "user": "chapoton"
}
```

tests do not pass



---

archive/issue_comments_212264.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-09T12:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16230",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16230#issuecomment-212264",
    "user": "chapoton"
}
```

Changing status from needs_review to needs_work.
