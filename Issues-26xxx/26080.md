# Issue 26080: The Baker-Campbell-Hausdorff formula for nilpotent Lie algebras

archive/issues_025843.json:
```json
{
    "assignees": [],
    "body": "Computation of the Baker-Campbell-Hausdorff formula `Z = log(exp(X)exp(Y))` in the case of nilpotent Lie algebras, where it reduces to a (complicated) polynomial expression.\n\nDepends on #26076\n\nKeywords: **Lie algebras, BCH formula**\n\nBranch/Commit: **[`369f7a6`](https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d)**\n\nReviewer: **Travis Scrimshaw**\n\nAuthor: **Eero Hakavuori**\n\nComponent: **algebra**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/26080_\n\n",
    "closed_at": "2018-09-27T17:41:24Z",
    "created_at": "2018-08-17T07:19:21Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20algebra",
        "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-8.4",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "The Baker-Campbell-Hausdorff formula for nilpotent Lie algebras",
    "type": "issue",
    "updated_at": "2018-09-27T17:41:24Z",
    "url": "https://github.com/sagemath/sage/issues/26080",
    "user": "https://github.com/ehaka"
}
```
Computation of the Baker-Campbell-Hausdorff formula `Z = log(exp(X)exp(Y))` in the case of nilpotent Lie algebras, where it reduces to a (complicated) polynomial expression.

Depends on #26076

Keywords: **Lie algebras, BCH formula**

Branch/Commit: **[`369f7a6`](https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d)**

Reviewer: **Travis Scrimshaw**

Author: **Eero Hakavuori**

Component: **algebra**

_Issue created by migration from https://trac.sagemath.org/ticket/26080_





---

archive/issue_events_360147.json:
```json
{
    "actor": "https://github.com/ehaka",
    "created_at": "2018-08-17T07:19:21Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "milestone_number": null,
    "milestone_title": "sage-8.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360147"
}
```



---

archive/issue_events_360148.json:
```json
{
    "actor": "https://github.com/ehaka",
    "created_at": "2018-08-17T07:19:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20algebra",
    "label_color": "0000ff",
    "label_name": "c: algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360148"
}
```



---

archive/issue_events_360149.json:
```json
{
    "actor": "https://github.com/ehaka",
    "created_at": "2018-08-17T07:19:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p: 3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360149"
}
```



---

archive/issue_events_360150.json:
```json
{
    "actor": "https://github.com/ehaka",
    "created_at": "2018-08-17T07:19:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360150"
}
```



---

archive/issue_comments_401756.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nSome implementation already exists in a codebase that I need to clean up and import into Sage. The method of computing is to compute the BCH formula for 2 generators of a free nilpotent Lie algebra of the same nilpotency step and to map the result to the desired nilpotent Lie algebra via a Lie algebra morphism mapping the generators to X and Y.",
    "created_at": "2018-08-17T07:21:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401756",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:1" align="right">comment:1</div>

Some implementation already exists in a codebase that I need to clean up and import into Sage. The method of computing is to compute the BCH formula for 2 generators of a free nilpotent Lie algebra of the same nilpotency step and to map the result to the desired nilpotent Lie algebra via a Lie algebra morphism mapping the generators to X and Y.



---

archive/issue_comments_401757.json:
```json
{
    "body": "Changed keywords from none to **Lie algebras, BCH formula**",
    "created_at": "2018-08-17T07:22:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401757",
    "user": "https://github.com/ehaka"
}
```

Changed keywords from none to **Lie algebras, BCH formula**



---

archive/issue_comments_401758.json:
```json
{
    "body": "Author: **Eero Hakavuori**",
    "created_at": "2018-09-23T08:21:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401758",
    "user": "https://github.com/ehaka"
}
```

Author: **Eero Hakavuori**



---

archive/issue_comments_401759.json:
```json
{
    "body": "Changed dependencies from **#26076, #26036** to **#26076**",
    "created_at": "2018-09-23T08:21:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401759",
    "user": "https://github.com/ehaka"
}
```

Changed dependencies from **#26076, #26036** to **#26076**



---

archive/issue_comments_401760.json:
```json
{
    "body": "Branch: **[u/gh-ehaka/bch-26080](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-ehaka/bch-26080)**",
    "created_at": "2018-09-23T08:21:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401760",
    "user": "https://github.com/ehaka"
}
```

Branch: **[u/gh-ehaka/bch-26080](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-ehaka/bch-26080)**



---

archive/issue_comments_401761.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nAn initial implementation is in the commits. I ended up making the computation into an iterator returning the terms involving brackets of increasing lengths, so it is in theory possible to compute the BCH formula to arbitrary precision in any Lie algebra. I added a `BCH` method to `LieAlgebras.Nilpotent` to compute the full expression using this iterator. \n\nThe iterator might be of independent interest for the computation of the (low order terms of the) abstract BCH formula in a free Lie algebra, however I did not know what would be the best way to expose it to the user.\n\nOne unfortunate part is that the computation time becomes quite unwieldy for the later terms. For example on my computer, computing the terms of increasing degree for the free Lie algebra on 2 generators took the following times:\n\n```\n10 : 45.4 ms\n11 : 116 ms\n12 : 327 ms\n13 : 1.08 s\n14 : 4.2 s\n15 : 16.3 s\n16 : 1min 8s\n17 : 4min 59s\n18 : 20min 52s\n```\nThe only more efficient algorithm I know of is the one of Casas-Murua (https://arxiv.org/abs/0810.2656). Based on their statement of requiring <15 mins for all terms of degree up to 20, I would guess that the efficiency improvement would be somewhere in the order of a 40x speed increase. For now, I think the simpler but less efficient approach is sufficient though.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1276e0eb34fc6509ef523cedee68803968fa70aa\">1276e0e</a></td><td><code>trac #26080: initial implementation of the BCH formula</code></td></tr></table>\n",
    "created_at": "2018-09-23T08:21:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401761",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:3" align="right">comment:3</div>

An initial implementation is in the commits. I ended up making the computation into an iterator returning the terms involving brackets of increasing lengths, so it is in theory possible to compute the BCH formula to arbitrary precision in any Lie algebra. I added a `BCH` method to `LieAlgebras.Nilpotent` to compute the full expression using this iterator. 

The iterator might be of independent interest for the computation of the (low order terms of the) abstract BCH formula in a free Lie algebra, however I did not know what would be the best way to expose it to the user.

One unfortunate part is that the computation time becomes quite unwieldy for the later terms. For example on my computer, computing the terms of increasing degree for the free Lie algebra on 2 generators took the following times:

```
10 : 45.4 ms
11 : 116 ms
12 : 327 ms
13 : 1.08 s
14 : 4.2 s
15 : 16.3 s
16 : 1min 8s
17 : 4min 59s
18 : 20min 52s
```
The only more efficient algorithm I know of is the one of Casas-Murua (https://arxiv.org/abs/0810.2656). Based on their statement of requiring <15 mins for all terms of degree up to 20, I would guess that the efficiency improvement would be somewhere in the order of a 40x speed increase. For now, I think the simpler but less efficient approach is sufficient though.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1276e0eb34fc6509ef523cedee68803968fa70aa">1276e0e</a></td><td><code>trac #26080: initial implementation of the BCH formula</code></td></tr></table>




---

archive/issue_comments_401762.json:
```json
{
    "body": "Commit: **[`1276e0e`](https://github.com/sagemath/sagetrac-mirror/commit/1276e0eb34fc6509ef523cedee68803968fa70aa)**",
    "created_at": "2018-09-23T08:21:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401762",
    "user": "https://github.com/ehaka"
}
```

Commit: **[`1276e0e`](https://github.com/sagemath/sagetrac-mirror/commit/1276e0eb34fc6509ef523cedee68803968fa70aa)**



---

archive/issue_events_360151.json:
```json
{
    "actor": "https://github.com/ehaka",
    "created_at": "2018-09-23T08:21:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360151"
}
```



---

archive/issue_comments_401763.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nProbably a good part of it might be a poor implementation of the Lie bracket for the free Lie algebra. At least it is taking on one iteration 14s/19s. Some caching, better implementation, and more Cythonization might help. At least, how it is currently designed is not very smart. For instance, it might be better to store the basis elements actually as lists that keeps track of the tree structure through some other list. There are definitely ways it can be improved (this is the first time that code is really being stress-tested for efficiency).\n\nAnyways, I think this will work for now as we can always work on it more on a followup. Some comments on the code.\n\n- I don't see the reason why the `bch_formula` should be a class. I think it would be better suited as just a generator function (i.e., using `yield` instead of `return`).\n- Break the really long `.. MATH::` line. Also avoid using `\\dots` and instead be more specific about what kind of dots (in this case, `\\cdots`) (I don't really trust `\\dots`).\n- You should have an alias `baker_campbell_hausdorff = BCH`. Also, Sage convention is still method names are generally lower cases, even for acronyms/last-names (e.g., it is `pbw_basis`, not `PBW_basis`).\n- Instead of just having a method for nilpotent Lie algebras, I think it would be good to have one that allows for a \"precision\" to be inputted. For instance\n\n  ```python\n  def bch(self, X, Y, prec=None):\n      if self not in LieAlgebras.Nilpotent and prec is None:\n          raise ValueError(\"the Lie algebra is not known to be nilpotent,\"\n                           \" so you must specify the precision\")\n      from sage.algebras.lie_algebras.bch import BCH_iterator\n      if prec is None:\n          return self.sum(Z for Z in BCH_iterator(X, Y))\n      bch = BCH_iterator(X, Y)\n      return self.sum(next(bch) for k in range(prec))  # maybe prec+1?\n```",
    "created_at": "2018-09-23T13:57:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401763",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:4" align="right">comment:4</div>

Probably a good part of it might be a poor implementation of the Lie bracket for the free Lie algebra. At least it is taking on one iteration 14s/19s. Some caching, better implementation, and more Cythonization might help. At least, how it is currently designed is not very smart. For instance, it might be better to store the basis elements actually as lists that keeps track of the tree structure through some other list. There are definitely ways it can be improved (this is the first time that code is really being stress-tested for efficiency).

Anyways, I think this will work for now as we can always work on it more on a followup. Some comments on the code.

- I don't see the reason why the `bch_formula` should be a class. I think it would be better suited as just a generator function (i.e., using `yield` instead of `return`).
- Break the really long `.. MATH::` line. Also avoid using `\dots` and instead be more specific about what kind of dots (in this case, `\cdots`) (I don't really trust `\dots`).
- You should have an alias `baker_campbell_hausdorff = BCH`. Also, Sage convention is still method names are generally lower cases, even for acronyms/last-names (e.g., it is `pbw_basis`, not `PBW_basis`).
- Instead of just having a method for nilpotent Lie algebras, I think it would be good to have one that allows for a "precision" to be inputted. For instance

  ```python
  def bch(self, X, Y, prec=None):
      if self not in LieAlgebras.Nilpotent and prec is None:
          raise ValueError("the Lie algebra is not known to be nilpotent,"
                           " so you must specify the precision")
      from sage.algebras.lie_algebras.bch import BCH_iterator
      if prec is None:
          return self.sum(Z for Z in BCH_iterator(X, Y))
      bch = BCH_iterator(X, Y)
      return self.sum(next(bch) for k in range(prec))  # maybe prec+1?
```



---

archive/issue_comments_401764.json:
```json
{
    "body": "Changed commit from **[`1276e0e`](https://github.com/sagemath/sagetrac-mirror/commit/1276e0eb34fc6509ef523cedee68803968fa70aa)** to **[`5972b6b`](https://github.com/sagemath/sagetrac-mirror/commit/5972b6b0fbe210019e72e844a1420c7455a7f03f)**",
    "created_at": "2018-09-23T14:41:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401764",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1276e0e`](https://github.com/sagemath/sagetrac-mirror/commit/1276e0eb34fc6509ef523cedee68803968fa70aa)** to **[`5972b6b`](https://github.com/sagemath/sagetrac-mirror/commit/5972b6b0fbe210019e72e844a1420c7455a7f03f)**



---

archive/issue_comments_401765.json:
```json
{
    "body": "<div id=\"comment:5\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5972b6b0fbe210019e72e844a1420c7455a7f03f\">5972b6b</a></td><td><code>trac #26080: converted bch iterator to a generator function and added interface for non-nilpotent Lie algebras</code></td></tr></table>\n",
    "created_at": "2018-09-23T14:41:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401765",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:5"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5972b6b0fbe210019e72e844a1420c7455a7f03f">5972b6b</a></td><td><code>trac #26080: converted bch iterator to a generator function and added interface for non-nilpotent Lie algebras</code></td></tr></table>




---

archive/issue_comments_401766.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nThanks for the suggestions, changing the iterator to a generator seemed to indeed make a lot of sense since it cut out a lot of the unnecessary pieces of code! Also good to know about the naming convention, I wasn't sure what the policy was for names.",
    "created_at": "2018-09-23T14:44:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401766",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:6" align="right">comment:6</div>

Thanks for the suggestions, changing the iterator to a generator seemed to indeed make a lot of sense since it cut out a lot of the unnecessary pieces of code! Also good to know about the naming convention, I wasn't sure what the policy was for names.



---

archive/issue_comments_401767.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nWe are all always learning. :)\n\nFour last little things I missed on the first go-around (but this is it, promise):\n\n- `(m - 1) / 2 + 1` -> `(m - 1) * 2 + 1` because on Python3, that will become a floating point and `range` does not like floating point limits (`*` is floor division).\n- A faster way to create fractions in `QQ`:\n\n  ```\n  sage: %timeit QQ(1) / QQ(121)\n  The slowest run took 12.50 times longer than the fastest. This could mean that an intermediate result is being cached.\n  1000000 loops, best of 3: 1.11 \u00b5s per loop\n  sage: %timeit QQ((1, 121))\n  The slowest run took 21.95 times longer than the fastest. This could mean that an intermediate result is being cached.\n  1000000 loops, best of 3: 771 ns per loop\n  sage: %timeit ~QQ(121)\n  The slowest run took 27.61 times longer than the fastest. This could mean that an intermediate result is being cached.\n  1000000 loops, best of 3: 440 ns per loop\n  ```\n  Similarly for `coeff`.\n- You can use the lower level `IntegerListsLex` to iterate over:\n\n  ```\n  sage: IV = IntegerVectorsConstraints(10 - 1, 2 * 3, min_part=1)\n  sage: ILL = IntegerListsLex(10-1, length=2*3, min_part=1)\n  sage: [list(x) for x in IV] == [list(x) for x in ILL]\n  True\n  ```\n  `IntegerVectorsConstraints` is slower because it generates instances of `Element`, which have extra overhead from not being a builtin Python type.\n- It is faster to use `X.bracket(Y)` instead of `L.bracket(X, Y)` as the latter calls the former. If you actually know the elements belong to the same parent, you can do `X._bracket_(Y)` and avoid some extra overhead checks, but that should be negligible.",
    "created_at": "2018-09-23T22:58:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401767",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:7" align="right">comment:7</div>

We are all always learning. :)

Four last little things I missed on the first go-around (but this is it, promise):

- `(m - 1) / 2 + 1` -> `(m - 1) * 2 + 1` because on Python3, that will become a floating point and `range` does not like floating point limits (`*` is floor division).
- A faster way to create fractions in `QQ`:

  ```
  sage: %timeit QQ(1) / QQ(121)
  The slowest run took 12.50 times longer than the fastest. This could mean that an intermediate result is being cached.
  1000000 loops, best of 3: 1.11 Âµs per loop
  sage: %timeit QQ((1, 121))
  The slowest run took 21.95 times longer than the fastest. This could mean that an intermediate result is being cached.
  1000000 loops, best of 3: 771 ns per loop
  sage: %timeit ~QQ(121)
  The slowest run took 27.61 times longer than the fastest. This could mean that an intermediate result is being cached.
  1000000 loops, best of 3: 440 ns per loop
  ```
  Similarly for `coeff`.
- You can use the lower level `IntegerListsLex` to iterate over:

  ```
  sage: IV = IntegerVectorsConstraints(10 - 1, 2 * 3, min_part=1)
  sage: ILL = IntegerListsLex(10-1, length=2*3, min_part=1)
  sage: [list(x) for x in IV] == [list(x) for x in ILL]
  True
  ```
  `IntegerVectorsConstraints` is slower because it generates instances of `Element`, which have extra overhead from not being a builtin Python type.
- It is faster to use `X.bracket(Y)` instead of `L.bracket(X, Y)` as the latter calls the former. If you actually know the elements belong to the same parent, you can do `X._bracket_(Y)` and avoid some extra overhead checks, but that should be negligible.



---

archive/issue_comments_401768.json:
```json
{
    "body": "Reviewer: **Travis Scrimshaw**",
    "created_at": "2018-09-23T22:58:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401768",
    "user": "https://github.com/tscrim"
}
```

Reviewer: **Travis Scrimshaw**



---

archive/issue_comments_401769.json:
```json
{
    "body": "Changed commit from **[`5972b6b`](https://github.com/sagemath/sagetrac-mirror/commit/5972b6b0fbe210019e72e844a1420c7455a7f03f)** to **[`e12ea13`](https://github.com/sagemath/sagetrac-mirror/commit/e12ea13e8fc20f818b6b13afd604e5fb8913f793)**",
    "created_at": "2018-09-24T05:31:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401769",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`5972b6b`](https://github.com/sagemath/sagetrac-mirror/commit/5972b6b0fbe210019e72e844a1420c7455a7f03f)** to **[`e12ea13`](https://github.com/sagemath/sagetrac-mirror/commit/e12ea13e8fc20f818b6b13afd604e5fb8913f793)**



---

archive/issue_comments_401770.json:
```json
{
    "body": "<div id=\"comment:8\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e12ea13e8fc20f818b6b13afd604e5fb8913f793\">e12ea13</a></td><td><code>trac #26080: efficiency improvements</code></td></tr></table>\n",
    "created_at": "2018-09-24T05:31:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401770",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:8"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e12ea13e8fc20f818b6b13afd604e5fb8913f793">e12ea13</a></td><td><code>trac #26080: efficiency improvements</code></td></tr></table>




---

archive/issue_comments_401771.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nI only now realized that `bernoulli` already returns elements of `QQ` so the first cast in `coeff` was unnecessary, so I left the latter cast and division in place. The other improvements are now in.",
    "created_at": "2018-09-24T05:39:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401771",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:9" align="right">comment:9</div>

I only now realized that `bernoulli` already returns elements of `QQ` so the first cast in `coeff` was unnecessary, so I left the latter cast and division in place. The other improvements are now in.



---

archive/issue_comments_401772.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nThanks. I unintentionally lied: `raise StopIteration` -> `return`. You can set a positive review on my behalf once fixed.\n\nSomething we might want to consider for a followup ticket (you can do it here if you want) is when, say, a Lie algebra does not know it is nilpotent or `X,Y` generate a finite BCH formula, we could have a test to stop the iteration. I think this would be just checking that all of the brackets computed at a particular depth are 0. I leave it up to you.",
    "created_at": "2018-09-24T06:42:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401772",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:10" align="right">comment:10</div>

Thanks. I unintentionally lied: `raise StopIteration` -> `return`. You can set a positive review on my behalf once fixed.

Something we might want to consider for a followup ticket (you can do it here if you want) is when, say, a Lie algebra does not know it is nilpotent or `X,Y` generate a finite BCH formula, we could have a test to stop the iteration. I think this would be just checking that all of the brackets computed at a particular depth are 0. I leave it up to you.



---

archive/issue_comments_401773.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nThat sounds like a good idea to add. It would also make sense then to allow `prec=Infinity` to handle the usecase where the formula is known to be finite even if the algebra is not nilpotent. Is there a canonical format for an input that can be an integer or infinite?\n\nI'll try to edit it into this ticket later today or tomorrow.",
    "created_at": "2018-09-24T07:49:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401773",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:11" align="right">comment:11</div>

That sounds like a good idea to add. It would also make sense then to allow `prec=Infinity` to handle the usecase where the formula is known to be finite even if the algebra is not nilpotent. Is there a canonical format for an input that can be an integer or infinite?

I'll try to edit it into this ticket later today or tomorrow.



---

archive/issue_comments_401774.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nReplying to [@ehaka](#comment:11):\n> That sounds like a good idea to add. It would also make sense then to allow `prec=Infinity` to handle the usecase where the formula is known to be finite even if the algebra is not nilpotent.\n\nThe problem with that there is no way to test whether a Lie algebra is nilpotent or not in general (at least, as far as I know). For the finite-dimensional ones, we can compute the lower central series of course, but that is expensive. So IMO it is better to avoid the computation and to play it safe. However, that is a very weak position as I can see good reason to just do the check in that case. Your choice.\n\n>  Is there a canonical format for an input that can be an integer or infinite?\n\nNot to my knowledge. You have to check both `x in ZZ or x == Infinity`.",
    "created_at": "2018-09-24T07:54:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401774",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:12" align="right">comment:12</div>

Replying to [@ehaka](#comment:11):
> That sounds like a good idea to add. It would also make sense then to allow `prec=Infinity` to handle the usecase where the formula is known to be finite even if the algebra is not nilpotent.

The problem with that there is no way to test whether a Lie algebra is nilpotent or not in general (at least, as far as I know). For the finite-dimensional ones, we can compute the lower central series of course, but that is expensive. So IMO it is better to avoid the computation and to play it safe. However, that is a very weak position as I can see good reason to just do the check in that case. Your choice.

>  Is there a canonical format for an input that can be an integer or infinite?

Not to my knowledge. You have to check both `x in ZZ or x == Infinity`.



---

archive/issue_comments_401775.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nI meant the usecase when the user knows for some a priori reason that the formula is finite, but maybe does not know the maximum degree. So there would be no nilpotency check, but the program would just compute until the formula terminates.\n\nThis would of course mean that if passed 'bad' parameters, the method would hang. Would this be bad practice to allow even with a warning about it in the doc?\n\nAlthough thinking about it a bit more, it is no longer clear to me if all brackets being zero on a degree is sufficient for termination. The brackets in the recursion are not very transparent, so it is not clear to me if there could be some corner case that fails. I will have to think about it more, and if I can't figure it out in a reasonable time, it can be left to a later improvement :)",
    "created_at": "2018-09-24T08:07:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401775",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:13" align="right">comment:13</div>

I meant the usecase when the user knows for some a priori reason that the formula is finite, but maybe does not know the maximum degree. So there would be no nilpotency check, but the program would just compute until the formula terminates.

This would of course mean that if passed 'bad' parameters, the method would hang. Would this be bad practice to allow even with a warning about it in the doc?

Although thinking about it a bit more, it is no longer clear to me if all brackets being zero on a degree is sufficient for termination. The brackets in the recursion are not very transparent, so it is not clear to me if there could be some corner case that fails. I will have to think about it more, and if I can't figure it out in a reasonable time, it can be left to a later improvement :)



---

archive/issue_comments_401776.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nAh, I see what you mean. Yes, having `prec=oo` to let it run is fine. As you said, we just put a warning in the doc that it may run forever, but the user then knows what s/he is doing. +1 for this.",
    "created_at": "2018-09-24T08:10:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401776",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:14" align="right">comment:14</div>

Ah, I see what you mean. Yes, having `prec=oo` to let it run is fine. As you said, we just put a warning in the doc that it may run forever, but the user then knows what s/he is doing. +1 for this.



---

archive/issue_comments_401777.json:
```json
{
    "body": "<div id=\"comment:15\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d\">369f7a6</a></td><td><code>trac #26080: replaced old stopiteration</code></td></tr></table>\n",
    "created_at": "2018-09-24T14:10:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401777",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:15"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d">369f7a6</a></td><td><code>trac #26080: replaced old stopiteration</code></td></tr></table>




---

archive/issue_comments_401778.json:
```json
{
    "body": "Changed commit from **[`e12ea13`](https://github.com/sagemath/sagetrac-mirror/commit/e12ea13e8fc20f818b6b13afd604e5fb8913f793)** to **[`369f7a6`](https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d)**",
    "created_at": "2018-09-24T14:10:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401778",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`e12ea13`](https://github.com/sagemath/sagetrac-mirror/commit/e12ea13e8fc20f818b6b13afd604e5fb8913f793)** to **[`369f7a6`](https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d)**



---

archive/issue_comments_401779.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nAt least with the current recursion algorithm, it is possible that all of the brackets `[X-Y,Z_{m-1}]` and `[Z_{k_1},...[Z_{k_{2p}}, X+Y]...]` computed in the recursion are zero for some `m`, but nonetheless higher order terms are non-zero. An example of this is given by quotienting a Lie algebra by the term of degree 3 of the BCH formula:\n\n```\nsage: L = LieAlgebra(QQ, 2, step=4)\nsage: X, Y = L.homogeneous_component_basis(3)\nsage: Q = L.quotient(X + Y)\nsage: Q.inject_variables()\nDefining X_1, X_2, X_12, X_112, X_1112\nsage: Q.bch(X_1, X_2)\nX_1 + X_2 + 1/2*X_12 - 1/24*X_1112\n```\nFor third order terms, the `IntegerListsLex` part of the sum is only `[Z_1, [Z_1, Z_1]] = 0`, so `Z_3` will be just a multiple of `[X-Y,Z_2]`, which has been quotiented out. Yet there are non-zero terms of degree 4.\n\nAt this point I don't know what would be a possible alternative check to see if the formula terminates (other than testing for nilpotency of the Lie algebra generated by the two elements). So I would say to leave the improvements to a later ticket.",
    "created_at": "2018-09-24T20:25:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401779",
    "user": "https://github.com/ehaka"
}
```

<div id="comment:16" align="right">comment:16</div>

At least with the current recursion algorithm, it is possible that all of the brackets `[X-Y,Z_{m-1}]` and `[Z_{k_1},...[Z_{k_{2p}}, X+Y]...]` computed in the recursion are zero for some `m`, but nonetheless higher order terms are non-zero. An example of this is given by quotienting a Lie algebra by the term of degree 3 of the BCH formula:

```
sage: L = LieAlgebra(QQ, 2, step=4)
sage: X, Y = L.homogeneous_component_basis(3)
sage: Q = L.quotient(X + Y)
sage: Q.inject_variables()
Defining X_1, X_2, X_12, X_112, X_1112
sage: Q.bch(X_1, X_2)
X_1 + X_2 + 1/2*X_12 - 1/24*X_1112
```
For third order terms, the `IntegerListsLex` part of the sum is only `[Z_1, [Z_1, Z_1]] = 0`, so `Z_3` will be just a multiple of `[X-Y,Z_2]`, which has been quotiented out. Yet there are non-zero terms of degree 4.

At this point I don't know what would be a possible alternative check to see if the formula terminates (other than testing for nilpotency of the Lie algebra generated by the two elements). So I would say to leave the improvements to a later ticket.



---

archive/issue_comments_401780.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nThis will definitely work for now (and IIRC, it sufficient for your purposes). Thank you for looking into it (and that interesting example).",
    "created_at": "2018-09-24T22:44:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401780",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:17" align="right">comment:17</div>

This will definitely work for now (and IIRC, it sufficient for your purposes). Thank you for looking into it (and that interesting example).



---

archive/issue_events_360152.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-09-24T22:44:31Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360152"
}
```



---

archive/issue_events_360153.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-09-24T22:44:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360153"
}
```



---

archive/issue_events_360154.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-09-27T17:41:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360154"
}
```



---

archive/issue_events_360155.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "039b8747397039e3f6731c48b5014240d723bae1",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2018-09-27T17:41:24Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/26080#event-360155"
}
```



---

archive/issue_comments_401781.json:
```json
{
    "body": "Changed branch from **[u/gh-ehaka/bch-26080](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-ehaka/bch-26080)** to **[`369f7a6`](https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d)**",
    "created_at": "2018-09-27T17:41:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/26080",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/26080#issuecomment-401781",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[u/gh-ehaka/bch-26080](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-ehaka/bch-26080)** to **[`369f7a6`](https://github.com/sagemath/sagetrac-mirror/commit/369f7a626c6aa4e362ac3d671ca4e28963d9163d)**
