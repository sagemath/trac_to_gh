# Issue 33078: Is there any equivalante to sympy cse method? (Common Subexpression Elimination)

archive/issues_033078.json:
```json
{
    "body": "CC:  slelievre\n\nI copied the explanation from:\nhttps://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/07-the-hard-way.html\n\nCommon Subexpression Elimination\n\nIf you look carefully at the expressions in the two matrices you'll see repeated expressions. These are not ideal in the sense that the computer has to repeat the exact same calculation multiple times. For large expressions this can be a major issue. Compilers, such as gcc, can often eliminate common subexpressions on their own when different optimization flags are invoked but for complex expressions the algorithms in some compilers do not do a thorough job or compilation can take an extremely long time. SymPy has tools to perform common subexpression elimination which is both thorough and reasonably efficient. In particular if gcc is run with the lowest optimization setting -O0 cse can give large speedups.\n\nFor example if you have two expressions:\n\na = x*y + 5\nb = x*y + 6\n\nyou can convert this to these three expressions:\n\nz = x*y\na = z + 5\nb = z + 6\n\nand x*y only has to be computed once.\n\nThe cse() function in SymPy returns the subexpression, z = x*y, and the simplified expressions: a = z + 5, b = z + 6.\n\nHere is how it works:\n\nsm.cse?\n\nObject `sm.cse` not found.\n\nsub_exprs, simplified_rhs = sym.cse(rhs_of_odes)\n\nfor var, expr in sub_exprs:\n    sym.pprint(sym.Eq(var, expr))\n\nx\u2080 = 0.0158\u22c5y\u2080\u22c5y\u2081\nx\u2081 = -x\u2080\nx\u2082 = 27600000.0\u22c5y\u2080\u22c5y\u2084\nx\u2083 = -x\u2082\nx\u2084 = 24400.0\u22c5y\u2082\u22c5y\u2084\n       2\nx\u2085 = y\u2080 \nx\u2086 = 14520000.0\u22c5x\u2085\nx\u2087 = -x\u2086\nx\u2088 = 5.83\u22c5y\u2084\nx\u2089 = 20900000.0\u22c5y\u2080\u22c5y\u2081\u2081\nx\u2081\u2080 = -x\u2089\nx\u2081\u2081 = 35500000.0\u22c5y\u2080\u22c5y\u2085\nx\u2081\u2082 = -x\u2081\u2081\nx\u2081\u2083 = 13600000.0\u22c5y\u2080\u22c5y\u2086\nx\u2081\u2084 = -x\u2081\u2083\nx\u2081\u2085 = 22900000.0\u22c5y\u2080\u22c5y\u2087\nx\u2081\u2086 = -x\u2081\u2085\nx\u2081\u2087 = y\u2080\u22c5y\u2088\nx\u2081\u2088 = 13000000.0\u22c5x\u2081\u2087\nx\u2081\u2089 = -x\u2081\u2088\nx\u2082\u2080 = 13000000.0\u22c5y\u2080\u22c5y\u2089\n\nIs there something like this in sagemath?\n\nIssue created by migration from https://trac.sagemath.org/ticket/33315\n\n",
    "created_at": "2022-02-08T16:59:08Z",
    "labels": [
        "symbolics",
        "minor",
        "enhancement"
    ],
    "title": "Is there any equivalante to sympy cse method? (Common Subexpression Elimination)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33078",
    "user": "@dorp92"
}
```
CC:  slelievre

I copied the explanation from:
https://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/07-the-hard-way.html

Common Subexpression Elimination

If you look carefully at the expressions in the two matrices you'll see repeated expressions. These are not ideal in the sense that the computer has to repeat the exact same calculation multiple times. For large expressions this can be a major issue. Compilers, such as gcc, can often eliminate common subexpressions on their own when different optimization flags are invoked but for complex expressions the algorithms in some compilers do not do a thorough job or compilation can take an extremely long time. SymPy has tools to perform common subexpression elimination which is both thorough and reasonably efficient. In particular if gcc is run with the lowest optimization setting -O0 cse can give large speedups.

For example if you have two expressions:

a = x*y + 5
b = x*y + 6

you can convert this to these three expressions:

z = x*y
a = z + 5
b = z + 6

and x*y only has to be computed once.

The cse() function in SymPy returns the subexpression, z = x*y, and the simplified expressions: a = z + 5, b = z + 6.

Here is how it works:

sm.cse?

Object `sm.cse` not found.

sub_exprs, simplified_rhs = sym.cse(rhs_of_odes)

for var, expr in sub_exprs:
    sym.pprint(sym.Eq(var, expr))

x₀ = 0.0158⋅y₀⋅y₁
x₁ = -x₀
x₂ = 27600000.0⋅y₀⋅y₄
x₃ = -x₂
x₄ = 24400.0⋅y₂⋅y₄
       2
x₅ = y₀ 
x₆ = 14520000.0⋅x₅
x₇ = -x₆
x₈ = 5.83⋅y₄
x₉ = 20900000.0⋅y₀⋅y₁₁
x₁₀ = -x₉
x₁₁ = 35500000.0⋅y₀⋅y₅
x₁₂ = -x₁₁
x₁₃ = 13600000.0⋅y₀⋅y₆
x₁₄ = -x₁₃
x₁₅ = 22900000.0⋅y₀⋅y₇
x₁₆ = -x₁₅
x₁₇ = y₀⋅y₈
x₁₈ = 13000000.0⋅x₁₇
x₁₉ = -x₁₈
x₂₀ = 13000000.0⋅y₀⋅y₉

Is there something like this in sagemath?

Issue created by migration from https://trac.sagemath.org/ticket/33315


