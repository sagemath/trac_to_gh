# Issue 28395: Implement Eulerian Polynomials and Numbers

Issue created by migration from https://trac.sagemath.org/ticket/28632

Original creator: selia

Original creation time: 2019-10-19 08:46:02

CC:  jipilab tscrim

In combinatorics, the Eulerian number A(n, m), is the number of permutations of the numbers 1 to n in which exactly m elements are greater than the previous element (permutations with m "ascents"). They are the coefficients of the Eulerian polynomials -[https://en.wikipedia.org/wiki/Eulerian_number](https://en.wikipedia.org/wiki/Eulerian_number)

It would be nice to have Eulerian polynomials and numbers available in Sage. 
Two possible ways to do this are::

```
sage: @cached_function
....: def eulerian_polynomial(n):
....:     R = PolynomialRing(ZZ, 't')
....:     if n == 0:
....:         return R.one()
....:     t = R.gen()
....:     return R.sum(binomial(n,k) * eulerian_polynomial(k) * (t-1)**(n-1-k) for k in range(n))
```

or using another recurrence relation

```
sage: def eulerian_numbers(n):
....:     A = zero_matrix(n+1,n+1)
....:     A[0,0] = 1
....:     for i in range(1,n+1):
....:         A[i,0] = 0
....:         A[i,1] = 1
....:     for j in range(2,n+1):                                                      
....:         for k in range(2,j+1):                                                  
....:             if j == k:                                                          
....:                 A[j,k] = 1                                                      
....:             else:                                                               
....:                 A[j,k] = (j-k+1)*A[j-1,k-1] +k*A[j-1,k]
....:     return(A)
....: 
....: def eulerian_polynomial(n):
....:     R = PolynomialRing(ZZ, 't')
....:     t = R.gen()
....:     A = eulerian_numbers(n)
....:     return(R.sum( A[n,i]*t**i for i in range(n+1)))
```


I'm not sure what the best output of the eulerian_numbers function is.



---

Comment by jipilab created at 2019-10-19 10:18:53

Looking into the source, I believe a good place to go would be in `sage.combinat.combinat`. That's where Stirling numbers and other similar sequences of numbers are.

It would be nice to have access to both the numbers and the polynomials:

 - `eulerian_polynomial(n)` would return the `n`-th Eulerian polynomial (recursively defined)
 - `eulerian_number(i,n)` would return the `i`-th coefficient of the `n`-th Eulerian polynomial. (or `(n,i)` whatever fits the actual conventions best).

I guess both would benefit from recursive functions. I would look at Stirling numbers for inspiration.

I would say that `eulerian_number` should just return an integer. It is then easy to create array if one want...


```
sage: [eulerian_number(i,5) for i in range(6)]
```


for example.


---

Comment by chapoton created at 2019-11-26 12:32:04

see #22313 for something else, that could be confused with the present ticket


---

Comment by chapoton created at 2019-12-05 13:32:56

Changing status from new to needs_review.


---

Comment by chapoton created at 2019-12-05 13:32:56

Here is a proposal, with the Narayana numbers as a bonus
----
New commits:


---

Comment by git created at 2019-12-05 19:59:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2019-12-05 22:55:28

+1 for also adding the Narayama numbers.

Have you run some tests of the different implementations to see which one is faster? I am a little worried about that derivative and the products being slow compared to one multiplication in the proposed first implementation above (after expanding `(t-1)**(n-1-k)` within the code). Granted, this will likely not need to be such a speed critical implementation, so we shouldn't spend too much time on this. However, I think we should at least take a moment to look at it. (Since it is a univariate polynomial ring, we might also be faster at creating things by passing a list of coefficients.)

Also, we might want to consider using the implementation of the closed formula for the Eulerian numbers and a separate algorithm for the polynomial using them as that would be much better in terms of memory usage (and possibly creation time) when starting from large `n`.


---

Comment by git created at 2019-12-06 09:53:22

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by chapoton created at 2019-12-06 10:02:12

I have added a recursive computation for single coefficients. Maybe one could also have the direct formula for the coefficients.

The other recurrence for the polynomials seems to be wrong, unless I missed something.

*EDIT*: maybe speed is not the first concern here..


---

Comment by tscrim created at 2019-12-06 21:36:23

Replying to [comment:7 chapoton]:
> I have added a recursive computation for single coefficients. Maybe one could also have the direct formula for the coefficients.

This is on the wikipedia page as an alternating sum of binomials.

> The other recurrence for the polynomials seems to be wrong, unless I missed something.

It seems to agree with the Wikipedia page, so if it is wrong, then Wikipedia is also wrong here. (Which is always possible.) Unfortunately it sounds like we need to check to see which parts of the page are correct. `:/` I can do this tomorrow.

> *EDIT*: maybe speed is not the first concern here..

Agreed, but I was hoping it would be a simple thing to check/implement (at most an hour). I can do this in more detail tomorrow once I get back. (I am finishing up a conference this week.)


---

Comment by git created at 2019-12-07 10:38:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2019-12-07 10:39:19

i have added the alternative algo for Eulerian numbers
----
New commits:
----
New commits:


---

Comment by tscrim created at 2019-12-08 09:39:13

Thank you.

I think it would be better for the cache key not to depend on the algorithm, so

```python
@cached_function(key=lambda n,k,a: (n,k))
def eulerian_number(n, k, algorithm='recursive'):
```

and similarly for the polynomial (although this will mean you need a new test case for the `"coeffs"` algorithm). Also, I think the `"coeffs"` should not use the recursive algorithm for the Eulerian numbers.


---

Comment by git created at 2019-12-08 12:03:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2019-12-08 12:04:22

ok, thx. All done.

I also replaced one doctest for Catalan by a faster one.


---

Comment by tscrim created at 2019-12-09 02:49:50

One last little doc tweak. If that is good, then positive review.
----
New commits:


---

Comment by chapoton created at 2019-12-09 07:54:48

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2019-12-09 07:54:48

ok, indeed, I forgot that. Thx. Setting to positive


---

Comment by vbraun created at 2019-12-11 21:46:18

Resolution: fixed
