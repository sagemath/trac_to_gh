# Issue 14732: Longest common subword

archive/issues_014732.json:
```json
{
    "body": "CC:  @seblabbe @videlec\n\nLooks like this was missing. It's a pity that there is no .pyx file for words, though `:-)`\n\nNathann\n\nIssue created by migration from https://trac.sagemath.org/ticket/14969\n\n",
    "created_at": "2013-07-25T09:59:51Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.12",
    "title": "Longest common subword",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14732",
    "user": "https://github.com/nathanncohen"
}
```
CC:  @seblabbe @videlec

Looks like this was missing. It's a pity that there is no .pyx file for words, though `:-)`

Nathann

Issue created by migration from https://trac.sagemath.org/ticket/14969





---

archive/issue_comments_187499.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-07-25T10:00:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187499",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_187500.json:
```json
{
    "body": "Attachment [trac_14969-review.patch](tarball://root/attachments/some-uuid/ticket14969/trac_14969-review.patch) by @hughrthomas created at 2013-08-08 20:16:43",
    "created_at": "2013-08-08T20:16:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187500",
    "user": "https://github.com/hughrthomas"
}
```

Attachment [trac_14969-review.patch](tarball://root/attachments/some-uuid/ticket14969/trac_14969-review.patch) by @hughrthomas created at 2013-08-08 20:16:43



---

archive/issue_comments_187501.json:
```json
{
    "body": "Hi Nathann!\n\nReview patch uploaded.  I don't think it will be controversial.  I removed one line of code which did nothing useful.  (Please confirm.)\n\nThe commit message on the original patch should be, um, more descriptive.  Other than that, I am ready to give it a positive review if you approve my changes.  \n\nWhat a nice algorithm!\n\nThe same approach could be used to find all that longest common subwords.  Do you think that would be useful?  To me it seems at least as natural.  \n\ncheers,\n\nHugh",
    "created_at": "2013-08-08T20:21:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187501",
    "user": "https://github.com/hughrthomas"
}
```

Hi Nathann!

Review patch uploaded.  I don't think it will be controversial.  I removed one line of code which did nothing useful.  (Please confirm.)

The commit message on the original patch should be, um, more descriptive.  Other than that, I am ready to give it a positive review if you approve my changes.  

What a nice algorithm!

The same approach could be used to find all that longest common subwords.  Do you think that would be useful?  To me it seems at least as natural.  

cheers,

Hugh



---

archive/issue_comments_187502.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-08-08T20:21:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187502",
    "user": "https://github.com/hughrthomas"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_187503.json:
```json
{
    "body": "Attachment [trac_14969.patch](tarball://root/attachments/some-uuid/ticket14969/trac_14969.patch) by @nathanncohen created at 2013-08-09 08:18:59",
    "created_at": "2013-08-09T08:18:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187503",
    "user": "https://github.com/nathanncohen"
}
```

Attachment [trac_14969.patch](tarball://root/attachments/some-uuid/ticket14969/trac_14969.patch) by @nathanncohen created at 2013-08-09 08:18:59



---

archive/issue_comments_187504.json:
```json
{
    "body": "Helloooooooooooo !!\n\n> Review patch uploaded.  I don't think it will be controversial.\n+1\n\n> I removed one line of code which did nothing useful.  (Please confirm.)\n+1 \n\n> The commit message on the original patch should be, um, more descriptive.\n\nRight. Fixed.\n\n> Other than that, I am ready to give it a positive review if you approve my changes.\n+1\n\n> What a nice algorithm!\n> \n> The same approach could be used to find all that longest common subwords.  Do you think that would be useful?  To me it seems at least as natural.  \n\nHmmmm. Well,  the same algorithm with the same complexity can return the number of longest common subwords too. In order to return all longest subwords, though, one would have to keep track of all `l[i,j]`, and not just `l[i,j]` and `l[i-1,j]`.\n\nNathann",
    "created_at": "2013-08-09T08:22:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187504",
    "user": "https://github.com/nathanncohen"
}
```

Helloooooooooooo !!

> Review patch uploaded.  I don't think it will be controversial.
+1

> I removed one line of code which did nothing useful.  (Please confirm.)
+1 

> The commit message on the original patch should be, um, more descriptive.

Right. Fixed.

> Other than that, I am ready to give it a positive review if you approve my changes.
+1

> What a nice algorithm!
> 
> The same approach could be used to find all that longest common subwords.  Do you think that would be useful?  To me it seems at least as natural.  

Hmmmm. Well,  the same algorithm with the same complexity can return the number of longest common subwords too. In order to return all longest subwords, though, one would have to keep track of all `l[i,j]`, and not just `l[i,j]` and `l[i-1,j]`.

Nathann



---

archive/issue_comments_187505.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-08-09T08:22:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187505",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_187506.json:
```json
{
    "body": "Replying to [comment:3 ncohen]:\n> \n> Hmmmm. Well,  the same algorithm with the same complexity can return the number of longest common subwords too. In order to return all longest subwords, though, one would have to keep track of all `l[i,j]`, and not just `l[i,j]` and `l[i-1,j]`.\n\nWhat I was thinking of was that l[i,j] would store a list of the longest subwords of self[:i],other[:j].  Then at each step, you merge the three lists l[i,j-1], l[i-1,j], and l[i-1,j-1] with self[i] tacked onto the end of each one if self[i]==other[j], and remove the items that aren't as long as the maximum.  \n\nThis wouldn't have the same complexity as the algorithm you implemented, but that seems somehow not unreasonable, since you're asking for more output.  Is this inefficient?",
    "created_at": "2013-08-09T11:51:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187506",
    "user": "https://github.com/hughrthomas"
}
```

Replying to [comment:3 ncohen]:
> 
> Hmmmm. Well,  the same algorithm with the same complexity can return the number of longest common subwords too. In order to return all longest subwords, though, one would have to keep track of all `l[i,j]`, and not just `l[i,j]` and `l[i-1,j]`.

What I was thinking of was that l[i,j] would store a list of the longest subwords of self[:i],other[:j].  Then at each step, you merge the three lists l[i,j-1], l[i-1,j], and l[i-1,j-1] with self[i] tacked onto the end of each one if self[i]==other[j], and remove the items that aren't as long as the maximum.  

This wouldn't have the same complexity as the algorithm you implemented, but that seems somehow not unreasonable, since you're asking for more output.  Is this inefficient?



---

archive/issue_comments_187507.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-08-09T11:53:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187507",
    "user": "https://github.com/hughrthomas"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_187508.json:
```json
{
    "body": "Hellooooooooo !!\n\n> What I was thinking of was that l[i,j] would store a list of the longest subwords of self[:i],other[:j].  Then at each step, you merge the three lists l[i,j-1], l[i-1,j], and l[i-1,j-1] with self[i] tacked onto the end of each one if self[i]==other[j], and remove the items that aren't as long as the maximum.  \n> \n> This wouldn't have the same complexity as the algorithm you implemented, but that seems somehow not unreasonable, since you're asking for more output.  Is this inefficient?  \n\nWell it's fine. It's just that it would be slightly better to do the computations twice : at first you only compute (and remember) all values of l[i,j] (i.e. just the size of the longest subword), then in a second pass you can actually build the list of longest subwords, from l[i,j] and recursively to the smaller values of l, only when needed, i.e. when it participates to a word of maximum length.\n\nThis way you make sure that you are not building and maintaining very long lists of words which you would throw away later `:-)`\n\nNathann",
    "created_at": "2013-08-09T11:56:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187508",
    "user": "https://github.com/nathanncohen"
}
```

Hellooooooooo !!

> What I was thinking of was that l[i,j] would store a list of the longest subwords of self[:i],other[:j].  Then at each step, you merge the three lists l[i,j-1], l[i-1,j], and l[i-1,j-1] with self[i] tacked onto the end of each one if self[i]==other[j], and remove the items that aren't as long as the maximum.  
> 
> This wouldn't have the same complexity as the algorithm you implemented, but that seems somehow not unreasonable, since you're asking for more output.  Is this inefficient?  

Well it's fine. It's just that it would be slightly better to do the computations twice : at first you only compute (and remember) all values of l[i,j] (i.e. just the size of the longest subword), then in a second pass you can actually build the list of longest subwords, from l[i,j] and recursively to the smaller values of l, only when needed, i.e. when it participates to a word of maximum length.

This way you make sure that you are not building and maintaining very long lists of words which you would throw away later `:-)`

Nathann



---

archive/issue_comments_187509.json:
```json
{
    "body": "Oh, and thank for your the review !!!\n\nNathann",
    "created_at": "2013-08-09T11:57:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187509",
    "user": "https://github.com/nathanncohen"
}
```

Oh, and thank for your the review !!!

Nathann



---

archive/issue_comments_187510.json:
```json
{
    "body": "Replying to [comment:6 ncohen]:\n > This way you make sure that you are not building and maintaining very long lists of words which you would throw away later `:-)`\n\nOh, I see!  Thanks very much for the explanation.  \n\nAnd as regards the review, you are very welcome -- it's fun to review efficient code!\n\nHugh",
    "created_at": "2013-08-09T12:29:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187510",
    "user": "https://github.com/hughrthomas"
}
```

Replying to [comment:6 ncohen]:
 > This way you make sure that you are not building and maintaining very long lists of words which you would throw away later `:-)`

Oh, I see!  Thanks very much for the explanation.  

And as regards the review, you are very welcome -- it's fun to review efficient code!

Hugh



---

archive/issue_events_042952.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-28T06:53:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14732#event-42952"
}
```



---

archive/issue_comments_187511.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-08-28T06:53:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187511",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_comments_187512.json:
```json
{
    "body": "Replying to [ticket:14969 ncohen]:\n> Looks like this was missing. It's a pity that there is no .pyx file for words, though `:-)`\n\nThere is one :\n\nsage/combinat/words/word_datatypes.pyx\n\nCode that goes there will apply only for words on specific data type (like list, tuple, str). If a method exists in the cython file and in the `finite_word.py` file, the cython method is called instead.\n\nI would be curious to know what is the gain... tell me if your test it.",
    "created_at": "2013-09-12T15:34:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14732",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14732#issuecomment-187512",
    "user": "https://github.com/seblabbe"
}
```

Replying to [ticket:14969 ncohen]:
> Looks like this was missing. It's a pity that there is no .pyx file for words, though `:-)`

There is one :

sage/combinat/words/word_datatypes.pyx

Code that goes there will apply only for words on specific data type (like list, tuple, str). If a method exists in the cython file and in the `finite_word.py` file, the cython method is called instead.

I would be curious to know what is the gain... tell me if your test it.
