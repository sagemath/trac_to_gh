# Issue 27908: Crystal on Semistandard Set Valued Tableaux

archive/issues_027908.json:
```json
{
    "body": "CC:  @jdmeza @tscrim @opechenik @anneschilling @bsalisbury1 @darijgr\n\nKeywords: fpsac2019\n\nImplementation of semistandard set-valued tableaux and their type A crystal structure as described by Monical, Pechenik and Scrimshaw, see \u200bhttps://arxiv.org/abs/1807.03294.\n\nIssue created by migration from https://trac.sagemath.org/ticket/28145\n\n",
    "created_at": "2019-07-09T16:34:57Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Crystal on Semistandard Set Valued Tableaux",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27908",
    "user": "wpoh"
}
```
CC:  @jdmeza @tscrim @opechenik @anneschilling @bsalisbury1 @darijgr

Keywords: fpsac2019

Implementation of semistandard set-valued tableaux and their type A crystal structure as described by Monical, Pechenik and Scrimshaw, see â€‹https://arxiv.org/abs/1807.03294.

Issue created by migration from https://trac.sagemath.org/ticket/28145





---

archive/issue_comments_394069.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-10T11:58:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394069",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394070.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-10T19:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394070",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394071.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-10T20:36:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394071",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394072.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-11T08:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394072",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394073.json:
```json
{
    "body": "some details:\n\n* This\n\n```\nReturns the excess statistic for self\n```\n\nshould be (no s and a final dot)\n\n```\nReturn the excess statistic for ``self``.\n```\n\nSame for \"Determines\", \"Initializes\", etc\n\n* Always have an empty line after `EXAMPLES::`\n\n* Comparison to None should be `right is not None`, same for \"below\"",
    "created_at": "2019-07-11T09:06:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394073",
    "user": "@fchapoton"
}
```

some details:

* This

```
Returns the excess statistic for self
```

should be (no s and a final dot)

```
Return the excess statistic for ``self``.
```

Same for "Determines", "Initializes", etc

* Always have an empty line after `EXAMPLES::`

* Comparison to None should be `right is not None`, same for "below"



---

archive/issue_comments_394074.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-11T11:53:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394074",
    "user": "@opechenik"
}
```

New commits:



---

archive/issue_comments_394075.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-11T13:22:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394075",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394076.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-11T13:37:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394076",
    "user": "@opechenik"
}
```

New commits:



---

archive/issue_comments_394077.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-11T16:20:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394077",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394078.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-11T16:26:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394078",
    "user": "@opechenik"
}
```

New commits:



---

archive/issue_comments_394079.json:
```json
{
    "body": "Let me know when the patch is ready for review!",
    "created_at": "2019-07-11T20:39:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394079",
    "user": "@anneschilling"
}
```

Let me know when the patch is ready for review!



---

archive/issue_comments_394080.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-12T11:11:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394080",
    "user": "wpoh"
}
```

New commits:



---

archive/issue_comments_394081.json:
```json
{
    "body": "Some quick notes:\n\n`SemistandardSetValuedTableaux` is *not* a factory class, it is an abstract base class (ABC) that also handles dispatching to the appropriate parent class. However, this should not be stated in the documentation as this is an implementation detail.\n\nI think we should split the `SemistandardSetValuedTableau(x)` classes into a separate file. The `tableau.py` is already quite big and this is just dependent on those classes.\n\nThe `SetValuedTableaux` class should be named consistently with `Semistandard` added (explicit is better than implicit; plus we can be more loose with naming rules in papers as they are more localized). Also, I think it would be better served just being in the corresponding tableau file.\n\nIt probably is better to have the crystal just be a parent in the SVT hierarchy corresponding to a fixed shape (with possibly a max entry defined). That way you do not effectively have two such parents, but you probably need a warning saying the output of weight is slightly different than the others (although it typically behaves the same).\n\nRemember that by the time it gets to `check`, the input should already be standardized (so checking `tuple` can be applied should have already been done).",
    "created_at": "2019-07-14T07:14:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394081",
    "user": "@tscrim"
}
```

Some quick notes:

`SemistandardSetValuedTableaux` is *not* a factory class, it is an abstract base class (ABC) that also handles dispatching to the appropriate parent class. However, this should not be stated in the documentation as this is an implementation detail.

I think we should split the `SemistandardSetValuedTableau(x)` classes into a separate file. The `tableau.py` is already quite big and this is just dependent on those classes.

The `SetValuedTableaux` class should be named consistently with `Semistandard` added (explicit is better than implicit; plus we can be more loose with naming rules in papers as they are more localized). Also, I think it would be better served just being in the corresponding tableau file.

It probably is better to have the crystal just be a parent in the SVT hierarchy corresponding to a fixed shape (with possibly a max entry defined). That way you do not effectively have two such parents, but you probably need a warning saying the output of weight is slightly different than the others (although it typically behaves the same).

Remember that by the time it gets to `check`, the input should already be standardized (so checking `tuple` can be applied should have already been done).



---

archive/issue_comments_394082.json:
```json
{
    "body": "I would suggest to follow a similar structure as Kirill Paramonov did for the shifted primed tableaux and crystal structure on it. He put all his code for these tableaux in the file shifted_primed_tableau.py in the combinat folder and created the corresponding crystal.",
    "created_at": "2019-07-14T22:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394082",
    "user": "@anneschilling"
}
```

I would suggest to follow a similar structure as Kirill Paramonov did for the shifted primed tableaux and crystal structure on it. He put all his code for these tableaux in the file shifted_primed_tableau.py in the combinat folder and created the corresponding crystal.



---

archive/issue_comments_394083.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-20T18:32:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394083",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394084.json:
```json
{
    "body": "Replying to [comment:23 tscrim]:\n> I think we should split the `SemistandardSetValuedTableau(x)` classes into a separate file. The `tableau.py` is already quite big and this is just dependent on those classes.\n> \n> The `SetValuedTableaux` class should be named consistently with `Semistandard` added (explicit is better than implicit; plus we can be more loose with naming rules in papers as they are more localized). Also, I think it would be better served just being in the corresponding tableau file.\n> \n> It probably is better to have the crystal just be a parent in the SVT hierarchy corresponding to a fixed shape (with possibly a max entry defined). That way you do not effectively have two such parents, but you probably need a warning saying the output of weight is slightly different than the others (although it typically behaves the same).\n\n`SemistandardSetValuedTableau(x)` classes are now in one file (see semistandard_set_valued_tableau.py) and the crystal element inherits from `SemistandardSetValuedTableau`. Probably this is not the best way, because as you said, output of weight() may be different from those of crystal elements (in case one wishes to work in the weight lattice). I welcome suggestion or improvement on how to access both weight outputs from tableau and crystal element.\n\nMost of the required code should be up; working on documentation, tests and cleanup soon. Do tell if other features need to be in this implementation.",
    "created_at": "2019-07-20T18:45:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394084",
    "user": "wpoh"
}
```

Replying to [comment:23 tscrim]:
> I think we should split the `SemistandardSetValuedTableau(x)` classes into a separate file. The `tableau.py` is already quite big and this is just dependent on those classes.
> 
> The `SetValuedTableaux` class should be named consistently with `Semistandard` added (explicit is better than implicit; plus we can be more loose with naming rules in papers as they are more localized). Also, I think it would be better served just being in the corresponding tableau file.
> 
> It probably is better to have the crystal just be a parent in the SVT hierarchy corresponding to a fixed shape (with possibly a max entry defined). That way you do not effectively have two such parents, but you probably need a warning saying the output of weight is slightly different than the others (although it typically behaves the same).

`SemistandardSetValuedTableau(x)` classes are now in one file (see semistandard_set_valued_tableau.py) and the crystal element inherits from `SemistandardSetValuedTableau`. Probably this is not the best way, because as you said, output of weight() may be different from those of crystal elements (in case one wishes to work in the weight lattice). I welcome suggestion or improvement on how to access both weight outputs from tableau and crystal element.

Most of the required code should be up; working on documentation, tests and cleanup soon. Do tell if other features need to be in this implementation.



---

archive/issue_comments_394085.json:
```json
{
    "body": "Replying to [comment:26 wpoh]:\n> Replying to [comment:23 tscrim]:\n> > I think we should split the `SemistandardSetValuedTableau(x)` classes into a separate file. The `tableau.py` is already quite big and this is just dependent on those classes.\n> > \n> > The `SetValuedTableaux` class should be named consistently with `Semistandard` added (explicit is better than implicit; plus we can be more loose with naming rules in papers as they are more localized). Also, I think it would be better served just being in the corresponding tableau file.\n> > \n> > It probably is better to have the crystal just be a parent in the SVT hierarchy corresponding to a fixed shape (with possibly a max entry defined). That way you do not effectively have two such parents, but you probably need a warning saying the output of weight is slightly different than the others (although it typically behaves the same).\n> \n> `SemistandardSetValuedTableau(x)` classes are now in one file (see semistandard_set_valued_tableau.py) and the crystal element inherits from `SemistandardSetValuedTableau`. Probably this is not the best way, because as you said, output of weight() may be different from those of crystal elements (in case one wishes to work in the weight lattice). I welcome suggestion or improvement on how to access both weight outputs from tableau and crystal element.\n\nFor the crystal elements, I think it will be faster to compute the weight by definition -- e.g., (#1s, #2s, ...) -- rather than using the generic crystals code. This also allows you to document the difference. As I mentioned, the elements of the ambient space behave in the same way as the list for item lookup, but unfortunately not for iteration.\n\nActually, another way out of this is just to make all of the tableaux classes a crystal. We do have `['A', NN]` for type A<sub>+oo</sub>. It will be different than for the usual tableaux, but I think that inconsistency is less surprising and easier to document.\n\nFor the class names, you can remove the `size_inf` part as the naming convention for tableaux (among others) is just adding onto the name the things which are finite/specified. Although perhaps that is a problem for the `module_generators`...maybe that could be a `Family` instead of a tuple?\n\nThis is bad:\n\n```\n        SemistandardSetValuedTableaux.__init__(self,max_entry=max_entry,category=ClassicalCrystals())\n        self._shape = p\n        self._cartan_type = CartanType(['A', max_entry-1])\n        self.Element = CrystalElementSemistandardSetValuedTableau\n```\n\nThe correct element is not created because all of the `Parent.__init__` stuff is done with the wrong `Element`, so `self.element_class` is not a subclass of `self.Element`. Just set `Element` as a normal class-level attribute.\n\nIt would be good to have both `crowding` and `uncrowding` maps accessible. I would make them *also* methods of `SemistandardTableau` and `SemistandardSetValuedTableau`, respectively.",
    "created_at": "2019-07-21T07:15:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394085",
    "user": "@tscrim"
}
```

Replying to [comment:26 wpoh]:
> Replying to [comment:23 tscrim]:
> > I think we should split the `SemistandardSetValuedTableau(x)` classes into a separate file. The `tableau.py` is already quite big and this is just dependent on those classes.
> > 
> > The `SetValuedTableaux` class should be named consistently with `Semistandard` added (explicit is better than implicit; plus we can be more loose with naming rules in papers as they are more localized). Also, I think it would be better served just being in the corresponding tableau file.
> > 
> > It probably is better to have the crystal just be a parent in the SVT hierarchy corresponding to a fixed shape (with possibly a max entry defined). That way you do not effectively have two such parents, but you probably need a warning saying the output of weight is slightly different than the others (although it typically behaves the same).
> 
> `SemistandardSetValuedTableau(x)` classes are now in one file (see semistandard_set_valued_tableau.py) and the crystal element inherits from `SemistandardSetValuedTableau`. Probably this is not the best way, because as you said, output of weight() may be different from those of crystal elements (in case one wishes to work in the weight lattice). I welcome suggestion or improvement on how to access both weight outputs from tableau and crystal element.

For the crystal elements, I think it will be faster to compute the weight by definition -- e.g., (#1s, #2s, ...) -- rather than using the generic crystals code. This also allows you to document the difference. As I mentioned, the elements of the ambient space behave in the same way as the list for item lookup, but unfortunately not for iteration.

Actually, another way out of this is just to make all of the tableaux classes a crystal. We do have `['A', NN]` for type A<sub>+oo</sub>. It will be different than for the usual tableaux, but I think that inconsistency is less surprising and easier to document.

For the class names, you can remove the `size_inf` part as the naming convention for tableaux (among others) is just adding onto the name the things which are finite/specified. Although perhaps that is a problem for the `module_generators`...maybe that could be a `Family` instead of a tuple?

This is bad:

```
        SemistandardSetValuedTableaux.__init__(self,max_entry=max_entry,category=ClassicalCrystals())
        self._shape = p
        self._cartan_type = CartanType(['A', max_entry-1])
        self.Element = CrystalElementSemistandardSetValuedTableau
```

The correct element is not created because all of the `Parent.__init__` stuff is done with the wrong `Element`, so `self.element_class` is not a subclass of `self.Element`. Just set `Element` as a normal class-level attribute.

It would be good to have both `crowding` and `uncrowding` maps accessible. I would make them *also* methods of `SemistandardTableau` and `SemistandardSetValuedTableau`, respectively.



---

archive/issue_comments_394086.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-08-12T08:32:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394086",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394087.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-08-19T03:27:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394087",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394088.json:
```json
{
    "body": "Good news: Based on Travis's suggestion (thanks Travis!) for iterating over countably many iterators (each generating countably many tableaux), the iterators for all semistandard set-valued tableaux works now.\n\nNot so good news: The following tests are failing, and I still need to figure them out.\n\n\n```\nwencin@wencin--VirtualBox2:~/sage$ sage -t src/sage/combinat/semistandard_set_valued_tableau.py \ntoo few successful tests, not using stored timings\nRunning doctests with ID 2019-08-18-20-23-59-4aa7d8db.\nGit branch: t/28145/crystal_on_semistandard_set_valued_tableaux\nUsing --optional=build,ccache,dochtml,dot2tex,memlimit,mpir,python2,sage\nDoctesting 1 file.\nsage -t src/sage/combinat/semistandard_set_valued_tableau.py\n**********************************************************************\nFile \"src/sage/combinat/semistandard_set_valued_tableau.py\", line 1393, in sage.combinat.semistandard_set_valued_tableau.SemistandardSetValuedTableaux_shape.__init__\nFailed example:\n    TestSuite(SemistandardSetValuedTableaux([])).run()\nExpected nothing\nGot:\n      Failure in _test_stembridge_local_axioms:\n      Traceback (most recent call last):\n        File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py\", line 296, in run\n          test_method(tester=tester)\n        File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py\", line 749, in _test_stembridge_local_axioms\n          for (i,j) in Subsets(index_set, 2):\n        File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py\", line 757, in __iter__\n          for x in self._fast_iterator():\n        File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py\", line 740, in _fast_iterator\n          return itertools.combinations(self._s, self._k)\n        File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/enumerated_sets.py\", line 485, in __len__\n          raise NotImplementedError('infinite set')\n      NotImplementedError: infinite set\n      ------------------------------------------------------------\n      The following tests failed: _test_stembridge_local_axioms\n    Failure in _test_elements\n    Failure in _test_stembridge_local_axioms:\n    Traceback (most recent call last):\n      File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py\", line 296, in run\n        test_method(tester=tester)\n      File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py\", line 313, in _test_stembridge_local_axioms\n        goodness = x._test_stembridge_local_axioms(index_set, verbose)\n      File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py\", line 749, in _test_stembridge_local_axioms\n        for (i,j) in Subsets(index_set, 2):\n      File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py\", line 757, in __iter__\n        for x in self._fast_iterator():\n      File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py\", line 740, in _fast_iterator\n        return itertools.combinations(self._s, self._k)\n      File \"/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/enumerated_sets.py\", line 485, in __len__\n        raise NotImplementedError('infinite set')\n    NotImplementedError: infinite set\n    ------------------------------------------------------------\n    The following tests failed: _test_elements, _test_stembridge_local_axioms\n**********************************************************************\n1 item had failures:\n   1 of   4 in sage.combinat.semistandard_set_valued_tableau.SemistandardSetValuedTableaux_shape.__init__\n    [301 tests, 1 failure, 4.91 s]\n----------------------------------------------------------------------\nsage -t src/sage/combinat/semistandard_set_valued_tableau.py  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 5.5 seconds\n    cpu time: 2.2 seconds\n    cumulative wall time: 4.9 seconds\n\n```\n",
    "created_at": "2019-08-19T03:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394088",
    "user": "wpoh"
}
```

Good news: Based on Travis's suggestion (thanks Travis!) for iterating over countably many iterators (each generating countably many tableaux), the iterators for all semistandard set-valued tableaux works now.

Not so good news: The following tests are failing, and I still need to figure them out.


```
wencin@wencin--VirtualBox2:~/sage$ sage -t src/sage/combinat/semistandard_set_valued_tableau.py 
too few successful tests, not using stored timings
Running doctests with ID 2019-08-18-20-23-59-4aa7d8db.
Git branch: t/28145/crystal_on_semistandard_set_valued_tableaux
Using --optional=build,ccache,dochtml,dot2tex,memlimit,mpir,python2,sage
Doctesting 1 file.
sage -t src/sage/combinat/semistandard_set_valued_tableau.py
**********************************************************************
File "src/sage/combinat/semistandard_set_valued_tableau.py", line 1393, in sage.combinat.semistandard_set_valued_tableau.SemistandardSetValuedTableaux_shape.__init__
Failed example:
    TestSuite(SemistandardSetValuedTableaux([])).run()
Expected nothing
Got:
      Failure in _test_stembridge_local_axioms:
      Traceback (most recent call last):
        File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 296, in run
          test_method(tester=tester)
        File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py", line 749, in _test_stembridge_local_axioms
          for (i,j) in Subsets(index_set, 2):
        File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py", line 757, in __iter__
          for x in self._fast_iterator():
        File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py", line 740, in _fast_iterator
          return itertools.combinations(self._s, self._k)
        File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/enumerated_sets.py", line 485, in __len__
          raise NotImplementedError('infinite set')
      NotImplementedError: infinite set
      ------------------------------------------------------------
      The following tests failed: _test_stembridge_local_axioms
    Failure in _test_elements
    Failure in _test_stembridge_local_axioms:
    Traceback (most recent call last):
      File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 296, in run
        test_method(tester=tester)
      File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py", line 313, in _test_stembridge_local_axioms
        goodness = x._test_stembridge_local_axioms(index_set, verbose)
      File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py", line 749, in _test_stembridge_local_axioms
        for (i,j) in Subsets(index_set, 2):
      File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py", line 757, in __iter__
        for x in self._fast_iterator():
      File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/combinat/subset.py", line 740, in _fast_iterator
        return itertools.combinations(self._s, self._k)
      File "/home/wencin/sage/local/lib/python2.7/site-packages/sage/categories/enumerated_sets.py", line 485, in __len__
        raise NotImplementedError('infinite set')
    NotImplementedError: infinite set
    ------------------------------------------------------------
    The following tests failed: _test_elements, _test_stembridge_local_axioms
**********************************************************************
1 item had failures:
   1 of   4 in sage.combinat.semistandard_set_valued_tableau.SemistandardSetValuedTableaux_shape.__init__
    [301 tests, 1 failure, 4.91 s]
----------------------------------------------------------------------
sage -t src/sage/combinat/semistandard_set_valued_tableau.py  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 5.5 seconds
    cpu time: 2.2 seconds
    cumulative wall time: 4.9 seconds

```




---

archive/issue_comments_394089.json:
```json
{
    "body": "The problem is that the Stembridge local axioms test assumes that the index set is finite. This will be the first implementation of a type A<sub>oo</sub> crystal, so we are running into these little issues. So one option is to just disable the test, but I think we can easily fix it by making this change:\n\n```diff\n-            if index_set is None: index_set=self.index_set()\n+            if index_set is None:\n+                index_set=self.index_set()\n+                if index_set in Sets().Infinite():\n+                    it = iter(index_set)\n+                    index_set = [it.next() for _ in range(10)]\n```\n\nthat way we get the first 10 elements. The other option would be to get 10 random elements.\nA final option would be to use `from sage.misc.misc import some_tuples` and throw out all of the pairs where `i == j`, that is\n\n```diff\n-            for (i,j) in Subsets(index_set, 2):\n+            from sage.misc.misc import some_tuples\n+            for i,j in some_tuples(index_set, 2, tester._max_runs):\n+                if i == j:\n+                    continue\n+                # Now do the rest of the test\n```\n",
    "created_at": "2019-08-19T04:04:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394089",
    "user": "@tscrim"
}
```

The problem is that the Stembridge local axioms test assumes that the index set is finite. This will be the first implementation of a type A<sub>oo</sub> crystal, so we are running into these little issues. So one option is to just disable the test, but I think we can easily fix it by making this change:

```diff
-            if index_set is None: index_set=self.index_set()
+            if index_set is None:
+                index_set=self.index_set()
+                if index_set in Sets().Infinite():
+                    it = iter(index_set)
+                    index_set = [it.next() for _ in range(10)]
```

that way we get the first 10 elements. The other option would be to get 10 random elements.
A final option would be to use `from sage.misc.misc import some_tuples` and throw out all of the pairs where `i == j`, that is

```diff
-            for (i,j) in Subsets(index_set, 2):
+            from sage.misc.misc import some_tuples
+            for i,j in some_tuples(index_set, 2, tester._max_runs):
+                if i == j:
+                    continue
+                # Now do the rest of the test
```




---

archive/issue_comments_394090.json:
```json
{
    "body": "Replying to [comment:31 tscrim]:\n> The problem is that the Stembridge local axioms test assumes that the index set is finite. This will be the first implementation of a type A<sub>oo</sub> crystal, so we are running into these little issues. \n\nShiftedPrimedTableaux also contains an implementation of a type A<sub>oo</sub> crystal!",
    "created_at": "2019-08-19T04:25:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394090",
    "user": "@anneschilling"
}
```

Replying to [comment:31 tscrim]:
> The problem is that the Stembridge local axioms test assumes that the index set is finite. This will be the first implementation of a type A<sub>oo</sub> crystal, so we are running into these little issues. 

ShiftedPrimedTableaux also contains an implementation of a type A<sub>oo</sub> crystal!



---

archive/issue_comments_394091.json:
```json
{
    "body": "Replying to [comment:32 aschilling]:\n> Replying to [comment:31 tscrim]:\n> > The problem is that the Stembridge local axioms test assumes that the index set is finite. This will be the first implementation of a type A<sub>oo</sub> crystal, so we are running into these little issues. \n> \n> ShiftedPrimedTableaux also contains an implementation of a type A<sub>oo</sub> crystal!\n\nI probably forgot about that. Yet, the A<sub>oo</sub> crystal there did not have `TestSuite(SPT).run()` call, so this was not previously caught.",
    "created_at": "2019-08-19T05:32:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394091",
    "user": "@tscrim"
}
```

Replying to [comment:32 aschilling]:
> Replying to [comment:31 tscrim]:
> > The problem is that the Stembridge local axioms test assumes that the index set is finite. This will be the first implementation of a type A<sub>oo</sub> crystal, so we are running into these little issues. 
> 
> ShiftedPrimedTableaux also contains an implementation of a type A<sub>oo</sub> crystal!

I probably forgot about that. Yet, the A<sub>oo</sub> crystal there did not have `TestSuite(SPT).run()` call, so this was not previously caught.



---

archive/issue_comments_394092.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-12-27T02:35:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394092",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394093.json:
```json
{
    "body": "`self.parent().parent().Element` is bad because you are not using the actual element class from the category framework. Instead you should use `a_parent_obj.element_class(foo)`. Also, your `EXAMPLES::` should have a blankline after them and there is a merge conflict with the latest beta (likely trivial).",
    "created_at": "2019-12-27T16:46:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394093",
    "user": "@tscrim"
}
```

`self.parent().parent().Element` is bad because you are not using the actual element class from the category framework. Instead you should use `a_parent_obj.element_class(foo)`. Also, your `EXAMPLES::` should have a blankline after them and there is a merge conflict with the latest beta (likely trivial).



---

archive/issue_comments_394094.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394094",
    "user": "@embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_394095.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394095",
    "user": "@mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_394096.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27908",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27908#issuecomment-394096",
    "user": "@mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
