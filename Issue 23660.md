# Issue 23660: Some minor cleanup with simplicial sets

archive/issues_023660.json:
```json
{
    "body": "CC:  @tscrim\n\nMinor cleanup:\n\n- fix a few bad spots in the documentation (e.g., the docstring for the function `is_injective` says \"Return True if this map is surjective\").\n\n- the disjoint union construction should ignore any empty factors, and the wedge sum (= one point union) construction should ignore any factors which are just single points.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/23897\n\n",
    "created_at": "2017-09-19T23:23:27Z",
    "labels": [
        "component: algebraic topology",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "Some minor cleanup with simplicial sets",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23660",
    "user": "https://github.com/jhpalmieri"
}
```
CC:  @tscrim

Minor cleanup:

- fix a few bad spots in the documentation (e.g., the docstring for the function `is_injective` says "Return True if this map is surjective").

- the disjoint union construction should ignore any empty factors, and the wedge sum (= one point union) construction should ignore any factors which are just single points.


Issue created by migration from https://trac.sagemath.org/ticket/23897





---

archive/issue_comments_331033.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-09-19T23:24:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331033",
    "user": "https://github.com/jhpalmieri"
}
```

New commits:



---

archive/issue_comments_331034.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-09-19T23:24:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331034",
    "user": "https://github.com/jhpalmieri"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_331035.json:
```json
{
    "body": "ok, looks good.",
    "created_at": "2017-09-20T07:58:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331035",
    "user": "https://github.com/fchapoton"
}
```

ok, looks good.



---

archive/issue_comments_331036.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-09-20T07:58:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331036",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_331037.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2017-09-20T18:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331037",
    "user": "https://github.com/tscrim"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_331038.json:
```json
{
    "body": "I'm not sure about ignoring single points in the wedge product. It is used in the construction information for the wedge product, such as `defining_map` and `structure_map`. There can also be mathematical reasons for wanting that single point to be considered in the wedge product.\n\nSimilar comments for the disjoint union.",
    "created_at": "2017-09-20T18:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331038",
    "user": "https://github.com/tscrim"
}
```

I'm not sure about ignoring single points in the wedge product. It is used in the construction information for the wedge product, such as `defining_map` and `structure_map`. There can also be mathematical reasons for wanting that single point to be considered in the wedge product.

Similar comments for the disjoint union.



---

archive/issue_comments_331039.json:
```json
{
    "body": "For disjoint unions, I almost can't imagine why you would want to consider \"(empty set) union X union Y\" to not be the same as \"X union Y\". Mathematically they are the same set. The same goes for wedges. (This is not the same as for products, for example, in which there is an obvious bijection between \"X x {y}\" and \"X\", but they are not mathematically identical.) The only situation I can imagine is if you construct some sets, don't know that some are empty, take their disjoint union, and then want to keep track of the indices of those sets in the list of factors. You can always use the `factors` method to recover the list of nonempty factors in this case. If you want I can add more documentation, emphasizing that these terms are completely ignored, dropped from the factors defining the construction. Or possibly add a flag (on by default) which says to ignore those factors.\n\nI was led to this when I was working on something else. I wanted to create a disjoint union of n copies of X, and given the two choices\n\n- `Empty().disjoint_union(*[X for i in range(n)])`\n- `X.disjoint_union(*[X for i in range(n-1)])`\n\nI like the first better, because the second seems to put too much focus on the initial factor of `X`, separating it from the others.",
    "created_at": "2017-09-20T18:20:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331039",
    "user": "https://github.com/jhpalmieri"
}
```

For disjoint unions, I almost can't imagine why you would want to consider "(empty set) union X union Y" to not be the same as "X union Y". Mathematically they are the same set. The same goes for wedges. (This is not the same as for products, for example, in which there is an obvious bijection between "X x {y}" and "X", but they are not mathematically identical.) The only situation I can imagine is if you construct some sets, don't know that some are empty, take their disjoint union, and then want to keep track of the indices of those sets in the list of factors. You can always use the `factors` method to recover the list of nonempty factors in this case. If you want I can add more documentation, emphasizing that these terms are completely ignored, dropped from the factors defining the construction. Or possibly add a flag (on by default) which says to ignore those factors.

I was led to this when I was working on something else. I wanted to create a disjoint union of n copies of X, and given the two choices

- `Empty().disjoint_union(*[X for i in range(n)])`
- `X.disjoint_union(*[X for i in range(n-1)])`

I like the first better, because the second seems to put too much focus on the initial factor of `X`, separating it from the others.



---

archive/issue_comments_331040.json:
```json
{
    "body": "As you said, sometimes you do not necessarily know they are empty and you are doing a construction where you expect a specific number of factors or it is natural to consider them as a factor. Would you consider `{x} \\sqcup {y}` to be the same set as `{x, y}`? I would say they are usually naturally isomorphic, unless `y = x`, and we as mathematicians would write them as equals for simplicity. However, when telling it to a computer, which doesn't allow as much ambiguity, it can be worthwhile to differentiate.\n\nAs a possible use-case, say you are constructing a wedge product from a bunch of spaces indexed by permutations, where some of them are a single point, where maybe you don't necessarily know which of them are a priori. Then you want to get some information about each of the factors (say, use the natural inclusion maps), but if you discard the single points, you have to keep track of the construction sets, which adds to the user's burden and doubles the memory usage.\n\nI do not have a specific use-case in mind, and so I won't hold this ticket up for this. Yet, I wanted to at least have a quick discussion about it.\n\nAs for your use-case, I think perhaps a better way forward is to use functor functions like `tensor` or `cartesian_product`. There already is a wedge function (that does `wedge(x,y) == x.wedge(y)`), but I think something like that would be the natural thing to do.",
    "created_at": "2017-09-20T21:23:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331040",
    "user": "https://github.com/tscrim"
}
```

As you said, sometimes you do not necessarily know they are empty and you are doing a construction where you expect a specific number of factors or it is natural to consider them as a factor. Would you consider `{x} \sqcup {y}` to be the same set as `{x, y}`? I would say they are usually naturally isomorphic, unless `y = x`, and we as mathematicians would write them as equals for simplicity. However, when telling it to a computer, which doesn't allow as much ambiguity, it can be worthwhile to differentiate.

As a possible use-case, say you are constructing a wedge product from a bunch of spaces indexed by permutations, where some of them are a single point, where maybe you don't necessarily know which of them are a priori. Then you want to get some information about each of the factors (say, use the natural inclusion maps), but if you discard the single points, you have to keep track of the construction sets, which adds to the user's burden and doubles the memory usage.

I do not have a specific use-case in mind, and so I won't hold this ticket up for this. Yet, I wanted to at least have a quick discussion about it.

As for your use-case, I think perhaps a better way forward is to use functor functions like `tensor` or `cartesian_product`. There already is a wedge function (that does `wedge(x,y) == x.wedge(y)`), but I think something like that would be the natural thing to do.



---

archive/issue_comments_331041.json:
```json
{
    "body": "As an alternate use case, I would expect `X == X.disjoint_union(empty, empty, ...)` to be True. I think something like this also came up for me recently.\n\nThe wedge is a slightly different situation, and it might make more sense to have `pt wedge X` and `X` not be identical, since the former is a quotient of the disjoint union of `pt` and `X`. They are canonically isomorphic but perhaps not equal.",
    "created_at": "2017-09-20T21:48:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331041",
    "user": "https://github.com/jhpalmieri"
}
```

As an alternate use case, I would expect `X == X.disjoint_union(empty, empty, ...)` to be True. I think something like this also came up for me recently.

The wedge is a slightly different situation, and it might make more sense to have `pt wedge X` and `X` not be identical, since the former is a quotient of the disjoint union of `pt` and `X`. They are canonically isomorphic but perhaps not equal.



---

archive/issue_comments_331042.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-09-20T22:26:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331042",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_331043.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2017-09-20T22:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331043",
    "user": "https://github.com/jhpalmieri"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_331044.json:
```json
{
    "body": "Here is a branch which only changes `DisjointUnion`, not `Wedge`.",
    "created_at": "2017-09-20T22:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331044",
    "user": "https://github.com/jhpalmieri"
}
```

Here is a branch which only changes `DisjointUnion`, not `Wedge`.



---

archive/issue_comments_331045.json:
```json
{
    "body": "still good for me. Travis ?",
    "created_at": "2017-09-22T18:47:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331045",
    "user": "https://github.com/fchapoton"
}
```

still good for me. Travis ?



---

archive/issue_comments_331046.json:
```json
{
    "body": "As I mentioned, you can set a positive review with the disjoint union discarding empty sets. Also, the equality desired in comment:7 is reasonable, but it is still broken with this branch:\n\n```\nsage: from sage.homology.simplicial_set_examples import Empty\nsage: E = Empty()\nsage: S = simplicial_sets.Sphere(2)\nsage: S.disjoint_union(E)\nDisjoint union: (S^2)\nsage: _ == S\nFalse\n```\n\nSo I still have some reservations, but this might be a problem more with how `==` is implemented. So if you want to fix that on a follow-up, go ahead and set a positive review.\n\nAlso, as a follow-up, I think we should flatten the disjoint unions like how we do for tensor products of comb. free modules.",
    "created_at": "2017-09-24T07:43:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331046",
    "user": "https://github.com/tscrim"
}
```

As I mentioned, you can set a positive review with the disjoint union discarding empty sets. Also, the equality desired in comment:7 is reasonable, but it is still broken with this branch:

```
sage: from sage.homology.simplicial_set_examples import Empty
sage: E = Empty()
sage: S = simplicial_sets.Sphere(2)
sage: S.disjoint_union(E)
Disjoint union: (S^2)
sage: _ == S
False
```

So I still have some reservations, but this might be a problem more with how `==` is implemented. So if you want to fix that on a follow-up, go ahead and set a positive review.

Also, as a follow-up, I think we should flatten the disjoint unions like how we do for tensor products of comb. free modules.



---

archive/issue_comments_331047.json:
```json
{
    "body": "Regarding comment:7, that was a mistake: that equality was not meant to be a goal of this change. It would be nice, and I don't think it would be hard. With this branch, we do get the equality `X.disjoint_union() == X.disjoint_union(empty, empty, ...)`, at least.",
    "created_at": "2017-09-24T15:11:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331047",
    "user": "https://github.com/jhpalmieri"
}
```

Regarding comment:7, that was a mistake: that equality was not meant to be a goal of this change. It would be nice, and I don't think it would be hard. With this branch, we do get the equality `X.disjoint_union() == X.disjoint_union(empty, empty, ...)`, at least.



---

archive/issue_comments_331048.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-09-24T15:11:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331048",
    "user": "https://github.com/jhpalmieri"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_060849.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-09-26T06:58:02Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23660#event-60849"
}
```



---

archive/issue_comments_331049.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-09-26T06:58:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331049",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_331050.json:
```json
{
    "body": "Hey Travis, I am wondering about flattening. It seems like this would go against your earlier philosophy: if I define an algebra `A` as the tensor product of `B` and `C`, then if I take `A tensor D` (isomorphic to `B tensor C tensor D`), I might want to recover the zeroth factor as `A`, not `B`. I thought about flattening various constructions with simplicial sets and immediately ran into this with products: if I take the product of the torus T = S<sup>1</sup> x S<sup>1</sup> with something else, I want the first factor to be T, not S<sup>1</sup>.\n\nAre you thinking that this would be appropriate only for disjoint unions, or for other constructions (wedge, smash product, product) as well? I could imagine each one having a `flatten` keyword which would default to `False` most of the time.",
    "created_at": "2017-09-29T00:05:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331050",
    "user": "https://github.com/jhpalmieri"
}
```

Hey Travis, I am wondering about flattening. It seems like this would go against your earlier philosophy: if I define an algebra `A` as the tensor product of `B` and `C`, then if I take `A tensor D` (isomorphic to `B tensor C tensor D`), I might want to recover the zeroth factor as `A`, not `B`. I thought about flattening various constructions with simplicial sets and immediately ran into this with products: if I take the product of the torus T = S<sup>1</sup> x S<sup>1</sup> with something else, I want the first factor to be T, not S<sup>1</sup>.

Are you thinking that this would be appropriate only for disjoint unions, or for other constructions (wedge, smash product, product) as well? I could imagine each one having a `flatten` keyword which would default to `False` most of the time.



---

archive/issue_comments_331051.json:
```json
{
    "body": "That is a good point. For flattening, I was thinking about applying the natural associativity. We do this for tensor products of, e.g., `CombinatorialFreeModule`s in part so we do not have so many objects running around that are all essentially equivalent. Although I make a distinction as I feel you are not loosing information by dropping factors, but there is a price to be paid with (re)indexing. Granted, for my applications, having\n\n```\ntensor([A, B, C]) is tensor([tensor([A,B]), C]) is tensor([A, tensor([B,C])])\n```\n\nbeing `True` makes my (much) life easier.\n\nI was thinking of this as being a broad thing for (naturally) associative constructions. I guess since we are considering the simplicial sets as being pointed sets, we do have the associativity for wedge and smash products. I don't mind adding a `flatten` keyword, although elsewhere in Sage the current behavior generally is to flatten. If it is more useful for you to have the default be `False`, then I will not oppose.",
    "created_at": "2017-09-29T00:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23660#issuecomment-331051",
    "user": "https://github.com/tscrim"
}
```

That is a good point. For flattening, I was thinking about applying the natural associativity. We do this for tensor products of, e.g., `CombinatorialFreeModule`s in part so we do not have so many objects running around that are all essentially equivalent. Although I make a distinction as I feel you are not loosing information by dropping factors, but there is a price to be paid with (re)indexing. Granted, for my applications, having

```
tensor([A, B, C]) is tensor([tensor([A,B]), C]) is tensor([A, tensor([B,C])])
```

being `True` makes my (much) life easier.

I was thinking of this as being a broad thing for (naturally) associative constructions. I guess since we are considering the simplicial sets as being pointed sets, we do have the associativity for wedge and smash products. I don't mind adding a `flatten` keyword, although elsewhere in Sage the current behavior generally is to flatten. If it is more useful for you to have the default be `False`, then I will not oppose.
