# Issue 12630: test containment of ideals in class MPolynomialIdeal

archive/issues_012630.json:
```json
{
    "body": "Assignee: AlexGhitza\n\nCC:  malb nthiery\n\nThere seems to be no way to test containment of ideals in the class MPolynomialIdeal in `sage.rings.polynomial.multi_polynomial_ideal`.  One might expect the comparison operators (e.g. `I<J` ) to do this, but in fact what they do is to compare the Groebner bases as sequences of polynomials, which is counterintuitive.\nFor example:\n\n\n```\nsage: R.<x,y> = PolynomialRing(QQ)\nsage: I=(x*y)*R; J=(x,y)*R; I<J\nFalse\nsage: I=(y+1)*R; J=(x,y)*R; I<J\nTrue\n```\n\n\nThis is implemented in the `__cmp__` method, which is not up to the task of doing subset comparison, since `__cmp__` is only suitable for total orderings.\n\nTo do it right would seem to require implementing Python's \"rich comparison\" methods, `__lt__`, `__gt__`, etc.\n\nFor example:\n\n\n```\nfrom sage.rings.polynomial.multi_polynomial_ideal import MPolynomialIdeal\n\ndef IsSubset(I,J):\n  for g in I.gens()\n    if not g in J: return False\n  return True\n\ndef IsSuperset(I,J):\n  return IsSubset(J,I)\n\ndef IsProperSubset(I,J):\n  return I!=J and IsSubset(I,J)\n\ndef IsProperSuperset(I,J):\n  return I!J and IsSuperset(I,J)\n\nsetattr(MPolynomialIdeal,'__le__',IsSubset)\nsetattr(MPolynomialIdeal,'__lt__',IsProperSubset)\nsetattr(MPolynomialIdeal,'__ge__',IsSuperset)\nsetattr(MPolynomialIdeal,'__gt__',IsProperSuperset)\n```\n\n\nWith these we now get the expected behavior:\n\n\n```\nsage: R.<x,y> = PolynomialRing(QQ)\nsage: I=(x*y)*R; J=(x,y)*R; I<J\nTrue\nsage: I=(y+1)*R; J=(x,y)*R; I<J\nFalse\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/12802\n\n",
    "created_at": "2012-04-03T20:03:18Z",
    "labels": [
        "algebra",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.4",
    "title": "test containment of ideals in class MPolynomialIdeal",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12630",
    "user": "mariah"
}
```
Assignee: AlexGhitza

CC:  malb nthiery

There seems to be no way to test containment of ideals in the class MPolynomialIdeal in `sage.rings.polynomial.multi_polynomial_ideal`.  One might expect the comparison operators (e.g. `I<J` ) to do this, but in fact what they do is to compare the Groebner bases as sequences of polynomials, which is counterintuitive.
For example:


```
sage: R.<x,y> = PolynomialRing(QQ)
sage: I=(x*y)*R; J=(x,y)*R; I<J
False
sage: I=(y+1)*R; J=(x,y)*R; I<J
True
```


This is implemented in the `__cmp__` method, which is not up to the task of doing subset comparison, since `__cmp__` is only suitable for total orderings.

To do it right would seem to require implementing Python's "rich comparison" methods, `__lt__`, `__gt__`, etc.

For example:


```
from sage.rings.polynomial.multi_polynomial_ideal import MPolynomialIdeal

def IsSubset(I,J):
  for g in I.gens()
    if not g in J: return False
  return True

def IsSuperset(I,J):
  return IsSubset(J,I)

def IsProperSubset(I,J):
  return I!=J and IsSubset(I,J)

def IsProperSuperset(I,J):
  return I!J and IsSuperset(I,J)

setattr(MPolynomialIdeal,'__le__',IsSubset)
setattr(MPolynomialIdeal,'__lt__',IsProperSubset)
setattr(MPolynomialIdeal,'__ge__',IsSuperset)
setattr(MPolynomialIdeal,'__gt__',IsProperSuperset)
```


With these we now get the expected behavior:


```
sage: R.<x,y> = PolynomialRing(QQ)
sage: I=(x*y)*R; J=(x,y)*R; I<J
True
sage: I=(y+1)*R; J=(x,y)*R; I<J
False
```


Issue created by migration from https://trac.sagemath.org/ticket/12802





---

archive/issue_comments_150278.json:
```json
{
    "body": "Changing keywords from \"\" to \"sd40.5, groebner bases, ideals\".",
    "created_at": "2012-05-25T23:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150278",
    "user": "john_perry"
}
```

Changing keywords from "" to "sd40.5, groebner bases, ideals".



---

archive/issue_comments_150279.json:
```json
{
    "body": "Attachment [trac_12802_and_12803.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_and_12803.patch) by john_perry created at 2012-05-25 23:22:34\n\nThe attached file gives a better check for correctness than even the proposed solution, using Groebner bases rather than generators alone. The examples given by mariah produce a correct result on my machine, though for a doctest I use a slightly different solution which her proposed fix wouldn't detect.\n\nThis patch also resolve #12839, as far as I can tell.",
    "created_at": "2012-05-25T23:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150279",
    "user": "john_perry"
}
```

Attachment [trac_12802_and_12803.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_and_12803.patch) by john_perry created at 2012-05-25 23:22:34

The attached file gives a better check for correctness than even the proposed solution, using Groebner bases rather than generators alone. The examples given by mariah produce a correct result on my machine, though for a doctest I use a slightly different solution which her proposed fix wouldn't detect.

This patch also resolve #12839, as far as I can tell.



---

archive/issue_comments_150280.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-05-25T23:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150280",
    "user": "john_perry"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_150281.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-05-27T04:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150281",
    "user": "novoselt"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150282.json:
```json
{
    "body": "Functions are missing standard documentation blocks.",
    "created_at": "2012-05-27T04:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150282",
    "user": "novoselt"
}
```

Functions are missing standard documentation blocks.



---

archive/issue_comments_150283.json:
```json
{
    "body": "Replying to [comment:2 novoselt]:\n> Functions are missing standard documentation blocks.\n\nIt's even worse than that. For some reason, I'm now finding regressions that I didn't find earlier. I'm working on an updated patch.",
    "created_at": "2012-05-27T17:37:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150283",
    "user": "john_perry"
}
```

Replying to [comment:2 novoselt]:
> Functions are missing standard documentation blocks.

It's even worse than that. For some reason, I'm now finding regressions that I didn't find earlier. I'm working on an updated patch.



---

archive/issue_comments_150284.json:
```json
{
    "body": "Okay, so the problems were real, but were discovered because there's a very weird test of elements of quadratic number fields: basically, if a and b are distinct elements of a quadratic number field, then a>b and b>a are always true:\n\n```\nsage: K.<a> = NumberField(x^2 + 1)\nsage: a > a + 1\nTrue\n```\n\nThat strikes me as really, really **odd** behavior.\n\nAnyway, I'm about to upload a new patch that undoes the stupidity I did to `sage.rings.ideal.py`, adds some documentation to the `__cmp__` function in `Ideal_generic`, then takes care of the things that need taking care of down in `sage.rings.polynomial.multi_polynomial_idea.py`. I've also added documentation. (Sorry about that -- it didn't occur to me because the stuff I was rewriting wasn't documented, either.) It also removes a boatload of whitespace.",
    "created_at": "2012-05-27T18:44:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150284",
    "user": "john_perry"
}
```

Okay, so the problems were real, but were discovered because there's a very weird test of elements of quadratic number fields: basically, if a and b are distinct elements of a quadratic number field, then a>b and b>a are always true:

```
sage: K.<a> = NumberField(x^2 + 1)
sage: a > a + 1
True
```

That strikes me as really, really **odd** behavior.

Anyway, I'm about to upload a new patch that undoes the stupidity I did to `sage.rings.ideal.py`, adds some documentation to the `__cmp__` function in `Ideal_generic`, then takes care of the things that need taking care of down in `sage.rings.polynomial.multi_polynomial_idea.py`. I've also added documentation. (Sorry about that -- it didn't occur to me because the stuff I was rewriting wasn't documented, either.) It also removes a boatload of whitespace.



---

archive/issue_comments_150285.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-05-27T18:45:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150285",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150286.json:
```json
{
    "body": "To help the reviewer(s), here are the non-whitespace changes.\n\n1. In `sage/rings/ideal.py`, I added a docstring & doctest to `Ideal_generic`'s `__cmp__`.\n2. In `sage/rings/polynomial/multipolynomial_ideal.py`, I\n   a. redefined `__cmp__` to rely on `__lt__`, `__gt__`, and `__eq__`;\n   b. changed `__eq__` to test whether each ideal is a subset of the other;\n   c. changed `__gt__` to test whether `other` is a subset of `self`; and\n   d. moved the old code for `__eq__` to `__lt__`, where it now checks whether each polynomial in the Groebner basis of `self` reduces to 0 modulo the Groebner basis of `other`. Here, I also had to move a `try...except` loop around, because of a strange `AttributeError` related to caching, raised **only** by the doctests of `pbori.pyx`.\n\nOn my machine all the doctests of `sage/rings` pass with this patch. I haven't doctested everything, though.",
    "created_at": "2012-05-27T18:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150286",
    "user": "john_perry"
}
```

To help the reviewer(s), here are the non-whitespace changes.

1. In `sage/rings/ideal.py`, I added a docstring & doctest to `Ideal_generic`'s `__cmp__`.
2. In `sage/rings/polynomial/multipolynomial_ideal.py`, I
   a. redefined `__cmp__` to rely on `__lt__`, `__gt__`, and `__eq__`;
   b. changed `__eq__` to test whether each ideal is a subset of the other;
   c. changed `__gt__` to test whether `other` is a subset of `self`; and
   d. moved the old code for `__eq__` to `__lt__`, where it now checks whether each polynomial in the Groebner basis of `self` reduces to 0 modulo the Groebner basis of `other`. Here, I also had to move a `try...except` loop around, because of a strange `AttributeError` related to caching, raised **only** by the doctests of `pbori.pyx`.

On my machine all the doctests of `sage/rings` pass with this patch. I haven't doctested everything, though.



---

archive/issue_comments_150287.json:
```json
{
    "body": "Would be better to have whitespaces separately... Anyway: \"Decides whether two ideals are equal. The test is performed on the generators.\" does not sound right, this method does not decide whether ideals are equal. How about \"Compare generators of two ideals.\" instead?",
    "created_at": "2012-05-27T19:24:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150287",
    "user": "novoselt"
}
```

Would be better to have whitespaces separately... Anyway: "Decides whether two ideals are equal. The test is performed on the generators." does not sound right, this method does not decide whether ideals are equal. How about "Compare generators of two ideals." instead?



---

archive/issue_comments_150288.json:
```json
{
    "body": "Replying to [comment:7 novoselt]:\n> Would be better to have whitespaces separately...\n\nI can do that, if you think it best. I'd rather not, now that I've removed them, but I can.\n\n> Anyway: \"Decides whether two ideals are equal. The test is performed on the generators.\" does not sound right, this method does not decide whether ideals are equal. How about \"Compare generators of two ideals.\" instead?\n\nDone.",
    "created_at": "2012-05-27T19:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150288",
    "user": "john_perry"
}
```

Replying to [comment:7 novoselt]:
> Would be better to have whitespaces separately...

I can do that, if you think it best. I'd rather not, now that I've removed them, but I can.

> Anyway: "Decides whether two ideals are equal. The test is performed on the generators." does not sound right, this method does not decide whether ideals are equal. How about "Compare generators of two ideals." instead?

Done.



---

archive/issue_comments_150289.json:
```json
{
    "body": "Apply trac_12802_and_12839.patch",
    "created_at": "2012-05-27T19:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150289",
    "user": "novoselt"
}
```

Apply trac_12802_and_12839.patch



---

archive/issue_comments_150290.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-05-27T20:07:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150290",
    "user": "novoselt"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150291.json:
```json
{
    "body": "I don't insist on separating whitespace patch now, it is just inconvenient to dig for changes in 100kb. But please make subsequent changes in a new little patch.\n\n1. `__cmp__` does not return the result of ``self == other`` contrary to what is written. I also think that the test should call cmp directly, since `==` does not always lead to `cmp`.\n2. In `__lt__` the documentation says \"We use ideal membership to test whether the generators of each ideal appears in the other.\" while only one of the containment directions should be checked. Despite of the description of the algorithm in the documentation, the actual code does something else in the beginning and can return numbers or result of `cmp` instead of `True/False`.\n3. What will `__cmp__` of ideals return if neither of them is contained in another? Do we even need it for ideals if there are lt/gt?\n4. Documentation of `__eq__` is wrong.",
    "created_at": "2012-05-27T20:07:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150291",
    "user": "novoselt"
}
```

I don't insist on separating whitespace patch now, it is just inconvenient to dig for changes in 100kb. But please make subsequent changes in a new little patch.

1. `__cmp__` does not return the result of ``self == other`` contrary to what is written. I also think that the test should call cmp directly, since `==` does not always lead to `cmp`.
2. In `__lt__` the documentation says "We use ideal membership to test whether the generators of each ideal appears in the other." while only one of the containment directions should be checked. Despite of the description of the algorithm in the documentation, the actual code does something else in the beginning and can return numbers or result of `cmp` instead of `True/False`.
3. What will `__cmp__` of ideals return if neither of them is contained in another? Do we even need it for ideals if there are lt/gt?
4. Documentation of `__eq__` is wrong.



---

archive/issue_comments_150292.json:
```json
{
    "body": "Replying to [comment:10 novoselt]:\n> I don't insist on separating whitespace patch now, it is just inconvenient to dig for changes in 100kb. But please make subsequent changes in a new little patch.\n\nOkay, new patch coming. It'll be a bit.\n\n>  1. `__cmp__` does not return the result of ``self == other`` contrary to what is written. I also think that the test should call cmp directly, since `==` does not always lead to `cmp`.\n\nGot it.\n\n>  2. In `__lt__` the documentation says \"We use ideal membership to test whether the generators of each ideal appears in the other.\" while only one of the containment directions should be checked. Despite of the description of the algorithm in the documentation, the actual code does something else in the beginning and can return numbers or result of `cmp` instead of `True/False`.\n\nThis was originally code for `__cmp__`, and when I first started working on it, I had completely forgotten that `__cmp__` doesn't work the same as these other special functions. That was one reason for the regression I encountered earlier.\n\n>  3. What will `__cmp__` of ideals return if neither of them is contained in another? Do we even need it for ideals if there are lt/gt?\n\nWhen I first worked on this, the `__cmp__` of `Ideal_generic` was trumping everything else. That's why I redefined `__cmp__`, and it's also why I originally did some of this in `Ideal_generic`.\n\n>  4. Documentation of `__eq__` is wrong.\n\nIt took me a while to find what you meant, but I finally saw it.",
    "created_at": "2012-05-27T21:13:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150292",
    "user": "john_perry"
}
```

Replying to [comment:10 novoselt]:
> I don't insist on separating whitespace patch now, it is just inconvenient to dig for changes in 100kb. But please make subsequent changes in a new little patch.

Okay, new patch coming. It'll be a bit.

>  1. `__cmp__` does not return the result of ``self == other`` contrary to what is written. I also think that the test should call cmp directly, since `==` does not always lead to `cmp`.

Got it.

>  2. In `__lt__` the documentation says "We use ideal membership to test whether the generators of each ideal appears in the other." while only one of the containment directions should be checked. Despite of the description of the algorithm in the documentation, the actual code does something else in the beginning and can return numbers or result of `cmp` instead of `True/False`.

This was originally code for `__cmp__`, and when I first started working on it, I had completely forgotten that `__cmp__` doesn't work the same as these other special functions. That was one reason for the regression I encountered earlier.

>  3. What will `__cmp__` of ideals return if neither of them is contained in another? Do we even need it for ideals if there are lt/gt?

When I first worked on this, the `__cmp__` of `Ideal_generic` was trumping everything else. That's why I redefined `__cmp__`, and it's also why I originally did some of this in `Ideal_generic`.

>  4. Documentation of `__eq__` is wrong.

It took me a while to find what you meant, but I finally saw it.



---

archive/issue_comments_150293.json:
```json
{
    "body": "The last line in this `if` statement that you pointed out:\n\n```\n        if R is not S: # rings are unique\n            if type(R) == type(S) and (R.base_ring() == S.base_ring()) and (R.ngens() == S.ngens()):\n                other = other.change_ring(R)\n            else:\n                return cmp((type(R), R.base_ring(), R.ngens()), (type(S), S.base_ring(), S.ngens()))\n```\n\nstrikes me as wrong. If the base ring or the number of generators are different, they can't be the same ideal. I'm changing that to return `False`.\n\nThe type is another story. If someone has defined a ring with singular, and wants to compare to a ring defined with cocoa or macaulay, that ought to be possible. Unfortunately, I can't test it: neither Macaulay nor CoCoA build on my Sage 5.0. Are you able to build either?",
    "created_at": "2012-05-27T21:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150293",
    "user": "john_perry"
}
```

The last line in this `if` statement that you pointed out:

```
        if R is not S: # rings are unique
            if type(R) == type(S) and (R.base_ring() == S.base_ring()) and (R.ngens() == S.ngens()):
                other = other.change_ring(R)
            else:
                return cmp((type(R), R.base_ring(), R.ngens()), (type(S), S.base_ring(), S.ngens()))
```

strikes me as wrong. If the base ring or the number of generators are different, they can't be the same ideal. I'm changing that to return `False`.

The type is another story. If someone has defined a ring with singular, and wants to compare to a ring defined with cocoa or macaulay, that ought to be possible. Unfortunately, I can't test it: neither Macaulay nor CoCoA build on my Sage 5.0. Are you able to build either?



---

archive/issue_comments_150294.json:
```json
{
    "body": "I think comparison of rings should be done by converting all to a single system where they will be unique. And in general what's the point in ring uniqueness if they may not be unique? If you are not satisfied with `R is S` check, use `R == S` and let the meaning of this be handled by ring code, not the ideal comparison.\n\nNote also that there are many failing doctests, the worst ones are with infinite recursion. If it will be necessary to change output in doctests of toric varieties, please do it on top of #13023 which is already positively reviewed.",
    "created_at": "2012-05-27T22:10:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150294",
    "user": "novoselt"
}
```

I think comparison of rings should be done by converting all to a single system where they will be unique. And in general what's the point in ring uniqueness if they may not be unique? If you are not satisfied with `R is S` check, use `R == S` and let the meaning of this be handled by ring code, not the ideal comparison.

Note also that there are many failing doctests, the worst ones are with infinite recursion. If it will be necessary to change output in doctests of toric varieties, please do it on top of #13023 which is already positively reviewed.



---

archive/issue_comments_150295.json:
```json
{
    "body": "Replying to [comment:13 novoselt]:\n> I think comparison of rings should be done by converting all to a single system where they will be unique.\n\nThis has to be checked, due to different term orders. I've encountered regressions because of this; they may be the cause of some of your failing doctests.\n\n> Note also that there are many failing doctests, the worst ones are with infinite recursion.\n\nI think I've fixed this one, too; I think the cause was related to returning numbers. I'm about to upload a new patch.\n\nI wasn't getting any failures in `sage/rings`, btw, so I guess your failures are elsewhere?",
    "created_at": "2012-05-27T22:22:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150295",
    "user": "john_perry"
}
```

Replying to [comment:13 novoselt]:
> I think comparison of rings should be done by converting all to a single system where they will be unique.

This has to be checked, due to different term orders. I've encountered regressions because of this; they may be the cause of some of your failing doctests.

> Note also that there are many failing doctests, the worst ones are with infinite recursion.

I think I've fixed this one, too; I think the cause was related to returning numbers. I'm about to upload a new patch.

I wasn't getting any failures in `sage/rings`, btw, so I guess your failures are elsewhere?



---

archive/issue_comments_150296.json:
```json
{
    "body": "I looked at the patchbot log (accessible through the disk in top right corner of the description).",
    "created_at": "2012-05-27T22:27:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150296",
    "user": "novoselt"
}
```

I looked at the patchbot log (accessible through the disk in top right corner of the description).



---

archive/issue_comments_150297.json:
```json
{
    "body": "I had plumb forgot about that.",
    "created_at": "2012-05-27T22:35:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150297",
    "user": "john_perry"
}
```

I had plumb forgot about that.



---

archive/issue_comments_150298.json:
```json
{
    "body": "At least some of those tests have nothing to do with this patch; I get them even when I pop & rebuild.\n\n*Edit:* I forgot that there are two patches involved. They may be due to this after all; I'm looking at them now.\n\nThe toric_ideals.py regressions are already fixed.",
    "created_at": "2012-05-27T22:38:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150298",
    "user": "john_perry"
}
```

At least some of those tests have nothing to do with this patch; I get them even when I pop & rebuild.

*Edit:* I forgot that there are two patches involved. They may be due to this after all; I'm looking at them now.

The toric_ideals.py regressions are already fixed.



---

archive/issue_comments_150299.json:
```json
{
    "body": "Okay, it looks like I have a new patch ready. The problem was that lots of things depended on the old mpolynomial_ideal `__cmp__` as it was, and I had inadvertently broken that by tying it to subsets (for less than & greater than) rather than equality and non-equality. Those six tests now pass for me.\n\nUpdated patch on its way... I also fixed something in the documentation of `ideal`'s `__cmp__`.",
    "created_at": "2012-05-27T23:07:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150299",
    "user": "john_perry"
}
```

Okay, it looks like I have a new patch ready. The problem was that lots of things depended on the old mpolynomial_ideal `__cmp__` as it was, and I had inadvertently broken that by tying it to subsets (for less than & greater than) rather than equality and non-equality. Those six tests now pass for me.

Updated patch on its way... I also fixed something in the documentation of `ideal`'s `__cmp__`.



---

archive/issue_comments_150300.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-05-27T23:11:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150300",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150301.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-05-27T23:32:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150301",
    "user": "novoselt"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150302.json:
```json
{
    "body": "\n```\nRx = PolynomialRing(QQ, 2, \"x\")\nIx = Rx.ideal(Rx.0)\nRy = PolynomialRing(QQ, 2, \"y\")\nIy = Ry.ideal(Ry.0)\nprint Ix, Iy\nIx == Iy\n```\n\nFalse before and True after. Better not detect equality in some convoluted cases than claim equality for different ideals.",
    "created_at": "2012-05-27T23:32:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150302",
    "user": "novoselt"
}
```


```
Rx = PolynomialRing(QQ, 2, "x")
Ix = Rx.ideal(Rx.0)
Ry = PolynomialRing(QQ, 2, "y")
Iy = Ry.ideal(Ry.0)
print Ix, Iy
Ix == Iy
```

False before and True after. Better not detect equality in some convoluted cases than claim equality for different ideals.



---

archive/issue_comments_150303.json:
```json
{
    "body": "Replying to [comment:20 novoselt]:\n> False before and True after. Better not detect equality in some convoluted cases than claim equality for different ideals.\n\nI agree. This is pretty easily fixed, though; the concern stated is that the orders might differ. I'll put in a narrower test. New patch on its way...",
    "created_at": "2012-05-28T00:44:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150303",
    "user": "john_perry"
}
```

Replying to [comment:20 novoselt]:
> False before and True after. Better not detect equality in some convoluted cases than claim equality for different ideals.

I agree. This is pretty easily fixed, though; the concern stated is that the orders might differ. I'll put in a narrower test. New patch on its way...



---

archive/issue_comments_150304.json:
```json
{
    "body": "I added your example as a test, and another for the orderings.\n\nBy the way, I'm sorry the patch is showing so many changes; I don't think there are that many, but somehow it thinks a lot of stuff was removed, then put back in. That actually did happen, but I thought I put things in the same order.",
    "created_at": "2012-05-28T00:46:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150304",
    "user": "john_perry"
}
```

I added your example as a test, and another for the orderings.

By the way, I'm sorry the patch is showing so many changes; I don't think there are that many, but somehow it thinks a lot of stuff was removed, then put back in. That actually did happen, but I thought I put things in the same order.



---

archive/issue_comments_150305.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-05-28T00:46:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150305",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150306.json:
```json
{
    "body": "\"at this point, the ideals are the same, except perhaps the term order\" - you meant that rings are the same, not ideals\n\nThere are still two doctest errors according to patchbot.",
    "created_at": "2012-05-28T01:56:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150306",
    "user": "novoselt"
}
```

"at this point, the ideals are the same, except perhaps the term order" - you meant that rings are the same, not ideals

There are still two doctest errors according to patchbot.



---

archive/issue_comments_150307.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-05-28T01:56:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150307",
    "user": "novoselt"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150308.json:
```json
{
    "body": "Oh, and \"OUTPUT:\" is usually on a separate line separated by a black line from the actual description:\n\nhttp://sagemath.org/doc/developer/conventions.html#documentation-strings",
    "created_at": "2012-05-28T01:58:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150308",
    "user": "novoselt"
}
```

Oh, and "OUTPUT:" is usually on a separate line separated by a black line from the actual description:

http://sagemath.org/doc/developer/conventions.html#documentation-strings



---

archive/issue_comments_150309.json:
```json
{
    "body": "Replying to [comment:23 novoselt]:\n> There are still two doctest errors according to patchbot. \n\nI caught it too, after I uploaded the patch. New one in a moment.\n\nReplying to [comment:24 novoselt]:\n> Oh, and \"OUTPUT:\" is usually on a separate line separated by a black line from the actual description:\n> \n> http://sagemath.org/doc/developer/conventions.html#documentation-strings\n\nI was following the practice I saw elsewhere in these files (quite a few places), but I'll change it.",
    "created_at": "2012-05-28T03:18:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150309",
    "user": "john_perry"
}
```

Replying to [comment:23 novoselt]:
> There are still two doctest errors according to patchbot. 

I caught it too, after I uploaded the patch. New one in a moment.

Replying to [comment:24 novoselt]:
> Oh, and "OUTPUT:" is usually on a separate line separated by a black line from the actual description:
> 
> http://sagemath.org/doc/developer/conventions.html#documentation-strings

I was following the practice I saw elsewhere in these files (quite a few places), but I'll change it.



---

archive/issue_comments_150310.json:
```json
{
    "body": "New patch ready. I've run doctests in sage/rings, as well the ones that had failed earlier, & those all pass. Hopefully the patchbot won't uncover any others.",
    "created_at": "2012-05-28T03:31:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150310",
    "user": "john_perry"
}
```

New patch ready. I've run doctests in sage/rings, as well the ones that had failed earlier, & those all pass. Hopefully the patchbot won't uncover any others.



---

archive/issue_comments_150311.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-05-28T03:31:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150311",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150312.json:
```json
{
    "body": "All tests pass on my machine.",
    "created_at": "2012-05-28T06:07:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150312",
    "user": "john_perry"
}
```

All tests pass on my machine.



---

archive/issue_comments_150313.json:
```json
{
    "body": "Compare #12976: If you work on comparison of ideals, you should perhaps also consider the fact that ideals evaluating as equal may have different hash, because the hash relies on the string representation (hence, on the generators), but the comparison relies on Gr\u00f6bner bases. So, the hash is broken (and is rather slow, too).\n\nAlso, there is one thing you didn't fix: If the Gr\u00f6bner basis of *only one* of the two to-be-compared ideals is not in the cache, then a *copy* of the two ideals is created using degrevlex term order, and then the Gr\u00f6bner basis is computed in the supposedly easier order. However, the ring change happens even if the ideals already are in degrevlex order, and moreover the result of the Gr\u00f6bner basis computation is not cached. For that problem, I had already opened #12987.\n\nBy the way, good that you do *not* try to change comparison of polynomial ideals into a generator-wise comparison - the ticket description let the impression arise that you want to drop Gr\u00f6bner bases.\n\nHow should one proceed? Fix the \"useless double-computation of Gr\u00f6bner bases of copies of ideals\" here? Then this ticket is \"needs work\", and #12987 is a duplicate. Or fix it at #12987? Then I have to add this ticket as a new dependency for #12987.\n\nPossible idea: One could create an attribute `_gb_by_term_order_` that is a dictionary storing the Gr\u00f6bner bases of an ideal with respect to different orders. Hence, when doing a comparison and computing the Gr\u00f6bner basis of a *copy* of ideal J in \"degrevlex\" order (while J lives in a ring with different order), then `J._gb_by_term_order_[\"degrevlex\"]` should store the result.\n\nA related topic: Avoid using comparison and hash when passing argument attributes in singular_function. See #12977 (needs review).\n\nAnother thing: This ticket's component should be \"commutative algebra\", not \"algebra\". And I guess Martin should be Cc.",
    "created_at": "2012-05-28T07:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150313",
    "user": "SimonKing"
}
```

Compare #12976: If you work on comparison of ideals, you should perhaps also consider the fact that ideals evaluating as equal may have different hash, because the hash relies on the string representation (hence, on the generators), but the comparison relies on Gröbner bases. So, the hash is broken (and is rather slow, too).

Also, there is one thing you didn't fix: If the Gröbner basis of *only one* of the two to-be-compared ideals is not in the cache, then a *copy* of the two ideals is created using degrevlex term order, and then the Gröbner basis is computed in the supposedly easier order. However, the ring change happens even if the ideals already are in degrevlex order, and moreover the result of the Gröbner basis computation is not cached. For that problem, I had already opened #12987.

By the way, good that you do *not* try to change comparison of polynomial ideals into a generator-wise comparison - the ticket description let the impression arise that you want to drop Gröbner bases.

How should one proceed? Fix the "useless double-computation of Gröbner bases of copies of ideals" here? Then this ticket is "needs work", and #12987 is a duplicate. Or fix it at #12987? Then I have to add this ticket as a new dependency for #12987.

Possible idea: One could create an attribute `_gb_by_term_order_` that is a dictionary storing the Gröbner bases of an ideal with respect to different orders. Hence, when doing a comparison and computing the Gröbner basis of a *copy* of ideal J in "degrevlex" order (while J lives in a ring with different order), then `J._gb_by_term_order_["degrevlex"]` should store the result.

A related topic: Avoid using comparison and hash when passing argument attributes in singular_function. See #12977 (needs review).

Another thing: This ticket's component should be "commutative algebra", not "algebra". And I guess Martin should be Cc.



---

archive/issue_comments_150314.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-05-28T22:11:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150314",
    "user": "novoselt"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150315.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2012-05-29T02:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150315",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_150316.json:
```json
{
    "body": "Replying to [comment:28 SimonKing]:\n> Compare #12976: If you work on comparison of ideals, you should perhaps also consider the fact that ideals evaluating as equal may have different hash, because the hash relies on the string representation (hence, on the generators), but the comparison relies on Gr\u00f6bner bases. So, the hash is broken (and is rather slow, too).\n\nI don't understand the issue with the hash, probably because I don't know anything about how Sage hashes rings, ideals, etc. I can look into this, but: the code ignores the hash altogether, and a Groebner basis is only computed for a copy; the original ideal is untouched. So, how could this patch break the hash?\n\n> Also, there is one thing you didn't fix: If the Gr\u00f6bner basis of *only one* of the two to-be-compared ideals is not in the cache, then a *copy* of the two ideals is created using degrevlex term order, and then the Gr\u00f6bner basis is computed in the supposedly easier order.\n\nWhen I run the example you provide in #12987, I get this:\n\n```\nsage: %timeit J==J2\n5 loops, best of 3: 534 ms per loop\nsage: _ = J.groebner_basis()\nsage: %timeit J==J2\n5 loops, best of 3: 533 ms per loop\nsage: _ = J2.groebner_basis()\nsage: %timeit J==J2\n5 loops, best of 3: 533 ms per loop\n```\n\nSo it's even worse than you say; it's not that I didn't fix it; I've actually broken something there. (I don't think this is the hash; correct me if I'm wrong.) That third timeit is definitely a lot slower with this patch installed.\n\nIMHO, rings and ideals ought to be independent of term orderings, which the user ought to be able to switch without creating a new ring & ideal. A Groebner basis of an ideal could be stored in a dictionary for each different term ordering requested. As far as I can tell, this isn't possible now, and I don't know if it's feasible at all, given the reliance on Singular.\n\nBut, your proposal:\n\n> One could create an attribute `_gb_by_term_order_` that is a dictionary storing the Gr\u00f6bner bases of an ideal with respect to different orders.\n\n...seems similar. Do you think a long-term fix of making rings independent of term orderings would be worth looking at?\n\n> Hence, when doing a comparison and computing the Gr\u00f6bner basis of a *copy* of ideal J in \"degrevlex\" order (while J lives in a ring with different order), then `J._gb_by_term_order_[\"degrevlex\"]` should store the result.\n\nThis can, of course, be done now. I will try to work on it over the next few days.\n\n> By the way, good that you do *not* try to change comparison of polynomial ideals into a generator-wise comparison - the ticket description let the impression arise that you want to drop Gr\u00f6bner bases.\n\nFWIW, I didn't write that part. I wrote the part where I said we *would* use Groebner bases. ;-)\n\n> How should one proceed? Fix the \"useless double-computation of Gr\u00f6bner bases of copies of ideals\" here? Then this ticket is \"needs work\", and #12987 is a duplicate. Or fix it at #12987? Then I have to add this ticket as a new dependency for #12987.\n\nI think it better to mark #12987 as a duplicate in that case, the same way #12839 is a duplicate, and fix this issue here, at least with your proposed approach. I can certainly do that.\n\n> Another thing: This ticket's component should be \"commutative algebra\"...\n\nI agree.",
    "created_at": "2012-05-29T02:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150316",
    "user": "john_perry"
}
```

Replying to [comment:28 SimonKing]:
> Compare #12976: If you work on comparison of ideals, you should perhaps also consider the fact that ideals evaluating as equal may have different hash, because the hash relies on the string representation (hence, on the generators), but the comparison relies on Gröbner bases. So, the hash is broken (and is rather slow, too).

I don't understand the issue with the hash, probably because I don't know anything about how Sage hashes rings, ideals, etc. I can look into this, but: the code ignores the hash altogether, and a Groebner basis is only computed for a copy; the original ideal is untouched. So, how could this patch break the hash?

> Also, there is one thing you didn't fix: If the Gröbner basis of *only one* of the two to-be-compared ideals is not in the cache, then a *copy* of the two ideals is created using degrevlex term order, and then the Gröbner basis is computed in the supposedly easier order.

When I run the example you provide in #12987, I get this:

```
sage: %timeit J==J2
5 loops, best of 3: 534 ms per loop
sage: _ = J.groebner_basis()
sage: %timeit J==J2
5 loops, best of 3: 533 ms per loop
sage: _ = J2.groebner_basis()
sage: %timeit J==J2
5 loops, best of 3: 533 ms per loop
```

So it's even worse than you say; it's not that I didn't fix it; I've actually broken something there. (I don't think this is the hash; correct me if I'm wrong.) That third timeit is definitely a lot slower with this patch installed.

IMHO, rings and ideals ought to be independent of term orderings, which the user ought to be able to switch without creating a new ring & ideal. A Groebner basis of an ideal could be stored in a dictionary for each different term ordering requested. As far as I can tell, this isn't possible now, and I don't know if it's feasible at all, given the reliance on Singular.

But, your proposal:

> One could create an attribute `_gb_by_term_order_` that is a dictionary storing the Gröbner bases of an ideal with respect to different orders.

...seems similar. Do you think a long-term fix of making rings independent of term orderings would be worth looking at?

> Hence, when doing a comparison and computing the Gröbner basis of a *copy* of ideal J in "degrevlex" order (while J lives in a ring with different order), then `J._gb_by_term_order_["degrevlex"]` should store the result.

This can, of course, be done now. I will try to work on it over the next few days.

> By the way, good that you do *not* try to change comparison of polynomial ideals into a generator-wise comparison - the ticket description let the impression arise that you want to drop Gröbner bases.

FWIW, I didn't write that part. I wrote the part where I said we *would* use Groebner bases. ;-)

> How should one proceed? Fix the "useless double-computation of Gröbner bases of copies of ideals" here? Then this ticket is "needs work", and #12987 is a duplicate. Or fix it at #12987? Then I have to add this ticket as a new dependency for #12987.

I think it better to mark #12987 as a duplicate in that case, the same way #12839 is a duplicate, and fix this issue here, at least with your proposed approach. I can certainly do that.

> Another thing: This ticket's component should be "commutative algebra"...

I agree.



---

archive/issue_comments_150317.json:
```json
{
    "body": "Changing component from algebra to commutative algebra.",
    "created_at": "2012-05-29T02:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150317",
    "user": "john_perry"
}
```

Changing component from algebra to commutative algebra.



---

archive/issue_comments_150318.json:
```json
{
    "body": "Replying to [comment:30 john_perry]:\n> Replying to [comment:28 SimonKing]:\n> > Compare #12976: If you work on comparison of ideals, you should perhaps also consider the fact that ideals evaluating as equal may have different hash, because the hash relies on the string representation (hence, on the generators), but the comparison relies on Gr\u00f6bner bases. So, the hash is broken (and is rather slow, too).\n> \n> I don't understand the issue with the hash, probably because I don't know anything about how Sage hashes rings, ideals, etc.\n\nThat's how Python uses the hash: Python's dictionaries and sets are hash tables. Hence, whenever you use an ideal J (or any other object) as a key in a dictionary D or put it into a set S, then the hash is computed, and the object is put into a \"bucket\" that corresponds to the hash value.\n\nIf you then have an object G (say, the ideal that is given by the reduced Gr\u00f6bner basis of J) and want to test whether G is in D or S (say, `D[G]` or `G in S`), then the hash of G is computed, and then **only the bucket corresponding to the hash of G** is searched for an equal object. The buckets typically are very small. Hence, if you have a quick hash function then searching in a set is much faster than searching in a list.\n\nNow, a problem arises if `G==J` but `hash(G)!=hash(J)`: G and J may end up in *different* buckets, and thus `G in S` would return False, even though `J in S and J==G`.\n\nSummary: It is required by Python that the hash values of equal objects are equal. Otherwise, the hash is called \"broken\".\n\n> I can look into this, but: the code ignores the hash altogether, and a Groebner basis is only computed for a copy; the original ideal is untouched. So, how could this patch break the hash?\n\nI did not claim that the patch breaks the hash. I merely stated that the hash **is** broken (see #12976), and I asked whether we should extend the patch here so that the hash is fixed, or whether we leave the hash broken for now.\n\n> When I run the example you provide in #12987, I get this:\n> {{{\n> sage: %timeit J==J2\n> 5 loops, best of 3: 534 ms per loop\n> sage: _ = J.groebner_basis()\n> sage: %timeit J==J2\n> 5 loops, best of 3: 533 ms per loop\n> sage: _ = J2.groebner_basis()\n> sage: %timeit J==J2\n> 5 loops, best of 3: 533 ms per loop\n> }}}\n> So it's even worse than you say; it's not that I didn't fix it; I've actually broken something there. (I don't think this is the hash; correct me if I'm wrong.)\n\nNo, there is no hash involved here.\n\n> IMHO, rings and ideals ought to be independent of term orderings, which the user ought to be able to switch without creating a new ring & ideal.\n\nThat sounds nice at first glance. However, it would be awkward to ask for providing a term order as a new argument to the groebner_basis() method. And there are many algorithms that rely on Gr\u00f6bner bases. So, I believe having a default term order for each ring (and thus have different rings for different term orders) is fine, IMHO.\n\nAnyway, ideals that are independent of a default term order could probably be implemented using the \"parents with multiple realisations\" that have recently been introduced (hence, Cc to Nicolas...). I wonder, though, if that would be possible without a speed regression.\n\n> But, your proposal:\n> \n> > One could create an attribute `_gb_by_term_order_` that is a dictionary storing the Gr\u00f6bner bases of an ideal with respect to different orders.\n> \n> ...seems similar. Do you think a long-term fix of making rings independent of term orderings would be worth looking at?\n\nI am not sure, see above.\n \n> > How should one proceed? Fix the \"useless double-computation of Gr\u00f6bner bases of copies of ideals\" here? Then this ticket is \"needs work\", and #12987 is a duplicate. Or fix it at #12987? Then I have to add this ticket as a new dependency for #12987.\n> \n> I think it better to mark #12987 as a duplicate in that case, the same way #12839 is a duplicate, and fix this issue here, at least with your proposed approach. I can certainly do that.\n\nOK, I'll comment #12987 accordingly.",
    "created_at": "2012-05-29T06:07:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150318",
    "user": "SimonKing"
}
```

Replying to [comment:30 john_perry]:
> Replying to [comment:28 SimonKing]:
> > Compare #12976: If you work on comparison of ideals, you should perhaps also consider the fact that ideals evaluating as equal may have different hash, because the hash relies on the string representation (hence, on the generators), but the comparison relies on Gröbner bases. So, the hash is broken (and is rather slow, too).
> 
> I don't understand the issue with the hash, probably because I don't know anything about how Sage hashes rings, ideals, etc.

That's how Python uses the hash: Python's dictionaries and sets are hash tables. Hence, whenever you use an ideal J (or any other object) as a key in a dictionary D or put it into a set S, then the hash is computed, and the object is put into a "bucket" that corresponds to the hash value.

If you then have an object G (say, the ideal that is given by the reduced Gröbner basis of J) and want to test whether G is in D or S (say, `D[G]` or `G in S`), then the hash of G is computed, and then **only the bucket corresponding to the hash of G** is searched for an equal object. The buckets typically are very small. Hence, if you have a quick hash function then searching in a set is much faster than searching in a list.

Now, a problem arises if `G==J` but `hash(G)!=hash(J)`: G and J may end up in *different* buckets, and thus `G in S` would return False, even though `J in S and J==G`.

Summary: It is required by Python that the hash values of equal objects are equal. Otherwise, the hash is called "broken".

> I can look into this, but: the code ignores the hash altogether, and a Groebner basis is only computed for a copy; the original ideal is untouched. So, how could this patch break the hash?

I did not claim that the patch breaks the hash. I merely stated that the hash **is** broken (see #12976), and I asked whether we should extend the patch here so that the hash is fixed, or whether we leave the hash broken for now.

> When I run the example you provide in #12987, I get this:
> {{{
> sage: %timeit J==J2
> 5 loops, best of 3: 534 ms per loop
> sage: _ = J.groebner_basis()
> sage: %timeit J==J2
> 5 loops, best of 3: 533 ms per loop
> sage: _ = J2.groebner_basis()
> sage: %timeit J==J2
> 5 loops, best of 3: 533 ms per loop
> }}}
> So it's even worse than you say; it's not that I didn't fix it; I've actually broken something there. (I don't think this is the hash; correct me if I'm wrong.)

No, there is no hash involved here.

> IMHO, rings and ideals ought to be independent of term orderings, which the user ought to be able to switch without creating a new ring & ideal.

That sounds nice at first glance. However, it would be awkward to ask for providing a term order as a new argument to the groebner_basis() method. And there are many algorithms that rely on Gröbner bases. So, I believe having a default term order for each ring (and thus have different rings for different term orders) is fine, IMHO.

Anyway, ideals that are independent of a default term order could probably be implemented using the "parents with multiple realisations" that have recently been introduced (hence, Cc to Nicolas...). I wonder, though, if that would be possible without a speed regression.

> But, your proposal:
> 
> > One could create an attribute `_gb_by_term_order_` that is a dictionary storing the Gröbner bases of an ideal with respect to different orders.
> 
> ...seems similar. Do you think a long-term fix of making rings independent of term orderings would be worth looking at?

I am not sure, see above.
 
> > How should one proceed? Fix the "useless double-computation of Gröbner bases of copies of ideals" here? Then this ticket is "needs work", and #12987 is a duplicate. Or fix it at #12987? Then I have to add this ticket as a new dependency for #12987.
> 
> I think it better to mark #12987 as a duplicate in that case, the same way #12839 is a duplicate, and fix this issue here, at least with your proposed approach. I can certainly do that.

OK, I'll comment #12987 accordingly.



---

archive/issue_comments_150319.json:
```json
{
    "body": "> > Replying to [comment:28 SimonKing]:\n> That's how Python uses the hash: Python's dictionaries and sets are hash tables. Hence, whenever you use an ideal J (or any other object) as a key in a dictionary D or put it into a set S, then the hash is computed, and the object is put into a \"bucket\" that corresponds to the hash value.\n\nThe only part that surprises me is that items with the same hash are put into a bucket. I had learned hashes differently.\n\n> Now, a problem arises if `G==J` but `hash(G)!=hash(J)`: G and J may end up in *different* buckets, and thus `G in S` would return False, even though `J in S and J==G`.\n> \n> Summary: It is required by Python that the hash values of equal objects are equal. Otherwise, the hash is called \"broken\".\n\nI see; the hash has been broken a while. I can suggest a quick hash function, actually: compute a Groebner basis of the *homogenized* ideal **up to degree** *d* for some small value of *d*. (Standard homogenization, if there's any doubt.)\n\nFiguring out a good value of *d* would be the hard part. If it's fixed at a constant, the worst you'd see is a bunch of ideals in the same bucket, which would force more Groebner basis computations than one would like. Alternately, *d* could be computed based on the generators, though I'm not sure how to do that quite yet. (max degree + 1? could get very, very expensive for some ideals)\n\nThis seems to me the safest way to provide a relatively quick signature for an ideal that ensures equal ideals with different presentations are in the same bucket, at the cost of several distinct ideals sharing the same bucket.\n\n> I did not claim that the patch breaks the hash. I merely stated that the hash **is** broken (see #12976), and I asked whether we should extend the patch here so that the hash is fixed, or whether we leave the hash broken for now.\n\nThis strikes me as a significantly different problem, albeit related, deserving of its own ticket.\n\n> > IMHO, rings and ideals ought to be independent of term orderings, which the user ought to be able to switch without creating a new ring & ideal.\n> \n> That sounds nice at first glance. However, it would be awkward to ask for providing a term order as a new argument to the groebner_basis() method.\n\nI wasn't thinking of eliminating a a *default* ordering for a ring that extends automatically to its ideals; that makes sense. I would just like the option to switch the default ordering of a ring or ideal, without having to create a new ring and/or ideal, *and* retaining the previously-computed Groebner basis, if desired.\n\nThis annoyance has actually come up in my work. I suspect a fix would require a serious re-thinking, since so many things rely on Groebner bases, and many have likely been written with the current framework in mind. It may not be feasible in the short term, maybe not even in the long term, but it seems worth discussing.\n\n> Anyway, ideals that are independent of a default term order could probably be implemented using the \"parents with multiple realisations\" that have recently been introduced (hence, Cc to Nicolas...). I wonder, though, if that would be possible without a speed regression.\n\nCan you point me to a thread or ticket?\n\nBTW, I'm adding you as a reviewer.",
    "created_at": "2012-05-29T15:14:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150319",
    "user": "john_perry"
}
```

> > Replying to [comment:28 SimonKing]:
> That's how Python uses the hash: Python's dictionaries and sets are hash tables. Hence, whenever you use an ideal J (or any other object) as a key in a dictionary D or put it into a set S, then the hash is computed, and the object is put into a "bucket" that corresponds to the hash value.

The only part that surprises me is that items with the same hash are put into a bucket. I had learned hashes differently.

> Now, a problem arises if `G==J` but `hash(G)!=hash(J)`: G and J may end up in *different* buckets, and thus `G in S` would return False, even though `J in S and J==G`.
> 
> Summary: It is required by Python that the hash values of equal objects are equal. Otherwise, the hash is called "broken".

I see; the hash has been broken a while. I can suggest a quick hash function, actually: compute a Groebner basis of the *homogenized* ideal **up to degree** *d* for some small value of *d*. (Standard homogenization, if there's any doubt.)

Figuring out a good value of *d* would be the hard part. If it's fixed at a constant, the worst you'd see is a bunch of ideals in the same bucket, which would force more Groebner basis computations than one would like. Alternately, *d* could be computed based on the generators, though I'm not sure how to do that quite yet. (max degree + 1? could get very, very expensive for some ideals)

This seems to me the safest way to provide a relatively quick signature for an ideal that ensures equal ideals with different presentations are in the same bucket, at the cost of several distinct ideals sharing the same bucket.

> I did not claim that the patch breaks the hash. I merely stated that the hash **is** broken (see #12976), and I asked whether we should extend the patch here so that the hash is fixed, or whether we leave the hash broken for now.

This strikes me as a significantly different problem, albeit related, deserving of its own ticket.

> > IMHO, rings and ideals ought to be independent of term orderings, which the user ought to be able to switch without creating a new ring & ideal.
> 
> That sounds nice at first glance. However, it would be awkward to ask for providing a term order as a new argument to the groebner_basis() method.

I wasn't thinking of eliminating a a *default* ordering for a ring that extends automatically to its ideals; that makes sense. I would just like the option to switch the default ordering of a ring or ideal, without having to create a new ring and/or ideal, *and* retaining the previously-computed Groebner basis, if desired.

This annoyance has actually come up in my work. I suspect a fix would require a serious re-thinking, since so many things rely on Groebner bases, and many have likely been written with the current framework in mind. It may not be feasible in the short term, maybe not even in the long term, but it seems worth discussing.

> Anyway, ideals that are independent of a default term order could probably be implemented using the "parents with multiple realisations" that have recently been introduced (hence, Cc to Nicolas...). I wonder, though, if that would be possible without a speed regression.

Can you point me to a thread or ticket?

BTW, I'm adding you as a reviewer.



---

archive/issue_comments_150320.json:
```json
{
    "body": "Replying to [comment:32 john_perry]:\n> The only part that surprises me is that items with the same hash are put into a bucket. I had learned hashes differently.\n\nIsn't that how hash tables work? Sorry, I am not a computer scientist, it could easily be that I misunderstood the internals of dictionaries.\n \n> I see; the hash has been broken a while. I can suggest a quick hash function, actually: compute a Groebner basis of the *homogenized* ideal **up to degree** *d* for some small value of *d*. (Standard homogenization, if there's any doubt.)\n\nWouldn't that, again, depend on the term order? And how should one choose *d*? After all, if you compute a Gr\u00f6bner basis out to degree *d* but there are further elements in higher degree, then the *complete* Gr\u00f6bner basis will have a different hash.\n\nPerhaps one could make ideals non-hashable? After all, what one needs in applications (to my experience) is the tuple of generators of the ideal.\n\n> This strikes me as a significantly different problem, albeit related, deserving of its own ticket.\n\nOK.\n \n> > Anyway, ideals that are independent of a default term order could probably be implemented using the \"parents with multiple realisations\" that have recently been introduced (hence, Cc to Nicolas...). I wonder, though, if that would be possible without a speed regression.\n> \n> Can you point me to a thread or ticket?\n\nSorry, have to catch a bus. I hope I don't forget to answer later. But perhaps Nicolas beats me to it?",
    "created_at": "2012-05-29T15:50:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150320",
    "user": "SimonKing"
}
```

Replying to [comment:32 john_perry]:
> The only part that surprises me is that items with the same hash are put into a bucket. I had learned hashes differently.

Isn't that how hash tables work? Sorry, I am not a computer scientist, it could easily be that I misunderstood the internals of dictionaries.
 
> I see; the hash has been broken a while. I can suggest a quick hash function, actually: compute a Groebner basis of the *homogenized* ideal **up to degree** *d* for some small value of *d*. (Standard homogenization, if there's any doubt.)

Wouldn't that, again, depend on the term order? And how should one choose *d*? After all, if you compute a Gröbner basis out to degree *d* but there are further elements in higher degree, then the *complete* Gröbner basis will have a different hash.

Perhaps one could make ideals non-hashable? After all, what one needs in applications (to my experience) is the tuple of generators of the ideal.

> This strikes me as a significantly different problem, albeit related, deserving of its own ticket.

OK.
 
> > Anyway, ideals that are independent of a default term order could probably be implemented using the "parents with multiple realisations" that have recently been introduced (hence, Cc to Nicolas...). I wonder, though, if that would be possible without a speed regression.
> 
> Can you point me to a thread or ticket?

Sorry, have to catch a bus. I hope I don't forget to answer later. But perhaps Nicolas beats me to it?



---

archive/issue_comments_150321.json:
```json
{
    "body": "Replying to [comment:33 SimonKing]: I am not a computer scientist, either. I learned that each hash corresponds to one, unique element. When clashes occur, the second element to hit the hash is given a new hash, based on a certain heuristic.\n\nMy understanding of what you wrote is that several objects can occupy the same hash value, and when comparisons need to be made, something more computationally expensive is called: `__eq__`, perhaps. (I wasn't sure exactly which.) That strikes me as what [this page](http://wiki.python.org/moin/DictionaryKeys) is saying, too, though I am not entirely sure.\n\n> > I see; the hash has been broken a while. I can suggest a quick hash function, actually: compute a Groebner basis of the * homogenized*  ideal ** up to degree**  * d*  for some small value of * d* . (Standard homogenization, if there's any doubt.)\n> Wouldn't that, again, depend on the term order?\n\nWe'd have to pick a \"good\" term order for the hash, just as we currently pick a \"good\" term order to test whether ideals are equal, if no Groebner basis currently exists.\n\n> And how should one choose * d* ? After all, if you compute a Gr\u00f6bner basis out to degree * d*  but there are further elements in higher degree, then the * complete*  Gr\u00f6bner basis will have a different hash.\n\nWell, yes, I said that, myself. My idea gets pretty bad, pretty quickly: A nice example of how things can go wrong is if I=<x,x<sup>5</sup>+x+1> and J=<x<sup>5</sup>+1,x<sup>5</sup>+x+1>, which are equal (to <1>, in fact). But the homogenized ideals' Groebner bases are different, regardless of degree. If one dehomogenizes, it works out, but this is already getting pretty ugly.\n\n> Perhaps one could make ideals non-hashable?\n\nI'm okay with that, too. Are ideals mutable? If so, the answer is easy.\n\nTo my thinking, ideals *are* hashable in principle; just use a Groebner basis wrt to any order at all. It's the computation of the hash that's potentially horrifying. Do you know if Python calls `__hash__` when the ideal is created, or when it's actually required? If it's the latter, rather than the former, we could simply compute a hash by computing the degrevlex Groebner basis, and be done with it. No one would encounter the performance penalty until they actually tried to use it.",
    "created_at": "2012-05-29T18:40:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150321",
    "user": "john_perry"
}
```

Replying to [comment:33 SimonKing]: I am not a computer scientist, either. I learned that each hash corresponds to one, unique element. When clashes occur, the second element to hit the hash is given a new hash, based on a certain heuristic.

My understanding of what you wrote is that several objects can occupy the same hash value, and when comparisons need to be made, something more computationally expensive is called: `__eq__`, perhaps. (I wasn't sure exactly which.) That strikes me as what [this page](http://wiki.python.org/moin/DictionaryKeys) is saying, too, though I am not entirely sure.

> > I see; the hash has been broken a while. I can suggest a quick hash function, actually: compute a Groebner basis of the * homogenized*  ideal ** up to degree**  * d*  for some small value of * d* . (Standard homogenization, if there's any doubt.)
> Wouldn't that, again, depend on the term order?

We'd have to pick a "good" term order for the hash, just as we currently pick a "good" term order to test whether ideals are equal, if no Groebner basis currently exists.

> And how should one choose * d* ? After all, if you compute a Gröbner basis out to degree * d*  but there are further elements in higher degree, then the * complete*  Gröbner basis will have a different hash.

Well, yes, I said that, myself. My idea gets pretty bad, pretty quickly: A nice example of how things can go wrong is if I=<x,x<sup>5</sup>+x+1> and J=<x<sup>5</sup>+1,x<sup>5</sup>+x+1>, which are equal (to <1>, in fact). But the homogenized ideals' Groebner bases are different, regardless of degree. If one dehomogenizes, it works out, but this is already getting pretty ugly.

> Perhaps one could make ideals non-hashable?

I'm okay with that, too. Are ideals mutable? If so, the answer is easy.

To my thinking, ideals *are* hashable in principle; just use a Groebner basis wrt to any order at all. It's the computation of the hash that's potentially horrifying. Do you know if Python calls `__hash__` when the ideal is created, or when it's actually required? If it's the latter, rather than the former, we could simply compute a hash by computing the degrevlex Groebner basis, and be done with it. No one would encounter the performance penalty until they actually tried to use it.



---

archive/issue_comments_150322.json:
```json
{
    "body": "Replying to [comment:34 john_perry]:\n> My understanding of what you wrote is that several objects can occupy the same hash value, and when comparisons need to be made, something more computationally expensive is called: `__eq__`, perhaps.\n\nYes.\n\n> > Perhaps one could make ideals non-hashable?\n> \n> I'm okay with that, too. Are ideals mutable? If so, the answer is easy.\n\nI don't think they are mutable.\n \n> To my thinking, ideals *are* hashable in principle; just use a Groebner basis wrt to any order at all. It's the computation of the hash that's potentially horrifying.\n\nYes, that's exactly the problem. One can compare ideals and can compute a reasonable hash effectively, but probably there is no way to do that efficiently in a way that preserves the mathematical notion of equality of ideals (namely: Equality as a sub-set of a ring).\n\n> Do you know if Python calls `__hash__` when the ideal is created, or when it's actually required?\n\nNo. The hash is only computed when it is needed (hence, when the ideal is put into a set or dictionary). The following toy example should illustrate what is called when:\n\n```\nsage: class Foo:\n....:     def __init__(self, n):\n....:         self.n = n\n....:     def __hash__(self):\n....:         print \"computing hash for\",self.n\n....:         return int(self.n%10)\n....:     def __cmp__(self, other):\n....:         print \"comparing\",self.n,\"with\",other.n\n....:         return cmp(self.n, other.n)\n....:     \nsage: a = Foo(5)\nsage: b = Foo(6)\nsage: c = Foo(15)\nsage: a2 = Foo(5)\nsage: a == a2\ncomparing 5 with 5\nTrue\nsage: a == b\ncomparing 5 with 6\nFalse\nsage: D = {}\nsage: D[a] = 1\ncomputing hash for 5\nsage: D[a]\ncomputing hash for 5\n1\nsage: D[b] = 2\ncomputing hash for 6\nsage: D[c] = 5\ncomputing hash for 15\ncomparing 5 with 15\n```\n\n\nAs you can see in the last line, the hash of c is computed, which I made coincide with the hash of a. So, they are put into the same hash bucket, and thus a comparison happens. But the line before, no comparison happens, because the hash bucket for b is empty when it is added to the dictionary.\n\nIn particular, normally the hash is not computed during initialisation. However, due to caching a lot of stuff in the category and coercion framework, it could very well be that the hash is created during `__init__`. I don't think that is the case for ideals, though.\n\n> If it's the latter, rather than the former, we could simply compute a hash by computing the degrevlex Groebner basis, and be done with it. No one would encounter the performance penalty until they actually tried to use it...\n\n... which is not unlikely. Currently, ideals *are* used in dictionaries, for example in singular_function, when trying to convince Singular that the given generators of some ideal form a Gr\u00f6bner basis. That's why I try to provide a faster (though syntactically less elegant) way to provide information on the arguments of singular_function (see #12977).\n\nI promised to provide you with a ticket number for multiple realisations: #7980.",
    "created_at": "2012-05-29T19:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150322",
    "user": "SimonKing"
}
```

Replying to [comment:34 john_perry]:
> My understanding of what you wrote is that several objects can occupy the same hash value, and when comparisons need to be made, something more computationally expensive is called: `__eq__`, perhaps.

Yes.

> > Perhaps one could make ideals non-hashable?
> 
> I'm okay with that, too. Are ideals mutable? If so, the answer is easy.

I don't think they are mutable.
 
> To my thinking, ideals *are* hashable in principle; just use a Groebner basis wrt to any order at all. It's the computation of the hash that's potentially horrifying.

Yes, that's exactly the problem. One can compare ideals and can compute a reasonable hash effectively, but probably there is no way to do that efficiently in a way that preserves the mathematical notion of equality of ideals (namely: Equality as a sub-set of a ring).

> Do you know if Python calls `__hash__` when the ideal is created, or when it's actually required?

No. The hash is only computed when it is needed (hence, when the ideal is put into a set or dictionary). The following toy example should illustrate what is called when:

```
sage: class Foo:
....:     def __init__(self, n):
....:         self.n = n
....:     def __hash__(self):
....:         print "computing hash for",self.n
....:         return int(self.n%10)
....:     def __cmp__(self, other):
....:         print "comparing",self.n,"with",other.n
....:         return cmp(self.n, other.n)
....:     
sage: a = Foo(5)
sage: b = Foo(6)
sage: c = Foo(15)
sage: a2 = Foo(5)
sage: a == a2
comparing 5 with 5
True
sage: a == b
comparing 5 with 6
False
sage: D = {}
sage: D[a] = 1
computing hash for 5
sage: D[a]
computing hash for 5
1
sage: D[b] = 2
computing hash for 6
sage: D[c] = 5
computing hash for 15
comparing 5 with 15
```


As you can see in the last line, the hash of c is computed, which I made coincide with the hash of a. So, they are put into the same hash bucket, and thus a comparison happens. But the line before, no comparison happens, because the hash bucket for b is empty when it is added to the dictionary.

In particular, normally the hash is not computed during initialisation. However, due to caching a lot of stuff in the category and coercion framework, it could very well be that the hash is created during `__init__`. I don't think that is the case for ideals, though.

> If it's the latter, rather than the former, we could simply compute a hash by computing the degrevlex Groebner basis, and be done with it. No one would encounter the performance penalty until they actually tried to use it...

... which is not unlikely. Currently, ideals *are* used in dictionaries, for example in singular_function, when trying to convince Singular that the given generators of some ideal form a Gröbner basis. That's why I try to provide a faster (though syntactically less elegant) way to provide information on the arguments of singular_function (see #12977).

I promised to provide you with a ticket number for multiple realisations: #7980.



---

archive/issue_comments_150323.json:
```json
{
    "body": "Replying to [comment:35 SimonKing]:\n> > > Perhaps one could make ideals non-hashable?\n> > \n> > I'm okay with that, too. Are ideals mutable? If so, the answer is easy.\n> \n> I don't think they are mutable.\n\nI don't think so, either. I don't see any way to add or subtract generators from the ideal. Well, is there a conceivable use for the hash of an ideal? For example, would someone need a set of ideals for something? I'm pretty sure this is a possibility.\n\n(Incidentally, when I wrote, \"If so, the answer is easy,\" I meant, \"If **not**, the answer is easy.\")\n\n> No. The hash is only computed when it is needed (hence, when the ideal is put into a set or dictionary). The following toy example should illustrate what is called when:\n\nIn that case, and if we can agree that someone might want to hash ideals, I suggest we using the degrevlex Groebner basis for the hash, and include a warning in the documentation that using an ideal with anything that requires a hash could slow things down seriously. That way, people have been warned. If this slows down some Sage functions that rely on dictionaries, we could rewrite them to avoid that, as you are doing with #12977.\n\nPersonally, I would rather have no hash than an incorrect one, even for immutable objects. That said, it could be a valid long-term project to find a hash for ideals.\n\n> I promised to provide you with a ticket number for multiple realisations: #7980.\n\nThanks. I'll look at it.",
    "created_at": "2012-05-29T21:10:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150323",
    "user": "john_perry"
}
```

Replying to [comment:35 SimonKing]:
> > > Perhaps one could make ideals non-hashable?
> > 
> > I'm okay with that, too. Are ideals mutable? If so, the answer is easy.
> 
> I don't think they are mutable.

I don't think so, either. I don't see any way to add or subtract generators from the ideal. Well, is there a conceivable use for the hash of an ideal? For example, would someone need a set of ideals for something? I'm pretty sure this is a possibility.

(Incidentally, when I wrote, "If so, the answer is easy," I meant, "If **not**, the answer is easy.")

> No. The hash is only computed when it is needed (hence, when the ideal is put into a set or dictionary). The following toy example should illustrate what is called when:

In that case, and if we can agree that someone might want to hash ideals, I suggest we using the degrevlex Groebner basis for the hash, and include a warning in the documentation that using an ideal with anything that requires a hash could slow things down seriously. That way, people have been warned. If this slows down some Sage functions that rely on dictionaries, we could rewrite them to avoid that, as you are doing with #12977.

Personally, I would rather have no hash than an incorrect one, even for immutable objects. That said, it could be a valid long-term project to find a hash for ideals.

> I promised to provide you with a ticket number for multiple realisations: #7980.

Thanks. I'll look at it.



---

archive/issue_comments_150324.json:
```json
{
    "body": "I'm about to upload a new patch that uses Simon's `_gb_by_ordering` idea. Here are the timings on the same machine as the other day:\n\n```\nsage: P.<x,y> = QQ[]\n<+ 30*y + 25, 1/400*x^4*y^4 - 1/5*x^5*y^2 - 1/20*x^4*y^3 + 4*x^6 + 2*x^5*y + 11/20*x^4*y^2 - 12*x^5 - 3*x^4*y + 9*x^4]*P      \nsage: J2 = J.gens()*P\nsage: %timeit J==J2\n5 loops, best of 3: 376 \u00b5s per loop\nsage: _ = J.groebner_basis()\nsage: %timeit J==J2         \n625 loops, best of 3: 372 \u00b5s per loop\nsage: _ = J2.groebner_basis()\nsage: %timeit J==J2\n625 loops, best of 3: 362 \u00b5s per loop\n```\n\nA more than 1000-fold increase. :-)\n\nAll tests in sage/rings pass muster, as do the tests in schemes that had failed the other day.",
    "created_at": "2012-05-30T15:20:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150324",
    "user": "john_perry"
}
```

I'm about to upload a new patch that uses Simon's `_gb_by_ordering` idea. Here are the timings on the same machine as the other day:

```
sage: P.<x,y> = QQ[]
<+ 30*y + 25, 1/400*x^4*y^4 - 1/5*x^5*y^2 - 1/20*x^4*y^3 + 4*x^6 + 2*x^5*y + 11/20*x^4*y^2 - 12*x^5 - 3*x^4*y + 9*x^4]*P      
sage: J2 = J.gens()*P
sage: %timeit J==J2
5 loops, best of 3: 376 µs per loop
sage: _ = J.groebner_basis()
sage: %timeit J==J2         
625 loops, best of 3: 372 µs per loop
sage: _ = J2.groebner_basis()
sage: %timeit J==J2
625 loops, best of 3: 362 µs per loop
```

A more than 1000-fold increase. :-)

All tests in sage/rings pass muster, as do the tests in schemes that had failed the other day.



---

archive/issue_comments_150325.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2012-05-30T15:20:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150325",
    "user": "john_perry"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_150326.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-05-30T17:31:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150326",
    "user": "SimonKing"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150327.json:
```json
{
    "body": "I can confirm the 1000-fold speed-up. Great!\n\nHowever, the patch bot finds a few doctest errors. They are clearly related to this patch.\n\nBy the way: Could you also provide a test that confirms that '_gb_by_ordering' is preserved when copying/pickling an ideal?",
    "created_at": "2012-05-30T17:31:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150327",
    "user": "SimonKing"
}
```

I can confirm the 1000-fold speed-up. Great!

However, the patch bot finds a few doctest errors. They are clearly related to this patch.

By the way: Could you also provide a test that confirms that '_gb_by_ordering' is preserved when copying/pickling an ideal?



---

archive/issue_comments_150328.json:
```json
{
    "body": "Replying to [comment:38 SimonKing]:\n> However, the patch bot finds a few doctest errors. They are clearly related to this patch.\n\nThanks for pointing them out. They look easy.\n\n> By the way: Could you also provide a test that confirms that '_gb_by_ordering' is preserved when copying/pickling an ideal?\n\nI should have an updated patch out by the end of the day",
    "created_at": "2012-05-30T17:43:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150328",
    "user": "john_perry"
}
```

Replying to [comment:38 SimonKing]:
> However, the patch bot finds a few doctest errors. They are clearly related to this patch.

Thanks for pointing them out. They look easy.

> By the way: Could you also provide a test that confirms that '_gb_by_ordering' is preserved when copying/pickling an ideal?

I should have an updated patch out by the end of the day



---

archive/issue_comments_150329.json:
```json
{
    "body": "New file fixes the previously broken doctests, and adds a pickling test for `__gb_by_ordering`.",
    "created_at": "2012-05-30T22:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150329",
    "user": "john_perry"
}
```

New file fixes the previously broken doctests, and adds a pickling test for `__gb_by_ordering`.



---

archive/issue_comments_150330.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-05-30T22:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150330",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150331.json:
```json
{
    "body": "As much as I understand, both patches need proper commit messages (also containing the ticket number).",
    "created_at": "2012-06-01T07:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150331",
    "user": "SimonKing"
}
```

As much as I understand, both patches need proper commit messages (also containing the ticket number).



---

archive/issue_comments_150332.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-06-01T07:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150332",
    "user": "SimonKing"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150333.json:
```json
{
    "body": "The second one definitely needs a non-queue message, but there is no need in the ticket number, it will be added automatically during merge.",
    "created_at": "2012-06-01T14:37:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150333",
    "user": "novoselt"
}
```

The second one definitely needs a non-queue message, but there is no need in the ticket number, it will be added automatically during merge.



---

archive/issue_comments_150334.json:
```json
{
    "body": "Attachment [trac_12802_and_12839.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_and_12839.patch) by john_perry created at 2012-06-01 16:41:25",
    "created_at": "2012-06-01T16:41:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150334",
    "user": "john_perry"
}
```

Attachment [trac_12802_and_12839.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_and_12839.patch) by john_perry created at 2012-06-01 16:41:25



---

archive/issue_comments_150335.json:
```json
{
    "body": "Attachment [trac_12802_additional_changes.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_additional_changes.patch) by john_perry created at 2012-06-01 16:41:36",
    "created_at": "2012-06-01T16:41:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150335",
    "user": "john_perry"
}
```

Attachment [trac_12802_additional_changes.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_additional_changes.patch) by john_perry created at 2012-06-01 16:41:36



---

archive/issue_comments_150336.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-06-01T16:43:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150336",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150337.json:
```json
{
    "body": "Replying to [comment:41 SimonKing]:\n> As much as I understand, both patches need proper commit messages (also containing the ticket number).\n\nOkidoki. Whether the ticket number is required or not, it's no skin off my back.",
    "created_at": "2012-06-01T16:43:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150337",
    "user": "john_perry"
}
```

Replying to [comment:41 SimonKing]:
> As much as I understand, both patches need proper commit messages (also containing the ticket number).

Okidoki. Whether the ticket number is required or not, it's no skin off my back.



---

archive/issue_comments_150338.json:
```json
{
    "body": "For the patchbot:\n\nApply trac_12802_and_12839.patch trac_12802_additional_changes.patch",
    "created_at": "2012-06-01T21:24:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150338",
    "user": "SimonKing"
}
```

For the patchbot:

Apply trac_12802_and_12839.patch trac_12802_additional_changes.patch



---

archive/issue_comments_150339.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-06-02T14:40:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150339",
    "user": "SimonKing"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_150340.json:
```json
{
    "body": "The tests with 5.0 ran fine, and the patchbot only finds a probably unrelated timeout with 5.1.beta. So, I'd say the patch looks fine, solves the problem, and the speed-up is impressive. Positive review.",
    "created_at": "2012-06-02T14:40:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150340",
    "user": "SimonKing"
}
```

The tests with 5.0 ran fine, and the patchbot only finds a probably unrelated timeout with 5.1.beta. So, I'd say the patch looks fine, solves the problem, and the speed-up is impressive. Positive review.



---

archive/issue_comments_150341.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-06-15T16:14:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150341",
    "user": "jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_150342.json:
```json
{
    "body": "What's up with all the whitespace changes in [attachment:trac_12802_and_12839.patch]?  Please don't do this, it will only cause merge conflicts.  Removing whitespace in/around code you change is fine (even encouraged), but don't just do this everywhere.",
    "created_at": "2012-06-15T16:14:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150342",
    "user": "jdemeyer"
}
```

What's up with all the whitespace changes in [attachment:trac_12802_and_12839.patch]?  Please don't do this, it will only cause merge conflicts.  Removing whitespace in/around code you change is fine (even encouraged), but don't just do this everywhere.



---

archive/issue_comments_150343.json:
```json
{
    "body": "Any progress on whitespace removal? Looks like that's the only issue here!",
    "created_at": "2012-07-25T22:23:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150343",
    "user": "novoselt"
}
```

Any progress on whitespace removal? Looks like that's the only issue here!



---

archive/issue_comments_150344.json:
```json
{
    "body": "I plan to do it, sooner rather than later. It just hasn't been as high a priority as some other things.",
    "created_at": "2012-07-25T22:26:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150344",
    "user": "john_perry"
}
```

I plan to do it, sooner rather than later. It just hasn't been as high a priority as some other things.



---

archive/issue_comments_150345.json:
```json
{
    "body": "I reworked the patches into one, which lacks the changes to whitespace. Two notes:\n\n1. I'm working with sage 5.0.1 here; I haven't downloaded 5.1 yet on any of my machines. I think this should work all the same. I'll download 5.1 next week and try it.\n2. I have not yet tested all of sage. I did run tests on all the files that have been modified; these were the only ones that had problems in the past. I am running doctests now, but if anyone sees a problem before I do, please do say.\n\n(Sorry about the whitespace thing, by the way; I got a little overeager on it.)",
    "created_at": "2012-07-27T21:04:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150345",
    "user": "john_perry"
}
```

I reworked the patches into one, which lacks the changes to whitespace. Two notes:

1. I'm working with sage 5.0.1 here; I haven't downloaded 5.1 yet on any of my machines. I think this should work all the same. I'll download 5.1 next week and try it.
2. I have not yet tested all of sage. I did run tests on all the files that have been modified; these were the only ones that had problems in the past. I am running doctests now, but if anyone sees a problem before I do, please do say.

(Sorry about the whitespace thing, by the way; I got a little overeager on it.)



---

archive/issue_comments_150346.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-07-27T21:04:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150346",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150347.json:
```json
{
    "body": "There's a problem with some files regarding schemes -- I think I know the cause, and will fix it soon.",
    "created_at": "2012-07-27T22:52:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150347",
    "user": "john_perry"
}
```

There's a problem with some files regarding schemes -- I think I know the cause, and will fix it soon.



---

archive/issue_comments_150348.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-07-27T22:52:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150348",
    "user": "john_perry"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150349.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-07-27T23:31:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150349",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150350.json:
```json
{
    "body": "Okay, a diff performed on the results of different patches showed the problems.\n\nMost tests passed before I interrupted the previous run; I've checked that the previous failures now pass. I'm running tests now on the files that were not checked before.",
    "created_at": "2012-07-27T23:31:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150350",
    "user": "john_perry"
}
```

Okay, a diff performed on the results of different patches showed the problems.

Most tests passed before I interrupted the previous run; I've checked that the previous failures now pass. I'm running tests now on the files that were not checked before.



---

archive/issue_comments_150351.json:
```json
{
    "body": "All tests pass on my machine.",
    "created_at": "2012-07-27T23:50:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150351",
    "user": "john_perry"
}
```

All tests pass on my machine.



---

archive/issue_comments_150352.json:
```json
{
    "body": "In order to tell the patch bot what to do:\n\nApply trac_12802_no_whitespace.patch",
    "created_at": "2012-07-28T07:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150352",
    "user": "SimonKing"
}
```

In order to tell the patch bot what to do:

Apply trac_12802_no_whitespace.patch



---

archive/issue_comments_150353.json:
```json
{
    "body": "I just noticed from the patchbot that I had uploaded an older version of the patch, on account of forgetting to sync. If you're testing this, please download the revision. Sorry about that.",
    "created_at": "2012-07-29T11:49:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150353",
    "user": "john_perry"
}
```

I just noticed from the patchbot that I had uploaded an older version of the patch, on account of forgetting to sync. If you're testing this, please download the revision. Sorry about that.



---

archive/issue_comments_150354.json:
```json
{
    "body": "The new patch still needs a good commit message.  This patch isn't about \"no white space\", it's about ideals...",
    "created_at": "2012-08-08T13:07:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150354",
    "user": "jdemeyer"
}
```

The new patch still needs a good commit message.  This patch isn't about "no white space", it's about ideals...



---

archive/issue_comments_150355.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-08-08T13:07:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150355",
    "user": "jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_150356.json:
```json
{
    "body": "Attachment [trac_12802_no_whitespace.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_no_whitespace.patch) by john_perry created at 2012-08-08 18:26:55\n\nshould incorporate other patches, without the removal of whitespace",
    "created_at": "2012-08-08T18:26:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150356",
    "user": "john_perry"
}
```

Attachment [trac_12802_no_whitespace.patch](tarball://root/attachments/some-uuid/ticket12802/trac_12802_no_whitespace.patch) by john_perry created at 2012-08-08 18:26:55

should incorporate other patches, without the removal of whitespace



---

archive/issue_comments_150357.json:
```json
{
    "body": "Informative commit message added.",
    "created_at": "2012-08-08T18:27:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150357",
    "user": "john_perry"
}
```

Informative commit message added.



---

archive/issue_comments_150358.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-08-08T18:27:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150358",
    "user": "john_perry"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_150359.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-09-26T07:34:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150359",
    "user": "jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_150360.json:
```json
{
    "body": "How much precedent do we have to let < and > mean a containment partial ordering? Doesn't the presence of '<' make that \"sort\" doesn't throw an error and instead produces arbitrary results?",
    "created_at": "2012-09-26T08:00:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150360",
    "user": "nbruin"
}
```

How much precedent do we have to let < and > mean a containment partial ordering? Doesn't the presence of '<' make that "sort" doesn't throw an error and instead produces arbitrary results?



---

archive/issue_comments_150361.json:
```json
{
    "body": "Replying to [comment:58 nbruin]:\n> How much precedent do we have to let < and > mean a containment partial ordering? Doesn't the presence of '<' make that \"sort\" doesn't throw an error and instead produces arbitrary results?\n\n**This problem predated the patch! ** As the original report points out, `<` returned a result before, but the result was wrong. There was already a `__cmp__` method, so the choices were either to remove it or make sure that something else trumped it. Hence the introduction of `__lt__`, etc.\n\nAs long as there is a `__cmp__`, there will be an ordering -- and Python supplies a `__cmp__` when none is given.\n\n(Or am I wrong?)",
    "created_at": "2012-09-26T13:40:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150361",
    "user": "john_perry"
}
```

Replying to [comment:58 nbruin]:
> How much precedent do we have to let < and > mean a containment partial ordering? Doesn't the presence of '<' make that "sort" doesn't throw an error and instead produces arbitrary results?

**This problem predated the patch! ** As the original report points out, `<` returned a result before, but the result was wrong. There was already a `__cmp__` method, so the choices were either to remove it or make sure that something else trumped it. Hence the introduction of `__lt__`, etc.

As long as there is a `__cmp__`, there will be an ordering -- and Python supplies a `__cmp__` when none is given.

(Or am I wrong?)



---

archive/issue_comments_150362.json:
```json
{
    "body": "Not all python types admit comparison\n\n```\nsage: complex(1,2)<complex(1,3)\nTypeError: no ordering relation is defined for complex numbers\n```\n\nbut you're right that by default it seems they do:\n\n```\nsage: class B(object):\n....:     pass\n....: \nsage: b1=B()\nsage: b2=B()\nsage: b1 < b2\nFalse\nsage: b2 < b1\nTrue\n```\n\nThat changes with Python 3, though.",
    "created_at": "2012-09-26T20:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150362",
    "user": "nbruin"
}
```

Not all python types admit comparison

```
sage: complex(1,2)<complex(1,3)
TypeError: no ordering relation is defined for complex numbers
```

but you're right that by default it seems they do:

```
sage: class B(object):
....:     pass
....: 
sage: b1=B()
sage: b2=B()
sage: b1 < b2
False
sage: b2 < b1
True
```

That changes with Python 3, though.



---

archive/issue_comments_150363.json:
```json
{
    "body": "Apparently, complex is a built-in class; I can't find the source that makes it avoid comparison. However, it makes sense to raise an error in the case where the ideals are incomparable. I wouldn't raise a TypeError, though, but a ValueError. Does that sound acceptable? If so, I'll change the status to Needs Work (AGAIN) and upload a new patch...",
    "created_at": "2012-09-26T20:38:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150363",
    "user": "john_perry"
}
```

Apparently, complex is a built-in class; I can't find the source that makes it avoid comparison. However, it makes sense to raise an error in the case where the ideals are incomparable. I wouldn't raise a TypeError, though, but a ValueError. Does that sound acceptable? If so, I'll change the status to Needs Work (AGAIN) and upload a new patch...



---

archive/issue_comments_150364.json:
```json
{
    "body": "What exactly does it mean \"incomparable ideals\"? If `I < J` means \"Is I a subideal of J?\", it always can be answered: if `I` leaves in a different ring without coercions - the answer is just \"no\". So I don't think any errors have to be thrown.\n\nI also think that it is useful to be able to sort any mix of anything, so `sort` should never though an error, even if the result depends on the position of objects in memory.",
    "created_at": "2012-09-26T20:48:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150364",
    "user": "novoselt"
}
```

What exactly does it mean "incomparable ideals"? If `I < J` means "Is I a subideal of J?", it always can be answered: if `I` leaves in a different ring without coercions - the answer is just "no". So I don't think any errors have to be thrown.

I also think that it is useful to be able to sort any mix of anything, so `sort` should never though an error, even if the result depends on the position of objects in memory.



---

archive/issue_comments_150365.json:
```json
{
    "body": "Replying to [comment:62 novoselt]:\n> I also think that it is useful to be able to sort any mix of anything, so `sort` should never though an error, even if the result depends on the position of objects in memory.\n\nThat just leads to silently incorrect code. If you want to sort on `id` you can do sort(L,key=id)\n\n```\nsage: sorted([-10,-11,123,124,1000],key=id)\n[123, -10, -11, 124, 1000]\nsage: sorted([-10,-11,123,124,1000],key=id)\n[124, 1000, 123, -10, -11]\nsage: sorted([-10,-11,123,124,1000],key=id)\n[-11, 124, 123, -10, 1000]\n```\n\nI'm curious to see a useful application of this.\n\nThis is all a bit off-topic, though. There IS precedent in python to use `<` for partial ordering.\n\n```\nsage: set([2])<set([1,2,3])\nTrue\nsage: set([1,2,3])<set([3])\nFalse\nsage: set([1,2,3])<set([4,5])\nFalse\nsage: set([4,5])<set([1,2,3])\nFalse\n```\n\nso supporting this for ideals should be fine. I'd throw an error if the ideals are \"incompatible\" for comparison (according to coercion rules for common covering structure, I'd say), but `False` would be consistent too (it's a partial ordering, after all).",
    "created_at": "2012-09-26T21:16:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150365",
    "user": "nbruin"
}
```

Replying to [comment:62 novoselt]:
> I also think that it is useful to be able to sort any mix of anything, so `sort` should never though an error, even if the result depends on the position of objects in memory.

That just leads to silently incorrect code. If you want to sort on `id` you can do sort(L,key=id)

```
sage: sorted([-10,-11,123,124,1000],key=id)
[123, -10, -11, 124, 1000]
sage: sorted([-10,-11,123,124,1000],key=id)
[124, 1000, 123, -10, -11]
sage: sorted([-10,-11,123,124,1000],key=id)
[-11, 124, 123, -10, 1000]
```

I'm curious to see a useful application of this.

This is all a bit off-topic, though. There IS precedent in python to use `<` for partial ordering.

```
sage: set([2])<set([1,2,3])
True
sage: set([1,2,3])<set([3])
False
sage: set([1,2,3])<set([4,5])
False
sage: set([4,5])<set([1,2,3])
False
```

so supporting this for ideals should be fine. I'd throw an error if the ideals are "incompatible" for comparison (according to coercion rules for common covering structure, I'd say), but `False` would be consistent too (it's a partial ordering, after all).



---

archive/issue_comments_150366.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-09-28T07:47:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12630#issuecomment-150366",
    "user": "jdemeyer"
}
```

Resolution: fixed
