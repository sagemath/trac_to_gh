# Issue 17441: special values of Bessel functions

Issue created by migration from https://trac.sagemath.org/ticket/17678

Original creator: rws

Original creation time: 2015-01-27 17:14:23

CC:  chapoton fredrik.johansson

At the moment everything Bessel is sent to mpmath and returns floating point but I<sub>n</sub>(0) and J<sub>n</sub>(0) are in (0,1). Also all I/J/K/Y<sub>n</sub>(x) with n in (-1/2,1/2) is a simple expression.

For the latter see p.10 of
http://www.math.psu.edu/papikian/Kreh.pdf


---

Comment by rws created at 2015-01-28 08:43:02

Changing status from new to needs_review.


---

Comment by rws created at 2015-01-28 08:43:02

New commits:


---

Comment by kcrisman created at 2015-02-03 03:32:55

I like the general idea of this ticket!  What happens in the following scenario

```
+        if x == 0:
+            if n == 0:
+                return ZZ(1)
```

for 

```
sage: bessel_J(0.0, 0.0)
1
```

should it instead return `1.0`? I feel like we have a lot of code in Sage doing type conversions of this kind smartly - sadly, I was not the one gifted to write it.  Maybe something like saving the parents of the input and if one is inexact then so is the output, something along those lines... we had some issues with `sin(0)` versus `sin(0.0)` even, I think; currently

```
sage: sin(0)
0
sage: sin(0.0)
0.000000000000000
sage: sin(float(0))
0.0
sage: sin(RDF(0))
0.0
sage: sin(complex(0))
0j
```



---

Comment by rws created at 2015-02-03 07:10:16

Replying to [comment:3 kcrisman]:
> What happens in the following scenario
> {{{
> +        if x == 0:
> +            if n == 0:
> +                return ZZ(1)
> }}}
> for 
> {{{
> sage: bessel_J(0.0, 0.0)
> 1
> }}}
> should it instead return `1.0`?
It does.

In #17130 Jeroen automatized handling of type in `BuiltinFunction`.


---

Comment by kcrisman created at 2015-02-03 13:49:50

I guess I didn't internalize that it would fix all future problems with this, very nice.


---

Comment by kcrisman created at 2015-02-03 15:40:30

These identities are also available (or derivable) from Wikipedia and Mathworld, so we are in good shape.

Question: [W|A claims](http://www.wolframalpha.com/input/?i=besselj%28-5%2F2%2C0%29) that one has the complex infinity, not positive infinity, for some of the negative ones like `bessel_J(-5/2, 0)` or for `bessel_I`.  I don't know what to make of that, though.  Also, does `bessel_Y` have an analogous special value for x=0, negative n?

Otherwise looks good.


---

Comment by rws created at 2015-02-04 09:25:23

Replying to [comment:6 kcrisman]:
> Question: [W|A claims](http://www.wolframalpha.com/input/?i=besselj%28-5%2F2%2C0%29) that one has the complex infinity, not positive infinity, for some of the negative ones like `bessel_J(-5/2, 0)` or for `bessel_I`.  I don't know what to make of that, though.
I got those values from mpmath and just tried to post about that to the mpmath group, but not yet approved.
> Also, does `bessel_Y` have an analogous special value for x=0, negative n?
Ah, I missed that. It should be easily derived from `Bessel_J` with Y<sub>n</sub>(z)=(J<sub>n</sub>(z)*cos(n*pi)-J<sub>-n</sub>(z))/sin(n*pi) (Abramowitz and Stegun 1972, p. 358).


---

Comment by kcrisman created at 2015-02-12 04:21:15

Changing status from needs_review to needs_work.


---

Comment by kcrisman created at 2015-02-12 04:21:15

> Ah, I missed that. It should be easily derived from
Yes, I figured - but should it be included?  Sorry for not being clear.

Did you hear back from Fredrik/mpmath?


---

Comment by rws created at 2015-02-12 06:39:51

Replying to [comment:8 kcrisman]:
> > Ah, I missed that. It should be easily derived from
> Yes, I figured - but should it be included?
Of course!
> Did you hear back from Fredrik/mpmath?
https://groups.google.com/forum/?hl=en#!topic/mpmath/FJqtBMNhYFo
So, IMO the mpmath behaviour fits its numerical requirements but we should use "zoo" because it's more symbolically correct, and because we have it.


---

Comment by git created at 2015-02-13 17:14:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-02-13 17:16:09

This uncovered a bug so we depend on #17777 as soon as it is resolved.


---

Comment by rws created at 2015-02-13 17:16:09

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-02-14 08:00:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-02-26 09:37:12

Changing status from needs_review to needs_work.


---

Comment by rws created at 2015-02-26 09:37:12

There is a doctest fail in french_book that is not from #17777.


---

Comment by git created at 2015-03-05 07:31:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-03-05 07:36:55

Squashed it all into one commit.
----
New commits:


---

Comment by rws created at 2015-03-05 07:36:55

Changing priority from minor to major.


---

Comment by rws created at 2015-03-05 07:36:55

Changing status from needs_work to needs_review.


---

Comment by kcrisman created at 2015-05-21 16:43:08

> > Also, does `bessel_Y` have an analogous special value for x=0, negative n?
> Ah, I missed that. It should be easily derived from `Bessel_J` with Y<sub>n</sub>(z)=(J<sub>n</sub>(z)*cos(n*pi)-J<sub>-n</sub>(z))/sin(n*pi) (Abramowitz and Stegun 1972, p. 358).
I didn't see anything about this in the many commits here, haven't looked at the 'squashed' one but assume it's not there either.  Otherwise this just requires (from my point of view) some testing.


---

Comment by kcrisman created at 2015-05-21 19:25:38

Replying to [comment:17 kcrisman]:
> > > Also, does `bessel_Y` have an analogous special value for x=0, negative n?
> > Ah, I missed that. It should be easily derived from `Bessel_J` with Y<sub>n</sub>(z)=(J<sub>n</sub>(z)*cos(n*pi)-J<sub>-n</sub>(z))/sin(n*pi) (Abramowitz and Stegun 1972, p. 358).
Also:

```
sage: bessel_J(-5./2,0.)
+infinity
sage: type(_)
<type 'sage.rings.real_mpfr.RealNumber'>
```

I'm not sure what the "right" resolution is here, since MPFR may not have an unsigned infinity.

Patchbot is happy and I don't expect my own last test run to go bad, so these two things are all that remains to resolve, perhaps they are even non-issues?


---

Comment by kcrisman created at 2015-05-21 19:26:10

Changing status from needs_review to needs_info.


---

Comment by rws created at 2015-05-24 15:24:32

Changing status from needs_info to needs_work.


---

Comment by rws created at 2015-05-25 16:27:53

Replying to [comment:18 kcrisman]:
> {{{
> sage: bessel_J(-5./2,0.)
> +infinity
> sage: type(_)
> <type 'sage.rings.real_mpfr.RealNumber'>
> }}}
> I'm not sure what the "right" resolution is here, since MPFR may not have an unsigned infinity.
This appears to be widespread, e.g. I just found `polylog(1.,1.)` vs. `polylog(1,1)` which is due to `zeta(1.)` vs. `zeta(1)`.


---

Comment by rws created at 2015-10-20 12:52:50

Changing status from needs_work to needs_review.


---

Comment by rws created at 2015-10-20 12:52:50

The infinity inconsistency is handled by #19439. Please review.
----
New commits:


---

Comment by kcrisman created at 2015-10-20 13:11:59

Thanks for opening that ticket, that is fine for that issue.

Still a problem here:

```
sage: bessel_Y(-3,0)
Infinity
sage: bessel_Y(3,0)
Infinity
sage: bessel_Y(3.1,0)
-infinity
sage: bessel_Y(3.2,0)
-infinity
sage: bessel_Y(-3.2,0)
+infinity
sage: bessel_Y(-3.3,0)
+infinity
sage: bessel_Y(-33/10,0)
Infinity
```



Extra `var('n')`?

```
+    def _eval_(self, n, x):
+        """
+        EXAMPLES::
+
+            sage: n = var('n')
+            sage: bessel_Y(1, 0)
+            Infinity
+            sage: bessel_Y(1/2, x)
+            -sqrt(2)*sqrt(1/(pi*x))*cos(x)
+            sage: bessel_Y(-1/2, x)
+            sqrt(2)*sqrt(1/(pi*x))*sin(x)
+        """
```



---

Comment by rws created at 2016-06-12 08:38:00

Changing status from needs_review to needs_work.


---

Comment by arminstraub created at 2016-08-08 11:42:30

Changing status from needs_work to needs_review.


---

Comment by arminstraub created at 2016-08-08 11:42:30

We stumpled across the issue that `bessel_J(0,x).series(x,3)` didn't have the expected result during a summer school on special functions, in which I was advertising Sage.  It would be nice to report back to the students that the next version of Sage has this fixed :)

This is my first attempt at using git and I haven't used the trac server in many years, so please let me know if I messed something up or didn't follow best practices.  The branch I pushed is supposed to be a merge with the most recent version of Sage, with the following additional changes:

* Removed the extra `var('n')` as noticed by Karl-Dieter.
* In `Function_Bessel_J._eval_`, I replaced `n > 0` with `n.real() > 0`.  I also changed the behaviour to only return `unsigned_infinity` if the real part of `n` is negative.  The reason for these changes is that `bessel_J(i, 0)` should not be evaluated as `0`, as it previously was, nor should it be evaluated as infinite.  (Mathematica evaluates this value as `Indeterminate`.)
* Likewise for `bessel_I`, for which the situation is equivalent.
* Similarly, I changed `Function_Bessel_Y._eval_` so that indeterminate values like `bessel_Y(I,0)` are not evaluated.
* Likewise for `bessel_K`.

Doctesting the 5 involved files didn't reveal any troubles.
----
New commits:


---

Comment by arminstraub created at 2016-08-08 11:47:16

Replying to [comment:24 kcrisman]:
> Still a problem here:
> {{{
> sage: bessel_Y(-3,0)
> Infinity
> sage: bessel_Y(3,0)
> Infinity
> sage: bessel_Y(3.1,0)
> -infinity
> sage: bessel_Y(3.2,0)
> -infinity
> sage: bessel_Y(-3.2,0)
> +infinity
> sage: bessel_Y(-3.3,0)
> +infinity
> sage: bessel_Y(-33/10,0)
> Infinity
> }}}

Indeed, the behaviour for values of Bessel functions at zero is not consistent between symbolic and numeric input.  The symbolic evaluations as provided by this ticket seem appropriate to me (and, as far as I have tested, also agree with the values that Mathematica produces).

On the other hand, the numerical evaluation of Bessel functions is currently outsourced to `mpmath`.  I don't know about the conventions that `mpmath` is using when reporting the corresponding values for numeric `x` (for instance, for `bessel_Y(1/2,x) == -sqrt(2)*sqrt(1/(pi*x))*cos(x)` mpmath produces `mpmath.bessely(0.5,0) == mpf('-inf')`, which results in `bessel_Y(0.5,0) == -infinity`, which is clearly not the limiting value when x approaches zero on the imaginary axis).  To achieve perfect consistency, one could modify the `_evalf_` function to not let `mpmath` handle these cases.  This seems, however, not like an ideal solution.

I would suggest that resolving this inconsistency is better suited for a different ticket (or, if desired, changing the behaviour within `mpmath` itself).


---

Comment by arminstraub created at 2016-08-08 11:52:01

By the way, what is the preferred approach of Sage to the following?

When the index of the Bessel functions is a half-integer, they can be written in terms of elementary functions.  This is currently implemented for indices 1/2 and -1/2 only.  Would it be desirable to likewise implement the case of general half-integer indices?  Or, would it be better to leave, say, `bessel_J(21/2, x)` unevaluated and wait for the user to, somehow (how?), explicitly ask for a simplification?


---

Comment by rws created at 2016-08-09 07:46:19

Replying to [comment:29 arminstraub]:
>  It would be nice to report back to the students that the next version of Sage has this fixed :)

Indeed, but the discussion focused a bit on the dependency on #17777, which I agree however does not exist, i.e. both issues are mutually independent.

Your additions look fine, consider them reviewed. There is one failing doctest due to simplification in `src/sage/interfaces/maxima_lib.py`. A minor caveat is also in my previous branch, all the comparisons `n,x == 0` should rather read `n,x.is_trivial_zero()` because any nonnumerical symbolic expression will trigger the expensive proof machinery in `Expression.__nonzero__()`. So if you could please change these two minor issues you can set positive yourself. Thanks for your work.

> By the way, what is the preferred approach of Sage to the following?
> 
> When the index of the Bessel functions is a half-integer, they can be written in terms of elementary functions.  This is currently implemented for indices 1/2 and -1/2 only.  Would it be desirable to likewise implement the case of general half-integer indices?  Or, would it be better to leave, say, `bessel_J(21/2, x)` unevaluated and wait for the user to, somehow (how?), explicitly ask for a simplification?

This was not formalized up to now, the general behaviour was to give such conversions if the result is both more elementary and not very complicated. Full implementation can be done in a `Expression.expand_bessel()` function which would then, at some time later, be part of a general `rewrite()` tool (#10137). So to your question, automatic expansion yes, as long as the output doesn't exceed---say one line, and in a dedicated expand function always welcome.


---

Comment by git created at 2016-08-09 20:35:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by arminstraub created at 2016-08-09 20:39:00

Thanks for your swift and helpful feedback!

I have fixed the failing doctest (the entire example needed to be replaced).

You also mentioned to use `sth.is_trivial_zero()` instead of `sth == 0`, and the reasoning makes perfect sense.  A minor trouble is that when calling, say, `sage: bessel_J(5/2, 0)`, then `x` and `n` are not expressions and so don't have the property `is_trivial_zero`.  One workaround would be to use `(isinstance(sth, Expression) and sth.is_trivial_zero()) or sth == 0` but that doesn't feel natural to me.  Another workaround would be `SR(sth).is_trivial_zero()` but that also doesn't feel right (and I couldn't find this being used in other Sage code).  After some more looking, I found that the code for hypergeometric functions uses things like `if not isinstance(z, Expression) and z == 0:` a couple of times.  For now, that's what I used also (only for `x` because the index `n` shouldn't usually be a complicated expression, and because other functions distinguish similarly).

Since there was some choices to be made, I haven't set the ticket to positive review myself.  Could you please have a quick look!


---

Comment by arminstraub created at 2016-08-09 20:43:43

On the other hand, wouldn't it be convenient to have a global function `is_trivial_zero` for the purpose of comparing with zero, without working too hard to simplify?


```
def is_trivial_zero(x):
    try: return x.is_trivial_zero()
    except AttributeError: return x == 0
```


One place for such a function could be `sage/misc/functional.py` which already contains things like `is_even` (which I used as a blueprint here).

Do you think it would be a good idea to have something like that?  If so, should a ticket be opened for that?


---

Comment by rws created at 2016-08-10 07:21:35

Replying to [comment:32 arminstraub]:
> ... to use `(isinstance(sth, Expression) and sth.is_trivial_zero()) or sth == 0` 

No, that calls `__nonzero__` after `is_trivial_zero()` returned `False`. You need `(isinstance(sth, Expression) and sth.is_trivial_zero()) or (not isinstance(sth, Expression) and sth == 0)`.

> After some more looking, I found that the code for hypergeometric functions uses things like `if not isinstance(z, Expression) and z == 0:` a couple of times.  For now, that's what I used also (only for `x` because the index `n` shouldn't usually be a complicated expression, and because other functions distinguish similarly).

Well that misses the `SR(0)` case and looks buggy.

> On the other hand, wouldn't it be convenient to have a global function `is_trivial_zero`...

Try opening a ticket, but see also #17158


---

Comment by rws created at 2016-08-10 08:21:55

> Well that misses the `SR(0)` case and looks buggy.

No, that actually works. What's odd is that I get now an error in `src/sage/tests/french_book/recequadiff.py` that only happens with `sage -tp`. As it is spurious I changed the test. As your work is reviewed someone still needs to look at my commit. Could you please do that and then set positive?
----
New commits:


---

Comment by arminstraub created at 2016-08-10 11:41:03

Changing status from needs_review to positive_review.


---

Comment by arminstraub created at 2016-08-10 11:41:03

Looks good! Set to positive review.

Replying to [comment:36 rws]:
> > Well that misses the `SR(0)` case and looks buggy.
> No, that actually works.

Yes, I was initially worried about that, too, when following the hypergeometric implementation.

> What's odd is that I get now an error in `src/sage/tests/french_book/recequadiff.py` that only happens with `sage -tp`. As it is spurious I changed the test.

Your solution seems fine.  I am seeing the same spurious behavior when running the test versus running the code in a notebook.

> You need `(isinstance(sth, Expression) and sth.is_trivial_zero()) or (not isinstance(sth, Expression) and sth == 0)`.

Oops, you are right!  Definitely not a brief and convenient substitute for `sth == 0`.  I'll open a ticket suggesting a global `is_trivial_zero` function.


---

Comment by arminstraub created at 2016-08-10 12:20:37

Replying to [comment:34 rws]:
> > On the other hand, wouldn't it be convenient to have a global function `is_trivial_zero`...
> Try opening a ticket, but see also #17158

Posted as #21201.


---

Comment by vbraun created at 2016-08-13 22:51:15

Resolution: fixed
