# Issue 22217: is_unit can give wrong results in mutlivariate and infinite polynomial rings.

Issue created by migration from Trac.

Original creator: msaaltink

Original creation time: 2017-02-26 20:58:07

There are 6 different definitions of `is_unit` for polynomials over commutative rings in sage/rings/polynomial/:


```
infinite_polynomial_element.py:428:    def is_unit(self):
multi_polynomial_element.py:914:    def is_unit(self):
multi_polynomial_libsingular.pyx:3092:    def is_unit(self):
pbori.pyx:3593:    def is_unit(BooleanPolynomial self):
polynomial_element_generic.py:962:    def is_unit(self):
polynomial_element.pyx:5041:    def is_unit(self):
```


Of these, pbori.pyx, polynomial_element_generic.py and polynomial_element.pyx correctly apply the following fact:

EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a polynomial ring in one variable. Then `f=\sum a_i x^i \in A[x]` is a unit if and only if `a_0` is a unit and `a_1,\ldots, a_n` are nilpotent.

(This fact is also noted in Dummit and Foote, "Abstract Algebra", 1991, Section 7.3 Exercise 33).

infinite_polynomial_element.py, multi_polynomial_element.py, multi_polynomial_libsingular.pyx have incorrect implementations and can give incorrect results:

```
sage: _.<x> = InfinitePolynomialRing(Zmod(4))
sage: p = (1 + 2*x[0])
sage: p*p
1
sage: p.is_unit()
False
sage: p.is_unit.__module__
'sage.rings.polynomial.infinite_polynomial_element'


sage: _.<x,y> = Zmod(4)[]
sage: p = 1+2*x
sage: p*p
1
sage: p.is_unit()
False
sage: type(p)
<type 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular'>
sage: p.is_unit
<built-in method is_unit of sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular object at 0x7fde1d743780>
```




---

Comment by msaaltink created at 2017-02-28 23:38:52

New commits:


---

Comment by msaaltink created at 2017-02-28 23:38:52

Changing status from new to needs_review.


---

Comment by tscrim created at 2017-03-01 15:26:24

For `is_unit` in `multi_polynomial.pyx`, I would do:

```sage
        if not self.constant_coefficient().is_unit():
            return False
        from polydict import ETuple
        cdef dict d = self.dict()
        cdef ETuple zero_key = ETuple([0]*self.parent().ngens())
        if zero_key in d:
            d.pop(zero_key)
        return all(d[k].is_nilpotent() for k in d)
```

for speed.


---

Comment by msaaltink created at 2017-03-01 18:05:22

Good idea.  I ran some timings with a polynomial (that was in fact a unit) over Zmod(125):


```
sage: len(p.coefficients())
249002
sage: %timeit p.is_unit()
1 loop, best of 3: 2.22 s per loop
sage: %timeit p.dict()
1 loop, best of 3: 1.69 s per loop
```


So around 76% of the time is taken to construct the dictionary.  I'll bet the best efficiency gains would be had by avoiding that step, but it would be messy and would repeat code.

With your version of the code, I got about a 2% improvement in runtime:


```
sage: %timeit p.is_unit()
1 loop, best of 3: 2.18 s per loop
```


I tried another small change:

```
        if not self.constant_coefficient().is_unit():
            return False
        cdef dict d = self.dict()
        cdef ETuple zero_key = ETuple([0]*self.parent().ngens())
        d.pop(zero_key, None)
        return all(d[k].is_nilpotent() for k in d)
```

This gives about a 6% speed improvement:

```
sage: %timeit p.is_unit()
1 loop, best of 3: 2.09 s per loop
```

I'll look for anything else I can do for efficiency, then push the changes.


---

Comment by tscrim created at 2017-03-01 18:16:27

You probably would need to write a helper method `_nonconstant_coeff_iter` that would likely be implementation dependent, but uses the underlying structure of the polynomial; i.e., compare the `dict` methods of an element of `ZZ['z']['x,y']` and `QQ['x,y']`. Although this might be a bit overkill for this ticket. Here, you can get some (micro)speed by

```
sage: from sage.rings.polynomial.polydict import ETuple
sage: n = 5
sage: z = int(0)
sage: %timeit [ETuple({}, int(n)) for _ in range(1000)]
1000 loops, best of 3: 724 µs per loop
sage: %timeit [ETuple([z]*n) for _ in range(1000)]
1000 loops, best of 3: 902 µs per loop
sage: n = int(300)
sage: %timeit [ETuple({}, int(n)) for _ in range(1000)]
1000 loops, best of 3: 685 µs per loop
sage: %timeit [ETuple([z]*n) for _ in range(1000)]
100 loops, best of 3: 3.83 ms per loop
```



---

Comment by git created at 2017-03-01 20:17:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-03-07 17:22:59

If you could make the one additional change to use:

```
cdef ETuple zero_key = ETuple({}, int(self.parent().ngens()))
```

then you can set a positive review on my behalf.


---

Comment by git created at 2017-03-07 20:13:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by msaaltink created at 2017-03-07 20:19:55

tscrim: Done.  I looked at ETuple and see that this call goes to a simpler code path.  As you showed above, it is indeed a bit faster.  Thanks for the review.


---

Comment by msaaltink created at 2017-03-07 20:19:55

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-03-10 23:12:42

Resolution: fixed
