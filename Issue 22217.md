# Issue 22217: is_unit can give wrong results in mutlivariate and infinite polynomial rings.

archive/issues_022217.json:
```json
{
    "body": "There are 6 different definitions of `is_unit` for polynomials over commutative rings in sage/rings/polynomial/:\n\n\n```\ninfinite_polynomial_element.py:428:    def is_unit(self):\nmulti_polynomial_element.py:914:    def is_unit(self):\nmulti_polynomial_libsingular.pyx:3092:    def is_unit(self):\npbori.pyx:3593:    def is_unit(BooleanPolynomial self):\npolynomial_element_generic.py:962:    def is_unit(self):\npolynomial_element.pyx:5041:    def is_unit(self):\n```\n\n\nOf these, pbori.pyx, polynomial_element_generic.py and polynomial_element.pyx correctly apply the following fact:\n\nEXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a polynomial ring in one variable. Then `f=\\sum a_i x^i \\in A[x]` is a unit if and only if `a_0` is a unit and `a_1,\\ldots, a_n` are nilpotent.\n\n(This fact is also noted in Dummit and Foote, \"Abstract Algebra\", 1991, Section 7.3 Exercise 33).\n\ninfinite_polynomial_element.py, multi_polynomial_element.py, multi_polynomial_libsingular.pyx have incorrect implementations and can give incorrect results:\n\n```\nsage: _.<x> = InfinitePolynomialRing(Zmod(4))\nsage: p = (1 + 2*x[0])\nsage: p*p\n1\nsage: p.is_unit()\nFalse\nsage: p.is_unit.__module__\n'sage.rings.polynomial.infinite_polynomial_element'\n\n\nsage: _.<x,y> = Zmod(4)[]\nsage: p = 1+2*x\nsage: p*p\n1\nsage: p.is_unit()\nFalse\nsage: type(p)\n<type 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular'>\nsage: p.is_unit\n<built-in method is_unit of sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular object at 0x7fde1d743780>\n```\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/22454\n\n",
    "created_at": "2017-02-26T20:58:07Z",
    "labels": [
        "component: algebra",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.6",
    "title": "is_unit can give wrong results in mutlivariate and infinite polynomial rings.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22217",
    "user": "https://trac.sagemath.org/admin/accounts/users/msaaltink"
}
```
There are 6 different definitions of `is_unit` for polynomials over commutative rings in sage/rings/polynomial/:


```
infinite_polynomial_element.py:428:    def is_unit(self):
multi_polynomial_element.py:914:    def is_unit(self):
multi_polynomial_libsingular.pyx:3092:    def is_unit(self):
pbori.pyx:3593:    def is_unit(BooleanPolynomial self):
polynomial_element_generic.py:962:    def is_unit(self):
polynomial_element.pyx:5041:    def is_unit(self):
```


Of these, pbori.pyx, polynomial_element_generic.py and polynomial_element.pyx correctly apply the following fact:

EXERCISE (Atiyah-McDonald, Ch 1): Let `A[x]` be a polynomial ring in one variable. Then `f=\sum a_i x^i \in A[x]` is a unit if and only if `a_0` is a unit and `a_1,\ldots, a_n` are nilpotent.

(This fact is also noted in Dummit and Foote, "Abstract Algebra", 1991, Section 7.3 Exercise 33).

infinite_polynomial_element.py, multi_polynomial_element.py, multi_polynomial_libsingular.pyx have incorrect implementations and can give incorrect results:

```
sage: _.<x> = InfinitePolynomialRing(Zmod(4))
sage: p = (1 + 2*x[0])
sage: p*p
1
sage: p.is_unit()
False
sage: p.is_unit.__module__
'sage.rings.polynomial.infinite_polynomial_element'


sage: _.<x,y> = Zmod(4)[]
sage: p = 1+2*x
sage: p*p
1
sage: p.is_unit()
False
sage: type(p)
<type 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular'>
sage: p.is_unit
<built-in method is_unit of sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular object at 0x7fde1d743780>
```



Issue created by migration from https://trac.sagemath.org/ticket/22454





---

archive/issue_comments_308424.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-02-28T23:38:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308424",
    "user": "https://trac.sagemath.org/admin/accounts/users/msaaltink"
}
```

New commits:



---

archive/issue_comments_308425.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-02-28T23:38:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308425",
    "user": "https://trac.sagemath.org/admin/accounts/users/msaaltink"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_308426.json:
```json
{
    "body": "For `is_unit` in `multi_polynomial.pyx`, I would do:\n\n```sage\n        if not self.constant_coefficient().is_unit():\n            return False\n        from polydict import ETuple\n        cdef dict d = self.dict()\n        cdef ETuple zero_key = ETuple([0]*self.parent().ngens())\n        if zero_key in d:\n            d.pop(zero_key)\n        return all(d[k].is_nilpotent() for k in d)\n```\n\nfor speed.",
    "created_at": "2017-03-01T15:26:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308426",
    "user": "https://github.com/tscrim"
}
```

For `is_unit` in `multi_polynomial.pyx`, I would do:

```sage
        if not self.constant_coefficient().is_unit():
            return False
        from polydict import ETuple
        cdef dict d = self.dict()
        cdef ETuple zero_key = ETuple([0]*self.parent().ngens())
        if zero_key in d:
            d.pop(zero_key)
        return all(d[k].is_nilpotent() for k in d)
```

for speed.



---

archive/issue_comments_308427.json:
```json
{
    "body": "Good idea.  I ran some timings with a polynomial (that was in fact a unit) over Zmod(125):\n\n\n```\nsage: len(p.coefficients())\n249002\nsage: %timeit p.is_unit()\n1 loop, best of 3: 2.22 s per loop\nsage: %timeit p.dict()\n1 loop, best of 3: 1.69 s per loop\n```\n\n\nSo around 76% of the time is taken to construct the dictionary.  I'll bet the best efficiency gains would be had by avoiding that step, but it would be messy and would repeat code.\n\nWith your version of the code, I got about a 2% improvement in runtime:\n\n\n```\nsage: %timeit p.is_unit()\n1 loop, best of 3: 2.18 s per loop\n```\n\n\nI tried another small change:\n\n```\n        if not self.constant_coefficient().is_unit():\n            return False\n        cdef dict d = self.dict()\n        cdef ETuple zero_key = ETuple([0]*self.parent().ngens())\n        d.pop(zero_key, None)\n        return all(d[k].is_nilpotent() for k in d)\n```\n\nThis gives about a 6% speed improvement:\n\n```\nsage: %timeit p.is_unit()\n1 loop, best of 3: 2.09 s per loop\n```\n\nI'll look for anything else I can do for efficiency, then push the changes.",
    "created_at": "2017-03-01T18:05:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308427",
    "user": "https://trac.sagemath.org/admin/accounts/users/msaaltink"
}
```

Good idea.  I ran some timings with a polynomial (that was in fact a unit) over Zmod(125):


```
sage: len(p.coefficients())
249002
sage: %timeit p.is_unit()
1 loop, best of 3: 2.22 s per loop
sage: %timeit p.dict()
1 loop, best of 3: 1.69 s per loop
```


So around 76% of the time is taken to construct the dictionary.  I'll bet the best efficiency gains would be had by avoiding that step, but it would be messy and would repeat code.

With your version of the code, I got about a 2% improvement in runtime:


```
sage: %timeit p.is_unit()
1 loop, best of 3: 2.18 s per loop
```


I tried another small change:

```
        if not self.constant_coefficient().is_unit():
            return False
        cdef dict d = self.dict()
        cdef ETuple zero_key = ETuple([0]*self.parent().ngens())
        d.pop(zero_key, None)
        return all(d[k].is_nilpotent() for k in d)
```

This gives about a 6% speed improvement:

```
sage: %timeit p.is_unit()
1 loop, best of 3: 2.09 s per loop
```

I'll look for anything else I can do for efficiency, then push the changes.



---

archive/issue_comments_308428.json:
```json
{
    "body": "You probably would need to write a helper method `_nonconstant_coeff_iter` that would likely be implementation dependent, but uses the underlying structure of the polynomial; i.e., compare the `dict` methods of an element of `ZZ['z']['x,y']` and `QQ['x,y']`. Although this might be a bit overkill for this ticket. Here, you can get some (micro)speed by\n\n```\nsage: from sage.rings.polynomial.polydict import ETuple\nsage: n = 5\nsage: z = int(0)\nsage: %timeit [ETuple({}, int(n)) for _ in range(1000)]\n1000 loops, best of 3: 724 \u00b5s per loop\nsage: %timeit [ETuple([z]*n) for _ in range(1000)]\n1000 loops, best of 3: 902 \u00b5s per loop\nsage: n = int(300)\nsage: %timeit [ETuple({}, int(n)) for _ in range(1000)]\n1000 loops, best of 3: 685 \u00b5s per loop\nsage: %timeit [ETuple([z]*n) for _ in range(1000)]\n100 loops, best of 3: 3.83 ms per loop\n```\n",
    "created_at": "2017-03-01T18:16:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308428",
    "user": "https://github.com/tscrim"
}
```

You probably would need to write a helper method `_nonconstant_coeff_iter` that would likely be implementation dependent, but uses the underlying structure of the polynomial; i.e., compare the `dict` methods of an element of `ZZ['z']['x,y']` and `QQ['x,y']`. Although this might be a bit overkill for this ticket. Here, you can get some (micro)speed by

```
sage: from sage.rings.polynomial.polydict import ETuple
sage: n = 5
sage: z = int(0)
sage: %timeit [ETuple({}, int(n)) for _ in range(1000)]
1000 loops, best of 3: 724 µs per loop
sage: %timeit [ETuple([z]*n) for _ in range(1000)]
1000 loops, best of 3: 902 µs per loop
sage: n = int(300)
sage: %timeit [ETuple({}, int(n)) for _ in range(1000)]
1000 loops, best of 3: 685 µs per loop
sage: %timeit [ETuple([z]*n) for _ in range(1000)]
100 loops, best of 3: 3.83 ms per loop
```




---

archive/issue_comments_308429.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-01T20:17:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308429",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_308430.json:
```json
{
    "body": "If you could make the one additional change to use:\n\n```\ncdef ETuple zero_key = ETuple({}, int(self.parent().ngens()))\n```\n\nthen you can set a positive review on my behalf.",
    "created_at": "2017-03-07T17:22:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308430",
    "user": "https://github.com/tscrim"
}
```

If you could make the one additional change to use:

```
cdef ETuple zero_key = ETuple({}, int(self.parent().ngens()))
```

then you can set a positive review on my behalf.



---

archive/issue_comments_308431.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-07T20:13:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308431",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_308432.json:
```json
{
    "body": "tscrim: Done.  I looked at ETuple and see that this call goes to a simpler code path.  As you showed above, it is indeed a bit faster.  Thanks for the review.",
    "created_at": "2017-03-07T20:19:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308432",
    "user": "https://trac.sagemath.org/admin/accounts/users/msaaltink"
}
```

tscrim: Done.  I looked at ETuple and see that this call goes to a simpler code path.  As you showed above, it is indeed a bit faster.  Thanks for the review.



---

archive/issue_comments_308433.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-03-07T20:19:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308433",
    "user": "https://trac.sagemath.org/admin/accounts/users/msaaltink"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_308434.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-03-10T23:12:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22217",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22217#issuecomment-308434",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
