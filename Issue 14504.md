# Issue 14504: Graph constructor forgets vertex labels

Issue created by migration from Trac.

Original creator: vbraun

Original creation time: 2013-06-09 20:53:28

Assignee: jason, ncohen, rlm


```
sage: g = Graph()
sage: g.add_vertex(0)
sage: g.set_vertex(0, 'foo')
sage: g.get_vertices()
{0: 'foo'}
sage: Graph(g).get_vertices()
{0: None}
```

Edge labels are remembered, though:

```
sage: g.add_vertex(1)
sage: g.add_edge(0,1, 'bar')
sage: g.edges()
[(0, 1, 'bar')]
sage: Graph(g).edges()
[(0, 1, 'bar')]
```



---

Comment by vbraun created at 2013-06-10 13:29:42

I'm also totally confused about what `set_vertex()` is supposed to achieve. Vertices are already some object. Then you can associate another object to the vertex object. How is that different to just using a pair `(object1, object2)` as vertex?


---

Comment by vbraun created at 2013-06-10 13:32:38

Somewhat related:

```
sage: g = Graph()
sage: g.set_vertex('foo', 'bar')
sage: g.get_vertices()
{}
```

Ok, I would have expected a ValueError when calling `set_vertex()`. But fine, lets continue...

```
sage: g.add_vertex('foo')
sage: g.get_vertices()
{'foo': 'bar'}
```

wat?


---

Comment by ncohen created at 2013-06-11 12:45:27

I think that these "vertex labels" are meant to associate non-hashable values to a vertex (whose name must be hashable).

I never used it, I also think that it is useless (just use an external dictionary..) and that we would be better without it.

Nathann


---

Comment by @Rithesh17 created at 2019-03-02 18:36:24

I would like to address the issue raised in the comments section.

This is the source code for the _**set_vertex()**_ function for generic graphs


```python
def set_vertex(self, vertex, object):
    if hasattr(self, '_assoc') is False:
        self._assoc = {}

    self._assoc[vertex] = object
```


Since _assoc is a dictionary, even if the vertex isn't added beforehand (as in the example demonstrated in the comments section), the dictionary adds an entry into it. For example,

```python
>>> vert = {}
>>> vert['foo'] = 'bar'
>>> vert
{'foo': 'bar'}
```


But we are adding a new vertex only on the call of the method _**_backend.add_vertex()**_ in the graph. Hence, on calling the method _**get_vertices()**_, 'foo' was not displayed.

But remember that **_alloc** already has the dictionary entry {_foo_: _bar_}. So once the method _**add_vertex('foo')**_ is called, the entry _foo_ is added to the list of vertices in the graph, and so on calling get_vertices, the entry {_foo_: _bar_} is displayed.


---

Comment by @Rithesh17 created at 2019-03-02 18:56:45

The issue in the comments is addressed in [https://trac.sagemath.org/ticket/27399](https://trac.sagemath.org/ticket/27399)


---

Comment by dcoudert created at 2019-03-06 17:46:59

Are you also planning to work on the other issue: copy of vertex labels when calling `Graph(g)` or `DiGraph(g)` ?

If so, there is a minor improvement to do in `get_vertices`: no need to build the list of vertices. So

```diff
-        if verts is None:
-            verts = list(self)
+        if verts is None:
+            verts = self
```



---

Comment by @Rithesh17 created at 2019-03-06 19:21:21

This solution did not work. The problem still persist

```
sage: g.set_vertex(0, 'foo')
sage: g.get_vertices()
{0: 'foo', 1: None, 2: None, 3: None, 4: None}
sage: Graph(g).get_vertices()
{0: None, 1: None, 2: None, 3: None, 4: None}
```

I think the problem is in not communicating the labels of vertices in `g` to `Graph(g)`.

If we look at the `.set_vertex` method, we have

```
self._assoc[vertex] = object
```

which, I believe, is not being transferred to Graph(g). On the other hand, in the `.set_edge_label` method, we have

```
self._backend.set_edge_label(u, v, l, self._directed)
```

I am not yet sure how these two different implementations affect Graph(g), but edge labels are retained in Graph(g) but not vertex labels


---

Comment by @Rithesh17 created at 2019-03-06 19:29:50

And this is one more thing I've found: if `g` has multiple edges and loops, then `Graph(g)` allows loops but not multiple edges. But `Graph(g.edges())` allows both (with a warning to set `multiedges` flag to `True`).


```
sage: g = digraphs.DeBruijn(2,2)
sage: g1 = Graph(g)
sage: g1.edges()
[('00', '00', '0'),
 ('00', '01', '1'),
 ('00', '10', '0'),
 ('01', '10', '0'),
 ('01', '11', '1'),
 ('10', '11', '0'),
 ('11', '11', '1')]
sage: g2 = Graph(g.edges())
sage: g2.edges()
[('00', '00', '0'),
 ('00', '01', '1'),
 ('00', '10', '0'),
 ('01', '10', '0'),
 ('01', '10', '1'),
 ('01', '11', '1'),
 ('10', '11', '0'),
 ('11', '11', '1')]
```



---

Comment by dcoudert created at 2019-03-07 07:50:13

When calling `Graph(g)`, the constructor gives the same settings for loops and multiple edges to the resulting graph than `g`, and here, the digraph `g` has loops but no multiple edges. Hence the returned graph has no multiple edges.

When a list of edges is given as input, we get a deprecation warning and the constructor sets parameter for multiple edges to True if necessary, but this behavior will soon be changed to False unless the user specifies `multiedges=True`.


---

Comment by @Rithesh17 created at 2019-03-07 15:11:28

Oh ok Sir. Anything suggestions on comment 13?


---

Comment by dcoudert created at 2019-03-07 15:29:15

Replying to [comment:15 gh-Rithesh17]:
> Oh ok Sir. Anything suggestions on comment 13?

The current behavior is the right one. So nothing to do for #comment:13.

There is however something to do for #comment:11


---

Comment by @Rithesh17 created at 2019-03-07 15:36:05

Sorry Sir. I meant any suggestion on comment 12.


---

Comment by dcoudert created at 2019-03-08 17:22:52

Check the `Graph` and `DiGraph` constructors.


---

Comment by @Rithesh17 created at 2019-03-09 10:22:44

I went through the `__init__` constructa of both `Graph` and `DiGraph` classes and found this line in both of them:

```python
self.add_vertices(data.vertex_iterator())
self.add_edges(data.edge_iterator())
```

Now in the `vertex_iterator` there is no field for the labels

```sage
sage: g = digraphs.DeBruijn(2,2)
sage: for v in g.vertex_iterator():
....:     print(v)
....:     
11
10
00
01
```

But the labels are displayed in the case of `edge_iterator`

```sage
sage: for v in g.edge_iterator():
....:     print(v)
....:     
('11', '10', '0')
('11', '11', '1')
('10', '00', '0')
('10', '01', '1')
('00', '00', '0')
('00', '01', '1')
('01', '10', '0')
('01', '11', '1')
```

If we need to modify into the `vertex_iterator` method. we must change the back-end code.

```python
def vertex_iterator(self, vertices=None):
    return self._backend.iterator_verts(vertices)
```

I'll have to look into the Pyrex file `basic/c_graph.pyx` to modify `_backend.iterator_verts(vertices)`, but can I do it? I generally would not like to touch the backend files because there could be many more methods using it


---

Comment by dcoudert created at 2019-03-09 10:35:02

Please don't change the backend.

What you must do is simply add `self.set_vertices(data.get_vertices())` at the right place in the `__init__` methods.


---

Comment by @Rithesh17 created at 2019-03-09 11:11:30

Yeah. That's a simpler solution.

I had to also modify `to_undirected` method in DiGraphs and `to_directed` method in Graphs to support vertex labels. And now it is working.


```
sage: g = Graph()
sage: g.add_vertex(0)
sage: g.set_vertex(0, 'foo')
sage: g.get_vertices()
{0: 'foo'}
sage: Graph(g).get_vertices()
{0: 'foo'}
```

Do I need to add a doctest for this?


---

Comment by dcoudert created at 2019-03-09 17:50:22

Yes, you need to add a doctest with a pointer to this ticket, i.e., `:trac:`14708``


---

Comment by @Rithesh17 created at 2019-03-11 05:05:40

New commits:


---

Comment by @Rithesh17 created at 2019-03-11 05:05:40

Changing status from new to needs_review.


---

Comment by dcoudert created at 2019-03-11 08:35:34

Can you change the first example in digraph.py to only `DiGraph`, so

```diff
-            sage: g = Graph()
+            sage: g = DiGraph()
```

Also, add ` (:trac:`14708`)` to each of the added doctests.


---

Comment by git created at 2019-03-11 09:29:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-04-22 10:04:42

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2019-04-22 10:04:42

Just tested it over 8.8.beta3. LGTM.


---

Comment by vbraun created at 2019-04-27 17:44:34

Resolution: fixed
