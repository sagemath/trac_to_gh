# Issue 12883: loss of precision via SR

Issue created by migration from https://trac.sagemath.org/ticket/13055

Original creator: dsm

Original creation time: 2012-05-29 03:27:40

Assignee: burcin

CC:  benjaminjones

Keywords: numerical_approx

By going via SR we can lose precision when using numerical_approx:


```

sage: p
3.1415926535897932384626433832795028841971693993751058209749
sage: parent(p)
Real Field with 200 bits of precision
sage: SR(p)
3.1415926535897932384626433832795028841971693993751058209749
sage: SR(p).n()
3.14159265358979
sage: parent(SR(p).n())
Real Field with 53 bits of precision
```


The information is still there, though (as is obvious from the fact the string produced has all those extra digits):


```
sage: SR(p).pyobject()
3.1415926535897932384626433832795028841971693993751058209749
sage: parent(SR(p).pyobject())
Real Field with 200 bits of precision
```


This might not seem that significant -- we could interpret "n" as always defaulting to 53 bits unless specified otherwise -- but it can cause some headaches when trying to get hold=True to behave nicely. I'd prefer that f(1.2345678901234567890) give the same answer as f(1.2345678901234567890, hold=True).n(), especially now that we typically get the precision from the parent.


---

Comment by dsm created at 2012-05-29 03:43:14

Changing keywords from "numerical_approx" to "numerical_approx, sd40.5".


---

Comment by jdemeyer created at 2014-11-27 19:03:38

I doubt that this is a bug. How would you guess the default precision for the `.n()` method?


---

Comment by jdemeyer created at 2014-11-27 21:15:09

Changing type from defect to enhancement.


---

Comment by jdemeyer created at 2014-11-27 21:15:25

Changing status from new to needs_review.


---

Comment by kcrisman created at 2014-12-04 03:30:24

Hmm, I'm not sure this is wontfix, though.  I'm sympathetic to your argument, but Doug's point that

```
sage: sin(1.2345678901234567890)
0.9440057250452665781
sage: sin(1.2345678901234567890).n()
0.944005725045267
```

seems good; you shouldn't _lose_ precision, should you?  (Forget about hold!)


---

Comment by jdemeyer created at 2014-12-04 07:42:25

Losing precision is a _feature_ of the `.n()` method, that's what it does. The `x.n()` method asks for a _numerical approximation_ of `x` to a precision of 53 bits. This is easily explained. I also like the fact that neither the implementation nor the user should need to worry about what `x` is, the output is a real/complex number with 53 bits of precision.

If you think that `.n()` is wrong, what should `(2/3).n()` return then? The only possible answer which doesn't lose precision is the rational 2/3.


---

Comment by jdemeyer created at 2014-12-04 07:51:57

About `hold=True`, that even doesn't seem to work with real numbers:

```
sage: gamma(1.2345678901234567890, hold=True)
0.9097200568693150729
```



---

Comment by kcrisman created at 2014-12-04 14:23:20

> About `hold=True`, that even doesn't seem to work with real numbers:
Exactly, which is why I didn't use that example.

Okay, I don't have that much invested in this.   But then 

```
sage: x = 1.2340000000000000000000001
sage: x.n?
Docstring:
   Return a numerical approximation of x with at least prec bits of
   precision.

   EXAMPLES:

      sage: (2/3).n()
      0.666666666666667
      sage: pi.n(digits=10)
      3.141592654
      sage: pi.n(prec=20)   # 20 bits
      3.1416

   TESTS:

   Check that http://trac.sagemath.org/14778 is fixed:

      sage: (0).n(algorithm='foo')
      0.000000000000000
```

should really be improved, and possibly the documentation for other versions of `.numerical_approx` as well.  Those are practically stubs!


---

Comment by kcrisman created at 2014-12-04 14:23:20

Changing status from needs_review to needs_work.


---

Comment by kcrisman created at 2014-12-04 14:23:20

Changing priority from major to minor.


---

Comment by rws created at 2014-12-25 09:11:45

Changing component from symbolics to documentation.


---

Comment by jdemeyer created at 2015-03-09 10:43:31

Replying to [comment:14 kcrisman]:
> Okay, I don't have that much invested in this.   But then `x.n?`
> should really be improved, and possibly the documentation for other versions of `.numerical_approx` as well.  Those are practically stubs!

This is actually a general problem we have with Sage documentation: often one has similar functions/methods which all do the same thing (on different kinds of objects). In this case, the `numerical_approx` function in `src/sage/misc/functional.py` is much better documented. What's the optimal solution which doesn't simply replicate the documentation from `numerical_approx()`?


---

Comment by jdemeyer created at 2015-03-09 10:45:01

One other detail which is wrong in the "at least" in "at least prec bits of precision". Certainly for the global `numerical_approx()` function, it's *exactly* `prec` bits.


---

Comment by jdemeyer created at 2016-06-01 10:00:06

Changing keywords from "numerical_approx, sd40.5" to "numerical_approx, sd40.5, days74".


---

Comment by jdemeyer created at 2016-06-01 12:42:33

Changing component from documentation to basic arithmetic.


---

Comment by jdemeyer created at 2016-06-01 14:54:19

New commits:


---

Comment by jdemeyer created at 2016-06-01 14:54:19

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2016-06-02 10:18:23

Most of the changes look good to me, but I don't like the new description of `RealLiteral.numerical_approx()`: as far as I understand “real literals” are exact decimal numbers, so converting one to a `RealField` element with d·log₁₀ 2 bits of precision doesn't really “change its precision” to d decimal digits.

And—just wondering, I have nothing against that choice—is there a reason why you didn't put the generic implementation directly in `Element` (and put code to convert non-Elements to Elements before calling it when necessary)?


---

Comment by jdemeyer created at 2016-06-02 11:40:49

Replying to [comment:24 mmezzarobba]:
> is there a reason why you didn't put the generic implementation directly in `Element` (and put code to convert non-Elements to Elements before calling it when necessary)?

Because of the "put code to convert non-Elements to Elements before calling it" part. I don't know how to do that in general.


---

Comment by jdemeyer created at 2016-08-01 11:42:57

*ping*


---

Comment by git created at 2016-08-02 06:13:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2016-08-04 09:27:35

I still disagree about the docstring of `RealLiteral.numerical_approx()`, but let's not again delay the ticket by two months...


---

Comment by mmezzarobba created at 2016-08-04 09:27:35

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-08-07 20:00:14

Resolution: fixed
