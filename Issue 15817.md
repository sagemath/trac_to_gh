# Issue 15817: Coercion map should depend on the signature of the arguments

Issue created by migration from https://trac.sagemath.org/ticket/16054

Original creator: tscrim

Original creation time: 2014-04-03 18:23:01

Assignee: tscrim

CC:  vbraun nils nbruin simonking

Keywords: coercion, algebras, base ring

The problem is the signature doesn't match the domain, so the incorrect conversion map is being called.

More specifically, I have an algebra (with a basis) where I want to be able to construct elements from the input of `(R, R, R)`. However it errors out because it's trying to apply the natural coercion from the base ring into my algebra.

```python
class Foo(Parent):
    def __init__(self, R):
        Parent.__init__(self, base=R, category=AlgebrasWithBasis(R))
    def _element_constructor_(self, *args):
        return self.element_class(self, *args)
    class Element(Element):   # Remember to import Element in the command line
        def __init__(self, parent, *args):
            Element.__init__(self, parent)
            self.value = args
        def _repr_(self):
            return "bar: {}".format(self.value)
```

So try:

```
sage: F = Foo(ZZ)
sage: F._element_constructor_(1, 2, 3)
bar: (1, 2, 3)
sage: F(1, 2, 3)
...
TypeError: Underlying map <type 'instancemethod'> does not accept additional arguments
```

Really I'm wanting a (conversion) map from `R x R x R` to my algebra.

Note that `F(1)` goes into an infinite loop because I haven't defined a `one()` method, nor multiplication.



---

Comment by nbruin created at 2014-04-03 18:46:22

If you want a conversion map from `R x R x R`, then you should call it with `F( (1, 2, 3) )`. I'd say the problem is that your signature isn't supported out of the box (and I don't think it should). If you want to support more liberal syntax for `F(...)` then you can implement it ad-hoc.


---

Comment by tscrim created at 2014-04-03 19:08:15

Actually I first wanted `R x M` for some other parent `M`. So `F(3, (1,2))` (which is what my repr currently looks like) does not with the same error as above, but this works `F((1, 2), 3)` (because there is no coercion map in the first arg). I can reverse my repr order, but I prefer my current output.
