# Issue 32684: k-recursive sequences with inhomogeneities

Issue created by migration from https://trac.sagemath.org/ticket/32921

Original creator: galipnik

Original creation time: 2021-11-22 02:00:01

CC:  cheuberg dkrenn

Implement k-recursive sequences with inhomogeneities as described in Corollary D of the paper ["Asymptotic Analysis of q-Recursive Sequences"](https://arxiv.org/abs/2105.04334).

See also meta ticket #21202.


---

Comment by git created at 2022-01-11 20:12:55

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2022-01-11 21:24:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-12 15:23:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by galipnik created at 2022-01-13 16:03:39

Changing status from new to needs_review.


---

Comment by cheuberg created at 2022-01-17 07:33:16

Changing status from needs_review to needs_work.


---

Comment by cheuberg created at 2022-01-17 07:33:16

I had a look at this branch and have some comments.

1. line 1042: would `(S - T).is_trivial_zero()` work if #33158 is merged?

2. `from_recurrence`: parameter `inhomogeneities`: please mention default value `{}` in docstring.

3. `RecurrenceParser.parameters`: parameter `inhomogeneities`: I do not think that the last sentence "All inhomogeneities have to be regular sequences from ``self``." is appropriate here. Also mentioning the default seems to be unusual in an output section.

4. `RecurrenceParser.values`: parameter `inhomogeneities`: I do not think that the last sentence "All inhomogeneities have to be regular sequences from ``self``." is appropriate here.

5. `RecurrenceParser.v_eval_n`: In the new code at the end, I am surprised that `n` does not occur in `shifted_inhomogeneities` at all.

6. `RecurrenceParser.v_eval_n`: In the new code at the end, I am not convinced that `upper + 1` is the correct second argument for `srange`: The paper contains an additional `+1` in what translates to `upper` here.

7. `RecurrenceParser.matrix`: Is `minimize=False` a tribute to #33158?

8. `RecurrenceParser.matrix`: Same comment as 6.

9. `RecurrenceParser.matrix`: for the second case, there is twice `rem_d - k` whereas the paper has `rem_d - k^M`

10. `RecurrenceParser.matrix`: setting `1` into the matrix silently assumes that the left vector of the shifted inhomogeneity is `(1, 0, ... ,0)`. This may not be the case (`subsequence` will copy the left vector of the inhomogeneity to the shifted version). So at least we have to check that this assumption holds, at best we would transform the linear representation of the inhomogeneity such that the condition holds. (choose a matrix `T` such that right multiplication of the existing left vector by `T` leads to the desired left vector, replace all matrices by `T^{-1}` times the matrix times `T` and multiply the right vector by `T^{-1}` from the left; all that should probably be a separate method of regular sequences). Alternatively, simply copying the left vector into the correct position might do the job.

11. `RecurrenceParser.matrix`: this code might be rather inefficient: The vector constructed by `subsequence(1, b)` will consist of several shifted versions of the inhomogeneity. So when calling `subsequence(1, b)` for adjacent values of `b`, chances are very high that there will be a noticeable overlap in the vectors constructed, which results in substantial redundancy. The method `subsequence` has provisions for computing several shifts at the same time (for linear combinations). So it would be advantageous to modify `subsequence` to also allow `b` to be a list (not only a scalar or a dictionary); it is currently unclear what the best return value would be in that case. Or one might simply take the existing version of subsequence with some dummy coefficients and throw away the left vector because it will be zero in this application, anyways.

12. Overall, all the parameters of the shifted inhomogeneities are computed thrice: in `v_eval_n`, in `matrix`, in `left` (see comments 6 and 8). This seems to be repetitive, error-prone and inefficient (because `subsequence` is called repeatedly). Therefore, I suggest to factor out these computations to a new method.

13. I have the impression that the code in `RecurrenceParser.matrix` could be somewhat simplified by not computing exact indices for the entries, but by constructing block matrices in a suitable way, see also #21325#comment:29 for a related discussion.

14. `from_recurrence`: in the example where `one` is constructed explicitly for the sum of digits function (currently line 910): I think that https://doc.sagemath.org/html/en/reference/combinat/sage/combinat/recognizable_series.html#sage.combinat.recognizable_series.RecognizableSeriesSpace.one_hadamard would do the job out of the box.


---

Comment by git created at 2022-01-18 16:36:00

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2022-01-19 09:14:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by galipnik created at 2022-01-19 09:14:38

Replying to [comment:7 cheuberg]:
> I had a look at this branch and have some comments.
Thank you very much for your review!
> 2. `from_recurrence`: parameter `inhomogeneities`: please mention default value `{}` in docstring.
Done.
> 3. `RecurrenceParser.parameters`: parameter `inhomogeneities`: I do not think that the last sentence "All inhomogeneities have to be regular sequences from ``self``." is appropriate here. Also mentioning the default seems to be unusual in an output section.
Removed.
> 4. `RecurrenceParser.values`: parameter `inhomogeneities`: I do not think that the last sentence "All inhomogeneities have to be regular sequences from ``self``." is appropriate here.
Removed.
> 5. `RecurrenceParser.v_eval_n`: In the new code at the end, I am surprised that `n` does not occur in `shifted_inhomogeneities` at all.
Fixed.
> 6. `RecurrenceParser.v_eval_n`: In the new code at the end, I am not convinced that `upper + 1` is the correct second argument for `srange`: The paper contains an additional `+1` in what translates to `upper` here.
I am not really convinced by your argument: In the first case in the paper, there is no additional `+1`, which should lead to `upper + 1` here. Am I missing something? (Or have you checked that `upper` cannot be reached in the first case? I have not, but maybe I should...)
> 7. `RecurrenceParser.matrix`: Is `minimize=False` a tribute to #33158?
Yes, removed.
> 8. `RecurrenceParser.matrix`: Same comment as 6.
> 
> 9. `RecurrenceParser.matrix`: for the second case, there is twice `rem_d - k` whereas the paper has `rem_d - k^M`
Fixed.
> 10. `RecurrenceParser.matrix`: setting `1` into the matrix silently assumes that the left vector of the shifted inhomogeneity is `(1, 0, ... ,0)`. This may not be the case (`subsequence` will copy the left vector of the inhomogeneity to the shifted version). So at least we have to check that this assumption holds, at best we would transform the linear representation of the inhomogeneity such that the condition holds. ...
The method `RecognizableSeries.minimized` should guarantee this (by line 1076 in `recognizable_series.py`). So if we use `kRegularSequence.subsequence` with `minimize=True`, we are on the safe side, right? I have included an `assert` to check this now.
> 12. Overall, all the parameters of the shifted inhomogeneities are computed thrice: in `v_eval_n`, in `matrix`, in `left` (see comments 6 and 8). This seems to be repetitive, error-prone and inefficient (because `subsequence` is called repeatedly). Therefore, I suggest to factor out these computations to a new method.
Done. (I am not sure what the best output of the new method is; see after commit 48ebcc4 and before.)
> 14. `from_recurrence`: in the example where `one` is constructed explicitly for the sum of digits function (currently line 910): I think that https://doc.sagemath.org/html/en/reference/combinat/sage/combinat/recognizable_series.html#sage.combinat.recognizable_series.RecognizableSeriesSpace.one_hadamard would do the job out of the box.
Done.

One test still fails, I have to fix this.


---

Comment by git created at 2022-01-19 10:01:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-19 16:02:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-19 18:55:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-21 14:00:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-21 16:40:28

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by cheuberg created at 2022-01-21 20:35:34

I had a look at the changes, thank you very much; and a few rather minor remarks.

1. line 1215: would `(S - T).is_trivial_zero()` work if #33158 is merged?

15. `RecurrenceParser.shifted_inhomogeneities`: output is said to be a list, but is a dictionary

16. `RecurrenceParser.shifted_inhomogeneities`: Typo `inhomogeineities`

17. `RecurrenceParser.shifted_inhomogeneities` should be a cached method

18. `RecognizableSeries.minimized`: In the note box, I would prefer not to refer to the method `.left()` because it might be confusing, but say "the left vector of the result".

19. `left_for_inhomogeneity`: `(wanted[1] == i and wanted[0] == r)` could be written as `wanted == (r, i)`

20. `RecurrenceParser.matrix`: I would probably write

```python
def matrix_row(row):
    wanted = wanted_inhomogeneity(row)
    return left_for_inhomogeneity(wanted)

mat_upper_right = Matrix([matrix_row(row) for row in srange(dim_without_corr)])
mat_inhomog = block_diagonal_matrix([S.mu[rem]
                                     for S in shifted_inhomogeneities.values()])

mat = block_matrix([[mat, mat_upper_right],
                    [zero_matrix(mat_inhomog.nrows(), dim_without_corr),
                     mat_inhomog]])
```


21. `RecurrenceParser.matrix`: In `wanted_inhomogeneity`, the checks `in inhomogeneities.keys()` could be omitted because in `left_for_inhomogeneity`, non-existing inhomogeneities are ignored anyways by the loop construction

22. `RecurrenceParser.matrix`: In `left_for_inhomgeneity`, `inhomogeneities[r]` could be replaced by `inhomogeneity` if `for r in inhomogeneities` was replaced by `for r, inhomogeneity in inhomogeneities.items()`


---

Comment by git created at 2022-01-22 12:32:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by galipnik created at 2022-01-22 12:41:53

Thank you again for the review.

Replying to [comment:16 cheuberg]:
> 1. line 1215: would `(S - T).is_trivial_zero()` work if #33158 is merged?
No.
> 17. `RecurrenceParser.shifted_inhomogeneities` should be a cached method
Really? This is not clear to me since the input contains a `dict`.

Moreover, I think that the name `left_for_inhomogeneity` is not ideal (besides others), but I have not found a better one...

All other review items should be included now.


---

Comment by git created at 2022-01-24 12:34:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2022-01-30 15:44:37

Thank you for your changes.

1. The new sequence avoids this problem, thank you. It seems that the old sequence was invalid because `mu[0] * right` was not equal to `right`. This should be checked (and there is #21343 to do so). It seems that minimization does not perform as advertised in such a case because it yields a minimal linear representation for the recognizable series instead of the regular sequence. In fact, the recognizable series given by the old linear representation had non-zero coefficients for some words with trailing zeros.

15. I think that the docstring should contain a short description on how the dictionary works (what are the keys, what are the values)

17. `RecurrenceParser.shifted_inhomogeneities` does some non-trivial operations (minimization is turned off, but still). Therefore, caching seems to be worthwhile. My understanding (see https://doc.sagemath.org/html/en/reference/misc/sage/misc/cachefunc.html#sage.misc.cachefunc.CachedMethod) is that the key parameter of `cached_method` would be useful, probably as a `lambda` which generates a tuple consisting of those parts of `recurrence_rules` which are actually used, transforming the dictionary `inhomogeneities` to `tuple(rules.inhomogeneities.items())` or so.

    Unfortunately, this induces a dependency on #21319.


---

Comment by git created at 2022-02-01 20:33:55

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by galipnik created at 2022-02-01 20:34:54

Changing status from needs_work to needs_review.


---

Comment by galipnik created at 2022-02-01 20:39:52

Replying to [comment:20 cheuberg]:
> 1. The new sequence avoids this problem, thank you. It seems that the old sequence was invalid because `mu[0] * right` was not equal to `right`. This should be checked (and there is #21343 to do so). It seems that minimization does not perform as advertised in such a case because it yields a minimal linear representation for the recognizable series instead of the regular sequence. In fact, the recognizable series given by the old linear representation had non-zero coefficients for some words with trailing zeros.

For the sake of completeness: More details in https://arxiv.org/abs/2201.13446.
> 
> 15. I think that the docstring should contain a short description on how the dictionary works (what are the keys, what are the values)
Draft in commit 8210a2b0.
> 17. `RecurrenceParser.shifted_inhomogeneities` does some non-trivial operations (minimization is turned off, but still). Therefore, caching seems to be worthwhile. My understanding (see https://doc.sagemath.org/html/en/reference/misc/sage/misc/cachefunc.html#sage.misc.cachefunc.CachedMethod) is that the key parameter of `cached_method` would be useful, probably as a `lambda` which generates a tuple consisting of those parts of `recurrence_rules` which are actually used, transforming the dictionary `inhomogeneities` to `tuple(rules.inhomogeneities.items())` or so.
> 
>     Unfortunately, this induces a dependency on #21319.
Thank you for the hint! Code added in commit 98d2719a, new dependency #21319 merged.


---

Comment by git created at 2022-05-24 14:28:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by galipnik created at 2022-05-24 14:32:49

Dependency merged and conflict in L2829 and L2918/L2919 resolved.


---

Comment by git created at 2022-05-25 08:38:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-30 13:51:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-23 07:35:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-19 07:42:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2022-09-19 07:45:38

15. I think that the sentence in the description of the output is hard to understand, but I have no idea for improvement.

    Therefore I propose to explain it via a doctest, see [e2d8f1d](https://git.sagemath.org/sage.git/commit/?id=e2d8f1d413375197e95038a6b12a891fe35d0fcc).


---

Comment by galipnik created at 2022-09-21 09:58:05

The two new commits LGTM, thank you!


---

Comment by cheuberg created at 2022-09-21 10:50:56

Changing status from needs_review to positive_review.


---

Comment by cheuberg created at 2022-09-21 10:50:56

The build failures detected by the github action seem to be completely unrelated to this branch; the patchbot, on the other hand, is happy.

So, time to set it to positive.


---

Comment by vbraun created at 2022-09-25 16:34:22

Resolution: fixed
