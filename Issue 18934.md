# Issue 18934: Add a method `divides` to Polynomial

Issue created by migration from Trac.

Original creator: bruno

Original creation time: 2015-09-09 09:24:04

Keywords: polynomial, division

The generic method `divides` that can be found in `src/sage/structure/element.pyx` uses `quo_rem` (_via_ `%`) to test if an element divides another one: `return (x % self) == 0`. 

For polynomials, depending on the implementations, the method `quo_rem` may raise an error if the divisor is not monic (see #16649 for more on this).

This ticket aims at implementing a method `divides` for the class `Polynomial`, so that it catches the errors in `quo_rem` to return `False` when it is needed.

**Example of a problematic behavior:**

```python
sage: R.<x> = PolynomialRing(ZZ, implementation="FLINT")
sage: p = 2*x + 1
sage: q = R.random_element(10)
sage: p.divides(q)
False
sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")
sage: p = R(p)
sage: q = R(q)
sage: p.divides(q)
Traceback (most recent call last):
...
ArithmeticError: division not exact in Z[x] (consider coercing to Q[x] first)
```



---

Comment by bruno created at 2015-09-09 11:48:45

Changing status from new to needs_review.


---

Comment by bruno created at 2015-09-09 11:48:45

New commits:


---

Comment by git created at 2016-05-22 16:09:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by bruno created at 2016-05-22 16:12:02

Changing component from basic arithmetic to commutative algebra.


---

Comment by bruno created at 2016-05-22 16:12:02

Changing type from enhancement to defect.


---

Comment by git created at 2016-05-23 09:38:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by bruno created at 2016-05-23 09:41:21

I added some noise with two forced pushes (due to some mistake I made), but there is really only one commit! Now the ticket passes the tests (as far as I can tell) and is very ready for review!


---

Comment by vdelecroix created at 2016-07-11 18:56:19

You would better use `coerce_binop` from `sage.structure.element` rather than a manually handled coercion.

Why is this code specific to polynomials?


---

Comment by vdelecroix created at 2016-07-11 18:56:31

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-07-18 13:21:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by bruno created at 2016-07-18 16:49:31

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2016-07-18 16:49:31

Replying to [comment:9 vdelecroix]:
> You would better use `coerce_binop` from `sage.structure.element` rather than a manually handled coercion.

Done.

> Why is this code specific to polynomials?

I tried to explain the reasons in the description: For polynomials over (say) `ZZ`, the euclidean division is not well defined. The problem occurs when the leading coefficient is not invertible. There are several ways to deal with this problem, and different implementations in Sage use different conventions (see #16649 for pointers on this). As a result, testing divisibility by invoking `self % p == 0` can lead to `ArithmeticError` for polynomials: But when this exception is raised, we know that `self` does not divide `p`.ยน That's why I decided to add this new method which only differs from the generic one by the fact it catches the exception. 

I could have changed the generic method instead to catch an `ArithmeticError` and return `False` in such case, but though I am pretty confident that it makes sense for polynomials, I am much less confident concerning other rings.

ยน "We know" is maybe a too strong assumption. In #16649, I did changes that ensure that the assumption holds for all _current implementations_ of polynomials in Sage. (This was not the case before.) Yet, future implementations may break this rule. This may imply that we shouldn't simply rely on `quo_rem` to test divisibility.


---

Comment by vdelecroix created at 2016-07-25 01:23:37

Since one is always a unit the `if self.is_one(): return True` would better be inside the block `except NotImplementedError:`.

Please add a more exotic example like `GF(4)['x']['y']`.


---

Comment by vdelecroix created at 2016-07-25 01:23:37

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2016-07-25 01:25:10

And why not using `quo_rem` instead of catching a potential `ArithmeticError`?


---

Comment by bruno created at 2016-07-26 07:00:29

I am not sure I fully understand your latest comments:  

> Since one is always a unit the `if self.is_one(): return True` would better be inside the block `except NotImplementedError:`.

Do you mean adding a `try: ... except NotImplementedError:` construction? Because if I add this test say right below the test `if self.is_unit(): return True`, an exception will be raised in the cases where `is_unit` is not implemented but `is_one` is.



> And why not using `quo_rem` instead of catching a potential `ArithmeticError`?

Using `p % self` is really the same as ` p.quo_rem(self)[1] ` so I do not see the difference.


---

Comment by vdelecroix created at 2016-07-26 16:22:17

Replying to [comment:15 bruno]:
> I am not sure I fully understand your latest comments:  
> 
> > Since one is always a unit the `if self.is_one(): return True` would better be inside the block `except NotImplementedError:`.
> 
> Do you mean adding a `try: ... except NotImplementedError:` construction? Because if I add this test say right below the test `if self.is_unit(): return True`, an exception will be raised in the cases where `is_unit` is not implemented but `is_one` is.

I meant

```
try:
    if self.is_unit(): return True   # units divide everything
except NotImplementedError:
    if self.is_one(): return True    # if is_unit is not implemented
```


> 
> > And why not using `quo_rem` instead of catching a potential `ArithmeticError`?
> 
> Using `p % self` is really the same as ` p.quo_rem(self)[1] ` so I do not see the difference.

Not exactly. NTL makes a distinction... and you should actually use `pseudo_quo_rem` when it is there:

```
sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")
sage: p = 2*x + 1
sage: q = R.random_element(10)
sage: p.quo_rem(q)
Traceback (most recent call last):
...
ArithmeticError: division not exact in Z[x] (consider coercing to Q[x] first)
sage: p.pseudo_quo_rem(q)
(0, 2*x + 1)
```



---

Comment by git created at 2016-07-27 09:18:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2016-07-27 09:30:48

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2016-07-27 09:30:48

Replying to [comment:16 vdelecroix]:
> `...`

> I meant

> `...`
Done.

> > 
> > > And why not using `quo_rem` instead of catching a potential `ArithmeticError`?
> > 
> > Using `p % self` is really the same as ` p.quo_rem(self)[1] ` so I do not see the difference.
> 
> Not exactly. NTL makes a distinction... and you should actually use `pseudo_quo_rem` when it is there:
> {{{
> sage: R.<x> = PolynomialRing(ZZ, implementation="NTL")
> sage: p = 2*x + 1
> sage: q = R.random_element(10)
> sage: p.quo_rem(q)
> Traceback (most recent call last):
> ...
> ArithmeticError: division not exact in Z[x] (consider coercing to Q[x] first)
> sage: p.pseudo_quo_rem(q)
> (0, 2*x + 1)
> }}}
Not done: I do not think `pseudo_quo_rem` is applicable, because of the following:

```python
sage: R.<x> = ZZ[] # works the same with NTL
sage: p = x^2 - 1
sage: q = 2*x + 2
sage: p.pseudo_quo_rem(q)
(2*x - 2, 0)
```

So, the remainder in `p.pseudo_quo_rem(q)` can be zero even if `q` does not divide `p`.


P.S.: I won't be able to work on this ticket until mid-august.


---

Comment by saraedum created at 2016-12-16 04:52:18

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-01-19 14:53:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2017-01-19 14:54:44

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-05-21 02:07:22

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2017-05-21 02:07:22

Needs rebasing.


---

Comment by git created at 2017-07-25 13:12:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2017-07-25 13:12:39

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2017-07-27 11:30:51

Hi,

This looks reasonable to me; I would be willing to set the ticket to positive review. Vincent, do you agree?


---

Comment by vdelecroix created at 2017-07-27 13:21:24

why `return (p % self) == 0` instead of `return (p % self).is_zero()`?


---

Comment by vdelecroix created at 2017-07-27 13:22:38

How can you be sure that the following

```
        except ArithmeticError:
            return False                     # if division is not exact
```

only catches non exact divisions?


---

Comment by vdelecroix created at 2017-07-27 13:23:47

Could you add check on more exotic rings like `Zmod(6)['x']`, `ZZ['x']['y']`, `GF(2)['x,y']['z']`?


---

Comment by vdelecroix created at 2017-07-27 13:24:32

Replying to [comment:27 vdelecroix]:
> How can you be sure that the following
> {{{
>         except ArithmeticError:
>             return False                     # if division is not exact
> }}}
> only catches non exact divisions?

BTW, each except will cost a non trivial amount of time. Isn't there a fastest way to see if the division is exact? (eg calling `quo_rem`)


---

Comment by vdelecroix created at 2017-07-27 13:24:42

Changing status from needs_review to needs_info.


---

Comment by mmezzarobba created at 2017-07-27 13:52:50

FWIW, I agree that using `is_zero()` would be better, but I don't think it matters enough for blocking the ticket.
Considering that an `ArithmeticError` implies that there is no divisibility looks very reasonable to me, though testing divisibility of the leading coefficients would likely be faster.


---

Comment by git created at 2017-11-23 15:15:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2017-11-23 15:43:08

Changing status from needs_info to needs_work.


---

Comment by bruno created at 2017-11-23 15:43:08

I've pushed my branch but some doctest fails. Actually I need some advice.

* The `try... except ArithmeticError` is needed for `PolynomialRing(ZZ, 'x', implementation = 'NTL')` since in this implementation `quo_rem` raises an exception for non-divisible polynomials, even when the leading coefficients divide each other. See [ticket:16649] for details.

* Contrary to what my (broken) commit message might indicate, I did not add a leading coefficient test that would fasten the computation. The problem comes from the `Zmod(6)['x']` example: In `Zmod(6)`, computing the remainder raise exceptions. (Test for instance `Zmod(6)(1) % Zmod(6)(4)`.)

* As mentioned before, there is still a failing doctest, also due to `Zmod(6)['x']`. We face the same kind problem as before with the 'NTL' implementation of Z[x]: Computing `quo_rem` in `Zmod(6)['x']` is only possible if the leading coefficient of the divisor is a unit (an exception is raised otherwise). The exception is not caught since contrary to the case of `ZZ['x']`, the raised exception is a `ValueError`.

I am not sure to see what the best solutions are to make it work. Some possibilities:

* We make this ticket depend on another one that unifies all the `quo_rem` implementations for polynomials over non-field, so that we can base this function on the common behavior of these methods.ยน
* We make this ticket depend on another one with more limited goals, such as unifying the errors to `ArithmeticError`.
* We add some specific code, to catch the `ValueError`.

What do you think? 

The first solution seem to me unreachable given the endless discussions about the behavior of `quo_rem` (links in [ticket:16649]). The second one is maybe more doable. The third one is probably the faster to close this ticket but I am not sure whether there is a good way to implement it.

ยน More generally, there should exist a ticket for unifying the diverse behaviors of polynomial rings, but 1. it is clearly off-topic this ticket and 2. given the difficulty with unifying "content" in another ticket, I am not at all ready to go for this!


---

Comment by vdelecroix created at 2018-05-01 15:35:58

An `ArithmeticError` in `%` does not imply not divisible as shown with

```
sage: R.<x> = Zmod(6)[]
sage: S.<z> = R[]
sage: p = x*z + 1
sage: q = z + 1
sage: (p*q) % p
Traceback (most recent call last):
...
ArithmeticError: Division non exact (consider coercing to polynomials over the fraction field)
```

The reason being that

```
sage: Z6 = Zmod(6)
sage: a = Z6(4)
sage: b = Z6(2)
sage: b.divides(a)
True
sage: a / b
Traceback (most recent call last):
...
ZeroDivisionError: Inverse does not exist.
```

From there three possibilities:
- "fix" divisions in integer mod ring `Zmod` so that `a / b` above does work. Though in
  this situation there are several possible answers as `4 = 2 x 5 = 2 x 2 mod 6`.
- restrict `divides` on polynomial whose base rings are integral domains (so that division
  is well defined: quotient is unique when it exists).


---

Comment by vdelecroix created at 2018-05-12 19:36:33

A fix is provided in #25277 for Zmod ring.


---

Comment by bruno created at 2018-06-12 16:02:16

The difficulties with rings such as `Zmod(6)` let me think that we should indeed restrict to polynomials over integral domains. The problem being that I actually do not know for instance how to test divisibility over `Zmod(6)`. 

If we decide this, the problem with `PolynomialRing(ZZ, 'x', implementation="NTL")` remains since `quo_rem` cannot be used there without catching an exception, which is not very appealing... Should we convert first the polynomial to polynomials over the fraction field of the base ring?


---

Comment by vdelecroix created at 2018-06-16 17:31:16

Replying to [comment:37 bruno]:
> The difficulties with rings such as `Zmod(6)` let me think that we should indeed restrict to polynomials over integral domains. The problem being that I actually do not know for instance how to test divisibility over `Zmod(6)`. 

There is #25277 for that (it is merged in beta3 already). So you can test for division... but you can not divide yet.

> If we decide this, the problem with `PolynomialRing(ZZ, 'x', implementation="NTL")` remains since `quo_rem` cannot be used there without catching an exception, which is not very appealing... Should we convert first the polynomial to polynomials over the fraction field of the base ring?

It is fine to catch an exception, but it should be clear what it means.


---

Comment by bruno created at 2018-06-18 14:42:01

Replying to [comment:38 vdelecroix]:
> Replying to [comment:37 bruno]:
> > The difficulties with rings such as `Zmod(6)` let me think that we should indeed restrict to polynomials over integral domains. The problem being that I actually do not know for instance how to test divisibility over `Zmod(6)`. 
> 
> There is #25277 for that (it is merged in beta3 already). So you can test for division... but you can not divide yet.

I meant testing divisibility of polynomials over `Zmod(6)`. I am not sure that it can be reduced to simply testing divisibility of elements of `Zmod(6)`, I think you need to perform some divisions.


---

Comment by vdelecroix created at 2018-06-18 20:31:15

Replying to [comment:39 bruno]:
> Replying to [comment:38 vdelecroix]:
> > Replying to [comment:37 bruno]:
> > > The difficulties with rings such as `Zmod(6)` let me think that we should indeed restrict to polynomials over integral domains. The problem being that I actually do not know for instance how to test divisibility over `Zmod(6)`. 
> > 
> > There is #25277 for that (it is merged in beta3 already). So you can test for division... but you can not divide yet.
> 
> I meant testing divisibility of polynomials over `Zmod(6)`. I am not sure that it can be reduced to simply testing divisibility of elements of `Zmod(6)`, I think you need to perform some divisions.

A far from efficient method consist in

1. testing divisibility of leading coefficients `b_m | a_n`
2. if yes, test all possible quotients `q` so that `a_n = q b_m`

But for that, you need a method that return all quotients. Hence my remark.


---

Comment by bruno created at 2018-06-19 13:34:32

So do you agree with me that we should better abandon non-integral rings (at least for now)?


---

Comment by vdelecroix created at 2018-06-19 14:48:41

Replying to [comment:41 bruno]:
> So do you agree with me that we should better abandon non-integral rings (at least for now)?

yes


---

Comment by git created at 2018-06-19 15:21:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-19 15:22:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2018-06-19 15:23:16

Is the proposed solution ok for you?


---

Comment by vdelecroix created at 2018-06-19 21:45:57

You are not doing the right thing on non-integral domains. You should test `is_integral_domain` much earlier. With the ticket applied

```
sage: R.<x> = Zmod(6)[]
sage: (2*x +1).divides(3)
False
sage: (2*x + 1) * 3 == 3
True
```

(testing divisibility of leading coefficient is not even valid... I was wrong)

You need a line break after `TESTS::`

It should be documented that this method only works for integral domains. And the examples with Zmod(6) (raising error) should be in the `EXAMPLES` block rather than `TESTS`.


---

Comment by git created at 2018-07-04 14:56:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2018-07-04 15:04:46

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2018-07-04 15:04:46

I've followed your advice, and changed my mind: My idea was to give an answer (for non-integral domains) as long as I am able to do so. The problem with the divisibility of leading coefficients made me adopt the opposite viewpoint: Divisibility is not implemented for non-integral domains, that's it. I am not sure that an implementation which only works in some uninteresting cases would be helpful to anyone!


---

Comment by vdelecroix created at 2018-08-03 19:20:18

update milestone 8.3 -> 8.4


---

Comment by vdelecroix created at 2018-08-23 03:53:38

ok


---

Comment by vdelecroix created at 2018-08-23 03:53:38

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-08-26 09:38:16

Resolution: fixed
