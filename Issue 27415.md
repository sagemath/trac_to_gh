# Issue 27415: parent of plethysm

Issue created by migration from https://trac.sagemath.org/ticket/27652

Original creator: mantepse

Original creation time: 2019-04-12 05:38:52

CC:  zabrocki




---

Comment by mantepse created at 2019-04-12 08:26:44

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2019-04-12 08:26:44

Changing status from new to needs_review.


---

Comment by mantepse created at 2019-04-12 08:26:44

New commits:


---

Comment by mantepse created at 2019-04-12 08:26:44

Changing type from PLEASE CHANGE to defect.


---

Comment by zabrocki created at 2019-04-15 14:31:59

Can you explain why you would do this?  It seems wrong to me.

```
sage: s[2,1](p[1]+1)
s[1] + s[1, 1] + s[2] + s[2, 1]
sage: s[2,1](tensor([p[1],p[1]]))
1/3*p[1, 1, 1] # p[1, 1, 1] - 1/3*p[3] # p[3]
```



---

Comment by mantepse created at 2019-04-15 15:34:58

I have two reasons:

1.) the result of plethysm with a tensor is a tensor.

2.) I have a class that inherits from `CombinatorialFreeModule_Tensor`.  Essentially, it is a parent for tensor products of symmetric functions, with some extra methods.  I want that plethysm with an element from this class works.  It almost does, except that the result is then a tensor product, and not an element from my class.

To elaborate on 2., here is my code.  (The `tensor_constructor` method works around another thing, which I think is a bug.)


```
"""
sage: S = SymmetricFunctions(QQ)
sage: S.inject_shorthands()
sage: t = tensor([s[1,1], h[2]])
sage: P = TwoPositions(S.s(), S.h())
sage: x = P(t)
sage: 2*x
sage: h[2](x)
"""
def from_ch_characters(t):
    P = TwoPositions(*t.parent()._sets)
    return P(t)

class TwoPositionsElement(CombinatorialFreeModule_Tensor.Element):
    pass


from sage.combinat.free_module import CombinatorialFreeModule_Tensor, CartesianProductWithFlattening
class TwoPositions(CombinatorialFreeModule_Tensor):
    def __init__(self, *modules):
        cat = HopfAlgebrasWithBasis(QQ).TensorProducts()
        CombinatorialFreeModule_Tensor.__init__(self,
                                                modules,
                                                category = cat)

    @cached_method
    def tensor_constructor(self, modules):
        assert(module in ModulesWithBasis(self.base_ring()) for module in modules)
        # assert(tensor(modules) == self)
        # a list l such that l[i] is True if modules[i] is readily a tensor product
        is_tensor = [isinstance(module, CombinatorialFreeModule_Tensor) for module in modules]
        # the tensor_constructor, on basis elements
        result = self.monomial * CartesianProductWithFlattening(is_tensor) #.
        # TODO: make this into an element of Hom( A x B, C ) when those will exist
        for i in range(0, len(modules)):
            result = modules[i]._module_morphism(result, position = i, codomain = self)
        return result

    def __repr__(self):
        return "TwoPositions in %s"%(self._sets,)

    Element = TwoPositionsElement
```



---

Comment by zabrocki created at 2019-04-15 15:53:56

A change like this may make yours work but at the expense of breaking other's code.

This change is not consistent with other uses of plethysm.  I don't think that your "1.) the result of plethysm with a tensor is a tensor" is a reason at all because the plethysm of a tensor is already a tensor.  What you are doing is proposing changing the output basis.  The choice of making the basis output of `f(g)` the basis that f is expressed in not arbitrary and should not be changed without fundamental reasons ("it doesn't work with my code" is not fundamental, find another way to make your code work, I am sure that there are a dozen ways of doing that without changing the behavoir of plethysm).

> except that the result is then a tensor product, and not an element from my class.
But then you should cast the output into your class.


---

Comment by mantepse created at 2019-04-15 16:41:47

OK, no problem, although I do not understand your reasons.

Possibly I miscommunicated item 1: what I meant to say is that `f(g)` is more naturally an element of the parent of `g` than of the parent of `f`.  The basis `f` is expressed in cannot possibly be a basis for `g` or `f(g)`, except when `f` and `g` are both symmetric functions (in a single alphabet, so to say).

In other words, the change of basis `plethysm` currently does is much more drastic than what I am proposing.

I agree that item 2 is not a good reason.  However, I do not know an easy workaround.  In particular, I do not know how to cast the output into my class, because `plethysm` is a method of symmetric functions, not of my class.


---

Comment by zabrocki created at 2019-04-15 17:00:22

In my example I showed you that the plethysm of a Schur basis element and a power basis element outputs something in the Schur basis.  That is the default behavior.

> what I meant to say is that `f(g)` is more naturally an element of the parent of `g` than of the parent of `f`.
Maybe sometimes, but not in my uses of plethysm.  I might be able to be convinced, but I would examples and even then I would hesitate to make a change like this because that is not what happens for `f(g)` currently and it is likely to break users' code.

> In particular, I do not know how to cast the output into my class, because plethysm is a method of symmetric functions, not of my class.
I think that what you are proposing is a way to `f(g)` when `g` is not a symmetric function or a tensor of symmetric functions, but instead an element of your new class.  That is, you are proposing adding another case into the computation of `f(g)` : if `g` is of new class then do yet a different computation.  I don't think that this requires you to change the default behavior of the computation of `f(g)` when `g` is a tensor of symmetric functions.


---

Comment by mantepse created at 2019-04-15 18:46:59

> Maybe sometimes, but not in my uses of plethysm.

I agree that other conventions may be more convenient for other uses.  Of course, I know nothing about your uses of plethysm.

In my computations, it happens frequently that the basis of the tensor product is chosen for a reason, and the basis of `f`  in `f(g)` is rather arbitrary.  But this is very likely only by coincidence.

```
sage: s[2](tensor([s(h[2]), s(m[2])]))
s[2, 2] # s[2, 2] - s[2, 2] # s[3, 1] + s[2, 2] # s[4] + s[3, 1] # s[1, 1, 1, 1] - s[3, 1] # s[2, 1, 1] + s[3, 1] # s[2, 2] + s[4] # s[2, 2] - s[4] # s[3, 1] + s[4] # s[4]
sage: s[2](tensor([(h[2]), (m[2])]))
h[2, 2] # m[2, 2] + h[2, 2] # m[4] - h[3, 1] # m[4] + h[4] # m[4]
```


I guess that the only real reason I have to offer is that a basis for the symmetric functions cannot possibly be a basis for a tensor power of symmetric functions.  Since the result is in tensor space, I really have to choose a basis for the tensor space, and taking a power of the basis of `f` seems more arbitrary than taking the basis of `g`.

Concerning the other question: no I do not want to add another case into the computation of `f(g)`, my class for `g` is simply a tensor product of symmetric functions with some more methods.  I guess it might be possible to define an action of symmetric functions on my class, but I don't know how to do that.  I wonder how generic plethysm really is (I think Borger and Wieland studied that).


---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.


---

Comment by mantepse created at 2022-09-19 19:28:36

I am coming back to this ticket, because the current behaviour still seems inconsistent to me.

```
sage: s = SymmetricFunctions(QQ).s()
sage: p = SymmetricFunctions(QQ).p()
sage: S = LazySymmetricFunctions(s)
sage: P = LazySymmetricFunctions(p)
sage: S(s[2,1])(P(p[1,1]))
(1/3*p[1,1,1,1,1,1]-1/3*p[3,3])
sage: s[2,1](p[1,1])
2*s[2, 1, 1, 1, 1] + 3*s[2, 2, 1, 1] + s[2, 2, 2] + 3*s[3, 1, 1, 1] + 6*s[3, 2, 1] + s[3, 3] + 3*s[4, 1, 1] + 3*s[4, 2] + 2*s[5, 1]
```



---

Comment by mantepse created at 2022-09-19 19:29:02

Changing keywords from "" to "conversion".


---

Comment by zabrocki created at 2022-09-20 02:00:01

Hi Martin, Can you explain your example?  Why would one prefer that the basis of `f(g)` should be expressed in the expression of `g` rather than the basis of `f`?

A typical use for plethysm in symmetric functions would be to represent expressions like $s_\lambda[X+1]$ or $s_\lambda[(1-q)X]$ in which case you would want those expressions to be expanded in the Schur basis and not of that where your expression $X+1$ or $(1-q)X$ lies.  For example::


```
sage: SymmetricFunctions(QQ['q'].fraction_field()).inject_shorthands(verbose=False)
sage: X = p[1]
sage: q = s.base_ring().gen()
sage: s[3,2](X+1)
s[2] + s[2, 1] + s[2, 2] + s[3] + s[3, 1] + s[3, 2]
sage: s[2,1]((1-q)*X)
(q^2-q)*s[1, 1, 1] + (-q^3+2*q^2-2*q+1)*s[2, 1] + (q^2-q)*s[3]
```


I would agree that a case *could* be made that the parent should be chosen from the inner symmetric function rather than the outer.  The problem is that a lot of code is based on the opposite choice was made from the very beginning.


---

Comment by tscrim created at 2022-09-20 05:35:23

One reason why I think you should use the inner parent, in addition to the example in comment:9, is that it is inconsistent with how polynomial evaluation is handled. Evaluation `ev_Y: R[X] -> S` is a morphism such that the rings `R <= S` (for fixed `Y <= S`). Likewise, as I understand your notes, plethysm is also a morphism of rings for a fixed set of "inputs". I think this is relevant since plethysm is like composition of symmetric functions. This is the motivation for our choice of the lazy symmetric functions.

Can you give some examples where the current choice is necessary (outside of the implementation of `plethysm()`? I feel like this is a bug, as I would expect this to work:

```
sage: s = SymmetricFunctions(QQ).s()
sage: q = ZZ['q'].fraction_field().gen()
sage: p = SymmetricFunctions(q.parent()).p()
sage: s[2,1]((1-q)*p[1])
TypeError: cannot convert nonconstant polynomial
```

Contrast this to what lazy symmetric functions does:

```python
sage: sq = SymmetricFunctions(q.parent()).s()
sage: Sq = LazySymmetricFunctions(sq)
sage: g = (1-q) * P(lambda n: p[1] if n == 1 else p.zero())
sage: g  # We make it an inexact series to not call the symmetric functions code
((-q+1)*p[1]) + O^7
sage: S(s[2,1])(g)
(((-q^3+3*q^2-3*q+1)/3)*p[1,1,1]+((q^3-1)/3)*p[3]) + O^7
sage: Sq(S(s[2,1])(g))
((q^2-q)*s[1,1,1]+(-q^3+2*q^2-2*q+1)*s[2,1]+(q^2-q)*s[3]) + O^7
```



---

Comment by mantepse created at 2022-09-20 10:42:49

Hi Mike!

Thank you for your rapid answer!

My example only shows that plethysm of `SymmetricFunctions` and `LazySymmetricFunctions` behaves differently.

I just realised that this behaviour (using the outer parent) is actually very specific to symmetric functions:

```
sage: s = SymmetricFunctions(QQ).s()
sage: Q.<t> = QQ[]
sage: f = 1 + t + 2*t^2
sage: f(s[1] + s[2] + s[1,1])
s[] + s[1] + 3*s[1, 1] + 4*s[1, 1, 1] + 2*s[1, 1, 1, 1] + 3*s[2] + 8*s[2, 1] + 6*s[2, 1, 1] + 4*s[2, 2] + 4*s[3] + 6*s[3, 1] + 2*s[4]
```

Thus, polynomials of symmetric functions yield symmetric functions.


---

Comment by zabrocki created at 2022-09-21 14:49:08

Where you say "plethysm is also a morphism of rings" might get at the argument for me.  For instance, one can define the plethysm of a symmetric function and a quasi-symmetric function.  The result is a quasi-symmetric function (e.g. `f(G)` where `f` is symmetric and `G` is quasi-symmetric the result is quasi-symmetric).

You've convinced me.  Sorry for being a stickler (but this change will break my code in places).  Its just that up to this point the examples seemed like it was based on the choice and I couldn't see an example where that choice wasn't arbitrary.


---

Comment by tscrim created at 2022-09-22 03:51:44

No problem. It's a fair question as it does seem arbitrary on the face of it, and likewise to request not to break your code. Hopefully to fix it, it is as simple as wrapping the output of the plethysm with the outer basis (which would effectively be a no-op with the current code).

Martin, for the code, do we know that the terms in the sum belong to `parent`? Or have some idea about the parent of the intermediate computations? It should be faster to do `P.linear_combination` and `P.sum` because these use the specific element class and avoid a number of transient elements.


---

Comment by mantepse created at 2022-09-22 07:11:05

Great!

Concerning the code: wouldn't it be better to do the easy change first, and speedup in another ticket?

Hm, I just wanted to show off that the lazy code would be much faster, but it isn't on my branch right now.  What happened?


---

Comment by tscrim created at 2022-09-22 07:16:48

Replying to [comment:26 Martin Rubey]:
> Great!
> 
> Concerning the code: wouldn't it be better to do the easy change first, and speedup in another ticket?

You are already changing the code there anyways. It is simple enough to do if you know which parent you are summing over.

> Hm, I just wanted to show off that the lazy code would be much faster, but it isn't on my branch right now.  What happened?

The current branch here doesn't have the lazy series stuff (it is better that it doesn't IMO). You can create a new branch and merge the two together to test them simultaneously.


---

Comment by mantepse created at 2022-09-22 07:26:20

Travis, I tested it on *my* branch, not on this branch.

```
sage: N=5; f = sum(s(Partitions(n).random_element()) for n in range(N)); g = sum(s(Partitions(n).random_element()) for n in range(1, N)); f1 = L(f) + L(lambda n: 0) ; g1 = L(g) + L(lambda n: 0)
sage: %time r = f(g)
CPU times: user 705 ms, sys: 1 µs, total: 705 ms
Wall time: 705 ms
sage: %time r1 = f1(g1).truncate(f.degree()*g.degree()+1)
CPU times: user 1.09 s, sys: 1 µs, total: 1.09 s
Wall time: 1.09 s
```



---

Comment by tscrim created at 2022-09-22 08:11:05

The branch in this ticket is also your branch. So I thought that was what you were talking.

However, I am not sure what has changed with the lazy plethysm speed. I don't think we changed anything with that...


---

Comment by mantepse created at 2022-09-22 09:28:46

Can we be sure that our plethysm was faster?


---

Comment by tscrim created at 2022-09-22 10:59:14

You had an example of this in ticket:34383#comment5.


---

Comment by mantepse created at 2022-09-22 11:39:48

Wow, great, thank you!

Apparently I misremembered, because there we only compute a single degree of the plethysm, not all of them.

However, `%prun` shows something very strange, which might give us a hint for what we are doing wrong.

```
sage: N=5; f = sum(s(Partitions(n).random_element()) for n in range(N)); g = sum(s(Partitions(n).random_element()) for n in range(1, N)); f1 = L(f) + L(lambda n: 0) ; g1 = L(g) + L(lambda n: 0)

sage: %prun r1 = f1(g1).truncate(f.degree()*g.degree()+1)
         2373194 function calls (2371664 primitive calls) in 1.949 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1173    0.656    0.001    1.519    0.001 {sage.libs.symmetrica.symmetrica.t_POWSYM_SCHUR_symmetrica}
    ...
      719    0.138    0.000    1.893    0.003 {built-in method sage.data_structures.blas_dict.linear_combination}
    ...
     1124    0.002    0.000    0.015    0.000 partition.py:1060(stretch)
    ...

sage: %prun r = f(g)
         1413296 function calls (1409790 primitive calls) in 1.182 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
      512    0.309    0.001    0.797    0.002 {sage.libs.symmetrica.symmetrica.t_POWSYM_SCHUR_symmetrica}
    ...
     26/4    0.091    0.004    1.182    0.295 {built-in method sage.data_structures.blas_dict.linear_combination}
    ...
      220    0.000    0.000    0.003    0.000 partition.py:1060(stretch)
```


For some reason, `t_POWSYM_SCHUR_symmetrica` is called more than twice as often for our algorithm than for the one in `sfa.py`.  I don't see why this should be the case.  Same goes for `stretch`.


---

Comment by tscrim created at 2022-09-22 14:40:33

Indeed, that is interesting. I guess it depends on what things we want to actually compute.

Perhaps we can move this to a new ticket, both to keep the scope of this ticket to symmetric functions, and to not spam other cc-ed people. `;)`.

For this ticket, I rebased it on #34470 (strictly speaking, it should be #34413) as there was a conflict. I made an optimization with how the sums are computed. I also fixed a few things with how scalars are handled, which arose from making the output be in the input parent (or the base ring for scalars; I don't see an easy way to deal with doing pushouts).

Unfortunately I accidentally put my changes into the merge comment. `>_<` So it is hard to see the bulk of them commit-by-commit.

Anyways, if the patchbot comes back again green and you are happy with my changes, then I think we are at a positive review.
----
Last 10 new commits:


---

Comment by mantepse created at 2022-09-22 15:02:29

I agree to moving the performance discussion to a different ticket.  I feel a bit uneasy with merging the lazy stuff into this ticket, but I guess it makes no difference.


---

Comment by tscrim created at 2022-09-22 15:04:04

We have to deal with the conflict somewhere, and better here because #34413 is already positively reviewed.


---

Comment by mantepse created at 2022-09-23 10:02:25

Do you understand these warnings?

```
========== deprecation_number ==========
git checkout patchbot/ticket_merged
+            deprecation(32367, 'the method coefficients now only returns the non-zero coefficients. Use __getitem__ instead.')
+        deprecation(32367, 'the method exponential is deprecated. Use exp instead.')
+        deprecation(32367, "the method compute_coefficients obsolete and has no effect.")
Wrong deprecation number inserted on 3 non-empty lines
deprecation_number -- 0 seconds
========== end deprecation_number ==========
```



---

Comment by tscrim created at 2022-09-23 10:17:49

It comes from the patchbot implementation being simple and not realizing it is coming from a dependency ticket. We can ignore it.


---

Comment by mantepse created at 2022-09-23 10:28:27

Should there be a doctest (and perhaps even specification) demonstrating that the parent is now the parent of the inner function?

Should there maybe even be a warning?  I am somewhat afraid that some people may have private code like

```
sage: s = SymmetricFunctions(QQ).s()
sage: p = SymmetricFunctions(QQ).p()
sage: n = 5; f = p[2,2,1] + p[5]
sage: s[2](f)[Partition([2*n])]
3
```

who might be not amused about not being warned.


---

Comment by tscrim created at 2022-09-23 10:34:28

IMO, this is a bug (such as composing with a tensor product), so no warning/deprecation is necessary. I agree with you that we should add a doctest and documentation indicating this behavior.


---

Comment by git created at 2022-09-23 11:05:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-23 11:06:01

I've added it.


---

Comment by mantepse created at 2022-11-25 08:04:25

ping?
----
New commits:


---

Comment by tscrim created at 2022-11-25 09:06:58

I'm happy. If you are with my added tests, then positive review.


---

Comment by mantepse created at 2022-11-25 10:14:22

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-12-11 11:11:48

Resolution: fixed
