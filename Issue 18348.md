# Issue 18348: Comparison of sparse polynomials

Issue created by migration from https://trac.sagemath.org/ticket/18585

Original creator: bruno

Original creation time: 2015-06-02 13:36:13

Keywords: polynomials

Currently, the default `_cmp_` is written with dense polynomials in mind since it creates an `xrange` of size the degree of the polynomial. For sparse polynomials which can have very high degree, this is a problem:


```python
sage: R.<x> = PolynomialRing(ZZ, sparse=True)
sage: x^2^100 == x^2^100
Traceback (most recent call last)
...
OverflowError: Python int too large to convert to C long
```


The patch introduces a `_cmp_` method in the class `Polynomial_generic_sparse` to get rid of this problem:


```python
sage: R.<x> = PolynomialRing(ZZ, sparse=True)
sage: x^2^100 == x^2^100
True
```


Note, as a side comment, that the comparison is faster for polynomials that are indeed sparse with the new code, while the timings are equivalent for quite dense polynomials.

Without the patch:

```python 
sage: %timeit x^100 == x^100
1000 loops, best of 3: 224 µs per loop
```


With the patch:

```python
sage: %timeit x^100 == x^100
The slowest run took 7.61 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 24.6 µs per loop
```




---

Comment by git created at 2015-06-02 13:38:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-06-02 13:39:12

Changing status from new to needs_review.


---

Comment by bruno created at 2015-06-02 13:39:26

Changing type from PLEASE CHANGE to defect.


---

Comment by bruno created at 2015-06-02 13:57:51

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-06-02 14:18:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-06-02 14:20:03

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2015-06-02 14:20:03

There was a bug in my first commit, for some case I didn't think to test. I hope there is no more bug, and I've tested all possibilities.


---

Comment by vdelecroix created at 2015-06-30 22:23:01

Hello,

1. You can replace

```
keys1 = list(reversed(sorted(d1.keys())))
```

  with

```
keys1 = d1.keys()
keys1.reverse()
```


2. Instead of looking at the length, you can do

```
if not keys1 and not keys2: return 0
if not keys1: return -1
if not keys2: return 1
```


3. Why the first key is treated differently?

Vincent


---

Comment by git created at 2015-07-16 08:50:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-07-16 08:56:39

Replying to [comment:7 vdelecroix]:
> 1. You can replace
> {{{
> keys1 = list(reversed(sorted(d1.keys())))
> }}}
>   with
> {{{
> keys1 = d1.keys()
> keys1.reverse()
> }}}
 
Done, with the added `keys1.sort()` before the `reverse()`.
 
> 2. Instead of looking at the length, you can do
> {{{
> if not keys1 and not keys2: return 0
> if not keys1: return -1
> if not keys2: return 1
> }}}
 
Also done.
  
> 3. Why the first key is treated differently?
 
This is to comply with the default `_cmp_` method for polynomials: for instance `-2x^2 > x` but `x^3 - 2x^2 < x^3 + x`. A larger degree polynomial is always greater than a lower degree polynomial, but then when the coefficients are compared, `0` is greater than a negative coefficient.


I add a question: I noticed after your remark than the method `exponents()` could be improved. This is now implemented as 

```python
        return [c[0] for c in sorted(self.__coeffs.iteritems())] 
```

while it would be faster (from my testing) to replace it by

```python
        keys = self.__coeffs.keys()
        keys.sort()
        return keys
```

Is that right to make the change in this ticket (since it is a rather minor change) or is it more appropriate to open a new one?


---

Comment by vdelecroix created at 2015-08-03 08:07:30

Replying to [comment:9 bruno]:
> Replying to [comment:7 vdelecroix]:
> I add a question: I noticed after your remark than the method `exponents()` could be improved. This is now implemented as 
> {{{#!python
>         return [c[0] for c in sorted(self.__coeffs.iteritems())] 
> }}}
> while it would be faster (from my testing) to replace it by
> {{{#!python
>         keys = self.__coeffs.keys()
>         keys.sort()
>         return keys
> }}}
> Is that right to make the change in this ticket (since it is a rather minor change) or is it more appropriate to open a new one?

That's fine with me.

And could you add a doctest like

```
sage: Rd = PolynomialRing(ZZ, 'x', sparse=False)
sage: Rs = PolynomialRing(ZZ, 'x', sparse=True)
sage: for _ in range(100):
....:     pd = Rd.random_element()
....:     qd = Rd.random_element()
....:     assert cmp(pd,qd) == cmp(Rs(pd), Rs(qd))
```



---

Comment by vdelecroix created at 2015-08-03 08:07:30

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-08-03 16:04:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-08-03 16:04:42

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-08-03 16:12:48

`keys1.sort(); keys1.reverse()` -> `keys1.sort(reverse=True)`


---

Comment by vdelecroix created at 2015-08-03 16:15:17

In

```
            if c > 0:
                c1 = cmp(d1[k1], 0)
                if c1: return c1
```

Isn't `c1` automatically nonzero? Could there be some zero coefficients in the dictionary?


---

Comment by vdelecroix created at 2015-08-03 16:16:40

Instead of comparing with `0` (the Python int zero) it would be better to compare with `self.base_ring().zero()`.


---

Comment by git created at 2015-08-03 16:26:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-08-03 16:29:05

Replying to [comment:14 vdelecroix]:
> In
> {{{
>             if c > 0:
>                 c1 = cmp(d1[k1], 0)
>                 if c1: return c1
> }}}
> Isn't `c1` automatically nonzero? Could there be some zero coefficients in the dictionary?


```
sage: R.<x> = PolynomialRing(ZZ, sparse=True)
sage: p = R({0:1, 1:0, 2:1}, check=False)
sage: p
x^2 + 1
sage: p.dict()
{0: 1, 1: 0, 2: 1}
```

I doubt this happens often in practice, but since this is possible, I am quite reluctant to remove the test.


---

Comment by vdelecroix created at 2015-08-03 16:30:53

Replying to [comment:17 bruno]:
> Replying to [comment:14 vdelecroix]:
> > In
> > {{{
> >             if c > 0:
> >                 c1 = cmp(d1[k1], 0)
> >                 if c1: return c1
> > }}}
> > Isn't `c1` automatically nonzero? Could there be some zero coefficients in the dictionary?
> 
> {{{
> sage: R.<x> = PolynomialRing(ZZ, sparse=True)
> sage: p = R({0:1, 1:0, 2:1}, check=False)
> sage: p
> x^2 + 1
> sage: p.dict()
> {0: 1, 1: 0, 2: 1}
> }}}
> I doubt this happens often in practice, but since this is possible, I am quite reluctant to remove the test.

Dough! I was asking because for sparse matrices it is explicitely mentioned in the specification that no value can be zero. And this is very useful!


---

Comment by vdelecroix created at 2015-08-03 16:31:55

Though, multiplication is nicer

```
sage: (p*p).dict()
{0: 1, 2: 2, 4: 1}
```


What do you think about opening a ticket about enforcing non-zero values in the dictionary?

Vincent


---

Comment by bruno created at 2015-08-03 16:45:26

Replying to [comment:18 vdelecroix]:
>Dough! I was asking because for sparse matrices it is explicitely mentioned in the specification that no value can be zero. And this is very useful!

There is no such specification as for matrices. There is a method `__normalize()` to remove the zero coefficients, used by default in `__init__`, and used for instance in the multiplication (since there may be some cancellations). 

Replying to [comment:19 vdelecroix]:
> Though, multiplication is nicer
> {{{
> sage: (p*p).dict()
> {0: 1, 2: 2, 4: 1}
> }}}
> 
> What do you think about opening a ticket about enforcing non-zero values in the dictionary?

I am in favor of opening a ticket to add this specification, though I am not in favor of removing the `check=False` option that can be useful at some places to get (slightly) faster code.


---

Comment by vdelecroix created at 2015-08-03 16:55:12

Replying to [comment:20 bruno]:
> Replying to [comment:18 vdelecroix]:
> >Dough! I was asking because for sparse matrices it is explicitely mentioned in the specification that no value can be zero. And this is very useful!
> 
> There is no such specification as for matrices. There is a method `__normalize()` to remove the zero coefficients, used by default in `__init__`, and used for instance in the multiplication (since there may be some cancellations). 

`matrix_generic_sparse.pyx`, main docstring line 69-71

```
    A generic sparse matrix is
    represented using a dictionary whose keys are pairs of integers `(i,j)` and
    values in the base ring. The values of the dictionary must never be zero.
```


> Replying to [comment:19 vdelecroix]:
> > Though, multiplication is nicer
> > {{{
> > sage: (p*p).dict()
> > {0: 1, 2: 2, 4: 1}
> > }}}
> > 
> > What do you think about opening a ticket about enforcing non-zero values in the dictionary?
> 
> I am in favor of opening a ticket to add this specification, though I am not in favor of removing the `check=False` option that can be useful at some places to get (slightly) faster code.

I now understand that it only due to `check=False`. In the case `check=True` (which is the default) zeros are removed. So I would assume that there *never* are zero value in the dictionary. One only needs to specify it in the documentation.

You could have a look at the implementation of `degree`. It does not check if the values are zero or not. It just assumes that values are nonzero.

Vincent


---

Comment by bruno created at 2015-08-03 17:01:05

Replying to [comment:21 vdelecroix]:
> Replying to [comment:20 bruno]:
> > Replying to [comment:18 vdelecroix]:
> > >Dough! I was asking because for sparse matrices it is explicitely mentioned in the specification that no value can be zero. And this is very useful!
> > 
> > There is no such specification as for matrices. There is a method `__normalize()` to remove the zero coefficients, used by default in `__init__`, and used for instance in the multiplication (since there may be some cancellations). 
> 
> `matrix_generic_sparse.pyx`, main docstring line 69-71
> {{{
>     A generic sparse matrix is
>     represented using a dictionary whose keys are pairs of integers `(i,j)` and
>     values in the base ring. The values of the dictionary must never be zero.
> }}}
> 
> > Replying to [comment:19 vdelecroix]:
> > > Though, multiplication is nicer
> > > {{{
> > > sage: (p*p).dict()
> > > {0: 1, 2: 2, 4: 1}
> > > }}}
> > > 
> > > What do you think about opening a ticket about enforcing non-zero values in the dictionary?
> > 
> > I am in favor of opening a ticket to add this specification, though I am not in favor of removing the `check=False` option that can be useful at some places to get (slightly) faster code.
> 
> I now understand that it only due to `check=False`. In the case `check=True` (which is the default) zeros are removed. So I would assume that there *never* are zero value in the dictionary. One only needs to specify it in the documentation.

Right. I guess we actually agree (though my previous comment was maybe unclear). 
 
> You could have a look at the implementation of `degree`. It does not check if the values are zero or not. It just assumes that values are nonzero.

True. And this is also the case of `_repr`:

```
sage: R.<x> = PolynomialRing(ZZ, sparse=True)
sage: R({0:1,1:0}, check=False)
 + 1
```


So we actually already assume that coefficients in the dictionary are nonzero. I'll add it in the specifications.


---

Comment by git created at 2015-08-03 17:09:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-08-03 17:19:26

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2015-08-03 17:19:26

Looks good to me.


---

Comment by bruno created at 2015-08-04 08:59:49

Thanks for your comments!


---

Comment by vbraun created at 2015-08-04 22:09:22

Resolution: fixed
