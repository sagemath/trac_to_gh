# Issue 25497: Hall-Littlewood Creation Operator has incorrect behavior for partitions with last entry negative

Issue created by migration from https://trac.sagemath.org/ticket/25734

Original creator: ghseeli

Original creation time: 2018-07-02 01:51:31

CC:  zabrocki tscrim @mareoraft

Keywords: symmetric functions, hall-littlewood vertex operators

I am little out of my depth mathematically here, but it seems to me that the `hl_creation_operator` method for symmetric function elements does the wrong thing when passing in a tuple with the last entry negative. According to the paper referenced in the documentation, [SZ2001], Remark 2 (4), when given a tuple `(\nu_1, \ldots, \nu_k)` with `\nu_k < 0`, one should get `H_\nu^q 1 = 0`. However, this is not the case.


```div style="font-size: 80%"
Code highlighting:
  {{{#!python
sage: s = SymmetricFunctions(QQ['t']).s()
sage: elm = s.one()
sage: elm.hl_creation_operator([-100])
-100*s[]
sage: elm.hl_creation_operator([2,1,-100])
(-100*t^2+t+2)*s[]
  }}}
```


I find this behavior totally bizarre, but it happens because:


```div style="font-size: 80%"
Code highlighting:
  {{{#!python
sage: s = SymmetricFunctions(QQ['t']).s()
sage: s([-100])
-100*s[]
sage: s([2,1,-100])
(-100*t^2+t+2)*s[]
  }}}
```


which is also, in my opinion, a very odd choice, but maybe justified somewhere? However, I cannot find this behavior documented anywhere in the symmetric function documentation. I would write some extra documentation myself, but I do not know where this behavior comes from. Any ideas? Thank you!

Reference:

[SZ2001] M. Shimozono, M. Zabrocki, Hall-Littlewood vertex operators and generalized Kostka polynomials. Adv. Math. 158 (2001), no. 1, 66-85.


---

Comment by tscrim created at 2018-07-02 06:06:59

So the behavior here:

```python
sage: s = SymmetricFunctions(QQ['t']).s()
sage: s([-100])
-100*s[]
sage: s([2,1,-100])
(-100*t^2+t+2)*s[]
```

is natural because `S(foo)` first tries to see if `foo` can be treated as an element of the indexing set (`[2,1,-100]` is not, so that fails) and then as an element as of the base ring (which it can because `QQ['t']([2,1,-100])` returns `-100*t^2 + t + 2`). In other words, this takes the same code path as `s(2)`.

From the doc, it is supposing `nu` is a partition, so technically this is bad input from my perspective. However, I will let Mike comment on what the implementation assumes.


---

Comment by zabrocki created at 2018-07-02 11:33:36

There is a formula which can be used in this case to compute the operator when it has negative parts, but it isn't implemented.  I think that Travis has correctly identified what is happening for this particular output.

What is implemented here is equation (12) from [SZ2001] (arXiv version equation numbers) which has as a hypothesis that all entries are non-negative.  But the actual definition of the operator does work for `{\mathbb Z}^k`.  We could (a) raise an error if `nu` is not a partition (b) document what happens if `nu` is not a partition (c) implement the operator for `nu` when it is not a partition.


---

Comment by @MareoRaft created at 2018-07-02 15:01:37

My two cents:

Having `s([2, 1])` return `s[2, 1]` and `s([1, 2])` return `(2*t+1)*s[]` is inconsistent behavior and can lead to a lot of confusion.

Since `[1, 2] != QQ['t']([1, 2])`, I think it is too much of a stretch to have `s([1, 2]) == s(QQ['t']([1, 2]))`.  A user should need to explicitly cast to the base ring before casting to `s`.

Thirdly -- and somewhat of an aside -- we may want to implement `s(g)` for any composition `g` in the future to be the schur straightening.  (https://mareoraft.github.io/k_combinat_for_sage/all.html#all.straighten)

All things considered, I think the desired behavior for `s([1, 2])` at the moment is (a).  Sage should simply raise an error complaining that it doesn't know how to convert it's input into something reasonable.


---

Comment by ghseeli created at 2018-07-02 16:02:55

I agree with Matt that `s([1,2])` should throw an error, or at the very least, issue a warning. Then, it will be up to the user to decide how to deal with "non-partition" inputs, since there seem to be multiple conventions based on what you are trying to do. (I am thinking of the Jacobi-Trudi identity as an example where this behavior would be bad.)

For the Hall-Littlewood Vertex Operator, I would personally like to see the see option (c), but would settle for option (a) for the time being.


---

Comment by tscrim created at 2018-07-02 16:14:12

Replying to [comment:4 gh-MareoRaft]:
> My two cents:
> 
> Having `s([2, 1])` return `s[2, 1]` and `s([1, 2])` return `(2*t+1)*s[]` is inconsistent behavior and can lead to a lot of confusion.
> 
> Since `[1, 2] != QQ['t']([1, 2])`, I think it is too much of a stretch to have `s([1, 2]) == s(QQ['t']([1, 2]))`.  A user should need to explicitly cast to the base ring before casting to `s`.

Then you will have to go and change polynomial ring constructors. We want `s(2)` to work, even when the input is not coercable into the base ring but convertable.

> Thirdly -- and somewhat of an aside -- we may want to implement `s(g)` for any composition `g` in the future to be the schur straightening.  (https://mareoraft.github.io/k_combinat_for_sage/all.html#all.straighten)

+1

> All things considered, I think the desired behavior for `s([1, 2])` at the moment is (a).  Sage should simply raise an error complaining that it doesn't know how to convert it's input into something reasonable.

Very strong -1. This is completely unnatural unless you do not want conversions to the base ring, fraught with corner cases, impossible to maintain. Also -1 on putting a warning for basically the same reasons.

For instance, what if you are doing Macdonald q,t computations, but have a HL in t. Then this is no longer automatic to construct scalars in the HL basis without an explicit base ring conversion. (You need to convert from `QQ[q,t]` to `QQ[t]`; you cannot coerce.) Most likely this will break a lot of code in the wild.

You should not be constructing scalars by using lists, but it is not the job of the code to police all bad user input (garbage-in, garbage-out), especially when such checks require complicated checks and hacks.


---

Comment by tscrim created at 2018-07-02 16:16:24

BTW, (a), (b), and (c) are unrelated to the `s(foo)`, which is what I was talking about above. For the options above for the `hl_creation_operator`, I also favor (a) and raising a `NotImplementedError` for now, but eventually implementing (c) when `nu` is not a partition.


---

Comment by zabrocki created at 2018-07-03 21:22:30

If there is intention to eventually implement (c), then I don't see why we don't do it.  Its only a change of a few lines.  Here is an implementation of `hl_creation_operator` for all sequences of integers rather than just partitions.

The problem is that it might slow down the calculation a bit because it can't take advantage of Proposition 5 from [SZ2001].  I don't know if it is significant enough to worry about, but we could add an `if nu in Partitions():` then calculate with Proposition 5, `else:` use this more general but slightly slower formula.

For the case of `basis(list_of_integers)` I added a line which raises a `NotImplementedError` when that list is not a partition.
----
New commits:


---

Comment by git created at 2018-07-05 12:09:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2018-07-05 12:12:12

The slow down in the non-partition case is significant hence I am applying two different formulae for computing `hl_creation_operator`.  One where `nu` is a partition and one where `nu` is a sequence of integers.


---

Comment by zabrocki created at 2018-07-05 12:12:12

Changing status from new to needs_review.


---

Comment by tscrim created at 2018-07-05 15:12:44

Remove this change:

```diff
diff --git a/src/sage/combinat/sf/classical.py b/src/sage/combinat/sf/classical.py
index 76d5f21..4809664 100644
--- a/src/sage/combinat/sf/classical.py
+++ b/src/sage/combinat/sf/classical.py
@@ -297,6 +297,8 @@ class SymmetricFunctionAlgebra_classical(sfa.SymmetricFunctionAlgebra_generic):
         # Last shot -- try calling R(x) #
         #################################
         else:
+            if isinstance(x, list) and all(isinstance(a,(int, Integer)) for a in x):
+                raise NotImplementedError
             try:
                 return eclass(self, {_Partitions([]): R(x)})
             except Exception:
```

I do not want such a behavior change, and even still, it does not change the confusion (try `s([1,4/2])`, I bet that will work). What about tuples that can be interpreted as a partitions:

```
sage: (2,1) in Partitions()
True
sage: R.<x> = QQ[]
sage: R((1,2))
2*x + 1
```


This check

```
        if not (isinstance(nu,list) and
                all(isinstance(a,(int,Integer)) for a in nu)):
            raise ValueError("nu must be a list of integers"%(nu))
```

should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input). You should also use the global object `_Partitions` for speed reasons (although it will not be too much).

Trivial, but the `\` are not needed in the `sum` (the open parentheses tell Python to continue checking the next line).

Note that this change:

```diff
-                t = QQ['t'].gen()
+                t = self.parent().base_ring()('t')
```

has the potential to break code in the wild.


---

Comment by zabrocki created at 2018-07-05 16:45:45

Can you clarify
> This check
> [snip]
> should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input).
Should I just remove those lines and force the user to check `basis(list_of_integers)` or did you mean that I should change the `else:` line to handle that check?

> Note that this change:
> {{{#!diff
> -                t = QQ['t'].gen()
> +                t = self.parent().base_ring()('t')
> }}}
> has the potential to break code in the wild.
I think that it was not a good idea to have it do calculations in `QQ['t']` and then have it map into the base ring.  Any time that there is not a map from `QQ['t']` to the base ring or if `QQ['t']` doesn't commute with some of the operations in the symmetric functions, you will get incorrect answers.  Former behavior:

```
sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
sage: s[2].hl_creation_operator([3])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
```

New behavior is that if `t` is not in the base ring than it raises an error and says `TypeError: unable to convert 't' to a ***` and (for example, it is mostly faster to compute in `ZZ['t'].fraction_field()` than `QQ['t'].fraction_field()`):

```
sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
sage: s[2].hl_creation_operator([3])
s[3, 2] + t*s[4, 1] + t^2*s[5]
```



---

Comment by tscrim created at 2018-07-05 16:54:51

Replying to [comment:12 zabrocki]:
> 
> Can you clarify
> > This check
> > [snip]
> > should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input).
> Should I just remove those lines and force the user to check `basis(list_of_integers)` or did you mean that I should change the `else:` line to handle that check?

The latter: change the `else:` to that check.

> > Note that this change:
> > {{{#!diff
> > -                t = QQ['t'].gen()
> > +                t = self.parent().base_ring()('t')
> > }}}
> > has the potential to break code in the wild.
> I think that it was not a good idea to have it do calculations in `QQ['t']` and then have it map into the base ring.  Any time that there is not a map from `QQ['t']` to the base ring or if `QQ['t']` doesn't commute with some of the operations in the symmetric functions, you will get incorrect answers.  Former behavior:
> {{{
> sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
> sage: s[2].hl_creation_operator([3])
> ---------------------------------------------------------------------------
> TypeError                                 Traceback (most recent call last)
> ...
> TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
> }}}
> New behavior is that if `t` is not in the base ring than it raises an error and says `TypeError: unable to convert 't' to a ***` and (for example, it is mostly faster to compute in `ZZ['t'].fraction_field()` than `QQ['t'].fraction_field()`):
> {{{
> sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
> sage: s[2].hl_creation_operator([3])
> s[3, 2] + t*s[4, 1] + t^2*s[5]
> }}}

That is a good point. I just wanted to note that this could cause code to break. Could you add this as a doctest?


---

Comment by git created at 2018-07-05 21:12:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-07-05 23:19:37

Thanks. Basically ready for positive review except for a bit of mostly PEP8/bikeshedding:

``s(la)`` -> either ```s(la)``` or ``s_{\lambda}``


```diff
-        r = len(nu)+len(la)
+        r = len(nu) + len(la)
         ga = [a-b for (a,b) in zip(nu+la.to_list(), range(-r,0))]
-        if r==len(set(ga)) and min(ga)>0:
-            m = sum(1 for i in range(len(ga)) for j in range(i,len(ga)) \
-                    if ga[i]<ga[j])
+        if r == len(set(ga)) and min(ga) > 0:
+            m = sum(1 for i in range(len(ga)) for j in range(i, len(ga))
+                    if ga[i] < ga[j])
             ga.sort(reverse=True)
-            return (-1)**m*self([a+b for (a,b) in zip(ga, range(-r,0))])
+            return (-1)**m * self([a+b for (a,b) in zip(ga, range(-r,0))])
         return self.zero()
```



```diff
         if nu in _Partitions:
             self = s(self)
             return P(self*s(nu) +
                      s.sum( s.sum_of_terms( (lam,c) for lam, c in s(mu)*s(nu) if len(lam) <= len(nu) ) *
                             self.skew_by(s(mu).plethysm((t-1)*s([1])))
                             for d in range(self.degree())
-                            for mu in Partitions(d+1, max_length=len(nu)) ) )
-        elif isinstance(nu,list) and all(isinstance(a,(int,Integer)) for a in nu):
-            return P(s.sum(t**la.size()*c*d*s(la)*
+                            for mu in Partitions(d+1, max_length=len(nu)) ))
+        elif isinstance(nu, list) and all(isinstance(a, (int,Integer)) for a in nu):
+            return P(s.sum(t**la.size() * c * d * s(la) *
                      s._repeated_bernstein_creation_operator_on_basis(ga, nu)
                      for ((la,mu),c) in s(self).coproduct()
-                     for (ga, d) in s(mu).plethysm((1-t)*s[1]) ) )
+                     for (ga, d) in s(mu).plethysm((1-t)*s[1]) ))
```


I know you didn't write the test, but if you could break the one very long doctest output for `s([3,2]).hl_creation_operator([2,1,1])`, I would appreciate it.


---

Comment by git created at 2018-07-05 23:30:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-07-05 23:33:29

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2018-07-05 23:33:29

Thank you.


---

Comment by zabrocki created at 2018-07-05 23:34:09

Thank you for the review!


---

Comment by vbraun created at 2018-08-29 22:27:35

Resolution: fixed
