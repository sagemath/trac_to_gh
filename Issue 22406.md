# Issue 22406: build with clang: fplll symbol not found errors

Issue created by migration from https://trac.sagemath.org/ticket/22643

Original creator: mkoeppe

Original creation time: 2017-03-19 01:10:44

CC:  fbissey dimpase malb

As mentioned in #12426 comment 106, there are symbol lookup errors when fpylll accesses fplll.


---

Comment by jdemeyer created at 2017-03-19 15:43:52

Replying to [ticket:22643 mkoeppe]:
> As mentioned in #12426 comment 106

It would be nice if the ticket description would be self-contained.


---

Comment by fbissey created at 2017-03-20 22:23:50

My current investigation shows that the missing symbols is in libfplll.dylib but it is a local symbol ("t") not a global one and as such it is not seen by objects linking to libfplll.dylib. I am not sure why it is the case but is likely because it was produced with a template.


---

Comment by fbissey created at 2017-03-20 22:30:11

The method `process_solution` in enumerate.h is declared private. That's why the symbol is local. It probably shouldn't make its way into the sage interface in the first place. And if it is needed in the sage interface it needs to be public. Digging sage's side...


---

Comment by fbissey created at 2017-03-20 22:31:28

Wait not sage's side, fpylll's side.


---

Comment by fbissey created at 2017-03-21 01:54:45

This is typically why I hate C++. So, in fplll, `EnumerationDyn` in `enumerate.h` defines a private method `process_solution`, but it is a derived class from `EnumerationBase` in `enumerate_base.h` which does also have a `process_solution` method but this one is only protected. I think there is a conflict there. But that's one of the point where my head hurts with C++.

Actually the method `process_subsolution` is in the same boat in both files.


---

Comment by fbissey created at 2017-03-21 02:22:23

Well moving in `process_solution` into protected in `EnumerationDyn` didn't change a thing. Don't know enough c++.


---

Comment by malb created at 2017-03-21 09:53:26

I've been bitten by this before and couldn't resolve it then. Have you tried the nuclear option of making everything public? I can also ask our resident C++ expert.


---

Comment by fbissey created at 2017-03-21 09:56:59

Replying to [comment:10 malb]:
> I've been bitten by this before and couldn't resolve it then. Have you tried the nuclear option of making everything public? I can also ask our resident C++ expert.

Only `process_solution` and `process_subsolution` to no effect. I am even sure what is the chain leading to the creation of this symbol in fplll or why fpylll thinks it should have it.


---

Comment by fbissey created at 2017-03-22 01:49:54

Replying to [comment:11 fbissey]:
> Replying to [comment:10 malb]:
> > I've been bitten by this before and couldn't resolve it then. Have you tried the nuclear option of making everything public? I can also ask our resident C++ expert.
> 
> Only `process_solution` and `process_subsolution` to no effect.

I should qualify that. I moved them to public in `enumerate.h` but not the parent ones in `enumerate_base.h`.


---

Comment by dimpase created at 2017-03-22 09:34:37

it's strange that creating fplll with clang works fine, while making a cython extension fails. It might well be a cython bug.
So the 1st step towards debugging this might be to try to trigger this without cython.


---

Comment by jdemeyer created at 2017-03-22 09:38:50

Replying to [comment:13 dimpase]:
> It might well be a cython bug.

Cython only creates a `.cpp` file. This seems like a linking issue, which Cython has nothing to do with.


---

Comment by dimpase created at 2017-03-22 10:35:29

Replying to [comment:14 jdemeyer]:
> Replying to [comment:13 dimpase]:
> > It might well be a cython bug.
> 
> Cython only creates a `.cpp` file. This seems like a linking issue, which Cython has nothing to do with.
it is perfectly possible to create a `.cpp` file that will produce a linking failure.
Given that fplll passes all of its own checks, it seems a bit strange that fpylll fails here.

By the way, I wonder what precisely are options passed to clang that lead to this. 

 * Does it get `-std=c++11`? 
 * Does it get `-stdlib=libc++`?


---

Comment by fbissey created at 2017-03-22 10:47:54

Replying to [comment:15 dimpase]:
> Replying to [comment:14 jdemeyer]:
> > Replying to [comment:13 dimpase]:
> > > It might well be a cython bug.
> > 
> > Cython only creates a `.cpp` file. This seems like a linking issue, which Cython has nothing to do with.
> it is perfectly possible to create a `.cpp` file that will produce a linking failure.
> Given that fplll passes all of its own checks, it seems a bit strange that fpylll fails here.
> 
> By the way, I wonder what precisely are options passed to clang that lead to this. 
> 
>  * Does it get `-std=c++11`? 
>  * Does it get `-stdlib=libc++`?
> 

There may be something to look there. `fplll` is compiled with `-std=c++11` but not `fpylll`. For the second, well it is a recent OS X so implicitly we are using `--stdlib=libc++` since this is the default one - I would have to point to the gnu one for it to be used.


---

Comment by fbissey created at 2017-03-22 10:53:50

Replying to [comment:16 fbissey]:
> 
> There may be something to look there. `fplll` is compiled with `-std=c++11` but not `fpylll`. For the second, well it is a recent OS X so implicitly we are using `--stdlib=libc++` since this is the default one - I would have to point to the gnu one for it to be used.

Nope, adding `-std=c++11` in fpylll didn't help so it is not sufficient.


---

Comment by dimpase created at 2017-03-22 10:57:47

to give you some context, I get 

```
building 'fplll.integer_matrix' extension
gcc -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/usr/local/lib/python2.7/site-packages/cysignals -I/usr/local/include/python2.7 -c build/src/fpylll/fplll/integer_matrix.cpp -o build/temp.macosx-10.4-x86_64-2.7/build/src/fpylll/fplll/integer_matrix.o -std=c++11 -stdlib=libc++
clang: error: invalid deployment target for -stdlib=libc++ (requires OS X 10.7 or later)
```

if I try using non-sage python; I first got that `build/temp.macosx-10.4` and weird C++ errors, and then this after I added explicit
`-stdlib=libc++` in `setup.py`.

So this is some sort of p/cython misconfiguration related to (lack of) c++ support we have seen a lot already.

PS. this particular error is fixed by `export MACOSX_DEPLOYMENT_TARGET=10.12`, and I am able to reproduce the import problem.


---

Comment by dimpase created at 2017-03-22 14:12:17

this is what this mangled symbol stands for:

```
$ c++filt -n _ZN5fplll14EnumerationDynINS_5FP_NRIA1_10dpe_structEEE16process_solutionEd
fplll::EnumerationDyn<fplll::FP_NR<dpe_struct [1]> >::process_solution(double)
```

however `enumeration.so` only has

```
typeinfo for fplll::EnumerationDyn<fplll::FP_NR<dpe_struct [1]> >
  and
typeinfo name for fplll::EnumerationDyn<fplll::FP_NR<dpe_struct [1]> >
```

(I extracted the latter running `nm -gU` on that .so file.)
In comparison, `enumeration.so` built with `gcc`, also has

```
fplll::EnumerationDyn<fplll::FP_NR<dpe_struct [1]> >::~EnumerationDyn()
```


I have no idea why this happens.

-------------

moreover, the same kind of difference can be traced by to `fplll.dynlib`, where the one built with gcc does have
explicit `process_solution` entries, e.g.

```
fplll::EnumerationDyn<fplll::FP_NR<dpe_struct [1]> >::process_solution(double)
```

but the one built with clang does not. So perhaps the problem is already in `fplll.dynlib`, it's just not tested properly.


---

Comment by fbissey created at 2017-03-22 21:00:32

The `-g` option of `nm` only show global symbols. The faulty one is "local", you will find it in the clang version if you don't pass any option to `nm`. What type of symbol is it according to `nm` for gcc on OS X for you?

On linux it is of type "W", according to the man page:

The symbol is a weak symbol that has not been specifically tagged as a weak object symbol. When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error. When a weak undefined symbol is linked and the symbol is not defined, the value of the symbol is determined in a system-specific manner without error. On some systems, uppercase indicates that a default value has been specified.


---

Comment by dimpase created at 2017-03-22 22:17:26

Replying to [comment:20 fbissey]:
> The `-g` option of `nm` only show global symbols. The faulty one is "local", you will find it in the clang version if you don't pass any option to `nm`. What type of symbol is it according to `nm` for gcc on OS X for you?
> 
running `nm` without options, I see that `gcc` makes them type 'T', whereas `clang` makes them type 't'. I.e. `gcc` makes them externally exposed, whereas `clang` does not (`t` stands for non-external section symbol, and `T` stands for external section symbol).
In fact, `clang` is totally correct there - private class members must not be exposed.

It seems that the design only works on `gcc` due to a bug there :-)

Also, it appears that `fplll` does not supply any tests for this "enumeration" functionality. I'm trying to write one now, so that it can be seen purely on C++ level.


---

Comment by isuruf created at 2017-03-23 11:28:48

Need this patch to build with clang on OSX https://github.com/fplll/fplll/commit/f372182bbe0f0597e7d6e39f8d23f18a21d1d500

Here's the backported patch for 5.0.3 https://github.com/conda-forge/fplll-feedstock/blob/master/recipe/enumeration-link-error.patch


---

Comment by malb created at 2017-03-23 11:36:43

Doh! Sage's fplll is not current! Thanks!


---

Comment by dimpase created at 2017-03-23 12:58:40

Replying to [comment:23 malb]:
> Doh! Sage's fplll is not current! Thanks!

with the current fplll master branch, I get the following error in building fpylll with clang:

```
building 'fplll.bkz_param' extension
gcc -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/usr/local/lib/python2.7/site-packages/cysignals -I/usr/local/include/python2.7 -c build/src/fpylll/fplll/bkz_param.cpp -o build/temp.macosx-10.4-x86_64-2.7/build/src/fpylll/fplll/bkz_param.o -std=c++11 -stdlib=libc++
build/src/fpylll/fplll/bkz_param.cpp:2084:44: error: no member named 'probability' in 'fplll::Pruning'
  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_p.probability); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 65, __pyx_L1_error)
                                 ~~~~~~~~~ ^
build/src/fpylll/fplll/bkz_param.cpp:2185:16: error: no member named 'probability' in 'fplll::Pruning'
  __pyx_v_self.probability = __pyx_t_1;
  ~~~~~~~~~~~~ ^
2 errors generated.
error: command 'gcc' failed with exit status 1

$ gcc -v
Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1
Apple LLVM version 8.0.0 (clang-800.0.42.1)
Target: x86_64-apple-darwin16.4.0
Thread model: posix
InstalledDir: /Volumes/Sage/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
```



---

Comment by dimpase created at 2017-03-23 13:15:43

Replying to [comment:24 dimpase]:
> Replying to [comment:23 malb]:
> > Doh! Sage's fplll is not current! Thanks!
> 
> with the current fplll master branch, I get the following error in building fpylll with clang:
>  
oh, fpylll isn't up do date in Sage, either. With the git master version of fpylll, everything works.
Martin, time for new fp(y)lll Sage packages?


---

Comment by isuruf created at 2017-03-23 13:26:02

fpylll 0.2.3dev with fplll 5.0.3 + patch I mentioned works on OSX with clang.

It's great to have new releases though.


---

Comment by malb created at 2017-03-23 13:45:11

Agreed, I'll get on that.


---

Comment by malb created at 2017-03-23 13:45:11

Set assignee to malb.


---

Comment by malb created at 2017-03-26 18:26:26

Changing status from new to needs_review.


---

Comment by malb created at 2017-03-26 18:26:26

New commits:


---

Comment by fbissey created at 2017-03-26 22:47:21

Changing status from needs_review to positive_review.


---

Comment by fbissey created at 2017-03-26 22:47:21

Works for me, solve the problem at hand fully.


---

Comment by dimpase created at 2017-03-27 14:30:26

works on FreeBSD 11.0 with clang (libc++) / gfortran (sic!, cf.  #22679) too.


---

Comment by vbraun created at 2017-04-03 21:00:05

Resolution: fixed
