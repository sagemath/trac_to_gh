# Issue 17855: evaluating symbolic expressions (without conversion to SR, i.e., staying in ring of values)

Issue created by migration from Trac.

Original creator: dkrenn

Original creation time: 2015-03-31 12:06:24

CC:  cheuberg mmezzarobba

`subs` of a symbolic expression converts its values to the symbolic ring before performing the actual substitution. This ticket proposes a new method `evaluate` which comes over this.

```
sage: E = (1+x).evaluate(x=RIF(3.42))
sage: E
4.4200000000000000?
sage: E.parent()
Real Interval Field with 53 bits of precision
```



---

Comment by dkrenn created at 2015-03-31 12:16:36

Changing status from new to needs_review.


---

Comment by dkrenn created at 2015-03-31 12:16:36

New commits:


---

Comment by rws created at 2015-03-31 12:52:40


```
+        The reason is that :meth:`subs` convert its arguments to the
+        symbolic ring, so we even have::
+
+            sage: x.subs(x=RIF(3.42)).parent()
+            Symbolic Ring
+
+        The :meth:`evaluate`-method prevents this conversion and
```

I think you misunderstand. `x` is not converted, it is wrapped in an expression:

```
sage: x.subs(x=RIF(3.42)).pyobject().parent()
Real Interval Field with 53 bits of precision
```

I have no idea if your idea is worth the effort, but suspect that not if it is only based on the necessity to prevent "conversion".


---

Comment by dkrenn created at 2015-03-31 13:07:47

Replying to [comment:4 rws]:
> I think you misunderstand. `x` is not converted, it is wrapped in an expression:

Ok, I used the wrong word; however, this example was to point out the differences between the two commands.

> {{{
> sage: x.subs(x=RIF(3.42)).pyobject().parent()
> Real Interval Field with 53 bits of precision
> }}}
> I have no idea if your idea is worth the effort, but suspect that not if it is only based on the necessity to prevent "conversion".

`subs` is not possible with something that does go into the symbolic ring, like power series:

```
sage: P.<p> = ZZ[[]]
sage: x.subs(x=p)
Traceback (most recent call last):
...
TypeError: no canonical coercion from Power Series Ring in p over Integer Ring to Symbolic Ring

sage: E = x.evaluate(x=p)
sage: E, E.parent()
p, Power Series Ring in p over Integer Ring)
```



---

Comment by dkrenn created at 2015-03-31 13:08:39

Changing keywords from "" to "sd66".


---

Comment by rws created at 2015-03-31 13:15:21

I thought everything coerces to `SR`? Maybe this is just a coercion bug?


---

Comment by dkrenn created at 2015-03-31 14:00:37

Replying to [comment:7 rws]:
> I thought everything coerces to `SR`? Maybe this is just a coercion bug?

IMHO, not everything coerces into `SR` and this for a good reason. But this is not (or should not) under discussion here.

The following is not possible at with subs:
{{{ 
sage: sage: P.<p> = ZZ[[]]
sage: var('a,b')
(a, b)
sage: (a+b).subs({a: p, b: p^2})
}}}
`evaluate` can do.


---

Comment by vdelecroix created at 2015-03-31 14:24:11

Changing status from needs_review to needs_info.


---

Comment by vdelecroix created at 2015-03-31 14:24:11

Hello,

Why not

```
sage: E = (1+x).subs(x=RIF(3.42))
sage: E.parent()
sage: F = E.pyobject()
sage: F
4.4200000000000000?
sage: F.parent()
Real Interval Field with 53 bits of precision
```


Vincent


---

Comment by git created at 2015-03-31 15:08:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-03-31 15:08:55

added a doctest and corrected a small bug


---

Comment by dkrenn created at 2015-03-31 15:27:16

Replying to [comment:10 vdelecroix]:
> Why not
> {{{
> sage: E = (1+x).subs(x=RIF(3.42))
> sage: E.parent()
> sage: F = E.pyobject()
> sage: F
> 4.4200000000000000?
> sage: F.parent()
> Real Interval Field with 53 bits of precision
> }}}

Ok, I see. Maybe RIFs are not a good example since they coerce into SR. Power series are better" example; since there problems.

I'll rewrite the description of the ticket and the examples.


---

Comment by nbruin created at 2015-03-31 15:39:14

The general idea is that the result of arithmetic only depends on the parents of the input data, not on the values of the input data (because the idea is that these things implement maps, which have domains and codomains). When you evaluate a SR element at a non-symbolic value, you don't know if the result can live in the parent of the original result (e.g., `(sin(x)+y).subs(y=1)`).

The appropriate solution is probably to first *convert* your symbolic expression to a parent where the parent is the desired thing, e.g.

```
sage: f = SR(1+x)
sage: R.<t>= ZZ[[]]
sage: P=R['x']
sage: P(f)(x=t^2+O(t^3))
```

This also has other advantages: in principle, when you do this with RIF, you might end up with an evaluation routine that takes into account that the coefficients are not exact and hence it could choose some more stable way of doing the evaluation (I think that's hypothetical--likely no such effort is made right now, but it could).


---

Comment by git created at 2015-03-31 15:40:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-03-31 15:41:09

rewritten documentation of function


---

Comment by dkrenn created at 2015-03-31 15:45:51

Replying to [comment:14 nbruin]:
> The general idea is that the result of arithmetic only depends on the parents of the input data, not on the values of the input data (because the idea is that these things implement maps, which have domains and codomains). When you evaluate a SR element at a non-symbolic value, you don't know if the result can live in the parent of the original result (e.g., `(sin(x)+y).subs(y=1)`).

True.

> The appropriate solution is probably to first *convert* your symbolic expression to a parent where the parent is the desired thing, e.g.
> {{{
> sage: f = SR(1+x)
> sage: R.<t>= ZZ[[]]
> sage: P=R['x']
> sage: P(f)(x=t<sup>2+O(t</sup>3))
> }}}

What if

```
f = SR(1+2^x)
```

or something worse (including e.g. exp, log, sin, ... or other functions)? There are no parents (except SR) for any of these constructs.


---

Comment by nbruin created at 2015-03-31 16:26:37

Replying to [comment:18 dkrenn]:
> What if
> {{{
> f = SR(1+2^x)
> }}}
> or something worse (including e.g. exp, log, sin, ... or other functions)? There are no parents (except SR) for any of these constructs.
And indeed it's tricky to evaluate the result. What is `2^<power series>`? I guess `exp(log(2)*x)`, which requires a ring that contains both `log(2)` and inverses of all integers., so that doesn't work in `Z[This is the Trac macro *t* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#t-macro)`. I think Sage is right in putting the onus on the user to first find a parent in which the expression fits and where the evaluation behaviour is the desired one.

Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.


---

Comment by dkrenn created at 2015-03-31 19:04:43

Replying to [comment:19 nbruin]:
> Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.

Ok, I'll make some experiments and run some tests to see if it satisfies my needs.

Thanks


---

Comment by vdelecroix created at 2015-04-20 11:08:07

Hello,

Would this ticket solve the following issue (from #9787)?

```
sage: parent(exp(1.2))
Real Field with 53 bits of precision
sage: f(x) = exp(x)
sage: parent(f(1.2))
Symbolic Ring
```


Vincent


---

Comment by dkrenn created at 2015-04-20 11:16:06

Replying to [comment:21 vdelecroix]:
> Hello,
> 
> Would this ticket solve the following issue (from #9787)?
> {{{
> sage: parent(exp(1.2))
> Real Field with 53 bits of precision
> sage: f(x) = exp(x)
> sage: parent(f(1.2))
> Symbolic Ring
> }}}

Yes.

```
sage: f(x).evaluate({x: 1.2}).parent()
Real Field with 53 bits of precision
```



---

Comment by vdelecroix created at 2015-04-20 11:36:32

Replying to [comment:22 dkrenn]:
> Replying to [comment:21 vdelecroix]:
> > Hello,
> > 
> > Would this ticket solve the following issue (from #9787)?
> > {{{
> > sage: parent(exp(1.2))
> > Real Field with 53 bits of precision
> > sage: f(x) = exp(x)
> > sage: parent(f(1.2))
> > Symbolic Ring
> > }}}
> 
> Yes.
> {{{
> sage: f(x).evaluate({x: 1.2}).parent()
> Real Field with 53 bits of precision
> }}}

Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?


---

Comment by dkrenn created at 2015-04-20 11:37:28

Replying to [comment:23 vdelecroix]:
> Replying to [comment:22 dkrenn]:
> > Replying to [comment:21 vdelecroix]:
> > > Would this ticket solve the following issue (from #9787)?
> > > {{{
> > > sage: parent(exp(1.2))
> > > Real Field with 53 bits of precision
> > > sage: f(x) = exp(x)
> > > sage: parent(f(1.2))
> > > Symbolic Ring
> > > }}}
> > [...]
> Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?

No, not modified by this ticket.


---

Comment by vdelecroix created at 2015-04-20 11:45:05

Replying to [comment:24 dkrenn]:
> Replying to [comment:23 vdelecroix]:
> > Replying to [comment:22 dkrenn]:
> > > Replying to [comment:21 vdelecroix]:
> > > > Would this ticket solve the following issue (from #9787)?
> ...
> > Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?
> 
> No, not modified by this ticket.

I saw too late your answer on #9878 ;-)

By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. But

```
sage: f(x) = 2*x
sage: f.subs(x=3)
x |--> 6
```

ie, `f` remains a function. It is hopefully not changed into a number.


---

Comment by dkrenn created at 2015-04-20 12:00:21

Replying to [comment:25 vdelecroix]:
> By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. 

In the following it does the same as subs:

```
sage:  sage: f(x) = 2*x
sage:  sage: f(x).subs(x=3)
6
sage:  sage: f(x).evaluate(x=3)
6
```


> But
> {{{
> sage: f(x) = 2*x
> sage: f.subs(x=3)
> x |--> 6
> }}}
> ie, `f` remains a function. It is hopefully not changed into a number.

Indeed, this changes (I wasn't aware of this up to now):

```
sage:  sage: f.evaluate(x=3)
6
```

This is because `evaluate` uses

```
sage: f.operator()
<built-in function mul>
sage: f.operands()
[x, 2]
```

From this, `f` is equal to `2*x`. Sage sees these two as equal as well:

```
sage: bool(f == 2*x)
True
```



---

Comment by vdelecroix created at 2015-04-20 12:38:50

Replying to [comment:26 dkrenn]:
> Replying to [comment:25 vdelecroix]:
> > By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. 
> 
> From this, `f` is equal to `2*x`. Sage sees these two as equal as well:
> {{{
> sage: bool(f == 2*x)
> True
> }}}

Argh. Definitely a bug to me. Another bug is that the variable defining a function should be transparent. And currently

```
sage: f(x) = 2*x
sage: g(y) = 2*y
sage: bool(f == g)
False
```


Vincent


---

Comment by rws created at 2015-04-20 12:43:26

Please Cc: me with any ticket you open regarding `Expression.nonzero()` or pynac.


---

Comment by dkrenn created at 2015-04-20 12:47:59

Replying to [comment:27 vdelecroix]:

```
sage: f(x) = 2*x
```

> > From this, `f` is equal to `2*x`. Sage sees these two as equal as well:
> > {{{
> > sage: bool(f == 2*x)
> > True
> > }}}
> 
> Argh. Definitely a bug to me. Another bug is that the variable defining a function should be transparent. And currently
> {{{
> sage: f(x) = 2*x
> sage: g(y) = 2*y
> sage: bool(f == g)
> False
> }}}

This is now #18259.


---

Comment by rws created at 2015-06-20 07:36:17

As to the original `subs` error, nbruin has explained why there is no general solution, a workaround for polynomials would be

```
sage: P.<p> = ZZ[[]]
sage: x.power_series(ZZ)
x + O(x^2)
sage: P(_)
p + O(p^2)
```

I believe a more general way to have all possibilities of both `SR` and the series rings is to fix conversions between them, and use a series ring over `SR`. This depends on #17659, please review.


---

Comment by cheuberg created at 2016-02-11 15:27:26

Replying to [comment:19 nbruin]:
> Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.

I had another instance where I needed a version of `.subs` like in this ticket, because there is no coercion from a number field to the symbolic ring.

```
sage: K.<omega> = NumberField(x^4 + 1)
sage: var('u')
sage: z = u/(u + 1)^2
sage: z.subs(u=omega)
Traceback (most recent call last):
...
TypeError: no canonical coercion from Number Field
in omega with defining polynomial x^16 + 1 to
Symbolic Ring
```

Using `fast_callable` works in this case:

```
sage: fast_callable(z, vars=[u])(omega)
1/2*omega^3 - 1/2*omega + 1
```


It works, but the solution is hard to find and the notation a bit cumbersome.

I see several solutions:
1. adding a link to `fast_callable` and some examples from this ticket to the documentation of `subs`.
2. indeed create a method as proposed here which acts as a wrapper for `fast_callable`.

Opinions?


---

Comment by cheuberg created at 2016-02-11 15:29:10

Replying to [comment:30 rws]:
> I believe a more general way to have all possibilities of both `SR` and the series rings is to fix conversions between them, and use a series ring over `SR`. This depends on #17659, please review.

Is it realistic to hope that all conversions will exist? Do they always make sense?


---

Comment by rws created at 2016-02-11 16:04:47

I am now neutral or positive on this ticket. Still,

>Is it realistic to hope that all conversions will exist? Do they always make sense?
I suspect many will and do. You can easily find out by reviewing #16203 and #17402.
