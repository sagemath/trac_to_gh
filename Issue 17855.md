# Issue 17855: evaluating symbolic expressions (without conversion to SR, i.e., staying in ring of values)

archive/issues_017855.json:
```json
{
    "body": "CC:  @cheuberg @mezzarobba\n\n`subs` of a symbolic expression converts its values to the symbolic ring before performing the actual substitution. This ticket proposes a new method `evaluate` which comes over this.\n\n```\nsage: E = (1+x).evaluate(x=RIF(3.42))\nsage: E\n4.4200000000000000?\nsage: E.parent()\nReal Interval Field with 53 bits of precision\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/18092\n\n",
    "created_at": "2015-03-31T12:06:24Z",
    "labels": [
        "component: symbolics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "evaluating symbolic expressions (without conversion to SR, i.e., staying in ring of values)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17855",
    "user": "https://github.com/dkrenn"
}
```
CC:  @cheuberg @mezzarobba

`subs` of a symbolic expression converts its values to the symbolic ring before performing the actual substitution. This ticket proposes a new method `evaluate` which comes over this.

```
sage: E = (1+x).evaluate(x=RIF(3.42))
sage: E
4.4200000000000000?
sage: E.parent()
Real Interval Field with 53 bits of precision
```


Issue created by migration from https://trac.sagemath.org/ticket/18092





---

archive/issue_comments_239145.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-03-31T12:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239145",
    "user": "https://github.com/dkrenn"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_239146.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-03-31T12:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239146",
    "user": "https://github.com/dkrenn"
}
```

New commits:



---

archive/issue_comments_239147.json:
```json
{
    "body": "\n```\n+        The reason is that :meth:`subs` convert its arguments to the\n+        symbolic ring, so we even have::\n+\n+            sage: x.subs(x=RIF(3.42)).parent()\n+            Symbolic Ring\n+\n+        The :meth:`evaluate`-method prevents this conversion and\n```\n\nI think you misunderstand. `x` is not converted, it is wrapped in an expression:\n\n```\nsage: x.subs(x=RIF(3.42)).pyobject().parent()\nReal Interval Field with 53 bits of precision\n```\n\nI have no idea if your idea is worth the effort, but suspect that not if it is only based on the necessity to prevent \"conversion\".",
    "created_at": "2015-03-31T12:52:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239147",
    "user": "https://github.com/rwst"
}
```


```
+        The reason is that :meth:`subs` convert its arguments to the
+        symbolic ring, so we even have::
+
+            sage: x.subs(x=RIF(3.42)).parent()
+            Symbolic Ring
+
+        The :meth:`evaluate`-method prevents this conversion and
```

I think you misunderstand. `x` is not converted, it is wrapped in an expression:

```
sage: x.subs(x=RIF(3.42)).pyobject().parent()
Real Interval Field with 53 bits of precision
```

I have no idea if your idea is worth the effort, but suspect that not if it is only based on the necessity to prevent "conversion".



---

archive/issue_comments_239148.json:
```json
{
    "body": "Replying to [comment:4 rws]:\n> I think you misunderstand. `x` is not converted, it is wrapped in an expression:\n\nOk, I used the wrong word; however, this example was to point out the differences between the two commands.\n\n> {{{\n> sage: x.subs(x=RIF(3.42)).pyobject().parent()\n> Real Interval Field with 53 bits of precision\n> }}}\n> I have no idea if your idea is worth the effort, but suspect that not if it is only based on the necessity to prevent \"conversion\".\n\n`subs` is not possible with something that does go into the symbolic ring, like power series:\n\n```\nsage: P.<p> = ZZ[[]]\nsage: x.subs(x=p)\nTraceback (most recent call last):\n...\nTypeError: no canonical coercion from Power Series Ring in p over Integer Ring to Symbolic Ring\n\nsage: E = x.evaluate(x=p)\nsage: E, E.parent()\np, Power Series Ring in p over Integer Ring)\n```\n",
    "created_at": "2015-03-31T13:07:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239148",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:4 rws]:
> I think you misunderstand. `x` is not converted, it is wrapped in an expression:

Ok, I used the wrong word; however, this example was to point out the differences between the two commands.

> {{{
> sage: x.subs(x=RIF(3.42)).pyobject().parent()
> Real Interval Field with 53 bits of precision
> }}}
> I have no idea if your idea is worth the effort, but suspect that not if it is only based on the necessity to prevent "conversion".

`subs` is not possible with something that does go into the symbolic ring, like power series:

```
sage: P.<p> = ZZ[[]]
sage: x.subs(x=p)
Traceback (most recent call last):
...
TypeError: no canonical coercion from Power Series Ring in p over Integer Ring to Symbolic Ring

sage: E = x.evaluate(x=p)
sage: E, E.parent()
p, Power Series Ring in p over Integer Ring)
```




---

archive/issue_comments_239149.json:
```json
{
    "body": "Changing keywords from \"\" to \"sd66\".",
    "created_at": "2015-03-31T13:08:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239149",
    "user": "https://github.com/dkrenn"
}
```

Changing keywords from "" to "sd66".



---

archive/issue_comments_239150.json:
```json
{
    "body": "I thought everything coerces to `SR`? Maybe this is just a coercion bug?",
    "created_at": "2015-03-31T13:15:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239150",
    "user": "https://github.com/rwst"
}
```

I thought everything coerces to `SR`? Maybe this is just a coercion bug?



---

archive/issue_comments_239151.json:
```json
{
    "body": "Replying to [comment:7 rws]:\n> I thought everything coerces to `SR`? Maybe this is just a coercion bug?\n\nIMHO, not everything coerces into `SR` and this for a good reason. But this is not (or should not) under discussion here.\n\nThe following is not possible at with subs:\n\n``` \nsage: sage: P.<p> = ZZ[[]]\nsage: var('a,b')\n(a, b)\nsage: (a+b).subs({a: p, b: p^2})\n```\n\n`evaluate` can do.",
    "created_at": "2015-03-31T14:00:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239151",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:7 rws]:
> I thought everything coerces to `SR`? Maybe this is just a coercion bug?

IMHO, not everything coerces into `SR` and this for a good reason. But this is not (or should not) under discussion here.

The following is not possible at with subs:

``` 
sage: sage: P.<p> = ZZ[[]]
sage: var('a,b')
(a, b)
sage: (a+b).subs({a: p, b: p^2})
```

`evaluate` can do.



---

archive/issue_comments_239152.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-03-31T14:24:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239152",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_239153.json:
```json
{
    "body": "Hello,\n\nWhy not\n\n```\nsage: E = (1+x).subs(x=RIF(3.42))\nsage: E.parent()\nsage: F = E.pyobject()\nsage: F\n4.4200000000000000?\nsage: F.parent()\nReal Interval Field with 53 bits of precision\n```\n\n\nVincent",
    "created_at": "2015-03-31T14:24:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239153",
    "user": "https://github.com/videlec"
}
```

Hello,

Why not

```
sage: E = (1+x).subs(x=RIF(3.42))
sage: E.parent()
sage: F = E.pyobject()
sage: F
4.4200000000000000?
sage: F.parent()
Real Interval Field with 53 bits of precision
```


Vincent



---

archive/issue_comments_239154.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-31T15:08:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239154",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239155.json:
```json
{
    "body": "added a doctest and corrected a small bug",
    "created_at": "2015-03-31T15:08:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239155",
    "user": "https://github.com/dkrenn"
}
```

added a doctest and corrected a small bug



---

archive/issue_comments_239156.json:
```json
{
    "body": "Replying to [comment:10 vdelecroix]:\n> Why not\n> {{{\n> sage: E = (1+x).subs(x=RIF(3.42))\n> sage: E.parent()\n> sage: F = E.pyobject()\n> sage: F\n> 4.4200000000000000?\n> sage: F.parent()\n> Real Interval Field with 53 bits of precision\n> }}}\n\nOk, I see. Maybe RIFs are not a good example since they coerce into SR. Power series are better\" example; since there problems.\n\nI'll rewrite the description of the ticket and the examples.",
    "created_at": "2015-03-31T15:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239156",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:10 vdelecroix]:
> Why not
> {{{
> sage: E = (1+x).subs(x=RIF(3.42))
> sage: E.parent()
> sage: F = E.pyobject()
> sage: F
> 4.4200000000000000?
> sage: F.parent()
> Real Interval Field with 53 bits of precision
> }}}

Ok, I see. Maybe RIFs are not a good example since they coerce into SR. Power series are better" example; since there problems.

I'll rewrite the description of the ticket and the examples.



---

archive/issue_comments_239157.json:
```json
{
    "body": "The general idea is that the result of arithmetic only depends on the parents of the input data, not on the values of the input data (because the idea is that these things implement maps, which have domains and codomains). When you evaluate a SR element at a non-symbolic value, you don't know if the result can live in the parent of the original result (e.g., `(sin(x)+y).subs(y=1)`).\n\nThe appropriate solution is probably to first *convert* your symbolic expression to a parent where the parent is the desired thing, e.g.\n\n```\nsage: f = SR(1+x)\nsage: R.<t>= ZZ[[]]\nsage: P=R['x']\nsage: P(f)(x=t^2+O(t^3))\n```\n\nThis also has other advantages: in principle, when you do this with RIF, you might end up with an evaluation routine that takes into account that the coefficients are not exact and hence it could choose some more stable way of doing the evaluation (I think that's hypothetical--likely no such effort is made right now, but it could).",
    "created_at": "2015-03-31T15:39:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239157",
    "user": "https://github.com/nbruin"
}
```

The general idea is that the result of arithmetic only depends on the parents of the input data, not on the values of the input data (because the idea is that these things implement maps, which have domains and codomains). When you evaluate a SR element at a non-symbolic value, you don't know if the result can live in the parent of the original result (e.g., `(sin(x)+y).subs(y=1)`).

The appropriate solution is probably to first *convert* your symbolic expression to a parent where the parent is the desired thing, e.g.

```
sage: f = SR(1+x)
sage: R.<t>= ZZ[[]]
sage: P=R['x']
sage: P(f)(x=t^2+O(t^3))
```

This also has other advantages: in principle, when you do this with RIF, you might end up with an evaluation routine that takes into account that the coefficients are not exact and hence it could choose some more stable way of doing the evaluation (I think that's hypothetical--likely no such effort is made right now, but it could).



---

archive/issue_comments_239158.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-31T15:40:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239158",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239159.json:
```json
{
    "body": "rewritten documentation of function",
    "created_at": "2015-03-31T15:41:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239159",
    "user": "https://github.com/dkrenn"
}
```

rewritten documentation of function



---

archive/issue_comments_239160.json:
```json
{
    "body": "Replying to [comment:14 nbruin]:\n> The general idea is that the result of arithmetic only depends on the parents of the input data, not on the values of the input data (because the idea is that these things implement maps, which have domains and codomains). When you evaluate a SR element at a non-symbolic value, you don't know if the result can live in the parent of the original result (e.g., `(sin(x)+y).subs(y=1)`).\n\nTrue.\n\n> The appropriate solution is probably to first *convert* your symbolic expression to a parent where the parent is the desired thing, e.g.\n> {{{\n> sage: f = SR(1+x)\n> sage: R.<t>= ZZ[[]]\n> sage: P=R['x']\n> sage: P(f)(x=t<sup>2+O(t</sup>3))\n> }}}\n\nWhat if\n\n```\nf = SR(1+2^x)\n```\n\nor something worse (including e.g. exp, log, sin, ... or other functions)? There are no parents (except SR) for any of these constructs.",
    "created_at": "2015-03-31T15:45:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239160",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:14 nbruin]:
> The general idea is that the result of arithmetic only depends on the parents of the input data, not on the values of the input data (because the idea is that these things implement maps, which have domains and codomains). When you evaluate a SR element at a non-symbolic value, you don't know if the result can live in the parent of the original result (e.g., `(sin(x)+y).subs(y=1)`).

True.

> The appropriate solution is probably to first *convert* your symbolic expression to a parent where the parent is the desired thing, e.g.
> {{{
> sage: f = SR(1+x)
> sage: R.<t>= ZZ[[]]
> sage: P=R['x']
> sage: P(f)(x=t<sup>2+O(t</sup>3))
> }}}

What if

```
f = SR(1+2^x)
```

or something worse (including e.g. exp, log, sin, ... or other functions)? There are no parents (except SR) for any of these constructs.



---

archive/issue_comments_239161.json:
```json
{
    "body": "Replying to [comment:18 dkrenn]:\n> What if\n> {{{\n> f = SR(1+2^x)\n> }}}\n> or something worse (including e.g. exp, log, sin, ... or other functions)? There are no parents (except SR) for any of these constructs.\nAnd indeed it's tricky to evaluate the result. What is `2^<power series>`? I guess `exp(log(2)*x)`, which requires a ring that contains both `log(2)` and inverses of all integers., so that doesn't work in `Z[This is the Trac macro *t* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#t-macro)`. I think Sage is right in putting the onus on the user to first find a parent in which the expression fits and where the evaluation behaviour is the desired one.\n\nAnyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.",
    "created_at": "2015-03-31T16:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239161",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:18 dkrenn]:
> What if
> {{{
> f = SR(1+2^x)
> }}}
> or something worse (including e.g. exp, log, sin, ... or other functions)? There are no parents (except SR) for any of these constructs.
And indeed it's tricky to evaluate the result. What is `2^<power series>`? I guess `exp(log(2)*x)`, which requires a ring that contains both `log(2)` and inverses of all integers., so that doesn't work in `Z[This is the Trac macro *t* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#t-macro)`. I think Sage is right in putting the onus on the user to first find a parent in which the expression fits and where the evaluation behaviour is the desired one.

Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.



---

archive/issue_comments_239162.json:
```json
{
    "body": "Replying to [comment:19 nbruin]:\n> Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.\n\nOk, I'll make some experiments and run some tests to see if it satisfies my needs.\n\nThanks",
    "created_at": "2015-03-31T19:04:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239162",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:19 nbruin]:
> Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.

Ok, I'll make some experiments and run some tests to see if it satisfies my needs.

Thanks



---

archive/issue_comments_239163.json:
```json
{
    "body": "Hello,\n\nWould this ticket solve the following issue (from #9787)?\n\n```\nsage: parent(exp(1.2))\nReal Field with 53 bits of precision\nsage: f(x) = exp(x)\nsage: parent(f(1.2))\nSymbolic Ring\n```\n\n\nVincent",
    "created_at": "2015-04-20T11:08:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239163",
    "user": "https://github.com/videlec"
}
```

Hello,

Would this ticket solve the following issue (from #9787)?

```
sage: parent(exp(1.2))
Real Field with 53 bits of precision
sage: f(x) = exp(x)
sage: parent(f(1.2))
Symbolic Ring
```


Vincent



---

archive/issue_comments_239164.json:
```json
{
    "body": "Replying to [comment:21 vdelecroix]:\n> Hello,\n> \n> Would this ticket solve the following issue (from #9787)?\n> {{{\n> sage: parent(exp(1.2))\n> Real Field with 53 bits of precision\n> sage: f(x) = exp(x)\n> sage: parent(f(1.2))\n> Symbolic Ring\n> }}}\n\nYes.\n\n```\nsage: f(x).evaluate({x: 1.2}).parent()\nReal Field with 53 bits of precision\n```\n",
    "created_at": "2015-04-20T11:16:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239164",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:21 vdelecroix]:
> Hello,
> 
> Would this ticket solve the following issue (from #9787)?
> {{{
> sage: parent(exp(1.2))
> Real Field with 53 bits of precision
> sage: f(x) = exp(x)
> sage: parent(f(1.2))
> Symbolic Ring
> }}}

Yes.

```
sage: f(x).evaluate({x: 1.2}).parent()
Real Field with 53 bits of precision
```




---

archive/issue_comments_239165.json:
```json
{
    "body": "Replying to [comment:22 dkrenn]:\n> Replying to [comment:21 vdelecroix]:\n> > Hello,\n> > \n> > Would this ticket solve the following issue (from #9787)?\n> > {{{\n> > sage: parent(exp(1.2))\n> > Real Field with 53 bits of precision\n> > sage: f(x) = exp(x)\n> > sage: parent(f(1.2))\n> > Symbolic Ring\n> > }}}\n> \n> Yes.\n> {{{\n> sage: f(x).evaluate({x: 1.2}).parent()\n> Real Field with 53 bits of precision\n> }}}\n\nSorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?",
    "created_at": "2015-04-20T11:36:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239165",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:22 dkrenn]:
> Replying to [comment:21 vdelecroix]:
> > Hello,
> > 
> > Would this ticket solve the following issue (from #9787)?
> > {{{
> > sage: parent(exp(1.2))
> > Real Field with 53 bits of precision
> > sage: f(x) = exp(x)
> > sage: parent(f(1.2))
> > Symbolic Ring
> > }}}
> 
> Yes.
> {{{
> sage: f(x).evaluate({x: 1.2}).parent()
> Real Field with 53 bits of precision
> }}}

Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?



---

archive/issue_comments_239166.json:
```json
{
    "body": "Replying to [comment:23 vdelecroix]:\n> Replying to [comment:22 dkrenn]:\n> > Replying to [comment:21 vdelecroix]:\n> > > Would this ticket solve the following issue (from #9787)?\n> > > {{{\n> > > sage: parent(exp(1.2))\n> > > Real Field with 53 bits of precision\n> > > sage: f(x) = exp(x)\n> > > sage: parent(f(1.2))\n> > > Symbolic Ring\n> > > }}}\n> > [...]\n> Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?\n\nNo, not modified by this ticket.",
    "created_at": "2015-04-20T11:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239166",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:23 vdelecroix]:
> Replying to [comment:22 dkrenn]:
> > Replying to [comment:21 vdelecroix]:
> > > Would this ticket solve the following issue (from #9787)?
> > > {{{
> > > sage: parent(exp(1.2))
> > > Real Field with 53 bits of precision
> > > sage: f(x) = exp(x)
> > > sage: parent(f(1.2))
> > > Symbolic Ring
> > > }}}
> > [...]
> Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?

No, not modified by this ticket.



---

archive/issue_comments_239167.json:
```json
{
    "body": "Replying to [comment:24 dkrenn]:\n> Replying to [comment:23 vdelecroix]:\n> > Replying to [comment:22 dkrenn]:\n> > > Replying to [comment:21 vdelecroix]:\n> > > > Would this ticket solve the following issue (from #9787)?\n> ...\n> > Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?\n> \n> No, not modified by this ticket.\n\nI saw too late your answer on #9878 ;-)\n\nBy the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. But\n\n```\nsage: f(x) = 2*x\nsage: f.subs(x=3)\nx |--> 6\n```\n\nie, `f` remains a function. It is hopefully not changed into a number.",
    "created_at": "2015-04-20T11:45:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239167",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:24 dkrenn]:
> Replying to [comment:23 vdelecroix]:
> > Replying to [comment:22 dkrenn]:
> > > Replying to [comment:21 vdelecroix]:
> > > > Would this ticket solve the following issue (from #9787)?
> ...
> > Sorry. This was not my question. What would be `parent(f(1.2))`? Is this modified by this ticket?
> 
> No, not modified by this ticket.

I saw too late your answer on #9878 ;-)

By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. But

```
sage: f(x) = 2*x
sage: f.subs(x=3)
x |--> 6
```

ie, `f` remains a function. It is hopefully not changed into a number.



---

archive/issue_comments_239168.json:
```json
{
    "body": "Replying to [comment:25 vdelecroix]:\n> By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. \n\nIn the following it does the same as subs:\n\n```\nsage:  sage: f(x) = 2*x\nsage:  sage: f(x).subs(x=3)\n6\nsage:  sage: f(x).evaluate(x=3)\n6\n```\n\n\n> But\n> {{{\n> sage: f(x) = 2*x\n> sage: f.subs(x=3)\n> x |--> 6\n> }}}\n> ie, `f` remains a function. It is hopefully not changed into a number.\n\nIndeed, this changes (I wasn't aware of this up to now):\n\n```\nsage:  sage: f.evaluate(x=3)\n6\n```\n\nThis is because `evaluate` uses\n\n```\nsage: f.operator()\n<built-in function mul>\nsage: f.operands()\n[x, 2]\n```\n\nFrom this, `f` is equal to `2*x`. Sage sees these two as equal as well:\n\n```\nsage: bool(f == 2*x)\nTrue\n```\n",
    "created_at": "2015-04-20T12:00:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239168",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:25 vdelecroix]:
> By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. 

In the following it does the same as subs:

```
sage:  sage: f(x) = 2*x
sage:  sage: f(x).subs(x=3)
6
sage:  sage: f(x).evaluate(x=3)
6
```


> But
> {{{
> sage: f(x) = 2*x
> sage: f.subs(x=3)
> x |--> 6
> }}}
> ie, `f` remains a function. It is hopefully not changed into a number.

Indeed, this changes (I wasn't aware of this up to now):

```
sage:  sage: f.evaluate(x=3)
6
```

This is because `evaluate` uses

```
sage: f.operator()
<built-in function mul>
sage: f.operands()
[x, 2]
```

From this, `f` is equal to `2*x`. Sage sees these two as equal as well:

```
sage: bool(f == 2*x)
True
```




---

archive/issue_comments_239169.json:
```json
{
    "body": "Replying to [comment:26 dkrenn]:\n> Replying to [comment:25 vdelecroix]:\n> > By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. \n> \n> From this, `f` is equal to `2*x`. Sage sees these two as equal as well:\n> {{{\n> sage: bool(f == 2*x)\n> True\n> }}}\n\nArgh. Definitely a bug to me. Another bug is that the variable defining a function should be transparent. And currently\n\n```\nsage: f(x) = 2*x\nsage: g(y) = 2*y\nsage: bool(f == g)\nFalse\n```\n\n\nVincent",
    "created_at": "2015-04-20T12:38:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239169",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:26 dkrenn]:
> Replying to [comment:25 vdelecroix]:
> > By the way, let me repeat another question from #9878. I found the behavior of `evaluate` in your [comment:22 comment:22] very weird. I thought it was a modification of `.subs` in order to take care of the parent. 
> 
> From this, `f` is equal to `2*x`. Sage sees these two as equal as well:
> {{{
> sage: bool(f == 2*x)
> True
> }}}

Argh. Definitely a bug to me. Another bug is that the variable defining a function should be transparent. And currently

```
sage: f(x) = 2*x
sage: g(y) = 2*y
sage: bool(f == g)
False
```


Vincent



---

archive/issue_comments_239170.json:
```json
{
    "body": "Please Cc: me with any ticket you open regarding `Expression.nonzero()` or pynac.",
    "created_at": "2015-04-20T12:43:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239170",
    "user": "https://github.com/rwst"
}
```

Please Cc: me with any ticket you open regarding `Expression.nonzero()` or pynac.



---

archive/issue_comments_239171.json:
```json
{
    "body": "Replying to [comment:27 vdelecroix]:\n\n```\nsage: f(x) = 2*x\n```\n\n> > From this, `f` is equal to `2*x`. Sage sees these two as equal as well:\n> > {{{\n> > sage: bool(f == 2*x)\n> > True\n> > }}}\n> \n> Argh. Definitely a bug to me. Another bug is that the variable defining a function should be transparent. And currently\n> {{{\n> sage: f(x) = 2*x\n> sage: g(y) = 2*y\n> sage: bool(f == g)\n> False\n> }}}\n\nThis is now #18259.",
    "created_at": "2015-04-20T12:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239171",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:27 vdelecroix]:

```
sage: f(x) = 2*x
```

> > From this, `f` is equal to `2*x`. Sage sees these two as equal as well:
> > {{{
> > sage: bool(f == 2*x)
> > True
> > }}}
> 
> Argh. Definitely a bug to me. Another bug is that the variable defining a function should be transparent. And currently
> {{{
> sage: f(x) = 2*x
> sage: g(y) = 2*y
> sage: bool(f == g)
> False
> }}}

This is now #18259.



---

archive/issue_comments_239172.json:
```json
{
    "body": "As to the original `subs` error, nbruin has explained why there is no general solution, a workaround for polynomials would be\n\n```\nsage: P.<p> = ZZ[[]]\nsage: x.power_series(ZZ)\nx + O(x^2)\nsage: P(_)\np + O(p^2)\n```\n\nI believe a more general way to have all possibilities of both `SR` and the series rings is to fix conversions between them, and use a series ring over `SR`. This depends on #17659, please review.",
    "created_at": "2015-06-20T07:36:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239172",
    "user": "https://github.com/rwst"
}
```

As to the original `subs` error, nbruin has explained why there is no general solution, a workaround for polynomials would be

```
sage: P.<p> = ZZ[[]]
sage: x.power_series(ZZ)
x + O(x^2)
sage: P(_)
p + O(p^2)
```

I believe a more general way to have all possibilities of both `SR` and the series rings is to fix conversions between them, and use a series ring over `SR`. This depends on #17659, please review.



---

archive/issue_comments_239173.json:
```json
{
    "body": "Replying to [comment:19 nbruin]:\n> Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.\n\nI had another instance where I needed a version of `.subs` like in this ticket, because there is no coercion from a number field to the symbolic ring.\n\n```\nsage: K.<omega> = NumberField(x^4 + 1)\nsage: var('u')\nsage: z = u/(u + 1)^2\nsage: z.subs(u=omega)\nTraceback (most recent call last):\n...\nTypeError: no canonical coercion from Number Field\nin omega with defining polynomial x^16 + 1 to\nSymbolic Ring\n```\n\nUsing `fast_callable` works in this case:\n\n```\nsage: fast_callable(z, vars=[u])(omega)\n1/2*omega^3 - 1/2*omega + 1\n```\n\n\nIt works, but the solution is hard to find and the notation a bit cumbersome.\n\nI see several solutions:\n1. adding a link to `fast_callable` and some examples from this ticket to the documentation of `subs`.\n2. indeed create a method as proposed here which acts as a wrapper for `fast_callable`.\n\nOpinions?",
    "created_at": "2016-02-11T15:27:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239173",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:19 nbruin]:
> Anyway, `fast_callable` takes a best effort approach towards compiling a program that tries to perform the evaluation, so that might be your best bet.

I had another instance where I needed a version of `.subs` like in this ticket, because there is no coercion from a number field to the symbolic ring.

```
sage: K.<omega> = NumberField(x^4 + 1)
sage: var('u')
sage: z = u/(u + 1)^2
sage: z.subs(u=omega)
Traceback (most recent call last):
...
TypeError: no canonical coercion from Number Field
in omega with defining polynomial x^16 + 1 to
Symbolic Ring
```

Using `fast_callable` works in this case:

```
sage: fast_callable(z, vars=[u])(omega)
1/2*omega^3 - 1/2*omega + 1
```


It works, but the solution is hard to find and the notation a bit cumbersome.

I see several solutions:
1. adding a link to `fast_callable` and some examples from this ticket to the documentation of `subs`.
2. indeed create a method as proposed here which acts as a wrapper for `fast_callable`.

Opinions?



---

archive/issue_comments_239174.json:
```json
{
    "body": "Replying to [comment:30 rws]:\n> I believe a more general way to have all possibilities of both `SR` and the series rings is to fix conversions between them, and use a series ring over `SR`. This depends on #17659, please review.\n\nIs it realistic to hope that all conversions will exist? Do they always make sense?",
    "created_at": "2016-02-11T15:29:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239174",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:30 rws]:
> I believe a more general way to have all possibilities of both `SR` and the series rings is to fix conversions between them, and use a series ring over `SR`. This depends on #17659, please review.

Is it realistic to hope that all conversions will exist? Do they always make sense?



---

archive/issue_comments_239175.json:
```json
{
    "body": "I am now neutral or positive on this ticket. Still,\n\n>Is it realistic to hope that all conversions will exist? Do they always make sense?\nI suspect many will and do. You can easily find out by reviewing #16203 and #17402.",
    "created_at": "2016-02-11T16:04:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17855",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17855#issuecomment-239175",
    "user": "https://github.com/rwst"
}
```

I am now neutral or positive on this ticket. Still,

>Is it realistic to hope that all conversions will exist? Do they always make sense?
I suspect many will and do. You can easily find out by reviewing #16203 and #17402.
