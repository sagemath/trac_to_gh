# Issue 15190: Performance of casting polynomials to polynomials over finite fields

archive/issues_015190.json:
```json
{
    "body": "CC:  roed jpflori\n\nKeywords: FiniteField Polynomial Casting\n\nOne would expect the performance of casting the usual way (as in test 1 below) to be at least not much worse than test 2:\n\n```\nsage: QQX=QQ['x']\nsage: QP=Qp(3,30);\nsage: R=QP.residue_field();\nsage: RX=R['x'];\nsage: prim=primes_first_n(1000)\nsage: polysQQ = [ QQX(prim[i:i+30]) for i in range(1,900)]\nsage: def test1(PR,l):\n        return [PR(P) for P in l];\n....:\nsage: def test2(PR,l):\n        return [PR([PR.base_ring()(coef) for coef in P.list()]) for P in l];\n....:\nsage: %timeit test1(RX,polysQQ)\n1 loops, best of 3: 478 ms per loop\nsage: %timeit test2(RX,polysQQ)\n1 loops, best of 3: 230 ms per loop\n```\n\nEspecially since the actual implementation of casting that is performed essentially reduces to converting to a list and casting as we do in test 2.\n\nThe problem is that the implementation of list->polynomial casting provided by Polynomial_template is very much not optimal, sufficiently so that two of the three implementing classes handle lists in their own __init__ rather than passing through to polynomial template.\n\nThe polynomial->polynomial casting is then also inefficient as it converts the poly to a list and recalls __init__. In the original code this bypassed the optimized list implementations in the implementing class, this is what the current patch changes. The effect on performance is as follows:\n\n```\nsage: %timeit test1(RX,polysQQ)\n1 loops, best of 3: 219 ms per loop\n```\n\n\nThere is still room for improvement, the current (and with patch) implementation will in most cases end up calling Polynomial_template.__init__ twice, and likely also Polynomial.__init__ twice, this is wasteful (even though the calls are largely no-ops). It would probably be better to, in addition to the currently proposed patch, special case casts from polynomials in the implementing classes the same way lists are done to avoid this.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/15427\n\n",
    "created_at": "2013-11-16T19:28:44Z",
    "labels": [
        "performance",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Performance of casting polynomials to polynomials over finite fields",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15190",
    "user": "afiori"
}
```
CC:  roed jpflori

Keywords: FiniteField Polynomial Casting

One would expect the performance of casting the usual way (as in test 1 below) to be at least not much worse than test 2:

```
sage: QQX=QQ['x']
sage: QP=Qp(3,30);
sage: R=QP.residue_field();
sage: RX=R['x'];
sage: prim=primes_first_n(1000)
sage: polysQQ = [ QQX(prim[i:i+30]) for i in range(1,900)]
sage: def test1(PR,l):
        return [PR(P) for P in l];
....:
sage: def test2(PR,l):
        return [PR([PR.base_ring()(coef) for coef in P.list()]) for P in l];
....:
sage: %timeit test1(RX,polysQQ)
1 loops, best of 3: 478 ms per loop
sage: %timeit test2(RX,polysQQ)
1 loops, best of 3: 230 ms per loop
```

Especially since the actual implementation of casting that is performed essentially reduces to converting to a list and casting as we do in test 2.

The problem is that the implementation of list->polynomial casting provided by Polynomial_template is very much not optimal, sufficiently so that two of the three implementing classes handle lists in their own __init__ rather than passing through to polynomial template.

The polynomial->polynomial casting is then also inefficient as it converts the poly to a list and recalls __init__. In the original code this bypassed the optimized list implementations in the implementing class, this is what the current patch changes. The effect on performance is as follows:

```
sage: %timeit test1(RX,polysQQ)
1 loops, best of 3: 219 ms per loop
```


There is still room for improvement, the current (and with patch) implementation will in most cases end up calling Polynomial_template.__init__ twice, and likely also Polynomial.__init__ twice, this is wasteful (even though the calls are largely no-ops). It would probably be better to, in addition to the currently proposed patch, special case casts from polynomials in the implementing classes the same way lists are done to avoid this.


Issue created by migration from https://trac.sagemath.org/ticket/15427





---

archive/issue_comments_195075.json:
```json
{
    "body": "Attachment [FiniteFieldPolyCast.patch](tarball://root/attachments/some-uuid/ticket15427/FiniteFieldPolyCast.patch) by afiori created at 2013-11-17 00:42:15",
    "created_at": "2013-11-17T00:42:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15190",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15190#issuecomment-195075",
    "user": "afiori"
}
```

Attachment [FiniteFieldPolyCast.patch](tarball://root/attachments/some-uuid/ticket15427/FiniteFieldPolyCast.patch) by afiori created at 2013-11-17 00:42:15
