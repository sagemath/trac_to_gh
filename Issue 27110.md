# Issue 27110: Lazy laurent series

archive/issues_027110.json:
```json
{
    "body": "Introduce lazy laurent series to Sage.\n\nIssue created by migration from https://trac.sagemath.org/ticket/27347\n\n",
    "created_at": "2019-02-24T22:11:36Z",
    "labels": [
        "algebra",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.8",
    "title": "Lazy laurent series",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27110",
    "user": "klee"
}
```
Introduce lazy laurent series to Sage.

Issue created by migration from https://trac.sagemath.org/ticket/27347





---

archive/issue_comments_381786.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-24T22:14:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381786",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381787.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-02-24T22:16:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381787",
    "user": "klee"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_381788.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-25T06:32:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381788",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381789.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-25T08:34:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381789",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381790.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-25T19:15:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381790",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381791.json:
```json
{
    "body": "Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)",
    "created_at": "2019-03-25T10:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381791",
    "user": "embray"
}
```

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)



---

archive/issue_comments_381792.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-04-01T00:49:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381792",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_381793.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-04-04T10:57:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381793",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_381794.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-04T20:05:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381794",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381795.json:
```json
{
    "body": "Some comments:\n\nIs there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.\n\nWhy do you override `__eq__` and not use the one provided by `Element` and the coercion framework? It is more flexible and allows you do implement comparisons (if you want) all in one function of `_richcmp_`.\n\nDo not have bare `except:` statements (see `coefficient`).\n\nDoes the elements pickle? I am a little worried that the addition of two power series will not pickling because of the little helper `add` function. You should add a `loads(dumps(foo))` test if it does work.\n\nTypo `laurent` -> `Laurent` (it is proper noun).\n\n`if len(s) == 0:` -> `if not s:`",
    "created_at": "2019-04-05T09:22:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381795",
    "user": "tscrim"
}
```

Some comments:

Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.

Why do you override `__eq__` and not use the one provided by `Element` and the coercion framework? It is more flexible and allows you do implement comparisons (if you want) all in one function of `_richcmp_`.

Do not have bare `except:` statements (see `coefficient`).

Does the elements pickle? I am a little worried that the addition of two power series will not pickling because of the little helper `add` function. You should add a `loads(dumps(foo))` test if it does work.

Typo `laurent` -> `Laurent` (it is proper noun).

`if len(s) == 0:` -> `if not s:`



---

archive/issue_comments_381796.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-04-05T23:01:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381796",
    "user": "klee"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_381797.json:
```json
{
    "body": "Replying to [comment:12 tscrim]:\n> Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.\n\nI looked into the `LazyPowerSeriesRing` many years ago:\n\nhttps://groups.google.com/forum/#!searchin/sage-support/lazy$20power$20series%7Csort:date/sage-support/JZwDWKq3DtM/tyfxxdxPyXYJ\n\nI think I didn't like it in several ways :-) Still I don't understand this behavior:\n\n\n```\nsage: L.<t>=LazyPowerSeriesRing(QQ)\nsage: s=L([0,0,1,2])\nsage: s.coefficient(0)\n0\nsage: s.coefficient(1)\n0\nsage: s.coefficient(2)\n1\nsage: s.coefficient(3)\n2\nsage: s\nt^2 + 2*t^3 + O(x^4)\nsage: s.get_order()\n1\nsage: s.get_aorder()\n1\n```\n\n\nThe reason was that it was easy to implement lazy laurent series with an interface and behaviors that I prefer, while I could not understand well enough `LazyPowerSeriesRing`... \n\nI would reconsider basing lazy laurent series on `LazyPowerSeriesRing`, if you help me understand the strange behaviour above.",
    "created_at": "2019-04-05T23:01:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381797",
    "user": "klee"
}
```

Replying to [comment:12 tscrim]:
> Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.

I looked into the `LazyPowerSeriesRing` many years ago:

https://groups.google.com/forum/#!searchin/sage-support/lazy$20power$20series%7Csort:date/sage-support/JZwDWKq3DtM/tyfxxdxPyXYJ

I think I didn't like it in several ways :-) Still I don't understand this behavior:


```
sage: L.<t>=LazyPowerSeriesRing(QQ)
sage: s=L([0,0,1,2])
sage: s.coefficient(0)
0
sage: s.coefficient(1)
0
sage: s.coefficient(2)
1
sage: s.coefficient(3)
2
sage: s
t^2 + 2*t^3 + O(x^4)
sage: s.get_order()
1
sage: s.get_aorder()
1
```


The reason was that it was easy to implement lazy laurent series with an interface and behaviors that I prefer, while I could not understand well enough `LazyPowerSeriesRing`... 

I would reconsider basing lazy laurent series on `LazyPowerSeriesRing`, if you help me understand the strange behaviour above.



---

archive/issue_comments_381798.json:
```json
{
    "body": "So here is what `refine_aorder` does. It first checks if `self.order` has been set, if it has, do not do anything. Then it goes through all of the `n` computed entries **if `self.aorder` is 0** and we have already computed at least one entry. Then find the first nonzero entry. If we have found one, set the order.\n\nThe problem is the bold part. After the first iteration when `n = 1`, the `self.aorder` gets set to `1`, then on the second run through, that block does not get run, which then means `self.aorder < n` and we set the order to be `1`.\n\n```\nsage: s.coefficient(1)\n0\nsage: s.aorder\n1\nsage: s.order\nUnknown series order\nsage: s.coefficient(2)\n1\nsage: s.aorder\n1\nsage: s.order\n1\n```\n\nIMO, this is a bug.",
    "created_at": "2019-04-05T23:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381798",
    "user": "tscrim"
}
```

So here is what `refine_aorder` does. It first checks if `self.order` has been set, if it has, do not do anything. Then it goes through all of the `n` computed entries **if `self.aorder` is 0** and we have already computed at least one entry. Then find the first nonzero entry. If we have found one, set the order.

The problem is the bold part. After the first iteration when `n = 1`, the `self.aorder` gets set to `1`, then on the second run through, that block does not get run, which then means `self.aorder < n` and we set the order to be `1`.

```
sage: s.coefficient(1)
0
sage: s.aorder
1
sage: s.order
Unknown series order
sage: s.coefficient(2)
1
sage: s.aorder
1
sage: s.order
1
```

IMO, this is a bug.



---

archive/issue_comments_381799.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-07T08:03:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381799",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381800.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-07T08:48:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381800",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381801.json:
```json
{
    "body": "> Why do you override `__eq__` and not use the one provided by `Element` and the coercion framework? It is more flexible and allows you do implement comparisons (if you want) all in one function of `_richcmp_`.\n\nOk. Fixed.\n \n> Do not have bare `except:` statements (see `coefficient`).\n\nFixed.\n\n> Does the elements pickle? I am a little worried that the addition of two power series will not pickling because of the little helper `add` function. You should add a `loads(dumps(foo))` test if it does work.\n\nNo. Your worry is real; lazy Laurent series is not picklable in general. This seems an inherent nature of my implementation...\n\nI added a test to show this. \n\n> Typo `laurent` -> `Laurent` (it is proper noun).\n\nRight. Fixed.\n\n> `if len(s) == 0:` -> `if not s:`\n\nDone. \n----\nNew commits:",
    "created_at": "2019-04-07T08:53:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381801",
    "user": "klee"
}
```

> Why do you override `__eq__` and not use the one provided by `Element` and the coercion framework? It is more flexible and allows you do implement comparisons (if you want) all in one function of `_richcmp_`.

Ok. Fixed.
 
> Do not have bare `except:` statements (see `coefficient`).

Fixed.

> Does the elements pickle? I am a little worried that the addition of two power series will not pickling because of the little helper `add` function. You should add a `loads(dumps(foo))` test if it does work.

No. Your worry is real; lazy Laurent series is not picklable in general. This seems an inherent nature of my implementation...

I added a test to show this. 

> Typo `laurent` -> `Laurent` (it is proper noun).

Right. Fixed.

> `if len(s) == 0:` -> `if not s:`

Done. 
----
New commits:



---

archive/issue_comments_381802.json:
```json
{
    "body": "Replying to [comment:12 tscrim]:\n> Some comments:\n> \n> Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.\n\nI thought about this. Now I think:\n\nLazy Laurent series is not just about Laurent series but also about how coefficients are computed lazily. A `LazyPowerSeriesRing` element gets its coefficients from a stream object, which essentially yields coefficients as required. On the other hand, lazy Laurent series `s` gets its coefficients from a python function that outputs n-th coefficient  for input `s` and `n`. This allows coefficients to be computed recursively. For example, it is very easy to define the Fibonacci series. \n\nSo it is impossible to base my lazy Laurent series code on `LazyPowerSeriesRing` without abandoning the essential feature of the implementation.\n\nFrankly, I would rather provide new lazy power series as a subclass of my lazy Laurent series. But this is of course highly biased opinion :-)\n\nYou may be reluctant to accept my implementation of lazy Laurent series into `sage.rings` as it then gets kind of standard status among different possible implementations of lazy Laurent series in Sage. Then I am willing to relocate it into `sage.rings.function_field`.",
    "created_at": "2019-04-07T09:40:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381802",
    "user": "klee"
}
```

Replying to [comment:12 tscrim]:
> Some comments:
> 
> Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.

I thought about this. Now I think:

Lazy Laurent series is not just about Laurent series but also about how coefficients are computed lazily. A `LazyPowerSeriesRing` element gets its coefficients from a stream object, which essentially yields coefficients as required. On the other hand, lazy Laurent series `s` gets its coefficients from a python function that outputs n-th coefficient  for input `s` and `n`. This allows coefficients to be computed recursively. For example, it is very easy to define the Fibonacci series. 

So it is impossible to base my lazy Laurent series code on `LazyPowerSeriesRing` without abandoning the essential feature of the implementation.

Frankly, I would rather provide new lazy power series as a subclass of my lazy Laurent series. But this is of course highly biased opinion :-)

You may be reluctant to accept my implementation of lazy Laurent series into `sage.rings` as it then gets kind of standard status among different possible implementations of lazy Laurent series in Sage. Then I am willing to relocate it into `sage.rings.function_field`.



---

archive/issue_comments_381803.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-07T10:04:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381803",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381804.json:
```json
{
    "body": "Replying to [comment:18 klee]:\n> Replying to [comment:12 tscrim]:\n> > Some comments:\n> > \n> > Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.\n> \n> I thought about this. Now I think:\n> \n> Lazy Laurent series is not just about Laurent series but also about how coefficients are computed lazily. A `LazyPowerSeriesRing` element gets its coefficients from a stream object, which essentially yields coefficients as required. On the other hand, lazy Laurent series `s` gets its coefficients from a python function that outputs n-th coefficient  for input `s` and `n`. This allows coefficients to be computed recursively. For example, it is very easy to define the Fibonacci series. \n\nWell, I am fairly certain you could do this with an `RecursivelyEnumeratedSet` and a bit of know-how, but I agree that it is more complicated and less intuitive. I also agree that having general functions as input would probably be a good thing for `LazyPowerSeriesRing` to have, but I believe that was designed for more specific use for the `combinat/species` code.\n\nOne benefit I do see is that you do not need to explicitly know the valuation at creation-time. With my suggested implementation, it does need to be computed at element creation.\n\n> Frankly, I would rather provide new lazy power series as a subclass of my lazy Laurent series. But this is of course highly biased opinion :-)\n\nI don't have an opinion on this matter, but there are likely some considerations required to replace or extend the current implementation.\n\n> You may be reluctant to accept my implementation of lazy Laurent series into `sage.rings` as it then gets kind of standard status among different possible implementations of lazy Laurent series in Sage. Then I am willing to relocate it into `sage.rings.function_field`.\n\nThis I don't really care about. I just am a little unhappy with the large difference between the semantics (and syntax) between the two implementations. I guess that is a bit unavoidable here because this definitely is serving a purpose.\n\nHowever, I do think we should at least try to address the pickling issues. I believe this means you cannot use this in parallel implementations (IIRC this uses pickling to communicate between the processes). It also means you cannot (easily) store the data you compute. I think it is sufficient to separate out the `add` and similar operations into functions, but maybe they need to be small little helper class, such as\n\n```python\nclass LaurentSeriesOperator(object):\n    def __init__(self, lps, op):\n        self.lps = lps\n        self.op = op\n    def __call__(self, s, n):\n        return self.op(self.lps[n], s[n])\n    def __reduce__(self):\n        return (type(self), (self.lps, self.op), {})\n    def __eq__(self, other):\n        return (isinstance(other, LaurentSeriesOperator)\n                and self.lps == other.lps and self.op == other.op)\n```\n\nwhere `op` is, e.g., `operator.add`. This way you might be able to do something with comparisons in some semi-reasonable capacity too.",
    "created_at": "2019-04-07T13:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381804",
    "user": "tscrim"
}
```

Replying to [comment:18 klee]:
> Replying to [comment:12 tscrim]:
> > Some comments:
> > 
> > Is there a reason why you do not use the `LazyPowerSeriesRing` for the main element (with a non-zero constant term until the whole series is zero) and then just store the valuation? This is how things are done for the Laurent polynomials. That way there is less duplication of code and improvements to one improve both.
> 
> I thought about this. Now I think:
> 
> Lazy Laurent series is not just about Laurent series but also about how coefficients are computed lazily. A `LazyPowerSeriesRing` element gets its coefficients from a stream object, which essentially yields coefficients as required. On the other hand, lazy Laurent series `s` gets its coefficients from a python function that outputs n-th coefficient  for input `s` and `n`. This allows coefficients to be computed recursively. For example, it is very easy to define the Fibonacci series. 

Well, I am fairly certain you could do this with an `RecursivelyEnumeratedSet` and a bit of know-how, but I agree that it is more complicated and less intuitive. I also agree that having general functions as input would probably be a good thing for `LazyPowerSeriesRing` to have, but I believe that was designed for more specific use for the `combinat/species` code.

One benefit I do see is that you do not need to explicitly know the valuation at creation-time. With my suggested implementation, it does need to be computed at element creation.

> Frankly, I would rather provide new lazy power series as a subclass of my lazy Laurent series. But this is of course highly biased opinion :-)

I don't have an opinion on this matter, but there are likely some considerations required to replace or extend the current implementation.

> You may be reluctant to accept my implementation of lazy Laurent series into `sage.rings` as it then gets kind of standard status among different possible implementations of lazy Laurent series in Sage. Then I am willing to relocate it into `sage.rings.function_field`.

This I don't really care about. I just am a little unhappy with the large difference between the semantics (and syntax) between the two implementations. I guess that is a bit unavoidable here because this definitely is serving a purpose.

However, I do think we should at least try to address the pickling issues. I believe this means you cannot use this in parallel implementations (IIRC this uses pickling to communicate between the processes). It also means you cannot (easily) store the data you compute. I think it is sufficient to separate out the `add` and similar operations into functions, but maybe they need to be small little helper class, such as

```python
class LaurentSeriesOperator(object):
    def __init__(self, lps, op):
        self.lps = lps
        self.op = op
    def __call__(self, s, n):
        return self.op(self.lps[n], s[n])
    def __reduce__(self):
        return (type(self), (self.lps, self.op), {})
    def __eq__(self, other):
        return (isinstance(other, LaurentSeriesOperator)
                and self.lps == other.lps and self.op == other.op)
```

where `op` is, e.g., `operator.add`. This way you might be able to do something with comparisons in some semi-reasonable capacity too.



---

archive/issue_comments_381805.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-08T05:45:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381805",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381806.json:
```json
{
    "body": "Replying to [comment:20 tscrim]:\n> However, I do think we should at least try to address the pickling issues. I believe this means you cannot use this in parallel implementations (IIRC this uses pickling to communicate between the processes). It also means you cannot (easily) store the data you compute. I think it is sufficient to separate out the `add` and similar operations into functions, but maybe they need to be small little helper class, such as\n> {{{#!python\n> class LaurentSeriesOperator(object):\n>     def __init__(self, lps, op):\n>         self.lps = lps\n>         self.op = op\n>     def __call__(self, s, n):\n>         return self.op(self.lps[n], s[n])\n>     def __reduce__(self):\n>         return (type(self), (self.lps, self.op), {})\n>     def __eq__(self, other):\n>         return (isinstance(other, LaurentSeriesOperator)\n>                 and self.lps == other.lps and self.op == other.op)\n> }}}\n> where `op` is, e.g., `operator.add`. This way you might be able to do something with comparisons in some semi-reasonable capacity too.\n\nUsing module-level classes to define operators is a good idea. Hinted by your template class, I could reimplement lazy Laurent series to be picklable. Great!",
    "created_at": "2019-04-08T05:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381806",
    "user": "klee"
}
```

Replying to [comment:20 tscrim]:
> However, I do think we should at least try to address the pickling issues. I believe this means you cannot use this in parallel implementations (IIRC this uses pickling to communicate between the processes). It also means you cannot (easily) store the data you compute. I think it is sufficient to separate out the `add` and similar operations into functions, but maybe they need to be small little helper class, such as
> {{{#!python
> class LaurentSeriesOperator(object):
>     def __init__(self, lps, op):
>         self.lps = lps
>         self.op = op
>     def __call__(self, s, n):
>         return self.op(self.lps[n], s[n])
>     def __reduce__(self):
>         return (type(self), (self.lps, self.op), {})
>     def __eq__(self, other):
>         return (isinstance(other, LaurentSeriesOperator)
>                 and self.lps == other.lps and self.op == other.op)
> }}}
> where `op` is, e.g., `operator.add`. This way you might be able to do something with comparisons in some semi-reasonable capacity too.

Using module-level classes to define operators is a good idea. Hinted by your template class, I could reimplement lazy Laurent series to be picklable. Great!



---

archive/issue_comments_381807.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-08T07:12:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381807",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381808.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-08T07:24:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381808",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381809.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2019-04-08T09:06:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381809",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_381810.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-04-08T09:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381810",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_381811.json:
```json
{
    "body": "Oops. Pushed a wrong branch!",
    "created_at": "2019-04-08T09:10:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381811",
    "user": "klee"
}
```

Oops. Pushed a wrong branch!



---

archive/issue_comments_381812.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-04-08T09:21:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381812",
    "user": "klee"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_381813.json:
```json
{
    "body": "This is looking good.\n\nPast experience tells me you should also implement a `__ne__` at the base class. I also think you should include more ABCs to avoid the extra duplication with the `__eq__` methods. Similarly, why not use the `op` version for `+-*/` to avoid class duplication? You may also want a `__hash__` and incorporate that into the hash of the lazy Laurent series. With how many operator classes you have, it may also be worthwhile pulling that out to a separate file for better separations-of-concerns between files.",
    "created_at": "2019-04-08T12:46:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381813",
    "user": "tscrim"
}
```

This is looking good.

Past experience tells me you should also implement a `__ne__` at the base class. I also think you should include more ABCs to avoid the extra duplication with the `__eq__` methods. Similarly, why not use the `op` version for `+-*/` to avoid class duplication? You may also want a `__hash__` and incorporate that into the hash of the lazy Laurent series. With how many operator classes you have, it may also be worthwhile pulling that out to a separate file for better separations-of-concerns between files.



---

archive/issue_comments_381814.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-09T04:00:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381814",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381815.json:
```json
{
    "body": "Replying to [comment:31 tscrim]:\n> This is looking good.\n> \n> Past experience tells me you should also implement a `__ne__` at the base class. \n\nDone.\n\n> I also think you should include more ABCs to avoid the extra duplication with the `__eq__` methods. \n\nOk.\n\n> Similarly, why not use the `op` version for `+-*/` to avoid class duplication? \n\nI don't get it. They cannot be treated uniformly. Look at the `__call__` method.\n\n> You may also want a `__hash__` and incorporate that into the hash of the lazy Laurent series. \n\nDone.\n\n> With how many operator classes you have, it may also be worthwhile pulling that out to a separate file for better separations-of-concerns between files.\n\nDone.",
    "created_at": "2019-04-09T04:04:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381815",
    "user": "klee"
}
```

Replying to [comment:31 tscrim]:
> This is looking good.
> 
> Past experience tells me you should also implement a `__ne__` at the base class. 

Done.

> I also think you should include more ABCs to avoid the extra duplication with the `__eq__` methods. 

Ok.

> Similarly, why not use the `op` version for `+-*/` to avoid class duplication? 

I don't get it. They cannot be treated uniformly. Look at the `__call__` method.

> You may also want a `__hash__` and incorporate that into the hash of the lazy Laurent series. 

Done.

> With how many operator classes you have, it may also be worthwhile pulling that out to a separate file for better separations-of-concerns between files.

Done.



---

archive/issue_comments_381816.json:
```json
{
    "body": "Replying to [comment:33 klee]:\n> Replying to [comment:31 tscrim]:\n> > Similarly, why not use the `op` version for `+-*/` to avoid class duplication? \n> \n> I don't get it. They cannot be treated uniformly. Look at the `__call__` method.\n\nYou can do what I suggested in comment:20 for these classes:\n- `LazyLaurentSeriesOperator_add` (by passing `operator.add`)\n- `LazyLaurentSeriesOperator_sub` (by passing `operator.sub`)\nYou're right that multiplication must be treated separately. Although you could also do this for a scalar multiplication version of this (which will be faster than coercion and multiplication). For 2 cases, there is a less compelling reason to factor the common code out like this.\n\nThere is not really a benefit for doing this for unitary operations (as there is only 1 that could work this way).\n\nIn some ways it feels like we are reinventing the wheel here because we are effectively building an evaluation tree, and we already have something like this within `SR` (or sympy/pynac/etc.). However, I don't see a way around this by using `SR` (and we might have to work a little bit to avoid doing computations unnecessarily inside of there). So I think we have to keep doing things this way. Just an observation.",
    "created_at": "2019-04-09T05:55:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381816",
    "user": "tscrim"
}
```

Replying to [comment:33 klee]:
> Replying to [comment:31 tscrim]:
> > Similarly, why not use the `op` version for `+-*/` to avoid class duplication? 
> 
> I don't get it. They cannot be treated uniformly. Look at the `__call__` method.

You can do what I suggested in comment:20 for these classes:
- `LazyLaurentSeriesOperator_add` (by passing `operator.add`)
- `LazyLaurentSeriesOperator_sub` (by passing `operator.sub`)
You're right that multiplication must be treated separately. Although you could also do this for a scalar multiplication version of this (which will be faster than coercion and multiplication). For 2 cases, there is a less compelling reason to factor the common code out like this.

There is not really a benefit for doing this for unitary operations (as there is only 1 that could work this way).

In some ways it feels like we are reinventing the wheel here because we are effectively building an evaluation tree, and we already have something like this within `SR` (or sympy/pynac/etc.). However, I don't see a way around this by using `SR` (and we might have to work a little bit to avoid doing computations unnecessarily inside of there). So I think we have to keep doing things this way. Just an observation.



---

archive/issue_comments_381817.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-09T08:20:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381817",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381818.json:
```json
{
    "body": "Replying to [comment:34 tscrim]:\n> Although you could also do this for a scalar multiplication version of this (which will be faster than coercion and multiplication). \n\nAdded scalar multiplication.\n\n> In some ways it feels like we are reinventing the wheel here because we are effectively building an evaluation tree, and we already have something like this within `SR` (or sympy/pynac/etc.). However, I don't see a way around this by using `SR` (and we might have to work a little bit to avoid doing computations unnecessarily inside of there). So I think we have to keep doing things this way. Just an observation.\n\nTrue. It is just inevitable that sometimes we make wheels for different needs :-)",
    "created_at": "2019-04-09T11:09:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381818",
    "user": "klee"
}
```

Replying to [comment:34 tscrim]:
> Although you could also do this for a scalar multiplication version of this (which will be faster than coercion and multiplication). 

Added scalar multiplication.

> In some ways it feels like we are reinventing the wheel here because we are effectively building an evaluation tree, and we already have something like this within `SR` (or sympy/pynac/etc.). However, I don't see a way around this by using `SR` (and we might have to work a little bit to avoid doing computations unnecessarily inside of there). So I think we have to keep doing things this way. Just an observation.

True. It is just inevitable that sometimes we make wheels for different needs :-)



---

archive/issue_comments_381819.json:
```json
{
    "body": "I find this quite wonderful!  It would be great if we could replace `LazyPowerSeries` with this.  One feature of `LazyPowerSeries` was that it allows recursive definitions \"guessing\" the correct initialisations, as for example in\n\n```\n            sage: L = LazyPowerSeriesRing(QQ)\n            sage: one = L(1)\n            sage: monom = L.gen()\n            sage: s = L()\n            sage: s._name = 's'\n            sage: s.define(one+monom*s*s)\n            sage: [s.coefficient(i) for i in range(6)]\n            [1, 1, 2, 5, 14, 42]\n```\n\nAlthough this is based on the original code by Ralf Hemmecke and myself, which in turn is based on code of Nicolas Thiery (I think), I am not sure anymore whether it is so important.  Of course, if we could have something similar, even better.",
    "created_at": "2019-04-09T11:24:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381819",
    "user": "mantepse"
}
```

I find this quite wonderful!  It would be great if we could replace `LazyPowerSeries` with this.  One feature of `LazyPowerSeries` was that it allows recursive definitions "guessing" the correct initialisations, as for example in

```
            sage: L = LazyPowerSeriesRing(QQ)
            sage: one = L(1)
            sage: monom = L.gen()
            sage: s = L()
            sage: s._name = 's'
            sage: s.define(one+monom*s*s)
            sage: [s.coefficient(i) for i in range(6)]
            [1, 1, 2, 5, 14, 42]
```

Although this is based on the original code by Ralf Hemmecke and myself, which in turn is based on code of Nicolas Thiery (I think), I am not sure anymore whether it is so important.  Of course, if we could have something similar, even better.



---

archive/issue_comments_381820.json:
```json
{
    "body": "One question with respect to equality.  It seems to me that your implementation of `__eq__` is quite brittle.  It is clear that one cannot have proper equality, so it should be clearly stated what it can do and what it can't.\n\nApart from that, in the case of truncation, one could make it exact easily.",
    "created_at": "2019-04-09T11:26:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381820",
    "user": "mantepse"
}
```

One question with respect to equality.  It seems to me that your implementation of `__eq__` is quite brittle.  It is clear that one cannot have proper equality, so it should be clearly stated what it can do and what it can't.

Apart from that, in the case of truncation, one could make it exact easily.



---

archive/issue_comments_381821.json:
```json
{
    "body": "Some other comments on the code:\n\nFor `__bool__`, I think erroring out immediately when `self._constant is None` is not the way to go. I think you should check the computed coefficients in that case to see if any of them are non-zero. If they are all `0`, then you should error out. Also, a fast first check when `self._constant` is not `None` is to see if that constant is non-zero `0`.\n\nIn `_repr_`, I do not see how `self.valuation()` would normally raise a `ValueError`. That method does not raise one, nor does `self.coefficient()` (the only other method it calls).\n\nInstead of `self.parent()(1)`, which calls the coercion framework, you should use `self.parent().one()`.\n\nAre you sure you want `_div_` to be two separate operations and not one combined one? I feel like the latter would be faster (at least since it is implemented at the Python level).\n\nActually, you may want to make the operator file into a Cython file (since is forms the key computational part and it is in a separate file).\n\nI think the truncate should return an honest Laurent polynomial. Furthermore, I don't think there are coercions (or at least conversions) from the corresponding Laurent polynomial ring. This feels like a very natural to have. I don't want to go too far with ticket expansion, but this feels like something people will try soon after having this.",
    "created_at": "2019-04-09T14:40:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381821",
    "user": "tscrim"
}
```

Some other comments on the code:

For `__bool__`, I think erroring out immediately when `self._constant is None` is not the way to go. I think you should check the computed coefficients in that case to see if any of them are non-zero. If they are all `0`, then you should error out. Also, a fast first check when `self._constant` is not `None` is to see if that constant is non-zero `0`.

In `_repr_`, I do not see how `self.valuation()` would normally raise a `ValueError`. That method does not raise one, nor does `self.coefficient()` (the only other method it calls).

Instead of `self.parent()(1)`, which calls the coercion framework, you should use `self.parent().one()`.

Are you sure you want `_div_` to be two separate operations and not one combined one? I feel like the latter would be faster (at least since it is implemented at the Python level).

Actually, you may want to make the operator file into a Cython file (since is forms the key computational part and it is in a separate file).

I think the truncate should return an honest Laurent polynomial. Furthermore, I don't think there are coercions (or at least conversions) from the corresponding Laurent polynomial ring. This feels like a very natural to have. I don't want to go too far with ticket expansion, but this feels like something people will try soon after having this.



---

archive/issue_comments_381822.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T04:49:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381822",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381823.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T04:54:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381823",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381824.json:
```json
{
    "body": "Replying to [comment:39 tscrim]:\n> For `__bool__`, I think erroring out immediately when `self._constant is None` is not the way to go. I think you should check the computed coefficients in that case to see if any of them are non-zero. If they are all `0`, then you should error out. \n\nGood idea. Done.\n\n> Also, a fast first check when `self._constant` is not `None` is to see if that constant is non-zero `0`.\n\nThis check is already there.\n\n> In `_repr_`, I do not see how `self.valuation()` would normally raise a `ValueError`. That method does not raise one, nor does `self.coefficient()` (the only other method it calls).\n\nRight. Fixed.\n\n\n> Instead of `self.parent()(1)`, which calls the coercion framework, you should use `self.parent().one()`.\n\nOk. Fixed.\n\n> Are you sure you want `_div_` to be two separate operations and not one combined one? I feel like the latter would be faster (at least since it is implemented at the Python level).\n\nI don't feel so. I don't see a way to implement series division such that 1 + 1 < 2 with a significant margin.\n\n> I think the truncate should return an honest Laurent polynomial. \n\nI don't agree. One might still want a truncated series  with laziness. For your cases, I added `polynomial` method to convert to an honest polynomial. \n\n>Furthermore, I don't think there are coercions (or at least conversions) from the corresponding Laurent polynomial ring. This feels like a very natural to have. I don't want to go too far with ticket expansion, but this feels like something people will try soon after having this.\n\nRight. I added coercions from (Laurent) polynomial rings.\n\n> Actually, you may want to make the operator file into a Cython file (since is forms the key computational part and it is in a separate file).\n\nHmm. I doubt if there would be significant speed boost, compensating increased build time (that I hate). Moreover I am not versed with Cython. So I don't want to do that, at least for this ticket. But if you do it, I would not object.",
    "created_at": "2019-04-10T05:14:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381824",
    "user": "klee"
}
```

Replying to [comment:39 tscrim]:
> For `__bool__`, I think erroring out immediately when `self._constant is None` is not the way to go. I think you should check the computed coefficients in that case to see if any of them are non-zero. If they are all `0`, then you should error out. 

Good idea. Done.

> Also, a fast first check when `self._constant` is not `None` is to see if that constant is non-zero `0`.

This check is already there.

> In `_repr_`, I do not see how `self.valuation()` would normally raise a `ValueError`. That method does not raise one, nor does `self.coefficient()` (the only other method it calls).

Right. Fixed.


> Instead of `self.parent()(1)`, which calls the coercion framework, you should use `self.parent().one()`.

Ok. Fixed.

> Are you sure you want `_div_` to be two separate operations and not one combined one? I feel like the latter would be faster (at least since it is implemented at the Python level).

I don't feel so. I don't see a way to implement series division such that 1 + 1 < 2 with a significant margin.

> I think the truncate should return an honest Laurent polynomial. 

I don't agree. One might still want a truncated series  with laziness. For your cases, I added `polynomial` method to convert to an honest polynomial. 

>Furthermore, I don't think there are coercions (or at least conversions) from the corresponding Laurent polynomial ring. This feels like a very natural to have. I don't want to go too far with ticket expansion, but this feels like something people will try soon after having this.

Right. I added coercions from (Laurent) polynomial rings.

> Actually, you may want to make the operator file into a Cython file (since is forms the key computational part and it is in a separate file).

Hmm. I doubt if there would be significant speed boost, compensating increased build time (that I hate). Moreover I am not versed with Cython. So I don't want to do that, at least for this ticket. But if you do it, I would not object.



---

archive/issue_comments_381825.json:
```json
{
    "body": "Replying to [comment:38 mantepse]:\n> One question with respect to equality.  It seems to me that your implementation of `__eq__` is quite brittle.  It is clear that one cannot have proper equality, so it should be clearly stated what it can do and what it can't.\n\nThe implementation gives an answer if possible without computing coefficients indefinitely. Otherwise raise an exception.\n\nI added a short explanation to the method. \n\n> Apart from that, in the case of truncation, one could make it exact easily.\n\nTruncation still gives a lazy series. I added `polynomial` method to convert to an exact polynomial.",
    "created_at": "2019-04-10T05:24:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381825",
    "user": "klee"
}
```

Replying to [comment:38 mantepse]:
> One question with respect to equality.  It seems to me that your implementation of `__eq__` is quite brittle.  It is clear that one cannot have proper equality, so it should be clearly stated what it can do and what it can't.

The implementation gives an answer if possible without computing coefficients indefinitely. Otherwise raise an exception.

I added a short explanation to the method. 

> Apart from that, in the case of truncation, one could make it exact easily.

Truncation still gives a lazy series. I added `polynomial` method to convert to an exact polynomial.



---

archive/issue_comments_381826.json:
```json
{
    "body": "Replying to [comment:37 mantepse]:\n> I find this quite wonderful!  It would be great if we could replace `LazyPowerSeries` with this.  One feature of `LazyPowerSeries` was that it allows recursive definitions \"guessing\" the correct initialisations, as for example in\n> {{{\n>             sage: L = LazyPowerSeriesRing(QQ)\n>             sage: one = L(1)\n>             sage: monom = L.gen()\n>             sage: s = L()\n>             sage: s._name = 's'\n>             sage: s.define(one+monom*s*s)\n>             sage: [s.coefficient(i) for i in range(6)]\n>             [1, 1, 2, 5, 14, 42]\n> }}}\n> Although this is based on the original code by Ralf Hemmecke and myself, which in turn is based on code of Nicolas Thiery (I think), I am not sure anymore whether it is so important.  Of course, if we could have something similar, even better.\n\nRecursive definition is possible as a result of being lazy and being power series. Now you can do the same in the following way:\n\n\n```\nsage: from sage.rings.lazy_laurent_series_ring import LazyLaurentSeriesRing\nsage: L = LazyLaurentSeriesRing(ZZ, 'z')\nsage: \nsage: z = L.gen()\nsage: def f(s,n):\n....:     return (1 + z*s^2).coefficient(n)\n....: \nsage: L.series(f, valuation=0)\n1 + z + 2*z^2 + 5*z^3 + 14*z^4 + 42*z^5 + 132*z^6 + ...\n```\n",
    "created_at": "2019-04-10T05:31:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381826",
    "user": "klee"
}
```

Replying to [comment:37 mantepse]:
> I find this quite wonderful!  It would be great if we could replace `LazyPowerSeries` with this.  One feature of `LazyPowerSeries` was that it allows recursive definitions "guessing" the correct initialisations, as for example in
> {{{
>             sage: L = LazyPowerSeriesRing(QQ)
>             sage: one = L(1)
>             sage: monom = L.gen()
>             sage: s = L()
>             sage: s._name = 's'
>             sage: s.define(one+monom*s*s)
>             sage: [s.coefficient(i) for i in range(6)]
>             [1, 1, 2, 5, 14, 42]
> }}}
> Although this is based on the original code by Ralf Hemmecke and myself, which in turn is based on code of Nicolas Thiery (I think), I am not sure anymore whether it is so important.  Of course, if we could have something similar, even better.

Recursive definition is possible as a result of being lazy and being power series. Now you can do the same in the following way:


```
sage: from sage.rings.lazy_laurent_series_ring import LazyLaurentSeriesRing
sage: L = LazyLaurentSeriesRing(ZZ, 'z')
sage: 
sage: z = L.gen()
sage: def f(s,n):
....:     return (1 + z*s^2).coefficient(n)
....: 
sage: L.series(f, valuation=0)
1 + z + 2*z^2 + 5*z^3 + 14*z^4 + 42*z^5 + 132*z^6 + ...
```




---

archive/issue_comments_381827.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T05:38:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381827",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381828.json:
```json
{
    "body": "> > Apart from that, in the case of truncation, one could make it exact easily.\n> \n> Truncation still gives a lazy series. I added `polynomial` method to convert to an exact polynomial.\n\nexcellent point! I missed that!",
    "created_at": "2019-04-10T05:56:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381828",
    "user": "mantepse"
}
```

> > Apart from that, in the case of truncation, one could make it exact easily.
> 
> Truncation still gives a lazy series. I added `polynomial` method to convert to an exact polynomial.

excellent point! I missed that!



---

archive/issue_comments_381829.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T07:01:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381829",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381830.json:
```json
{
    "body": "> > Are you sure you want `_div_` to be two separate operations and not one combined one? I feel like the latter would be faster (at least since it is implemented at the Python level).\n> \n> I don't feel so. I don't see a way to implement series division such that 1 + 1 < 2 with a significant margin.\n\nYou are right. I was wrong!",
    "created_at": "2019-04-10T07:02:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381830",
    "user": "klee"
}
```

> > Are you sure you want `_div_` to be two separate operations and not one combined one? I feel like the latter would be faster (at least since it is implemented at the Python level).
> 
> I don't feel so. I don't see a way to implement series division such that 1 + 1 < 2 with a significant margin.

You are right. I was wrong!



---

archive/issue_comments_381831.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T07:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381831",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381832.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T07:13:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381832",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381833.json:
```json
{
    "body": "Are composition and reversion planned in a later ticket?\n\nI am really looking forward to this!  I hope very much we can rebase the species code on it.  Should `LazyPowerSeriesRing` be a subclass?",
    "created_at": "2019-04-11T05:46:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381833",
    "user": "mantepse"
}
```

Are composition and reversion planned in a later ticket?

I am really looking forward to this!  I hope very much we can rebase the species code on it.  Should `LazyPowerSeriesRing` be a subclass?



---

archive/issue_comments_381834.json:
```json
{
    "body": "Replying to [comment:51 mantepse]:\n> Are composition and reversion planned in a later ticket?\n\nNot by me. Anyone is invited to add them in a later ticket.\n\n> I hope very much we can rebase the species code on it.  Should `LazyPowerSeriesRing` be a subclass?\n\nYes, in a separate file alongside with lazy Laurent series.  It would be great. I don't have a plan to do it in any short time, simply because I don't need it now.",
    "created_at": "2019-04-11T07:33:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381834",
    "user": "klee"
}
```

Replying to [comment:51 mantepse]:
> Are composition and reversion planned in a later ticket?

Not by me. Anyone is invited to add them in a later ticket.

> I hope very much we can rebase the species code on it.  Should `LazyPowerSeriesRing` be a subclass?

Yes, in a separate file alongside with lazy Laurent series.  It would be great. I don't have a plan to do it in any short time, simply because I don't need it now.



---

archive/issue_comments_381835.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-11T09:40:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381835",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381836.json:
```json
{
    "body": "Last little thing:\n\n`R(0)` -> `R.zero()` (as it is cached and `R` is always a `LazyLaurentSeriesRing`).\n\nOnce done you can set a positive review on my behalf.",
    "created_at": "2019-04-13T09:18:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381836",
    "user": "tscrim"
}
```

Last little thing:

`R(0)` -> `R.zero()` (as it is cached and `R` is always a `LazyLaurentSeriesRing`).

Once done you can set a positive review on my behalf.



---

archive/issue_comments_381837.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-13T11:26:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381837",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_381838.json:
```json
{
    "body": "Thank you, Travis!",
    "created_at": "2019-04-13T11:28:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381838",
    "user": "klee"
}
```

Thank you, Travis!



---

archive/issue_comments_381839.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-04-13T11:28:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381839",
    "user": "klee"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_381840.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-04-15T17:47:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381840",
    "user": "vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_381841.json:
```json
{
    "body": "Nice work! Follow-up ticket at #27694 for allowing syntactic sugar\n\n```\nsage: L.<x> = LazyLaurentSeriesRing(ZZ)\n```\n",
    "created_at": "2019-04-17T17:09:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27110",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27110#issuecomment-381841",
    "user": "slelievre"
}
```

Nice work! Follow-up ticket at #27694 for allowing syntactic sugar

```
sage: L.<x> = LazyLaurentSeriesRing(ZZ)
```

