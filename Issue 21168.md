# Issue 21168: Introduce extension of scalars coercion of CombinatorialFreeModules

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2016-09-02 23:11:11

CC:  sage-combinat nthiery darij

Keywords: combinatorial free module

Currently, `CombinatorialFreeModule` does not allow coercion from another `CombinatorialFreeModule` with the same indices but with a base ring coercion:

```sage
sage: C = CombinatorialFreeModule(ZZ, Set([1,2]))
sage: CQ = CombinatorialFreeModule(QQ, Set([1,2]))
sage: C.has_coerce_map_from(CQ)
False
```

We plan to introduce such a coercion.


---

Comment by darij created at 2016-09-02 23:12:56

Ah! That said, your example is backwards. :P


---

Comment by tscrim created at 2016-09-02 23:14:46

Changing status from new to needs_review.


---

Comment by tscrim created at 2016-09-02 23:14:46

New commits:


---

Comment by git created at 2016-09-03 03:48:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-09-03 03:49:37

See commit msg. Other than this, LGTM!


---

Comment by tscrim created at 2016-09-03 04:34:18

Nicolas, any comments or concerns? I would like your opinion on this before setting it to a positive review (Darij, I'm happy with your changes).


---

Comment by nthiery created at 2016-09-03 06:01:36

Hi Travis, Darij,

Thanks for investigating this! We definitely want to make it trivial
for the user to build the trivial morphism between C and Q, and to set
it up as conversion or coercion map.

Setting it up as coercion map by default is dangerous. I haven't
tried, but I believe that, with the current implementation, you could
get the wrong coercion map while doing things like:

```
    Sym = SymmetricFunctions(QQ)
    s = Sym().s(); p = Sym().p()
    s.an_element() + p.an_element()
```


Probably the above example actually works because we have a direct
coercion implemented between `s` and `p`; but imagine how wrong it
could get in other cases. Even a conversion could get dangerous if the
user does `p(s.an_element())`.

That applies also to plain CombinatorialFreeModule: the user may want
to create several of them modeling e.g. different bases on the same
abstract vector space, with non trivial canonical morphisms between
them.

The only exception I could see where the user explicitly requests a
coercion morphism is if `Q` has been constructed explicitly as
`C.extend_base_ring()`.

In general, in case of doubt, I tend to prefer to not set
coercion/conversion maps by default, and instead make it easy for
users to set them up. It's safer and easier to revert the decision
later than the converse.


About constructing the trivial morphism. This is already fairly easy
with `module_morphism`:


```
    sage: C = CombinatorialFreeModule(ZZ, [1,2,3])
    sage: Q = CombinatorialFreeModule(QQ, [1,2,3])
    sage: phi = C.module_morphism(Q.term, codomain=Q)
    sage: phi(C.an_element())
    2*B[1] + 2*B[2] + 3*B[3]
    sage: phi(C.an_element())[3].parent()
    Rational Field
```


This has the merit of being a very flexible idiom.

Still, we may want to improve this:

- Advertise more this feature in the documentation: the idiom is
  natural once a user has seen it once, but beginners will usually not
  immediately think about it.

- Further simplify the idiom: in MuPAD, we were detecting that Q.term
  had Q as codomain, so it was not needed to specify codomain=Q.
  (I am so much longing for Python 3 where we will finally be able to
  be explicit about the codomain of functions!).

- Constructing an optimized morphism by detecting that the function is
  of the form `Q.term`, and building e.g. a `DiagonalModuleMorphism`
  (see the comment in the code of `DiagonalModuleMorphism` about
  generalizing to a `mapcoeffs`).

Cheers


---

Comment by darij created at 2016-09-03 16:31:39

Changing status from needs_review to needs_work.


---

Comment by darij created at 2016-09-03 16:31:39

Ouch. This is bad! Thanks for the `Q.term` trick; it should indeed be better advertised!


---

Comment by tscrim created at 2016-09-03 16:58:49

Yes, that is a good point.

Perhaps a solution would be to implement a functor for extension of scalars (or at least `F_K(X) = K \otimes_R X`) that would create the corresponding `CombinatorialFreeModule` with the appropriate coercion, taking your idea a bit further. This shouldn't be too hard to get working.

We might have to fight against (and possibly remove) `UniqueRepresentation` part of `CombinatorialFreeModule` to have everything work.

I also agree that we could specialize this morphism too.


---

Comment by nthiery created at 2016-09-04 12:34:22

Replying to [comment:9 tscrim]:
> Perhaps a solution would be to implement a functor for extension of scalars (or at least `F_K(X) = K \otimes_R X`) that would create the corresponding `CombinatorialFreeModule` with the appropriate coercion, taking your idea a bit further. This shouldn't be too hard to get working.

Yup. For consistency with FreeModules and polynomial rings, we should use `K.base_extend(R)` and `K.change_ring(R)` for this.

> We might have to fight against (and possibly remove) `UniqueRepresentation` part of `CombinatorialFreeModule` to have everything work.

Probably not a problem; we have a "key" argument which is meant typically for such use cases (and would deserve more advertising in the doc ...):

```
    sage: V = CombinatorialFreeModule(ZZ, [1,2,3])
    sage: VQ = CombinatorialFreeModule(QQ, [1,2,3], key=("extends", V))
    sage: V2 = CombinatorialFreeModule(QQ, [1,2,3])
    sage: V2 is VQ
    False
```


I am more worried about the handling of subclasses of `CombinatorialFreeModule`, like e.g. `Sym.s`, where one will need:
- to figure out the proper way to call the constructor
- possibly recreate the parent with several realizations, ...


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-05-09 06:00:34

this can also be solved by #30235


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2022-08-31 03:34:54

In 9.7.rc0 (with #30235):

```
sage: C = CombinatorialFreeModule(ZZ, Set([1,2]))
sage: CQ = CombinatorialFreeModule(QQ, Set([1,2]))
sage: from sage.categories.pushout import pushout
sage: pushout(C, CQ) is CQ
True
sage: CQ.has_coerce_map_from(C)
False
```

