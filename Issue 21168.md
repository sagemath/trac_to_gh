# Issue 21168: Introduce extension of scalars coercion of CombinatorialFreeModules

archive/issues_021168.json:
```json
{
    "body": "CC:  sage-combinat nthiery darij\n\nKeywords: combinatorial free module\n\nCurrently, `CombinatorialFreeModule` does not allow coercion from another `CombinatorialFreeModule` with the same indices but with a base ring coercion:\n\n```sage\nsage: C = CombinatorialFreeModule(ZZ, Set([1,2]))\nsage: CQ = CombinatorialFreeModule(QQ, Set([1,2]))\nsage: C.has_coerce_map_from(CQ)\nFalse\n```\n\nWe plan to introduce such a coercion.\n\nIssue created by migration from https://trac.sagemath.org/ticket/21405\n\n",
    "created_at": "2016-09-02T23:11:11Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Introduce extension of scalars coercion of CombinatorialFreeModules",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21168",
    "user": "tscrim"
}
```
CC:  sage-combinat nthiery darij

Keywords: combinatorial free module

Currently, `CombinatorialFreeModule` does not allow coercion from another `CombinatorialFreeModule` with the same indices but with a base ring coercion:

```sage
sage: C = CombinatorialFreeModule(ZZ, Set([1,2]))
sage: CQ = CombinatorialFreeModule(QQ, Set([1,2]))
sage: C.has_coerce_map_from(CQ)
False
```

We plan to introduce such a coercion.

Issue created by migration from https://trac.sagemath.org/ticket/21405





---

archive/issue_comments_293304.json:
```json
{
    "body": "Ah! That said, your example is backwards. :P",
    "created_at": "2016-09-02T23:12:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293304",
    "user": "darij"
}
```

Ah! That said, your example is backwards. :P



---

archive/issue_comments_293305.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-09-02T23:14:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293305",
    "user": "tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_293306.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-09-02T23:14:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293306",
    "user": "tscrim"
}
```

New commits:



---

archive/issue_comments_293307.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-09-03T03:48:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293307",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293308.json:
```json
{
    "body": "See commit msg. Other than this, LGTM!",
    "created_at": "2016-09-03T03:49:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293308",
    "user": "darij"
}
```

See commit msg. Other than this, LGTM!



---

archive/issue_comments_293309.json:
```json
{
    "body": "Nicolas, any comments or concerns? I would like your opinion on this before setting it to a positive review (Darij, I'm happy with your changes).",
    "created_at": "2016-09-03T04:34:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293309",
    "user": "tscrim"
}
```

Nicolas, any comments or concerns? I would like your opinion on this before setting it to a positive review (Darij, I'm happy with your changes).



---

archive/issue_comments_293310.json:
```json
{
    "body": "Hi Travis, Darij,\n\nThanks for investigating this! We definitely want to make it trivial\nfor the user to build the trivial morphism between C and Q, and to set\nit up as conversion or coercion map.\n\nSetting it up as coercion map by default is dangerous. I haven't\ntried, but I believe that, with the current implementation, you could\nget the wrong coercion map while doing things like:\n\n```\n    Sym = SymmetricFunctions(QQ)\n    s = Sym().s(); p = Sym().p()\n    s.an_element() + p.an_element()\n```\n\n\nProbably the above example actually works because we have a direct\ncoercion implemented between `s` and `p`; but imagine how wrong it\ncould get in other cases. Even a conversion could get dangerous if the\nuser does `p(s.an_element())`.\n\nThat applies also to plain CombinatorialFreeModule: the user may want\nto create several of them modeling e.g. different bases on the same\nabstract vector space, with non trivial canonical morphisms between\nthem.\n\nThe only exception I could see where the user explicitly requests a\ncoercion morphism is if `Q` has been constructed explicitly as\n`C.extend_base_ring()`.\n\nIn general, in case of doubt, I tend to prefer to not set\ncoercion/conversion maps by default, and instead make it easy for\nusers to set them up. It's safer and easier to revert the decision\nlater than the converse.\n\n\nAbout constructing the trivial morphism. This is already fairly easy\nwith `module_morphism`:\n\n\n```\n    sage: C = CombinatorialFreeModule(ZZ, [1,2,3])\n    sage: Q = CombinatorialFreeModule(QQ, [1,2,3])\n    sage: phi = C.module_morphism(Q.term, codomain=Q)\n    sage: phi(C.an_element())\n    2*B[1] + 2*B[2] + 3*B[3]\n    sage: phi(C.an_element())[3].parent()\n    Rational Field\n```\n\n\nThis has the merit of being a very flexible idiom.\n\nStill, we may want to improve this:\n\n- Advertise more this feature in the documentation: the idiom is\n  natural once a user has seen it once, but beginners will usually not\n  immediately think about it.\n\n- Further simplify the idiom: in MuPAD, we were detecting that Q.term\n  had Q as codomain, so it was not needed to specify codomain=Q.\n  (I am so much longing for Python 3 where we will finally be able to\n  be explicit about the codomain of functions!).\n\n- Constructing an optimized morphism by detecting that the function is\n  of the form `Q.term`, and building e.g. a `DiagonalModuleMorphism`\n  (see the comment in the code of `DiagonalModuleMorphism` about\n  generalizing to a `mapcoeffs`).\n\nCheers",
    "created_at": "2016-09-03T06:01:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293310",
    "user": "nthiery"
}
```

Hi Travis, Darij,

Thanks for investigating this! We definitely want to make it trivial
for the user to build the trivial morphism between C and Q, and to set
it up as conversion or coercion map.

Setting it up as coercion map by default is dangerous. I haven't
tried, but I believe that, with the current implementation, you could
get the wrong coercion map while doing things like:

```
    Sym = SymmetricFunctions(QQ)
    s = Sym().s(); p = Sym().p()
    s.an_element() + p.an_element()
```


Probably the above example actually works because we have a direct
coercion implemented between `s` and `p`; but imagine how wrong it
could get in other cases. Even a conversion could get dangerous if the
user does `p(s.an_element())`.

That applies also to plain CombinatorialFreeModule: the user may want
to create several of them modeling e.g. different bases on the same
abstract vector space, with non trivial canonical morphisms between
them.

The only exception I could see where the user explicitly requests a
coercion morphism is if `Q` has been constructed explicitly as
`C.extend_base_ring()`.

In general, in case of doubt, I tend to prefer to not set
coercion/conversion maps by default, and instead make it easy for
users to set them up. It's safer and easier to revert the decision
later than the converse.


About constructing the trivial morphism. This is already fairly easy
with `module_morphism`:


```
    sage: C = CombinatorialFreeModule(ZZ, [1,2,3])
    sage: Q = CombinatorialFreeModule(QQ, [1,2,3])
    sage: phi = C.module_morphism(Q.term, codomain=Q)
    sage: phi(C.an_element())
    2*B[1] + 2*B[2] + 3*B[3]
    sage: phi(C.an_element())[3].parent()
    Rational Field
```


This has the merit of being a very flexible idiom.

Still, we may want to improve this:

- Advertise more this feature in the documentation: the idiom is
  natural once a user has seen it once, but beginners will usually not
  immediately think about it.

- Further simplify the idiom: in MuPAD, we were detecting that Q.term
  had Q as codomain, so it was not needed to specify codomain=Q.
  (I am so much longing for Python 3 where we will finally be able to
  be explicit about the codomain of functions!).

- Constructing an optimized morphism by detecting that the function is
  of the form `Q.term`, and building e.g. a `DiagonalModuleMorphism`
  (see the comment in the code of `DiagonalModuleMorphism` about
  generalizing to a `mapcoeffs`).

Cheers



---

archive/issue_comments_293311.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-09-03T16:31:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293311",
    "user": "darij"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_293312.json:
```json
{
    "body": "Ouch. This is bad! Thanks for the `Q.term` trick; it should indeed be better advertised!",
    "created_at": "2016-09-03T16:31:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293312",
    "user": "darij"
}
```

Ouch. This is bad! Thanks for the `Q.term` trick; it should indeed be better advertised!



---

archive/issue_comments_293313.json:
```json
{
    "body": "Yes, that is a good point.\n\nPerhaps a solution would be to implement a functor for extension of scalars (or at least `F_K(X) = K \\otimes_R X`) that would create the corresponding `CombinatorialFreeModule` with the appropriate coercion, taking your idea a bit further. This shouldn't be too hard to get working.\n\nWe might have to fight against (and possibly remove) `UniqueRepresentation` part of `CombinatorialFreeModule` to have everything work.\n\nI also agree that we could specialize this morphism too.",
    "created_at": "2016-09-03T16:58:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293313",
    "user": "tscrim"
}
```

Yes, that is a good point.

Perhaps a solution would be to implement a functor for extension of scalars (or at least `F_K(X) = K \otimes_R X`) that would create the corresponding `CombinatorialFreeModule` with the appropriate coercion, taking your idea a bit further. This shouldn't be too hard to get working.

We might have to fight against (and possibly remove) `UniqueRepresentation` part of `CombinatorialFreeModule` to have everything work.

I also agree that we could specialize this morphism too.



---

archive/issue_comments_293314.json:
```json
{
    "body": "Replying to [comment:9 tscrim]:\n> Perhaps a solution would be to implement a functor for extension of scalars (or at least `F_K(X) = K \\otimes_R X`) that would create the corresponding `CombinatorialFreeModule` with the appropriate coercion, taking your idea a bit further. This shouldn't be too hard to get working.\n\nYup. For consistency with FreeModules and polynomial rings, we should use `K.base_extend(R)` and `K.change_ring(R)` for this.\n\n> We might have to fight against (and possibly remove) `UniqueRepresentation` part of `CombinatorialFreeModule` to have everything work.\n\nProbably not a problem; we have a \"key\" argument which is meant typically for such use cases (and would deserve more advertising in the doc ...):\n\n```\n    sage: V = CombinatorialFreeModule(ZZ, [1,2,3])\n    sage: VQ = CombinatorialFreeModule(QQ, [1,2,3], key=(\"extends\", V))\n    sage: V2 = CombinatorialFreeModule(QQ, [1,2,3])\n    sage: V2 is VQ\n    False\n```\n\n\nI am more worried about the handling of subclasses of `CombinatorialFreeModule`, like e.g. `Sym.s`, where one will need:\n- to figure out the proper way to call the constructor\n- possibly recreate the parent with several realizations, ...",
    "created_at": "2016-09-04T12:34:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293314",
    "user": "nthiery"
}
```

Replying to [comment:9 tscrim]:
> Perhaps a solution would be to implement a functor for extension of scalars (or at least `F_K(X) = K \otimes_R X`) that would create the corresponding `CombinatorialFreeModule` with the appropriate coercion, taking your idea a bit further. This shouldn't be too hard to get working.

Yup. For consistency with FreeModules and polynomial rings, we should use `K.base_extend(R)` and `K.change_ring(R)` for this.

> We might have to fight against (and possibly remove) `UniqueRepresentation` part of `CombinatorialFreeModule` to have everything work.

Probably not a problem; we have a "key" argument which is meant typically for such use cases (and would deserve more advertising in the doc ...):

```
    sage: V = CombinatorialFreeModule(ZZ, [1,2,3])
    sage: VQ = CombinatorialFreeModule(QQ, [1,2,3], key=("extends", V))
    sage: V2 = CombinatorialFreeModule(QQ, [1,2,3])
    sage: V2 is VQ
    False
```


I am more worried about the handling of subclasses of `CombinatorialFreeModule`, like e.g. `Sym.s`, where one will need:
- to figure out the proper way to call the constructor
- possibly recreate the parent with several realizations, ...



---

archive/issue_comments_293315.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293315",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_293316.json:
```json
{
    "body": "this can also be solved by #30235",
    "created_at": "2021-05-09T06:00:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293316",
    "user": "mkoeppe"
}
```

this can also be solved by #30235



---

archive/issue_comments_293317.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293317",
    "user": "mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_comments_293318.json:
```json
{
    "body": "In 9.7.rc0 (with #30235):\n\n```\nsage: C = CombinatorialFreeModule(ZZ, Set([1,2]))\nsage: CQ = CombinatorialFreeModule(QQ, Set([1,2]))\nsage: from sage.categories.pushout import pushout\nsage: pushout(C, CQ) is CQ\nTrue\nsage: CQ.has_coerce_map_from(C)\nFalse\n```\n",
    "created_at": "2022-08-31T03:34:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21168",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21168#issuecomment-293318",
    "user": "mkoeppe"
}
```

In 9.7.rc0 (with #30235):

```
sage: C = CombinatorialFreeModule(ZZ, Set([1,2]))
sage: CQ = CombinatorialFreeModule(QQ, Set([1,2]))
sage: from sage.categories.pushout import pushout
sage: pushout(C, CQ) is CQ
True
sage: CQ.has_coerce_map_from(C)
False
```

