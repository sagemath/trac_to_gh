# Issue 22312: py3: change semantics of equality for real an complex interval fields

Issue created by migration from https://trac.sagemath.org/ticket/22549

Original creator: chapoton

Original creation time: 2017-03-08 10:20:56

CC:  tscrim jdemeyer aapitzsch dkrenn cheuberg behackl

The change is **required** for the transition to Python3.

Before (now), == means that both interval-numbers are exact and equal.

After, == means that both interval numbers have the same bounds.

In both cases, equality with an exact number holds only for another exact number.



---

Comment by chapoton created at 2017-03-08 10:23:47

Work in progress. In particular doc still needs to be adapted.
----
New commits:


---

Comment by jdemeyer created at 2017-03-08 11:30:12

Replying to [ticket:22549 chapoton]:
> The change is **required** for the transition to Python3.

Please elaborate.


---

Comment by dkrenn created at 2017-03-08 11:33:19

Replying to [ticket:22549 chapoton]:
> The change is **required** for the transition to Python3.
> 
> Before (now), == means that both interval-numbers are exact and equal.
> 
> After, == means that both interval numbers have the same bounds.
> 
> In both cases, equality with an exact number holds only for another exact number.

Why the change in the behavior of == **required** when switching to Python3?


---

Comment by chapoton created at 2017-03-08 12:40:55

For these interval-numbers, we absolutely need to get rid of the incompatible double comparison (cmp on one hand (currently lexicographic), and rich comparison (<,>,==,!=,<=,=>, currently with the semantics "all elements are related to all elements") on the other hand).

Right now "cmp" is used very deeply to make sure that objects have UniqueRepresentation or can be pickled correctly. In order for all this to work, we need to relax the richcmp behaviour of equality to match the current behaviour of equality with cmp.

An illustrating problem is the following : take an interval say (0.1,0.2). Pickle it. Load it again. According to the current rich comparison, it will not be equal to itself. This breaks **many** things.

If one of you think he can get quickly an alternative easy solution, I engage him or her to try. I can tell you that I did. IMHO, the current proposal is the least invasive solution.


---

Comment by jdemeyer created at 2017-03-08 12:46:20

Replying to [comment:5 chapoton]:
> For these interval-numbers, we absolutely need to get rid of the incompatible double comparison (cmp on one hand (currently lexicographic), and rich comparison (<,>,==,!=,<=,=>, currently with the semantics "all elements are related to all elements") on the other hand).

I agree. However, I would rather keep the current rich comparison and drop the old-style `cmp`.

> Right now "cmp" is used very deeply to make sure that objects have UniqueRepresentation

`UniqueRepresentation` deals with parents. Here we are talking about elements, so I don't see the issue.

> or can be pickled correctly.

How does pickling involve `cmp()`?

> An illustrating problem is the following : take an interval say (0.1,0.2). Pickle it. Load it again. According to the current rich comparison, it will not be equal to itself.

Feature, not a bug.

> This breaks **many** things.

Like what?


---

Comment by chapoton created at 2017-03-08 12:48:04

Just look at the patchbot reports of #22257


---

Comment by jdemeyer created at 2017-03-08 12:53:38

Replying to [comment:7 chapoton]:
> Just look at the patchbot reports of #22257

That just shows that #22257 should be fixed. I don't see why it would require to change the semantics of `==` on intervals.


---

Comment by chapoton created at 2017-03-08 12:58:29

#22257 tells you what happens if you replace current cmp behaviour by current richcmp behaviour. If you think you can repair all the breaking doctests there by doing something else, please try. I have not found any other solution.

The solution proposed here almost passes all tests. The few failing doctests are mostly expected due to the change of behaviour, and do no harm. There is one more complex failure related to composite of number fields. I would like to have the opinion of a  number theorist on this one.


---

Comment by chapoton created at 2017-03-08 13:08:43

This is really involved in unique representation and ComparisonById, because Number Fields (which are Parent) have embeddings (which are interval-numbers) that need to compare equal to themselves for the number fields to do the same.

For some triggered failures by using the current richcmp, see precisely this report:

https://patchbot.sagemath.org/log/22257/Ubuntu/16.04/x86_64/4.4.0-53-generic/petitbonum/2017-01-29%2003:55:48?short


---

Comment by cheuberg created at 2017-03-08 13:09:47

Replying to [comment:9 chapoton]:
> The solution proposed here almost passes all tests. The few failing doctests are mostly expected due to the change of behaviour, and do no harm. There is one more complex failure related to composite of number fields. I would like to have the opinion of a  number theorist on this one.

Tons of external code might be broken by this change of behaviour. Changing the semantics of `==` at this point is completely inacceptable for me.


---

Comment by jdemeyer created at 2017-03-08 13:09:57

Replying to [comment:9 chapoton]:
> #22257 tells you what happens if you replace current cmp behaviour by current richcmp behaviour.

Here is a constructive suggestion: essentially, what `cmp()` does on intervals is comparing the endpoints. So whenever you need to replace `cmp()` for intervals by rich comparison, use rich comparison on the endpoints. For example, you can replace

```
cmp(x, y) < 0
```

by

```
x.endpoints() < y.endpoints()
```


For `x.endpoints() == y.endpoints()`, it makes sense to define a new method `equals()` on intervals which does this.


---

Comment by jdemeyer created at 2017-03-08 13:10:19

Replying to [comment:11 cheuberg]:
> Tons of external code might be broken by this change of behaviour. Changing the semantics of `==` at this point is completely inacceptable for me.

+1


---

Comment by jdemeyer created at 2017-03-08 13:12:15

Replying to [comment:10 chapoton]:
> This is really involved in unique representation and ComparisonById, because Number Fields (which are Parent) have embeddings (which are interval-numbers) that need to compare equal to themselves for the number fields to do the same.

Could we replace checking for equality to checking for non-inequality instead?


---

Comment by chapoton created at 2017-03-08 13:15:28

Yes, guys, I understand your issues. Nevertheless, I have worked hard on the question, and this really stands in our way to python3. I do not think that this proposal is such a big change of behaviour. Maybe most equality tests between elements of RIF should involve an exact element, no ?

Transition to python3 is going to be painful, but you really appreciate that when spending a lot of time on this transition, as I did.


---

Comment by chapoton created at 2017-03-08 13:18:49

If I read the code correctly, the proposed behaviour is the same as the current behaviour for real and complex ball fields, so it should not be so bad.


---

Comment by jdemeyer created at 2017-03-08 13:25:10

Replying to [comment:15 chapoton]:
> Nevertheless, I have worked hard on the question, and this really stands in our way to python3.

So far, I totally agree.

> I do not think that this proposal is such a big change of behaviour.

I think it's a massive change of behaviour which really should not be done unless you have very good reasons (so far, I haven't seen such a reason).

> Maybe most equality tests between elements of RIF should involve an exact element, no ?

Probably yes.

> Transition to python3 is going to be painful, but you really appreciate that when spending a lot of time on this transition, as I did.

Again, I totally agree. Still, the fact that it's painful does not mean that we should go ahead with what you propose here.


---

Comment by jdemeyer created at 2017-03-08 13:27:17

Replying to [comment:16 chapoton]:
> the proposed behaviour is the same as the current behaviour for real and complex ball fields

This is simply not true:

```
sage: x = RIF.pi()
sage: x == x
False
sage: RBF(x) == RBF(x)
False
```



---

Comment by mmezzarobba created at 2017-03-08 13:28:47

Replying to [comment:12 jdemeyer]:
> For `x.endpoints() == y.endpoints()`, it makes sense to define a new method `equals()` on intervals which does this.

I'd suggest calling it `identical()`, for consistency with real and complex balls.


---

Comment by chapoton created at 2017-03-08 13:35:10

Indeed, I was wrong on that point. The doc of ball fields says

```
Two elements are equal if and only if they are the same object
or if both are exact and equal::
```

so that

```
sage: x=RBF(pi)
sage: x==x
True
```


Replying to [comment:18 jdemeyer]:
> Replying to [comment:16 chapoton]:
> > the proposed behaviour is the same as the current behaviour for real and complex ball fields
> 
> This is simply not true:
> {{{
> sage: x = RIF.pi()
> sage: x == x
> False
> sage: RBF(x) == RBF(x)
> False
> }}}


---

Comment by dkrenn created at 2017-03-08 13:59:46

Replying to [comment:13 jdemeyer]:
> Replying to [comment:11 cheuberg]:
> > Tons of external code might be broken by this change of behaviour. Changing the semantics of `==` at this point is completely inacceptable for me.
> 
> +1

+1 as well


---

Comment by chapoton created at 2017-03-08 15:59:09

Ok. It seems that the solution proposed here will not be accepted. I will now try to go back to #22257 and propose there another fix with no change to the == semantics.


---

Comment by tscrim created at 2017-03-08 16:54:10

I would say what needs to be fixed is what is stored as the caching key for number fields. In this case, it looks like the construction of said key, when given an element of RIF/RBF, should instead store the endpoints. The parent is reconstructible from that data and it doesn't involve the `x == x` being `False` issue.


---

Comment by jdemeyer created at 2017-03-09 09:19:43

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-03-09 09:19:50

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2017-03-09 09:24:56

yes, I agree, you can close as wontfix


---

Comment by mmezzarobba created at 2017-03-12 11:13:01

Replying to [comment:12 jdemeyer]:
> Here is a constructive suggestion: essentially, what `cmp()` does on intervals is comparing the endpoints.

Note however that we have:

```
sage: cmp(RIF(1/3), RIF('nan'))
0
```

IMO this is a bug or at least a misfeature of the current `_cmp_()`, but who knows what might rely on it... (I had code that did by accident.)


---

Comment by embray created at 2017-07-13 07:54:31

Resolution: wontfix


---

Comment by embray created at 2017-07-13 07:54:31

Closing tickets in the sage-duplicate/invalid/wontfix module with positive_review (i.e. someone has confirmed they should be closed).
