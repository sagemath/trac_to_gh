# Issue 18363: Fix several methods for sparse polynomials

archive/issues_018363.json:
```json
{
    "body": "Keywords: sparse polynomial\n\nIn tickets #18518 and #18585, I've fixed some problems in two methods of the class `Polynomial` to make them work with high-degree sparse polynomials. Globally, many methods in this class are written with dense polynomials (or at least low-degree polynomials) in mind. \n\nThe purpose of this ticket is to provide easy fixes for many of these methods. The list of the methods I've treated is:\n- `denominator` in #18518\n- `_cmp_` in #18585\n- `integral`\n- `is_nilpotent`\n- `padded_list`\n- `newton_slopes`\n- `reverse`\n- `shift`\n- `truncate`\n- `norm`\n\nFor `integral`, I also correct some bug that affects all polynomials (dense as well as sparse).\n\n**Note.** This is a work in progress.\n\nIssue created by migration from https://trac.sagemath.org/ticket/18600\n\n",
    "created_at": "2015-06-03T13:46:50Z",
    "labels": [
        "commutative algebra",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "Fix several methods for sparse polynomials",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18363",
    "user": "@bgrenet"
}
```
Keywords: sparse polynomial

In tickets #18518 and #18585, I've fixed some problems in two methods of the class `Polynomial` to make them work with high-degree sparse polynomials. Globally, many methods in this class are written with dense polynomials (or at least low-degree polynomials) in mind. 

The purpose of this ticket is to provide easy fixes for many of these methods. The list of the methods I've treated is:
- `denominator` in #18518
- `_cmp_` in #18585
- `integral`
- `is_nilpotent`
- `padded_list`
- `newton_slopes`
- `reverse`
- `shift`
- `truncate`
- `norm`

For `integral`, I also correct some bug that affects all polynomials (dense as well as sparse).

**Note.** This is a work in progress.

Issue created by migration from https://trac.sagemath.org/ticket/18600





---

archive/issue_comments_249294.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-06-03T14:24:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249294",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_249295.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-06-03T14:37:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249295",
    "user": "@bgrenet"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_249296.json:
```json
{
    "body": "Hello,\n\nSome technical comments:\n\n* `integral`\n\n    What about `Q = self.base_ring().fraction_field()` instead of `Q = (self.constant_coefficient()/1).parent()`?\n\n    The `.change_ring` method is very slow but this has nothing to do with this ticket.\n\n* `is_unit`\n\n    Why do you care that the base ring being an integral domain? Is `1` not a unit in `Z/4Z`? Sage thinks it is\n\n```\nsage: Zmod(4)(1).is_unit()\nTrue\n```\n\n\n* `reverse`\n\n    You can use `for k,v in self.__coeffs.iteritems()`\n\n* `integral` for sparse\n\n    idem: use `iteritems`. In other words, replace\n\n```\nQ({k:self.__coeffs[k].integral(var) for k in self.__coeffs.keys()})\n```\n\n    with\n\n```\nQ({k:v.integral(var) for k,v in self.__coeffs.iteritems()})\n```\n\n   I found strange that in one case you defined the dictionary `d` and then `return Q(d)` while in the other you do everything at once.\n\nVincent",
    "created_at": "2015-08-03T16:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249296",
    "user": "@videlec"
}
```

Hello,

Some technical comments:

* `integral`

    What about `Q = self.base_ring().fraction_field()` instead of `Q = (self.constant_coefficient()/1).parent()`?

    The `.change_ring` method is very slow but this has nothing to do with this ticket.

* `is_unit`

    Why do you care that the base ring being an integral domain? Is `1` not a unit in `Z/4Z`? Sage thinks it is

```
sage: Zmod(4)(1).is_unit()
True
```


* `reverse`

    You can use `for k,v in self.__coeffs.iteritems()`

* `integral` for sparse

    idem: use `iteritems`. In other words, replace

```
Q({k:self.__coeffs[k].integral(var) for k in self.__coeffs.keys()})
```

    with

```
Q({k:v.integral(var) for k,v in self.__coeffs.iteritems()})
```

   I found strange that in one case you defined the dictionary `d` and then `return Q(d)` while in the other you do everything at once.

Vincent



---

archive/issue_comments_249297.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-03T16:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249297",
    "user": "@videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_249298.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-04T09:47:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249298",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_249299.json:
```json
{
    "body": "Replying to [comment:3 vdelecroix]:\n> * `integral`\n> \n>     What about `Q = self.base_ring().fraction_field()` instead of `Q = (self.constant_coefficient()/1).parent()`?\n \nRight, I do not remember why I wrote it in such a weird way... Corrected!\n \n> \n>     The `.change_ring` method is very slow but this has nothing to do with this ticket.\n \nAnd actually, a large part is already taken to simply build the new polynomial ring. For instance, on my laptop, `change_ring` takes approximately 12\u00b5s, of which 9\u00b5s are taken for building the new `PolynomialRing`. Yet the extra 3\u00b5s shouldn't exist...\n \n> \n> * `is_unit`\n> \n>     Why do you care that the base ring being an integral domain? Is `1` not a unit in `Z/4Z`? Sage thinks it is\n> {{{\n> sage: Zmod(4)(1).is_unit()\n> True\n> }}}\n \nYou may have overlooked the code: If the base ring is an integral domain and the input polynomial has degree > 0, it cannot be a unit so I directly return `False`. I test the nilpotency of the coefficients only if the base ring is not an integral domain.\n \n> * `reverse`\n> \n>     You can use `for k,v in self.__coeffs.iteritems()`\n> \n> * `integral` for sparse\n> \n>     idem: use `iteritems`. In other words, replace\n> {{{\n> Q({k:self.__coeffs[k].integral(var) for k in self.__coeffs.keys()})\n> }}}\n>     with\n> {{{\n> Q({k:v.integral(var) for k,v in self.__coeffs.iteritems()})\n> }}}\n>    I found strange that in one case you defined the dictionary `d` and then `return Q(d)` while in the other you do everything at once.\n \nComments taken into account.",
    "created_at": "2015-08-04T09:54:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249299",
    "user": "@bgrenet"
}
```

Replying to [comment:3 vdelecroix]:
> * `integral`
> 
>     What about `Q = self.base_ring().fraction_field()` instead of `Q = (self.constant_coefficient()/1).parent()`?
 
Right, I do not remember why I wrote it in such a weird way... Corrected!
 
> 
>     The `.change_ring` method is very slow but this has nothing to do with this ticket.
 
And actually, a large part is already taken to simply build the new polynomial ring. For instance, on my laptop, `change_ring` takes approximately 12µs, of which 9µs are taken for building the new `PolynomialRing`. Yet the extra 3µs shouldn't exist...
 
> 
> * `is_unit`
> 
>     Why do you care that the base ring being an integral domain? Is `1` not a unit in `Z/4Z`? Sage thinks it is
> {{{
> sage: Zmod(4)(1).is_unit()
> True
> }}}
 
You may have overlooked the code: If the base ring is an integral domain and the input polynomial has degree > 0, it cannot be a unit so I directly return `False`. I test the nilpotency of the coefficients only if the base ring is not an integral domain.
 
> * `reverse`
> 
>     You can use `for k,v in self.__coeffs.iteritems()`
> 
> * `integral` for sparse
> 
>     idem: use `iteritems`. In other words, replace
> {{{
> Q({k:self.__coeffs[k].integral(var) for k in self.__coeffs.keys()})
> }}}
>     with
> {{{
> Q({k:v.integral(var) for k,v in self.__coeffs.iteritems()})
> }}}
>    I found strange that in one case you defined the dictionary `d` and then `return Q(d)` while in the other you do everything at once.
 
Comments taken into account.



---

archive/issue_comments_249300.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-04T09:54:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249300",
    "user": "@bgrenet"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_249301.json:
```json
{
    "body": "Hello,\n\nFor non integral domain, there are some failures for `integral`\n\n```\nsage: x = polygen(Zmod(4))\nsage: p = x**4 + 1\nsage: p.integral()\nTraceback (most recent call last):\n...\nZeroDivisionError: Inverse does not exist.\n```\n\nAnd for more complicated rings as well\n\n```\nsage: Sx.<x> = ZZ[]\nsage: Sxy.<y> = Sx[]\nsage: Sxyz.<z> = Sxy[]\nsage: p = 1 + x*y + x*z + y*z^2\nsage: p.integral(y)\nTraceback (most recent call last):\n...\nTypeError: no conversion of this rational to integer\n```\n\nMoreover, you kept the `self.constant_coefficient()/1`. In some cases (like the one above) there is no fraction field, so it makes sense to ask for the result of the division. But this is also accessible from the coercion model\n\n```\nsage: cm = get_coercion_model()\nsage: cm.division_parent(ZZ)\nRational Field\nsage: cm.division_parent(Zmod(4))\nRing of integers modulo 4\n```\n\nThat way you avoid a useless division (and a coercion since you used `1` instead of `base_ring.one()`).\n\nThat being said, there are plenty of broken thing in the coercion model. I ended up with a relatively robust solution but not ideal. In order to be improved, one has to work more on the coercion model and the polynomial division.\n\nTell me what you think.\n\nVincent\n----\nNew commits:",
    "created_at": "2015-08-07T20:06:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249301",
    "user": "@videlec"
}
```

Hello,

For non integral domain, there are some failures for `integral`

```
sage: x = polygen(Zmod(4))
sage: p = x**4 + 1
sage: p.integral()
Traceback (most recent call last):
...
ZeroDivisionError: Inverse does not exist.
```

And for more complicated rings as well

```
sage: Sx.<x> = ZZ[]
sage: Sxy.<y> = Sx[]
sage: Sxyz.<z> = Sxy[]
sage: p = 1 + x*y + x*z + y*z^2
sage: p.integral(y)
Traceback (most recent call last):
...
TypeError: no conversion of this rational to integer
```

Moreover, you kept the `self.constant_coefficient()/1`. In some cases (like the one above) there is no fraction field, so it makes sense to ask for the result of the division. But this is also accessible from the coercion model

```
sage: cm = get_coercion_model()
sage: cm.division_parent(ZZ)
Rational Field
sage: cm.division_parent(Zmod(4))
Ring of integers modulo 4
```

That way you avoid a useless division (and a coercion since you used `1` instead of `base_ring.one()`).

That being said, there are plenty of broken thing in the coercion model. I ended up with a relatively robust solution but not ideal. In order to be improved, one has to work more on the coercion model and the polynomial division.

Tell me what you think.

Vincent
----
New commits:



---

archive/issue_comments_249302.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-08-07T20:06:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249302",
    "user": "@videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_249303.json:
```json
{
    "body": "The coercion model is really something I do not understand yet in Sage, so I trust what you wrote. Simply, in the following change, isn't it faster (and cleaner to some extent) to first define the underlying list of coefficients rather than defining the zero polynomial before adding monomials to it? \n\n\n```diff\n-        coeffs = self.list()\n-        v = [0] + [coeffs[n]/(n+1) for n from 0 <= n <= degree]\n-        return S(v)\n+        p = S.zero()\n+        for n in range(degree+1):\n+            if self[n]:\n+                p += cm.bin_op(Q(self[n]), n+1, operator.div) * S.gen()**(n+1)\n+        return p\n```\n\n\nWhat about something as the following?\n\n```python\n    coeffs = [self.zero()] * (degree + 2)\n    for n in range(degree+1):\n        if self[n]:\n            coeffs[n+1] = cm.bin_op(Q(self[n]), n+1, operator.div)\n    return S(coeffs)\n```\n\n\n*Note. I'm going in vacations and won't be able to interact much until August 24.*",
    "created_at": "2015-08-08T07:35:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249303",
    "user": "@bgrenet"
}
```

The coercion model is really something I do not understand yet in Sage, so I trust what you wrote. Simply, in the following change, isn't it faster (and cleaner to some extent) to first define the underlying list of coefficients rather than defining the zero polynomial before adding monomials to it? 


```diff
-        coeffs = self.list()
-        v = [0] + [coeffs[n]/(n+1) for n from 0 <= n <= degree]
-        return S(v)
+        p = S.zero()
+        for n in range(degree+1):
+            if self[n]:
+                p += cm.bin_op(Q(self[n]), n+1, operator.div) * S.gen()**(n+1)
+        return p
```


What about something as the following?

```python
    coeffs = [self.zero()] * (degree + 2)
    for n in range(degree+1):
        if self[n]:
            coeffs[n+1] = cm.bin_op(Q(self[n]), n+1, operator.div)
    return S(coeffs)
```


*Note. I'm going in vacations and won't be able to interact much until August 24.*



---

archive/issue_comments_249304.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-08T21:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249304",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_249305.json:
```json
{
    "body": "The current branch passes all the tests. As far as I can tell, this ticket can now be positive reviewed. Is it appropriate if I set it myself? I am quite reluctant since I wrote most of the code, and also sine you didn't set it to `needs_review`.",
    "created_at": "2015-08-26T13:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249305",
    "user": "@bgrenet"
}
```

The current branch passes all the tests. As far as I can tell, this ticket can now be positive reviewed. Is it appropriate if I set it myself? I am quite reluctant since I wrote most of the code, and also sine you didn't set it to `needs_review`.



---

archive/issue_comments_249306.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-09-04T00:14:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249306",
    "user": "@videlec"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_249307.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-04T00:30:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249307",
    "user": "@videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_249308.json:
```json
{
    "body": "- `The integral is always chosen so the constant term is 0.` -> `... so that ...`\n- inconsistency between dense and sparse\n\n```\nsage: R.<x> = PolynomialRing(Zmod(4), sparse=False)\nsage: p = x**4 + 1\nsage: p.integral()\nx^5 + x\nsage: R.<x> = PolynomialRing(Zmod(4), sparse=True)\nsage: p = x**4 + 1\nsage: p.integral()\nTraceback (most recent call last):\n...\nTypeError: self must be an integral domain.\n```\n",
    "created_at": "2015-09-04T00:30:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249308",
    "user": "@videlec"
}
```

- `The integral is always chosen so the constant term is 0.` -> `... so that ...`
- inconsistency between dense and sparse

```
sage: R.<x> = PolynomialRing(Zmod(4), sparse=False)
sage: p = x**4 + 1
sage: p.integral()
x^5 + x
sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
sage: p = x**4 + 1
sage: p.integral()
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
```




---

archive/issue_comments_249309.json:
```json
{
    "body": "Replying to [comment:11 vdelecroix]:\n> - inconsistency between dense and sparse\n> {{{\n> sage: R.<x> = PolynomialRing(Zmod(4), sparse=False)\n> sage: p = x**4 + 1\n> sage: p.integral()\n> x^5 + x\n> sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)\n> sage: p = x**4 + 1\n> sage: p.integral()\n> Traceback (most recent call last):\n> ...\n> TypeError: self must be an integral domain.\n> }}}\n\nRight, I should mimick what you did for the dense case. Before I do this, I actually have a question on what you wrote:\n\n```python\n        cm = sage.structure.element.get_coercion_model()\n        try:\n            S = cm.bin_op(R.one(), ZZ.one(), operator.div).parent()\n            Q = S.base_ring()\n        except TypeError:\n            Q = (R.base_ring().one()/ZZ.one()).parent()\n            S = R.change_ring(Q)\n```\n\nI don't get what you consider `ZZ.one()` instead of `R.one()` or even better `R.base_ring.one()`. I have the following behavior:\n\n```python\nsage: R.<x> = Zmod(4)[]\nsage: cm.bin_op(R.one(),ZZ.one(),operator.div).parent()\nTraceback (most recent call last):\n...\nTypeError: self must be an integral domain.\nsage: cm.bin_op(R.one(),R.one(),operator.div).parent()\nTraceback (most recent call last):\n...\nTypeError: self must be an integral domain.\nsage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()\nUnivariate Polynomial Ring in x over Ring of integers modulo 4\n```\n\n\nand\n\n\n```python\nsage: R.<x> = ZZ[]\nsage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()\nUnivariate Polynomial Ring in x over Rational Field\nsage: R.<x> = ZZ['y'][]\nsage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()\nUnivariate Polynomial Ring in x over Fraction Field of Univariate Polynomial Ring in y over Integer Ring\n```\n\n\nIf I understand correctly, using `R.base_ring.one()` may fix the issue of your `TODO`. What do you think of this?",
    "created_at": "2015-09-04T09:11:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249309",
    "user": "@bgrenet"
}
```

Replying to [comment:11 vdelecroix]:
> - inconsistency between dense and sparse
> {{{
> sage: R.<x> = PolynomialRing(Zmod(4), sparse=False)
> sage: p = x**4 + 1
> sage: p.integral()
> x^5 + x
> sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
> sage: p = x**4 + 1
> sage: p.integral()
> Traceback (most recent call last):
> ...
> TypeError: self must be an integral domain.
> }}}

Right, I should mimick what you did for the dense case. Before I do this, I actually have a question on what you wrote:

```python
        cm = sage.structure.element.get_coercion_model()
        try:
            S = cm.bin_op(R.one(), ZZ.one(), operator.div).parent()
            Q = S.base_ring()
        except TypeError:
            Q = (R.base_ring().one()/ZZ.one()).parent()
            S = R.change_ring(Q)
```

I don't get what you consider `ZZ.one()` instead of `R.one()` or even better `R.base_ring.one()`. I have the following behavior:

```python
sage: R.<x> = Zmod(4)[]
sage: cm.bin_op(R.one(),ZZ.one(),operator.div).parent()
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
sage: cm.bin_op(R.one(),R.one(),operator.div).parent()
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
sage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()
Univariate Polynomial Ring in x over Ring of integers modulo 4
```


and


```python
sage: R.<x> = ZZ[]
sage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()
Univariate Polynomial Ring in x over Rational Field
sage: R.<x> = ZZ['y'][]
sage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()
Univariate Polynomial Ring in x over Fraction Field of Univariate Polynomial Ring in y over Integer Ring
```


If I understand correctly, using `R.base_ring.one()` may fix the issue of your `TODO`. What do you think of this?



---

archive/issue_comments_249310.json:
```json
{
    "body": "Actually, this yields other problems... And with my proposal, you get the following behavior which may not be wanted:\n\n\n```python\nsage: A.<a1, a2> = PolynomialRing(ZZ)\nsage: B.<b> = PolynomialRing(A)\nsage: C.<c> = PowerSeriesRing(B)\nsage: R.<x> = PolynomialRing(C)\nsage: f = a2*x^2 + c*x - a1*b\nsage: f.parent()\nUnivariate Polynomial Ring in x over Power Series Ring in c over Univariate Polynomial Ring in b over Multivariate Polynomial Ring in a1, a2 over Integer Ring\nsage: f.integral().parent()\nUnivariate Polynomial Ring in x over Fraction Field of Power Series Ring in c over Univariate Polynomial Ring in b over Multivariate Polynomial Ring in a1, a2 over Integer Ring\n```\n",
    "created_at": "2015-09-04T13:55:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249310",
    "user": "@bgrenet"
}
```

Actually, this yields other problems... And with my proposal, you get the following behavior which may not be wanted:


```python
sage: A.<a1, a2> = PolynomialRing(ZZ)
sage: B.<b> = PolynomialRing(A)
sage: C.<c> = PowerSeriesRing(B)
sage: R.<x> = PolynomialRing(C)
sage: f = a2*x^2 + c*x - a1*b
sage: f.parent()
Univariate Polynomial Ring in x over Power Series Ring in c over Univariate Polynomial Ring in b over Multivariate Polynomial Ring in a1, a2 over Integer Ring
sage: f.integral().parent()
Univariate Polynomial Ring in x over Fraction Field of Power Series Ring in c over Univariate Polynomial Ring in b over Multivariate Polynomial Ring in a1, a2 over Integer Ring
```




---

archive/issue_comments_249311.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-04T14:25:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249311",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_249312.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-04T14:27:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249312",
    "user": "@bgrenet"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_249313.json:
```json
{
    "body": "- ` if not isinstance(degree, int) and not isinstance(degree, Integer)` -> `not isinstance(degree, (int,Integer))`.\n\n- after `OUTPUT:` in the docstring of `newton_slopes` you should add a line break\n\n- you can do one liners (you are not obliged though)\n\n```\nd = {degree-k: v for k,v in self.__coeffs.iteritems() if degree >= k}\n```\n\n\n- why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?",
    "created_at": "2015-09-04T17:16:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249313",
    "user": "@videlec"
}
```

- ` if not isinstance(degree, int) and not isinstance(degree, Integer)` -> `not isinstance(degree, (int,Integer))`.

- after `OUTPUT:` in the docstring of `newton_slopes` you should add a line break

- you can do one liners (you are not obliged though)

```
d = {degree-k: v for k,v in self.__coeffs.iteritems() if degree >= k}
```


- why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?



---

archive/issue_comments_249314.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-04T17:16:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249314",
    "user": "@videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_249315.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-08T13:27:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249315",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_249316.json:
```json
{
    "body": "When writing a comment like this\n\n```\n# But it does not work in all cases!!\n```\n\nyou should be explicit about the cases where it does not work. Just saying \"it sometimes does not work\" is not sufficient justification.",
    "created_at": "2015-09-08T13:32:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249316",
    "user": "@jdemeyer"
}
```

When writing a comment like this

```
# But it does not work in all cases!!
```

you should be explicit about the cases where it does not work. Just saying "it sometimes does not work" is not sufficient justification.



---

archive/issue_comments_249317.json:
```json
{
    "body": "Replying to [comment:16 vdelecroix]:\n> - ` if not isinstance(degree, int) and not isinstance(degree, Integer)` -> `not isinstance(degree, (int,Integer))`.\n\nDone.\n\n> - after `OUTPUT:` in the docstring of `newton_slopes` you should add a line break\n\nDone.\n\n> - you can do one liners (you are not obliged though)\n> {{{\n> d = {degree-k: v for k,v in self.__coeffs.iteritems() if degree >= k}\n> }}}\n\nDone.\n \n> - why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?\n\nThe rationale is that for very sparse polynomials, one may want to get the newton slopes in a \"compressed\" format, that is as a list of segments defined by their slope and length rather than as a (very long) list of length-1 segments solely defined by their slope. I decided to implement this \"compressed\" output for sparse polynomials only since this feature seem(ed) mostly useful for sparse polynomials. \n\nA modification I could do is to move my implementation in the `Polynomial` class. Do yo think it would be the right thing to do?",
    "created_at": "2015-09-08T13:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249317",
    "user": "@bgrenet"
}
```

Replying to [comment:16 vdelecroix]:
> - ` if not isinstance(degree, int) and not isinstance(degree, Integer)` -> `not isinstance(degree, (int,Integer))`.

Done.

> - after `OUTPUT:` in the docstring of `newton_slopes` you should add a line break

Done.

> - you can do one liners (you are not obliged though)
> {{{
> d = {degree-k: v for k,v in self.__coeffs.iteritems() if degree >= k}
> }}}

Done.
 
> - why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?

The rationale is that for very sparse polynomials, one may want to get the newton slopes in a "compressed" format, that is as a list of segments defined by their slope and length rather than as a (very long) list of length-1 segments solely defined by their slope. I decided to implement this "compressed" output for sparse polynomials only since this feature seem(ed) mostly useful for sparse polynomials. 

A modification I could do is to move my implementation in the `Polynomial` class. Do yo think it would be the right thing to do?



---

archive/issue_comments_249318.json:
```json
{
    "body": "Replying to [comment:19 bruno]:\n> Replying to [comment:16 vdelecroix]:\n> > - why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?\n> \n> The rationale is that for very sparse polynomials, one may want to get the newton slopes in a \"compressed\" format, that is as a list of segments defined by their slope and length rather than as a (very long) list of length-1 segments solely defined by their slope. I decided to implement this \"compressed\" output for sparse polynomials only since this feature seem(ed) mostly useful for sparse polynomials. \n> \n> A modification I could do is to move my implementation in the `Polynomial` class. Do yo think it would be the right thing to do?\n\nI understand the need of the argument. But if it also makes sense at the level of `Polynomial` then yes, do it there. That way there will only be one implementation and one signature.\n\nVincent",
    "created_at": "2015-09-08T23:20:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249318",
    "user": "@videlec"
}
```

Replying to [comment:19 bruno]:
> Replying to [comment:16 vdelecroix]:
> > - why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?
> 
> The rationale is that for very sparse polynomials, one may want to get the newton slopes in a "compressed" format, that is as a list of segments defined by their slope and length rather than as a (very long) list of length-1 segments solely defined by their slope. I decided to implement this "compressed" output for sparse polynomials only since this feature seem(ed) mostly useful for sparse polynomials. 
> 
> A modification I could do is to move my implementation in the `Polynomial` class. Do yo think it would be the right thing to do?

I understand the need of the argument. But if it also makes sense at the level of `Polynomial` then yes, do it there. That way there will only be one implementation and one signature.

Vincent



---

archive/issue_comments_249319.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-09T09:03:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249319",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_249320.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-09T09:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249320",
    "user": "@bgrenet"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_249321.json:
```json
{
    "body": "I moved the implementation to `Polynomial`. It actually make more sense.",
    "created_at": "2015-09-09T09:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249321",
    "user": "@bgrenet"
}
```

I moved the implementation to `Polynomial`. It actually make more sense.



---

archive/issue_comments_249322.json:
```json
{
    "body": "Let it go. These are nice improvements to sparse polynomials. Thanks.",
    "created_at": "2015-09-15T01:06:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249322",
    "user": "@videlec"
}
```

Let it go. These are nice improvements to sparse polynomials. Thanks.



---

archive/issue_comments_249323.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-09-15T01:06:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249323",
    "user": "@videlec"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_249324.json:
```json
{
    "body": "Thanks for the help!",
    "created_at": "2015-09-15T09:03:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249324",
    "user": "@bgrenet"
}
```

Thanks for the help!



---

archive/issue_comments_249325.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-09-15T22:30:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18363",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18363#issuecomment-249325",
    "user": "@vbraun"
}
```

Resolution: fixed
