# Issue 18363: Fix several methods for sparse polynomials

Issue created by migration from Trac.

Original creator: bruno

Original creation time: 2015-06-03 13:46:50

Keywords: sparse polynomial

In tickets #18518 and #18585, I've fixed some problems in two methods of the class `Polynomial` to make them work with high-degree sparse polynomials. Globally, many methods in this class are written with dense polynomials (or at least low-degree polynomials) in mind. 

The purpose of this ticket is to provide easy fixes for many of these methods. The list of the methods I've treated is:
- `denominator` in #18518
- `_cmp_` in #18585
- `integral`
- `is_nilpotent`
- `padded_list`
- `newton_slopes`
- `reverse`
- `shift`
- `truncate`
- `norm`

For `integral`, I also correct some bug that affects all polynomials (dense as well as sparse).

**Note.** This is a work in progress.


---

Comment by git created at 2015-06-03 14:24:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-06-03 14:37:44

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2015-08-03 16:28:34

Hello,

Some technical comments:

* `integral`

    What about `Q = self.base_ring().fraction_field()` instead of `Q = (self.constant_coefficient()/1).parent()`?

    The `.change_ring` method is very slow but this has nothing to do with this ticket.

* `is_unit`

    Why do you care that the base ring being an integral domain? Is `1` not a unit in `Z/4Z`? Sage thinks it is

```
sage: Zmod(4)(1).is_unit()
True
```


* `reverse`

    You can use `for k,v in self.__coeffs.iteritems()`

* `integral` for sparse

    idem: use `iteritems`. In other words, replace

```
Q({k:self.__coeffs[k].integral(var) for k in self.__coeffs.keys()})
```

    with

```
Q({k:v.integral(var) for k,v in self.__coeffs.iteritems()})
```

   I found strange that in one case you defined the dictionary `d` and then `return Q(d)` while in the other you do everything at once.

Vincent


---

Comment by vdelecroix created at 2015-08-03 16:28:34

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-08-04 09:47:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-08-04 09:54:16

Replying to [comment:3 vdelecroix]:
> * `integral`
> 
>     What about `Q = self.base_ring().fraction_field()` instead of `Q = (self.constant_coefficient()/1).parent()`?
 
Right, I do not remember why I wrote it in such a weird way... Corrected!
 
> 
>     The `.change_ring` method is very slow but this has nothing to do with this ticket.
 
And actually, a large part is already taken to simply build the new polynomial ring. For instance, on my laptop, `change_ring` takes approximately 12µs, of which 9µs are taken for building the new `PolynomialRing`. Yet the extra 3µs shouldn't exist...
 
> 
> * `is_unit`
> 
>     Why do you care that the base ring being an integral domain? Is `1` not a unit in `Z/4Z`? Sage thinks it is
> {{{
> sage: Zmod(4)(1).is_unit()
> True
> }}}
 
You may have overlooked the code: If the base ring is an integral domain and the input polynomial has degree > 0, it cannot be a unit so I directly return `False`. I test the nilpotency of the coefficients only if the base ring is not an integral domain.
 
> * `reverse`
> 
>     You can use `for k,v in self.__coeffs.iteritems()`
> 
> * `integral` for sparse
> 
>     idem: use `iteritems`. In other words, replace
> {{{
> Q({k:self.__coeffs[k].integral(var) for k in self.__coeffs.keys()})
> }}}
>     with
> {{{
> Q({k:v.integral(var) for k,v in self.__coeffs.iteritems()})
> }}}
>    I found strange that in one case you defined the dictionary `d` and then `return Q(d)` while in the other you do everything at once.
 
Comments taken into account.


---

Comment by bruno created at 2015-08-04 09:54:16

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-08-07 20:06:03

Hello,

For non integral domain, there are some failures for `integral`

```
sage: x = polygen(Zmod(4))
sage: p = x**4 + 1
sage: p.integral()
Traceback (most recent call last):
...
ZeroDivisionError: Inverse does not exist.
```

And for more complicated rings as well

```
sage: Sx.<x> = ZZ[]
sage: Sxy.<y> = Sx[]
sage: Sxyz.<z> = Sxy[]
sage: p = 1 + x*y + x*z + y*z^2
sage: p.integral(y)
Traceback (most recent call last):
...
TypeError: no conversion of this rational to integer
```

Moreover, you kept the `self.constant_coefficient()/1`. In some cases (like the one above) there is no fraction field, so it makes sense to ask for the result of the division. But this is also accessible from the coercion model

```
sage: cm = get_coercion_model()
sage: cm.division_parent(ZZ)
Rational Field
sage: cm.division_parent(Zmod(4))
Ring of integers modulo 4
```

That way you avoid a useless division (and a coercion since you used `1` instead of `base_ring.one()`).

That being said, there are plenty of broken thing in the coercion model. I ended up with a relatively robust solution but not ideal. In order to be improved, one has to work more on the coercion model and the polynomial division.

Tell me what you think.

Vincent
----
New commits:


---

Comment by vdelecroix created at 2015-08-07 20:06:03

Changing status from needs_review to needs_info.


---

Comment by bruno created at 2015-08-08 07:35:35

The coercion model is really something I do not understand yet in Sage, so I trust what you wrote. Simply, in the following change, isn't it faster (and cleaner to some extent) to first define the underlying list of coefficients rather than defining the zero polynomial before adding monomials to it? 


```diff
-        coeffs = self.list()
-        v = [0] + [coeffs[n]/(n+1) for n from 0 <= n <= degree]
-        return S(v)
+        p = S.zero()
+        for n in range(degree+1):
+            if self[n]:
+                p += cm.bin_op(Q(self[n]), n+1, operator.div) * S.gen()**(n+1)
+        return p
```


What about something as the following?

```python
    coeffs = [self.zero()] * (degree + 2)
    for n in range(degree+1):
        if self[n]:
            coeffs[n+1] = cm.bin_op(Q(self[n]), n+1, operator.div)
    return S(coeffs)
```


_Note. I'm going in vacations and won't be able to interact much until August 24._


---

Comment by git created at 2015-08-08 21:13:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-08-26 13:43:03

The current branch passes all the tests. As far as I can tell, this ticket can now be positive reviewed. Is it appropriate if I set it myself? I am quite reluctant since I wrote most of the code, and also sine you didn't set it to `needs_review`.


---

Comment by vdelecroix created at 2015-09-04 00:14:47

Changing status from needs_info to needs_review.


---

Comment by vdelecroix created at 2015-09-04 00:30:23

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-09-04 00:30:23

- `The integral is always chosen so the constant term is 0.` -> `... so that ...`
- inconsistency between dense and sparse

```
sage: R.<x> = PolynomialRing(Zmod(4), sparse=False)
sage: p = x**4 + 1
sage: p.integral()
x^5 + x
sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
sage: p = x**4 + 1
sage: p.integral()
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
```



---

Comment by bruno created at 2015-09-04 09:11:35

Replying to [comment:11 vdelecroix]:
> - inconsistency between dense and sparse
> {{{
> sage: R.<x> = PolynomialRing(Zmod(4), sparse=False)
> sage: p = x**4 + 1
> sage: p.integral()
> x^5 + x
> sage: R.<x> = PolynomialRing(Zmod(4), sparse=True)
> sage: p = x**4 + 1
> sage: p.integral()
> Traceback (most recent call last):
> ...
> TypeError: self must be an integral domain.
> }}}

Right, I should mimick what you did for the dense case. Before I do this, I actually have a question on what you wrote:

```python
        cm = sage.structure.element.get_coercion_model()
        try:
            S = cm.bin_op(R.one(), ZZ.one(), operator.div).parent()
            Q = S.base_ring()
        except TypeError:
            Q = (R.base_ring().one()/ZZ.one()).parent()
            S = R.change_ring(Q)
```

I don't get what you consider `ZZ.one()` instead of `R.one()` or even better `R.base_ring.one()`. I have the following behavior:

```python
sage: R.<x> = Zmod(4)[]
sage: cm.bin_op(R.one(),ZZ.one(),operator.div).parent()
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
sage: cm.bin_op(R.one(),R.one(),operator.div).parent()
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
sage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()
Univariate Polynomial Ring in x over Ring of integers modulo 4
```


and


```python
sage: R.<x> = ZZ[]
sage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()
Univariate Polynomial Ring in x over Rational Field
sage: R.<x> = ZZ['y'][]
sage: cm.bin_op(R.one(),R.base_ring().one(),operator.div).parent()
Univariate Polynomial Ring in x over Fraction Field of Univariate Polynomial Ring in y over Integer Ring
```


If I understand correctly, using `R.base_ring.one()` may fix the issue of your `TODO`. What do you think of this?


---

Comment by bruno created at 2015-09-04 13:55:32

Actually, this yields other problems... And with my proposal, you get the following behavior which may not be wanted:


```python
sage: A.<a1, a2> = PolynomialRing(ZZ)
sage: B.<b> = PolynomialRing(A)
sage: C.<c> = PowerSeriesRing(B)
sage: R.<x> = PolynomialRing(C)
sage: f = a2*x^2 + c*x - a1*b
sage: f.parent()
Univariate Polynomial Ring in x over Power Series Ring in c over Univariate Polynomial Ring in b over Multivariate Polynomial Ring in a1, a2 over Integer Ring
sage: f.integral().parent()
Univariate Polynomial Ring in x over Fraction Field of Power Series Ring in c over Univariate Polynomial Ring in b over Multivariate Polynomial Ring in a1, a2 over Integer Ring
```



---

Comment by git created at 2015-09-04 14:25:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-09-04 14:27:17

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-09-04 17:16:26

- ` if not isinstance(degree, int) and not isinstance(degree, Integer)` -> `not isinstance(degree, (int,Integer))`.

- after `OUTPUT:` in the docstring of `newton_slopes` you should add a line break

- you can do one liners (you are not obliged though)

```
d = {degree-k: v for k,v in self.__coeffs.iteritems() if degree >= k}
```


- why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?


---

Comment by vdelecroix created at 2015-09-04 17:16:26

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-09-08 13:27:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-09-08 13:32:05

When writing a comment like this

```
# But it does not work in all cases!!
```

you should be explicit about the cases where it does not work. Just saying "it sometimes does not work" is not sufficient justification.


---

Comment by bruno created at 2015-09-08 13:36:56

Replying to [comment:16 vdelecroix]:
> - ` if not isinstance(degree, int) and not isinstance(degree, Integer)` -> `not isinstance(degree, (int,Integer))`.

Done.

> - after `OUTPUT:` in the docstring of `newton_slopes` you should add a line break

Done.

> - you can do one liners (you are not obliged though)
> {{{
> d = {degree-k: v for k,v in self.__coeffs.iteritems() if degree >= k}
> }}}

Done.
 
> - why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?

The rationale is that for very sparse polynomials, one may want to get the newton slopes in a "compressed" format, that is as a list of segments defined by their slope and length rather than as a (very long) list of length-1 segments solely defined by their slope. I decided to implement this "compressed" output for sparse polynomials only since this feature seem(ed) mostly useful for sparse polynomials. 

A modification I could do is to move my implementation in the `Polynomial` class. Do yo think it would be the right thing to do?


---

Comment by vdelecroix created at 2015-09-08 23:20:32

Replying to [comment:19 bruno]:
> Replying to [comment:16 vdelecroix]:
> > - why are you keeping a method `newton_slopes` in both `polynomial_element.Polynomial` and `polynomial_element_generic.Polynomial_generic_sparse`? The algorithm does not seem to use much about the sparse structure. Moreover, why their arguments differ?
> 
> The rationale is that for very sparse polynomials, one may want to get the newton slopes in a "compressed" format, that is as a list of segments defined by their slope and length rather than as a (very long) list of length-1 segments solely defined by their slope. I decided to implement this "compressed" output for sparse polynomials only since this feature seem(ed) mostly useful for sparse polynomials. 
> 
> A modification I could do is to move my implementation in the `Polynomial` class. Do yo think it would be the right thing to do?

I understand the need of the argument. But if it also makes sense at the level of `Polynomial` then yes, do it there. That way there will only be one implementation and one signature.

Vincent


---

Comment by git created at 2015-09-09 09:03:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2015-09-09 09:04:54

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2015-09-09 09:04:54

I moved the implementation to `Polynomial`. It actually make more sense.


---

Comment by vdelecroix created at 2015-09-15 01:06:21

Let it go. These are nice improvements to sparse polynomials. Thanks.


---

Comment by vdelecroix created at 2015-09-15 01:06:21

Changing status from needs_review to positive_review.


---

Comment by bruno created at 2015-09-15 09:03:22

Thanks for the help!


---

Comment by vbraun created at 2015-09-15 22:30:53

Resolution: fixed
