# Issue 19560: Build GSL in IEEE 754 compliant mode

Issue created by migration from Trac.

Original creator: jdemeyer

Original creation time: 2015-12-29 10:15:31

CC:  rws

The following can happen on some hardware architectures due to fused multiply-add instructions:

```
sage: x = CDF(0.99, 0.2)
sage: x * x.conj()
1.0201 + 1.1102230246251575e-19*I
```


It's annoying because it causes doctest failures, for example

```
sage -t --long --warn-long 62.3 src/sage/symbolic/expression.pyx
**********************************************************************
File "src/sage/symbolic/expression.pyx", line 11105, in sage.symbolic.expression.Expression._plot_fast_callable
Failed example:
    plot(s)
Expected:
    Graphics object consisting of 1 graphics primitive
Got:
    Graphics object consisting of 0 graphics primitives
**********************************************************************
```



---

Comment by vbraun created at 2015-12-29 16:33:58

Isn't this sacrificing a lot of numerical performance? At least IEEE 754-2008 contains fused multiply-add.

The doctest is

```
            sage: x = var('x', domain='real')
            sage: s = abs((1+I*x)^4); s
            (I*x + 1)^2*(-I*x + 1)^2
            sage: s._plot_fast_callable(x)
            <sage.ext.interpreters.wrapper_py.Wrapper_py object at ...>
            sage: s._plot_fast_callable(x)(10)
            10201
            sage: abs((I*10+1)^4)
            10201
            sage: plot(s)
            Graphics object consisting of 1 graphics primitive
```

Isn't the real problem that abs does not default to `hold=True`

```
sage: ((1+I*x)^4).abs()
(I*x + 1)^2*(-I*x + 1)^2
```

so something that ought to be manifestly real is not. Compare:

```
sage: abs((1+I*x)^4)._plot_fast_callable(x)(RDF(10))
10201.00000000001
sage: type(_)
<type 'sage.rings.complex_double.ComplexDoubleElement'>
```

vs.

```
sage: ((1+I*x)^4).abs(hold=True)._plot_fast_callable(x)(RDF(10))
10201.000000000005
sage: type(_)
<type 'sage.rings.real_double.RealDoubleElement'>
```

----
New commits:


---

Comment by jdemeyer created at 2015-12-29 21:20:04

Replying to [comment:2 vbraun]:
> Isn't this sacrificing a lot of numerical performance?

I have no idea but I doubt it. For example, Intel architectures added this instruction only very recently.


---

Comment by vbraun created at 2015-12-29 21:57:07

Yes but CPU's haven't seen any general speedups recently, either. Only more specialized instructions, and if you don't use them then you are not participating in progress.


---

Comment by jdemeyer created at 2015-12-29 22:16:22

Replying to [comment:4 vbraun]:
> Yes but CPU's haven't seen any general speedups recently, either. Only more specialized instructions, and if you don't use them then you are not participating in progress.

I would say that _at least in the specific case of complex multiplication_, the use of FMA instructions is wrong.


---

Comment by jdemeyer created at 2015-12-29 22:44:30

Alternatively, we could probably play some tricks with `volatile` to fix complex multiplication.


---

Comment by vbraun created at 2015-12-30 00:17:45

So the question is: Should we guarantee that `x*x.conj()` has no numerical noise as imaginary part.

I'm not sure. 
* Even besides FMA there is always the possibility of 80-bit x87 instructions messing things up, though thats being retired now. 
* Blas are more than happy to use FMA, so //if// we make guarantees for scalars then they'll most likely be broken by diagonal matrices, say. 

What I am pretty sure about is: multiplying `x*x.conj()` as complex numbers is a bad way of evaluating the absolute value. Fast callables using abs should return real and not complex values. And for that we need to hold abs. At which point the issue of the numerical noise in the imaginary part is pretty meaningless.


---

Comment by rws created at 2015-12-30 06:08:19

Replying to [comment:2 vbraun]:
> {{{
>             sage: x = var('x', domain='real')
>             sage: s = abs((1+I*x)^4); s
>             (I*x + 1)^2*(-I*x + 1)^2
> }}}
> Isn't the real problem that abs does not default to `hold=True`
Maybe it's better to expand automatically if the result contains `I`. Automatic expansion also resolved a similar problem in #18952

```
sage: x = var('x', domain='real')
sage: ((1+I*x)^4).abs().expand()
x^4 + 2*x^2 + 1
```

> so something that ought to be manifestly real is not.
It is but only when expanded.


---

Comment by rws created at 2015-12-30 09:01:19

> Maybe it's better to expand automatically if the result contains `I`.
Also only if the result is not of form `abs(...)`


---

Comment by vbraun created at 2015-12-30 09:11:40

And not of the form `1+abs(...)` and so on

Automatically expanding isn't good enough either in general:

```
sage: x = var('x', domain='real')
sage: ((exp(I*x)+exp(-I*x))^4).abs().expand()
e^(4*I*x) + 4*e^(2*I*x) + 4*e^(-2*I*x) + e^(-4*I*x) + 6
```



---

Comment by jdemeyer created at 2015-12-30 09:27:04

Replying to [comment:7 vbraun]:
> * Even besides FMA there is always the possibility of 80-bit x87 instructions messing things up

With x87, it is reasonable to assume that the whole imaginary part will be evaluated with 80 bits, so there won't be numerical noise either (see also the successful i386 buildbot reports).


---

Comment by rws created at 2015-12-30 09:29:30

Replying to [comment:10 vbraun]:
> And not of the form `1+abs(...)` and so on
This can be fixed in `GiNaC::abs_eval()`

> Automatically expanding isn't good enough either in general:
> {{{
> sage: x = var('x', domain='real')
> sage: ((exp(I*x)+exp(-I*x))^4).abs().expand()
> e^(4*I*x) + 4*e^(2*I*x) + 4*e^(-2*I*x) + e^(-4*I*x) + 6
> }}}
Why not? This is real as well and could be rewritten as a sum of trig function expressions.


---

Comment by jdemeyer created at 2015-12-30 09:35:55

Replying to [comment:13 rws]:
> This is real as well and could be rewritten as a sum of trig function expressions.

Volker's point is about being "manifestly" real, which means: an expression which will always give a real result when evaluated, even if sub-expressions introduce numerical noise.

An expression like

```
e^(4*I*x) + e^(-4*I*x)
```

is not manifestly real, since there is no guarantee that the imaginary parts of the two terms will _exactly_ cancel out.


---

Comment by rws created at 2015-12-30 09:43:36

Well then, exclude functions in the treewalk in the search for `I`. Treewalks are very fast in comparison to other Pynac operations, and those are only a small fraction when compared to what Python costs.


---

Comment by vbraun created at 2015-12-30 10:02:55

Its not just that there is no guarantee against numerical noise in the imaginary part of `exp(I*x)+exp(-I*x)`, the return type of the fast callable also changes from real to complex (comment:2). The symbolic expression containing abs() should only do automatic simplifications that are again manifestly real.

* Expanding polynomials over QQ[I] is safe, and that is the only safe case I can think of

* Transcendental functions are not safe

* Expanding polynomials whose coefficients are radical expressions over QQ[I] are not safe

Thoughts?


---

Comment by rws created at 2015-12-30 16:08:16

Replying to [comment:16 vbraun]:
> * Expanding polynomials whose coefficients are radical expressions over QQ[I] are not safe
Is this decidable without expansion? Simply weeding out rational exponents will make `(I<sup>(5/4))*(I</sup>(3/4))` a false negative. OTOH first expanding then checking would be costly.

If so, I no longer think it useful.


---

Comment by rws created at 2015-12-30 16:36:05

So, you're proposing to always hold `abs()` and probably have a keyword for `x*conjugate(x)` output?


---

Comment by vbraun created at 2015-12-30 16:43:24

Even with expansion I think it can be difficult to tell if a radical is real or not; Cardano's formula which can't be written in real radicals even if the roots are real comes to mind.

Of course it **is** possible to decide if a radical is real or not, for example using QQbar.

Can't we just `abs(hold=True)` by default? You can always simplify or set `hold=False` if you don't want that.


---

Comment by jdemeyer created at 2015-12-30 22:42:55

Replying to [comment:19 vbraun]:
> Can't we just `abs(hold=True)` by default?

We could certainly do that as a stopgap-style solution. However, this is certainly going to break some doctests...


---

Comment by rws created at 2015-12-31 07:22:16

Replying to [comment:20 jdemeyer]:
> Replying to [comment:19 vbraun]:
> > Can't we just `abs(hold=True)` by default?
> 
> We could certainly do that as a stopgap-style solution. However, this is certainly going to break some doctests...
I get only two fails in `functions/`, `symbolic/`, `calculus/`, `doc/` if I outcomment this snippet in Pynac which is responsible for the specific behaviour:
https://github.com/pynac/pynac/blob/master/ginac/inifcns.cpp#L253


---

Comment by rws created at 2015-12-31 07:37:13

So the result is arrived at by two code parts: first `abs` of real power (or power of positive) is rewritten as power of `abs` and, second, even power of `abs(x)` is rewritten as `x*x.conj()` to the half power.


---

Comment by rws created at 2015-12-31 08:26:47

So I'll just disable the `abs(ex<sup>real)-->abs(ex)</sup>real` part in that Pynac ticket if there are no objections.


---

Comment by jdemeyer created at 2015-12-31 09:01:04

Replying to [comment:22 rws]:
> second, even power of `abs(x)` is rewritten as `x*x.conj()` to the half power.

It's really this second part which is problematic.


---

Comment by jdemeyer created at 2015-12-31 09:08:54

The simplification `abs(ex<sup>real)-->abs(ex)</sup>real` is safe since the result is still manifestly real.


---

Comment by rws created at 2015-12-31 09:29:45

This was introduced with pynac-0.3.9.2 from GiNaC. I'll revert it for pynac-0.5.4.


---

Comment by jdemeyer created at 2016-01-03 12:37:07

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2016-01-03 12:37:07

"Duplicate" of #19819.


---

Comment by jdemeyer created at 2016-01-03 12:37:12

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-01-03 20:28:33

Resolution: duplicate
