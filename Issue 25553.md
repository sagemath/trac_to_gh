# Issue 25553: Random failure in hyperelliptic_finite_field.py

Issue created by migration from https://trac.sagemath.org/ticket/25790

Original creator: vbraun

Original creation time: 2018-07-06 18:21:30

CC:  @timokau roed

Keywords: random_fail

This happens occasionally, is a somewhat recent regression:

```
sage -t --long src/sage/schemes/hyperelliptic_curves/hyperelliptic_finite_field.py
**********************************************************************
File "src/sage/schemes/hyperelliptic_curves/hyperelliptic_finite_field.py", line 780, in sage.schemes.hyperelliptic_curves.hyperelliptic_finite_field.HyperellipticCurve_finite_field.points
Failed example:
    len(C.points())
Exception raised:
    Traceback (most recent call last):
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 573, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 983, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.schemes.hyperelliptic_curves.hyperelliptic_finite_field.HyperellipticCurve_finite_field.points[5]>", line 1, in <module>
        len(C.points())
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/hyperelliptic_finite_field.py", line 825, in points
        self.__points = self._points_fast_sqrt() # this is fast using Zech logarithms
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/hyperelliptic_finite_field.py", line 675, in _points_fast_sqrt
        points.append(self.point([x, v+sqrtD, one], check=True))
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/projective/projective_subscheme.py", line 122, in point
        return self.point_homset()(v, check=check)
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/generic/homset.py", line 279, in __call__
        return Set_generic.__call__(self, *args, **kwds)
      File "sage/structure/parent.pyx", line 922, in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9761)
        return mor._call_with_args(x, args, kwds)
      File "sage/structure/coerce_maps.pyx", line 164, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_with_args (build/cythonized/sage/structure/coerce_maps.c:5093)
        raise
      File "sage/structure/coerce_maps.pyx", line 154, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_with_args (build/cythonized/sage/structure/coerce_maps.c:4883)
        return C._element_constructor(x, **kwds)
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/generic/homset.py", line 653, in _element_constructor_
        return self.codomain()._point(self, v, **kwds)
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/projective/projective_point.py", line 1474, in __init__
        X.extended_codomain()._check_satisfies_equations(v)
      File "/home/vbraun/Code/sage.git/local/lib/python2.7/site-packages/sage/schemes/generic/algebraic_scheme.py", line 973, in _check_satisfies_equations
        raise TypeError("Coordinates %s do not define a point on %s"%(coords,self))
    TypeError: Coordinates [4*a + 9, 8*a + 5, 1] do not define a point on Hyperelliptic Curve over Finite Field in a of size 11^2 defined by y^2 + (x^2 + 2)*y = x^5 + x + 10
**********************************************************************
1 item had failures:
   1 of  13 in sage.schemes.hyperelliptic_curves.hyperelliptic_finite_field.HyperellipticCurve_finite_field.points
    [373 tests, 1 failure, 91.08 s]
```



---

Comment by @timokau created at 2018-07-10 22:42:22

Shouldn't this be a blocker? Its a regression and one of the worst kind, a non-deterministic one.


---

Comment by jdemeyer created at 2018-07-11 21:57:57

Changing priority from major to blocker.


---

Comment by chapoton created at 2018-07-12 06:28:33

reminds me of #25379, where finite fields are also involved in a random failing doctest


---

Comment by vbraun created at 2018-07-16 22:26:52

Unless a reviewed fix materializes real soon this will have to be postponed to the next version...


---

Comment by @timokau created at 2018-07-28 12:51:25

If we can't get this fixed for the release, shouldn't we mark the doctest as a known failure?


---

Comment by vbraun created at 2018-07-29 10:38:41

It isn't the only random failure that yields an error instead of the correct answer, e.g. #24747 is in the same category. At least it doesn't return an incorrect answer...


---

Comment by vbraun created at 2018-07-29 10:38:41

Changing priority from blocker to major.


---

Comment by @timokau created at 2018-07-29 13:29:46

Then I think we should mark all of them as known failures before a release. Such failures decrease the value of the test suite. I'm currently running the whole `--long` test suite after every rebuild of sage for nix and block the release on any failure. If the test suite just randomly fails sometimes, I cannot do that.


---

Comment by @timokau created at 2018-07-29 13:42:24

See #25968.


---

Comment by embray created at 2018-09-24 12:47:47

Is there a particular platform this occurs on ?  I feel like I've run this test over and over again and I can't get it to fail.


---

Comment by vbraun created at 2018-09-24 20:28:11

I haven't seen this in a while fwiw


---

Comment by @timokau created at 2018-09-27 21:53:22

Me neither.


---

Comment by embray created at 2018-10-08 09:45:51

Per discussion in #25968, no one interested in this has been able to reproduce the bug in a while so maybe it's fixed itself.  Feel free to reopen this if it comes up again.


---

Comment by embray created at 2018-10-08 09:45:51

Resolution: worksforme


---

Comment by vbraun created at 2020-01-31 23:48:54

Resolution changed from worksforme to 


---

Comment by vbraun created at 2020-01-31 23:48:54

Changing status from closed to new.


---

Comment by vbraun created at 2020-01-31 23:48:54

I'm seeing this a lot right now on the aims buildbot, but can't reproduce in isolation.


---

Comment by git created at 2020-02-01 10:08:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-01 14:33:28

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-01 17:38:56

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-01 23:09:25

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vbraun created at 2020-02-01 23:16:46

Note: in the failing example `x = 4*a + 9`, so `D(x) = 10*a` (the value that one has to take a square root of to find a point on the hyperelliptic curve) is not a square. For some reason `is_square()` erroneously returns True`


---

Comment by git created at 2020-02-02 08:56:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-02 08:59:15

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-02 12:14:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vbraun created at 2020-02-02 12:17:49

Actually the discriminant `D(x)` has the wrong value (and happens to be a square when it shouldn't). So it seems that evaluating a `Polynomial_ZZ_pEX` is flaky.


---

Comment by vbraun created at 2020-02-02 14:36:25

When the error happens D prints correctly as `x^5 + 3*x^4 + x^2 + x`, but evaluates wrong. Naively evaluating it with Sage-wrapped `FiniteField_givaroElement` gives the right answer.


---

Comment by git created at 2020-02-02 15:38:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-02 19:16:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-02 23:06:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-05 21:49:01

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-06 22:54:45

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-08 00:27:12

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-09 13:09:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-09 14:25:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-09 14:51:34

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vbraun created at 2020-02-09 15:28:51

I've got the suspicion that this is a NTL context mismatch. The danger is that a !Python/Cython destructor is being called at inopportune times and changes the (global) NTL context. This can happen whenever Python objects are being allocated. Its more likely if there is memory pressure, which would explain why I'm seeing this on the buildbot but it disappers when tested in isolation.

In the attached branch I'm introducing `_assert_is_current_modulus()` methods to debug this better. 

In particular, the constructors for the ntl wrappers like `ntl_ZZ_pE` are not entirely safe in that they occasionally change the context away from the context of the NTL object that is being wrapped. Since they are Python objects there is an unavoidable allocation, though they then restore the context in `__cinit__`. But then `__init__` tends to create auxiliary Python objects which can change the context again. There are two possible contracts here

1. Instantiating NTL wrappers can change the context, and the user must restore the context before any further NTL calls that require a context

2. Instantiating NTL wrappers shall not change the context, and any branch in the constructor that potentially causes a gc must be followed up with a context restore.

Setting the NTL context should be quite cheap, so I'm in favor of the the safer option 2. Even though it might cause unneeded NTL context restores.


---

Comment by vbraun created at 2020-02-09 15:37:16

I've added extra logging to original random failure in `hyperelliptic_finite_field.py` and when it fails its because a call to `self._parent._modulus.ZZ_pE([7, 7])` returned the NTL `ZZ_pE` that prints as `[1 7]` instead of `[7 7]`.


---

Comment by git created at 2020-02-09 17:56:25

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-09 21:07:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vbraun created at 2020-02-09 21:26:34

In the failing example the `[7, 7]` list actually contains `Integer_mod` elements, which ends up being converted to `ntl_ZZ_p` via conversion to string. This is the unsafe call 

```
    ccreadstr(self.x, str(v))
```

in `ntl_ZZ_p.__init__()`. So what happens is:
* we start with the correct NTL modulus
* Calling `str(v)` ends up making Python allocations, which can cause gc to run and to change the NTL modulus
* In that case `ccreadstr(self.x, ...)` interprets it as a number with the wrong modulus


---

Comment by vbraun created at 2020-02-09 23:28:11

Replying to [comment:36 vbraun]:
> 1. Instantiating NTL wrappers can change the context, and the user must restore the context before any further NTL calls that require a context

Actually, this is the only possibility. When `__init__` ends some temporary objects go out of scope and this can trigger a gc, changing the NTL context. So even if you had the correct NTL context at the last line of `__init__`, it can be different once you return to the calling site.


---

Comment by git created at 2020-02-10 20:23:28

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-10 20:33:46

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-10 20:43:29

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-02-10 23:48:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vbraun created at 2020-02-10 23:51:05

Changing status from new to needs_review.


---

Comment by vbraun created at 2020-02-10 23:51:05

I can't reproduce it any more with the attached branch, looks like the gc hitting in the `ccreadstr(self.x, str(v))` was the main culprit.


---

Comment by vbraun created at 2020-02-10 23:51:05

Changing priority from major to blocker.


---

Comment by vbraun created at 2020-02-10 23:55:39

David, do you want to review this ticket?


---

Comment by roed created at 2020-02-11 03:28:01

Yep, I'll take a look tonight.


---

Comment by vbraun created at 2020-02-15 11:42:18

Did you manage to take a look? No pressure ;-) but I'd like to get the buildbot working and, while its an unlikely bug, when it strikes it can silently return wrong values...


---

Comment by roed created at 2020-02-17 04:05:33

Changing status from needs_review to positive_review.


---

Comment by roed created at 2020-02-17 04:05:33

Looks good.  I ran tests locally.


---

Comment by vbraun created at 2020-02-19 23:27:04

Resolution: fixed
