# Issue 23209: Implement plethysm of tensors of symmetric functions

Issue created by migration from https://trac.sagemath.org/ticket/23446

Original creator: zabrocki

Original creation time: 2017-07-17 07:08:25

CC:  mantepse tscrim saliola

Keywords: sf, combinat

Currently plethsym of symmetric functions `f(g)` where both f and g are symmetric functions is implemented.  This ticket would add the feature to allow `g` to be a tensor of symmetric functions.

If `X = tensor([s[1],s[[]]])` and `Y = tensor([s[[]], s[1]])` then `f(X+Y)` and `f(X*Y)` make sense and follow the notation found in mathematical papers that use plethystic notation.


---

Comment by zabrocki created at 2017-07-17 07:20:53

Here is a first implementation
----
New commits:


---

Comment by zabrocki created at 2017-07-17 08:07:31

Changing component from PLEASE CHANGE to combinatorics.


---

Attachment

Hi Mike!

I attached some code for working with symmetric functions in several alphabets, including the plethysm of an ordinary and a multivariate symmetric function as well as the plethysm of a multivariate and an ordinary symmetric function.  It is by no means polished, but maybe you can use it anyway.


---

Comment by git created at 2017-07-24 12:08:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2017-07-24 12:46:31

Changing status from new to needs_review.


---

Comment by zabrocki created at 2017-07-24 12:46:31

It looks like my implementation is similar to Martin's.  I think that adding features such as scalar product and change basis are for another ticket, but I agree that they would be useful.


---

Comment by mantepse created at 2017-07-24 23:04:11

Do you think it would be possible to also support the following?

```
sage: s = SymmetricFunctions(QQ).s()
sage: X = tensor([s([1]), s([])])
sage: Y = tensor([s([]), s([1])]);
sage: X(s[2])
s[2] # s[]
sage: Y(s[2])
1/2*s[] # s[1, 1] + 1/2*s[] # s[2] - 1/2*s[1, 1] # s[] + 1/2*s[2] # s[]
```



---

Comment by zabrocki created at 2017-07-24 23:18:01

Hi Martin,
What is the definition of that notation?  I understand what f(expression) means, but I am not sure if I know a meaning of the definition of (f \otimes g)(expression).  Do you have a mathematical reference?

This is also not as easily introduced as you suggest since the parent of tensors of symmetric functions is not currently implemented.


---

Comment by tscrim created at 2017-07-25 00:47:12

Replying to [comment:10 zabrocki]:
> This is also not as easily introduced as you suggest since the parent of tensors of symmetric functions is not currently implemented.

Not quite. There is a parent for `s # s`, but it is the generic CFM tensor product class. However, it would not be difficult to create such a parent (with perhaps a custom element class), and I think it would be straightforward to plug that into the current framework.

-----

Some code comments:

This is a little cleaner:

```diff
-tHA = TensorProductsCategory.category_of(HopfAlgebrasWithBasis(R))
+tHA = HopfAlgebrasWithBasis(R).TensorProducts()
```


Why not this:

```diff
-            tparents = list(x.parent().__dict__['_sets'])
+            tparents = x.parent()._sets
```


For better readability (if it goes slightly over the 80 char/line, that's okay, it's worth it IMO):

```python
            return sum(d*prod(sum(raise_c(r)(c)
                                  * tensor([parent(p[r].plethysm(base(la)))
                                            for (base,la) in zip(tparents,trm)])
                                  for (trm,c) in x)
                              for r in mu)
                       for (mu, d) in p(self))
```



---

Comment by git created at 2017-07-25 01:47:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-07-25 07:22:50

In short, I think I should take back my suggestion.

Replying to [comment:10 zabrocki]:

> What is the definition of that notation?

It appears at the bottom of page 6 of https://arxiv.org/abs/math/0307383, `Lambda(r)` is defined on top of page 5.  Just as in Macdonald, the tensor positions correspond to the conjugacy classes of the cyclic group `1, zeta, zeta^2, ...`

This is less artificial than it may look, it makes symmetric functions into a plethory, https://arxiv.org/abs/math/0407227v1.

On the other hand, it is more specialised than it looks, because it is the special case of the cyclic group of the more general definition on page 9 of https://arxiv.org/abs/math/0604126.  Again, one needs to identify the conjugacy classes of a finite group with the tensor positions.


---

Comment by mantepse created at 2017-07-26 08:16:15

I don't now why, but my version is *much* faster:

```
sage: X = tensor([p([1]), p([])]); Y = tensor([p([]), p([1])]);
sage: H = sum(h[n] for n in range(7));
sage: timeit("myplethysm(H, X*Y)")
5 loops, best of 3: 270 ms per loop
sage: timeit("H(X*Y)")
5 loops, best of 3: 753 ms per loop
sage: H = sum(h[n] for n in range(8));
sage: timeit("myplethysm(H, X*Y)")
5 loops, best of 3: 508 ms per loop
sage: timeit("H(X*Y)")
5 loops, best of 3: 1.97 s per loop
```



---

Comment by mantepse created at 2017-07-26 08:16:42

Changing status from needs_review to needs_info.


---

Comment by git created at 2017-07-26 11:08:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2017-07-26 11:14:44

Changing status from needs_info to needs_review.


---

Comment by zabrocki created at 2017-07-26 11:14:44

Good call.  It should compute in the p-basis and then change to its target instead of changing to the target during the computation.  The previous version computed target(p_r[expression_1]) \otimes ... \otimes target(p_r[expression_k]) and then took their product.  This new version had comparable timings on my computer.


---

Comment by mantepse created at 2017-07-26 16:56:51

Changing status from needs_review to positive_review.


---

Comment by mantepse created at 2017-07-26 16:56:51

Many thanks, looks good!


---

Comment by mantepse created at 2017-07-26 18:57:40

Dear Travis,

do you have an idea how/where we should provide methods `change_basis`, `restrict_degree`, `diagonal` and `scalar`?

* `change_basis` would take a tensor product of symmetric functions and a tuple of as many bases as there are tensor positions.  It's somehow like a "diagonally applied plethysm".  Maybe we want to write:

```
sage: tensor([s,h])(X*Y)
s[1] # h[1]
```


* for `restrict_degree`, I'd like to write

```
sage: ((X+Y)^2).restrict_degree([1,2])
p[] # p[1, 1] + 2*p[1] # p[1]
}}} 

* similarly, for `diagonal` and `scalar`


---

Comment by tscrim created at 2017-07-26 19:45:26

I would just implement a `TensorProducts` category for the Sym bases with the appropriate methods in the `ParentMethods`.


---

Comment by mantepse created at 2017-07-26 20:00:48

Replying to [comment:20 tscrim]:
> I would just implement a `TensorProducts` category for the Sym bases with the appropriate methods in the `ParentMethods`.

Alas, I have absolutely no clue what I'd have to type into the editor to achieve this :-(

Help appreciated, but I'm afraid I cannot contribute much besides what is in the attached file.

Best wishes,

Martin


---

Comment by vbraun created at 2017-07-30 09:11:10

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2017-07-30 09:11:10

Reviewer name missing


---

Comment by mantepse created at 2017-07-30 10:19:06

Changing status from needs_work to positive_review.


---

Comment by mantepse created at 2017-07-30 12:19:12

Oh, I'm very sorry, that was autofill, probably!  Thanks for correcting!


---

Comment by vbraun created at 2017-07-31 20:18:19

Resolution: fixed
