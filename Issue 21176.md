# Issue 21176: A class for ring extensions

archive/issues_021176.json:
```json
{
    "body": "CC:  @johanrosenkilde @defeo @bgrenet @nthiery simonking @saraedum\n\nKeywords: sd75, padicBordeaux\n\nSage provides a rich framework for dealing with all classical algebraic structures: rings, fields, algebras, etc. \nNevertheless, given (for instance) two fields K and L with K \\subset L, it is not possible to build the extension L/K as a Sage object. However one can easily imagine methods related to this extension (e.g. `degree`, `discriminant`, `normal_basis`, `decompose_on_basis`, etc.)\n\nWith Bruno Grenet, Johan Rosenkilde and Luca De Feo, we raised this issue at Sage Days 75. A summary of our discussion is available \n[here](https://gist.github.com/defeo/cabab27ea93aeb9e0deb0ba8c5bc745b).\n\nThis ticket implements a generic class for ring extensions, and more specific classes for finite free ring extensions (as finite degree field extensions).\n\nBelow is a small tutorial extracted from the documentation:\n\n```\nExtension of rings.\n\nSage offers the possibility to work with ring extensions `L/K` as\nactual parents and perform meaningful operations on them and their\nelements.\n\nThe simplest way to build an extension is to use the method\n:meth:`sage.rings.ring.CommutativeRing.over` on the top ring,\nthat is `L`.\nFor example, the following line constructs the extension of\nfinite fields `\\mathbf{F}_{5^4}/\\mathbf{F}_{5^2}`::\n\n    sage: GF(5^4).over(GF(5^2))\n    Field in z4 with defining polynomial x^2 + (4*z2 + 3)*x + z2 over its base\n\nBy default, Sage reuses the canonical generator of the top ring\n(here `z_4 \\in \\mathbf{F}_{5^4}`), together with its name. However,\nthe user can customize them by passing in appropriate arguments::\n\n    sage: F = GF(5^2)\n    sage: k = GF(5^4)\n    sage: z4 = k.gen()\n    sage: K.<a> = k.over(F, gen = 1-z4)\n    sage: K\n    Field in a with defining polynomial x^2 + z2*x + 4 over its base\n\nThe base of the extension is available via the method :meth:`base` (or\nequivalently :meth:`base_ring`)::\n\n    sage: K.base()\n    Finite Field in z2 of size 5^2\n\nIt also possible to building an extension on top of another extension,\nobtaining this way a tower of extensions::\n\n    sage: L.<b> = GF(5^8).over(K)\n    sage: L\n    Field in b with defining polynomial x^2 + (4*z2 + 3*a)*x + 1 - a over its base\n    sage: L.base()\n    Field in a with defining polynomial x^2 + z2*x + 4 over its base\n    sage: L.base().base()\n    Finite Field in z2 of size 5^2\n\nThe method :meth:`bases` gives access to the complete list of rings in\na tower::\n\n    sage: L.bases()\n    [Field in b with defining polynomial x^2 + (4*z2 + 3*a)*x + 1 - a over its base,\n     Field in a with defining polynomial x^2 + z2*x + 4 over its base,\n     Finite Field in z2 of size 5^2]\n\nOnce we have constructed an extension (or a tower of extensions), we\nhave interesting methods attached to it. As a basic example, one can\ncompute a basis of the top ring over any base in the tower::\n\n    sage: L.basis_over(K)\n    [1, b]\n    sage: L.basis_over(F)\n    [1, a, b, a*b]\n\nWhen the base is omitted, the default is the natural base of the extension::\n\n    sage: L.basis_over()\n    [1, b]\n\nThe method :meth:`sage.rings.ring_extension_element.RingExtensionWithBasis.vector`\ncomputes the coordinates of an element according to the above basis::\n\n    sage: u = a + 2*b + 3*a*b\n    sage: u.vector()   # over K\n    (a, 2 + 3*a)\n    sage: u.vector(F)\n    (0, 1, 2, 3)\n\nOne can also compute traces and norms with respect to any base of the tower::\n\n    sage: u.trace()           # over K\n    (2*z2 + 1) + (2*z2 + 1)*a\n    sage: u.trace(F)\n    z2 + 1\n    sage: u.trace().trace()   # over K, then over F\n    z2 + 1\n\n    sage: u.norm()            # over K\n    (z2 + 1) + (4*z2 + 2)*a\n    sage: u.norm(F)\n    2*z2 + 2\n\nAnd minimal polynomials::\n\n    sage: u.minpoly()\n    x^2 + ((3*z2 + 4) + (3*z2 + 4)*a)*x + (z2 + 1) + (4*z2 + 2)*a\n    sage: u.minpoly(F)\n    x^4 + (4*z2 + 4)*x^3 + x^2 + (z2 + 1)*x + 2*z2 + 2\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/21413\n\n",
    "closed_at": "2020-01-25T17:27:22Z",
    "created_at": "2016-09-04T09:55:04Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.1",
    "title": "A class for ring extensions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21176",
    "user": "https://github.com/xcaruso"
}
```
CC:  @johanrosenkilde @defeo @bgrenet @nthiery simonking @saraedum

Keywords: sd75, padicBordeaux

Sage provides a rich framework for dealing with all classical algebraic structures: rings, fields, algebras, etc. 
Nevertheless, given (for instance) two fields K and L with K \subset L, it is not possible to build the extension L/K as a Sage object. However one can easily imagine methods related to this extension (e.g. `degree`, `discriminant`, `normal_basis`, `decompose_on_basis`, etc.)

With Bruno Grenet, Johan Rosenkilde and Luca De Feo, we raised this issue at Sage Days 75. A summary of our discussion is available 
[here](https://gist.github.com/defeo/cabab27ea93aeb9e0deb0ba8c5bc745b).

This ticket implements a generic class for ring extensions, and more specific classes for finite free ring extensions (as finite degree field extensions).

Below is a small tutorial extracted from the documentation:

```
Extension of rings.

Sage offers the possibility to work with ring extensions `L/K` as
actual parents and perform meaningful operations on them and their
elements.

The simplest way to build an extension is to use the method
:meth:`sage.rings.ring.CommutativeRing.over` on the top ring,
that is `L`.
For example, the following line constructs the extension of
finite fields `\mathbf{F}_{5^4}/\mathbf{F}_{5^2}`::

    sage: GF(5^4).over(GF(5^2))
    Field in z4 with defining polynomial x^2 + (4*z2 + 3)*x + z2 over its base

By default, Sage reuses the canonical generator of the top ring
(here `z_4 \in \mathbf{F}_{5^4}`), together with its name. However,
the user can customize them by passing in appropriate arguments::

    sage: F = GF(5^2)
    sage: k = GF(5^4)
    sage: z4 = k.gen()
    sage: K.<a> = k.over(F, gen = 1-z4)
    sage: K
    Field in a with defining polynomial x^2 + z2*x + 4 over its base

The base of the extension is available via the method :meth:`base` (or
equivalently :meth:`base_ring`)::

    sage: K.base()
    Finite Field in z2 of size 5^2

It also possible to building an extension on top of another extension,
obtaining this way a tower of extensions::

    sage: L.<b> = GF(5^8).over(K)
    sage: L
    Field in b with defining polynomial x^2 + (4*z2 + 3*a)*x + 1 - a over its base
    sage: L.base()
    Field in a with defining polynomial x^2 + z2*x + 4 over its base
    sage: L.base().base()
    Finite Field in z2 of size 5^2

The method :meth:`bases` gives access to the complete list of rings in
a tower::

    sage: L.bases()
    [Field in b with defining polynomial x^2 + (4*z2 + 3*a)*x + 1 - a over its base,
     Field in a with defining polynomial x^2 + z2*x + 4 over its base,
     Finite Field in z2 of size 5^2]

Once we have constructed an extension (or a tower of extensions), we
have interesting methods attached to it. As a basic example, one can
compute a basis of the top ring over any base in the tower::

    sage: L.basis_over(K)
    [1, b]
    sage: L.basis_over(F)
    [1, a, b, a*b]

When the base is omitted, the default is the natural base of the extension::

    sage: L.basis_over()
    [1, b]

The method :meth:`sage.rings.ring_extension_element.RingExtensionWithBasis.vector`
computes the coordinates of an element according to the above basis::

    sage: u = a + 2*b + 3*a*b
    sage: u.vector()   # over K
    (a, 2 + 3*a)
    sage: u.vector(F)
    (0, 1, 2, 3)

One can also compute traces and norms with respect to any base of the tower::

    sage: u.trace()           # over K
    (2*z2 + 1) + (2*z2 + 1)*a
    sage: u.trace(F)
    z2 + 1
    sage: u.trace().trace()   # over K, then over F
    z2 + 1

    sage: u.norm()            # over K
    (z2 + 1) + (4*z2 + 2)*a
    sage: u.norm(F)
    2*z2 + 2

And minimal polynomials::

    sage: u.minpoly()
    x^2 + ((3*z2 + 4) + (3*z2 + 4)*a)*x + (z2 + 1) + (4*z2 + 2)*a
    sage: u.minpoly(F)
    x^4 + (4*z2 + 4)*x^3 + x^2 + (z2 + 1)*x + 2*z2 + 2
```

Issue created by migration from https://trac.sagemath.org/ticket/21413





---

archive/issue_comments_293033.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-09-06T09:10:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293033",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293034.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-09-06T13:15:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293034",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293035.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-09-08T18:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293035",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293036.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-09-08T18:48:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293036",
    "user": "https://github.com/xcaruso"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_293037.json:
```json
{
    "body": "Wow, this is great Xavier! Sorry for not being more active before - I promise to look more at it tomorrow.\n\nI'm wondering whether it's a good idea to merge the \"framework\" before the first concrete instantiation? I.e. whether we should try to get the field-extension-algebra finished before considering this as mature? (I know you have bad experience with too large patches, but if we don't put too much stuff in the field extension as a first approximation, perhaps it's ok).\n\nBest,\nJohan",
    "created_at": "2016-09-08T19:09:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293037",
    "user": "https://github.com/johanrosenkilde"
}
```

Wow, this is great Xavier! Sorry for not being more active before - I promise to look more at it tomorrow.

I'm wondering whether it's a good idea to merge the "framework" before the first concrete instantiation? I.e. whether we should try to get the field-extension-algebra finished before considering this as mature? (I know you have bad experience with too large patches, but if we don't put too much stuff in the field extension as a first approximation, perhaps it's ok).

Best,
Johan



---

archive/issue_comments_293038.json:
```json
{
    "body": "In the following, the extension is A = L/K with L and K rings. `L.base()` is B.\nSometimes B is a subring of K.\n\nRight now this `AlgebraFromMorphism` is mainly a thin wrapper around the\nL, so e.g. A elements are represented internally as elements of L, and this is\nalso how you print them. Can you try to convince me of the value from a user's\nPOV that he can do arithmetic on his elements inside this algebra, rather than\ndropping the whole Algebra idea and just letting `RingExtension` be some\nnon-parent object with fancy methods on it like `decompose_on_basis`?\n\nWhat I had in mind after SD75 is that `RingExtension` is an `Algebra` as in \"a\nvector space equipped with a bilinear product\"; in other words, when I want to\nsee L as a vector space over K, I use `RingExtension`. In this world, it makes\nsense to have arithmetic on elements of `A` and they should print (and possibly\nbe internally represented by) vectors over K; because that's the whole point of\nwhy I'm wrapping L.\n\nIn that world, `AlgebraFromMorphism` shouldn't have a `gen` method because it\nisn't really focused on its personality as a ring (it might have a\n`multiplicative_generator` if you like). But it should definitely have a `basis`\nmethod.\n\nOther remarks that I got by looking at the code. Let's see where the above\ndiscussion takes us before doing much about the stuff below:\n\n1. Why are you not giving `self._base` as argument to `CommutativeAlgebra.__init__`? You write in a comment that we don't want a coercion map `base -> self` -- I don't see why not? I guess this is related to the left/right action dichotomy you have?\n2. The module doc for `algebra_from_morphism is too short`. It should explain what this module is and what is offered.\n   Redundancy is not bad.\n3. A method \"def something(self)\" should never have the doc-string \"Return the something of self\". That's utterly unhelpful :-)\n4. `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.\n5. The doc for `scalar_restriction` is very hard to read. Attempt to write before INPUT what this means. Could we write something like\n\n        {{{\n        If ``newbase`` is a sub-ring of `self.base()`, then the scalar restriction of `self` to `newbase` is the ring extension `self.ring()/newbase`. The defining morphism will be the composition of `f` and ``self.defining_morphism()`` where `f` is the coercion map from `newbase` to `self.base()`.\n\n        ``newbase`` can be given as an extension, ... \n\n        ``newbase`` can be given as a morphism, ...\n        }}}\n\n   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?\n6. I don't like `ring` and `base`. They are too short and it's not clear which is which.\n7. Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse! I'm also very concerned that this might break several things in Sage since you're inheriting from `CommutativeAlgebra`.\n8. Doc of `RingExtension`: can we make a commuting diagram to describe the coercion between L1/K1 and L2/K2? Something like\n\n      {{{\n      K1 -----> L1\n      ^         |\n      |         | \n      |         v\n      K2 -----> L2\n      }}}\n\nBest,\nJohan",
    "created_at": "2016-09-09T14:50:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293038",
    "user": "https://github.com/johanrosenkilde"
}
```

In the following, the extension is A = L/K with L and K rings. `L.base()` is B.
Sometimes B is a subring of K.

Right now this `AlgebraFromMorphism` is mainly a thin wrapper around the
L, so e.g. A elements are represented internally as elements of L, and this is
also how you print them. Can you try to convince me of the value from a user's
POV that he can do arithmetic on his elements inside this algebra, rather than
dropping the whole Algebra idea and just letting `RingExtension` be some
non-parent object with fancy methods on it like `decompose_on_basis`?

What I had in mind after SD75 is that `RingExtension` is an `Algebra` as in "a
vector space equipped with a bilinear product"; in other words, when I want to
see L as a vector space over K, I use `RingExtension`. In this world, it makes
sense to have arithmetic on elements of `A` and they should print (and possibly
be internally represented by) vectors over K; because that's the whole point of
why I'm wrapping L.

In that world, `AlgebraFromMorphism` shouldn't have a `gen` method because it
isn't really focused on its personality as a ring (it might have a
`multiplicative_generator` if you like). But it should definitely have a `basis`
method.

Other remarks that I got by looking at the code. Let's see where the above
discussion takes us before doing much about the stuff below:

1. Why are you not giving `self._base` as argument to `CommutativeAlgebra.__init__`? You write in a comment that we don't want a coercion map `base -> self` -- I don't see why not? I guess this is related to the left/right action dichotomy you have?
2. The module doc for `algebra_from_morphism is too short`. It should explain what this module is and what is offered.
   Redundancy is not bad.
3. A method "def something(self)" should never have the doc-string "Return the something of self". That's utterly unhelpful :-)
4. `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.
5. The doc for `scalar_restriction` is very hard to read. Attempt to write before INPUT what this means. Could we write something like

        {{{
        If ``newbase`` is a sub-ring of `self.base()`, then the scalar restriction of `self` to `newbase` is the ring extension `self.ring()/newbase`. The defining morphism will be the composition of `f` and ``self.defining_morphism()`` where `f` is the coercion map from `newbase` to `self.base()`.

        ``newbase`` can be given as an extension, ... 

        ``newbase`` can be given as a morphism, ...
        }}}

   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?
6. I don't like `ring` and `base`. They are too short and it's not clear which is which.
7. Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse! I'm also very concerned that this might break several things in Sage since you're inheriting from `CommutativeAlgebra`.
8. Doc of `RingExtension`: can we make a commuting diagram to describe the coercion between L1/K1 and L2/K2? Something like

      {{{
      K1 -----> L1
      ^         |
      |         | 
      |         v
      K2 -----> L2
      }}}

Best,
Johan



---

archive/issue_comments_293039.json:
```json
{
    "body": "Replying to [comment:7 jsrn]:\n> Right now this `AlgebraFromMorphism` is mainly a thin wrapper around the\n> L, so e.g. A elements are represented internally as elements of L, and this is\n> also how you print them. Can you try to convince me of the value from a user's\n> POV that he can do arithmetic on his elements inside this algebra, rather than\n> dropping the whole Algebra idea and just letting `RingExtension` be some\n> non-parent object with fancy methods on it like `decompose_on_basis`?\n\n\nMaybe I misunderstand your proposal but I really think that a ring extension should be a parent because we really want to take advantage of the coercion stuff.\nNonetheless, the question \"should it derive from `CommutativeAlgebra`?\" is arguable and I can imagine arguments in both directions.\n\n> What I had in mind after SD75 is that `RingExtension` is an `Algebra` as in \"a\n> vector space equipped with a bilinear product\"; in other words, when I want to\n> see L as a vector space over K, I use `RingExtension`.\n\n\nIt is definitely.\n\n> In this world, it makes\n> sense to have arithmetic on elements of `A` and they should print (and possibly\n> be internally represented by) vectors over K; because that's the whole point of\n> why I'm wrapping L.\n\n\nI agree. But all of this has to be implemented in subclasses. For now, I just wrote a very general class which is supposed to deal with all algebras (possibly not free, not finite...) so it is of course difficult to implement concrete methods. \n\nBut these methods clearly exist. Here is a far-from-exhaustive list: `scalar_restriction` (which is already implemented), `__mul__` (usual product of algebras), `tensor_product`, `scalar_extension`, `cayley_differentials`, `krull_relative_dimension`, `is_free`, `is_finite`, `is_flat`, `is_etale`, `is_smooth`, `is_open_immersion`, `is_closed_immersion`, `is_galois`, `galois_group`. And for elements: `trace`, `norm`.\n\nIf you insist, I can put these methods in the general class and let them raise `NotImplementedError`... but it would be difficult to write the doctest :-)\n\n> In that world, `AlgebraFromMorphism` shouldn't have a `gen` method because it\n> isn't really focused on its personality as a ring (it might have a\n> `multiplicative_generator` if you like).\n\n\nThe generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \\cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.\n\n> But it should definitely have a `basis` method.\n\n\nWell there does exist algebras which are not free. So the `basis` method is clearly something we want. However it should not be inserted in such a general class but in the subclass `FreeAlgebraFromMorphism` or `FiniteFreeAlgebraFromMorphism` (which is coming soon).\n\n> Why are you not giving `self._base` as argument to `CommutativeAlgebra.__init__`? You write in a comment that we don't want a coercion map `base -> self` -- I don't see why not? I guess this is related to the left/right action dichotomy you have?\n\n\nSuppose that we create an algebra L/K with a defining morphism phi : K -> L which is not a coercion map. If K coerces to L/K through phi and L/K coerces to L, then we would derive that K coerces to L through phi.\n\nSuch a situation really occurs in every day life (at least for people working in algebraic geometry). For instance, if K has characteristic p, these people often consider K as an algebra over itself *through the Frobenius morphism* (which is definitely not a coercion map).\n\n> The module doc for `algebra_from_morphism is too short`. It should explain what this module is and what is offered.\n>   Redundancy is not bad.\n\n>\n> A method \"def something(self)\" should never have the doc-string \"Return the something of self\". That's utterly unhelpful :-)\n\n\nOk for both. I'll try to fix this.\n\n> `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.\n\n\nIt is not my fault :-). This method is needed by the coercion model.\n\n> The doc for `scalar_restriction` is very hard to read. Attempt to write before INPUT what this means. Could we write something like\n\n\nOk. I'll do it.\n\n>   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?\n\n\nSure, it is something we normally do... just as composing ring homomorphisms.\n\n> I don't like `ring` and `base`. They are too short and it's not clear which is which.\n\n\nOk for changing. I'm also not completed satisfied with these names. Do you have some propositions?\n\n> Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse!\n\n\nI definitely agree that it is not perfect, but I have not found something better :-).\nThe point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.\n\n> I'm also very concerned that this might break several things in Sage since you're inheriting from `CommutativeAlgebra`.\n\n\nIt is one reason why I'm sure that we should inherit from `CommutativeAlgebra`\n\n> Doc of `RingExtension`: can we make a commuting diagram to describe the coercion between L1/K1 and L2/K2?\n\n\nOk.\n\nXavier",
    "created_at": "2016-09-09T21:56:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293039",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:7 jsrn]:
> Right now this `AlgebraFromMorphism` is mainly a thin wrapper around the
> L, so e.g. A elements are represented internally as elements of L, and this is
> also how you print them. Can you try to convince me of the value from a user's
> POV that he can do arithmetic on his elements inside this algebra, rather than
> dropping the whole Algebra idea and just letting `RingExtension` be some
> non-parent object with fancy methods on it like `decompose_on_basis`?


Maybe I misunderstand your proposal but I really think that a ring extension should be a parent because we really want to take advantage of the coercion stuff.
Nonetheless, the question "should it derive from `CommutativeAlgebra`?" is arguable and I can imagine arguments in both directions.

> What I had in mind after SD75 is that `RingExtension` is an `Algebra` as in "a
> vector space equipped with a bilinear product"; in other words, when I want to
> see L as a vector space over K, I use `RingExtension`.


It is definitely.

> In this world, it makes
> sense to have arithmetic on elements of `A` and they should print (and possibly
> be internally represented by) vectors over K; because that's the whole point of
> why I'm wrapping L.


I agree. But all of this has to be implemented in subclasses. For now, I just wrote a very general class which is supposed to deal with all algebras (possibly not free, not finite...) so it is of course difficult to implement concrete methods. 

But these methods clearly exist. Here is a far-from-exhaustive list: `scalar_restriction` (which is already implemented), `__mul__` (usual product of algebras), `tensor_product`, `scalar_extension`, `cayley_differentials`, `krull_relative_dimension`, `is_free`, `is_finite`, `is_flat`, `is_etale`, `is_smooth`, `is_open_immersion`, `is_closed_immersion`, `is_galois`, `galois_group`. And for elements: `trace`, `norm`.

If you insist, I can put these methods in the general class and let them raise `NotImplementedError`... but it would be difficult to write the doctest :-)

> In that world, `AlgebraFromMorphism` shouldn't have a `gen` method because it
> isn't really focused on its personality as a ring (it might have a
> `multiplicative_generator` if you like).


The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.

> But it should definitely have a `basis` method.


Well there does exist algebras which are not free. So the `basis` method is clearly something we want. However it should not be inserted in such a general class but in the subclass `FreeAlgebraFromMorphism` or `FiniteFreeAlgebraFromMorphism` (which is coming soon).

> Why are you not giving `self._base` as argument to `CommutativeAlgebra.__init__`? You write in a comment that we don't want a coercion map `base -> self` -- I don't see why not? I guess this is related to the left/right action dichotomy you have?


Suppose that we create an algebra L/K with a defining morphism phi : K -> L which is not a coercion map. If K coerces to L/K through phi and L/K coerces to L, then we would derive that K coerces to L through phi.

Such a situation really occurs in every day life (at least for people working in algebraic geometry). For instance, if K has characteristic p, these people often consider K as an algebra over itself *through the Frobenius morphism* (which is definitely not a coercion map).

> The module doc for `algebra_from_morphism is too short`. It should explain what this module is and what is offered.
>   Redundancy is not bad.

>
> A method "def something(self)" should never have the doc-string "Return the something of self". That's utterly unhelpful :-)


Ok for both. I'll try to fix this.

> `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.


It is not my fault :-). This method is needed by the coercion model.

> The doc for `scalar_restriction` is very hard to read. Attempt to write before INPUT what this means. Could we write something like


Ok. I'll do it.

>   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?


Sure, it is something we normally do... just as composing ring homomorphisms.

> I don't like `ring` and `base`. They are too short and it's not clear which is which.


Ok for changing. I'm also not completed satisfied with these names. Do you have some propositions?

> Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse!


I definitely agree that it is not perfect, but I have not found something better :-).
The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.

> I'm also very concerned that this might break several things in Sage since you're inheriting from `CommutativeAlgebra`.


It is one reason why I'm sure that we should inherit from `CommutativeAlgebra`

> Doc of `RingExtension`: can we make a commuting diagram to describe the coercion between L1/K1 and L2/K2?


Ok.

Xavier



---

archive/issue_comments_293040.json:
```json
{
    "body": "Thanks for your careful explanations. I'm learning a lot here.\n\nReplying to [comment:8 carus]:\n> Maybe I misunderstand your proposal but I really think that a ring extension should be a parent because we really want to take advantage of the coercion stuff.\n\n>\n> Nonetheless, the question \"should it derive from `CommutativeAlgebra`?\" is arguable and I can imagine arguments in both directions.\n\n\nOK, so \"coercion stuff\" is an argument in favour of a Parent. I guess you mean that many objects will magically coerce to the Do-What-I-Mean behaviour on methods. But if a weird/surprising behaviour follows from forcing it into the category framework, perhaps that's an argument against it.\n\nAt least having a `RingExtension` being a class with lots of service methods, sort of like David's `RelativeFiniteFieldExtension`, there will be no arithmetic problems. You could also put `norm` and `trace` there.\n\n> > In this world, it makes\n> > sense to have arithmetic on elements of `A` and they should print (and possibly\n> > be internally represented by) vectors over K; because that's the whole point of\n> > why I'm wrapping L.\n\n> \n> I agree. But all of this has to be implemented in subclasses. For now, I just wrote a very general class which is supposed to deal with all algebras (possibly not free, not finite...) so it is of course difficult to implement concrete methods. \n\n\nOK, that makes sense. I can see why the general class would have very weak functionality then.\n\n> But these methods clearly exist. Here is a far-from-exhaustive list:  ....\n> If you insist, I can put these methods in the general class and let them raise `NotImplementedError`... but it would be difficult to write the doctest :-)\n\n\nPerhaps that's not a bad idea: it's nicer that any algebra will have the methods you expect and then throw `NotImplementedError` rather than not advertising the method at all.\n\nThe doc-test can be on a more concrete class that does implement the method. If none exist for this ticket, the doc-test will just be one demonstrating the `NotImplentedError` for now, with the sole purpose of doc-test coverage ;-)\n\n> The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \\cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.\n\n\nHmm, but couldn't there be multiple generators? E.g. `F[x,y]/F`?\n\n> Well there does exist algebras which are not free. So the `basis` method is clearly something we want. However it should not be inserted in such a general class but in the subclass `FreeAlgebraFromMorphism` or `FiniteFreeAlgebraFromMorphism` (which is coming soon).\n\n\nOK, argument accepted. But I think this kind of stuff reinforces that we should try to design the first concrete `RingExtension`, e.g. `FiniteFieldExtension` simultaneously with this ticket. Then we'll better be able to judge what goes where and how it should look to be useful on both sides.\n\n> Suppose that we create an algebra L/K with a defining morphism phi : K -> L which is not a coercion map. If K coerces to L/K through phi and L/K coerces to L, then we would derive that K coerces to L through phi.\n> \n> Such a situation really occurs in every day life (at least for people working in algebraic geometry). For instance, if K has characteristic p, these people often consider K as an algebra over itself *through the Frobenius morphism* (which is definitely not a coercion map).\n\n\nYikes! So we must disallow coercion from `K -> L/K`. But we should allow `A(k)`\nand `k*a`, `a*k`, `k + a`, etc. for `k in K` and `a in A`. And `A(a * l)` is\ndifferent from `a * A(l)`. Oh man...\n\nIt seems to me that this is really dangerous territory - but perhaps\nunavoidable. Someone implementing algorithms for `CommutativeAlgebra` is going\nto assume that there is coercion from `base` to `self`. And that multiplication\nof `base` and `self` elements commute!\n\nPerhaps `CommutativeAlgebra` should be called something different, and\n`AlgebraFromMorphism` should have a different base class. I've cc'ed Nicolas\nThiery and Simon King in this discussion to chip in.\n\n> > `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.\n\n> \n> It is not my fault :-). This method is needed by the coercion model.\n\n\nEew, yet another symptom that we're perhaps abusing the current hierarchy.\n\nWhy doesn't `GF(9)` have `from_base_ring`? What kind of Parent requires it?\n\n> >   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?\n\n> \n> Sure, it is something we normally do... just as composing ring homomorphisms.\n\n\nSo it is something where established mathematical notation supports this\ndirectly? It's much more explicit to just write\n`A.scalar_restriction(Aother.ring())`, so I'd prefer not supporting\n`A.scalar_restriction(Aother)`, except if a properly educated mathematician\nwould be very surprised if this didn't exist.\n\n> > I don't like `ring` and `base`. They are too short and it's not clear which is which.\n\n> \n> Ok for changing. I'm also not completed satisfied with these names. Do you have some propositions?\n\n\nWe should probably first figure out what to do hierarchy-wise. But perhaps\nkeep `ring -> ring_of_element` and `base -> ring_of_scalars`. Alternative `element_ring` resp. `scalar_ring`.\n\n> > Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse!\n\n> \n> I definitely agree that it is not perfect, but I have not found something better :-).\n> The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.\n\n\nWhat do you mean \"is the least we can do\"?\n\nWhy is this an argument to make left and right actions different? Couldn't you implement the same left/right action, namely mapping `K -> A` by `phi`, followed by multiplication in `A`.\n\nBest,\nJohan",
    "created_at": "2016-09-10T10:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293040",
    "user": "https://github.com/johanrosenkilde"
}
```

Thanks for your careful explanations. I'm learning a lot here.

Replying to [comment:8 carus]:
> Maybe I misunderstand your proposal but I really think that a ring extension should be a parent because we really want to take advantage of the coercion stuff.

>
> Nonetheless, the question "should it derive from `CommutativeAlgebra`?" is arguable and I can imagine arguments in both directions.


OK, so "coercion stuff" is an argument in favour of a Parent. I guess you mean that many objects will magically coerce to the Do-What-I-Mean behaviour on methods. But if a weird/surprising behaviour follows from forcing it into the category framework, perhaps that's an argument against it.

At least having a `RingExtension` being a class with lots of service methods, sort of like David's `RelativeFiniteFieldExtension`, there will be no arithmetic problems. You could also put `norm` and `trace` there.

> > In this world, it makes
> > sense to have arithmetic on elements of `A` and they should print (and possibly
> > be internally represented by) vectors over K; because that's the whole point of
> > why I'm wrapping L.

> 
> I agree. But all of this has to be implemented in subclasses. For now, I just wrote a very general class which is supposed to deal with all algebras (possibly not free, not finite...) so it is of course difficult to implement concrete methods. 


OK, that makes sense. I can see why the general class would have very weak functionality then.

> But these methods clearly exist. Here is a far-from-exhaustive list:  ....
> If you insist, I can put these methods in the general class and let them raise `NotImplementedError`... but it would be difficult to write the doctest :-)


Perhaps that's not a bad idea: it's nicer that any algebra will have the methods you expect and then throw `NotImplementedError` rather than not advertising the method at all.

The doc-test can be on a more concrete class that does implement the method. If none exist for this ticket, the doc-test will just be one demonstrating the `NotImplentedError` for now, with the sole purpose of doc-test coverage ;-)

> The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.


Hmm, but couldn't there be multiple generators? E.g. `F[x,y]/F`?

> Well there does exist algebras which are not free. So the `basis` method is clearly something we want. However it should not be inserted in such a general class but in the subclass `FreeAlgebraFromMorphism` or `FiniteFreeAlgebraFromMorphism` (which is coming soon).


OK, argument accepted. But I think this kind of stuff reinforces that we should try to design the first concrete `RingExtension`, e.g. `FiniteFieldExtension` simultaneously with this ticket. Then we'll better be able to judge what goes where and how it should look to be useful on both sides.

> Suppose that we create an algebra L/K with a defining morphism phi : K -> L which is not a coercion map. If K coerces to L/K through phi and L/K coerces to L, then we would derive that K coerces to L through phi.
> 
> Such a situation really occurs in every day life (at least for people working in algebraic geometry). For instance, if K has characteristic p, these people often consider K as an algebra over itself *through the Frobenius morphism* (which is definitely not a coercion map).


Yikes! So we must disallow coercion from `K -> L/K`. But we should allow `A(k)`
and `k*a`, `a*k`, `k + a`, etc. for `k in K` and `a in A`. And `A(a * l)` is
different from `a * A(l)`. Oh man...

It seems to me that this is really dangerous territory - but perhaps
unavoidable. Someone implementing algorithms for `CommutativeAlgebra` is going
to assume that there is coercion from `base` to `self`. And that multiplication
of `base` and `self` elements commute!

Perhaps `CommutativeAlgebra` should be called something different, and
`AlgebraFromMorphism` should have a different base class. I've cc'ed Nicolas
Thiery and Simon King in this discussion to chip in.

> > `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.

> 
> It is not my fault :-). This method is needed by the coercion model.


Eew, yet another symptom that we're perhaps abusing the current hierarchy.

Why doesn't `GF(9)` have `from_base_ring`? What kind of Parent requires it?

> >   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?

> 
> Sure, it is something we normally do... just as composing ring homomorphisms.


So it is something where established mathematical notation supports this
directly? It's much more explicit to just write
`A.scalar_restriction(Aother.ring())`, so I'd prefer not supporting
`A.scalar_restriction(Aother)`, except if a properly educated mathematician
would be very surprised if this didn't exist.

> > I don't like `ring` and `base`. They are too short and it's not clear which is which.

> 
> Ok for changing. I'm also not completed satisfied with these names. Do you have some propositions?


We should probably first figure out what to do hierarchy-wise. But perhaps
keep `ring -> ring_of_element` and `base -> ring_of_scalars`. Alternative `element_ring` resp. `scalar_ring`.

> > Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse!

> 
> I definitely agree that it is not perfect, but I have not found something better :-).
> The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.


What do you mean "is the least we can do"?

Why is this an argument to make left and right actions different? Couldn't you implement the same left/right action, namely mapping `K -> A` by `phi`, followed by multiplication in `A`.

Best,
Johan



---

archive/issue_comments_293041.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2016-09-10T10:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293041",
    "user": "https://github.com/johanrosenkilde"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_293042.json:
```json
{
    "body": "Replying to [comment:9 jsrn]:\n> Perhaps that's not a bad idea: it's nicer that any algebra will have the methods you expect and then throw `NotImplementedError` rather than not advertising the method at all.\n\n\nOK. But, on the other hand, the list of possible methods is possibly quite long. Having a parent with 90% not implemented methods is also not that nice.\n\n> > The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \\cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.\n\n> \n> Hmm, but couldn't there be multiple generators? E.g. `F[x,y]/F`?\n\n\nYes, of course. \n\nFor traditional rings, the current behaviour of `gen` is rather stange (to me):\n\n```\n    sage: R.<x,y> = QQ[]\n    sage: R.gen()\n    x\n```\nIs that normal?\n\n> OK, argument accepted. But I think this kind of stuff reinforces that we should try to design the first concrete `RingExtension`, e.g. `FiniteFieldExtension` simultaneously with this ticket. Then we'll better be able to judge what goes where and how it should look to be useful on both sides.\n\n\nI just do not want this ticket to become too big. \nBut I agree for implementing `FiniteFieldExtension` here.\n\n> Yikes! So we must disallow coercion from `K -> L/K`. But we should allow `A(k)`\n> and `k*a`, `a*k`, `k + a`, etc. for `k in K` and `a in A`. And `A(a * l)` is\n> different from `a * A(l)`. Oh man...\n\n\n(First, let me emphasize that this issue only occurs when the defining morphism is not a coercion map.)\n\nCurrently `A(k)`, `a*k`, `k + a` uses coercion maps (and not defining morphism): for instance, if K coerces to L then `k+a` is the addition in L while if K does not coerce to L, `k+a` produces an error. Only `k*a` (implemented by a left action of K on L/K) uses the defining morphism.\n\nI agree that it is really confusing but the same confusion appears exactly in the same way in the \"theory\". So I assume that people who really wants to work with algebras whose defining morphisms are not coercion maps are very aware of this source of confusion!\n\nWhy left action and not right action? Because usually scalars act on the left (for instance, we write `2x` and not `x2` when x lies in some vector space). I nevertheless agree that this convention is not very strong. Another option would be to implement both actions (at some point I actually did this) but it then becomes impossible to multiply an element of K by an element of L without writing explicitly the conversion.\n\nProbably the best solution would be to have a completely different operator for the action of the base through the defining morphism. But which one? Is it a good idea to override the dot operator?\n\n> Why doesn't `GF(9)` have `from_base_ring`? What kind of Parent requires it?\n\n\nI think (but I'm not quite sure) that it is used when no coercing map is set from `self._base` to `self`.\n\n> So it is something where established mathematical notation supports this\n> directly? It's much more explicit to just write\n> `A.scalar_restriction(Aother.ring())`, so I'd prefer not supporting\n> `A.scalar_restriction(Aother)`, except if a properly educated mathematician\n> would be very surprised if this didn't exist.\n\n\nI think that sometimes mathematicians may want to invoke `A.scalar_restriction(Aother)`. For instance assume that we have an algebra A defined over C[X]. The fibre of A at the point x is by definition the scalar extension of A with respect to the morphism C[X] -> C mapping X to x. (It is actually also A/(X-x), but sometimes we really want to think of it as a scalar extension.)\n\nActually we probably prefer to use the \"base_change\" in that case. So maybe we can implement two methods: first `scalar_extension` which always uses coercion maps and second `base_change` which accepts all constructions.\n\n> > I think that implementing the action of scalars (through the defining morphism) is the least we can do.\n\n> \n> What do you mean \"is the least we can do\"?\n\n\nWhen we want to regard L as a K-algebra, a basic thing we want to have is the action of K on L defining the algebra.",
    "created_at": "2016-09-10T13:34:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293042",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:9 jsrn]:
> Perhaps that's not a bad idea: it's nicer that any algebra will have the methods you expect and then throw `NotImplementedError` rather than not advertising the method at all.


OK. But, on the other hand, the list of possible methods is possibly quite long. Having a parent with 90% not implemented methods is also not that nice.

> > The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.

> 
> Hmm, but couldn't there be multiple generators? E.g. `F[x,y]/F`?


Yes, of course. 

For traditional rings, the current behaviour of `gen` is rather stange (to me):

```
    sage: R.<x,y> = QQ[]
    sage: R.gen()
    x
```
Is that normal?

> OK, argument accepted. But I think this kind of stuff reinforces that we should try to design the first concrete `RingExtension`, e.g. `FiniteFieldExtension` simultaneously with this ticket. Then we'll better be able to judge what goes where and how it should look to be useful on both sides.


I just do not want this ticket to become too big. 
But I agree for implementing `FiniteFieldExtension` here.

> Yikes! So we must disallow coercion from `K -> L/K`. But we should allow `A(k)`
> and `k*a`, `a*k`, `k + a`, etc. for `k in K` and `a in A`. And `A(a * l)` is
> different from `a * A(l)`. Oh man...


(First, let me emphasize that this issue only occurs when the defining morphism is not a coercion map.)

Currently `A(k)`, `a*k`, `k + a` uses coercion maps (and not defining morphism): for instance, if K coerces to L then `k+a` is the addition in L while if K does not coerce to L, `k+a` produces an error. Only `k*a` (implemented by a left action of K on L/K) uses the defining morphism.

I agree that it is really confusing but the same confusion appears exactly in the same way in the "theory". So I assume that people who really wants to work with algebras whose defining morphisms are not coercion maps are very aware of this source of confusion!

Why left action and not right action? Because usually scalars act on the left (for instance, we write `2x` and not `x2` when x lies in some vector space). I nevertheless agree that this convention is not very strong. Another option would be to implement both actions (at some point I actually did this) but it then becomes impossible to multiply an element of K by an element of L without writing explicitly the conversion.

Probably the best solution would be to have a completely different operator for the action of the base through the defining morphism. But which one? Is it a good idea to override the dot operator?

> Why doesn't `GF(9)` have `from_base_ring`? What kind of Parent requires it?


I think (but I'm not quite sure) that it is used when no coercing map is set from `self._base` to `self`.

> So it is something where established mathematical notation supports this
> directly? It's much more explicit to just write
> `A.scalar_restriction(Aother.ring())`, so I'd prefer not supporting
> `A.scalar_restriction(Aother)`, except if a properly educated mathematician
> would be very surprised if this didn't exist.


I think that sometimes mathematicians may want to invoke `A.scalar_restriction(Aother)`. For instance assume that we have an algebra A defined over C[X]. The fibre of A at the point x is by definition the scalar extension of A with respect to the morphism C[X] -> C mapping X to x. (It is actually also A/(X-x), but sometimes we really want to think of it as a scalar extension.)

Actually we probably prefer to use the "base_change" in that case. So maybe we can implement two methods: first `scalar_extension` which always uses coercion maps and second `base_change` which accepts all constructions.

> > I think that implementing the action of scalars (through the defining morphism) is the least we can do.

> 
> What do you mean "is the least we can do"?


When we want to regard L as a K-algebra, a basic thing we want to have is the action of K on L defining the algebra.



---

archive/issue_comments_293043.json:
```json
{
    "body": "I just found this ticket and I only have a vague idea about what this ticket does. I am curious if  the present ticket would solve or at least help one solve each of the following problems (of mine)? I believe that these cases are not supported by Sage yet.\n \n1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. \n\n2. Suppose K is a field and R is a subring of K. Suppose K is the fraction field of R. Let e be an element of K. Then `d=e.denominator(R)` gives a denominator of e in R such that `d*e.numerator(R) ` is in R.\n\n3. Let E,F be rings. Suppose phi is a homomorphism from E to F. I want to extend phi to a homomorphism psi from the polynomial ring R=E[x] to F mapping x to c in F. Thus `psi(a2*x<sup>2+a1*x+a0)==phi(a2)*c</sup>2+phi(a1)*c+phi(a0)`.  Perhaps I want  `R.hom([c],F, base=phi)` or like to work.",
    "created_at": "2016-10-10T09:43:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293043",
    "user": "https://github.com/kwankyu"
}
```

I just found this ticket and I only have a vague idea about what this ticket does. I am curious if  the present ticket would solve or at least help one solve each of the following problems (of mine)? I believe that these cases are not supported by Sage yet.
 
1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. 

2. Suppose K is a field and R is a subring of K. Suppose K is the fraction field of R. Let e be an element of K. Then `d=e.denominator(R)` gives a denominator of e in R such that `d*e.numerator(R) ` is in R.

3. Let E,F be rings. Suppose phi is a homomorphism from E to F. I want to extend phi to a homomorphism psi from the polynomial ring R=E[x] to F mapping x to c in F. Thus `psi(a2*x<sup>2+a1*x+a0)==phi(a2)*c</sup>2+phi(a1)*c+phi(a0)`.  Perhaps I want  `R.hom([c],F, base=phi)` or like to work.



---

archive/issue_comments_293044.json:
```json
{
    "body": "Replying to [comment:11 klee]:\n> 1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. \n\n\nThat currently works fine, just try it.\n\nIf you want to go from `F` back to `E` for any of the elements `phi(E)`, use `phi.section()`.\n\nIf you want to express `F` as a vector space over `E`, things are more limited. We implemented basic support for it in `sage.coding.relative_finite_field_extension`. This ticket is about making that functionality much more general and thought out, and getting it into the core algebra of Sage.\n\n> 2. Suppose K is a field and R is a subring of K. Suppose K is the fraction field of R. Let e be an element of K. Then `d=e.denominator(R)` gives a denominator of e in R such that `d*e.numerator(R) ` is in R.\n\n\nThat also currently works fine. I just tested with `R = GF(3^2)['x']`:\n\n```\nsage: R = GF(3^2)['x']\nsage: K = R.fraction_field()\nsage: e = K.random_element()\nsage: e.denominator()\n(z2 + 2)*x^2 + (z2 + 1)*x\nsage: e.denominator().parent()\nUnivariate Polynomial Ring in x over Finite Field in z2 of size 3^2\nsage: e.denominator() in R\nTrue\nsage: R( e.denominator() * e )\n(2*z2 + 2)*x^2 + (z2 + 2)*x + z2\n```\n\n\n> 3. Let E,F be rings. Suppose phi is a homomorphism from E to F. I want to extend phi to a homomorphism psi from the polynomial ring R=E[x] to F mapping x to c in F. Thus `psi(a2*x<sup>2+a1*x+a0)==phi(a2)*c</sup>2+phi(a1)*c+phi(a0)`.  Perhaps I want  `R.hom([c],F, base=phi)` or like to work. \n\n\nThat seems more tricky to do. Note that it can easily be split into the composition of two homomorphisms:\n\n```\nmapCoef:  E[x]  --> F[x]\n          a*x^i |-> phi(a)*x^i\n\neval:     F[x] --> F\n             x |-> c\n```\n\nThe eval homomorphism can be created in the current Sage, but I don't know how to conveniently create `mapCoef` (as a `Morphism` object).\n\nBest,\nJohan",
    "created_at": "2016-10-10T10:49:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293044",
    "user": "https://github.com/johanrosenkilde"
}
```

Replying to [comment:11 klee]:
> 1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. 


That currently works fine, just try it.

If you want to go from `F` back to `E` for any of the elements `phi(E)`, use `phi.section()`.

If you want to express `F` as a vector space over `E`, things are more limited. We implemented basic support for it in `sage.coding.relative_finite_field_extension`. This ticket is about making that functionality much more general and thought out, and getting it into the core algebra of Sage.

> 2. Suppose K is a field and R is a subring of K. Suppose K is the fraction field of R. Let e be an element of K. Then `d=e.denominator(R)` gives a denominator of e in R such that `d*e.numerator(R) ` is in R.


That also currently works fine. I just tested with `R = GF(3^2)['x']`:

```
sage: R = GF(3^2)['x']
sage: K = R.fraction_field()
sage: e = K.random_element()
sage: e.denominator()
(z2 + 2)*x^2 + (z2 + 1)*x
sage: e.denominator().parent()
Univariate Polynomial Ring in x over Finite Field in z2 of size 3^2
sage: e.denominator() in R
True
sage: R( e.denominator() * e )
(2*z2 + 2)*x^2 + (z2 + 2)*x + z2
```


> 3. Let E,F be rings. Suppose phi is a homomorphism from E to F. I want to extend phi to a homomorphism psi from the polynomial ring R=E[x] to F mapping x to c in F. Thus `psi(a2*x<sup>2+a1*x+a0)==phi(a2)*c</sup>2+phi(a1)*c+phi(a0)`.  Perhaps I want  `R.hom([c],F, base=phi)` or like to work. 


That seems more tricky to do. Note that it can easily be split into the composition of two homomorphisms:

```
mapCoef:  E[x]  --> F[x]
          a*x^i |-> phi(a)*x^i

eval:     F[x] --> F
             x |-> c
```

The eval homomorphism can be created in the current Sage, but I don't know how to conveniently create `mapCoef` (as a `Morphism` object).

Best,
Johan



---

archive/issue_comments_293045.json:
```json
{
    "body": "Replying to [comment:12 jsrn]:\n> Replying to [comment:11 klee]:\n> > 1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. \n  \n> \n> That currently works fine, just try it.\n> \n> If you want to go from `F` back to `E` for any of the elements `phi(E)`, use `phi.section()`.\n> \n> If you want to express `F` as a vector space over `E`, things are more limited. We implemented basic support for it in `sage.coding.relative_finite_field_extension`. This ticket is about making that functionality much more general and thought out, and getting it into the core algebra of Sage.\n\n\nNice. Good luck!",
    "created_at": "2016-10-10T12:47:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293045",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:12 jsrn]:
> Replying to [comment:11 klee]:
> > 1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. 
  
> 
> That currently works fine, just try it.
> 
> If you want to go from `F` back to `E` for any of the elements `phi(E)`, use `phi.section()`.
> 
> If you want to express `F` as a vector space over `E`, things are more limited. We implemented basic support for it in `sage.coding.relative_finite_field_extension`. This ticket is about making that functionality much more general and thought out, and getting it into the core algebra of Sage.


Nice. Good luck!



---

archive/issue_comments_293046.json:
```json
{
    "body": "The following reference might be useful for the design of the class:\n\nLattices of Compatibly Embedded Finite Fields - WIEB BOSMA, JOHN CANNON AND ALLAN STEEL 1997\n\nas various extensions should be compatible to each other...",
    "created_at": "2016-10-11T17:40:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293046",
    "user": "https://github.com/kwankyu"
}
```

The following reference might be useful for the design of the class:

Lattices of Compatibly Embedded Finite Fields - WIEB BOSMA, JOHN CANNON AND ALLAN STEEL 1997

as various extensions should be compatible to each other...



---

archive/issue_comments_293047.json:
```json
{
    "body": "Doctest failures:\n\n```\nsage -t src/sage/rings/algebra_from_morphism.py\n**********************************************************************\nFile \"src/sage/rings/algebra_from_morphism.py\", line 260, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_\nFailed example:\n    E2._pushout_(E1) is E2\nExpected:\n    True\nGot:\n    False\n**********************************************************************\nFile \"src/sage/rings/algebra_from_morphism.py\", line 262, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_\nFailed example:\n    E1._pushout_(E2) is E2\nExpected:\n    True\nGot:\n    False\n**********************************************************************\nFile \"src/sage/rings/algebra_from_morphism.py\", line 265, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_\nFailed example:\n    E1._pushout_(L2) is L2\nExpected:\n    True\nGot:\n    False\n**********************************************************************\nFile \"src/sage/rings/algebra_from_morphism.py\", line 272, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_\nFailed example:\n    E1p._pushout_(E2) is L2\nExpected:\n    True\nGot:\n    False\n**********************************************************************\nFile \"src/sage/rings/algebra_from_morphism.py\", line 276, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_\nFailed example:\n    E1p._pushout_(E2p) is L2\nExpected:\n    True\nGot:\n    False\n**********************************************************************\n1 item had failures:\n   5 of  11 in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_\n    [119 tests, 5 failures, 0.86 s]\n----------------------------------------------------------------------\nsage -t src/sage/rings/algebra_from_morphism.py  # 5 doctests failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.9 seconds\n    cumulative wall time: 0.9 seconds\n```\n\n---\nNew commits:",
    "created_at": "2017-02-07T16:53:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293047",
    "user": "https://github.com/defeo"
}
```

Doctest failures:

```
sage -t src/sage/rings/algebra_from_morphism.py
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 260, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E2._pushout_(E1) is E2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 262, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1._pushout_(E2) is E2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 265, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1._pushout_(L2) is L2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 272, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1p._pushout_(E2) is L2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 276, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1p._pushout_(E2p) is L2
Expected:
    True
Got:
    False
**********************************************************************
1 item had failures:
   5 of  11 in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
    [119 tests, 5 failures, 0.86 s]
----------------------------------------------------------------------
sage -t src/sage/rings/algebra_from_morphism.py  # 5 doctests failed
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.9 seconds
    cumulative wall time: 0.9 seconds
```

---
New commits:



---

archive/issue_comments_293048.json:
```json
{
    "body": "Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:\n\n```\nsage: K = GF(5^2)\nsage: L = GF(5^4)\nsage: E = L.algebra(K, category=Semigroups())\nsage: E\nFree module generated by Finite Field in z4 of size 5^4 over Finite Field in z2 of size 5^2\nsage: E.an_element()\n2*B[0] + 2*B[z4] + 3*B[z4^2]\nsage: E.categories()\n\n[Category of finite dimensional semigroup algebras over Finite Field in z2 of size 5^2,\n Category of semigroup algebras over Finite Field in z2 of size 5^2,\n Category of associative algebras over Finite Field in z2 of size 5^2,\n Category of rngs,\n Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n Category of magma algebras over Finite Field in z2 of size 5^2,\n Category of magmatic algebras with basis over Finite Field in z2 of size 5^2,\n Category of magmatic algebras over Finite Field in z2 of size 5^2,\n Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n Category of additive commutative additive associative distributive magmas and additive magmas,\n Category of additive associative distributive magmas and additive magmas,\n Category of distributive magmas and additive magmas,\n Category of magmas and additive magmas,\n Category of finite semigroups,\n Category of semigroups,\n Category of magmas,\n Category of finite dimensional modules with basis over Finite Field in z2 of size 5^2,\n Category of set algebras over Finite Field in z2 of size 5^2,\n Category of vector spaces with basis over Finite Field in z2 of size 5^2,\n Category of modules with basis over Finite Field in z2 of size 5^2,\n Category of finite dimensional modules over Finite Field in z2 of size 5^2,\n Category of vector spaces over Finite Field in z2 of size 5^2,\n Category of modules over Finite Field in z2 of size 5^2,\n Category of bimodules over Finite Field in z2 of size 5^2 on the left and Finite Field in z2 of size 5^2 on the right,\n Category of right modules over Finite Field in z2 of size 5^2,\n Category of left modules over Finite Field in z2 of size 5^2,\n Category of commutative additive groups,\n Category of additive groups,\n Category of additive inverse additive unital additive magmas,\n Category of commutative additive monoids,\n Category of additive monoids,\n Category of additive unital additive magmas,\n Category of commutative additive semigroups,\n Category of additive commutative additive magmas,\n Category of additive semigroups,\n Category of additive magmas,\n Category of finite sets,\n Category of sets,\n Category of sets with partial maps,\n Category of objects]\n```",
    "created_at": "2017-02-07T17:23:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293048",
    "user": "https://github.com/defeo"
}
```

Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:

```
sage: K = GF(5^2)
sage: L = GF(5^4)
sage: E = L.algebra(K, category=Semigroups())
sage: E
Free module generated by Finite Field in z4 of size 5^4 over Finite Field in z2 of size 5^2
sage: E.an_element()
2*B[0] + 2*B[z4] + 3*B[z4^2]
sage: E.categories()

[Category of finite dimensional semigroup algebras over Finite Field in z2 of size 5^2,
 Category of semigroup algebras over Finite Field in z2 of size 5^2,
 Category of associative algebras over Finite Field in z2 of size 5^2,
 Category of rngs,
 Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,
 Category of magma algebras over Finite Field in z2 of size 5^2,
 Category of magmatic algebras with basis over Finite Field in z2 of size 5^2,
 Category of magmatic algebras over Finite Field in z2 of size 5^2,
 Category of additive commutative additive associative additive unital distributive magmas and additive magmas,
 Category of additive commutative additive associative distributive magmas and additive magmas,
 Category of additive associative distributive magmas and additive magmas,
 Category of distributive magmas and additive magmas,
 Category of magmas and additive magmas,
 Category of finite semigroups,
 Category of semigroups,
 Category of magmas,
 Category of finite dimensional modules with basis over Finite Field in z2 of size 5^2,
 Category of set algebras over Finite Field in z2 of size 5^2,
 Category of vector spaces with basis over Finite Field in z2 of size 5^2,
 Category of modules with basis over Finite Field in z2 of size 5^2,
 Category of finite dimensional modules over Finite Field in z2 of size 5^2,
 Category of vector spaces over Finite Field in z2 of size 5^2,
 Category of modules over Finite Field in z2 of size 5^2,
 Category of bimodules over Finite Field in z2 of size 5^2 on the left and Finite Field in z2 of size 5^2 on the right,
 Category of right modules over Finite Field in z2 of size 5^2,
 Category of left modules over Finite Field in z2 of size 5^2,
 Category of commutative additive groups,
 Category of additive groups,
 Category of additive inverse additive unital additive magmas,
 Category of commutative additive monoids,
 Category of additive monoids,
 Category of additive unital additive magmas,
 Category of commutative additive semigroups,
 Category of additive commutative additive magmas,
 Category of additive semigroups,
 Category of additive magmas,
 Category of finite sets,
 Category of sets,
 Category of sets with partial maps,
 Category of objects]
```



---

archive/issue_comments_293049.json:
```json
{
    "body": "Replying to [comment:17 defeo]:\n> Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:\n\n\nIn what sense would it be relevant for this ticket?",
    "created_at": "2017-02-07T18:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293049",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:17 defeo]:
> Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:


In what sense would it be relevant for this ticket?



---

archive/issue_comments_293050.json:
```json
{
    "body": "Hello, as you might have guessed, I'm trying to resurrect this ticket.\n\nMy biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:\n\n- It is silently not commutative;\n- The parent of `a*k` is neither `A` nor `K`.\n\nHowever I think the fix is simple: explicit is better than implicit, get rid of the coercion `A -> L`. I find the following idiom completely reasonable:\n\n```\nsage: K = GF(5^2); z2 = K.gen()\nsage: L = GF(5^4); z4 = L.gen()\nsage: A = RingExtension(L, K, K.frobenius_endomorphism())\nsage: z2 * E(z4)\n4*z4^3 + 3*z4^2 + 2*z4 + 2\nsage: E(z4) * z2\nTypeError: ...\nsage: L(E(z4)) * z2\nz4^3 + 2*z4^2 + 4*z4 + 3\n```\n\nIt could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).\n\nOr maybe just have the right action be the same as the left action, which apparently you already did.",
    "created_at": "2017-02-07T18:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293050",
    "user": "https://github.com/defeo"
}
```

Hello, as you might have guessed, I'm trying to resurrect this ticket.

My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:

- It is silently not commutative;
- The parent of `a*k` is neither `A` nor `K`.

However I think the fix is simple: explicit is better than implicit, get rid of the coercion `A -> L`. I find the following idiom completely reasonable:

```
sage: K = GF(5^2); z2 = K.gen()
sage: L = GF(5^4); z4 = L.gen()
sage: A = RingExtension(L, K, K.frobenius_endomorphism())
sage: z2 * E(z4)
4*z4^3 + 3*z4^2 + 2*z4 + 2
sage: E(z4) * z2
TypeError: ...
sage: L(E(z4)) * z2
z4^3 + 2*z4^2 + 4*z4 + 3
```

It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).

Or maybe just have the right action be the same as the left action, which apparently you already did.



---

archive/issue_comments_293051.json:
```json
{
    "body": "Replying to [comment:18 SimonKing]:\n> Replying to [comment:17 defeo]:\n> > Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:\n\n> \n> In what sense would it be relevant for this ticket?\n\n\nAt the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.\n\nWe had already discussed of various possible APIs for this, and `L.algebra_over(K)` was one of those. I think Johan was in favour of this kind of API, rather than cluttering the namespace with yet another mysterious name `RingExtension`. It would be quite confusing to have `L.algebra()` and `L.algebra_over()`.",
    "created_at": "2017-02-07T18:31:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293051",
    "user": "https://github.com/defeo"
}
```

Replying to [comment:18 SimonKing]:
> Replying to [comment:17 defeo]:
> > Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:

> 
> In what sense would it be relevant for this ticket?


At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.

We had already discussed of various possible APIs for this, and `L.algebra_over(K)` was one of those. I think Johan was in favour of this kind of API, rather than cluttering the namespace with yet another mysterious name `RingExtension`. It would be quite confusing to have `L.algebra()` and `L.algebra_over()`.



---

archive/issue_comments_293052.json:
```json
{
    "body": "Replying to [comment:19 defeo]:\n> My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:\n> \n> - It is silently not commutative;\n\n\nNo problem, from my perspective. While \"+\" normally denotes a commutative operation in mathematics, \"*\" is generally not supposed to be commutative.\n\n> - The parent of `a*k` is neither `A` nor `K`.\n\n\nWhy would that be a problem? If `a=x+2` is in `ZZ[x]` and `x=1/2` is in `QQ` then `a*x` neither is in `ZZ[x]` nor in `QQ`.\n\n> It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).\n\n\nPerhaps `x>>a` and `a<<x`?\n\nBest regards,\nSimon",
    "created_at": "2017-02-07T20:41:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293052",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:19 defeo]:
> My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:
> 
> - It is silently not commutative;


No problem, from my perspective. While "+" normally denotes a commutative operation in mathematics, "*" is generally not supposed to be commutative.

> - The parent of `a*k` is neither `A` nor `K`.


Why would that be a problem? If `a=x+2` is in `ZZ[x]` and `x=1/2` is in `QQ` then `a*x` neither is in `ZZ[x]` nor in `QQ`.

> It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).


Perhaps `x>>a` and `a<<x`?

Best regards,
Simon



---

archive/issue_comments_293053.json:
```json
{
    "body": "Replying to [comment:20 defeo]:\n> At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.\n\n\nI would not expect `L.algebra(K)` to return `RingExtension(L,K)` but to return the `K`-algebra with basis `L` whose multiplication is induced by the multiplication in  `L` (hence `L` is only supposed to be a multiplicative monoid).\n\n> We had already discussed of various possible APIs for this, and `L.algebra_over(K)` was one of those. I think Johan was in favour of this kind of API, rather than cluttering the namespace with yet another mysterious name `RingExtension`.\n\n\nI agree. When developing SageMath, we should avoid adding further stuff to the global namespace, whenever possible.\n\n> It would be quite confusing to have `L.algebra()` and `L.algebra_over()`.\n\n\nPerhaps a little variation: `L.as_algebra_over(K)`. Or, changing perspective: `L` is an extension **of `K`**; so, `L/K` should be returned by a method of `K`, not by a method of `L`. Say, `K.extension(L)`.",
    "created_at": "2017-02-07T20:52:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293053",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:20 defeo]:
> At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.


I would not expect `L.algebra(K)` to return `RingExtension(L,K)` but to return the `K`-algebra with basis `L` whose multiplication is induced by the multiplication in  `L` (hence `L` is only supposed to be a multiplicative monoid).

> We had already discussed of various possible APIs for this, and `L.algebra_over(K)` was one of those. I think Johan was in favour of this kind of API, rather than cluttering the namespace with yet another mysterious name `RingExtension`.


I agree. When developing SageMath, we should avoid adding further stuff to the global namespace, whenever possible.

> It would be quite confusing to have `L.algebra()` and `L.algebra_over()`.


Perhaps a little variation: `L.as_algebra_over(K)`. Or, changing perspective: `L` is an extension **of `K`**; so, `L/K` should be returned by a method of `K`, not by a method of `L`. Say, `K.extension(L)`.



---

archive/issue_comments_293054.json:
```json
{
    "body": "Replying to [comment:21 SimonKing]:\n> Replying to [comment:19 defeo]:\n> > My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:\n> > \n> > - It is silently not commutative;\n \n> \n> No problem, from my perspective. While \"+\" normally denotes a commutative operation in mathematics, \"*\" is generally not supposed to be commutative.\n\n\nI expect it to be associative, at least. With the proposed code `(k*a)*k != k*(a*k)`.\n\n> > - The parent of `a*k` is neither `A` nor `K`.\n \n> \n> Why would that be a problem? If `a=x+2` is in `ZZ[x]` and `x=1/2` is in `QQ` then `a*x` neither is in `ZZ[x]` nor in `QQ`.\n\n\nI know the coercion system finds common parents, but in your example `parent(a*x) == parent(x*a)`, and I expect the same here. I know there are exceptions even to this (e.g., matrices), but here we are talking about a commutative ring `A`, so I expect `*` to behave like its internal multiplication. \n\nBy a very common stretch of notation, I am glad to accept `k*a` as a shorthand for `phi(k)*a`, but I really don't see why `a*k` should be a shorthand for `L(a)*L(k)`. If we want such exotic semantics, then we should use another symbol than `*`. See below\n\n> > It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).\n\n> \n> Perhaps `x>>a` and `a<<x`?\n\n\nThat's quite ugly, but as I said, it would be the only sensible way to support such exotic semantics.\n\nLet's keep in mind that 90% of Sage users are going to use this to work with field extensions of finite fields or number fields. They expect `k*a` to mean \"scalar multiplication of `a` by `k`\", not to raise an exception.\n\nThe uses proposed by Xavier are certainly important, and it would be nice to support them, but I think those mathematicians who want to work with them should be ready to accept a slightly more explicit notation (an explicit conversion, or a different operator). If they really want to have `k*a == a*k^p`, then they should use a dedicated class such as `SkewPolynomialRing`.",
    "created_at": "2017-02-07T22:12:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293054",
    "user": "https://github.com/defeo"
}
```

Replying to [comment:21 SimonKing]:
> Replying to [comment:19 defeo]:
> > My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:
> > 
> > - It is silently not commutative;
 
> 
> No problem, from my perspective. While "+" normally denotes a commutative operation in mathematics, "*" is generally not supposed to be commutative.


I expect it to be associative, at least. With the proposed code `(k*a)*k != k*(a*k)`.

> > - The parent of `a*k` is neither `A` nor `K`.
 
> 
> Why would that be a problem? If `a=x+2` is in `ZZ[x]` and `x=1/2` is in `QQ` then `a*x` neither is in `ZZ[x]` nor in `QQ`.


I know the coercion system finds common parents, but in your example `parent(a*x) == parent(x*a)`, and I expect the same here. I know there are exceptions even to this (e.g., matrices), but here we are talking about a commutative ring `A`, so I expect `*` to behave like its internal multiplication. 

By a very common stretch of notation, I am glad to accept `k*a` as a shorthand for `phi(k)*a`, but I really don't see why `a*k` should be a shorthand for `L(a)*L(k)`. If we want such exotic semantics, then we should use another symbol than `*`. See below

> > It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).

> 
> Perhaps `x>>a` and `a<<x`?


That's quite ugly, but as I said, it would be the only sensible way to support such exotic semantics.

Let's keep in mind that 90% of Sage users are going to use this to work with field extensions of finite fields or number fields. They expect `k*a` to mean "scalar multiplication of `a` by `k`", not to raise an exception.

The uses proposed by Xavier are certainly important, and it would be nice to support them, but I think those mathematicians who want to work with them should be ready to accept a slightly more explicit notation (an explicit conversion, or a different operator). If they really want to have `k*a == a*k^p`, then they should use a dedicated class such as `SkewPolynomialRing`.



---

archive/issue_comments_293055.json:
```json
{
    "body": "Replying to [comment:22 SimonKing]:\n> Replying to [comment:20 defeo]:\n> > At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.\n\n> \n> I would not expect `L.algebra(K)` to return `RingExtension(L,K)` but to return the `K`-algebra with basis `L` whose multiplication is induced by the multiplication in  `L` (hence `L` is only supposed to be a multiplicative monoid).\n\n\nI frankly don't know what I expect from `L.algebra(K)`. I would run it, and see what comes out.\n\n> Perhaps a little variation: `L.as_algebra_over(K)`. Or, changing perspective: `L` is an extension **of `K`**; so, `L/K` should be returned by a method of `K`, not by a method of `L`. Say, `K.extension(L)`.\n\n\nWe had already considered this possibility. The problem is that `K.extension()` is already defined for most rings, and it returns a ring. It wouldn't break compatibility, but it would be a bit surprising if `QQ.extension(x^2+1)` returned a number field, whereas `QQ.extension(K)` returned an algebra object.\n\nOf course, it could be `K.extension_algebra(L)`.",
    "created_at": "2017-02-07T22:23:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293055",
    "user": "https://github.com/defeo"
}
```

Replying to [comment:22 SimonKing]:
> Replying to [comment:20 defeo]:
> > At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.

> 
> I would not expect `L.algebra(K)` to return `RingExtension(L,K)` but to return the `K`-algebra with basis `L` whose multiplication is induced by the multiplication in  `L` (hence `L` is only supposed to be a multiplicative monoid).


I frankly don't know what I expect from `L.algebra(K)`. I would run it, and see what comes out.

> Perhaps a little variation: `L.as_algebra_over(K)`. Or, changing perspective: `L` is an extension **of `K`**; so, `L/K` should be returned by a method of `K`, not by a method of `L`. Say, `K.extension(L)`.


We had already considered this possibility. The problem is that `K.extension()` is already defined for most rings, and it returns a ring. It wouldn't break compatibility, but it would be a bit surprising if `QQ.extension(x^2+1)` returned a number field, whereas `QQ.extension(K)` returned an algebra object.

Of course, it could be `K.extension_algebra(L)`.



---

archive/issue_comments_293056.json:
```json
{
    "body": "I am just reading up on this ticket, it has quote a long discussion. Does it still really need info? If so could someone who knows what info put that in the ticket description?",
    "created_at": "2017-09-11T11:21:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293056",
    "user": "https://github.com/koffie"
}
```

I am just reading up on this ticket, it has quote a long discussion. Does it still really need info? If so could someone who knows what info put that in the ticket description?



---

archive/issue_comments_293057.json:
```json
{
    "body": "The \"info\" the ticket needs is a few decisions on trickier points of the design. But perhaps what would be most useful is a concrete suggestion by updating the ticket's code. I would personally also really like to see how e.g. a finite field extension of #20284 would be instantiated in the current - quite abstract - proposal.",
    "created_at": "2017-09-11T14:37:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293057",
    "user": "https://github.com/johanrosenkilde"
}
```

The "info" the ticket needs is a few decisions on trickier points of the design. But perhaps what would be most useful is a concrete suggestion by updating the ticket's code. I would personally also really like to see how e.g. a finite field extension of #20284 would be instantiated in the current - quite abstract - proposal.



---

archive/issue_comments_293058.json:
```json
{
    "body": "Yes I agree that is important to get the design right, especially since this touches something that touches quite a few areas of sage, since finite fields are far from the only place that one wants to consider relative extensions.\n\nIt is quite difficult for me to grasp what the \"current proposal\" is from the all the discussion that has been going on here. Or is the the [one linked to in the description](https://gist.github.com/defeo/cabab27ea93aeb9e0deb0ba8c5bc745b). I need this for something else as well so I plan to work on this.\n\nWhat I think is that sage already has a class for relative extensions, and that class is called CommutativeAlgebra from sage.rings.ring  . The only problem is that right now that class is a dummy class which has almost nothing implemented yet. \n\nSo what I propose is the following, try to put as much general code as possible in CommutativeAlgebra and set up a framework there that makes it easy later for concrete implementations of rings/fields to see themselves as Algebras over over other bases then their current base. And use this framework to make things work as follows:\n\n```\nsage: GF(81).vector_space() #note this already works\nVector space of dimension 4 over Finite Field of size 3\nsage: GF81_as_GF_9_algeba = Algebras(GF(9))(GF(81))\nsage: GF81_as_GF_9_algeba.vector_space()\nVector space of dimension 2 over Finite Field in z2 of size 3^2\n```\n\nFor the more complicated cases where there is no coercion morphism yet we can try to make the following work\n\n```\nAlgebras(GF(9))(GF(81), morphism=my_morhpism)\n```",
    "created_at": "2017-09-11T17:19:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293058",
    "user": "https://github.com/koffie"
}
```

Yes I agree that is important to get the design right, especially since this touches something that touches quite a few areas of sage, since finite fields are far from the only place that one wants to consider relative extensions.

It is quite difficult for me to grasp what the "current proposal" is from the all the discussion that has been going on here. Or is the the [one linked to in the description](https://gist.github.com/defeo/cabab27ea93aeb9e0deb0ba8c5bc745b). I need this for something else as well so I plan to work on this.

What I think is that sage already has a class for relative extensions, and that class is called CommutativeAlgebra from sage.rings.ring  . The only problem is that right now that class is a dummy class which has almost nothing implemented yet. 

So what I propose is the following, try to put as much general code as possible in CommutativeAlgebra and set up a framework there that makes it easy later for concrete implementations of rings/fields to see themselves as Algebras over over other bases then their current base. And use this framework to make things work as follows:

```
sage: GF(81).vector_space() #note this already works
Vector space of dimension 4 over Finite Field of size 3
sage: GF81_as_GF_9_algeba = Algebras(GF(9))(GF(81))
sage: GF81_as_GF_9_algeba.vector_space()
Vector space of dimension 2 over Finite Field in z2 of size 3^2
```

For the more complicated cases where there is no coercion morphism yet we can try to make the following work

```
Algebras(GF(9))(GF(81), morphism=my_morhpism)
```



---

archive/issue_comments_293059.json:
```json
{
    "body": "The main objection by `@`caruso, and the reason for the code he wrote, was that most on the interface, and some algorithms, can also be useful for non-commutative algebras.\n\nHe is especially interested in \"skew algebras\". Citing [comment:8 `@`caruso]:\n\n> The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.",
    "created_at": "2017-09-11T20:16:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293059",
    "user": "https://github.com/defeo"
}
```

The main objection by `@`caruso, and the reason for the code he wrote, was that most on the interface, and some algorithms, can also be useful for non-commutative algebras.

He is especially interested in "skew algebras". Citing [comment:8 `@`caruso]:

> The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.



---

archive/issue_comments_293060.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-05T11:20:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293060",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293061.json:
```json
{
    "body": "I inexplicably got remotivated to revive and work on this, despite its marathon\ndiscussion and open questions. I'll try to summarise the design problems we are\nfacing along with solution proposals in the following.\n\n**Naming:** Of the now many suggestions, I really like that the algebra `L/K`\ncould be obtained from `K.extension_algebra(L)`. `AlgebraWithMorphism` should\nnot be exposed in the global namespace since it is too abstract to have any\nuseful functionality in itself.\n\n**The commutativity issue:** The issue is that in the current proposal, if `A = L/K` uses a defining map `phi` which is _not_ the coercion map of `K` in `L`, then\n`k*a == phi(k)*a`, while `a*k == a*L(k)`. This could cause confusion for users,\nbut also developers since the class of `A` currently derives from\n`CommutativeAlgebra` (In `A` we do guarantee that `a1 * a2 = a2 * a1`)\n\nIt has been suggested to let `*` be commutative and mean `k * a = a * k = a * L(k)`, and introduce a new operator for `phi(k) * a`. I propose using the\nbinary-and operator for this purpose, `&`, and hence\n\n```\n   k & a = a & k = phi(k) * a = a * phi(k) = A(k) * a = a * A(k)\n```\n\n**The issue with `L.algebra`:** The issue is that there is an existing method\n `L.algebra(K)`, which does something different from what we want. One way to\n alleviate confusion suggested by Simon is to introduce the method\n`L.as_algebra_over(K)`. I see no reason why we could not have both this as well\n as `K.extension_algebra(L)`.\n\n**Writing `GF(q^m)/GF(q)` in this ticket:** I still advocate that we should write a\n (bare-bone) implementation of this particular ring extension in this ticket. We\n need to see the abstract class in action to properly judge whether the design\n is at least not crazy.",
    "created_at": "2019-06-26T13:32:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293061",
    "user": "https://github.com/johanrosenkilde"
}
```

I inexplicably got remotivated to revive and work on this, despite its marathon
discussion and open questions. I'll try to summarise the design problems we are
facing along with solution proposals in the following.

**Naming:** Of the now many suggestions, I really like that the algebra `L/K`
could be obtained from `K.extension_algebra(L)`. `AlgebraWithMorphism` should
not be exposed in the global namespace since it is too abstract to have any
useful functionality in itself.

**The commutativity issue:** The issue is that in the current proposal, if `A = L/K` uses a defining map `phi` which is _not_ the coercion map of `K` in `L`, then
`k*a == phi(k)*a`, while `a*k == a*L(k)`. This could cause confusion for users,
but also developers since the class of `A` currently derives from
`CommutativeAlgebra` (In `A` we do guarantee that `a1 * a2 = a2 * a1`)

It has been suggested to let `*` be commutative and mean `k * a = a * k = a * L(k)`, and introduce a new operator for `phi(k) * a`. I propose using the
binary-and operator for this purpose, `&`, and hence

```
   k & a = a & k = phi(k) * a = a * phi(k) = A(k) * a = a * A(k)
```

**The issue with `L.algebra`:** The issue is that there is an existing method
 `L.algebra(K)`, which does something different from what we want. One way to
 alleviate confusion suggested by Simon is to introduce the method
`L.as_algebra_over(K)`. I see no reason why we could not have both this as well
 as `K.extension_algebra(L)`.

**Writing `GF(q^m)/GF(q)` in this ticket:** I still advocate that we should write a
 (bare-bone) implementation of this particular ring extension in this ticket. We
 need to see the abstract class in action to properly judge whether the design
 is at least not crazy.



---

archive/issue_comments_293062.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2019-06-26T13:32:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293062",
    "user": "https://github.com/johanrosenkilde"
}
```

Changing status from needs_info to needs_work.



---

archive/issue_comments_293063.json:
```json
{
    "body": "Replying to [comment:32 jsrn]:\n> **Writing `GF(q^m)/GF(q)` in this ticket:** I still advocate that we should write a\n>  (bare-bone) implementation of this particular ring extension in this ticket. We\n>  need to see the abstract class in action to properly judge whether the design\n>  is at least not crazy.\n\n\nActually I have a plan to remove the experimental `RelativeFiniteFieldExtension`  module from the coding section of Sage, right after the cleanup ticket #27634. For one thing, the module is ill-placed. For another, codes can live without it -- I checked this.\n\nBy the way, welcome back Johan!",
    "created_at": "2019-06-26T14:19:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293063",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:32 jsrn]:
> **Writing `GF(q^m)/GF(q)` in this ticket:** I still advocate that we should write a
>  (bare-bone) implementation of this particular ring extension in this ticket. We
>  need to see the abstract class in action to properly judge whether the design
>  is at least not crazy.


Actually I have a plan to remove the experimental `RelativeFiniteFieldExtension`  module from the coding section of Sage, right after the cleanup ticket #27634. For one thing, the module is ill-placed. For another, codes can live without it -- I checked this.

By the way, welcome back Johan!



---

archive/issue_comments_293064.json:
```json
{
    "body": "Changing keywords from \"sd75\" to \"sd75, padicBordeaux\".",
    "created_at": "2019-09-07T12:14:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293064",
    "user": "https://github.com/roed314"
}
```

Changing keywords from "sd75" to "sd75, padicBordeaux".



---

archive/issue_comments_293065.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-10T15:09:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293065",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293066.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-10T16:21:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293066",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293067.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-10T20:38:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293067",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293068.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-11T17:20:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293068",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293069.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-11T21:17:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293069",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293070.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-12T12:15:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293070",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293071.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-12T12:50:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293071",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293072.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-12T13:20:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293072",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293073.json:
```json
{
    "body": "`is_finite` should not return `True` btw as this is about cardinality.",
    "created_at": "2019-09-12T16:42:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293073",
    "user": "https://github.com/saraedum"
}
```

`is_finite` should not return `True` btw as this is about cardinality.



---

archive/issue_comments_293074.json:
```json
{
    "body": "It appears that your homs cannot handle generators?\n\nThe following happens in the new finite field code:\n\n```\nsage: GF(3^2).extension(3, absolute=False)._any_embedding(GF(3^12))\n```\n\nproduces\n\n```\n        if codomain.has_coerce_map_from(self):\n      File \"sage/structure/parent.pyx\", line 1969, in sage.structure.parent.Parent.has_coerce_map_from (build/cythonized/sage/structure/parent.c:16392)\n        cpdef bint has_coerce_map_from(self, S) except -2:\n      File \"sage/structure/parent.pyx\", line 1991, in sage.structure.parent.Parent.has_coerce_map_from (build/cythonized/sage/structure/parent.c:16343)\n        return self._internal_coerce_map_from(S) is not None\n      File \"sage/structure/parent.pyx\", line 2133, in sage.structure.parent.Parent._internal_coerce_map_from (build/cythonized/sage/structure/parent.c:17274)\n        mor = self.discover_coerce_map_from(S)\n      File \"sage/structure/parent.pyx\", line 2270, in sage.structure.parent.Parent.discover_coerce_map_from (build/cythonized/sage/structure/parent.c:17722)\n        user_provided_mor = self._coerce_map_from_(S)\n      File \"sage/rings/finite_rings/finite_field_base.pyx\", line 1334, in sage.rings.finite_rings.finite_field_base.FiniteField._coerce_map_from_ (build/cythonized/sage/rings/finite_rings/finite_field_base.c:15164)\n        return R.hom((self.gen() ** ((self.order() - 1)//(R.order() - 1)),))\n      File \"sage/structure/parent_gens.pyx\", line 291, in sage.structure.parent_gens.ParentWithGens.hom (build/cythonized/sage/structure/parent_gens.c:3689)\n        return parent.Parent.hom(self, im_gens, codomain, base_map=base_map, category=category, check=check)\n      File \"sage/structure/parent.pyx\", line 1363, in sage.structure.parent.Parent.hom (build/cythonized/sage/structure/parent.c:11767)\n        return self.Hom(codomain, **Hom_kwds)(im_gens, **kwds)\n      File \"/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension_homset.py\", line 7, in __call__\n        return RingExtensionHomomorphism(self, *args, **kwargs)\n      File \"sage/rings/ring_extension_morphism.pyx\", line 74, in sage.rings.ring_extension_morphism.RingExtensionHomomorphism.__init__ (build/cythonized/sage/rings/ring_extension_morphism.c:4992)\n        backend = backend_morphism(backend)\n      File \"sage/rings/ring_extension_morphism.pyx\", line 33, in sage.rings.ring_extension_morphism.backend_morphism (build/cythonized/sage/rings/ring_extension_morphism.c:3757)\n        g = _backend_morphism(f)\n      File \"sage/rings/ring_extension_morphism.pyx\", line 22, in sage.rings.ring_extension_morphism._backend_morphism (build/cythonized/sage/rings/ring_extension_morphism.c:3355)\n        if not isinstance(f.domain(), RingExtension_class) and not isinstance(f.codomain(), RingExtension_class):\n    AttributeError: 'list' object has no attribute 'domain'\n```\n\nwhere `any_embedding` looks like this:\n\n```\n    def _any_embedding(self, codomain):\n        if codomain.has_coerce_map_from(self):\n            return codomain.coerce_map_from(self)\n\n        base_hom = self.base_ring()._any_embedding(codomain)\n        minpoly = self.gen().minpoly().change_ring(base_hom)\n        return self.hom(codomain, [minpoly.any_root()], base_map=base_hom)\n```\n\nHere is some more info about this:\n\n```\nsage: k = GF(3^2).extension(3, absolute=False)\nsage: l = GF(3^12)\nsage: k._defining_morphism\nRing morphism:\n  From: Finite Field in z2 of size 3^2\n  To:   Finite Field in b729 of size 3^6\n  Defn: z2 |--> 2*b729^5 + 2*b729^3 + b729^2 + 2*b729 + 2\nsage: l.has_coerce_map_from(k) *boom*\n```",
    "created_at": "2019-09-12T17:43:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293074",
    "user": "https://github.com/saraedum"
}
```

It appears that your homs cannot handle generators?

The following happens in the new finite field code:

```
sage: GF(3^2).extension(3, absolute=False)._any_embedding(GF(3^12))
```

produces

```
        if codomain.has_coerce_map_from(self):
      File "sage/structure/parent.pyx", line 1969, in sage.structure.parent.Parent.has_coerce_map_from (build/cythonized/sage/structure/parent.c:16392)
        cpdef bint has_coerce_map_from(self, S) except -2:
      File "sage/structure/parent.pyx", line 1991, in sage.structure.parent.Parent.has_coerce_map_from (build/cythonized/sage/structure/parent.c:16343)
        return self._internal_coerce_map_from(S) is not None
      File "sage/structure/parent.pyx", line 2133, in sage.structure.parent.Parent._internal_coerce_map_from (build/cythonized/sage/structure/parent.c:17274)
        mor = self.discover_coerce_map_from(S)
      File "sage/structure/parent.pyx", line 2270, in sage.structure.parent.Parent.discover_coerce_map_from (build/cythonized/sage/structure/parent.c:17722)
        user_provided_mor = self._coerce_map_from_(S)
      File "sage/rings/finite_rings/finite_field_base.pyx", line 1334, in sage.rings.finite_rings.finite_field_base.FiniteField._coerce_map_from_ (build/cythonized/sage/rings/finite_rings/finite_field_base.c:15164)
        return R.hom((self.gen() ** ((self.order() - 1)//(R.order() - 1)),))
      File "sage/structure/parent_gens.pyx", line 291, in sage.structure.parent_gens.ParentWithGens.hom (build/cythonized/sage/structure/parent_gens.c:3689)
        return parent.Parent.hom(self, im_gens, codomain, base_map=base_map, category=category, check=check)
      File "sage/structure/parent.pyx", line 1363, in sage.structure.parent.Parent.hom (build/cythonized/sage/structure/parent.c:11767)
        return self.Hom(codomain, **Hom_kwds)(im_gens, **kwds)
      File "/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension_homset.py", line 7, in __call__
        return RingExtensionHomomorphism(self, *args, **kwargs)
      File "sage/rings/ring_extension_morphism.pyx", line 74, in sage.rings.ring_extension_morphism.RingExtensionHomomorphism.__init__ (build/cythonized/sage/rings/ring_extension_morphism.c:4992)
        backend = backend_morphism(backend)
      File "sage/rings/ring_extension_morphism.pyx", line 33, in sage.rings.ring_extension_morphism.backend_morphism (build/cythonized/sage/rings/ring_extension_morphism.c:3757)
        g = _backend_morphism(f)
      File "sage/rings/ring_extension_morphism.pyx", line 22, in sage.rings.ring_extension_morphism._backend_morphism (build/cythonized/sage/rings/ring_extension_morphism.c:3355)
        if not isinstance(f.domain(), RingExtension_class) and not isinstance(f.codomain(), RingExtension_class):
    AttributeError: 'list' object has no attribute 'domain'
```

where `any_embedding` looks like this:

```
    def _any_embedding(self, codomain):
        if codomain.has_coerce_map_from(self):
            return codomain.coerce_map_from(self)

        base_hom = self.base_ring()._any_embedding(codomain)
        minpoly = self.gen().minpoly().change_ring(base_hom)
        return self.hom(codomain, [minpoly.any_root()], base_map=base_hom)
```

Here is some more info about this:

```
sage: k = GF(3^2).extension(3, absolute=False)
sage: l = GF(3^12)
sage: k._defining_morphism
Ring morphism:
  From: Finite Field in z2 of size 3^2
  To:   Finite Field in b729 of size 3^6
  Defn: z2 |--> 2*b729^5 + 2*b729^3 + b729^2 + 2*b729 + 2
sage: l.has_coerce_map_from(k) *boom*
```



---

archive/issue_comments_293075.json:
```json
{
    "body": "Also, it seems that you want to make this change to ignore any check here\n\n```\ndiff --git a/src/sage/rings/ring_extension_morphism.pyx b/src/sage/rings/ring_extension_morphism.pyx\nindex 3028d763ec..644273ddd3 100644\n--- a/src/sage/rings/ring_extension_morphism.pyx\n+++ b/src/sage/rings/ring_extension_morphism.pyx\n@@ -63,7 +63,7 @@ cdef class RingExtensionHomomorphism(RingHomomorphism):\n         sage: E2 = RingExtension(L,K)\n \n     \"\"\"\n-    def __init__(self, parent, backend):\n+    def __init__(self, parent, backend, check=None):\n         RingHomomorphism.__init__(self, parent)\n         backend_domain = self.domain()\n         if isinstance(backend_domain, RingExtension_class):\n```",
    "created_at": "2019-09-12T17:44:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293075",
    "user": "https://github.com/saraedum"
}
```

Also, it seems that you want to make this change to ignore any check here

```
diff --git a/src/sage/rings/ring_extension_morphism.pyx b/src/sage/rings/ring_extension_morphism.pyx
index 3028d763ec..644273ddd3 100644
--- a/src/sage/rings/ring_extension_morphism.pyx
+++ b/src/sage/rings/ring_extension_morphism.pyx
@@ -63,7 +63,7 @@ cdef class RingExtensionHomomorphism(RingHomomorphism):
         sage: E2 = RingExtension(L,K)
 
     """
-    def __init__(self, parent, backend):
+    def __init__(self, parent, backend, check=None):
         RingHomomorphism.__init__(self, parent)
         backend_domain = self.domain()
         if isinstance(backend_domain, RingExtension_class):
```



---

archive/issue_comments_293076.json:
```json
{
    "body": "I think that `RingExtension_class` shouldn't be a `UniqueRepresentation`. Instead `RingExtension` should be a factory. Otherwise, I probably can't inherit from `RingExtension_class` for classes that are served through a `UniqueFactory`.",
    "created_at": "2019-09-12T21:49:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293076",
    "user": "https://github.com/saraedum"
}
```

I think that `RingExtension_class` shouldn't be a `UniqueRepresentation`. Instead `RingExtension` should be a factory. Otherwise, I probably can't inherit from `RingExtension_class` for classes that are served through a `UniqueFactory`.



---

archive/issue_comments_293077.json:
```json
{
    "body": "Working on p-adic extensions with this I am now stuck at this that I cannot make much sense of.\n\nGo to https://gitlab-hooks-flau3jeaza-ew.a.run.app/status/dev/branch/general-extensions click \"Launch Binder\" and type in\n\n```\nL.<a> = Qp(2).extension(x)\n```\n\nto get\n\n```\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension.pyc in __init__(self, defining_morphism, basis, names, coerce, check)\n    616     def __init__(self, defining_morphism, basis, names=None, coerce=False, check=True):\n    617         RingExtension_class.__init__(self, defining_morphism, coerce)\n--> 618         self._basis = [ self(b) for b in basis ]\n    619         if names is None:\n    620             names = [ ]\n\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9203)()\n    898         if mor is not None:\n    899             if no_extra_args:\n--> 900                 return mor._call_(x)\n    901             else:\n    902                 return mor._call_with_args(x, args, kwds)\n\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension_morphism.pyx in sage.rings.ring_extension_morphism.RingExtensionHomomorphism._call_ (build/cythonized/sage/rings/ring_extension_morphism.c:5278)()\n     85         if isinstance(self.domain(), RingExtension_class):\n     86             x = x._backend()\n---> 87         y = self._backend_morphism(x)\n     88         if isinstance(self.codomain(), RingExtension_class):\n     89             y = self._codomain(y)\n\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/categories/map.pyx in sage.categories.map.Map.__call__ (build/cythonized/sage/categories/map.c:6517)()\n    771         if P is D: # we certainly want to call _call_/with_args\n    772             if not args and not kwds:\n--> 773                 return self._call_(x)\n    774             return self._call_with_args(x, args, kwds)\n    775         # Is there coercion?\n\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/morphism.pyx in sage.rings.morphism.RingHomomorphism_im_gens._call_ (build/cythonized/sage/rings/morphism.c:9428)()\n   1285             2*x + 3*y + 2*z\n   1286         \"\"\"\n-> 1287         return x._im_gens_(self.codomain(), self.im_gens(), base_map=self.base_map())\n   1288 \n   1289 \n\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/structure/element.pyx in sage.structure.element.Element._im_gens_ (build/cythonized/sage/structure/element.c:5592)()\n    615         tuple of elements of im_gens.\n    616         \"\"\"\n--> 617         raise NotImplementedError\n    618 \n    619     cpdef base_extend(self, R):\n\nNotImplementedError: \n```",
    "created_at": "2019-09-12T22:48:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293077",
    "user": "https://github.com/saraedum"
}
```

Working on p-adic extensions with this I am now stuck at this that I cannot make much sense of.

Go to https://gitlab-hooks-flau3jeaza-ew.a.run.app/status/dev/branch/general-extensions click "Launch Binder" and type in

```
L.<a> = Qp(2).extension(x)
```

to get

```
/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension.pyc in __init__(self, defining_morphism, basis, names, coerce, check)
    616     def __init__(self, defining_morphism, basis, names=None, coerce=False, check=True):
    617         RingExtension_class.__init__(self, defining_morphism, coerce)
--> 618         self._basis = [ self(b) for b in basis ]
    619         if names is None:
    620             names = [ ]

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9203)()
    898         if mor is not None:
    899             if no_extra_args:
--> 900                 return mor._call_(x)
    901             else:
    902                 return mor._call_with_args(x, args, kwds)

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension_morphism.pyx in sage.rings.ring_extension_morphism.RingExtensionHomomorphism._call_ (build/cythonized/sage/rings/ring_extension_morphism.c:5278)()
     85         if isinstance(self.domain(), RingExtension_class):
     86             x = x._backend()
---> 87         y = self._backend_morphism(x)
     88         if isinstance(self.codomain(), RingExtension_class):
     89             y = self._codomain(y)

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/categories/map.pyx in sage.categories.map.Map.__call__ (build/cythonized/sage/categories/map.c:6517)()
    771         if P is D: # we certainly want to call _call_/with_args
    772             if not args and not kwds:
--> 773                 return self._call_(x)
    774             return self._call_with_args(x, args, kwds)
    775         # Is there coercion?

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/morphism.pyx in sage.rings.morphism.RingHomomorphism_im_gens._call_ (build/cythonized/sage/rings/morphism.c:9428)()
   1285             2*x + 3*y + 2*z
   1286         """
-> 1287         return x._im_gens_(self.codomain(), self.im_gens(), base_map=self.base_map())
   1288 
   1289 

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/structure/element.pyx in sage.structure.element.Element._im_gens_ (build/cythonized/sage/structure/element.c:5592)()
    615         tuple of elements of im_gens.
    616         """
--> 617         raise NotImplementedError
    618 
    619     cpdef base_extend(self, R):

NotImplementedError: 
```



---

archive/issue_comments_293078.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-13T12:40:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293078",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293079.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-13T13:51:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293079",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293080.json:
```json
{
    "body": "I think we should change this:\n\n```\n/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension.py(699)__init__()\n    697             RingExtensionWithBasis.__init__(self, defining_morphism, basis, names, coerce, check)\n    698         except ValueError:\n--> 699             raise ValueError(\"the given element is not a generator\")\n```\n\nThe actual error was: `*** ValueError: too many values to unpack`. Essentially a syntax error that now manifested in that strange way.\n\nWe probably do not want to catch at all here but instead add a comment in the line above `RingExtensionWithBasis.__init__(\u2026)` that says something like `if you see a ValueError here, gen is probably not a generator`.",
    "created_at": "2019-09-13T14:03:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293080",
    "user": "https://github.com/saraedum"
}
```

I think we should change this:

```
/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension.py(699)__init__()
    697             RingExtensionWithBasis.__init__(self, defining_morphism, basis, names, coerce, check)
    698         except ValueError:
--> 699             raise ValueError("the given element is not a generator")
```

The actual error was: `*** ValueError: too many values to unpack`. Essentially a syntax error that now manifested in that strange way.

We probably do not want to catch at all here but instead add a comment in the line above `RingExtensionWithBasis.__init__()` that says something like `if you see a ValueError here, gen is probably not a generator`.



---

archive/issue_comments_293081.json:
```json
{
    "body": "You might want to cherry pick these two commits:\n\nhttps://gitlab.com/sagemath/sage/merge_requests/33/diffs?commit_id=2482826f13425776a95576fbe8a602b636259ad3\n\nhttps://gitlab.com/sagemath/sage/merge_requests/33/diffs?commit_id=d044c89f78c0d0b6f6db2042b5c1e30ddb8b27b8\n\n(or just manually copy them over.)",
    "created_at": "2019-09-13T14:44:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293081",
    "user": "https://github.com/saraedum"
}
```

You might want to cherry pick these two commits:

https://gitlab.com/sagemath/sage/merge_requests/33/diffs?commit_id=2482826f13425776a95576fbe8a602b636259ad3

https://gitlab.com/sagemath/sage/merge_requests/33/diffs?commit_id=d044c89f78c0d0b6f6db2042b5c1e30ddb8b27b8

(or just manually copy them over.)



---

archive/issue_comments_293082.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-13T15:20:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293082",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293083.json:
```json
{
    "body": "We worked with David Roe and Julian R\u00fcth on this ticket this week and finally decided to follow a different approach. We defined a coercion map from `K` to the extension `A = L/K` (coming from the defining morphism) but no coercion map from `A` to `L` (except when `K` coerces to `L` through the defining morphism of the extension). Consequently `a*k` is always the same as `k*a` (and is equal to `phi(k)*a` where `phi` is the defining morphism) but differs from `l*k`.\n\nThis point of view looked good to us because, in the use cases we have in mind (typically implementing field towers), the defining morphisms are basically never coercion maps but we definitely don't want to use the ``@`` operator to perform multiplications in the tower.\n\nWe also implemented special classes for finite field extensions. Below is a short demo showing the capabilities provided by this ticket.\n\nWe first create several a bunch of number fields and define a tower of extension `QQ -> AA -> BB -> CC`. (Currently, the tower is not that easy to define because we still miss a good `extension` method; we will implement it soon, hopefully.)\n\n``` \nsage: A.<a> = QQ.extension(x^2 - 2)\nsage: B.<b> = QQ.extension(x^4 - 2)\nsage: C.<c> = QQ.extension(x^12 - 2)\n\n# We create extensions\nsage: AA.<a> = RingExtension(QQ)\nsage: f = Hom(AA,B)(A.hom([b^2]))\nsage: BB.<b> = RingExtension(f)\nsage: g = Hom(BB,C)(B.hom([c^3]))\nsage: CC.<c> = RingExtension(g)\n```\n\nNow we have our tower `QQ -> AA -> BB -> CC`. Let's play with it.\n\n```\nsage: AA\nRing in a with defining polynomial x^2 - 2 over its base\nsage: BB\nRing in b with defining polynomial x^2 - a over its base\nsage: CC\nRing in c with defining polynomial x^3 - b over its base\n\nsage: CC.base_field()\nRing in b with defining polynomial x^2 - a over its base\nsage: CC.base_field() is BB\nTrue\nsage: BB.base_field() is AA\nTrue\nsage: CC.intermediate_rings()\n[Ring in c with defining polynomial x^3 - b over its base,\n Ring in b with defining polynomial x^2 - a over its base,\n Ring in a with defining polynomial x^2 - 2 over its base,\n Number Field in void with defining polynomial x]\n\nsage: CC.gens()\n(c,)\n```\n\nThe `gens` method has also a relative version\n\n```\nsage: CC.gens(AA)   # generators over AA\n(c,b)\nsage: CC.gens(QQ)\n(c,b,a)\n```\n\nAnd also:\n\n```\nsage: CC.basis()\n[1, c, c^2]\nsage: CC.basis(AA)\n[1, c, c^2, b, b*c, b*c^2]\nsage: CC.basis(QQ)\n[1, c, c^2, b, b*c, b*c^2, a, a*c, a*c^2, a*b, a*b*c, a*b*c^2]\n```\n\nNow let's play with elements\n\n```\nsage: u = CC.random_element(); u\n((-1/2 + 2*a) - 31*b) + (2 + (1 + 1/2*a)*b)*c + ((5/2 - 1/2*a) + 3*b)*c^2\nsage: u.trace()     # trace over the base field BB\n(-3/2 + 6*a) - 93*b\nsage: u.norm()\n(95447/8 - 5353/8*a) + (-2443/4 - 115345/4*a)*b\nsage: u.matrix()\n[  (-1/2 + 2*a) - 31*b     2 + (1 + 1/2*a)*b   (5/2 - 1/2*a) + 3*b]\n[3*a + (5/2 - 1/2*a)*b   (-1/2 + 2*a) - 31*b     2 + (1 + 1/2*a)*b]\n[        (1 + a) + 2*b 3*a + (5/2 - 1/2*a)*b   (-1/2 + 2*a) - 31*b]\nsage: u.polynomial()\n((5/2 - 1/2*a) + 3*b)*x^2 + (2 + (1 + 1/2*a)*b)*x + (-1/2 + 2*a) - 31*b\nsage: u.polynomial()(c) == u\nTrue\n```\n\nSimilarly, all the above functions have relative versions\n\n```\nsage: u.trace(QQ)\n-6\nsage: u.trace().trace().trace() == u.trace(QQ)\nTrue\nsage: u.matrix(AA)\n[ -1/2 + 2*a           2 5/2 - 1/2*a         -31   1 + 1/2*a           3]\n[        3*a  -1/2 + 2*a           2 5/2 - 1/2*a         -31   1 + 1/2*a]\n[      1 + a         3*a  -1/2 + 2*a           2 5/2 - 1/2*a         -31]\n[      -31*a       1 + a         3*a  -1/2 + 2*a           2 5/2 - 1/2*a]\n[ -1 + 5/2*a       -31*a       1 + a         3*a  -1/2 + 2*a           2]\n[        2*a  -1 + 5/2*a       -31*a       1 + a         3*a  -1/2 + 2*a]\nsage: P = u.polynomial(QQ); P\n3*x0^2*x1 - 1/2*x0^2*x2 + 1/2*x0*x1*x2 + 5/2*x0^2 + x0*x1 + 2*x0 - 31*x1 + 2*x2 - 1/2\nsage: P(c,b,a) == u   # (c,b,a) are the generators of CC over QQ\nTrue\n```",
    "created_at": "2019-09-13T19:34:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293083",
    "user": "https://github.com/xcaruso"
}
```

We worked with David Roe and Julian Rth on this ticket this week and finally decided to follow a different approach. We defined a coercion map from `K` to the extension `A = L/K` (coming from the defining morphism) but no coercion map from `A` to `L` (except when `K` coerces to `L` through the defining morphism of the extension). Consequently `a*k` is always the same as `k*a` (and is equal to `phi(k)*a` where `phi` is the defining morphism) but differs from `l*k`.

This point of view looked good to us because, in the use cases we have in mind (typically implementing field towers), the defining morphisms are basically never coercion maps but we definitely don't want to use the ``@`` operator to perform multiplications in the tower.

We also implemented special classes for finite field extensions. Below is a short demo showing the capabilities provided by this ticket.

We first create several a bunch of number fields and define a tower of extension `QQ -> AA -> BB -> CC`. (Currently, the tower is not that easy to define because we still miss a good `extension` method; we will implement it soon, hopefully.)

``` 
sage: A.<a> = QQ.extension(x^2 - 2)
sage: B.<b> = QQ.extension(x^4 - 2)
sage: C.<c> = QQ.extension(x^12 - 2)

# We create extensions
sage: AA.<a> = RingExtension(QQ)
sage: f = Hom(AA,B)(A.hom([b^2]))
sage: BB.<b> = RingExtension(f)
sage: g = Hom(BB,C)(B.hom([c^3]))
sage: CC.<c> = RingExtension(g)
```

Now we have our tower `QQ -> AA -> BB -> CC`. Let's play with it.

```
sage: AA
Ring in a with defining polynomial x^2 - 2 over its base
sage: BB
Ring in b with defining polynomial x^2 - a over its base
sage: CC
Ring in c with defining polynomial x^3 - b over its base

sage: CC.base_field()
Ring in b with defining polynomial x^2 - a over its base
sage: CC.base_field() is BB
True
sage: BB.base_field() is AA
True
sage: CC.intermediate_rings()
[Ring in c with defining polynomial x^3 - b over its base,
 Ring in b with defining polynomial x^2 - a over its base,
 Ring in a with defining polynomial x^2 - 2 over its base,
 Number Field in void with defining polynomial x]

sage: CC.gens()
(c,)
```

The `gens` method has also a relative version

```
sage: CC.gens(AA)   # generators over AA
(c,b)
sage: CC.gens(QQ)
(c,b,a)
```

And also:

```
sage: CC.basis()
[1, c, c^2]
sage: CC.basis(AA)
[1, c, c^2, b, b*c, b*c^2]
sage: CC.basis(QQ)
[1, c, c^2, b, b*c, b*c^2, a, a*c, a*c^2, a*b, a*b*c, a*b*c^2]
```

Now let's play with elements

```
sage: u = CC.random_element(); u
((-1/2 + 2*a) - 31*b) + (2 + (1 + 1/2*a)*b)*c + ((5/2 - 1/2*a) + 3*b)*c^2
sage: u.trace()     # trace over the base field BB
(-3/2 + 6*a) - 93*b
sage: u.norm()
(95447/8 - 5353/8*a) + (-2443/4 - 115345/4*a)*b
sage: u.matrix()
[  (-1/2 + 2*a) - 31*b     2 + (1 + 1/2*a)*b   (5/2 - 1/2*a) + 3*b]
[3*a + (5/2 - 1/2*a)*b   (-1/2 + 2*a) - 31*b     2 + (1 + 1/2*a)*b]
[        (1 + a) + 2*b 3*a + (5/2 - 1/2*a)*b   (-1/2 + 2*a) - 31*b]
sage: u.polynomial()
((5/2 - 1/2*a) + 3*b)*x^2 + (2 + (1 + 1/2*a)*b)*x + (-1/2 + 2*a) - 31*b
sage: u.polynomial()(c) == u
True
```

Similarly, all the above functions have relative versions

```
sage: u.trace(QQ)
-6
sage: u.trace().trace().trace() == u.trace(QQ)
True
sage: u.matrix(AA)
[ -1/2 + 2*a           2 5/2 - 1/2*a         -31   1 + 1/2*a           3]
[        3*a  -1/2 + 2*a           2 5/2 - 1/2*a         -31   1 + 1/2*a]
[      1 + a         3*a  -1/2 + 2*a           2 5/2 - 1/2*a         -31]
[      -31*a       1 + a         3*a  -1/2 + 2*a           2 5/2 - 1/2*a]
[ -1 + 5/2*a       -31*a       1 + a         3*a  -1/2 + 2*a           2]
[        2*a  -1 + 5/2*a       -31*a       1 + a         3*a  -1/2 + 2*a]
sage: P = u.polynomial(QQ); P
3*x0^2*x1 - 1/2*x0^2*x2 + 1/2*x0*x1*x2 + 5/2*x0^2 + x0*x1 + 2*x0 - 31*x1 + 2*x2 - 1/2
sage: P(c,b,a) == u   # (c,b,a) are the generators of CC over QQ
True
```



---

archive/issue_comments_293084.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-13T20:21:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293084",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293085.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-14T10:15:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293085",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293086.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2019-09-15T22:01:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293086",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_293087.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-21T10:41:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293087",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293088.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-22T21:14:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293088",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293089.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-24T15:47:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293089",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293090.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-26T10:08:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293090",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293091.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-26T19:21:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293091",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293092.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-26T20:02:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293092",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293093.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-26T20:25:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293093",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293094.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-03T19:51:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293094",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293095.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2019-10-03T23:50:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293095",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_293096.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-06T17:06:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293096",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293097.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-10-06T17:10:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293097",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_293098.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-06T18:39:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293098",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293099.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-06T18:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293099",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293100.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-07T15:51:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293100",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293101.json:
```json
{
    "body": "See the description of the ticket for a small tutorial showing the main functionalities provided by this ticket.",
    "created_at": "2019-10-07T15:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293101",
    "user": "https://github.com/xcaruso"
}
```

See the description of the ticket for a small tutorial showing the main functionalities provided by this ticket.



---

archive/issue_comments_293102.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-13T03:01:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293102",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293103.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-14T21:48:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293103",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293104.json:
```json
{
    "body": "I changed the milestone, hoping that it will encourage the patchbot to run on this ticket.\n\n---\nNew commits:",
    "created_at": "2019-11-14T22:40:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293104",
    "user": "https://github.com/xcaruso"
}
```

I changed the milestone, hoping that it will encourage the patchbot to run on this ticket.

---
New commits:



---

archive/issue_events_056933.json:
```json
{
    "actor": "https://github.com/xcaruso",
    "created_at": "2019-11-14T22:40:25Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "milestone": "sage-9.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/21176#event-56933"
}
```



---

archive/issue_comments_293105.json:
```json
{
    "body": "Positive review once tests pass",
    "created_at": "2019-11-15T09:43:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293105",
    "user": "https://github.com/roed314"
}
```

Positive review once tests pass



---

archive/issue_comments_293106.json:
```json
{
    "body": "Patchbot reported many errors of this shape:\n\n```\nFailed example:\n    type(K)\nExpected:\n    <class 'sage.rings.ring_extension.RingExtensionWithGen'>\nGot:\n    <type 'sage.rings.ring_extension.RingExtensionWithGen'>\n```\nThis sounds weird.\n\nActually, on my laptop, the output I get is `class` and not `type`. Moreover, I noticed the same ambiguity in many other places in Sage. Even more bizarre, sometimes `type` appears in the doctest, my output is `class` but no error is reported.\n\nDo you know what's going on here?",
    "created_at": "2019-11-15T11:39:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293106",
    "user": "https://github.com/xcaruso"
}
```

Patchbot reported many errors of this shape:

```
Failed example:
    type(K)
Expected:
    <class 'sage.rings.ring_extension.RingExtensionWithGen'>
Got:
    <type 'sage.rings.ring_extension.RingExtensionWithGen'>
```
This sounds weird.

Actually, on my laptop, the output I get is `class` and not `type`. Moreover, I noticed the same ambiguity in many other places in Sage. Even more bizarre, sometimes `type` appears in the doctest, my output is `class` but no error is reported.

Do you know what's going on here?



---

archive/issue_comments_293107.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-15T11:54:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293107",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293108.json:
```json
{
    "body": "Python2 versus python3. You are supposed to use python3 for development..",
    "created_at": "2019-11-15T16:03:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293108",
    "user": "https://github.com/fchapoton"
}
```

Python2 versus python3. You are supposed to use python3 for development..



---

archive/issue_comments_293109.json:
```json
{
    "body": "OK. So does it mean that I should keep `class` as it is currently?",
    "created_at": "2019-11-15T16:17:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293109",
    "user": "https://github.com/xcaruso"
}
```

OK. So does it mean that I should keep `class` as it is currently?



---

archive/issue_comments_293110.json:
```json
{
    "body": "You should do whatever it takes to have doctests pass in both py2 and py3.\n\nHere this can be achieved by writing `...` instead of type or class.\n\nThere is also an existing mechanism in the doctest framework that accepts \"class\" when \"type\" is required. The other direction has not been implemented. So you can use \"type\".",
    "created_at": "2019-11-15T18:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293110",
    "user": "https://github.com/fchapoton"
}
```

You should do whatever it takes to have doctests pass in both py2 and py3.

Here this can be achieved by writing `...` instead of type or class.

There is also an existing mechanism in the doctest framework that accepts "class" when "type" is required. The other direction has not been implemented. So you can use "type".



---

archive/issue_comments_293111.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-16T06:47:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293111",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293112.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-16T10:55:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293112",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293113.json:
```json
{
    "body": "Reste encore un probl\u00e8me sous python2:\n\n```\nsage -t --long src/sage/rings/ring_extension_homset.py\n**********************************************************************\nFile \"src/sage/rings/ring_extension_homset.py\", line 26, in sage.rings.ring_extension_homset.RingExtensionHomset\nFailed example:\n    type(H)\nExpected:\n    <type 'sage.rings.ring_extension_homset.RingExtensionHomset_with_category'>\nGot:\n    <class 'sage.rings.ring_extension_homset.RingExtensionHomset_with_category'>\n```\nqui me semble bizarre. Il devrait \u00eatre r\u00e9gl\u00e9 comme les autres par le m\u00e9canisme dont j'ai parl\u00e9. Utiliser `...` pour celui-la, peut-\u00eatre ?",
    "created_at": "2019-11-16T17:35:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293113",
    "user": "https://github.com/fchapoton"
}
```

Reste encore un problme sous python2:

```
sage -t --long src/sage/rings/ring_extension_homset.py
**********************************************************************
File "src/sage/rings/ring_extension_homset.py", line 26, in sage.rings.ring_extension_homset.RingExtensionHomset
Failed example:
    type(H)
Expected:
    <type 'sage.rings.ring_extension_homset.RingExtensionHomset_with_category'>
Got:
    <class 'sage.rings.ring_extension_homset.RingExtensionHomset_with_category'>
```
qui me semble bizarre. Il devrait tre rgl comme les autres par le mcanisme dont j'ai parl. Utiliser `...` pour celui-la, peut-tre ?



---

archive/issue_comments_293114.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-16T17:49:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293114",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293115.json:
```json
{
    "body": "All tests pass!",
    "created_at": "2019-11-16T19:55:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293115",
    "user": "https://github.com/xcaruso"
}
```

All tests pass!



---

archive/issue_comments_293116.json:
```json
{
    "body": "Wonderful!",
    "created_at": "2019-11-17T06:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293116",
    "user": "https://github.com/roed314"
}
```

Wonderful!



---

archive/issue_comments_293117.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-11-17T06:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293117",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_293118.json:
```json
{
    "body": "Mumble... build failed with sage 9.0.beta6\n\nHere is the error:\n\n```\n[sagelib-9.0.beta6] Traceback (most recent call last):\n[sagelib-9.0.beta6]   File \"setup.py\", line 22, in <module>\n[sagelib-9.0.beta6]     import fpickle_setup\n[sagelib-9.0.beta6]   File \"/local/sage-patchbot/sage/src/fpickle_setup.py\", line 8, in <module>\n[sagelib-9.0.beta6]     from six.moves import copyreg\n[sagelib-9.0.beta6] ModuleNotFoundError: No module named 'six'\n```\n\nI would say that it is not related to this ticket, is it?",
    "created_at": "2019-11-18T08:54:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293118",
    "user": "https://github.com/xcaruso"
}
```

Mumble... build failed with sage 9.0.beta6

Here is the error:

```
[sagelib-9.0.beta6] Traceback (most recent call last):
[sagelib-9.0.beta6]   File "setup.py", line 22, in <module>
[sagelib-9.0.beta6]     import fpickle_setup
[sagelib-9.0.beta6]   File "/local/sage-patchbot/sage/src/fpickle_setup.py", line 8, in <module>
[sagelib-9.0.beta6]     from six.moves import copyreg
[sagelib-9.0.beta6] ModuleNotFoundError: No module named 'six'
```

I would say that it is not related to this ticket, is it?



---

archive/issue_comments_293119.json:
```json
{
    "body": "caused by the switch to python3. You need to do \"make distclean\" and \"make\"",
    "created_at": "2019-11-18T09:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293119",
    "user": "https://github.com/fchapoton"
}
```

caused by the switch to python3. You need to do "make distclean" and "make"



---

archive/issue_comments_293120.json:
```json
{
    "body": "Well, this error was reported (4 times) by the patchbot; it is normal?",
    "created_at": "2019-11-18T10:15:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293120",
    "user": "https://github.com/xcaruso"
}
```

Well, this error was reported (4 times) by the patchbot; it is normal?



---

archive/issue_comments_293121.json:
```json
{
    "body": "As explained on sage-devel, all patchbots were broken by the switch to python3",
    "created_at": "2019-11-18T10:52:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293121",
    "user": "https://github.com/fchapoton"
}
```

As explained on sage-devel, all patchbots were broken by the switch to python3



---

archive/issue_comments_293122.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2019-11-19T23:36:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293122",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_293123.json:
```json
{
    "body": "PDF docs don't build \n\n```\n! Undefined control sequence.\nl.7333 \\(K_n/\\cots\n                  \\K_2/K_1\\) is the ring \\(K_1\\).\n```",
    "created_at": "2019-11-19T23:36:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293123",
    "user": "https://github.com/vbraun"
}
```

PDF docs don't build 

```
! Undefined control sequence.
l.7333 \(K_n/\cots
                  \K_2/K_1\) is the ring \(K_1\).
```



---

archive/issue_comments_293124.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-20T07:10:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293124",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293125.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-11-20T07:12:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293125",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_293126.json:
```json
{
    "body": "Thanks. Fixed.",
    "created_at": "2019-11-20T07:12:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293126",
    "user": "https://github.com/xcaruso"
}
```

Thanks. Fixed.



---

archive/issue_comments_293127.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-20T11:30:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293127",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293128.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-11-20T21:26:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293128",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_293129.json:
```json
{
    "body": "I checked that the documentation builds now.",
    "created_at": "2019-11-20T21:26:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293129",
    "user": "https://github.com/roed314"
}
```

I checked that the documentation builds now.



---

archive/issue_comments_293130.json:
```json
{
    "body": "pdf docs don't build:\n\n```\n[docpdf] ! Undefined control sequence.\n[docpdf] <recently read> \\K \n[docpdf]                    \n[docpdf] l.7333 \\(K_n/\\cdots\\K\n[docpdf]                      _2/K_1\\) is the ring \\(K_1\\).\n[docpdf] ? \n```",
    "created_at": "2019-11-28T00:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293130",
    "user": "https://github.com/vbraun"
}
```

pdf docs don't build:

```
[docpdf] ! Undefined control sequence.
[docpdf] <recently read> \K 
[docpdf]                    
[docpdf] l.7333 \(K_n/\cdots\K
[docpdf]                      _2/K_1\) is the ring \(K_1\).
[docpdf] ? 
```



---

archive/issue_comments_293131.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2019-11-28T00:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293131",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_293132.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-29T16:22:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293132",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293133.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-11-29T16:23:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293133",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_293134.json:
```json
{
    "body": "Should be OK this time...",
    "created_at": "2019-11-29T16:23:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293134",
    "user": "https://github.com/xcaruso"
}
```

Should be OK this time...



---

archive/issue_comments_293135.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2020-01-06T14:10:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293135",
    "user": "https://github.com/embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_events_056934.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2020-01-06T14:10:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "milestone": "sage-9.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/21176#event-56934"
}
```



---

archive/issue_events_056935.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2020-01-06T14:10:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "milestone": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/21176#event-56935"
}
```



---

archive/issue_comments_293136.json:
```json
{
    "body": "David, if my changes are okay with you, could you please give (again) a positive review to this ticket?",
    "created_at": "2020-01-07T08:58:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293136",
    "user": "https://github.com/xcaruso"
}
```

David, if my changes are okay with you, could you please give (again) a positive review to this ticket?



---

archive/issue_comments_293137.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-10T08:12:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293137",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293138.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-01-10T16:52:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293138",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_293139.json:
```json
{
    "body": "ok, let it be",
    "created_at": "2020-01-10T16:52:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293139",
    "user": "https://github.com/fchapoton"
}
```

ok, let it be



---

archive/issue_comments_293140.json:
```json
{
    "body": "Thanks.\n\nBTW, do you know why some patchbots report building errors?",
    "created_at": "2020-01-11T07:59:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293140",
    "user": "https://github.com/xcaruso"
}
```

Thanks.

BTW, do you know why some patchbots report building errors?



---

archive/issue_comments_293141.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2020-01-15T20:35:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293141",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_293142.json:
```json
{
    "body": "I'm getting a lot of failures like this on 32-bit\n\n```\n**********************************************************************\nFile \"src/sage/categories/commutative_rings.py\", line 156, in sage.categories.commutative_rings.CommutativeRings.ParentMethods.over\nFailed example:\n    L = GF(5^12).over(K)\nException raised:\n    Traceback (most recent call last):\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 681, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 1123, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.categories.commutative_rings.CommutativeRings.ParentMethods.over[17]>\", line 1, in <module>\n        L = GF(Integer(5)**Integer(12)).over(K)\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/categories/commutative_rings.py\", line 212, in over\n        return RingExtension(self, base, gens, names)\n      File \"sage/structure/factory.pyx\", line 369, in sage.structure.factory.UniqueFactory.__call__ (build/cythonized/sage/structure/factory.c:2240)\n        return self.get_object(version, key, kwds)\n      File \"sage/structure/factory.pyx\", line 406, in sage.structure.factory.UniqueFactory.get_object (build/cythonized/sage/structure/factory.c:2444)\n        return self._cache[version, cache_key]\n      File \"sage/misc/weak_dict.pyx\", line 703, in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3650)\n        cdef PyObject* wr = PyDict_GetItemWithError(self, k)\n      File \"sage/categories/morphism.pyx\", line 323, in sage.categories.morphism.Morphism.__hash__ (build/cythonized/sage/categories/morphism.c:4888)\n        return hash((domain, codomain, definition))\n      File \"sage/rings/ring_extension.pyx\", line 696, in sage.rings.ring_extension.RingExtension_generic.__hash__ (build/cythonized/sage/rings/ring_extension.c:10685)\n        return id(self)\n    OverflowError: Python int too large to convert to C ssize_t\n**********************************************************************\n```",
    "created_at": "2020-01-15T20:35:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293142",
    "user": "https://github.com/vbraun"
}
```

I'm getting a lot of failures like this on 32-bit

```
**********************************************************************
File "src/sage/categories/commutative_rings.py", line 156, in sage.categories.commutative_rings.CommutativeRings.ParentMethods.over
Failed example:
    L = GF(5^12).over(K)
Exception raised:
    Traceback (most recent call last):
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1123, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.categories.commutative_rings.CommutativeRings.ParentMethods.over[17]>", line 1, in <module>
        L = GF(Integer(5)**Integer(12)).over(K)
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/categories/commutative_rings.py", line 212, in over
        return RingExtension(self, base, gens, names)
      File "sage/structure/factory.pyx", line 369, in sage.structure.factory.UniqueFactory.__call__ (build/cythonized/sage/structure/factory.c:2240)
        return self.get_object(version, key, kwds)
      File "sage/structure/factory.pyx", line 406, in sage.structure.factory.UniqueFactory.get_object (build/cythonized/sage/structure/factory.c:2444)
        return self._cache[version, cache_key]
      File "sage/misc/weak_dict.pyx", line 703, in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3650)
        cdef PyObject* wr = PyDict_GetItemWithError(self, k)
      File "sage/categories/morphism.pyx", line 323, in sage.categories.morphism.Morphism.__hash__ (build/cythonized/sage/categories/morphism.c:4888)
        return hash((domain, codomain, definition))
      File "sage/rings/ring_extension.pyx", line 696, in sage.rings.ring_extension.RingExtension_generic.__hash__ (build/cythonized/sage/rings/ring_extension.c:10685)
        return id(self)
    OverflowError: Python int too large to convert to C ssize_t
**********************************************************************
```



---

archive/issue_comments_293143.json:
```json
{
    "body": "using id(self) for the hash may be a bad idea",
    "created_at": "2020-01-16T20:52:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293143",
    "user": "https://github.com/fchapoton"
}
```

using id(self) for the hash may be a bad idea



---

archive/issue_comments_293144.json:
```json
{
    "body": "We can certainly fix that problem, but neither Xavier nor I have access to a 32-bit machine, so I'm not sure what other problems might arise.",
    "created_at": "2020-01-16T21:04:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293144",
    "user": "https://github.com/roed314"
}
```

We can certainly fix that problem, but neither Xavier nor I have access to a 32-bit machine, so I'm not sure what other problems might arise.



---

archive/issue_comments_293145.json:
```json
{
    "body": "Replying to [comment:112 roed]:\n> We can certainly fix that problem, but neither Xavier nor I have access to a 32-bit machine, so I'm not sure what other problems might arise.\n\n\njust to mention that the access is now available :-)",
    "created_at": "2020-01-17T21:48:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293145",
    "user": "https://github.com/dimpase"
}
```

Replying to [comment:112 roed]:
> We can certainly fix that problem, but neither Xavier nor I have access to a 32-bit machine, so I'm not sure what other problems might arise.


just to mention that the access is now available :-)



---

archive/issue_comments_293146.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-23T10:01:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293146",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_293147.json:
```json
{
    "body": "I'm trying with the function `hash_by_id`...",
    "created_at": "2020-01-23T10:02:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293147",
    "user": "https://github.com/xcaruso"
}
```

I'm trying with the function `hash_by_id`...



---

archive/issue_comments_293148.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-01-23T10:17:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293148",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_293149.json:
```json
{
    "body": "did you check on a 32-bit machine ? If yes, you can set to positive on my name",
    "created_at": "2020-01-23T18:57:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293149",
    "user": "https://github.com/fchapoton"
}
```

did you check on a 32-bit machine ? If yes, you can set to positive on my name



---

archive/issue_comments_293150.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-01-23T19:13:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293150",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_293151.json:
```json
{
    "body": "I just ran `make ptestlong` on a 32-bit machine and they all passed.  Setting back to positive review.",
    "created_at": "2020-01-23T19:13:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293151",
    "user": "https://github.com/roed314"
}
```

I just ran `make ptestlong` on a 32-bit machine and they all passed.  Setting back to positive review.



---

archive/issue_comments_293152.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-01-25T17:27:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293152",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_056936.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2020-01-25T17:27:22Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/21176#event-56936"
}
```



---

archive/issue_comments_293153.json:
```json
{
    "body": "Champagne!",
    "created_at": "2020-01-26T22:24:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21176",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21176#issuecomment-293153",
    "user": "https://github.com/xcaruso"
}
```

Champagne!
