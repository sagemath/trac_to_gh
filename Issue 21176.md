# Issue 21176: A class for ring extensions

Issue created by migration from https://trac.sagemath.org/ticket/21413

Original creator: caruso

Original creation time: 2016-09-04 09:55:04

CC:  jsrn defeo bruno nthiery simonking saraedum

Keywords: sd75

Sage actually provides a rich framework for dealing with all classical algebraic structures: rings, fields, algebras, etc. 
Nevertheless, given (for instance) two fields K and L with K \subset L, it is not possible to build the extension L/K as a Sage object. However one can easily imagine methods related to this extension (e.g. `degree`, `discriminant`, `normal_basis`, `decompose_on_basis`, etc.)

With Bruno Grenet, Johan Rosenkilde and Luca De Feo, we raised this issue at Sage Days 75. A summary of our discussion is available 
[here](https://gist.github.com/defeo/cabab27ea93aeb9e0deb0ba8c5bc745b).


---

Comment by git created at 2016-09-06 09:10:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-09-06 13:15:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-09-08 18:44:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2016-09-08 18:48:45

Changing status from new to needs_review.


---

Comment by jsrn created at 2016-09-08 19:09:31

Wow, this is great Xavier! Sorry for not being more active before - I promise to look more at it tomorrow.

I'm wondering whether it's a good idea to merge the "framework" before the first concrete instantiation? I.e. whether we should try to get the field-extension-algebra finished before considering this as mature? (I know you have bad experience with too large patches, but if we don't put too much stuff in the field extension as a first approximation, perhaps it's ok).

Best,
Johan


---

Comment by jsrn created at 2016-09-09 14:50:56

In the following, the extension is A = L/K with L and K rings. `L.base()` is B.
Sometimes B is a subring of K.

Right now this `AlgebraFromMorphism` is mainly a thin wrapper around the
L, so e.g. A elements are represented internally as elements of L, and this is
also how you print them. Can you try to convince me of the value from a user's
POV that he can do arithmetic on his elements inside this algebra, rather than
dropping the whole Algebra idea and just letting `RingExtension` be some
non-parent object with fancy methods on it like `decompose_on_basis`?

What I had in mind after SD75 is that `RingExtension` is an `Algebra` as in "a
vector space equipped with a bilinear product"; in other words, when I want to
see L as a vector space over K, I use `RingExtension`. In this world, it makes
sense to have arithmetic on elements of `A` and they should print (and possibly
be internally represented by) vectors over K; because that's the whole point of
why I'm wrapping L.

In that world, `AlgebraFromMorphism` shouldn't have a `gen` method because it
isn't really focused on its personality as a ring (it might have a
`multiplicative_generator` if you like). But it should definitely have a `basis`
method.

Other remarks that I got by looking at the code. Let's see where the above
discussion takes us before doing much about the stuff below:

1. Why are you not giving `self._base` as argument to `CommutativeAlgebra.__init__`? You write in a comment that we don't want a coercion map `base -> self` -- I don't see why not? I guess this is related to the left/right action dichotomy you have?
1. The module doc for `algebra_from_morphism is too short`. It should explain what this module is and what is offered.
  Redundancy is not bad.
1. A method "def something(self)" should never have the doc-string "Return the something of self". That's utterly unhelpful :-)
1. `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.
1. The doc for `scalar_restriction` is very hard to read. Attempt to write before INPUT what this means. Could we write something like

        {{{
        If ``newbase`` is a sub-ring of `self.base()`, then the scalar restriction of `self` to `newbase` is the ring extension `self.ring()/newbase`. The defining morphism will be the composition of `f` and ``self.defining_morphism()`` where `f` is the coercion map from `newbase` to `self.base()`.

        ``newbase`` can be given as an extension, ... 

        ``newbase`` can be given as a morphism, ...
        }}}

  What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?
1. I don't like `ring` and `base`. They are too short and it's not clear which is which.
1. Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse! I'm also very concerned that this might break several things in Sage since you're inheriting from `CommutativeAlgebra`.
1. Doc of `RingExtension`: can we make a commuting diagram to describe the coercion between L1/K1 and L2/K2? Something like

      {{{
      K1 -----> L1
      ^         |
      |         | 
      |         v
      K2 -----> L2
      }}}

Best,
Johan


---

Comment by caruso created at 2016-09-09 21:56:43

Replying to [comment:7 jsrn]:
> Right now this `AlgebraFromMorphism` is mainly a thin wrapper around the
> L, so e.g. A elements are represented internally as elements of L, and this is
> also how you print them. Can you try to convince me of the value from a user's
> POV that he can do arithmetic on his elements inside this algebra, rather than
> dropping the whole Algebra idea and just letting `RingExtension` be some
> non-parent object with fancy methods on it like `decompose_on_basis`?

Maybe I misunderstand your proposal but I really think that a ring extension should be a parent because we really want to take advantage of the coercion stuff.
Nonetheless, the question "should it derive from `CommutativeAlgebra`?" is arguable and I can imagine arguments in both directions.

> What I had in mind after SD75 is that `RingExtension` is an `Algebra` as in "a
> vector space equipped with a bilinear product"; in other words, when I want to
> see L as a vector space over K, I use `RingExtension`.

It is definitely.

> In this world, it makes
> sense to have arithmetic on elements of `A` and they should print (and possibly
> be internally represented by) vectors over K; because that's the whole point of
> why I'm wrapping L.

I agree. But all of this has to be implemented in subclasses. For now, I just wrote a very general class which is supposed to deal with all algebras (possibly not free, not finite...) so it is of course difficult to implement concrete methods. 

But these methods clearly exist. Here is a far-from-exhaustive list: `scalar_restriction` (which is already implemented), `__mul__` (usual product of algebras), `tensor_product`, `scalar_extension`, `cayley_differentials`, `krull_relative_dimension`, `is_free`, `is_finite`, `is_flat`, `is_etale`, `is_smooth`, `is_open_immersion`, `is_closed_immersion`, `is_galois`, `galois_group`. And for elements: `trace`, `norm`.

If you insist, I can put these methods in the general class and let them raise `NotImplementedError`... but it would be difficult to write the doctest :-)

> In that world, `AlgebraFromMorphism` shouldn't have a `gen` method because it
> isn't really focused on its personality as a ring (it might have a
> `multiplicative_generator` if you like).

The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.

> But it should definitely have a `basis` method.

Well there does exist algebras which are not free. So the `basis` method is clearly something we want. However it should not be inserted in such a general class but in the subclass `FreeAlgebraFromMorphism` or `FiniteFreeAlgebraFromMorphism` (which is coming soon).

> Why are you not giving `self._base` as argument to `CommutativeAlgebra.__init__`? You write in a comment that we don't want a coercion map `base -> self` -- I don't see why not? I guess this is related to the left/right action dichotomy you have?

Suppose that we create an algebra L/K with a defining morphism phi : K -> L which is not a coercion map. If K coerces to L/K through phi and L/K coerces to L, then we would derive that K coerces to L through phi.

Such a situation really occurs in every day life (at least for people working in algebraic geometry). For instance, if K has characteristic p, these people often consider K as an algebra over itself *through the Frobenius morphism* (which is definitely not a coercion map).

> The module doc for `algebra_from_morphism is too short`. It should explain what this module is and what is offered.
>   Redundancy is not bad.
>
> A method "def something(self)" should never have the doc-string "Return the something of self". That's utterly unhelpful :-)

Ok for both. I'll try to fix this.

> `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.

It is not my fault :-). This method is needed by the coercion model.

> The doc for `scalar_restriction` is very hard to read. Attempt to write before INPUT what this means. Could we write something like

Ok. I'll do it.

>   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?

Sure, it is something we normally do... just as composing ring homomorphisms.

> I don't like `ring` and `base`. They are too short and it's not clear which is which.

Ok for changing. I'm also not completed satisfied with these names. Do you have some propositions?

> Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse!

I definitely agree that it is not perfect, but I have not found something better :-).
The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.

> I'm also very concerned that this might break several things in Sage since you're inheriting from `CommutativeAlgebra`.

It is one reason why I'm sure that we should inherit from `CommutativeAlgebra`

> Doc of `RingExtension`: can we make a commuting diagram to describe the coercion between L1/K1 and L2/K2?

Ok.

Xavier


---

Comment by jsrn created at 2016-09-10 10:17:06

Thanks for your careful explanations. I'm learning a lot here.

Replying to [comment:8 carus]:
> Maybe I misunderstand your proposal but I really think that a ring extension should be a parent because we really want to take advantage of the coercion stuff.
>
> Nonetheless, the question "should it derive from `CommutativeAlgebra`?" is arguable and I can imagine arguments in both directions.

OK, so "coercion stuff" is an argument in favour of a Parent. I guess you mean that many objects will magically coerce to the Do-What-I-Mean behaviour on methods. But if a weird/surprising behaviour follows from forcing it into the category framework, perhaps that's an argument against it.

At least having a `RingExtension` being a class with lots of service methods, sort of like David's `RelativeFiniteFieldExtension`, there will be no arithmetic problems. You could also put `norm` and `trace` there.

> > In this world, it makes
> > sense to have arithmetic on elements of `A` and they should print (and possibly
> > be internally represented by) vectors over K; because that's the whole point of
> > why I'm wrapping L.
> 
> I agree. But all of this has to be implemented in subclasses. For now, I just wrote a very general class which is supposed to deal with all algebras (possibly not free, not finite...) so it is of course difficult to implement concrete methods. 

OK, that makes sense. I can see why the general class would have very weak functionality then.

> But these methods clearly exist. Here is a far-from-exhaustive list:  ....
> If you insist, I can put these methods in the general class and let them raise `NotImplementedError`... but it would be difficult to write the doctest :-)

Perhaps that's not a bad idea: it's nicer that any algebra will have the methods you expect and then throw `NotImplementedError` rather than not advertising the method at all.

The doc-test can be on a more concrete class that does implement the method. If none exist for this ticket, the doc-test will just be one demonstrating the `NotImplentedError` for now, with the sole purpose of doc-test coverage ;-)

> The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.

Hmm, but couldn't there be multiple generators? E.g. `F[x,y]/F`?

> Well there does exist algebras which are not free. So the `basis` method is clearly something we want. However it should not be inserted in such a general class but in the subclass `FreeAlgebraFromMorphism` or `FiniteFreeAlgebraFromMorphism` (which is coming soon).

OK, argument accepted. But I think this kind of stuff reinforces that we should try to design the first concrete `RingExtension`, e.g. `FiniteFieldExtension` simultaneously with this ticket. Then we'll better be able to judge what goes where and how it should look to be useful on both sides.

> Suppose that we create an algebra L/K with a defining morphism phi : K -> L which is not a coercion map. If K coerces to L/K through phi and L/K coerces to L, then we would derive that K coerces to L through phi.
> 
> Such a situation really occurs in every day life (at least for people working in algebraic geometry). For instance, if K has characteristic p, these people often consider K as an algebra over itself *through the Frobenius morphism* (which is definitely not a coercion map).

Yikes! So we must disallow coercion from `K -> L/K`. But we should allow `A(k)`
and `k*a`, `a*k`, `k + a`, etc. for `k in K` and `a in A`. And `A(a * l)` is
different from `a * A(l)`. Oh man...

It seems to me that this is really dangerous territory - but perhaps
unavoidable. Someone implementing algorithms for `CommutativeAlgebra` is going
to assume that there is coercion from `base` to `self`. And that multiplication
of `base` and `self` elements commute!

Perhaps `CommutativeAlgebra` should be called something different, and
`AlgebraFromMorphism` should have a different base class. I've cc'ed Nicolas
Thiery and Simon King in this discussion to chip in.

> > `from_base_ring` has an extremely bad name considering that it doesn't embed an element of the base. I think we need to establish some proper nomenclature and do some commutation diagrams in the doc of this module.
> 
> It is not my fault :-). This method is needed by the coercion model.

Eew, yet another symptom that we're perhaps abusing the current hierarchy.

Why doesn't `GF(9)` have `from_base_ring`? What kind of Parent requires it?

> >   What is the argument for allowing extensions and morphisms as arguments to `scalar_restriction`? Is it really something you would normally do? Couldn't the user just do `A.scalar_restriction(mymorphism.codomain())`, etc.?
> 
> Sure, it is something we normally do... just as composing ring homomorphisms.

So it is something where established mathematical notation supports this
directly? It's much more explicit to just write
`A.scalar_restriction(Aother.ring())`, so I'd prefer not supporting
`A.scalar_restriction(Aother)`, except if a properly educated mathematician
would be very surprised if this didn't exist.

> > I don't like `ring` and `base`. They are too short and it's not clear which is which.
> 
> Ok for changing. I'm also not completed satisfied with these names. Do you have some propositions?

We should probably first figure out what to do hierarchy-wise. But perhaps
keep `ring -> ring_of_element` and `base -> ring_of_scalars`. Alternative `element_ring` resp. `scalar_ring`.

> > Speaking in parents, you let K * A = A but you let A * K = L. Won't this be a major source of confusion for users? I think your nasty example with non-commutativity at the end of `RingExtension` doc makes this even worse!
> 
> I definitely agree that it is not perfect, but I have not found something better :-).
> The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.

What do you mean "is the least we can do"?

Why is this an argument to make left and right actions different? Couldn't you implement the same left/right action, namely mapping `K -> A` by `phi`, followed by multiplication in `A`.

Best,
Johan


---

Comment by jsrn created at 2016-09-10 10:17:06

Changing status from needs_review to needs_info.


---

Comment by caruso created at 2016-09-10 13:34:59

Replying to [comment:9 jsrn]:
> Perhaps that's not a bad idea: it's nicer that any algebra will have the methods you expect and then throw `NotImplementedError` rather than not advertising the method at all.

OK. But, on the other hand, the list of possible methods is possibly quite long. Having a parent with 90% not implemented methods is also not that nice.

> > The generator of an algebra is a well-defined mathematical notion: the algebra L/K is generated by x if $K \cup {x}$ generates L as a ring. So it clearly makes sense to have a `gen` method.
> 
> Hmm, but couldn't there be multiple generators? E.g. `F[x,y]/F`?

Yes, of course. 

For traditional rings, the current behaviour of `gen` is rather stange (to me):

```
    sage: R.<x,y> = QQ[]
    sage: R.gen()
    x
```

Is that normal?

> OK, argument accepted. But I think this kind of stuff reinforces that we should try to design the first concrete `RingExtension`, e.g. `FiniteFieldExtension` simultaneously with this ticket. Then we'll better be able to judge what goes where and how it should look to be useful on both sides.

I just do not want this ticket to become too big. 
But I agree for implementing `FiniteFieldExtension` here.

> Yikes! So we must disallow coercion from `K -> L/K`. But we should allow `A(k)`
> and `k*a`, `a*k`, `k + a`, etc. for `k in K` and `a in A`. And `A(a * l)` is
> different from `a * A(l)`. Oh man...

(First, let me emphasize that this issue only occurs when the defining morphism is not a coercion map.)

Currently `A(k)`, `a*k`, `k + a` uses coercion maps (and not defining morphism): for instance, if K coerces to L then `k+a` is the addition in L while if K does not coerce to L, `k+a` produces an error. Only `k*a` (implemented by a left action of K on L/K) uses the defining morphism.

I agree that it is really confusing but the same confusion appears exactly in the same way in the "theory". So I assume that people who really wants to work with algebras whose defining morphisms are not coercion maps are very aware of this source of confusion!

Why left action and not right action? Because usually scalars act on the left (for instance, we write `2x` and not `x2` when x lies in some vector space). I nevertheless agree that this convention is not very strong. Another option would be to implement both actions (at some point I actually did this) but it then becomes impossible to multiply an element of K by an element of L without writing explicitly the conversion.

Probably the best solution would be to have a completely different operator for the action of the base through the defining morphism. But which one? Is it a good idea to override the dot operator?

> Why doesn't `GF(9)` have `from_base_ring`? What kind of Parent requires it?

I think (but I'm not quite sure) that it is used when no coercing map is set from `self._base` to `self`.

> So it is something where established mathematical notation supports this
> directly? It's much more explicit to just write
> `A.scalar_restriction(Aother.ring())`, so I'd prefer not supporting
> `A.scalar_restriction(Aother)`, except if a properly educated mathematician
> would be very surprised if this didn't exist.

I think that sometimes mathematicians may want to invoke `A.scalar_restriction(Aother)`. For instance assume that we have an algebra A defined over C[X]. The fibre of A at the point x is by definition the scalar extension of A with respect to the morphism C[X] -> C mapping X to x. (It is actually also A/(X-x), but sometimes we really want to think of it as a scalar extension.)

Actually we probably prefer to use the "base_change" in that case. So maybe we can implement two methods: first `scalar_extension` which always uses coercion maps and second `base_change` which accepts all constructions.

> > I think that implementing the action of scalars (through the defining morphism) is the least we can do.
> 
> What do you mean "is the least we can do"?

When we want to regard L as a K-algebra, a basic thing we want to have is the action of K on L defining the algebra.


---

Comment by klee created at 2016-10-10 09:43:21

I just found this ticket and I only have a vague idea about what this ticket does. I am curious if  the present ticket would solve or at least help one solve each of the following problems (of mine)? I believe that these cases are not supported by Sage yet.
 
1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. 

2. Suppose K is a field and R is a subring of K. Suppose K is the fraction field of R. Let e be an element of K. Then `d=e.denominator(R)` gives a denominator of e in R such that `d*e.numerator(R) ` is in R.

3. Let E,F be rings. Suppose phi is a homomorphism from E to F. I want to extend phi to a homomorphism psi from the polynomial ring R=E[x] to F mapping x to c in F. Thus `psi(a2*x<sup>2+a1*x+a0)==phi(a2)*c</sup>2+phi(a1)*c+phi(a0)`.  Perhaps I want  `R.hom([c],F, base=phi)` or like to work.


---

Comment by jsrn created at 2016-10-10 10:49:09

Replying to [comment:11 klee]:
> 1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. 

That currently works fine, just try it.

If you want to go from `F` back to `E` for any of the elements `phi(E)`, use `phi.section()`.

If you want to express `F` as a vector space over `E`, things are more limited. We implemented basic support for it in `sage.coding.relative_finite_field_extension`. This ticket is about making that functionality much more general and thought out, and getting it into the core algebra of Sage.

> 2. Suppose K is a field and R is a subring of K. Suppose K is the fraction field of R. Let e be an element of K. Then `d=e.denominator(R)` gives a denominator of e in R such that `d*e.numerator(R) ` is in R.

That also currently works fine. I just tested with `R = GF(3^2)['x']`:


```
sage: R = GF(3^2)['x']
sage: K = R.fraction_field()
sage: e = K.random_element()
sage: e.denominator()
(z2 + 2)*x^2 + (z2 + 1)*x
sage: e.denominator().parent()
Univariate Polynomial Ring in x over Finite Field in z2 of size 3^2
sage: e.denominator() in R
True
sage: R( e.denominator() * e )
(2*z2 + 2)*x^2 + (z2 + 2)*x + z2
```



> 3. Let E,F be rings. Suppose phi is a homomorphism from E to F. I want to extend phi to a homomorphism psi from the polynomial ring R=E[x] to F mapping x to c in F. Thus `psi(a2*x<sup>2+a1*x+a0)==phi(a2)*c</sup>2+phi(a1)*c+phi(a0)`.  Perhaps I want  `R.hom([c],F, base=phi)` or like to work. 

That seems more tricky to do. Note that it can easily be split into the composition of two homomorphisms:


```
mapCoef:  E[x]  --> F[x]
          a*x^i |-> phi(a)*x^i

eval:     F[x] --> F
             x |-> c
```


The eval homomorphism can be created in the current Sage, but I don't know how to conveniently create `mapCoef` (as a `Morphism` object).

Best,
Johan


---

Comment by klee created at 2016-10-10 12:47:47

Replying to [comment:12 jsrn]:
> Replying to [comment:11 klee]:
> > 1. Suppose F is a non-prime finite field, say `GF(3^2)`. I want to construct an extension field E over F. So `E,phi=F.extension(4,map=True)` gives the extension field `GF(3^8)`and the embedding phi. This currently only works for prime fields. 
> 
> That currently works fine, just try it.
> 
> If you want to go from `F` back to `E` for any of the elements `phi(E)`, use `phi.section()`.
> 
> If you want to express `F` as a vector space over `E`, things are more limited. We implemented basic support for it in `sage.coding.relative_finite_field_extension`. This ticket is about making that functionality much more general and thought out, and getting it into the core algebra of Sage.

Nice. Good luck!


---

Comment by klee created at 2016-10-11 17:40:45

The following reference might be useful for the design of the class:

Lattices of Compatibly Embedded Finite Fields - WIEB BOSMA, JOHN CANNON AND ALLAN STEEL 1997

as various extensions should be compatible to each other...


---

Comment by defeo created at 2017-02-07 16:53:33

Doctest failures:


```
sage -t src/sage/rings/algebra_from_morphism.py
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 260, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E2._pushout_(E1) is E2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 262, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1._pushout_(E2) is E2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 265, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1._pushout_(L2) is L2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 272, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1p._pushout_(E2) is L2
Expected:
    True
Got:
    False
**********************************************************************
File "src/sage/rings/algebra_from_morphism.py", line 276, in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
Failed example:
    E1p._pushout_(E2p) is L2
Expected:
    True
Got:
    False
**********************************************************************
1 item had failures:
   5 of  11 in sage.rings.algebra_from_morphism.AlgebraFromMorphism._pushout_
    [119 tests, 5 failures, 0.86 s]
----------------------------------------------------------------------
sage -t src/sage/rings/algebra_from_morphism.py  # 5 doctests failed
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.9 seconds
    cumulative wall time: 0.9 seconds
```

----
New commits:


---

Comment by defeo created at 2017-02-07 17:23:59

Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:


```
sage: K = GF(5^2)
sage: L = GF(5^4)
sage: E = L.algebra(K, category=Semigroups())
sage: E
Free module generated by Finite Field in z4 of size 5^4 over Finite Field in z2 of size 5^2
sage: E.an_element()
2*B[0] + 2*B[z4] + 3*B[z4^2]
sage: E.categories()

[Category of finite dimensional semigroup algebras over Finite Field in z2 of size 5^2,
 Category of semigroup algebras over Finite Field in z2 of size 5^2,
 Category of associative algebras over Finite Field in z2 of size 5^2,
 Category of rngs,
 Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,
 Category of magma algebras over Finite Field in z2 of size 5^2,
 Category of magmatic algebras with basis over Finite Field in z2 of size 5^2,
 Category of magmatic algebras over Finite Field in z2 of size 5^2,
 Category of additive commutative additive associative additive unital distributive magmas and additive magmas,
 Category of additive commutative additive associative distributive magmas and additive magmas,
 Category of additive associative distributive magmas and additive magmas,
 Category of distributive magmas and additive magmas,
 Category of magmas and additive magmas,
 Category of finite semigroups,
 Category of semigroups,
 Category of magmas,
 Category of finite dimensional modules with basis over Finite Field in z2 of size 5^2,
 Category of set algebras over Finite Field in z2 of size 5^2,
 Category of vector spaces with basis over Finite Field in z2 of size 5^2,
 Category of modules with basis over Finite Field in z2 of size 5^2,
 Category of finite dimensional modules over Finite Field in z2 of size 5^2,
 Category of vector spaces over Finite Field in z2 of size 5^2,
 Category of modules over Finite Field in z2 of size 5^2,
 Category of bimodules over Finite Field in z2 of size 5^2 on the left and Finite Field in z2 of size 5^2 on the right,
 Category of right modules over Finite Field in z2 of size 5^2,
 Category of left modules over Finite Field in z2 of size 5^2,
 Category of commutative additive groups,
 Category of additive groups,
 Category of additive inverse additive unital additive magmas,
 Category of commutative additive monoids,
 Category of additive monoids,
 Category of additive unital additive magmas,
 Category of commutative additive semigroups,
 Category of additive commutative additive magmas,
 Category of additive semigroups,
 Category of additive magmas,
 Category of finite sets,
 Category of sets,
 Category of sets with partial maps,
 Category of objects]
```



---

Comment by SimonKing created at 2017-02-07 18:21:37

Replying to [comment:17 defeo]:
> Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:

In what sense would it be relevant for this ticket?


---

Comment by defeo created at 2017-02-07 18:27:31

Hello, as you might have guessed, I'm trying to resurrect this ticket.

My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:

- It is silently not commutative;
- The parent of `a*k` is neither `A` nor `K`.

However I think the fix is simple: explicit is better than implicit, get rid of the coercion `A -> L`. I find the following idiom completely reasonable:


```
sage: K = GF(5^2); z2 = K.gen()
sage: L = GF(5^4); z4 = L.gen()
sage: A = RingExtension(L, K, K.frobenius_endomorphism())
sage: z2 * E(z4)
4*z4^3 + 3*z4^2 + 2*z4 + 2
sage: E(z4) * z2
TypeError: ...
sage: L(E(z4)) * z2
z4^3 + 2*z4^2 + 4*z4 + 3
```


It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).

Or maybe just have the right action be the same as the left action, which apparently you already did.


---

Comment by defeo created at 2017-02-07 18:31:15

Replying to [comment:18 SimonKing]:
> Replying to [comment:17 defeo]:
> > Had you guys notice that there is this interface in Sage, which returns a mostly empty shell:
> 
> In what sense would it be relevant for this ticket?

At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.

We had already discussed of various possible APIs for this, and `L.algebra_over(K)` was one of those. I think Johan was in favour of this kind of API, rather than cluttering the namespace with yet another mysterious name `RingExtension`. It would be quite confusing to have `L.algebra()` and `L.algebra_over()`.


---

Comment by SimonKing created at 2017-02-07 20:41:17

Replying to [comment:19 defeo]:
> My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:
> 
> - It is silently not commutative;

No problem, from my perspective. While "+" normally denotes a commutative operation in mathematics, "*" is generally not supposed to be commutative.

> - The parent of `a*k` is neither `A` nor `K`.

Why would that be a problem? If `a=x+2` is in `ZZ[x]` and `x=1/2` is in `QQ` then `a*x` neither is in `ZZ[x]` nor in `QQ`.

> It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).

Perhaps `x>>a` and `a<<x`?

Best regards,
Simon


---

Comment by SimonKing created at 2017-02-07 20:52:00

Replying to [comment:20 defeo]:
> At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.

I would not expect `L.algebra(K)` to return `RingExtension(L,K)` but to return the `K`-algebra with basis `L` whose multiplication is induced by the multiplication in  `L` (hence `L` is only supposed to be a multiplicative monoid).

> We had already discussed of various possible APIs for this, and `L.algebra_over(K)` was one of those. I think Johan was in favour of this kind of API, rather than cluttering the namespace with yet another mysterious name `RingExtension`.

I agree. When developing SageMath, we should avoid adding further stuff to the global namespace, whenever possible.

> It would be quite confusing to have `L.algebra()` and `L.algebra_over()`.

Perhaps a little variation: `L.as_algebra_over(K)`. Or, changing perspective: `L` is an extension **of `K`**; so, `L/K` should be returned by a method of `K`, not by a method of `L`. Say, `K.extension(L)`.


---

Comment by defeo created at 2017-02-07 22:12:12

Replying to [comment:21 SimonKing]:
> Replying to [comment:19 defeo]:
> > My biggest concern is the same as Johan's: I find `k*a != a*k` very confusing for two reasons:
> > 
> > - It is silently not commutative;
> 
> No problem, from my perspective. While "+" normally denotes a commutative operation in mathematics, "*" is generally not supposed to be commutative.

I expect it to be associative, at least. With the proposed code `(k*a)*k != k*(a*k)`.

> > - The parent of `a*k` is neither `A` nor `K`.
> 
> Why would that be a problem? If `a=x+2` is in `ZZ[x]` and `x=1/2` is in `QQ` then `a*x` neither is in `ZZ[x]` nor in `QQ`.

I know the coercion system finds common parents, but in your example `parent(a*x) == parent(x*a)`, and I expect the same here. I know there are exceptions even to this (e.g., matrices), but here we are talking about a commutative ring `A`, so I expect `*` to behave like its internal multiplication. 

By a very common stretch of notation, I am glad to accept `k*a` as a shorthand for `phi(k)*a`, but I really don't see why `a*k` should be a shorthand for `L(a)*L(k)`. If we want such exotic semantics, then we should use another symbol than `*`. See below

> > It could be useful if the left action was represented by an operator other than `*`, however there is no acceptable operator in Python (`.` cannot be overridden and ``@`` (matmul) was only introduced in Python 3.5).
> 
> Perhaps `x>>a` and `a<<x`?

That's quite ugly, but as I said, it would be the only sensible way to support such exotic semantics.

Let's keep in mind that 90% of Sage users are going to use this to work with field extensions of finite fields or number fields. They expect `k*a` to mean "scalar multiplication of `a` by `k`", not to raise an exception.

The uses proposed by Xavier are certainly important, and it would be nice to support them, but I think those mathematicians who want to work with them should be ready to accept a slightly more explicit notation (an explicit conversion, or a different operator). If they really want to have `k*a == a*k^p`, then they should use a dedicated class such as `SkewPolynomialRing`.


---

Comment by defeo created at 2017-02-07 22:23:41

Replying to [comment:22 SimonKing]:
> Replying to [comment:20 defeo]:
> > At the very least, it is confusing that there is a method defined on `L` whose name suggests it might return `RingExtension(L, K)`, and it returns a completely unrelated object instead.
> 
> I would not expect `L.algebra(K)` to return `RingExtension(L,K)` but to return the `K`-algebra with basis `L` whose multiplication is induced by the multiplication in  `L` (hence `L` is only supposed to be a multiplicative monoid).

I frankly don't know what I expect from `L.algebra(K)`. I would run it, and see what comes out.

> Perhaps a little variation: `L.as_algebra_over(K)`. Or, changing perspective: `L` is an extension **of `K`**; so, `L/K` should be returned by a method of `K`, not by a method of `L`. Say, `K.extension(L)`.

We had already considered this possibility. The problem is that `K.extension()` is already defined for most rings, and it returns a ring. It wouldn't break compatibility, but it would be a bit surprising if `QQ.extension(x^2+1)` returned a number field, whereas `QQ.extension(K)` returned an algebra object.

Of course, it could be `K.extension_algebra(L)`.


---

Comment by mderickx created at 2017-09-11 11:21:44

I am just reading up on this ticket, it has quote a long discussion. Does it still really need info? If so could someone who knows what info put that in the ticket description?


---

Comment by jsrn created at 2017-09-11 14:37:24

The "info" the ticket needs is a few decisions on trickier points of the design. But perhaps what would be most useful is a concrete suggestion by updating the ticket's code. I would personally also really like to see how e.g. a finite field extension of #20284 would be instantiated in the current - quite abstract - proposal.


---

Comment by mderickx created at 2017-09-11 17:19:50

Yes I agree that is important to get the design right, especially since this touches something that touches quite a few areas of sage, since finite fields are far from the only place that one wants to consider relative extensions.

It is quite difficult for me to grasp what the "current proposal" is from the all the discussion that has been going on here. Or is the the [one linked to in the description](https://gist.github.com/defeo/cabab27ea93aeb9e0deb0ba8c5bc745b). I need this for something else as well so I plan to work on this.

What I think is that sage already has a class for relative extensions, and that class is called CommutativeAlgebra from sage.rings.ring  . The only problem is that right now that class is a dummy class which has almost nothing implemented yet. 

So what I propose is the following, try to put as much general code as possible in CommutativeAlgebra and set up a framework there that makes it easy later for concrete implementations of rings/fields to see themselves as Algebras over over other bases then their current base. And use this framework to make things work as follows:


```
sage: GF(81).vector_space() #note this already works
Vector space of dimension 4 over Finite Field of size 3
sage: GF81_as_GF_9_algeba = Algebras(GF(9))(GF(81))
sage: GF81_as_GF_9_algeba.vector_space()
Vector space of dimension 2 over Finite Field in z2 of size 3^2
```


For the more complicated cases where there is no coercion morphism yet we can try to make the following work

```
Algebras(GF(9))(GF(81), morphism=my_morhpism)
```



---

Comment by defeo created at 2017-09-11 20:16:16

The main objection by `@`caruso, and the reason for the code he wrote, was that most on the interface, and some algorithms, can also be useful for non-commutative algebras.

He is especially interested in "skew algebras". Citing [comment:8 `@`caruso]:

> The point is that I really want to have algebras_from_morphisms_which_are_not_coercion_maps and I think that implementing the action of scalars (through the defining morphism) is the least we can do.


---

Comment by git created at 2018-09-05 11:20:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jsrn created at 2019-06-26 13:32:48

I inexplicably got remotivated to revive and work on this, despite its marathon
discussion and open questions. I'll try to summarise the design problems we are
facing along with solution proposals in the following.

**Naming:** Of the now many suggestions, I really like that the algebra `L/K`
could be obtained from `K.extension_algebra(L)`. `AlgebraWithMorphism` should
not be exposed in the global namespace since it is too abstract to have any
useful functionality in itself.

**The commutativity issue:** The issue is that in the current proposal, if `A = L/K` uses a defining map `phi` which is _not_ the coercion map of `K` in `L`, then
`k*a == phi(k)*a`, while `a*k == a*L(k)`. This could cause confusion for users,
but also developers since the class of `A` currently derives from
`CommutativeAlgebra` (In `A` we do guarantee that `a1 * a2 = a2 * a1`)

It has been suggested to let `*` be commutative and mean `k * a = a * k = a * L(k)`, and introduce a new operator for `phi(k) * a`. I propose using the
binary-and operator for this purpose, `&`, and hence


```
   k & a = a & k = phi(k) * a = a * phi(k) = A(k) * a = a * A(k)
```


**The issue with `L.algebra`:** The issue is that there is an existing method
 `L.algebra(K)`, which does something different from what we want. One way to
 alleviate confusion suggested by Simon is to introduce the method
 `L.as_algebra_over(K)`. I see no reason why we could not have both this as well
 as `K.extension_algebra(L)`.

**Writing `GF(q^m)/GF(q)` in this ticket:** I still advocate that we should write a
 (bare-bone) implementation of this particular ring extension in this ticket. We
 need to see the abstract class in action to properly judge whether the design
 is at least not crazy.


---

Comment by jsrn created at 2019-06-26 13:32:48

Changing status from needs_info to needs_work.


---

Comment by klee created at 2019-06-26 14:19:10

Replying to [comment:32 jsrn]:
> **Writing `GF(q^m)/GF(q)` in this ticket:** I still advocate that we should write a
>  (bare-bone) implementation of this particular ring extension in this ticket. We
>  need to see the abstract class in action to properly judge whether the design
>  is at least not crazy.

Actually I have a plan to remove the experimental `RelativeFiniteFieldExtension`  module from the coding section of Sage, right after the cleanup ticket #27634. For one thing, the module is ill-placed. For another, codes can live without it -- I checked this.

By the way, welcome back Johan!


---

Comment by roed created at 2019-09-07 12:14:56

Changing keywords from "sd75" to "sd75, padicBordeaux".


---

Comment by git created at 2019-09-10 15:09:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-10 16:21:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-10 20:38:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-11 17:20:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-11 21:17:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-12 12:15:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-12 12:50:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-12 13:20:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2019-09-12 16:42:28

`is_finite` should not return `True` btw as this is about cardinality.


---

Comment by saraedum created at 2019-09-12 17:43:27

It appears that your homs cannot handle generators?

The following happens in the new finite field code:


```
sage: GF(3^2).extension(3, absolute=False)._any_embedding(GF(3^12))
```


produces

```
        if codomain.has_coerce_map_from(self):
      File "sage/structure/parent.pyx", line 1969, in sage.structure.parent.Parent.has_coerce_map_from (build/cythonized/sage/structure/parent.c:16392)
        cpdef bint has_coerce_map_from(self, S) except -2:
      File "sage/structure/parent.pyx", line 1991, in sage.structure.parent.Parent.has_coerce_map_from (build/cythonized/sage/structure/parent.c:16343)
        return self._internal_coerce_map_from(S) is not None
      File "sage/structure/parent.pyx", line 2133, in sage.structure.parent.Parent._internal_coerce_map_from (build/cythonized/sage/structure/parent.c:17274)
        mor = self.discover_coerce_map_from(S)
      File "sage/structure/parent.pyx", line 2270, in sage.structure.parent.Parent.discover_coerce_map_from (build/cythonized/sage/structure/parent.c:17722)
        user_provided_mor = self._coerce_map_from_(S)
      File "sage/rings/finite_rings/finite_field_base.pyx", line 1334, in sage.rings.finite_rings.finite_field_base.FiniteField._coerce_map_from_ (build/cythonized/sage/rings/finite_rings/finite_field_base.c:15164)
        return R.hom((self.gen() ** ((self.order() - 1)//(R.order() - 1)),))
      File "sage/structure/parent_gens.pyx", line 291, in sage.structure.parent_gens.ParentWithGens.hom (build/cythonized/sage/structure/parent_gens.c:3689)
        return parent.Parent.hom(self, im_gens, codomain, base_map=base_map, category=category, check=check)
      File "sage/structure/parent.pyx", line 1363, in sage.structure.parent.Parent.hom (build/cythonized/sage/structure/parent.c:11767)
        return self.Hom(codomain, **Hom_kwds)(im_gens, **kwds)
      File "/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension_homset.py", line 7, in __call__
        return RingExtensionHomomorphism(self, *args, **kwargs)
      File "sage/rings/ring_extension_morphism.pyx", line 74, in sage.rings.ring_extension_morphism.RingExtensionHomomorphism.__init__ (build/cythonized/sage/rings/ring_extension_morphism.c:4992)
        backend = backend_morphism(backend)
      File "sage/rings/ring_extension_morphism.pyx", line 33, in sage.rings.ring_extension_morphism.backend_morphism (build/cythonized/sage/rings/ring_extension_morphism.c:3757)
        g = _backend_morphism(f)
      File "sage/rings/ring_extension_morphism.pyx", line 22, in sage.rings.ring_extension_morphism._backend_morphism (build/cythonized/sage/rings/ring_extension_morphism.c:3355)
        if not isinstance(f.domain(), RingExtension_class) and not isinstance(f.codomain(), RingExtension_class):
    AttributeError: 'list' object has no attribute 'domain'
```


where `any_embedding` looks like this:

```
    def _any_embedding(self, codomain):
        if codomain.has_coerce_map_from(self):
            return codomain.coerce_map_from(self)

        base_hom = self.base_ring()._any_embedding(codomain)
        minpoly = self.gen().minpoly().change_ring(base_hom)
        return self.hom(codomain, [minpoly.any_root()], base_map=base_hom)
```


Here is some more info about this:


```
sage: k = GF(3^2).extension(3, absolute=False)
sage: l = GF(3^12)
sage: k._defining_morphism
Ring morphism:
  From: Finite Field in z2 of size 3^2
  To:   Finite Field in b729 of size 3^6
  Defn: z2 |--> 2*b729^5 + 2*b729^3 + b729^2 + 2*b729 + 2
sage: l.has_coerce_map_from(k) *boom*
```



---

Comment by saraedum created at 2019-09-12 17:44:52

Also, it seems that you want to make this change to ignore any check here

```
diff --git a/src/sage/rings/ring_extension_morphism.pyx b/src/sage/rings/ring_extension_morphism.pyx
index 3028d763ec..644273ddd3 100644
--- a/src/sage/rings/ring_extension_morphism.pyx
+++ b/src/sage/rings/ring_extension_morphism.pyx
@@ -63,7 +63,7 @@ cdef class RingExtensionHomomorphism(RingHomomorphism):
         sage: E2 = RingExtension(L,K)
 
     """
-    def __init__(self, parent, backend):
+    def __init__(self, parent, backend, check=None):
         RingHomomorphism.__init__(self, parent)
         backend_domain = self.domain()
         if isinstance(backend_domain, RingExtension_class):
```



---

Comment by saraedum created at 2019-09-12 21:49:21

I think that `RingExtension_class` shouldn't be a `UniqueRepresentation`. Instead `RingExtension` should be a factory. Otherwise, I probably can't inherit from `RingExtension_class` for classes that are served through a `UniqueFactory`.


---

Comment by saraedum created at 2019-09-12 22:48:01

Working on p-adic extensions with this I am now stuck at this that I cannot make much sense of.

Go to https://gitlab-hooks-flau3jeaza-ew.a.run.app/status/dev/branch/general-extensions click "Launch Binder" and type in

```
L.<a> = Qp(2).extension(x)
```


to get

```
/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension.pyc in __init__(self, defining_morphism, basis, names, coerce, check)
    616     def __init__(self, defining_morphism, basis, names=None, coerce=False, check=True):
    617         RingExtension_class.__init__(self, defining_morphism, coerce)
--> 618         self._basis = [ self(b) for b in basis ]
    619         if names is None:
    620             names = [ ]

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9203)()
    898         if mor is not None:
    899             if no_extra_args:
--> 900                 return mor._call_(x)
    901             else:
    902                 return mor._call_with_args(x, args, kwds)

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension_morphism.pyx in sage.rings.ring_extension_morphism.RingExtensionHomomorphism._call_ (build/cythonized/sage/rings/ring_extension_morphism.c:5278)()
     85         if isinstance(self.domain(), RingExtension_class):
     86             x = x._backend()
---> 87         y = self._backend_morphism(x)
     88         if isinstance(self.codomain(), RingExtension_class):
     89             y = self._codomain(y)

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/categories/map.pyx in sage.categories.map.Map.__call__ (build/cythonized/sage/categories/map.c:6517)()
    771         if P is D: # we certainly want to call _call_/with_args
    772             if not args and not kwds:
--> 773                 return self._call_(x)
    774             return self._call_with_args(x, args, kwds)
    775         # Is there coercion?

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/morphism.pyx in sage.rings.morphism.RingHomomorphism_im_gens._call_ (build/cythonized/sage/rings/morphism.c:9428)()
   1285             2*x + 3*y + 2*z
   1286         """
-> 1287         return x._im_gens_(self.codomain(), self.im_gens(), base_map=self.base_map())
   1288 
   1289 

/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/structure/element.pyx in sage.structure.element.Element._im_gens_ (build/cythonized/sage/structure/element.c:5592)()
    615         tuple of elements of im_gens.
    616         """
--> 617         raise NotImplementedError
    618 
    619     cpdef base_extend(self, R):

NotImplementedError: 
```



---

Comment by git created at 2019-09-13 12:40:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-13 13:51:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2019-09-13 14:03:13

I think we should change this:

```
/projects/ab5d7b52-0433-4883-9a36-a20aa7103d52/sage/local/lib/python2.7/site-packages/sage/rings/ring_extension.py(699)__init__()
    697             RingExtensionWithBasis.__init__(self, defining_morphism, basis, names, coerce, check)
    698         except ValueError:
--> 699             raise ValueError("the given element is not a generator")
```


The actual error was: `*** ValueError: too many values to unpack`. Essentially a syntax error that now manifested in that strange way.

We probably do not want to catch at all here but instead add a comment in the line above `RingExtensionWithBasis.__init__(…)` that says something like `if you see a ValueError here, gen is probably not a generator`.


---

Comment by saraedum created at 2019-09-13 14:44:15

You might want to cherry pick these two commits:

https://gitlab.com/sagemath/sage/merge_requests/33/diffs?commit_id=2482826f13425776a95576fbe8a602b636259ad3

https://gitlab.com/sagemath/sage/merge_requests/33/diffs?commit_id=d044c89f78c0d0b6f6db2042b5c1e30ddb8b27b8

(or just manually copy them over.)


---

Comment by git created at 2019-09-13 15:20:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-09-13 19:34:23

We worked with David Roe and Julian Rüth on this ticket this week and finally decided to follow a different approach. We defined a coercion map from `K` to the extension `A = L/K` (coming from the defining morphism) but no coercion map from `A` to `L` (except when `K` coerces to `L` through the defining morphism of the extension). Consequently `a*k` is always the same as `k*a` (and is equal to `phi(k)*a` where `phi` is the defining morphism) but differs from `l*k`.

This point of view looked good to us because, in the use cases we have in mind (typically implementing field towers), the defining morphisms are basically never coercion maps but we definitely don't want to use the ``@`` operator to perform multiplications in the tower.

We also implemented special classes for finite field extensions. Below is a short demo showing the capabilities provided by this ticket.

We first create several a bunch of number fields and define a tower of extension `QQ -> AA -> BB -> CC`. (Currently, the tower is not that easy to define because we still miss a good `extension` method; we will implement it soon, hopefully.)


``` 
sage: A.<a> = QQ.extension(x^2 - 2)
sage: B.<b> = QQ.extension(x^4 - 2)
sage: C.<c> = QQ.extension(x^12 - 2)

# We create extensions
sage: AA.<a> = RingExtension(QQ)
sage: f = Hom(AA,B)(A.hom([b^2]))
sage: BB.<b> = RingExtension(f)
sage: g = Hom(BB,C)(B.hom([c^3]))
sage: CC.<c> = RingExtension(g)
```


Now we have our tower `QQ -> AA -> BB -> CC`. Let's play with it.


```
sage: AA
Ring in a with defining polynomial x^2 - 2 over its base
sage: BB
Ring in b with defining polynomial x^2 - a over its base
sage: CC
Ring in c with defining polynomial x^3 - b over its base

sage: CC.base_field()
Ring in b with defining polynomial x^2 - a over its base
sage: CC.base_field() is BB
True
sage: BB.base_field() is AA
True
sage: CC.intermediate_rings()
[Ring in c with defining polynomial x^3 - b over its base,
 Ring in b with defining polynomial x^2 - a over its base,
 Ring in a with defining polynomial x^2 - 2 over its base,
 Number Field in void with defining polynomial x]

sage: CC.gens()
(c,)
```


The `gens` method has also a relative version


```
sage: CC.gens(AA)   # generators over AA
(c,b)
sage: CC.gens(QQ)
(c,b,a)
```


And also:


```
sage: CC.basis()
[1, c, c^2]
sage: CC.basis(AA)
[1, c, c^2, b, b*c, b*c^2]
sage: CC.basis(QQ)
[1, c, c^2, b, b*c, b*c^2, a, a*c, a*c^2, a*b, a*b*c, a*b*c^2]
```


Now let's play with elements


```
sage: u = CC.random_element(); u
((-1/2 + 2*a) - 31*b) + (2 + (1 + 1/2*a)*b)*c + ((5/2 - 1/2*a) + 3*b)*c^2
sage: u.trace()     # trace over the base field BB
(-3/2 + 6*a) - 93*b
sage: u.norm()
(95447/8 - 5353/8*a) + (-2443/4 - 115345/4*a)*b
sage: u.matrix()
[  (-1/2 + 2*a) - 31*b     2 + (1 + 1/2*a)*b   (5/2 - 1/2*a) + 3*b]
[3*a + (5/2 - 1/2*a)*b   (-1/2 + 2*a) - 31*b     2 + (1 + 1/2*a)*b]
[        (1 + a) + 2*b 3*a + (5/2 - 1/2*a)*b   (-1/2 + 2*a) - 31*b]
sage: u.polynomial()
((5/2 - 1/2*a) + 3*b)*x^2 + (2 + (1 + 1/2*a)*b)*x + (-1/2 + 2*a) - 31*b
sage: u.polynomial()(c) == u
True
```


Similarly, all the above functions have relative versions


```
sage: u.trace(QQ)
-6
sage: u.trace().trace().trace() == u.trace(QQ)
True
sage: u.matrix(AA)
[ -1/2 + 2*a           2 5/2 - 1/2*a         -31   1 + 1/2*a           3]
[        3*a  -1/2 + 2*a           2 5/2 - 1/2*a         -31   1 + 1/2*a]
[      1 + a         3*a  -1/2 + 2*a           2 5/2 - 1/2*a         -31]
[      -31*a       1 + a         3*a  -1/2 + 2*a           2 5/2 - 1/2*a]
[ -1 + 5/2*a       -31*a       1 + a         3*a  -1/2 + 2*a           2]
[        2*a  -1 + 5/2*a       -31*a       1 + a         3*a  -1/2 + 2*a]
sage: P = u.polynomial(QQ); P
3*x0^2*x1 - 1/2*x0^2*x2 + 1/2*x0*x1*x2 + 5/2*x0^2 + x0*x1 + 2*x0 - 31*x1 + 2*x2 - 1/2
sage: P(c,b,a) == u   # (c,b,a) are the generators of CC over QQ
True
```



---

Comment by git created at 2019-09-13 20:21:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-14 10:15:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-15 22:01:52

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2019-09-21 10:41:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-22 21:14:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-24 15:47:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-26 10:08:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-26 19:21:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-26 20:02:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-26 20:25:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-10-03 19:51:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-10-03 23:50:28

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2019-10-06 17:06:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-10-06 17:10:06

Changing status from needs_work to needs_review.


---

Comment by git created at 2019-10-06 18:39:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-10-06 18:49:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-10-07 15:51:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-10-07 15:56:34

See the description of the ticket for a small tutorial showing the main functionalities provided by this ticket.


---

Comment by git created at 2019-10-13 03:01:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-11-14 21:48:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-11-14 22:40:25

I changed the milestone, hoping that it will encourage the patchbot to run on this ticket.
----
New commits:


---

Comment by roed created at 2019-11-15 09:43:52

Positive review once tests pass


---

Comment by caruso created at 2019-11-15 11:39:05

Patchbot reported many errors of this shape:

```
Failed example:
    type(K)
Expected:
    <class 'sage.rings.ring_extension.RingExtensionWithGen'>
Got:
    <type 'sage.rings.ring_extension.RingExtensionWithGen'>
```

This sounds weird.

Actually, on my laptop, the output I get is `class` and not `type`. Moreover, I noticed the same ambiguity in many other places in Sage. Even more bizarre, sometimes `type` appears in the doctest, my output is `class` but no error is reported.

Do you know what's going on here?


---

Comment by git created at 2019-11-15 11:54:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2019-11-15 16:03:10

Python2 versus python3. You are supposed to use python3 for development..


---

Comment by caruso created at 2019-11-15 16:17:35

OK. So does it mean that I should keep `class` as it is currently?


---

Comment by chapoton created at 2019-11-15 18:56:15

You should do whatever it takes to have doctests pass in both py2 and py3.

Here this can be achieved by writing `...` instead of type or class.

There is also an existing mechanism in the doctest framework that accepts "class" when "type" is required. The other direction has not been implemented. So you can use "type".


---

Comment by git created at 2019-11-16 06:47:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-11-16 10:55:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2019-11-16 17:35:28

Reste encore un problème sous python2:

```
sage -t --long src/sage/rings/ring_extension_homset.py
**********************************************************************
File "src/sage/rings/ring_extension_homset.py", line 26, in sage.rings.ring_extension_homset.RingExtensionHomset
Failed example:
    type(H)
Expected:
    <type 'sage.rings.ring_extension_homset.RingExtensionHomset_with_category'>
Got:
    <class 'sage.rings.ring_extension_homset.RingExtensionHomset_with_category'>
```

qui me semble bizarre. Il devrait être réglé comme les autres par le mécanisme dont j'ai parlé. Utiliser `...` pour celui-la, peut-être ?


---

Comment by git created at 2019-11-16 17:49:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-11-16 19:55:23

All tests pass!


---

Comment by roed created at 2019-11-17 06:09:41

Wonderful!


---

Comment by roed created at 2019-11-17 06:09:41

Changing status from needs_review to positive_review.


---

Comment by caruso created at 2019-11-18 08:54:00

Mumble... build failed with sage 9.0.beta6

Here is the error:


```
[sagelib-9.0.beta6] Traceback (most recent call last):
[sagelib-9.0.beta6]   File "setup.py", line 22, in <module>
[sagelib-9.0.beta6]     import fpickle_setup
[sagelib-9.0.beta6]   File "/local/sage-patchbot/sage/src/fpickle_setup.py", line 8, in <module>
[sagelib-9.0.beta6]     from six.moves import copyreg
[sagelib-9.0.beta6] ModuleNotFoundError: No module named 'six'
```


I would say that it is not related to this ticket, is it?


---

Comment by chapoton created at 2019-11-18 09:22:02

caused by the switch to python3. You need to do "make distclean" and "make"


---

Comment by caruso created at 2019-11-18 10:15:00

Well, this error was reported (4 times) by the patchbot; it is normal?


---

Comment by chapoton created at 2019-11-18 10:52:31

As explained on sage-devel, all patchbots were broken by the switch to python3


---

Comment by vbraun created at 2019-11-19 23:36:01

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2019-11-19 23:36:01

PDF docs don't build 

```
! Undefined control sequence.
l.7333 \(K_n/\cots
                  \K_2/K_1\) is the ring \(K_1\).
```



---

Comment by git created at 2019-11-20 07:10:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-11-20 07:12:11

Changing status from needs_work to needs_review.


---

Comment by caruso created at 2019-11-20 07:12:11

Thanks. Fixed.


---

Comment by git created at 2019-11-20 11:30:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by roed created at 2019-11-20 21:26:11

Changing status from needs_review to positive_review.


---

Comment by roed created at 2019-11-20 21:26:11

I checked that the documentation builds now.


---

Comment by vbraun created at 2019-11-28 00:33:51

pdf docs don't build:

```
[docpdf] ! Undefined control sequence.
[docpdf] <recently read> \K 
[docpdf]                    
[docpdf] l.7333 \(K_n/\cdots\K
[docpdf]                      _2/K_1\) is the ring \(K_1\).
[docpdf] ? 
```



---

Comment by vbraun created at 2019-11-28 00:33:51

Changing status from positive_review to needs_work.


---

Comment by git created at 2019-11-29 16:22:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2019-11-29 16:23:23

Changing status from needs_work to needs_review.


---

Comment by caruso created at 2019-11-29 16:23:23

Should be OK this time...


---

Comment by embray created at 2020-01-06 14:10:03

Ticket retargeted after milestone closed


---

Comment by caruso created at 2020-01-07 08:58:46

David, if my changes are okay with you, could you please give (again) a positive review to this ticket?


---

Comment by git created at 2020-01-10 08:12:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2020-01-10 16:52:23

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2020-01-10 16:52:23

ok, let it be


---

Comment by caruso created at 2020-01-11 07:59:51

Thanks.

BTW, do you know why some patchbots report building errors?


---

Comment by vbraun created at 2020-01-15 20:35:52

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2020-01-15 20:35:52

I'm getting a lot of failures like this on 32-bit

```
**********************************************************************
File "src/sage/categories/commutative_rings.py", line 156, in sage.categories.commutative_rings.CommutativeRings.ParentMethods.over
Failed example:
    L = GF(5^12).over(K)
Exception raised:
    Traceback (most recent call last):
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1123, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.categories.commutative_rings.CommutativeRings.ParentMethods.over[17]>", line 1, in <module>
        L = GF(Integer(5)**Integer(12)).over(K)
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/categories/commutative_rings.py", line 212, in over
        return RingExtension(self, base, gens, names)
      File "sage/structure/factory.pyx", line 369, in sage.structure.factory.UniqueFactory.__call__ (build/cythonized/sage/structure/factory.c:2240)
        return self.get_object(version, key, kwds)
      File "sage/structure/factory.pyx", line 406, in sage.structure.factory.UniqueFactory.get_object (build/cythonized/sage/structure/factory.c:2444)
        return self._cache[version, cache_key]
      File "sage/misc/weak_dict.pyx", line 703, in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3650)
        cdef PyObject* wr = PyDict_GetItemWithError(self, k)
      File "sage/categories/morphism.pyx", line 323, in sage.categories.morphism.Morphism.__hash__ (build/cythonized/sage/categories/morphism.c:4888)
        return hash((domain, codomain, definition))
      File "sage/rings/ring_extension.pyx", line 696, in sage.rings.ring_extension.RingExtension_generic.__hash__ (build/cythonized/sage/rings/ring_extension.c:10685)
        return id(self)
    OverflowError: Python int too large to convert to C ssize_t
**********************************************************************
```



---

Comment by chapoton created at 2020-01-16 20:52:47

using id(self) for the hash may be a bad idea


---

Comment by roed created at 2020-01-16 21:04:36

We can certainly fix that problem, but neither Xavier nor I have access to a 32-bit machine, so I'm not sure what other problems might arise.


---

Comment by dimpase created at 2020-01-17 21:48:36

Replying to [comment:112 roed]:
> We can certainly fix that problem, but neither Xavier nor I have access to a 32-bit machine, so I'm not sure what other problems might arise.

just to mention that the access is now available :-)


---

Comment by git created at 2020-01-23 10:01:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2020-01-23 10:02:21

I'm trying with the function `hash_by_id`...


---

Comment by caruso created at 2020-01-23 10:17:52

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2020-01-23 18:57:37

did you check on a 32-bit machine ? If yes, you can set to positive on my name


---

Comment by roed created at 2020-01-23 19:13:22

Changing status from needs_review to positive_review.


---

Comment by roed created at 2020-01-23 19:13:22

I just ran `make ptestlong` on a 32-bit machine and they all passed.  Setting back to positive review.


---

Comment by vbraun created at 2020-01-25 17:27:22

Resolution: fixed


---

Comment by caruso created at 2020-01-26 22:24:41

Champagne!
