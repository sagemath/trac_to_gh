# Issue 15564: Categories over a base ring category

archive/issues_015564.json:
```json
{
    "body": "CC:  sage-combinat @vbraun simonking @darijgr\n\nCurrently, to construct a category of algebras, we need to specify the\nbase ring:\n\n```\n    sage: Algebras(QQ)\n```\n\n\nA side effect is that the construction of e.g. `GF(p)['x']` for a\nlot of `p`'s in number theoretic calculations triggers the\nconstruction of many parallel hierarchies of categories.\n\nThis is a waste because in most situations only the category of the\nbase ring is relevant. In particular, the generic code provided to\nparents/elements/... only depends on the latter.\n\nThe purpose of this ticket is to allow for only specifying the\ncategory of the base ring, as in:\n\n```\n    sage: Algebras(Fields())\n```\n\nwith\n\n```\n    sage: Algebras(QQ)\n```\n\nconstructing a subcategory of the former. Then go trough the code,\ndecide in each case whether we want to use {{{Algebras(QQ)}} or\n`Algebras(Fields())`, and update the doctests accordingly. In most\ncase, the latter idiom will be preferable, unless we need some\noperation on the category itself.\n\nThis would fix the regression noted on #15792 and made worse by\n#10963.\n\nFurther features for this ticket or follow-up tickets would be to:\n\n- make `Modules(...)` into a covariant functorial\n  constructions. This would give a proper framework for the feature\n  `Modules(QQ)` -> `VectorSpaces(QQ)` instead of having to\n  tackle it with a special hack.\n\n- implement a `PolynomialRings(...)`  covariant functorial\n  construction.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15801\n\n",
    "created_at": "2014-02-10T11:41:14Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Categories over a base ring category",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15564",
    "user": "https://github.com/nthiery"
}
```
CC:  sage-combinat @vbraun simonking @darijgr

Currently, to construct a category of algebras, we need to specify the
base ring:

```
    sage: Algebras(QQ)
```


A side effect is that the construction of e.g. `GF(p)['x']` for a
lot of `p`'s in number theoretic calculations triggers the
construction of many parallel hierarchies of categories.

This is a waste because in most situations only the category of the
base ring is relevant. In particular, the generic code provided to
parents/elements/... only depends on the latter.

The purpose of this ticket is to allow for only specifying the
category of the base ring, as in:

```
    sage: Algebras(Fields())
```

with

```
    sage: Algebras(QQ)
```

constructing a subcategory of the former. Then go trough the code,
decide in each case whether we want to use {{{Algebras(QQ)}} or
`Algebras(Fields())`, and update the doctests accordingly. In most
case, the latter idiom will be preferable, unless we need some
operation on the category itself.

This would fix the regression noted on #15792 and made worse by
#10963.

Further features for this ticket or follow-up tickets would be to:

- make `Modules(...)` into a covariant functorial
  constructions. This would give a proper framework for the feature
  `Modules(QQ)` -> `VectorSpaces(QQ)` instead of having to
  tackle it with a special hack.

- implement a `PolynomialRings(...)`  covariant functorial
  construction.

Issue created by migration from https://trac.sagemath.org/ticket/15801





---

archive/issue_comments_200790.json:
```json
{
    "body": "As commented on #10963, I see some questions to be addressed.\n\nIf I understand correctly, we sometimes do want to specify the base ring/field, and Volker says that this should be by a \"mixin\" category (lets call it `FixedBaseRing(...)`) that simply is joined with the non-specific category, say, `Algebras(Fields())`.\n\nFirst complication: We not only have base rings, but (for bimodules) left and right base rings. Should this be reflected in the \"FixedBaseBla\" categories as well?\n\nAnd another complication: We want to have categories expressing the fact that a field (not just a ring) is acting on the objects, and then want to compute the join. Is there an easy programmatic way to let an error be raised when someone tries to compute the join \"Algebras(Fields()) & FixedBaseRing(ZZ)\"?",
    "created_at": "2014-02-10T11:49:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200790",
    "user": "https://github.com/simon-king-jena"
}
```

As commented on #10963, I see some questions to be addressed.

If I understand correctly, we sometimes do want to specify the base ring/field, and Volker says that this should be by a "mixin" category (lets call it `FixedBaseRing(...)`) that simply is joined with the non-specific category, say, `Algebras(Fields())`.

First complication: We not only have base rings, but (for bimodules) left and right base rings. Should this be reflected in the "FixedBaseBla" categories as well?

And another complication: We want to have categories expressing the fact that a field (not just a ring) is acting on the objects, and then want to compute the join. Is there an easy programmatic way to let an error be raised when someone tries to compute the join "Algebras(Fields()) & FixedBaseRing(ZZ)"?



---

archive/issue_comments_200791.json:
```json
{
    "body": "Replying to [comment:1 SimonKing]:\n> So, the strategy would be this: The current \"Category over base ring\" should accept as input no a ring, but a subcategory of the category of rings.\n\nOr more precisely, it would accept both kinds of input.\n\n> A polynomial ring should be initialised in the category of \"commutative algebras over Category of quotient fields\" (say), and should of course have its own reference to the base ring (say, the rational field).\n\nYup. And later in the category of \"polynomial rings over a quotient field.\"\n\n> Since the parent and element classes only depend on the category of the base ring (by the current implementation), a category refinement would probably not be needed.\n\nYes.\n\n> But *if* needed, it would amount to take the join with the category \"`FixedBaseField(QQ)`, perhaps with super-categories \"`FixedBaseRing(QQ)`\".\n\nYes, though I would write it as taking the join with Algebras(QQ).\n\n> Additional technical problem: We not only have base rings, but (for bimodules) left and right base rings. Should this be reflected in the \"`FixedBaseBla`\" categories as well?\n\nWe will want to accept both:\n\n```\n    Bimodules(Fields(), Fields())\n```\n\nand\n\n```\n    Bimodules(QQ, QQ)\n```\n\n\nIn a first step, I would not bother about mixed calls likes `Bimodules(QQ, Fields)`/\n\n> And another complication: We want to have categories expressing the fact that a field (not just a ring) is acting on the objects, and then want to compute the join. Is there an easy programmatic way to let an error be raised when someone tries to compute the join \"`Algebras(Fields()) & FixedBaseRing(ZZ)`\"?\n\nI don't see a trivial way to do it at this point. It certainly would\nbe a nice feature to bark upon such constructions, but not having it\nis not really worst than the current situation where we have:\n\n```\nsage: Algebras(QQ) & Algebras(GF(3))\nJoin of Category of algebras over Finite Field of size 3 and Category of algebras over Rational Field\n```\n\n\nSo this issue should not prevent us to proceed even if we don't find a good way out.",
    "created_at": "2014-02-10T11:56:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200791",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:1 SimonKing]:
> So, the strategy would be this: The current "Category over base ring" should accept as input no a ring, but a subcategory of the category of rings.

Or more precisely, it would accept both kinds of input.

> A polynomial ring should be initialised in the category of "commutative algebras over Category of quotient fields" (say), and should of course have its own reference to the base ring (say, the rational field).

Yup. And later in the category of "polynomial rings over a quotient field."

> Since the parent and element classes only depend on the category of the base ring (by the current implementation), a category refinement would probably not be needed.

Yes.

> But *if* needed, it would amount to take the join with the category "`FixedBaseField(QQ)`, perhaps with super-categories "`FixedBaseRing(QQ)`".

Yes, though I would write it as taking the join with Algebras(QQ).

> Additional technical problem: We not only have base rings, but (for bimodules) left and right base rings. Should this be reflected in the "`FixedBaseBla`" categories as well?

We will want to accept both:

```
    Bimodules(Fields(), Fields())
```

and

```
    Bimodules(QQ, QQ)
```


In a first step, I would not bother about mixed calls likes `Bimodules(QQ, Fields)`/

> And another complication: We want to have categories expressing the fact that a field (not just a ring) is acting on the objects, and then want to compute the join. Is there an easy programmatic way to let an error be raised when someone tries to compute the join "`Algebras(Fields()) & FixedBaseRing(ZZ)`"?

I don't see a trivial way to do it at this point. It certainly would
be a nice feature to bark upon such constructions, but not having it
is not really worst than the current situation where we have:

```
sage: Algebras(QQ) & Algebras(GF(3))
Join of Category of algebras over Finite Field of size 3 and Category of algebras over Rational Field
```


So this issue should not prevent us to proceed even if we don't find a good way out.



---

archive/issue_comments_200792.json:
```json
{
    "body": "OK, that's the other possibility: Rather than having a separate mix-in category `FixedBaseRing(...)`, we would allow both `Algebras(Fields())` and `Algebras(QQ)`.\n\nI have already done some experiments in that direction. We certainly want `Algebras(R.category())` among the super-categories of `Algebras(R)`. But if `C` is a category, do we want that `Algebras(D)` is among the super-categories of `Algebras(C)`, for all `D` in `C.super_categories()`?\n\nWhen I tried it yesterday, Nicolas' bounded C3 algorithm barked at me. Reason (if I recall correctly, I can't use my laptop right now): We want that `Algebras(QQ)` and `Algebras(QQ.category()` have the same parent and element classes, hence, `_make_named_class_key` returns the same, and thus they also share the cmp-key used in the C3 algorithm. But the C3 algorithm expects that the items on the given lists (here: the list of all super categories) have distinct keys.\n\nOne possible approach to solve that problem: The strict super-categories of a category with fixed base ring should *all* be categories with unspecified base rings. Hence, `Algebras(R)` should not have the super-categories `Rings()` and `Modules(R)`, but `Algebras(R.category())`.",
    "created_at": "2014-02-10T12:46:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200792",
    "user": "https://github.com/simon-king-jena"
}
```

OK, that's the other possibility: Rather than having a separate mix-in category `FixedBaseRing(...)`, we would allow both `Algebras(Fields())` and `Algebras(QQ)`.

I have already done some experiments in that direction. We certainly want `Algebras(R.category())` among the super-categories of `Algebras(R)`. But if `C` is a category, do we want that `Algebras(D)` is among the super-categories of `Algebras(C)`, for all `D` in `C.super_categories()`?

When I tried it yesterday, Nicolas' bounded C3 algorithm barked at me. Reason (if I recall correctly, I can't use my laptop right now): We want that `Algebras(QQ)` and `Algebras(QQ.category()` have the same parent and element classes, hence, `_make_named_class_key` returns the same, and thus they also share the cmp-key used in the C3 algorithm. But the C3 algorithm expects that the items on the given lists (here: the list of all super categories) have distinct keys.

One possible approach to solve that problem: The strict super-categories of a category with fixed base ring should *all* be categories with unspecified base rings. Hence, `Algebras(R)` should not have the super-categories `Rings()` and `Modules(R)`, but `Algebras(R.category())`.



---

archive/issue_comments_200793.json:
```json
{
    "body": "Replying to [comment:3 SimonKing]:\n> OK, that's the other possibility: Rather than having a separate mix-in category `FixedBaseRing(...)`, we would allow both `Algebras(Fields())` and `Algebras(QQ)`.\n> \n> I have already done some experiments in that direction. We certainly want `Algebras(R.category())` among the super-categories of `Algebras(R)`. But if `C` is a category, do we want that `Algebras(D)` is among the super-categories of `Algebras(C)`, for all `D` in `C.super_categories()`?\n\n> When I tried it yesterday, Nicolas' bounded C3 algorithm barked at me. Reason (if I recall correctly, I can't use my laptop right now): We want that `Algebras(QQ)` and `Algebras(QQ.category()` have the same parent and element classes, hence, `_make_named_class_key` returns the same, and thus they also share the cmp-key used in the C3 algorithm. But the C3 algorithm expects that the items on the given lists (here: the list of all super categories) have distinct keys.\n> \n> One possible approach to solve that problem: The strict super-categories of a category with fixed base ring should *all* be categories with unspecified base rings. Hence, `Algebras(R)` should not have the super-categories `Rings()` and `Modules(R)`, but `Algebras(R.category())`.\n\nThis sounds reasonable. A variant would be, for a category over base\nring C, to set `C(R).parent_class` explicitly to\n`C(R.category()).parent_class`, bypassing the\n`_make_named_class_key` business since it won't really be needed\nanymore anyway (and similarly for the element class and so on).\n\nI'd say that we certainly want `Algebras(R)` to be a subcategory\nof `Modules(R)`, as tested by `is_subcategory`. But we could\nimagine doing like for joins, and *not* put `Modules(R)` in\n`Algebras(R).<all_>super_categories()`.\n\nIn fact, maybe `Algebras(R)` should really be a join category:\nthat of `Algebras(Fields()) & Modules(R)`.\n\n<ramble> Here Modules(R) would play a role similar to the category\nwith axiom `C().A()` associated to the category `C` defining\nthe axiom `A`. We would not have the option to define the analogue\nof a ``category with axioms`` for a subcategory, but at this point I\ndon't foresee a use for it either.</ramble>\n\nCheers,\n                               Nicolas",
    "created_at": "2014-02-10T13:11:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200793",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:3 SimonKing]:
> OK, that's the other possibility: Rather than having a separate mix-in category `FixedBaseRing(...)`, we would allow both `Algebras(Fields())` and `Algebras(QQ)`.
> 
> I have already done some experiments in that direction. We certainly want `Algebras(R.category())` among the super-categories of `Algebras(R)`. But if `C` is a category, do we want that `Algebras(D)` is among the super-categories of `Algebras(C)`, for all `D` in `C.super_categories()`?

> When I tried it yesterday, Nicolas' bounded C3 algorithm barked at me. Reason (if I recall correctly, I can't use my laptop right now): We want that `Algebras(QQ)` and `Algebras(QQ.category()` have the same parent and element classes, hence, `_make_named_class_key` returns the same, and thus they also share the cmp-key used in the C3 algorithm. But the C3 algorithm expects that the items on the given lists (here: the list of all super categories) have distinct keys.
> 
> One possible approach to solve that problem: The strict super-categories of a category with fixed base ring should *all* be categories with unspecified base rings. Hence, `Algebras(R)` should not have the super-categories `Rings()` and `Modules(R)`, but `Algebras(R.category())`.

This sounds reasonable. A variant would be, for a category over base
ring C, to set `C(R).parent_class` explicitly to
`C(R.category()).parent_class`, bypassing the
`_make_named_class_key` business since it won't really be needed
anymore anyway (and similarly for the element class and so on).

I'd say that we certainly want `Algebras(R)` to be a subcategory
of `Modules(R)`, as tested by `is_subcategory`. But we could
imagine doing like for joins, and *not* put `Modules(R)` in
`Algebras(R).<all_>super_categories()`.

In fact, maybe `Algebras(R)` should really be a join category:
that of `Algebras(Fields()) & Modules(R)`.

<ramble> Here Modules(R) would play a role similar to the category
with axiom `C().A()` associated to the category `C` defining
the axiom `A`. We would not have the option to define the analogue
of a ``category with axioms`` for a subcategory, but at this point I
don't foresee a use for it either.</ramble>

Cheers,
                               Nicolas



---

archive/issue_comments_200794.json:
```json
{
    "body": "We want to build on top of #10963, right?\n\nReplying to [comment:4 nthiery]:\n> > One possible approach to solve that problem: The strict super-categories of a category with fixed base ring should *all* be categories with unspecified base rings. Hence, `Algebras(R)` should not have the super-categories `Rings()` and `Modules(R)`, but `Algebras(R.category())`.\n> \n> This sounds reasonable. A variant would be, for a category over base\n> ring C, to set `C(R).parent_class` explicitly to\n> `C(R.category()).parent_class`, bypassing the\n> `_make_named_class_key` business since it won't really be needed\n> anymore anyway (and similarly for the element class and so on).\n\nI think `_make_named_class_key` would still be make sense: We need to distinguish the element and parent classes of `Algebras(Fields())` from `Algebras(Rings())`, but probably not from `Algebras(QuotientFields())`. And in particular (when following your suggestion below) we would still want that `Modules(GF(5))` and `Modules(GF(7))` have the same parent and element classes.\n \n> I'd say that we certainly want `Algebras(R)` to be a subcategory\n> of `Modules(R)`, as tested by `is_subcategory`. But we could\n> imagine doing like for joins, and *not* put `Modules(R)` in\n> `Algebras(R).<all_>super_categories()`.\n\nYes, but then one needs a category `FixedBase(R)` to be joined with! And I think that's not so nice, as pointed out in comment:1. Or so I thought. But:\n\n> In fact, maybe `Algebras(R)` should really be a join category:\n> that of `Algebras(Fields()) & Modules(R)`.\n\nHmmm. Yes, in that case one wouldn't need an ugly `FixedBase(R)` category...\n \n> <ramble> Here Modules(R) would play a role similar to the category\n> with axiom `C().A()` associated to the category `C` defining\n> the axiom `A`. We would not have the option to define the analogue\n> of a ``category with axioms`` for a subcategory, but at this point I\n> don't foresee a use for it either.</ramble>\n\nWell, that's what I commented on at #10963: I was playing with the idea of an axiom `WithFixedBase`, accepting an argument, but Volker has cut the argument short `;-)`.",
    "created_at": "2014-02-10T13:22:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200794",
    "user": "https://github.com/simon-king-jena"
}
```

We want to build on top of #10963, right?

Replying to [comment:4 nthiery]:
> > One possible approach to solve that problem: The strict super-categories of a category with fixed base ring should *all* be categories with unspecified base rings. Hence, `Algebras(R)` should not have the super-categories `Rings()` and `Modules(R)`, but `Algebras(R.category())`.
> 
> This sounds reasonable. A variant would be, for a category over base
> ring C, to set `C(R).parent_class` explicitly to
> `C(R.category()).parent_class`, bypassing the
> `_make_named_class_key` business since it won't really be needed
> anymore anyway (and similarly for the element class and so on).

I think `_make_named_class_key` would still be make sense: We need to distinguish the element and parent classes of `Algebras(Fields())` from `Algebras(Rings())`, but probably not from `Algebras(QuotientFields())`. And in particular (when following your suggestion below) we would still want that `Modules(GF(5))` and `Modules(GF(7))` have the same parent and element classes.
 
> I'd say that we certainly want `Algebras(R)` to be a subcategory
> of `Modules(R)`, as tested by `is_subcategory`. But we could
> imagine doing like for joins, and *not* put `Modules(R)` in
> `Algebras(R).<all_>super_categories()`.

Yes, but then one needs a category `FixedBase(R)` to be joined with! And I think that's not so nice, as pointed out in comment:1. Or so I thought. But:

> In fact, maybe `Algebras(R)` should really be a join category:
> that of `Algebras(Fields()) & Modules(R)`.

Hmmm. Yes, in that case one wouldn't need an ugly `FixedBase(R)` category...
 
> <ramble> Here Modules(R) would play a role similar to the category
> with axiom `C().A()` associated to the category `C` defining
> the axiom `A`. We would not have the option to define the analogue
> of a ``category with axioms`` for a subcategory, but at this point I
> don't foresee a use for it either.</ramble>

Well, that's what I commented on at #10963: I was playing with the idea of an axiom `WithFixedBase`, accepting an argument, but Volker has cut the argument short `;-)`.



---

archive/issue_comments_200795.json:
```json
{
    "body": "Replying to [comment:5 SimonKing]:\n> We want to build on top of #10963, right?\n\nDefinitely.\n\n> Replying to [comment:4 nthiery]:\n> I think `_make_named_class_key` would still be make sense: We need to distinguish the element and parent classes of `Algebras(Fields())` from `Algebras(Rings())`, but probably not from `Algebras(QuotientFields())`.\n\nThat would be for free if we make Algebras a functorial construction:\nif a category, say `QuotientFields()`, says nothing about algebras\nover itself, then `Algebras(QuotientFields())` will actually\nreturn `Algebras(Fields())`.\n\n> And in particular (when following your suggestion below) we would still want that `Modules(GF(5))` and `Modules(GF(7))` have the same parent and element classes.\n\nRight, if we go the join way, we will need to handle the base case of\nModules and have a make_named_class_key mechanism there.",
    "created_at": "2014-02-10T14:55:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200795",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:5 SimonKing]:
> We want to build on top of #10963, right?

Definitely.

> Replying to [comment:4 nthiery]:
> I think `_make_named_class_key` would still be make sense: We need to distinguish the element and parent classes of `Algebras(Fields())` from `Algebras(Rings())`, but probably not from `Algebras(QuotientFields())`.

That would be for free if we make Algebras a functorial construction:
if a category, say `QuotientFields()`, says nothing about algebras
over itself, then `Algebras(QuotientFields())` will actually
return `Algebras(Fields())`.

> And in particular (when following your suggestion below) we would still want that `Modules(GF(5))` and `Modules(GF(7))` have the same parent and element classes.

Right, if we go the join way, we will need to handle the base case of
Modules and have a make_named_class_key mechanism there.



---

archive/issue_comments_200796.json:
```json
{
    "body": "Just a little note. In [http://trac.sagemath.org/ticket/10963#comment:261](http://trac.sagemath.org/ticket/10963#comment:261) it was noted that base categories are referenced strongly by a global cache, and hence are prone to cause \"memory leaks\". This was rebutted there by noting that the number of categories created is uniformly bounded, so the memory use is manageable. This is clearly not true for these parametrized \"categories with fixed base\".\n\nThe work on this ticket will improve the situation, because categories parametrized by elements from an infinite set will be less often created, but it's worthwhile to try and think of what to do if they do get created. Perhaps we should really try and avoid them completely? Certainly the infrastructure requirements to support them is radically different, because such parametrized categories need to be deallocatable (I'm impressed that Firefox's spell checker accepts that word and not Firefox).",
    "created_at": "2014-02-10T18:38:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200796",
    "user": "https://github.com/nbruin"
}
```

Just a little note. In [http://trac.sagemath.org/ticket/10963#comment:261](http://trac.sagemath.org/ticket/10963#comment:261) it was noted that base categories are referenced strongly by a global cache, and hence are prone to cause "memory leaks". This was rebutted there by noting that the number of categories created is uniformly bounded, so the memory use is manageable. This is clearly not true for these parametrized "categories with fixed base".

The work on this ticket will improve the situation, because categories parametrized by elements from an infinite set will be less often created, but it's worthwhile to try and think of what to do if they do get created. Perhaps we should really try and avoid them completely? Certainly the infrastructure requirements to support them is radically different, because such parametrized categories need to be deallocatable (I'm impressed that Firefox's spell checker accepts that word and not Firefox).



---

archive/issue_comments_200797.json:
```json
{
    "body": "A simple test that detects some of the problems #10963 presently causes:\n\n```\nwhile True: k=random_matrix(Rationals(),30,20).echelon_form()\n```\n\nOn 6.2beta4 this happily runs with constant memory footprint and about constant time per iteration.\n\nWith #10963 applied, it gradually eats memory. The reason is that \"integers mod p\" and their categories pile up in memory. The iterations also take about twice as long and they slow down over time (as one would expect with memory use increasing).\n\n(see #13925 for why the choice of algorithm might not be so sensible, but it's a useful test for our purposes here)",
    "created_at": "2014-03-12T21:29:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200797",
    "user": "https://github.com/nbruin"
}
```

A simple test that detects some of the problems #10963 presently causes:

```
while True: k=random_matrix(Rationals(),30,20).echelon_form()
```

On 6.2beta4 this happily runs with constant memory footprint and about constant time per iteration.

With #10963 applied, it gradually eats memory. The reason is that "integers mod p" and their categories pile up in memory. The iterations also take about twice as long and they slow down over time (as one would expect with memory use increasing).

(see #13925 for why the choice of algorithm might not be so sensible, but it's a useful test for our purposes here)



---

archive/issue_comments_200798.json:
```json
{
    "body": "Hi!\n\nI started to work on this. We can now do:\n\n```\n    sage: Algebras(Fields())\n    Category of algebras over Category of fields\n```\n\n\n(TODO: would be nicer as Category of algebras over fields)\n\nand by default, polynomial rings are created in such categories:\n\n```\n    sage: QQ['x'].category()\n    Join of Category of euclidean domains and Category of commutative algebras over Category of quotient fields\n```\n\nAll tests pass in the sage/rings/polynomial.\n\n\nHere are the new timing for Simon's benchmark about creating lots of\npolynomial rings:\n\nWith Sage 5.0.1:\n\n```\nsage: %time test()\nCPU times: user 7.38 s, sys: 0.08 s, total: 7.46 s\nWall time: 7.48 s\n```\n\nWith develop (6.2.beta7):\n\n```\nsage: %time test()\nCPU times: user 9.31 s, sys: 125 ms, total: 9.44 s\nWall time: 9.47 s\n```\n\nWith #10963:\n\n```\nsage: %time test()\nCPU times: user 17.6 s, sys: 288 ms, total: 17.9 s\nWall time: 17.8 s\n```\n\nWith #10963 and this ticket:\n\n```\nsage: def test():\n....:     for p in prime_range(10000):\n....:         P = GF(p)['t','x','z']\nsage: %time test()\nCPU times: user 2.99 s, sys: 127 ms, total: 3.11 s\nWall time: 3.03 s\n```\n\n\nSounds like the time-performance issue for polynomials is indeed fixed for polynomials :-)\n\nNow, on to matrices!",
    "created_at": "2014-04-10T19:15:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200798",
    "user": "https://github.com/nthiery"
}
```

Hi!

I started to work on this. We can now do:

```
    sage: Algebras(Fields())
    Category of algebras over Category of fields
```


(TODO: would be nicer as Category of algebras over fields)

and by default, polynomial rings are created in such categories:

```
    sage: QQ['x'].category()
    Join of Category of euclidean domains and Category of commutative algebras over Category of quotient fields
```

All tests pass in the sage/rings/polynomial.


Here are the new timing for Simon's benchmark about creating lots of
polynomial rings:

With Sage 5.0.1:

```
sage: %time test()
CPU times: user 7.38 s, sys: 0.08 s, total: 7.46 s
Wall time: 7.48 s
```

With develop (6.2.beta7):

```
sage: %time test()
CPU times: user 9.31 s, sys: 125 ms, total: 9.44 s
Wall time: 9.47 s
```

With #10963:

```
sage: %time test()
CPU times: user 17.6 s, sys: 288 ms, total: 17.9 s
Wall time: 17.8 s
```

With #10963 and this ticket:

```
sage: def test():
....:     for p in prime_range(10000):
....:         P = GF(p)['t','x','z']
sage: %time test()
CPU times: user 2.99 s, sys: 127 ms, total: 3.11 s
Wall time: 3.03 s
```


Sounds like the time-performance issue for polynomials is indeed fixed for polynomials :-)

Now, on to matrices!



---

archive/issue_comments_200799.json:
```json
{
    "body": "Replying to [comment:9 nbruin]:\n> A simple test that detects some of the problems #10963 presently causes:\n> {{{\n> while True: k=random_matrix(Rationals(),30,20).echelon_form()\n> }}}\n> On 6.2beta4 this happily runs with constant memory footprint and about constant time per iteration.\n> \n> With #10963 applied, it gradually eats memory. The reason is that \"integers mod p\" and their categories pile up in memory. The iterations also take about twice as long and they slow down over time (as one would expect with memory use increasing).\n> \n> (see #13925 for why the choice of algorithm might not be so sensible, but it's a useful test for our purposes here)\n\nFor the record: I just checked, and with the current version of this\nticket on top of #10963, this runs with constant memory footprint and\nabout constant time per iteration.\n\nCheers,\n                           Nicolas\n----\nLast 10 new commits:",
    "created_at": "2014-04-14T20:18:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200799",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:9 nbruin]:
> A simple test that detects some of the problems #10963 presently causes:
> {{{
> while True: k=random_matrix(Rationals(),30,20).echelon_form()
> }}}
> On 6.2beta4 this happily runs with constant memory footprint and about constant time per iteration.
> 
> With #10963 applied, it gradually eats memory. The reason is that "integers mod p" and their categories pile up in memory. The iterations also take about twice as long and they slow down over time (as one would expect with memory use increasing).
> 
> (see #13925 for why the choice of algorithm might not be so sensible, but it's a useful test for our purposes here)

For the record: I just checked, and with the current version of this
ticket on top of #10963, this runs with constant memory footprint and
about constant time per iteration.

Cheers,
                           Nicolas
----
Last 10 new commits:



---

archive/issue_comments_200800.json:
```json
{
    "body": "Replying to [nbruin](http://trac.sagemath.org/ticket/10963#comment:571):\n> There are some performance and leaking issues with the proposed code here. They\n> have been mentioned before, but they got swamped in more theoretical design\n> discussions. Consider for instance with sage 6.2.beta4:\n>\n> ...\n>\n> As you can see, much slower execution and much leakier behaviour (even without\n> the patch this kind of stuff is very liable to leak but as you can see, this\n> patch makes it much worse). Note that we have to sort types by their string\n> representation, because for each of these `..._with_category` types, the 5000 instances are in fact unique types with identical print names. So the memory load is even higher (types are fairly heavy data structures). As you can see, categories are eternal (they get cached) and since they store a reference to their base, they nail the base ring in memory too. We'll have to merge this ticket together with a ticket that moves base ring references out of the categories, since the constructions introduced in this ticket make the problem urgent.\n\nFor the record, here is what I currently get on my machine:\n\nWith this ticket applied on top of #10963:\n\n```\nsage: import gc\nsage: from collections import Counter\nsage: before={id(c) for c in gc.get_objects()}\nsage: %time for n in [1..5000]: x=(matrix(Integers(n),2,2,1))\nCPU times: user 3.83 s, sys: 41.2 ms, total: 3.87 s\nWall time: 3.84 s\nsage: sage: gc.collect()\n17047\nsage: sage: gc.collect()\n864\nsage: sage: after=[c for c in gc.get_objects() if id(c) not in before]\nsage: sage: [c for c in Counter([str(type(a)) for a in after]).items() if c[1] > 4000]\n[]\n```\n\nSame, without systematic full category initialization for matrices:\n\n```\nCPU times: user 3.49 s, sys: 52.8 ms, total: 3.54 s\nWall time: 3.49 s\nsage: sage: sage: sage: gc.collect()\n18836\nsage: sage: sage: sage: gc.collect()\n1344\n```\n\n\nWith vanilla 6.2.beta6 (no systematic full category initialization for matrices):\n\n```\nCPU times: user 2.89 s, sys: 33.6 ms, total: 2.92 s\nWall time: 2.88 s\nsage: sage: sage: gc.collect()\n5032\nsage: sage: sage: gc.collect()\n704\n```\n\n\nHence #15801 as is seems to be going a long way toward fixing this\nissue. It's still non negligibly slower than develop on this very\ntight loop (and apparently more objects get\nallocated/deallocated). But in exchange we are back to systematic full\ncategory initialization which I believe is much nicer to the user.\n\nWhat do you think?\n\nOn to the elliptic curve benchmarks.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-04-14T20:57:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200800",
    "user": "https://github.com/nthiery"
}
```

Replying to [nbruin](http://trac.sagemath.org/ticket/10963#comment:571):
> There are some performance and leaking issues with the proposed code here. They
> have been mentioned before, but they got swamped in more theoretical design
> discussions. Consider for instance with sage 6.2.beta4:
>
> ...
>
> As you can see, much slower execution and much leakier behaviour (even without
> the patch this kind of stuff is very liable to leak but as you can see, this
> patch makes it much worse). Note that we have to sort types by their string
> representation, because for each of these `..._with_category` types, the 5000 instances are in fact unique types with identical print names. So the memory load is even higher (types are fairly heavy data structures). As you can see, categories are eternal (they get cached) and since they store a reference to their base, they nail the base ring in memory too. We'll have to merge this ticket together with a ticket that moves base ring references out of the categories, since the constructions introduced in this ticket make the problem urgent.

For the record, here is what I currently get on my machine:

With this ticket applied on top of #10963:

```
sage: import gc
sage: from collections import Counter
sage: before={id(c) for c in gc.get_objects()}
sage: %time for n in [1..5000]: x=(matrix(Integers(n),2,2,1))
CPU times: user 3.83 s, sys: 41.2 ms, total: 3.87 s
Wall time: 3.84 s
sage: sage: gc.collect()
17047
sage: sage: gc.collect()
864
sage: sage: after=[c for c in gc.get_objects() if id(c) not in before]
sage: sage: [c for c in Counter([str(type(a)) for a in after]).items() if c[1] > 4000]
[]
```

Same, without systematic full category initialization for matrices:

```
CPU times: user 3.49 s, sys: 52.8 ms, total: 3.54 s
Wall time: 3.49 s
sage: sage: sage: sage: gc.collect()
18836
sage: sage: sage: sage: gc.collect()
1344
```


With vanilla 6.2.beta6 (no systematic full category initialization for matrices):

```
CPU times: user 2.89 s, sys: 33.6 ms, total: 2.92 s
Wall time: 2.88 s
sage: sage: sage: gc.collect()
5032
sage: sage: sage: gc.collect()
704
```


Hence #15801 as is seems to be going a long way toward fixing this
issue. It's still non negligibly slower than develop on this very
tight loop (and apparently more objects get
allocated/deallocated). But in exchange we are back to systematic full
category initialization which I believe is much nicer to the user.

What do you think?

On to the elliptic curve benchmarks.

Cheers,
                              Nicolas



---

archive/issue_comments_200801.json:
```json
{
    "body": "On the benchmark from #11900, I get significantly the same timing with develop and #10963+#15801:\n\n```\nsage: E = J0(46).endomorphism_ring()\nsage: %time g = E.gens()\nCPU times: user 3.63 s, sys: 94.9 ms, total: 3.73 s\nWall time: 3.90 s    #develop     \nWall time: 3.98 s    #10963\nWall time: 3.86 s    #10963+#15801   \n```\n\nThis, despite the additional full category initialization.",
    "created_at": "2014-04-14T21:16:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200801",
    "user": "https://github.com/nthiery"
}
```

On the benchmark from #11900, I get significantly the same timing with develop and #10963+#15801:

```
sage: E = J0(46).endomorphism_ring()
sage: %time g = E.gens()
CPU times: user 3.63 s, sys: 94.9 ms, total: 3.73 s
Wall time: 3.90 s    #develop     
Wall time: 3.98 s    #10963
Wall time: 3.86 s    #10963+#15801   
```

This, despite the additional full category initialization.



---

archive/issue_comments_200802.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-04-14T21:38:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200802",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_200803.json:
```json
{
    "body": "Up to merging in #15919, it's likely that all long test will pass. Running them now.",
    "created_at": "2014-04-14T21:40:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200803",
    "user": "https://github.com/nthiery"
}
```

Up to merging in #15919, it's likely that all long test will pass. Running them now.



---

archive/issue_comments_200804.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-14T21:44:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200804",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200805.json:
```json
{
    "body": "So `Algebras(Rings())` would cover any algebra (well...any assoc & unital algebra)?\n\nAlso I think we should not loose support for having the category of algebras over a fixed base ring. For example, given two representations `V`, `W` of a group algebra `RG` over `R`, the morphisms from `V` to `W` as `RG`-modules is (significantly) smaller than the morphisms as `R`-modules. Currently our set of morphisms depends on the category, which if we keep the current setup, would give that `Hom(V, W, Modules(RG)) is Hom(V, W, Modules(R))` (well, maybe only `==`).\n\nActually...`RG` would be the category of group algebras whereas `R` would be in the category of rings, unless `R` was also the group algebra of some other group (okay, it's very contrived, but possible). My point is that just passing the category into `Modules` doesn't always tell us the full structure (of the homset), and is there some way we can work around this?",
    "created_at": "2014-04-15T15:32:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200805",
    "user": "https://github.com/tscrim"
}
```

So `Algebras(Rings())` would cover any algebra (well...any assoc & unital algebra)?

Also I think we should not loose support for having the category of algebras over a fixed base ring. For example, given two representations `V`, `W` of a group algebra `RG` over `R`, the morphisms from `V` to `W` as `RG`-modules is (significantly) smaller than the morphisms as `R`-modules. Currently our set of morphisms depends on the category, which if we keep the current setup, would give that `Hom(V, W, Modules(RG)) is Hom(V, W, Modules(R))` (well, maybe only `==`).

Actually...`RG` would be the category of group algebras whereas `R` would be in the category of rings, unless `R` was also the group algebra of some other group (okay, it's very contrived, but possible). My point is that just passing the category into `Modules` doesn't always tell us the full structure (of the homset), and is there some way we can work around this?



---

archive/issue_comments_200806.json:
```json
{
    "body": "Replying to [comment:19 tscrim]:\n> So `Algebras(Rings())` would cover any algebra (well...any assoc & unital algebra)?\n\nYup. And at some point we will want weaker things like `Algebras(SemiRings())` and so on.\n\n> Also I think we should not loose support for having the category of algebras over a fixed base ring.\n\nI agree with that, though more if we want to manipulate the category\n\"mathematically\". From a code perspective point of view, since #11900,\nthe provided abstract classes only depends on the category of the base\nring, and this has not been a limitation so far.\n\n> For example, given two representations `V`, `W` of a group algebra `RG` over `R`, the morphisms from `V` to `W` as `RG`-modules is (significantly) smaller than the morphisms as `R`-modules. Currently our set of morphisms depends on the category, which if we keep the current setup, would give that `Hom(V, W, Modules(RG)) is Hom(V, W, Modules(R))` (well, maybe only `==`).\n> \n> Actually...`RG` would be the category of group algebras whereas `R` would be in the category of rings, unless `R` was also the group algebra of some other group (okay, it's very contrived, but possible). My point is that just passing the category into `Modules` doesn't always tell us the full structure (of the homset), and is there some way we can work around this?\n\nWell, as you say, we have two distinct categories:\n\n```\n    sage: Modules(Rings())\n\n    sage: Modules(GroupAlgebras(Rings()))\n\n```\n\nso we are fine, aren't we?\n\nCheers,\n                                          Nicolas",
    "created_at": "2014-04-18T13:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200806",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:19 tscrim]:
> So `Algebras(Rings())` would cover any algebra (well...any assoc & unital algebra)?

Yup. And at some point we will want weaker things like `Algebras(SemiRings())` and so on.

> Also I think we should not loose support for having the category of algebras over a fixed base ring.

I agree with that, though more if we want to manipulate the category
"mathematically". From a code perspective point of view, since #11900,
the provided abstract classes only depends on the category of the base
ring, and this has not been a limitation so far.

> For example, given two representations `V`, `W` of a group algebra `RG` over `R`, the morphisms from `V` to `W` as `RG`-modules is (significantly) smaller than the morphisms as `R`-modules. Currently our set of morphisms depends on the category, which if we keep the current setup, would give that `Hom(V, W, Modules(RG)) is Hom(V, W, Modules(R))` (well, maybe only `==`).
> 
> Actually...`RG` would be the category of group algebras whereas `R` would be in the category of rings, unless `R` was also the group algebra of some other group (okay, it's very contrived, but possible). My point is that just passing the category into `Modules` doesn't always tell us the full structure (of the homset), and is there some way we can work around this?

Well, as you say, we have two distinct categories:

```
    sage: Modules(Rings())

    sage: Modules(GroupAlgebras(Rings()))

```

so we are fine, aren't we?

Cheers,
                                          Nicolas



---

archive/issue_comments_200807.json:
```json
{
    "body": "Until I make a group ring over a group ring. Actually, maybe a less contrived example of modules over `S = R[a,b] / J` where `R = ZZ[x,y] / I` for some ideals `I, J`. There should be more morphisms as `R` modules than as `S` modules. I think this could be a general issue anytime we try to do extension of scalars (or I'm being completely paranoid).",
    "created_at": "2014-04-18T14:27:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200807",
    "user": "https://github.com/tscrim"
}
```

Until I make a group ring over a group ring. Actually, maybe a less contrived example of modules over `S = R[a,b] / J` where `R = ZZ[x,y] / I` for some ideals `I, J`. There should be more morphisms as `R` modules than as `S` modules. I think this could be a general issue anytime we try to do extension of scalars (or I'm being completely paranoid).



---

archive/issue_comments_200808.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-18T15:55:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200808",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200809.json:
```json
{
    "body": "Replying to [comment:21 tscrim]:\n> Until I make a group ring over a group ring.\n\nWhat about:\n\n```\n    Modules(Groups().Algebras(Groups().Algebras()))\n```\n\n\n> Actually, maybe a less contrived example of modules over `S = R[a,b] / J` where `R = ZZ[x,y] / I` for some ideals `I, J`. There should be more morphisms as `R` modules than as `S` modules. I think this could be a general issue anytime we try to do extension of scalars (or I'm being completely paranoid).\n\nOne thing is that each module M in Sage has a distinguished \"base ring\".\n<digression>\nIn particular, M can't be in `Modules(R)` and in `Modules(S)`\nsimultaneously; this can be seen as a limitation of the current\ncategory framework; no other CAS found a good solution to that\nthough\n</digression>\n\nSo, if I have two modules M and N, Hom(M,N) actually depends on this\ndistinguished base ring (they should have the same!).\n\nIf I build M and N as R-modules, and M' and N' as S-modules, the fact\nthat they all belong to the same category only means that the code to\nhandle and compute the homsets will be the same, not that the homsets\nHom(M,N) and Hom(M',N') themselves will be the same.\n\nCheers,\n                             Nicolas",
    "created_at": "2014-04-18T16:15:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200809",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:21 tscrim]:
> Until I make a group ring over a group ring.

What about:

```
    Modules(Groups().Algebras(Groups().Algebras()))
```


> Actually, maybe a less contrived example of modules over `S = R[a,b] / J` where `R = ZZ[x,y] / I` for some ideals `I, J`. There should be more morphisms as `R` modules than as `S` modules. I think this could be a general issue anytime we try to do extension of scalars (or I'm being completely paranoid).

One thing is that each module M in Sage has a distinguished "base ring".
<digression>
In particular, M can't be in `Modules(R)` and in `Modules(S)`
simultaneously; this can be seen as a limitation of the current
category framework; no other CAS found a good solution to that
though
</digression>

So, if I have two modules M and N, Hom(M,N) actually depends on this
distinguished base ring (they should have the same!).

If I build M and N as R-modules, and M' and N' as S-modules, the fact
that they all belong to the same category only means that the code to
handle and compute the homsets will be the same, not that the homsets
Hom(M,N) and Hom(M',N') themselves will be the same.

Cheers,
                             Nicolas



---

archive/issue_comments_200810.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-04-21T16:50:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200810",
    "user": "https://github.com/nthiery"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_200811.json:
```json
{
    "body": "Replying to [comment:23 nthiery]:\n\nOkay, I'm happy as long as we're getting things like this:\n> {{{\n>    Modules(Groups().Algebras(Groups().Algebras()))\n> }}}\nfor things like `(QQ[G])[H]` where `G,H` are groups.\n\n\n> One thing is that each module M in Sage has a distinguished \"base ring\".\n> <digression>\n> In particular, M can't be in `Modules(R)` and in `Modules(S)`\n> simultaneously; this can be seen as a limitation of the current\n> category framework; no other CAS found a good solution to that\n> though\n> </digression>\n\n<digressing as well>This might improve as (if) we implement coercions between categories.</digressing as well>\n\n> So, if I have two modules M and N, Hom(M,N) actually depends on this\n> distinguished base ring (they should have the same!).\n> \n> If I build M and N as R-modules, and M' and N' as S-modules, the fact\n> that they all belong to the same category only means that the code to\n> handle and compute the homsets will be the same, not that the homsets\n> Hom(M,N) and Hom(M',N') themselves will be the same.\n\nAh, I see. You *must* construct new modules M' and N' in order to consider morphisms as S-modules. I'm good with everything (conceptually).\n\nSimon, Nils, (or anyone else,) did either of you verify Nicolas' above (or have any objections)?",
    "created_at": "2014-04-22T18:46:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200811",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:23 nthiery]:

Okay, I'm happy as long as we're getting things like this:
> {{{
>    Modules(Groups().Algebras(Groups().Algebras()))
> }}}
for things like `(QQ[G])[H]` where `G,H` are groups.


> One thing is that each module M in Sage has a distinguished "base ring".
> <digression>
> In particular, M can't be in `Modules(R)` and in `Modules(S)`
> simultaneously; this can be seen as a limitation of the current
> category framework; no other CAS found a good solution to that
> though
> </digression>

<digressing as well>This might improve as (if) we implement coercions between categories.</digressing as well>

> So, if I have two modules M and N, Hom(M,N) actually depends on this
> distinguished base ring (they should have the same!).
> 
> If I build M and N as R-modules, and M' and N' as S-modules, the fact
> that they all belong to the same category only means that the code to
> handle and compute the homsets will be the same, not that the homsets
> Hom(M,N) and Hom(M',N') themselves will be the same.

Ah, I see. You *must* construct new modules M' and N' in order to consider morphisms as S-modules. I'm good with everything (conceptually).

Simon, Nils, (or anyone else,) did either of you verify Nicolas' above (or have any objections)?



---

archive/issue_comments_200812.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-24T09:56:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200812",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200813.json:
```json
{
    "body": "Replying to [comment:25 tscrim]:\n> Replying to [comment:23 nthiery]:\n> Okay, I'm happy as long as we're getting things like this:\n> > {{{\n> >    Modules(Groups().Algebras(Groups().Algebras()))\n> > }}}\n> for things like `(QQ[G])[H]` where `G,H` are groups.\n\nFor now the group algebra construction still uses categories over base\nrings. But yes, that's what would happen otherwise.\n\nThanks for the feedback!",
    "created_at": "2014-04-24T10:17:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200813",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:25 tscrim]:
> Replying to [comment:23 nthiery]:
> Okay, I'm happy as long as we're getting things like this:
> > {{{
> >    Modules(Groups().Algebras(Groups().Algebras()))
> > }}}
> for things like `(QQ[G])[H]` where `G,H` are groups.

For now the group algebra construction still uses categories over base
rings. But yes, that's what would happen otherwise.

Thanks for the feedback!



---

archive/issue_comments_200814.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-04-26T06:31:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200814",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_200815.json:
```json
{
    "body": "I've merged in the latest #10963, made some misc doctweaks (added some doctests to/near functions were editing), fixed an issue with `Sets.Algebras` not taking a category (so `GroupAlgebras(Rings())` used to fail). If you're happy with my changes, then I think this part is a positive review.",
    "created_at": "2014-04-26T06:32:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200815",
    "user": "https://github.com/tscrim"
}
```

I've merged in the latest #10963, made some misc doctweaks (added some doctests to/near functions were editing), fixed an issue with `Sets.Algebras` not taking a category (so `GroupAlgebras(Rings())` used to fail). If you're happy with my changes, then I think this part is a positive review.



---

archive/issue_comments_200816.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-04-26T16:09:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200816",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200817.json:
```json
{
    "body": "Replying to [comment:29 tscrim]:\n> I've merged in the latest #10963, made some misc doctweaks (added some doctests to/near functions were editing), fixed an issue with `Sets.Algebras` not taking a category (so `GroupAlgebras(Rings())` used to fail). If you're happy with my changes, then I think this part is a positive review.\n\nCool, thanks! Please proofread my proofreading :-)\n\nI have merged the latest #10963 since I was not sure it would not conflict with my changes.\n\nRunning all doctests now with the little tweak from #15919.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-04-26T16:11:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200817",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:29 tscrim]:
> I've merged in the latest #10963, made some misc doctweaks (added some doctests to/near functions were editing), fixed an issue with `Sets.Algebras` not taking a category (so `GroupAlgebras(Rings())` used to fail). If you're happy with my changes, then I think this part is a positive review.

Cool, thanks! Please proofread my proofreading :-)

I have merged the latest #10963 since I was not sure it would not conflict with my changes.

Running all doctests now with the little tweak from #15919.

Cheers,
                              Nicolas



---

archive/issue_comments_200818.json:
```json
{
    "body": "If all doctests pass for you, then positive review for this.",
    "created_at": "2014-04-26T16:50:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200818",
    "user": "https://github.com/tscrim"
}
```

If all doctests pass for you, then positive review for this.



---

archive/issue_comments_200819.json:
```json
{
    "body": "Shoot, there is one failing doctest which I somehow missed. Some Homset is missing a base_ring method which causes it not to be detected properly as being in its category. I'll try to fix this tomorrow or so.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-04-26T21:56:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200819",
    "user": "https://github.com/nthiery"
}
```

Shoot, there is one failing doctest which I somehow missed. Some Homset is missing a base_ring method which causes it not to be detected properly as being in its category. I'll try to fix this tomorrow or so.

Cheers,
                              Nicolas



---

archive/issue_comments_200820.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-04-26T21:56:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200820",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_200821.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-05-01T16:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200821",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_200822.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-05-01T16:48:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200822",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_200823.json:
```json
{
    "body": "I've fixed it by implementing a `_Hom_()` for `Modules` (see commit ac91ed0). This might be more of a hack solution, but it works.",
    "created_at": "2014-05-01T16:48:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200823",
    "user": "https://github.com/tscrim"
}
```

I've fixed it by implementing a `_Hom_()` for `Modules` (see commit ac91ed0). This might be more of a hack solution, but it works.



---

archive/issue_comments_200824.json:
```json
{
    "body": "Ah, yes, that could one way to handle it. Thanks!\n\nSorry for the silence. I have been toying with a variant of it,\nputting a similar test in the Homset constructor. I don't know which\none is best. Yours is more local context-wise (it only affects\nmodules); mine is more local code wise.\n\nHowever while doing this I stumbled on another issue, which is that\nnow `X in category` is not necessarily equivalent to\n`X.category().is_subcategory(category)`. This is ok theoretically,\nbut there is at least one spot in the code, namely in Hom, where this\nhas to be fixed, which in turn opens a can of pickling worms.\nHopefully I'll have a proposal later tonight.\n\nCheers,\n                            Nicolas",
    "created_at": "2014-05-01T20:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200824",
    "user": "https://github.com/nthiery"
}
```

Ah, yes, that could one way to handle it. Thanks!

Sorry for the silence. I have been toying with a variant of it,
putting a similar test in the Homset constructor. I don't know which
one is best. Yours is more local context-wise (it only affects
modules); mine is more local code wise.

However while doing this I stumbled on another issue, which is that
now `X in category` is not necessarily equivalent to
`X.category().is_subcategory(category)`. This is ok theoretically,
but there is at least one spot in the code, namely in Hom, where this
has to be fixed, which in turn opens a can of pickling worms.
Hopefully I'll have a proposal later tonight.

Cheers,
                            Nicolas



---

archive/issue_comments_200825.json:
```json
{
    "body": "I pushed my proposal to #16275.\n\nThanks to the use of ``X in category`` for sanity checks in Hom, we\ncan still handle things like:\n\n\n```\n    Hom(ZZ['x'], ZZ['x'], Modules(ZZ))\n```\n\n\neven if ``ZZ['x']`` is now in the category of ``Modules(Rings())``\n(which is not a subcategory of ``Modules(ZZ)``).\n\nI'll work tomorrow on double checking everything once #16275 is merged\nin this ticket. I might end up preferring my hack rather than the\n_Hom_ hack, because the whole _Hom_ protocol is not quite\nsatisfactory, and I'd rather avoid it when we can.\n\nWhat do you think?",
    "created_at": "2014-05-01T23:05:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200825",
    "user": "https://github.com/nthiery"
}
```

I pushed my proposal to #16275.

Thanks to the use of ``X in category`` for sanity checks in Hom, we
can still handle things like:


```
    Hom(ZZ['x'], ZZ['x'], Modules(ZZ))
```


even if ``ZZ['x']`` is now in the category of ``Modules(Rings())``
(which is not a subcategory of ``Modules(ZZ)``).

I'll work tomorrow on double checking everything once #16275 is merged
in this ticket. I might end up preferring my hack rather than the
_Hom_ hack, because the whole _Hom_ protocol is not quite
satisfactory, and I'd rather avoid it when we can.

What do you think?



---

archive/issue_comments_200826.json:
```json
{
    "body": "I think we should leave my `_Hom_` hack in because the homset is a module (when the codomain is a module as well) and at least we're somewhat demonstrating that when specifying that the homset has a base ring (through the `Parent.__init__`). So I'd say my `_Hom_` and #16275 should coexist in the final version.",
    "created_at": "2014-05-02T07:06:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200826",
    "user": "https://github.com/tscrim"
}
```

I think we should leave my `_Hom_` hack in because the homset is a module (when the codomain is a module as well) and at least we're somewhat demonstrating that when specifying that the homset has a base ring (through the `Parent.__init__`). So I'd say my `_Hom_` and #16275 should coexist in the final version.



---

archive/issue_comments_200827.json:
```json
{
    "body": "Replying to [comment:38 tscrim]:\n> I think we should leave my `_Hom_` hack in because the homset is a module (when the codomain is a module as well) and at least we're somewhat demonstrating that when specifying that the homset has a base ring (through the `Parent.__init__`). So I'd say my `_Hom_` and #16275 should coexist in the final version.\n\nSorry, I was unclear. Yes, we definitely need some Hom hack to setup base_ring properly by passing it to __init__. My question is just whether this hack belongs to a custom `_Hom_` method as you did or to `Homset.__init__` as in my (yet unpushed) branch.",
    "created_at": "2014-05-02T09:01:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200827",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:38 tscrim]:
> I think we should leave my `_Hom_` hack in because the homset is a module (when the codomain is a module as well) and at least we're somewhat demonstrating that when specifying that the homset has a base ring (through the `Parent.__init__`). So I'd say my `_Hom_` and #16275 should coexist in the final version.

Sorry, I was unclear. Yes, we definitely need some Hom hack to setup base_ring properly by passing it to __init__. My question is just whether this hack belongs to a custom `_Hom_` method as you did or to `Homset.__init__` as in my (yet unpushed) branch.



---

archive/issue_comments_200828.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:",
    "created_at": "2014-05-02T15:47:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200828",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:



---

archive/issue_comments_200829.json:
```json
{
    "body": "I just pushed my branch. Hmm, that was a bit bruteforce, sorry: I should probably have pushed it under a different name since it does not include your change ac91ed0.\n\nSee 54c3d67 for the alternative I propose; does it sound ok?\n----\nLast 10 new commits:",
    "created_at": "2014-05-02T15:51:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200829",
    "user": "https://github.com/nthiery"
}
```

I just pushed my branch. Hmm, that was a bit bruteforce, sorry: I should probably have pushed it under a different name since it does not include your change ac91ed0.

See 54c3d67 for the alternative I propose; does it sound ok?
----
Last 10 new commits:



---

archive/issue_comments_200830.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-03T19:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200830",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_200831.json:
```json
{
    "body": "Your proposal will work since any category with has a `WithBasis` should have a forgetful functor to modules.",
    "created_at": "2014-05-03T19:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200831",
    "user": "https://github.com/tscrim"
}
```

Your proposal will work since any category with has a `WithBasis` should have a forgetful functor to modules.



---

archive/issue_comments_200832.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:",
    "created_at": "2014-05-10T22:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200832",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:



---

archive/issue_comments_200833.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2014-05-10T22:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200833",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_200834.json:
```json
{
    "body": "Rebased over rebased #10963.",
    "created_at": "2014-05-10T22:19:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200834",
    "user": "https://github.com/tscrim"
}
```

Rebased over rebased #10963.



---

archive/issue_comments_200835.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-10T22:34:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200835",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_200836.json:
```json
{
    "body": "I get lots of doctest failuers, e..g `NotImplementedError: Pieri factors for type ['A', 3, 1]`. Might be this ticket or #10963. On top of 6.3.beta0.",
    "created_at": "2014-05-12T09:25:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200836",
    "user": "https://github.com/vbraun"
}
```

I get lots of doctest failuers, e..g `NotImplementedError: Pieri factors for type ['A', 3, 1]`. Might be this ticket or #10963. On top of 6.3.beta0.



---

archive/issue_comments_200837.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-05-12T09:25:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200837",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_200838.json:
```json
{
    "body": "Is this with #14102 applied? Could this be due to the import statement that was accidently removed and then reinserted in \u200b1579b88. See http://trac.sagemath.org/ticket/14102#comment:72.\n\nCheers,\n                      Nicolas",
    "created_at": "2014-05-12T10:20:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200838",
    "user": "https://github.com/nthiery"
}
```

Is this with #14102 applied? Could this be due to the import statement that was accidently removed and then reinserted in 1579b88. See http://trac.sagemath.org/ticket/14102#comment:72.

Cheers,
                      Nicolas



---

archive/issue_comments_200839.json:
```json
{
    "body": "No, #14102 wasn't applied since it depends on this ticket.",
    "created_at": "2014-05-12T10:36:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200839",
    "user": "https://github.com/vbraun"
}
```

No, #14102 wasn't applied since it depends on this ticket.



---

archive/issue_comments_200840.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-12T11:52:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200840",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200841.json:
```json
{
    "body": "Ah, I see: the accidental removal of `import` occured in this branch (commit 41768a3), and was reverted in the followup branch #14102 (commit \u200b1579b88). I cherry-picked back 1579b88 to this branch. This should work now. Running the tests.\n\nThanks for your report!\n\nCheers,\n                                Nicolas",
    "created_at": "2014-05-12T11:56:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200841",
    "user": "https://github.com/nthiery"
}
```

Ah, I see: the accidental removal of `import` occured in this branch (commit 41768a3), and was reverted in the followup branch #14102 (commit 1579b88). I cherry-picked back 1579b88 to this branch. This should work now. Running the tests.

Thanks for your report!

Cheers,
                                Nicolas



---

archive/issue_comments_200842.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2014-05-12T11:57:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200842",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_200843.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-05-12T12:59:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200843",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_200844.json:
```json
{
    "body": "`make doc-pdf` fails (probably due to #10963)",
    "created_at": "2014-05-12T12:59:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200844",
    "user": "https://github.com/vbraun"
}
```

`make doc-pdf` fails (probably due to #10963)



---

archive/issue_comments_200845.json:
```json
{
    "body": "Also\n\n```\nsage -t --long src/sage/quivers/path_semigroup.py  # 1 doctest failed\nsage -t --long src/sage/quivers/representation.py  # 6 doctests failed\n```\n",
    "created_at": "2014-05-12T13:27:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200845",
    "user": "https://github.com/vbraun"
}
```

Also

```
sage -t --long src/sage/quivers/path_semigroup.py  # 1 doctest failed
sage -t --long src/sage/quivers/representation.py  # 6 doctests failed
```




---

archive/issue_comments_200846.json:
```json
{
    "body": "Replying to [comment:54 vbraun]:\n> Also\n> {{{\n> sage -t --long src/sage/quivers/path_semigroup.py  # 1 doctest failed\n> sage -t --long src/sage/quivers/representation.py  # 6 doctests failed\n> }}}\n\nIndeed, I just found out about this integration failure with #12630, and posted a question there:\n\nhttp://trac.sagemath.org/ticket/12630#comment:270",
    "created_at": "2014-05-12T13:41:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200846",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:54 vbraun]:
> Also
> {{{
> sage -t --long src/sage/quivers/path_semigroup.py  # 1 doctest failed
> sage -t --long src/sage/quivers/representation.py  # 6 doctests failed
> }}}

Indeed, I just found out about this integration failure with #12630, and posted a question there:

http://trac.sagemath.org/ticket/12630#comment:270



---

archive/issue_comments_200847.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-12T14:44:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200847",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200848.json:
```json
{
    "body": "Pdf compilation fixed in #10963 and merged here.",
    "created_at": "2014-05-12T14:48:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200848",
    "user": "https://github.com/nthiery"
}
```

Pdf compilation fixed in #10963 and merged here.



---

archive/issue_comments_200849.json:
```json
{
    "body": "I think the quiver issue should be discussed here.\n\nNicolas, do you agree with Darij that quiver representations over QQ should live in `Modules(QQ)`, not in `Modules(QuiverAlgebra)`? If this is so, then hopefully it will be easy to switch.",
    "created_at": "2014-05-12T15:51:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200849",
    "user": "https://github.com/simon-king-jena"
}
```

I think the quiver issue should be discussed here.

Nicolas, do you agree with Darij that quiver representations over QQ should live in `Modules(QQ)`, not in `Modules(QuiverAlgebra)`? If this is so, then hopefully it will be easy to switch.



---

archive/issue_comments_200850.json:
```json
{
    "body": "Replying to [comment:58 SimonKing]:\n> I think the quiver issue should be discussed here.\n\nOk.\n\n> Nicolas, do you agree with Darij that quiver representations over QQ should live in `Modules(QQ)`, not in `Modules(QuiverAlgebra)`? If this is so, then hopefully it will be easy to switch.\n\nNo strong opinion either way, but yes, I would lean in this direction\nsince we don't have yet a proper category hierarchy for\nrepresentations. So in the mean time, it makes sense to reserve\n`Modules(K)` for what we have used it so far: doing linear algebra\nover K, ...\n\nIf it makes it easier to switch, so much the better :-)\n\nCheers,\n                              Nicolas",
    "created_at": "2014-05-12T15:59:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200850",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:58 SimonKing]:
> I think the quiver issue should be discussed here.

Ok.

> Nicolas, do you agree with Darij that quiver representations over QQ should live in `Modules(QQ)`, not in `Modules(QuiverAlgebra)`? If this is so, then hopefully it will be easy to switch.

No strong opinion either way, but yes, I would lean in this direction
since we don't have yet a proper category hierarchy for
representations. So in the mean time, it makes sense to reserve
`Modules(K)` for what we have used it so far: doing linear algebra
over K, ...

If it makes it easier to switch, so much the better :-)

Cheers,
                              Nicolas



---

archive/issue_comments_200851.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-13T13:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200851",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_200852.json:
```json
{
    "body": "Replying to [comment:58 SimonKing]:\n> Nicolas, do you agree with Darij that quiver representations over QQ should live in `Modules(QQ)`, not in `Modules(QuiverAlgebra)`? If this is so, then hopefully it will be easy to switch.\n\nDone. Please review! Running all long tests now.",
    "created_at": "2014-05-13T13:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200852",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:58 SimonKing]:
> Nicolas, do you agree with Darij that quiver representations over QQ should live in `Modules(QQ)`, not in `Modules(QuiverAlgebra)`? If this is so, then hopefully it will be easy to switch.

Done. Please review! Running all long tests now.



---

archive/issue_comments_200853.json:
```json
{
    "body": "Sorry for my being too slow. I wanted to try and fix it, but was busy with some other tickets. Thank you for doing it, and I'll now try to review.",
    "created_at": "2014-05-13T14:03:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200853",
    "user": "https://github.com/simon-king-jena"
}
```

Sorry for my being too slow. I wanted to try and fix it, but was busy with some other tickets. Thank you for doing it, and I'll now try to review.



---

archive/issue_comments_200854.json:
```json
{
    "body": "I read the latest commit, and it seems good. Hence, I wait for the test results...",
    "created_at": "2014-05-13T14:06:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200854",
    "user": "https://github.com/simon-king-jena"
}
```

I read the latest commit, and it seems good. Hence, I wait for the test results...



---

archive/issue_comments_200855.json:
```json
{
    "body": "The pdf does build...",
    "created_at": "2014-05-13T14:56:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200855",
    "user": "https://github.com/simon-king-jena"
}
```

The pdf does build...



---

archive/issue_comments_200856.json:
```json
{
    "body": "I get numerous errors of the following type:\n\n```\nFile \"src/sage/dev/sagedev.py\", line 4836, in sage.dev.sagedev.SageDev._new_local_branch_for_ticket\nFailed example:\n    dev, config, UI, server = single_user_setup()\nExpected nothing\nGot:\n    GitError: git exited with a non-zero exit code (1).\n    This happened while executing \"git -c user.email=doc@test.test -c user.name=doctest pull /home/king/.sage/temp/linux-etl7.site/1419/dir_y4yz1q/repo master\".\n    git printed nothing to STDOUT.\n    git printed the following to STDERR:\n    git: 'pull' is not a git command. See 'git --help'.\n    <BLANKLINE>\n    Did you mean this?\n        shell\n```\n\nNever seen such errors before.",
    "created_at": "2014-05-13T15:04:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200856",
    "user": "https://github.com/simon-king-jena"
}
```

I get numerous errors of the following type:

```
File "src/sage/dev/sagedev.py", line 4836, in sage.dev.sagedev.SageDev._new_local_branch_for_ticket
Failed example:
    dev, config, UI, server = single_user_setup()
Expected nothing
Got:
    GitError: git exited with a non-zero exit code (1).
    This happened while executing "git -c user.email=doc@test.test -c user.name=doctest pull /home/king/.sage/temp/linux-etl7.site/1419/dir_y4yz1q/repo master".
    git printed nothing to STDOUT.
    git printed the following to STDERR:
    git: 'pull' is not a git command. See 'git --help'.
    <BLANKLINE>
    Did you mean this?
        shell
```

Never seen such errors before.



---

archive/issue_comments_200857.json:
```json
{
    "body": "Is this perhaps an issue of sage-6.3.beta0?",
    "created_at": "2014-05-13T15:06:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200857",
    "user": "https://github.com/simon-king-jena"
}
```

Is this perhaps an issue of sage-6.3.beta0?



---

archive/issue_comments_200858.json:
```json
{
    "body": "Thanks Simon for reviewing this! Could you have a quick look as well at the small last commit on #10963?\n\nFor the git error, IIRC you need a recent version of git for all tests to pass, and doing\n`sage -i git` should do the job.\n\nCheers,\n                                                Nicolas",
    "created_at": "2014-05-13T17:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200858",
    "user": "https://github.com/nthiery"
}
```

Thanks Simon for reviewing this! Could you have a quick look as well at the small last commit on #10963?

For the git error, IIRC you need a recent version of git for all tests to pass, and doing
`sage -i git` should do the job.

Cheers,
                                                Nicolas



---

archive/issue_comments_200859.json:
```json
{
    "body": "Simon, are you using `sage git`? There is always plain `git`, and I fear that it'll stay the more reliable option for a long time...",
    "created_at": "2014-05-13T18:35:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200859",
    "user": "https://github.com/darijgr"
}
```

Simon, are you using `sage git`? There is always plain `git`, and I fear that it'll stay the more reliable option for a long time...



---

archive/issue_comments_200860.json:
```json
{
    "body": "Tests pass for me, so I'm going to set this to positive review.\n\nI also only use my system-wide `git`.",
    "created_at": "2014-05-13T20:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200860",
    "user": "https://github.com/tscrim"
}
```

Tests pass for me, so I'm going to set this to positive review.

I also only use my system-wide `git`.



---

archive/issue_comments_200861.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2014-05-13T20:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200861",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_200862.json:
```json
{
    "body": "Replying to [comment:69 tscrim]:\n> I also only use my system-wide `git`.\n\nAre you sure that you use your system-wide `git` when you run the tests in sage.dev? Anyway, my system-wide git does know about `git pull`---only Sage's git doesn't know.\n\nBest regards,\nSimon",
    "created_at": "2014-05-13T21:33:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200862",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:69 tscrim]:
> I also only use my system-wide `git`.

Are you sure that you use your system-wide `git` when you run the tests in sage.dev? Anyway, my system-wide git does know about `git pull`---only Sage's git doesn't know.

Best regards,
Simon



---

archive/issue_comments_200863.json:
```json
{
    "body": "Replying to [comment:68 darij]:\n> Simon, are you using `sage git`? There is always plain `git`, and I fear that it'll stay the more reliable option for a long time...\n\nI am now talking about the git that I use, but about the git that `sage -dev` uses.",
    "created_at": "2014-05-13T21:34:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200863",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:68 darij]:
> Simon, are you using `sage git`? There is always plain `git`, and I fear that it'll stay the more reliable option for a long time...

I am now talking about the git that I use, but about the git that `sage -dev` uses.



---

archive/issue_comments_200864.json:
```json
{
    "body": "Replying to [comment:67 nthiery]:\n> For the git error, IIRC you need a recent version of git for all tests to pass, and doing\n> `sage -i git` should do the job.\n\nIt doesn't, because git is already installed. `sage -f git` doesn't work either. The resulting git still doesn't know about the pull command.",
    "created_at": "2014-05-13T21:39:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200864",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:67 nthiery]:
> For the git error, IIRC you need a recent version of git for all tests to pass, and doing
> `sage -i git` should do the job.

It doesn't, because git is already installed. `sage -f git` doesn't work either. The resulting git still doesn't know about the pull command.



---

archive/issue_comments_200865.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-05-19T10:24:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15564",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15564#issuecomment-200865",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
