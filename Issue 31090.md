# Issue 31090: Cannot pass PARI precision to UnitGroup

Issue created by migration from https://trac.sagemath.org/ticket/31327

Original creator: DavidLowry

Original creation time: 2021-02-02 18:43:38

CC:  @cmhsu2012 vdelacroix

Keywords: pari, number fields

There is no way to pass a specific precision to `UnitGroup`, so that on some inputs it fails. The following code fails.


```
R.<x> = ZZ[]
K_def_poly = x^5 - 463
K_field.<sqrt_ell> = NumberField(K_def_poly)
Kz_split = K_def_poly.splitting_field('kz_splitting')
Kz_poly = Kz_split.optimized_representation()[0].absolute_polynomial()
Kz_abs.<kz_gen> = NumberField(Kz_poly)

S_Kz_abs_ell0 = Kz_abs.primes_above(11)
SUKz_abs_ell0 = UnitGroup(Kz_abs, proof=False, S=tuple(S_Kz_abs_ell0))
```


This last line causes a PARI precision error.

However, PARI can handle this directly. Usually one can input desired precision, but `UnitGroup` doesn't accept any precision arguments.

In PARI, this could be done through


```
default(realprecision,350);
default(parisize, 10000000);
nf = nfsplitting(x^5-463);
bnf = bnfinit(nf);
bnfsunit(bnf,[]);
S = idealprimedec(bnf,11);
US = bnfsunit(bnf,S);
US[6];
```


This was brought to me by Cathy Hsu (cc'd).


---

Comment by mkoeppe created at 2021-03-24 02:04:25

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.


---

Comment by @AurelPage created at 2022-08-11 12:25:57

Hi,

The pari code above is not the right way to handle this example. Instead of a priori increasing the precision, one should use the flag of bnfinit.


```
nf = nfsplitting(x^5-463);
bnf = bnfinit(nf,1);
bnfsunit(bnf,[]);
S = idealprimedec(bnf,11);
US = bnfsunit(bnf,S);
US[6];
```


However, I am not sure that this is the problem here. I am building the developement version of sage to be sure, but on the version I have (version 9.6, Release Date: 2022-05-15) the problem is that the sage code tries to fully expand the units as linear combinations of the integral basis instead of keeping them in factored form. In fact the error message I got displayed some TODO comments precisely pointing at this inefficiency.

Aurel


---

Comment by @AurelPage created at 2022-08-11 16:09:51

Ok, after trying again with the development version of Sage, I think that the bug has changed since this ticket was created, with the update of the Pari version. Now there is no precision problem anymore, but there is an inefficiency due to the fact that units are fully expanded instead of being kept in factored form.


---

Comment by DavidLowry created at 2022-08-12 09:40:29

I checked now. I have two versions of sage built right now, a dev branch from February 20th and a dev branch from July 10th. In both of these, a `PariError` is thrown complaining about "overflow in lg()" and the error message includes the TODO comments pointing to the inefficiency Aurel mentioned a few messages ago.

This does still throw an error for me, but I think this is a different error than when first reported --- I don't remember clearly.


---

Comment by @AurelPage created at 2022-08-12 10:18:55

The new error (overflow in lg) is triggered because the code is trying to reconstruct units (or some intermediate objects) that don't fit in the maximum size of Pari objects.

I think I can reconstruct the old error in gp, it was probably something like what this code triggers:


```
nf = nfsplitting(x^5-463);
bnf = bnfinit(nf);
bnfsunit(bnf,[]);
S = idealprimedec(bnf,11);
US = bnfsunit(bnf,S);
```


With an old version of Pari, the only way to fix this was to increase precision before the call to bnfinit:


```
nf = nfsplitting(x^5-463);
default(realprecision,300);
bnf = bnfinit(nf);
S = idealprimedec(bnf,11);
US = bnfsunit(bnf,S);
```


With the new version of pari, one can solve this problem in a better way by setting the bnfinit flag to 1:


```
nf = nfsplitting(x^5-463);
default(realprecision,38);
bnf = bnfinit(nf,1);
S = idealprimedec(bnf,11);
US = bnfsunit(bnf,S);
```


However, if we try to ask for the fundamental units in fully expanded form, then we can get the overflow error, although I was unable to reproduce it within gp (the units are large but do not overflow):


```
nf = nfsplitting(x^5-463);
default(realprecision,38);
bnf = bnfinit(nf,1);
bnf.fu
```



---

Comment by @AurelPage created at 2022-08-12 11:33:33

Actually, the recommended way to obtain units and S-units with the new version of pari is with the function bnfunits (not to be confused with bnfsunit). This is what the Sage code does, except that it then tries to expand the units. In gp that would be something like:


```
nf = nfsplitting(x^5-463);
bnf = bnfinit(nf,1);
U = bnfunits(bnf);
[nffactorback(bnf,u) | u <- U[1]]
```


Applying nffactoback to the huge factored forms often results in overflows. If one insists on having expanded forms for the units, one should use bnf.fu instead, which computes the product in a more clever way.


---

Comment by cremona created at 2022-08-15 13:08:09

Thanks for the useful comments, Aurel.   I don't think we want to (at least, not on this ticket) create a new class for factored-units, though I know that they can be much more compact than when expanded (I first heard Buchmann talk about this in 1994, just before ANTS 1).


---

Comment by cremona created at 2022-08-15 13:28:28

As far as I can see, the Sage code (version 9.7.beta8) is wrong, or at least bad.  Looking at lines 326-346 in units.py:
   - it calls bnf_get_fu() which gives the usual fundamental units (and it calls this function a second time later);
   - it then calls bnfunits(S), only using the first (index 0) component;
   - it expands the latter and concatenates lists.

There is rather a lot of repetition in here.  I see that for empty S one can ask for the units in nonfactored form (as thecode does already, twice), but that option does not seem to be possible for general S.  So the way round seems to be to do the expansion within Sage itself.

If other agree that that is a reasonable way forward, I can try doing it.


---

Comment by cremona created at 2022-08-17 07:49:50

To a recent question on pari-users concerning S-units in Pari, Karim gave a detailed reply some of which seems relevant here:


```
The algorithm is folklore, following from the exact sequence defining
the S-unit and standard algorithms to handle short exact sequences of
abelian groups (HNF, etc.).

It was originally implemented in PARI by Denis Simon around 1997. A general
overview is given in Denis's paper on relative norm equations:

  https://www.ams.org/journals/mcom/2002-71-239/S0025-5718-02-01309-1/S0025-5718-02-01309-1.pdf

Proofs are not given for this part but can be found in his PhD thesis

  http://simond.users.lmno.cnrs.fr/maths/these.pdf

I rewrote the details around 2004 to allow privately so called "compact
representations" (which was used to compute tame kernels in algebraic
K-theory; these functions were never included in Pari). Compact
representations were systematized much later and in particular exposed in
the new public function bnfunits() for Pari-2.13.

You should first check this latter function and its documentation.
Details of the basis are meant to be opaque: you shouldn't need any
particular property that's not part of the documentation.

It's basically meant as an input to bnfisunit() [precomputations
allow to decompose any S-unit into a unit and product of generators
given its valuations at S]; the S-units basis is meant to be given
in compact form (which allows to also handle cases where fundamental
units are huge).
```



---

Comment by cremona created at 2022-08-17 08:37:33

Adding Vincent Delacroix to CC since (via git blame) it seems that he's the one who changed this to work with the new pari bnfunits() function, and may want to join in.

It is not so easy to see how to proceed:   the `UnitGroup` class is derived from the class `AbelianGroupWithValues` whose constructor is called in the `__init__()` method, after having computed the generators, `gens`, and their orders, `gens_orders`, and that base class does really want those generators in its constructor.  But where are they actually used?  In two places, first in the method `fundamental_units` which lists all the gens except the torsion generator, and in `exp()` which converts an integer vector of exponents into an actual unit.

I also looked to see where and how the `UnitGroup` class is used in Sage itself.  Outside this file it is used in (1) `bdd_height.py` where the actual fundamental units are requested, and then for certain exponent vectors the associated units are computed (though for some reason not using the exp() method). (2) Used a lot in `S_unit_solver.py` where the `exp()` method is used a lot.  There are more places, of course (e.g. in my own `selmer_group.py`) via the number field methods `unit_group()` and `S_unit_group()`.

Extending the `UnitGroup` class to work with compact representations would be a lot of work.  In a lot of the applications, people really do want to construct actual units!

I don't think that any of this has much to do with passing a precisin parameter.


---

Comment by DavidLowry created at 2022-08-18 13:33:02

> I don't think that any of this has much to do with passing a precision parameter.

I agree. It turns out that I misidentified the problem and gave this ticket a poor name.


---

Comment by cremona created at 2022-08-18 15:03:53

I have a patch which tidies up the code a bit (in the `UnitGroup` constructor) but does not yet allow the example to run.

Aurel suggested asking for bnf.fu whereby pari expands the units for you ("in a more clever way") but as far as I can see this is not available for S-units, only plain units.

I have experimented with allowing a precision parameter which passed down to bnfinit, but as far as I can tell that does not help with the issue here.  Anyway, it seems a good thing to allow (and certainly in the spirit of the ticket's title!), but it is quite a bit of work since (1) every number field method which relies on pari needs to have a new precision parameter (and it is easy to miss some); (2) the pari bnf structure is cached, and so we'll have to have a cached dict of these, keyed by the precisin parameter.  This sort of thing does happen elsewhere.


---

Comment by @AurelPage created at 2022-09-06 12:24:19

If the decision is not to add support for S-units represented as products of small elements, then one should use bnfsunit (old function) instead of bnfunits (new function) + nffactorback. Maybe at some point we will want to add options to bnfunits to ask for expanded forms and deprecate bnfsunit, but at the moment this is probably the best solution.


---

Comment by cremona created at 2022-09-06 13:16:58

I had better upload my patch (branch) before I lose it, though I will not be working more on this soon.

I don't think that anyone has decided  "not to add support for S-units represented as products of small elements" -- I just know that *I* will not be adding such support.


---

Comment by @AurelPage created at 2022-09-06 20:24:18

Sorry, my wording was clumsy. What I meant is that as long as there is no support for product representations, it is better to use bnfsunit. This should allow the above example to run successfully.

If in the future this support gets implemented, then bnfunits will become useful.


---

Comment by cremona created at 2022-09-07 08:37:36

OK, I understand.  I have put my branch on the ticket (not yet merged with most recent develop branch), but I will not have time to do more with this until around 19 Sept.
----
New commits:


---

Comment by cremona created at 2022-09-07 13:38:13

The commit I uploaded (034cb84) was based on a beta from a couple of weeks ago, so I am rebasing it on 9.7.rc0 and will update the commit when I have done that and tested that it still works.


---

Comment by git created at 2022-09-07 15:44:50

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by cremona created at 2022-09-07 15:45:48

OK, same edits but rebased onto 9.7.rc0
