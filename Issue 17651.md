# Issue 17651: Implement check for modular elements and if a poset is supersovable

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-03-03 03:16:35

Assignee: sage-combinat

CC:  sage-combinat

This adds an option to check if a set of elements are modular (and by extension, if you pass a singleton, then that element is modular). This also checks if a lattice is supersolvable, that is to say there exists a maximal chain of modular elements.


---

Comment by tscrim created at 2015-03-03 03:17:08

New commits:


---

Comment by tscrim created at 2015-03-03 03:17:08

Changing status from new to needs_review.


---

Comment by chapoton created at 2015-03-03 21:09:46

Hmm. `is_supersolvable` does not seems very efficient to me. What about something like that (not tested)

```
def is_supersolvable(self):
    """
    """
    x0 = self.minimal_elements()[0]
    x1 = self.maximal_elements()[0]
    mod_elts = [x for x in self if self.is_modular([x])]
    mg = DiGraph([e for e in self.cover_relations()
                  if e[0] in mod_elts and e[1] in mod_elts])
    return mg.shortest_path(x0, x1) != []
```

Maybe you could also make sure that `is_modular` can take a single element of the lattice as argument ?


---

Comment by tscrim created at 2015-03-04 05:19:35

Replying to [comment:2 chapoton]:
> Hmm. `is_supersolvable` does not seems very efficient to me. What about something like that (not tested)

This is likely not as efficient because it checks all elements for modularity, whereas the current implementation will short-circuit. I think we can do this by starting at the lowest element, going up a cover relation to another modular element, if no such element exists, backtrack. I'll implement this tomorrow.

> Maybe you could also make sure that `is_modular` can take a single element of the lattice as argument ?

How would you handle the following poset: `x ,- [x] <- [This is the Trac macro *x* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x-macro)`? By enforcing that it is always a list (or quacks like one), then there's no ambiguity.


---

Comment by chapoton created at 2015-03-05 09:34:40

Replying to [comment:4 tscrim]:
> Replying to [comment:2 chapoton]:
> > Hmm. `is_supersolvable` does not seems very efficient to me. What about something like that (not tested)
> 
> This is likely not as efficient because it checks all elements for modularity, whereas the current implementation will short-circuit. I think we can do this by starting at the lowest element, going up a cover relation to another modular element, if no such element exists, backtrack. I'll implement this tomorrow.

You're right. It would be good to never check twice if some element is modular.

> > Maybe you could also make sure that `is_modular` can take a single element of the lattice as argument ?
> 
> How would you handle the following poset: `x ,- [x] <- [This is the Trac macro *x* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#x-macro)`? By enforcing that it is always a list (or quacks like one), then there's no ambiguity.

ok, I understand. Maybe we can have a function is_modular_element, then ?


---

Comment by chapoton created at 2015-03-05 11:27:36

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-03-06 23:22:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-03-06 23:23:49

Replying to [comment:5 chapoton]:
> Replying to [comment:4 tscrim]:
> You're right. It would be good to never check twice if some element is modular.

It's tomorrow...ish. I've implemented a backtracing version of `is_supersolvable`.

> ok, I understand. Maybe we can have a function is_modular_element, then ?

I've added such a method.


---

Comment by tscrim created at 2015-03-06 23:23:49

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-03-07 01:27:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-03-07 01:28:53

I changed things so that we go from the maximal elements down since in most of my use cases, the rank 1 elements are typically modular.


---

Comment by git created at 2015-03-07 19:08:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-03-07 19:10:11

I have tried to enhance the doc.

I also propose to cache the modular property inside "is_supersolvable", so that one does not check twice that an element is modular or not. What do you think ? (the line with `@`cached_function is currently commented out)


---

Comment by tscrim created at 2015-03-07 23:25:19

I agree with the ``@`cached_function` (at least, from my testing it doesn't cause any memory leaks). Once that's uncommented, then you can set a positive review.


---

Comment by git created at 2015-03-08 09:19:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-03-08 09:20:05

ok, then positive review. thanks for implementing that !


---

Comment by chapoton created at 2015-03-08 09:20:05

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2015-03-08 17:11:54

Thanks Frederic.


---

Comment by vbraun created at 2015-03-08 22:01:05

Resolution: fixed
