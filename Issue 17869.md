# Issue 17869: Maximum depth recursion in QQbar

archive/issues_017869.json:
```json
{
    "body": "CC:  @gagern\n\n```\nsage: a = QQbar.zeta(1009)\nsage: p = cyclotomic_polynomial(1009)\nsage: b = p(a)\nsage: b\n0.?e-12 + 0.?e-12*I\nsage: b == 0\nTraceback (most recent call last):\n...\nRuntimeError: maximum recursion depth exceeded\n```\n\nSuch behavior prevents avoiding lazy fields (RLF and CLF) for number field embeddings (see e.g. #18103).\n\nIssue created by migration from https://trac.sagemath.org/ticket/18106\n\n",
    "created_at": "2015-04-02T09:17:31Z",
    "labels": [
        "component: number fields",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "Maximum depth recursion in QQbar",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17869",
    "user": "https://github.com/videlec"
}
```
CC:  @gagern

```
sage: a = QQbar.zeta(1009)
sage: p = cyclotomic_polynomial(1009)
sage: b = p(a)
sage: b
0.?e-12 + 0.?e-12*I
sage: b == 0
Traceback (most recent call last):
...
RuntimeError: maximum recursion depth exceeded
```

Such behavior prevents avoiding lazy fields (RLF and CLF) for number field embeddings (see e.g. #18103).

Issue created by migration from https://trac.sagemath.org/ticket/18106





---

archive/issue_comments_239349.json:
```json
{
    "body": "Changing keywords from \"\" to \"sd66\".",
    "created_at": "2015-04-02T09:17:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239349",
    "user": "https://github.com/videlec"
}
```

Changing keywords from "" to "sd66".



---

archive/issue_comments_239350.json:
```json
{
    "body": "In `exactify` there is a bit of code which adjusts the recursion limit, increasing it by 10 for every recursive call so it will never be reached. It was introduced in [42b0fb3](http://git.sagemath.org/sage.git/commit/?id=42b0fb3d75cf0967592d2ffdc731a8a610659b59) to address #2638. I guess we could use the same for `_interval_fast` as well.\n\nOn the other hand, we could also try addressing the source of this deep recursion. The way I see it, that's because addition is left associative, so that cyclotomic polynomial will be a very deep but thin binary tree. If we had a representation which describes a sum (and perhaps also a product) of an arbitrary number of algebraic numbers using a single descriptor, the data structure would become much more shallow.\n\nAs a third solution, we might set up our own evaluation machinery for these trees, with our own stack instead of Python recursion. I haven't yet worked out all the details, but if this sounds interesting I might write some code to see how this approach feels.\n\nThe way I see it, since the backtrace is about `_interval_fast` and `_more_precision`, all of this is happening before exact computation is triggered, right? Do we have any way to find out that exact computation might in this case be faster than repeated numeric refinement? I fear we have no way to detect this, but if someone has an idea, please share it.",
    "created_at": "2015-04-02T09:39:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239350",
    "user": "https://github.com/gagern"
}
```

In `exactify` there is a bit of code which adjusts the recursion limit, increasing it by 10 for every recursive call so it will never be reached. It was introduced in [42b0fb3](http://git.sagemath.org/sage.git/commit/?id=42b0fb3d75cf0967592d2ffdc731a8a610659b59) to address #2638. I guess we could use the same for `_interval_fast` as well.

On the other hand, we could also try addressing the source of this deep recursion. The way I see it, that's because addition is left associative, so that cyclotomic polynomial will be a very deep but thin binary tree. If we had a representation which describes a sum (and perhaps also a product) of an arbitrary number of algebraic numbers using a single descriptor, the data structure would become much more shallow.

As a third solution, we might set up our own evaluation machinery for these trees, with our own stack instead of Python recursion. I haven't yet worked out all the details, but if this sounds interesting I might write some code to see how this approach feels.

The way I see it, since the backtrace is about `_interval_fast` and `_more_precision`, all of this is happening before exact computation is triggered, right? Do we have any way to find out that exact computation might in this case be faster than repeated numeric refinement? I fear we have no way to detect this, but if someone has an idea, please share it.



---

archive/issue_comments_239351.json:
```json
{
    "body": "Replying to [comment:2 gagern]: \n> On the other hand, we could also try addressing the source of this deep recursion. The way I see it, that's because addition is left associative, so that cyclotomic polynomial will be a very deep but thin binary tree. If we had a representation which describes a sum (and perhaps also a product) of an arbitrary number of algebraic numbers using a single descriptor, the data structure would become much more shallow.\n\n\nLooks like a good idea to have a polynomial descriptor for one (or several?) algebraic numbers. It might even be used to get faster and more precise interval evaluations.\n\n> As a third solution, we might set up our own evaluation machinery for these trees, with our own stack instead of Python recursion. I haven't yet worked out all the details, but if this sounds interesting I might write some code to see how this approach feels.\n\n\nLooks reasonable to do it without recursion. We might obtain a good speed up.\n\n> The way I see it, since the backtrace is about `_interval_fast` and `_more_precision`, all of this is happening before exact computation is triggered, right?\n\n\nRight!\n\nDo you find reasonable to open two tickets:\n- one for polynomial descriptor in one variable\n- one for evaluation without recursion\n\nVincent",
    "created_at": "2015-04-02T10:11:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239351",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:2 gagern]: 
> On the other hand, we could also try addressing the source of this deep recursion. The way I see it, that's because addition is left associative, so that cyclotomic polynomial will be a very deep but thin binary tree. If we had a representation which describes a sum (and perhaps also a product) of an arbitrary number of algebraic numbers using a single descriptor, the data structure would become much more shallow.


Looks like a good idea to have a polynomial descriptor for one (or several?) algebraic numbers. It might even be used to get faster and more precise interval evaluations.

> As a third solution, we might set up our own evaluation machinery for these trees, with our own stack instead of Python recursion. I haven't yet worked out all the details, but if this sounds interesting I might write some code to see how this approach feels.


Looks reasonable to do it without recursion. We might obtain a good speed up.

> The way I see it, since the backtrace is about `_interval_fast` and `_more_precision`, all of this is happening before exact computation is triggered, right?


Right!

Do you find reasonable to open two tickets:
- one for polynomial descriptor in one variable
- one for evaluation without recursion

Vincent



---

archive/issue_comments_239352.json:
```json
{
    "body": "No, I'd keep it in one ticket, although it certainly makes sense to have multiple branches. But I see these things as complementary: if either one works well, the other *might* become obsolete. And to decide that, we need to compare them, which is easier when we have a single ticket. Once one thing is ready to be merged, *then* we can move the remaining idea to a new ticket.",
    "created_at": "2015-04-02T11:24:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239352",
    "user": "https://github.com/gagern"
}
```

No, I'd keep it in one ticket, although it certainly makes sense to have multiple branches. But I see these things as complementary: if either one works well, the other *might* become obsolete. And to decide that, we need to compare them, which is easier when we have a single ticket. Once one thing is ready to be merged, *then* we can move the remaining idea to a new ticket.



---

archive/issue_comments_239353.json:
```json
{
    "body": "Changing keywords from \"sd66\" to \"sd66, qqbar\".",
    "created_at": "2017-09-22T14:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239353",
    "user": "https://github.com/fchapoton"
}
```

Changing keywords from "sd66" to "sd66, qqbar".



---

archive/issue_comments_239354.json:
```json
{
    "body": "FWIW, in Sage9.1beta3:\n\n```\nsage: a = QQbar.zeta(1009)\nsage: p = cyclotomic_polynomial(1009)\nsage: b = p(a)\nsage: b\n0\nsage: b == 0\nTrue\n```\n\nI arrived on this ticket because of #28599.",
    "created_at": "2020-02-07T17:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239354",
    "user": "https://github.com/jplab"
}
```

FWIW, in Sage9.1beta3:

```
sage: a = QQbar.zeta(1009)
sage: p = cyclotomic_polynomial(1009)
sage: b = p(a)
sage: b
0
sage: b == 0
True
```

I arrived on this ticket because of #28599.



---

archive/issue_comments_239355.json:
```json
{
    "body": "Oh my, increasing the recursion limit is a *horrible* hack. There's a reason why python doesn't like to do deep recursions: stack management in C means that C generally doesn't like to do it, and CPython implements recursion by doing recursion in C. So along with the Python frame stack, the C call stack is also getting deeper.\n\nBefore you start changing the recursion limit in Python, you really want to make sure you can't accomplish the same thing in another way. In particular, you should make sure that the \"recursion\" really gets used: basically that stack depth will only grow logarithmically with problem size (but a little beyond the default 1000 that is normally set) The patch from #2638 seems to be still in force. If it is at all possible to rewrite that code so that recursion limit increases are not necessary, we'd have a significant improvement in our code base.",
    "created_at": "2020-02-07T21:56:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17869",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17869#issuecomment-239355",
    "user": "https://github.com/nbruin"
}
```

Oh my, increasing the recursion limit is a *horrible* hack. There's a reason why python doesn't like to do deep recursions: stack management in C means that C generally doesn't like to do it, and CPython implements recursion by doing recursion in C. So along with the Python frame stack, the C call stack is also getting deeper.

Before you start changing the recursion limit in Python, you really want to make sure you can't accomplish the same thing in another way. In particular, you should make sure that the "recursion" really gets used: basically that stack depth will only grow logarithmically with problem size (but a little beyond the default 1000 that is normally set) The patch from #2638 seems to be still in force. If it is at all possible to rewrite that code so that recursion limit increases are not necessary, we'd have a significant improvement in our code base.
