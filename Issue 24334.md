# Issue 24334: Orthogonal groups of TorsionQuadraticModules

Issue created by migration from https://trac.sagemath.org/ticket/24571

Original creator: sbrandhorst

Original creation time: 2018-01-19 15:44:54

CC:  tscrim vdelecroix

If `T` is a torsion quadratic module, then the orthogonal group consists of those group automorphisms that preserve the torsion quadratic form and bilinear form.

- We can derive this from `sage.groups.abelian_gps.abelian_aut.AbelianGroupAutomorphismGroup_generic`#24087.
- The class should interact well with `FGP_module_homomorphisms`,
- If `T` is the discrimiant group of an IntegralLattice then there should be a coercion from the orthogonal group of the lattice. 
- Of course there `O(T)` must act consistently on elements of `T`.

Generators are hard to come by though ...


---

Comment by sbrandhorst created at 2018-01-24 08:30:28

Changing component from PLEASE CHANGE to group theory.


---

Comment by sbrandhorst created at 2018-01-24 08:30:28

Changing type from PLEASE CHANGE to enhancement.


---

Comment by git created at 2018-01-28 08:55:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-29 08:41:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-31 18:25:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-14 09:55:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-14 18:13:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-03-06 15:25:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-03-06 15:28:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-03-07 15:55:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-03-13 21:53:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-16 06:08:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-16 06:11:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-16 08:34:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-16 10:01:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-17 09:30:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2020-01-08 16:13:34

Changing status from new to needs_review.


---

Comment by sbrandhorst created at 2020-01-08 16:13:34

Added a slow brute force fallback to compute the generators.
In general one can "write down" the generators, but that took me a few thousand lines of code. I'll turn that into an optional package sometimes...
Meanwhile this should do it. 
----
New commits:


---

Comment by git created at 2020-02-18 10:35:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-18 10:48:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-02-18 12:45:11

A bunch of little things:

For the first line of the module, it gets displayed as a title. So could you remove the period/full-stop at the end? Also, I think it should follow title capitalization, but Sage is not so consistent about this...

PEP8 nitpick (just because changes are being done):

```diff
-return x*self
+return x * self
```

and a few other similar such things.


```diff
     INPUT:
 
-        - ``T`` a non degenerate torsion quadratic module.
+    - ``T`` -- a non degenerate torsion quadratic module
```


`FqfOrthogonalGroup.__init__` is missing its docstring (and a `TestSuite(foo).run()` call).


```diff
-if not fqf.invariants() == ambient.domain().gens_orders():
+if fqf.invariants() != ambient.domain().gens_orders():
```



```diff
-        if check:
-            for g in self.gens():
-                if not self._preserves_form(g):
-                    raise ValueError("%s does not preserve the quadratic form"%g)
+        if check and any(not self._preserves_form(g) for g in self.gens()):
+            raise ValueError("%s does not preserve the quadratic form"%g)
```


Do you really want specific type checking here and not subclass

```python
if not type(x) is GapElement:
```

compared to `if not isinstance(x, GapElement):`?

The `_preserves_form` could be condensed into an `all()` statement:

```python
return all((gi*f).q() != gi.q() and all((gi*f).b(g[j]*f) != (gi*f).b(g[j]*f)
                                        for j in range(i+1, len(g)))
           for i, gi in enumerate(g)
```



```diff
-        WARNING:
+        .. WARNING::
 
-        This is usually smaller than the orthogonal group of the bilinear form.
+            This is usually smaller than the orthogonal group of the bilinear form.
```


I don't understand these lines here:

```python
        try:
            gens = [matrix(x*g for x in self.smith_form_gens()) for g in gens]
        except TypeError:
            pass
```

Why should it continue without modifying `gens`? It might be good to include this as a comment in the code.


---

Comment by git created at 2020-02-18 14:07:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2020-02-18 14:10:38


```
File "src/sage/groups/fqf_orthogonal.py", line 190, in sage.groups.fqf_orthogonal.FqfOrthogonalGroup.invariant_form
Failed example:
    Oq.invariant_form() is T
Expected:
    True
Got:
    False
```

But in an interactive session I get

```
sage: q = matrix.diagonal(QQ, [2/3])
....: T = TorsionQuadraticForm(q)
....: Oq = T.orthogonal_group()
....: Oq.invariant_form() is T
....: 
True
```

Can you reproduce this behavior? What is going on?


---

Comment by tscrim created at 2020-02-19 00:10:58

You have to create it twice to see it (see lines 71-74 (side note, probably be better to call the `TorsionQuadraticForm` `T` instead of reusing `q`)):

```
sage: qp = matrix.diagonal(QQ, [2/3])
sage: Tp = TorsionQuadraticForm(qp)
sage: Gp = Tp.orthogonal_group()
sage: Gp.invariant_form() is Tp
True
sage: q = matrix.diagonal(QQ, [2/3])
sage: T = TorsionQuadraticForm(q)
sage: G = DiGraph([[1,2],[2,3]])
sage: Oq = T.orthogonal_group()
sage: Oq.invariant_form() is T
False
```

Something is not being set correctly in a cache somewhere:

```
sage: T is Tp
False
sage: Oq.invariant_form() is Tp
True
sage: Oq is Gp
True
```

My solution would be to make the results from `TorsionQuadraticForm` to be `UniqueRepresentation`. Otherwise just weaken the test slightly to be `==` instead of `is` (and make a clear note saying that the result does not have the unique representation property). (Side question: why aren't the (only ambient?) free modules in Sage a `UniqueRepresentation`?)


---

Comment by sbrandhorst created at 2020-02-19 19:29:48

My guess is that the creation of ambient free modules predates `UniqueRepresentation` and no one cared enough to change it.

Indeed, it seems that torsion quadratic modules are not uniquely represented while FGP_modules are. But not via `UniqueRepresentation`.
In the computation of the orthogonal group we have the call

```
  Oq =  FqfOrthogonalGroup(ambient, gens, self, check=check)
```

which returns an instance of `UniqueRepresentation`.

```
sage: isinstance(Oq,UniqueRepresentation)
True
```

To do that, it uses the hash of `ambient`, `gens` and `self`
but `self` is not uniquely determined (`is`) by its hash (only up to `==`). 

We could make FGP_Modules a `UniqueRepresentation` and do the same with `TorsionQuadraticModule`


---

Comment by sbrandhorst created at 2020-02-19 19:35:39

Another option would be to remove the `UniqueRepresentation` from
`AbelianGroupAutomorphismGroup_gap` which is fine for me.


---

Comment by tscrim created at 2020-02-19 21:19:37

I would make them `UniqueRepresentation`s as the coercion framework works a lot better with them, it comes with pickling, and is faster when doing equality testing. It might be sufficient to just do `TorsionQuadraticModule` for this doctest. The `UniqueRepresentation` key only compares things up to `==`, not `is`.


---

Comment by sbrandhorst created at 2020-02-19 21:21:15

How about `CachedRepresentation` instead? Like for symmetric groups?


---

Comment by sbrandhorst created at 2020-02-19 21:23:10

At the moment I am trying to turn `FGP_Module` into a `UniqueRepresentation` but it breaks a lot of code elsewhere with non-hashable input. So maybe just doing `TorsionQuadraticModule` is okay.


---

Comment by git created at 2020-02-19 21:59:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2020-02-19 22:04:26

For reason to use CachedRepresentation instead of UniqueRepresentation
I quote its


```
In many applications, one wants to combine unique instance and cached
representation behaviour. This is called *unique representation* behaviour.
We have seen above that symmetric groups have a *cached* representation
behaviour. However, they do not show the *unique* representation behaviour,
since they are equal to groups created in a totally different way, namely to
subgroups::

    sage: G = SymmetricGroup(6)
    sage: G3 = G.subgroup([G((1,2,3,4,5,6)),G((1,2))])
    sage: G is G3
    False
    sage: type(G) == type(G3)
    False
    sage: G == G3
    True

```

The same reasoning applies to both `TorsionQuadraticModule` and `AbelianGroupAutomorphismGroup_gap`


---

Comment by sbrandhorst created at 2020-02-19 22:06:50

Replying to [comment:23 tscrim]:
> The `_preserves_form` could be condensed into an `all()` statement:
> {{{#!python
> return all((gi*f).q() != gi.q() and all((gi*f).b(g[j]*f) != (gi*f).b(g[j]*f)
>                                         for j in range(i+1, len(g)))
>            for i, gi in enumerate(g)
> }}}
What is the benefit of this? I do not find it more aesthetic. 
Is it faster?


---

Comment by tscrim created at 2020-02-19 22:34:09

For comment:34: yes, it is faster.

For comment:33: I don't see that for `TorsionQuadraticModule` or `AbelianGroupAutomorphismGroup_gap`. For the symmetric groups, you can realize, e.g., `S_4` as either the group itself or as the natural subgroup of `S_5`. Since these are the same permutation group, the problem arises from `UniqueRepresentation` as the latter should know it is a subgroup but the former should not. Here, the `AbelianGroupAutomorphismGroup_gap` is created only as a specific (sub)group of automorphisms. The same reasoning holds true for `TorsionQuadraticModule`: it is identified with unique additional data.

For `FGP_Module`, this is not the case as the same Python class (representing the same module) can be created in different ways that carry different information. So I agree that this should not be a `UniqueRepresentation`.


---

Comment by sbrandhorst created at 2020-02-20 09:11:06

`UniqueRepresentation`, that is, equality if and only if it is the same object would change the behavior.

```
sage: q = TorsionQuadraticForm(matrix([2/3]))
sage: q1 = q.submodule_with_gens([2*q.0])
sage: q == q1
True
sage: q is q1
False
```

You can have the same group with different generators.

To me `any` is twice as slow as a simple for loop.

```
sage: def test(k):
....:     for i in range(k):
....:         if False:
....:             break
....:         
sage: %timeit test(10^9)
1 loop, best of 5: 18.6 s per loop
sage: %timeit any(False for i in range(10^9))
1 loop, best of 5: 43.4 s per loop
sage: %timeit any(False for i in range(10^5))
The slowest run took 4.35 times longer than the fastest. This could mean that an intermediate result is being cached.
100 loops, best of 5: 3.9 ms per loop
sage: %timeit any(False for i in range(10^5))
100 loops, best of 5: 3.88 ms per loop
sage: %timeit test(10^5)
The slowest run took 4.28 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 5: 1.73 ms per loop
sage: %timeit test(10^5)

```



---

Comment by tscrim created at 2020-02-20 10:57:47

Replying to [comment:36 sbrandhorst]:
> `UniqueRepresentation`, that is, equality if and only if it is the same object would change the behavior.
> {{{
> sage: q = TorsionQuadraticForm(matrix([2/3]))
> sage: q1 = q.submodule_with_gens([2*q.0])
> sage: q == q1
> True
> sage: q is q1
> False
> }}}
> You can have the same group with different generators.

I see. I was thinking the extra construction data would make you want to distinguish them via equality. Okay, then using `CachedRepresentation` is good.

> To me `any` is twice as slow as a simple for loop.
> {{{
> sage: def test(k):
> ....:     for i in range(k):
> ....:         if False:
> ....:             break
> ....:         
> sage: %timeit test(10^9)
> 1 loop, best of 5: 18.6 s per loop
> sage: %timeit any(False for i in range(10^9))
> 1 loop, best of 5: 43.4 s per loop
> sage: %timeit any(False for i in range(10^5))
> The slowest run took 4.35 times longer than the fastest. This could mean that an intermediate result is being cached.
> 100 loops, best of 5: 3.9 ms per loop
> sage: %timeit any(False for i in range(10^5))
> 100 loops, best of 5: 3.88 ms per loop
> sage: %timeit test(10^5)
> The slowest run took 4.28 times longer than the fastest. This could mean that an intermediate result is being cached.
> 1000 loops, best of 5: 1.73 ms per loop
> sage: %timeit test(10^5)
> 
> }}}

When I change it to a non-trivial test, I get nearly the same timings, but with an extra 3ms for the `any` and `all`. So they are essentially the same in any practical scenario. Maybe something has changed in Python3 compared to Python2? I definitely did test this previously and saw a speedup... Oh well. I agree the current code with `for` loops is easier to understand. However, I still recommend using `for i,gi in enumerate(g):`. You may also want to have `g[i]*f` into a separate variable so you are not recomputing it a bunch of times (about 2n<sup>2</sup> times in total in fact).


---

Comment by sbrandhorst created at 2020-02-20 11:12:25

Good point.


---

Comment by git created at 2020-02-20 11:30:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-20 11:39:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-20 19:53:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2020-02-20 19:54:58

O.K. it should be ready now.


---

Comment by tscrim created at 2020-02-21 02:07:44

Thank you for the changes.

Last time I checked, it (surprisingly) is faster to do

```diff
-gf = tuple(h*f for h in g)
+gf = tuple([h*f for h in g])
```

However, I might not do that because then it doesn't take advantage of short-circuiting and it puts everything in memory. So there is a design choice to be made here. I guess it depends on how often you think it will pass through every element in the list at least once before failing and if `g` is expected to be a "short" list (in some appropriate sense of the word). You know more the use-cases than I do. This probably is the correct thing to do, but I just wanted to check that you thought about these things as well.

Finally, this change (2x) should be reverted:

```diff
-        .. WARNING::
+        ..WARNING::
```



---

Comment by sbrandhorst created at 2020-02-21 08:17:16

I guess the common use case is to create a subgroup from some hand-made matrices with `check=True`.
Then they are tested to preserve the form. If the user did not fuck up, the answer is `True` every time so that the check goes through the whole tuple. 
Are you saying that `gf = tuple(h*f for h in g)` is not expanded in memory?


---

Comment by git created at 2020-02-21 08:35:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2020-02-21 08:38:13

I guess if we want speed, the right thing to do is to make `fgp_element.py` a cython file first.
But that is certainly for another ticket.


---

Comment by tscrim created at 2020-02-21 08:58:20

Fair enough. Thank you. Positive review.


---

Comment by tscrim created at 2020-02-21 08:58:20

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-02-22 18:28:18

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2020-02-22 18:28:18

On python 2:

```
**********************************************************************
File "src/sage/groups/fqf_orthogonal.py", line 12, in sage.groups.fqf_orthogonal
Failed example:
    T = L.discriminant_group()
Exception raised:
    Traceback (most recent call last):
      File "/var/lib/buildbot/slave/sage2_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/var/lib/buildbot/slave/sage2_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1123, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.groups.fqf_orthogonal[1]>", line 1, in <module>
        T = L.discriminant_group()
      File "sage/misc/cachefunc.pyx", line 1948, in sage.misc.cachefunc.CachedMethodCaller.__call__ (build/cythonized/sage/misc/cachefunc.c:10273)
        w = self._instance_call(*args, **kwds)
      File "sage/misc/cachefunc.pyx", line 1824, in sage.misc.cachefunc.CachedMethodCaller._instance_call (build/cythonized/sage/misc/cachefunc.c:9758)
        return self.f(self._instance, *args, **kwds)
      File "/var/lib/buildbot/slave/sage2_git/build/local/lib/python2.7/site-packages/sage/modules/free_quadratic_module_integer_symmetric.py", line 808, in discriminant_group
        D = TorsionQuadraticModule(self.dual_lattice(), self)
      File "sage/misc/classcall_metaclass.pyx", line 334, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1741)
        return cls.classcall(cls, *args, **kwds)
    TypeError: unbound method __classcall__() must be called with TorsionQuadraticModule instance as first argument (got ClasscallMetaclass instance instead)
**********************************************************************
```



---

Comment by tscrim created at 2020-02-23 00:04:11

`__classcall__` should be an ``@`staticmethod`. Once changed, you can set it back to a positive review.


---

Comment by git created at 2020-02-24 17:45:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2020-02-24 17:45:41

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2020-02-26 20:35:39

Resolution: fixed


---

Comment by fbissey created at 2020-02-29 02:55:11

I am getting

```
sage -t --long /usr/lib/python3.7/site-packages/sage/groups/fqf_orthogonal.py
**********************************************************************
File "/usr/lib/python3.7/site-packages/sage/groups/fqf_orthogonal.py", line 17, in sage.groups.fqf_orthogonal
Failed example:
    T.gen(0) * Oq.an_element()
Expected:
    (1, 3)
Got:
    (0, 3)
**********************************************************************
```

Does it depends on what gap packages are installed?


---

Comment by sbrandhorst created at 2020-03-01 18:51:04

Maybe the `Oq.an_element()` call does? One could replace it by a hard coded element.


---

Comment by sbrandhorst created at 2020-03-04 09:41:03

`an_element` returns the product of the generators.
Now the generators are produced using the gap function
`SmallGeneratingSet`.
I do not know how the function works internally but it seems possible this is where the packages come in.


---

Comment by fbissey created at 2020-03-04 10:01:59

This may be difficult to track down unless you know `gap` well. But I probably won't be the only one with a failure - unless I am missing a gap package that is meant to be in the sage's default.


---

Comment by dimpase created at 2020-03-05 13:08:30

Replying to [comment:56 fbissey]:
> This may be difficult to track down unless you know `gap` well. But I probably won't be the only one with a failure - unless I am missing a gap package that is meant to be in the sage's default.

I've go the same error (`(0,3)`, not `(1,3)`), on Fedora 30, x86_64, and the current 9.1.beta6 with gap_packages spkg installed.

This is not surprising, in fact, as gap_packages contain stuff that speeds up certain GAP algorithms. This test is buggy; it should be not using the call to `an_element`, but something deterministic. I've opened #29282 as a followup
