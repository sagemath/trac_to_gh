# Issue 16347: allow R(vector())

Issue created by migration from https://trac.sagemath.org/ticket/16584

Original creator: malb

Original creation time: 2014-06-28 17:45:07

CC:  mmarco slelievre

Keywords: sd59

This should work:


```
sage: P.<x> = ZZ[]
sage: v = random_vector(ZZ, 10); v
(2, 2, 0, 0, 4, -1, 30, -1, 1, -145)
sage: P(v)
-145*x^9 + x^8 - x^7 + 30*x^6 - x^5 + 4*x^4 + 2*x + 2
```



---

Comment by malb created at 2014-06-28 17:46:38

New commits:


---

Comment by malb created at 2014-06-28 17:46:38

Changing status from new to needs_review.


---

Comment by mmarco created at 2014-06-28 21:59:33

I think that this would be better done in the _element_constructor_ method of the parent. That way this feature would be automatically available for univariate polynomials in general (not just over ZZ)


---

Comment by rws created at 2014-06-29 09:02:18

Changing status from needs_review to needs_work.


---

Comment by git created at 2014-06-29 17:15:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by malb created at 2014-06-29 17:17:01

Replying to [comment:2 mmarco]:
> I think that this would be better done in the _element_constructor_ method of the parent. That way this feature would be automatically available for univariate polynomials in general (not just over ZZ)

It isn't as straight forward as that: every class implements its own `__init__` without using the superclass. I implemented this for a few more classes.


---

Comment by malb created at 2014-06-29 17:17:11

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2014-07-06 18:11:44

I'm worried about this change:

```diff
@@ -239,8 +249,11 @@ cdef class Polynomial_integer_dense_flint(Polynomial):
                 sig_off()
                 return
 
-        elif not isinstance(x, list):
-            x = [x]   # constant polynomials
+        else:
+            try:
+                x = list(x) # at this point anything that can be a list, is treated list
+            except TypeError:
+                x = [x]   # constant polynomials
 
         sig_on()
         fmpz_poly_realloc(self.__poly, len(x))
```

In particular, we might end up trying to make a list of an infinite set, which runs indefinitely. However this isn't the problem, the issue is that we won't be able to interrupt it because it's not in a `sig_on()/sig_off()` block. This would also be useful for other such long time iterators.


---

Comment by git created at 2014-07-07 15:40:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by malb created at 2014-07-07 15:42:17

Changing status from needs_review to needs_work.


---

Comment by malb created at 2014-07-07 15:42:17

I addressed this issue, but Miguel suggested to refactor this ticket at SD59 such that we don't implement this list(x) business more than once. Hence, I'm keeping it as **needs work**.


---

Comment by jdemeyer created at 2014-12-29 23:42:32

You should probably not wrap list comprehensions in `sig_on()`/`sig_off()`, see [http://www.sagemath.org/doc/developer/coding_in_cython.html#using-sig-on-and-sig-off](http://www.sagemath.org/doc/developer/coding_in_cython.html#using-sig-on-and-sig-off)


---

Comment by tscrim created at 2014-12-30 07:11:20

So because it's python code which manipulates objects in memory, you shouldn't wrap it because the interrupt will not clean up the partial allocation. Instead one should use `sign_check`. Is this correct?


---

Comment by jdemeyer created at 2014-12-30 08:44:53

Yes, better use `sig_check()` (although it seems non-trivial to do that in a list comprehension). If there is enough Python code involved, you might even get away with no signal handling at all, since Python _does_ check for interrupts.
