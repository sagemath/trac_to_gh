# Issue 22604: Speed up hermite normal form and weak popov form

Issue created by migration from Trac.

Original creator: klee

Original creation time: 2017-04-20 13:45:43

This ticket provides faster Hermite normal form and weak Popov form computations for polynomial matrices.


---

Comment by klee created at 2017-04-20 13:48:29

New commits:


---

Comment by klee created at 2017-04-24 23:45:17

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2017-05-19 18:08:45

The code looks good.

1) Why these new methods are cpdef? It will make any difference if you *repeatedly* call such method. Which I do not think is the case for most application.

2) The logic of

```
shift = False
if shifts:
    shift = True
```

is quite confusing. You can use `if shifts` instead of `if shift` anywhere.

3) Does `hermite_form_reversed` just the transposed of the hermite form of the transposed matrix or with respect to row/column ordering? If so, you can just remove the method (one can apply some permutations of entries first and then call the standard algorithm). If not, you should clarify the documentation.

4) As far as I can see, most of the code in `_hermite_form_euclidean` is not polynomial specific but would work as soon as you have `xgcd`. The only missing piece is the normalization to monic polynomial. Am I right? In that case, it would be good to have this code available more generally.

5) Instead of

```
if transformation:
    U = A._hermite_form_euclidean(transformation=True)
    if not include_zero_rows:
        i = A.nrows() - 1
        while i >= 0 and A.row(i) == 0:
            i -= 1
        A = A[:i+1]
        U = U[:i+1]
    return A, U
else:
    A._hermite_form_euclidean(transformation=False)
    if not include_zero_rows:
        i = A.nrows() - 1
        while i >= 0 and A.row(i) == 0:
            i -= 1
        A = A[:i+1]
    return A
```

why not

```
U = A._hermite_form_euclidean(transformation=transformation)
if not include_zero_rows:
    i = A.nrows() - 1
    while i >= 0 and A.row(i) == 0:
        i -= 1
    A = A[:i+1]
    if transformation
        U = U[:i+1]

return (A, U) if transformation else A
```


7) You claim that there is a speed up. Could you provide some relevant timings?

8) Please fill the "Authors" field of the ticket with your full name


---

Comment by vdelecroix created at 2017-05-19 18:08:45

Changing status from needs_review to needs_work.


---

Comment by klee created at 2017-05-19 22:39:54

> 3) Does `hermite_form_reversed` just the transposed of the hermite form of the transposed matrix or with respect to row/column ordering? If so, you can just remove the method (one can apply some permutations of entries first and then call the standard algorithm). If not, you should clarify the documentation.

The output of `hermite_form_reversed` for matrix X is the row-and-column-reversed matrix of the hermite_form of the row-and-column-reversed matrix of X. So you are right that `hermite_form_reversed` can be implemented with the standard hermite form algorithm and some reversals of entries. 

The issue is speed. I have an application for which reversed hermite forms are natural, and it is crucial to have this algorithm as fast as possible. I cannot lose any time in reversing entries. For me, I would rather keep `hermite_form_reversed` and make `hermite_form` do the reversals! But should I?

(I will respond to your other comments later)


---

Comment by vdelecroix created at 2017-05-22 07:01:31

Replying to [comment:5 klee]:
> > 3) Does `hermite_form_reversed` just the transposed of the hermite form of the transposed matrix or with respect to row/column ordering? If so, you can just remove the method (one can apply some permutations of entries first and then call the standard algorithm). If not, you should clarify the documentation.
> 
> The output of `hermite_form_reversed` for matrix X is the row-and-column-reversed matrix of the hermite_form of the row-and-column-reversed matrix of X. So you are right that `hermite_form_reversed` can be implemented with the standard hermite form algorithm and some reversals of entries. 
> 
> The issue is speed. I have an application for which reversed hermite forms are natural, and it is crucial to have this algorithm as fast as possible. I cannot lose any time in reversing entries. For me, I would rather keep `hermite_form_reversed` and make `hermite_form` do the reversals! But should I?

Reversing the entries will definitely not be time critical (zero copy, it is just swapping some pointers). The algorithm will spend much more time doing polynomial divisions. Am I correct that you call the row-and-column reversed matrix `(i,j) -> m[nrows - i - 1, ncols - j - 1]`?

If I had to choose I would implement only `hermite_form` and do in your algorithm

```
my_matrix.reverse_rows_and_columns()
hnf = my_matrix.hermite_form()
my_matrix.reverse_rows_and_columns()  # put back the matrix in the right order
```

If you need help, I can implement this `reverse_rows_and_columns`.


---

Comment by klee created at 2017-05-22 07:25:33

Replying to [comment:6 vdelecroix]: 
> Reversing the entries will definitely not be time critical (zero copy, it is just swapping some pointers). The algorithm will spend much more time doing polynomial divisions. 

I know. I once experimented with that row-and-column reversing. At that time, I was obsessed with timings and could not afford even that small time losing in reversing. My application computes lots of reversed hermite form. Here it is

https://trac.sagemath.org/ticket/22982

if you are interested.

> Am I correct that you call the row-and-column reversed matrix `(i,j) -> m[nrows - i - 1, ncols - j - 1]`?

Yes.

> If I had to choose I would implement only `hermite_form` and do in your algorithm
> {{{
> my_matrix.reverse_rows_and_columns()
> hnf = my_matrix.hermite_form()
> my_matrix.reverse_rows_and_columns()  # put back the matrix in the right order
> }}}

I understand your concern; it is a burden to keep two versions of essentially the same algorithm. Hmm. Now that I am out of that timing obsession, I will check again if I can live with only the standard hermite form. 

> If you need help, I can implement this `reverse_rows_and_columns`.

Can you think of an implementation simpler or faster than this?

```
def reverse_rows_and_columns(m):
    return matrix([e for e in reversed(m.list())])
```



---

Comment by vdelecroix created at 2017-05-22 07:29:55

Replying to [comment:7 klee]:
> Replying to [comment:6 vdelecroix]: 
> Can you think of an implementation simpler or faster than this?
> {{{
> def reverse_rows_and_columns(m):
>     return matrix([e for e in reversed(m.list())])
> }}}

Of course! This is damn slow (and makes a copy).


---

Comment by vdelecroix created at 2017-05-22 08:05:17

Replying to [comment:8 vdelecroix]:
> Replying to [comment:7 klee]:
> > Replying to [comment:6 vdelecroix]: 
> > Can you think of an implementation simpler or faster than this?
> > {{{
> > def reverse_rows_and_columns(m):
> >     return matrix([e for e in reversed(m.list())])
> > }}}
> 
> Of course! This is damn slow (and makes a copy).

See #23050.


---

Comment by vdelecroix created at 2017-05-22 08:06:41

And for timings

```
sage: m = random_matrix(ZZ['x'], 10, 10)
sage: %timeit m.reverse_rows_and_columns()
10000000 loops, best of 3: 100 ns per loop

sage: m = random_matrix(ZZ['x'], 100, 100)
sage: %timeit m.reverse_rows_and_columns()
100000 loops, best of 3: 3.76 µs per loop
```



---

Comment by vdelecroix created at 2017-05-22 08:09:13

Your version with the function is 2000x slower for 10x10 matrices!


---

Comment by git created at 2017-05-22 21:52:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-05-22 22:02:38

Some timings

Before the patch:


```
sage: P.<x> = GF(5)[]
sage: m = matrix(P,5,[x^((i-j) % 5) + i for i in range(5) for j in range(5)])
sage: timeit('m.weak_popov_form()')
625 loops, best of 3: 54.4 µs per loop
sage: timeit('m.hermite_form()')
125 loops, best of 3: 2.49 ms per loop
```


After the patch:

```
sage: P.<x> = GF(5)[]
sage: m = matrix(P,5,[x^((i-j) % 5) + i for i in range(5) for j in range(5)])
sage: timeit('m.weak_popov_form()')
625 loops, best of 3: 5.17 µs per loop
sage: timeit('m.hermite_form()')
625 loops, best of 3: 171 µs per loop
```



---

Comment by klee created at 2017-05-22 22:11:12

More timings for a larger matrix:

Before the patch:

```
sage: P.<x> = GF(5)[]
sage: m = matrix(P,50,[x^((i-j) % 20) + i for i in range(50) for j in range(50)])
sage: timeit('m.hermite_form()')
... (seemingly takes forever; interrupted)
sage: timeit('m.weak_popov_form()')
125 loops, best of 3: 2.61 ms per loop
```


After the patch:

```
sage: P.<x> = GF(5)[]
sage: m = matrix(P,50,[x^((i-j) % 20) + i for i in range(50) for j in range(50)])
sage: timeit('m.hermite_form()')
5 loops, best of 3: 116 ms per loop
sage: timeit('m.weak_popov_form()')
625 loops, best of 3: 1.61 ms per loop
```



---

Comment by klee created at 2017-05-22 22:26:03

> 1) Why these new methods are cpdef? 

Now they are `def` methods.

> 2) You can use `if shifts` instead of `if shift` anywhere.

That will incur many useless conversions (from a list to a boolean). I kept `shift` but reshaped the code slightly to be less confusing, hopefully.
 
> 4) As far as I can see, most of the code in `_hermite_form_euclidean` is not polynomial specific but would work as soon as you have `xgcd`. The only missing piece is the normalization to monic polynomial. Am I right? In that case, it would be good to have this code available more generally.

True. But for that, the normalization part should be removed, and I am not interested in doing this work myself. I want to leave this work to a separate ticket and to others.
> 
> 5) Instead of ...

Done. Thanks.

> 7) You claim that there is a speed up. Could you provide some relevant timings?

Done.
 
> 8) Please fill the "Authors" field of the ticket with your full name

Done.


---

Comment by tscrim created at 2017-05-23 04:20:25

AFAIK, there is no penalty for making a method `cpdef`, but there could be a benefit for those times it does get called though a C codepath. IIRC, it also means it gets to call `cdef` functions as C functions without some extra. Vincent, is there a reason I don't know about for not making these `cpdef`? There also looks like there are some other variables that you could explicitly declare their types.

This is not true:

```
boolean (default: ``None``) A tuple or list of integers
```

Also, the boolean check of, e.g., a list should be very quick and insignificant in terms of speed, but it can make the code easier to maintain in the long run.

Something I have found that I wish Python would do is return the object even when you do something that mutates it. This allows you to chain operations together in a more natural way, e.g.,

```
M._weak_popov_form().transpose()
```



---

Comment by vdelecroix created at 2017-05-23 06:41:17

Replying to [comment:17 tscrim]:
> AFAIK, there is no penalty for making a method `cpdef`, but there could be a benefit for those times it does get called though a C codepath. IIRC, it also means it gets to call `cdef` functions as C functions without some extra. Vincent, is there a reason I don't know about for not making these `cpdef`? 

-1 the time is not spent in the function call. It is an extra complication for no use. If the code can stay simpler keep it simpler.

> There also looks like there are some other variables that you could explicitly declare their types.

+1

> Also, the boolean check of, e.g., a list should be very quick and insignificant in terms of speed, but it can make the code easier to maintain in the long run.

+1. There is no such thing as a conversion. `if my_list` is as fast as it can be. Anyway, if you seriously care about speed, this is not the kind of things you want to optimize.


---

Comment by git created at 2017-05-23 16:09:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-05-23 16:11:26

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2017-05-23 16:12:40

There is a field "Dependencies" in the ticket for dependencies...


---

Comment by git created at 2017-05-23 16:25:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-05-23 21:04:12

Replying to [comment:4 vdelecroix]:

> 4) As far as I can see, most of the code in `_hermite_form_euclidean` is not polynomial specific but would work as soon as you have `xgcd`. The only missing piece is the normalization to monic polynomial. Am I right? In that case, it would be good to have this code available more generally.

My previous response to this comment was somewhat adequate. I now try to answer again.

I didn't want to put the code into a more general place like `matrix2.pyx`, because that would incur some condition checking for every call of `hermite_form`.  It was just clean to put the code into the file dedicated for polynomial matrices. 

Now it occurs to me that putting just `_hermite_form_euclidean` to `matrix2.pyx` (but keeping `hermite_form` to the present place) may not hurt. The normalization code depending on `lc()` may be put into a `try` clause. Then  the `_hermite_form_euclidean` could be used to provide `hermite_form()` for matrices for other euclidean domains, in future.

If you agree, then I can do this part: putting `_hermite_form_euclidean` to `matrix2.pyx`. But I will leave it as a future task to to provide `hermite_form()` for matrices for other euclidean domains (though I cannot imagine what these would be in practice right now...).

Perhaps this was in your mind when you wrote the comment :-)


---

Comment by klee created at 2017-05-24 10:25:55

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-05-24 11:57:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-05-24 12:00:07

> I can do this part: putting `_hermite_form_euclidean` to `matrix2.pyx`. 

Done.


---

Comment by klee created at 2017-05-24 12:00:28

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2017-05-24 13:09:56

I don't mind that you move `_hermite_form_euclidean`. But if you do, it must be tested with other base rings than polynomials. My question was more of a prospective form (Hermite form is useful to study submodules and quotients of free modules).


---

Comment by git created at 2017-05-24 16:34:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-05-26 17:42:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-05-29 14:10:11

Is there a need for both `hermite_form_reversed` and `_reversed_hermite_form_euclidean`?


---

Comment by vdelecroix created at 2017-05-29 14:16:46

Would be more natural to replace

```
for c in range(j,n):
    temp = A.get_unsafe(k,c)
    A.set_unsafe(k, c, p * A.get_unsafe(k,c) + q * A.get_unsafe(l,c))
    A.set_unsafe(l, c, (-f) * temp + e * A.get_unsafe(l,c))
```

with

```
for c in range(j,n):
    Akc = A.get_unsafe(k,c)
    Alc = A.get_unsafe(l,c)
    A.set_unsafe(k, c, p * Akc + q * Alc)
    A.set_unsafe(l, c, -f * Akc + e * Alc)
```



---

Comment by klee created at 2017-05-29 15:52:23

Replying to [comment:31 vdelecroix]:
> Is there a need for both `hermite_form_reversed` and `_reversed_hermite_form_euclidean`?

As you see, `hermite_form_reversed` returns a new matrix from self while `_reversed_hermite_form_euclidean` transforms self in place. This is obvious. Did I understand your question correctly?


---

Comment by git created at 2017-05-29 16:29:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-05-29 16:32:05

Further gain by the last commit:


```
sage: P.<x> = GF(5)[]
sage: m = matrix(5,[(x+i)^((i-j)%7) for i in range(5) for j in range(5)])
sage: timeit('m.hermite_form_reversed(transformation=True)')
625 loops, best of 3: 957 µs per loop
```


vs


```
sage: P.<x> = GF(5)[]
sage: m = matrix(5,[(x+i)^((i-j)%7) for i in range(5) for j in range(5)])
sage: timeit('m.hermite_form_reversed(transformation=True)')
625 loops, best of 3: 431 µs per loop
```



---

Comment by klee created at 2017-05-30 16:07:53

Replying to [comment:31 vdelecroix]:
> Is there a need for both `hermite_form_reversed` and `_reversed_hermite_form_euclidean`?

Are you asking if I can get rid of both of those methods from the patch (and implement them in my own application for personal use)?


---

Comment by git created at 2017-06-02 08:48:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-06-02 08:59:34

Replying to [comment:36 klee]:
> Replying to [comment:31 vdelecroix]:
> > Is there a need for both `hermite_form_reversed` and `_reversed_hermite_form_euclidean`?
> 
> Are you asking if I can get rid of both of those methods from the patch (and implement them in my own application for personal use)?

Perhaps, the reversed hermite form methods have little use, except to me. I removed them.


---

Comment by klee created at 2017-06-02 11:59:04

The present `hermite_form` method returns an immutable matrix only when `include_zero_rows=False`, because of the side effect of taking `A[:i]`. This raises some questions:

(1) Should `hermite_form` always return an immutable matrix?

(2) `A[:i]` returns an immutable matrix even if A is not? Is this expected or a bug?

If the answer to (1) is true, then `reversed_hermite_form` cannot be obtained just by wrapping `hermite_form` with `reverse_rows_and_columns` because you cannot "reverse" an immutable matrix.


---

Comment by klee created at 2017-06-02 11:59:23

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-06-02 14:12:51

The best would be to follow the conventions of `echelon_form`

```
sage: m = matrix(QQ, 2, [1, 2, 3, 4])
sage: h = m.echelon_form()
sage: h.is_mutable()
False
```

So I would answer yes to (1).

Concerning (2), you can always get a copy using `m.__copy__()`.


---

Comment by git created at 2017-06-02 14:31:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-06-02 14:33:26

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2017-06-03 15:18:52

I find weird to have this `lc` lying around in the generic implementation. A more appropriate way might be to have an optional `normalize` argument that would be a function

```
def _hermite_form_euclidean(self, transformation=False, normalize=None):
    ...
    # possibly normlize the pivot
    if normalize:
        coeff = normalize(pivot)
        for c in range(j,n):
            A.set_unsafe(i, c, A.get_unsafe(i,c) * coeff)
            if transformation:
                for c in range(m):
                    U.set_unsafe(i, c, U.get_unsafe(i,c) * coeff)
```

Then it could be used as

```
if transformation:
    U = A._hermite_form_euclidean(transformation=True, normalize=lambda p: ~p.lc())
else:
    A._hermite_form_euclidean(transformation=False, normalize=lambda p: ~p.lc())
```


(I am not really convinced by the name `normalize`)


---

Comment by vdelecroix created at 2017-06-03 15:19:30

In `_weak_popov_form` you might want to declare as `cdef list` both `to_row` and `conflicts`.


---

Comment by git created at 2017-06-03 19:38:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-06-03 19:40:18

Replying to [comment:46 vdelecroix]:
> In `_weak_popov_form` you might want to declare as `cdef list` both `to_row` and `conflicts`.

Done. But I don't notice any difference in speed.


---

Comment by git created at 2017-06-06 08:15:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-06-09 07:36:33

Vincent, it would be good that this is merged to Sage 8.0. Is there anything missing yet?


---

Comment by vdelecroix created at 2017-06-11 04:47:38

You did not answer to [comment:45 comment:45].


---

Comment by git created at 2017-06-11 07:35:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-06-11 07:39:25

Replying to [comment:45 vdelecroix]:
> I find weird to have this `lc` lying around in the generic implementation. A more appropriate way might be to have an optional `normalize` argument that would be a function

Good idea. I found one instance where `normalization` is used for a similar purpose. So I use that.


---

Comment by vdelecroix created at 2017-06-12 07:33:35

small typo: forgot a `a` in `# possibly normlize the pivot`

A simplification: the following

```
if transformation:
    U = A._hermite_form_euclidean(transformation=True, normalization=lambda p: ~p.lc())
else:
    A._hermite_form_euclidean(transformation=False, normalization=lambda p: ~p.lc())
```

could be replaced by

```
U = A._hermite_form_euclidean(transformation=transformation, normalization=lambda p: ~p.lc())
```

(in the second cas `U` will be set to `None` which is fine)


---

Comment by vdelecroix created at 2017-06-12 07:34:49

Could you add an example in `_hermite_form_euclidean` where the argument `normalization` is actually used?


---

Comment by git created at 2017-06-12 09:42:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-06-12 09:46:16

> A simplification: the following
> {{{
> if transformation:
>     U = A._hermite_form_euclidean(transformation=True, normalization=lambda p: ~p.lc())
> else:
>     A._hermite_form_euclidean(transformation=False, normalization=lambda p: ~p.lc())
> }}}
> could be replaced by
> {{{
> U = A._hermite_form_euclidean(transformation=transformation, normalization=lambda p: ~p.lc())
> }}}
> (in the second cas `U` will be set to `None` which is fine)

Yes, it works. I didn't know this :-)


---

Comment by klee created at 2017-06-17 23:39:55

The patchbot failures seem unrelated with this patch. I have nothing to do with that. Anything else to do?


---

Comment by vdelecroix created at 2017-06-18 20:37:18

looks good.


---

Comment by vdelecroix created at 2017-06-18 20:37:18

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-06-22 07:23:36

Resolution: fixed
