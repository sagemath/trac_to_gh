# Issue 20278: Proper idiom for defining an axiom as the intersection of two axioms defined in the same category.

Issue created by migration from https://trac.sagemath.org/ticket/20515

Original creator: nthiery

Original creation time: 2016-04-28 22:34:10

Let `Cs` be a category, where three axioms are defined, `A`, `A1`,
`A2`, with `A` being the intersection of `A1` and `A2`. The natural
implementation would look like:


```
    from sage.categories.category_with_axiom import CategoryWithAxiom, all_axioms

    all_axioms += ("A", "A1", "A2")

    class Cs(Category):
        def super_categories(self):
            return [Objects()]

        class SubcategoryMethods:
            def A1(self):
                return self._with_axiom("A1")
            def A2(self):
                return self._with_axiom("A2")
            def A(self):
                return self._with_axiom("A")

        class A1(CategoryWithAxiom):
            pass

        class A2(CategoryWithAxiom):
            def A1_extra_super_categories(self):
                return [Cs().A()]

        class A(CategoryWithAxiom):
            def extra_super_categories(self):
                return [Cs().A1(), Cs().A2()]
```


However this triggers an infinite recursion loop:

```
    sage: Cs().A()
    RuntimeError: maximum recursion depth exceeded while calling a Python object
```


This is because `Cs().A2().A1_extra_super_categories()` does not
return a strict super category of the to-be-constructed category,
which is forbidden by the current specifications:

http://doc.sagemath.org/html/en/reference/categories/sage/categories/category_with_axiom.html#id2

A workaround is to define A (or A1, or A2) in some super category:

```
    class C0(Category):
        def super_categories(self):
            return [Objects()]
        class SubcategoryMethods:
            def A(self):
                return self._with_axiom("A")
        class A(CategoryWithAxiom):
            pass

    class C1(Category):
        def super_categories(self):
            return [C0()]

        class SubcategoryMethods:
            def A1(self):
                return self._with_axiom("A1")
            def A2(self):
                return self._with_axiom("A2")

        class A1(CategoryWithAxiom):
            pass

        class A2(CategoryWithAxiom):
            def A1_extra_super_categories(self):
                return [C0.A()]

        class A(CategoryWithAxiom):
            def extra_super_categories(self):
                return [C1.A1(), C1.A2()]
```

Then,

```
    sage: C1().A1().A2() is C1().A()
    True
    sage: C1().A()
    Category of a1 a2 c1
    sage: C1().A().super_categories()
    [Category of a c0, Category of a2 c1, Category of a1 c1]
    sage: C1().A1().A2() is C1().A()
    True
```


A better idiom would be desirable, for cases where none of `A`, `A1`,
`A2` make sense in a strict super category.

See #18265 for a concrete instance where this workaround is currently
used.
