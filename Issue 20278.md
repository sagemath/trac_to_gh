# Issue 20278: Proper idiom for defining an axiom as the intersection of two axioms defined in the same category.

archive/issues_020278.json:
```json
{
    "body": "Let `Cs` be a category, where three axioms are defined, `A`, `A1`,\n`A2`, with `A` being the intersection of `A1` and `A2`. The natural\nimplementation would look like:\n\n\n```\n    from sage.categories.category_with_axiom import CategoryWithAxiom, all_axioms\n\n    all_axioms += (\"A\", \"A1\", \"A2\")\n\n    class Cs(Category):\n        def super_categories(self):\n            return [Objects()]\n\n        class SubcategoryMethods:\n            def A1(self):\n                return self._with_axiom(\"A1\")\n            def A2(self):\n                return self._with_axiom(\"A2\")\n            def A(self):\n                return self._with_axiom(\"A\")\n\n        class A1(CategoryWithAxiom):\n            pass\n\n        class A2(CategoryWithAxiom):\n            def A1_extra_super_categories(self):\n                return [Cs().A()]\n\n        class A(CategoryWithAxiom):\n            def extra_super_categories(self):\n                return [Cs().A1(), Cs().A2()]\n```\n\n\nHowever this triggers an infinite recursion loop:\n\n```\n    sage: Cs().A()\n    RuntimeError: maximum recursion depth exceeded while calling a Python object\n```\n\n\nThis is because `Cs().A2().A1_extra_super_categories()` does not\nreturn a strict super category of the to-be-constructed category,\nwhich is forbidden by the current specifications:\n\nhttp://doc.sagemath.org/html/en/reference/categories/sage/categories/category_with_axiom.html#id2\n\nA workaround is to define A (or A1, or A2) in some super category:\n\n```\n    class C0(Category):\n        def super_categories(self):\n            return [Objects()]\n        class SubcategoryMethods:\n            def A(self):\n                return self._with_axiom(\"A\")\n        class A(CategoryWithAxiom):\n            pass\n\n    class C1(Category):\n        def super_categories(self):\n            return [C0()]\n\n        class SubcategoryMethods:\n            def A1(self):\n                return self._with_axiom(\"A1\")\n            def A2(self):\n                return self._with_axiom(\"A2\")\n\n        class A1(CategoryWithAxiom):\n            pass\n\n        class A2(CategoryWithAxiom):\n            def A1_extra_super_categories(self):\n                return [C0.A()]\n\n        class A(CategoryWithAxiom):\n            def extra_super_categories(self):\n                return [C1.A1(), C1.A2()]\n```\n\nThen,\n\n```\n    sage: C1().A1().A2() is C1().A()\n    True\n    sage: C1().A()\n    Category of a1 a2 c1\n    sage: C1().A().super_categories()\n    [Category of a c0, Category of a2 c1, Category of a1 c1]\n    sage: C1().A1().A2() is C1().A()\n    True\n```\n\n\nA better idiom would be desirable, for cases where none of `A`, `A1`,\n`A2` make sense in a strict super category.\n\nSee #18265 for a concrete instance where this workaround is currently\nused.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20515\n\n",
    "created_at": "2016-04-28T22:34:10Z",
    "labels": [
        "categories",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "Proper idiom for defining an axiom as the intersection of two axioms defined in the same category.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20278",
    "user": "nthiery"
}
```
Let `Cs` be a category, where three axioms are defined, `A`, `A1`,
`A2`, with `A` being the intersection of `A1` and `A2`. The natural
implementation would look like:


```
    from sage.categories.category_with_axiom import CategoryWithAxiom, all_axioms

    all_axioms += ("A", "A1", "A2")

    class Cs(Category):
        def super_categories(self):
            return [Objects()]

        class SubcategoryMethods:
            def A1(self):
                return self._with_axiom("A1")
            def A2(self):
                return self._with_axiom("A2")
            def A(self):
                return self._with_axiom("A")

        class A1(CategoryWithAxiom):
            pass

        class A2(CategoryWithAxiom):
            def A1_extra_super_categories(self):
                return [Cs().A()]

        class A(CategoryWithAxiom):
            def extra_super_categories(self):
                return [Cs().A1(), Cs().A2()]
```


However this triggers an infinite recursion loop:

```
    sage: Cs().A()
    RuntimeError: maximum recursion depth exceeded while calling a Python object
```


This is because `Cs().A2().A1_extra_super_categories()` does not
return a strict super category of the to-be-constructed category,
which is forbidden by the current specifications:

http://doc.sagemath.org/html/en/reference/categories/sage/categories/category_with_axiom.html#id2

A workaround is to define A (or A1, or A2) in some super category:

```
    class C0(Category):
        def super_categories(self):
            return [Objects()]
        class SubcategoryMethods:
            def A(self):
                return self._with_axiom("A")
        class A(CategoryWithAxiom):
            pass

    class C1(Category):
        def super_categories(self):
            return [C0()]

        class SubcategoryMethods:
            def A1(self):
                return self._with_axiom("A1")
            def A2(self):
                return self._with_axiom("A2")

        class A1(CategoryWithAxiom):
            pass

        class A2(CategoryWithAxiom):
            def A1_extra_super_categories(self):
                return [C0.A()]

        class A(CategoryWithAxiom):
            def extra_super_categories(self):
                return [C1.A1(), C1.A2()]
```

Then,

```
    sage: C1().A1().A2() is C1().A()
    True
    sage: C1().A()
    Category of a1 a2 c1
    sage: C1().A().super_categories()
    [Category of a c0, Category of a2 c1, Category of a1 c1]
    sage: C1().A1().A2() is C1().A()
    True
```


A better idiom would be desirable, for cases where none of `A`, `A1`,
`A2` make sense in a strict super category.

See #18265 for a concrete instance where this workaround is currently
used.

Issue created by migration from https://trac.sagemath.org/ticket/20515


