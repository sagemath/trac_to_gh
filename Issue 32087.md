# Issue 32087: lazy_taylor_series

Issue created by migration from https://trac.sagemath.org/ticket/32324

Original creator: mantepse

Original creation time: 2021-08-02 07:14:26

CC:  tscrim @tejasvicsr1 slelievre




---

Comment by mantepse created at 2021-08-02 07:21:49

Last 10 new commits:


---

Comment by mantepse created at 2021-08-02 07:21:49

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2021-08-02 07:21:49

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2021-08-02 07:21:49

Changing keywords from "" to "LazyPowerSeries, FormalSeries".


---

Comment by git created at 2021-08-02 15:01:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-03 12:21:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-04 09:34:00

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2021-08-04 11:08:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-04 11:19:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-04 15:56:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-05 10:20:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-05 11:07:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-05 15:37:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-05 17:41:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-07 17:39:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-08 13:09:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-08 20:37:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-09 11:26:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-09 11:27:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-09 12:10:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-09 14:22:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-09 20:53:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-10 14:45:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-11 08:36:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-11 14:13:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-11 18:26:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-12 08:49:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-12 08:50:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-12 09:01:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-12 15:54:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-12 16:07:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 09:14:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 09:27:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 11:41:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 13:58:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-15 16:18:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-17 06:57:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-17 06:59:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-17 09:35:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-17 10:02:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-10-02 01:16:30

Here is an initial rebase over the recent changes. I had the manually add stuff in because the backporting was removing stuff from this branch, so it didn't actually add the code under a `git merge`. However, I believe I got everything.

There are a number of doctests that are failing, as well as additional work to bring it fully in line with the other tickets. Likely nearly all of the failures are related to a single issue as they all have error messages of the form:

```
TypeError: Could not find a mapping of the passed element to this ring.
```

However, I have yet to investigate.


---

Comment by git created at 2021-10-02 01:17:06

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2021-10-03 05:54:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-01-30 09:30:44

Trying to get back to this ticket :-)

* there are some failing doctests (essentially, the `polynomial` method is missing for `LazyTaylorSeries`, but used, in various doctests and in `LazyTaylorSeries.__call__`)
* if I recall correctly, we need to rethink `__call__` for some classes, because I was introducing a memory leak - part of the method probably has to be moved to `sage.data_structures.stream`.
* we define `self._laurent_poly_ring` and `self._internal_poly_ring` for various parents, but
  - they are undocumented
  - we use them in the element classes

* it might be good to have an overview somewhere, describing which gems we have created!

* we should have a doctest for implicitly defined lazy symmetric functions


---

Comment by git created at 2022-02-03 09:07:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-02-03 09:16:59

Replying to [comment:44 mantepse]:
> Trying to get back to this ticket :-)

Same here. `:)`

> * there are some failing doctests (essentially, the `polynomial` method is missing for `LazyTaylorSeries`, but used, in various doctests and in `LazyTaylorSeries.__call__`)

I have added this and fixed up other failing doctests.

> * if I recall correctly, we need to rethink `__call__` for some classes, because I was introducing a memory leak - part of the method probably has to be moved to `sage.data_structures.stream`.

I recall it was very specific with the `series()` implementation when it was passed in a `coefficient` function. I don't remember anything about `__call__` having a (potential) memleak, but I might be forgetting something. (I think we can use `R.zero()` instead of `R(0)` though.) Perhaps I wanted to use the underlying stream to build the new stream instead of the element class?

> * we define `self._laurent_poly_ring` and `self._internal_poly_ring` for various parents, but
>   - they are undocumented
>   - we use them in the element classes

They are attributes that are fairly self-documented and an implementation detail. So I don't feel the need to put much more in, especially in the public documentation. If you want to add a (code) comment, feel free to do so.

> * it might be good to have an overview somewhere, describing which gems we have created!

I agree that having a nice (thematic?) tutorial will be good. Although we can do it on a separate ticket.

> * we should have a doctest for implicitly defined lazy symmetric functions

Can you add this in?


---

Comment by git created at 2022-07-25 07:14:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-27 13:21:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-07-27 13:21:51

Changing status from new to needs_review.


---

Comment by tscrim created at 2022-07-28 00:30:54

Greetings from Singapore. I hope you are having a good trip back as well.

Two things from the patchbot that should be quick to fix:

1. Two of the new methods are lacking doctests (or being marked as `# indirect doctest`). Run `sage —coverage rings/lazy_series_ring.py` to see which ones.
2. Pyflakes fixes (see, e.g., patchbot).

I can do these next week once I get back to my office. Although if you do them before me, feel free to set this to a positive review once pushed.


---

Comment by mantepse created at 2022-07-28 13:40:06

Hi Travis!  I am at the gate, another 14 hours and I am at home :-)

These missing doctests were in fact hiding bugs and small shortcomings.  I fixed most of them (did not push yet), but I still have to fix `__call__` with second argument being a symmetric function (not lazy) and the analogous thing for multivariate Taylor.

The easy fix would be to convert the inner function(s) to their lazy versions first, and profile and optimize later, but I'm not sure whether that's the right approach.


---

Comment by tscrim created at 2022-07-28 13:49:28

Hopefully it wasn't any trouble getting back to Bangalore and to the airport from there. I am responding on the train on my phone, so I can't really check the code right now. Sorry about going off my memory here.

I am a bit split about this. In one sense, I like just doing the simple fix because that makes it work and behaves like the correct object, and it makes the code shorter. However, it is not correct because it returns an element in the wrong parent when we have a finite (exact) series. (E.g., evaluating a polynomial at an element of the base ring gives you a base ring element, not a polynomial.) It probably isn't too bad to separate these cases here (if we don't do it already). For the case when we have an infinite series, it is safe to convert it since we can't do better. Although perhaps we should raise an error in that case? What did we do for Laurent series?

Oh, I also thought of another minor point about the exactness. This depends on the exactness of the underlying field. I don't remember if we checked this or not. If we didn't get this right for Laurent series, then it should be a followup ticket. I can check this.


---

Comment by tscrim created at 2022-08-03 03:03:29

Now that I have looked at the code for Laurent series, we should convert the symmetric function over to a lazy one when doing `f(g)` when `f` is a not-known-to-be-finite lazy symmetric function and `g` is a symmetric function. This is what we do with lazy Laurent series, where composition implemented as a `Stream_function`. Lazy Taylor series will also follow the same model.

For exactness, we are just using the default from `Parent`, which returns `True`. However, it should also check the base ring (a la polynomials).


---

Comment by tscrim created at 2022-08-03 03:04:28

Also, if you could push where you are currently at, that way I can look at those changes. I can also work on the composition code if you are a bit busy right now too.


---

Comment by mantepse created at 2022-08-03 06:54:21

I don't have proper internet until Saturday. But I have no changes to the composition code which are worth keeping yet.

A tiny thing: maybe sparseness should dépend on the outer argument, not the inner.


---

Comment by tscrim created at 2022-08-04 02:20:04

No problem. I will just look at it next week.

I think sparseness (for compositions) should depend on the inner argument since the result should belong to the parent of the inner argument (to the extent it is possible). So having it depend on the outer argument breaks that principle.


---

Comment by git created at 2022-08-07 09:36:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-07 09:37:40

There is now one failing doctest in `LazySymmetricFunction.__call__`.


---

Comment by mantepse created at 2022-08-07 09:53:47

We currently distinguish between fully lazy and "exact" objects (where the underlying stream is eventually constant).

The advantage of keeping track of "exact" objects is, that we can test for zero in some cases, and possibly speed.

However, some operations on "exact" objects which in principle would produce "exact" objects again, such as multiplication in the Dirichlet ring, may produce objects of very large degree.  In such a case the full computation would be very time-consuming, so we switched it off, see `LazyDirichletSeries._mul_`.

Would it be feasible, and make sense, to introduce another class in the hierarchy of streams, which only asserts that the stream is eventually constant (possibly keeping track of the degree from which this must be the case), but does not perform the computations?

I am not sure how much performance we gain in the "exact" case in practice.  It is a fair bit of code.  (in `lazy_series.py`, we check 35 times `isinstance(*, Stream_exact)`.  If the performance gain is not important, maybe it would be even better to only keep track of the degree.


---

Comment by tscrim created at 2022-08-08 06:08:34

There is a difference between an element of a different ring and an element of the lazy ring, which is _independent_ of the internal implementation details of the lazy ring elements. The issue at hand is about how to handle elements in a different ring converting to coercing in. I just want to make sure you are not accidentally mixing the two issues.

I strongly believe we should keep the special cases for when it is exact. I agree that Dirichlet series is a special case because of the product structure. Even if (and that is a huge if) we agree to not support true exact arithmetic when possible, I don't think you are proposing will reduce much of the code because you still want to check the cases when we know it is exact (e.g., checking if an element is `0` or not). We could add support for this in `Stream_dirichlet_convolve`, but that should be a followup ticket.

Here is also a small demo of the speed improvements:

```
sage: R.<z> = LazyLaurentSeriesRing(QQ)
sage: f = R(lambda n: 1 if n < 3 else 0, valuation=0)
sage: f  # this caches the values
1 + z + z^2 + O(z^7)
sage: g = 1 + z + z^2
sage: %timeit (f * f)[0:5]
16.7 µs ± 66.6 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
sage: %timeit (g * g)[0:5]
14.1 µs ± 88.2 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)

sage: f = R(lambda n: 1 if n < 6 else 0, valuation=0)
sage: f
1 + z + z^2 + z^3 + z^4 + z^5 + O(z^7)
sage: g = 1 + z + z^2 + z^3 + z^4 + z^5
sage: %timeit (f * f)[0:11]
52.5 µs ± 244 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
sage: %timeit (g * g)[0:11]
32.1 µs ± 411 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
```

Of course, the non-exact computation could likely be made faster, but I doubt in a way that could compare to the exact one.


---

Comment by mantepse created at 2022-08-08 09:17:11

That's perfect!  Thank you for illustrating the performance difference.  I will try to add it somewhere as a comment.


---

Comment by mantepse created at 2022-08-08 09:51:14

I just noticed:

```
sage: L.<z> = LazyLaurentSeriesRing(ZZ)
sage: f = 1-z
sage: isinstance((f^-1)._coeff_stream, sage.data_structures.stream.Stream_exact)
True
sage: isinstance((1/f)._coeff_stream, sage.data_structures.stream.Stream_exact)
False
```



---

Comment by tscrim created at 2022-08-08 09:53:45

Dividing by an exact series is not always eventually constant, so it cannot be exact:

```
sage: 1 / (1 + z)
1 - z + z^2 - z^3 + z^4 - z^5 + z^6 + O(z^7)
```

We would have to work somewhat hard to check this.


---

Comment by tscrim created at 2022-08-08 09:56:02

Actually, we already do the work in `__invert__`. We just do not seem to have carried it over to division.


---

Comment by mantepse created at 2022-08-08 09:58:26

Replying to [comment:65 tscrim]:
> Actually, we already do the work in `__invert__`. We just do not seem to have carried it over to division.

That's what I should have written :-)


---

Comment by mantepse created at 2022-08-08 09:59:50

I'll work on `_div_`, so you can concentrate on `_call_`, OK?


---

Comment by tscrim created at 2022-08-08 10:04:08

Sounds good. Although I won't be able to get back to it until tomorrow (it is 7 PM here now and I am hungry `:)`).


---

Comment by mantepse created at 2022-08-09 21:37:30

I think I have an elegant way to preserve exactness in `_div_`, but it fails for series with symmetric functions as coefficients, because symmetric functions in sage do not inherit from ring :-(


---

Comment by git created at 2022-08-10 15:51:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-10 22:50:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-10 22:52:53

`_div_` should be working now, so the only missing thing is plethysm.


---

Comment by tscrim created at 2022-08-11 03:05:41

Good catch and fix for the Laurent polynomial `quo_rem()` bug.

I do not agree that

```
sage: L.<x, y> = LazyTaylorSeriesRing(QQ)
sage: 1 / (1 - y) # should be exact, but isn't
```

should be exact. What does it mean for an infinite multivariate series to be exact? It means each homogeneous component has the same value. However, that is not the case here. Exactness is hard for multivariate series. As another thing to consider, is `\sum_{i=0}^n (x*y)^n` exact?


---

Comment by git created at 2022-08-11 03:36:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-11 03:38:02

I fixed some other doctest failures because more things are exact (this is a good thing!). You did a great job with the division.

I also made it so that `valuation()` cannot return an `int` (it sometimes could do this). A general principle in Sage is to not return Python objects on user-facing methods. This could be problematic if someone tried to do `self.valuation().is_prime()`.

Now I will finish the plethysm. Sorry for being slow on this.


---

Comment by git created at 2022-08-11 03:45:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-11 08:34:43

Excellent!  I will add an alias `set` for `define` and a method `unknown` for the rings, for compatibility with padics.  I also fix the pyflakes notes.  These are very local changes.


---

Comment by mantepse created at 2022-08-11 09:08:42

Do you know whether it is correct that `1/(1-z)` calls `_div_`, and `(1-z)^-1` calls `_pow_` rather than `_invert_`?  Would it make sense to redirect these two?


---

Comment by mantepse created at 2022-08-11 09:55:23

We currently set `options = LazyLaurentSeriesRing.options` in the individual lazy ring classes.  Can I move this to the abstract base class `LazySeriesRing`?  I will try.


---

Comment by mantepse created at 2022-08-11 10:09:08

Can you remember why `LazyTaylorSeries` and `LazySymmetricFunctions` do not inherit from `LazySeries`?


---

Comment by mantepse created at 2022-08-11 10:14:10

Well, I made them inherit from `LazySeries` and moved `options` there, and all doctests pass, so it was probably by historical accident.


---

Comment by mantepse created at 2022-08-11 10:41:57

Sorry for being noisy: we have several identical implementations for the various rings:

* `zero`
* `one` (with minimal differences, I cannot tell yet, whether they are important)
* `characteristic` (missing in some classes)
* `_coerce_map_from_` (with one difference in the Dirichlet case)
* `_coerce_map_from_base_ring`

I will try to move these in a separate commit.


---

Comment by tscrim created at 2022-08-11 10:44:05

Replying to [comment:79 mantepse]:
> Do you know whether it is correct that `1/(1-z)` calls `_div_`, and `(1-z)^-1` calls `_pow_` rather than `_invert_`?  Would it make sense to redirect these two?

It is correct. Note also that `__pow__()` calls `generic_power()` calls `__invert__()`, which we can see by

```
sage: s = SymmetricFunctions(QQ).s()
sage: S = LazySymmetricFunctions(s)
sage: elt = 1 + S(s[2])
sage: f = elt^-1
sage: type(f._coeff_stream)
<class 'sage.data_structures.stream.Stream_cauchy_invert'>
sage: f._coeff_stream._series
<sage.data_structures.stream.Stream_exact object at 0x7fdffdc1cca0>

sage: f = 1 / elt
sage: type(f._coeff_stream)
<class 'sage.data_structures.stream.Stream_cauchy_mul'>
```

If we wanted `1 / (1-z)` to be an inverse, we would also need to check in `_div_` that the numerator is `1` or not (this might be a worthwhile optimization).


---

Comment by mantepse created at 2022-08-11 10:47:18

Meanwhile I discovered yet another (probable) bug:


```
sage: L.<z> = LazyTaylorSeriesRing(ZZ)
sage: s = L(None, valuation=1)
sage: s.define(z + (s^2+s(z^2))/2)
sage: s[0]
0
sage: s[1]
KeyError                                  Traceback (most recent call last)
File ~/sage-develop/src/sage/data_structures/stream.py:316, in Stream_inexact.__getitem__(self, n)
    315 try:
--> 316     c = self._cache[n]
    317 except KeyError:
...
RecursionError: maximum recursion depth exceeded
```

Note that this works with `LazyLaurentSeriesRing`.

I added the (failing) doctest.


---

Comment by tscrim created at 2022-08-11 10:47:47

comment:81, comment:82: Yes, I think this is all because we didn't have the ABC of `LazySeries` when we first did things and never migrated things over. This likely also applies to comment:83 too.


---

Comment by git created at 2022-08-11 10:49:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-11 11:15:40

In the Frobenius character of unlabeled trees test, I need to explicitly declare the `valuation = 1` when I add in a test for composing that the valuation is positive.


---

Comment by tscrim created at 2022-08-11 11:16:36

Can you also explain the logic behind the plethysm implementation? I have trouble understanding what is happening there.


---

Comment by mantepse created at 2022-08-11 11:17:40

The bug is in `LazyTaylorSeries.__call__`:

```
    def __call__(self, *g):
    ...
        coeff_stream = Stream_function(coefficient, R, P._sparse, 0)
        return P.element_class(P, coeff_stream)
```

It is not good enough to set the valuation to 0 here.


---

Comment by mantepse created at 2022-08-11 11:19:53

I also have trouble understanding plethysm :-)

Can you propose a time for a zoom meeting?  (I need a break for about half an hour now, though, and I currently do not have a whiteboard, but I have a tablet.)


---

Comment by git created at 2022-08-11 11:24:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-11 11:24:46

Sounds good. I sent you an email for scheduling a meeting.

I just pushed my changes for tonight. Dinner time for me. `:)`


---

Comment by mantepse created at 2022-08-11 11:38:23

Replying to [comment:88 tscrim]:
> In the Frobenius character of unlabeled trees test, I need to explicitly declare the `valuation = 1` when I add in a test for composing that the valuation is positive.

That should not really be necessary, because the valuation of `X*E(A)` (in fact, of `X*anything`)  is positive.


---

Comment by git created at 2022-08-11 14:56:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-12 04:35:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-12 04:43:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-12 04:46:39

There were actually a lot of issues with `LazyTaylorSeries.__call__` with handling different inputs to make it (mostly?) compatible with the lazy Laurent series. So most of the code added there is to handle when `f` is an infinite series but `g` is finite. I added more examples for compositions.

A principle of Sage is that the result of `__call__` should not depend on the elements, only the parents. Of course, we deliberately break this (infinite versus finite series), but it is mostly consistent now I believe.

I implemented an `is_exact` because it is not an exact ring when the base ring is not exact.

Added alias `plethysm = __call__`.

I moved the plethysm code into `Stream_plethysm`. I also made it smarter with only computing the terms in the necessary degrees. I couldn't do anything smarter than going through the power sums either.


---

Comment by mantepse created at 2022-08-12 07:58:00

I am very much impressed! 

Thank you so much!

I had a brief look at the html documentation, seems fine.
(there is one weird thing: the signatures of `compose` sometimes have `check` first, sometimes last, and never show the default value `True`, which is quite confusing)

I guess that the tutorial section should be rewritten, but I think it is good enough for now.  In fact, that might be a good project for a summer intern: unify the documentation of the power series classes.

Could you give it a positive review once you are happy?


---

Comment by git created at 2022-08-12 08:47:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-12 08:50:19

Thank you. I made a few other small fixes, in part because the doc wasn't building for me. Unfortunately Sphinx doesn't seem to be so good with keyword-only arguments; we just have to accept it. `:/`

If my changes are good, then you can set the positive review.

Thank you for all of your hard work on this.


---

Comment by mantepse created at 2022-08-12 09:30:50

Changing status from needs_review to positive_review.


---

Comment by mantepse created at 2022-08-12 09:31:33

It might be interesting to compare with fricas speed wise.


---

Comment by tscrim created at 2022-08-12 10:00:10

Replying to [comment:103 mantepse]:
> It might be interesting to compare with fricas speed wise.

Indeed, that would be good. I am curious to see how it compares.


---

Comment by mantepse created at 2022-08-12 10:45:02

I guess there is room for improvements:

```
sage: T.<X, Y> = LazyTaylorSeriesRing(QQ)
sage: S = 2*~(1+2*X+sqrt(1-4*X)-2*X*Y)
sage: %time _ = S[10]
CPU times: user 6.32 ms, sys: 0 ns, total: 6.32 ms
Wall time: 6.31 ms
sage: %time _ = S[100]
CPU times: user 1.45 s, sys: 0 ns, total: 1.45 s
Wall time: 1.45 s
sage: %time _ = S[200]
CPU times: user 13 s, sys: 8.03 ms, total: 13 s
Wall time: 13 s

sage: x = fricas("x::TaylorSeries Fraction Integer")
sage: y = fricas("y::TaylorSeries Fraction Integer")
sage: s = 2*(1+2*x+sqrt(1-4*x)-2*x*y).recip()
sage: %time _ = s.coefficient(10)
CPU times: user 1.98 ms, sys: 0 ns, total: 1.98 ms
Wall time: 3.86 ms
sage: %time _ = s.coefficient(100)
CPU times: user 2.36 ms, sys: 0 ns, total: 2.36 ms
Wall time: 301 ms
sage: %time _ = s.coefficient(200)
CPU times: user 0 ns, sys: 2.26 ms, total: 2.26 ms
Wall time: 2.28 s

sage: X, Y = S[10].variables(); S[200].coefficient({X:199, Y:1})
38258081747085632190083666133480795008333871737968781386233193048331692888394736170337405196826277395315492416836472
sage: s.coefficient(200).coefficient([fricas("'x"), fricas("'y")], [199, 1]).sage()
38258081747085632190083666133480795008333871737968781386233193048331692888394736170337405196826277395315492416836472
```



---

Comment by mantepse created at 2022-08-12 10:47:17


```
sage: %prun _ = S[200]
         4266270 function calls (105763 primitive calls) in 15.196 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
39710/398   12.348    0.000   14.627    0.037 stream.py:1373(get_coefficient)
4100012/1    2.200    0.000   15.195   15.195 stream.py:281(__getitem__)
    190/1    0.248    0.001   15.195   15.195 stream.py:2044(get_coefficient)
40470/20235    0.191    0.000   14.786    0.001 stream.py:1645(<genexpr>)
  760/380    0.169    0.000   14.918    0.039 {built-in method builtins.sum}
    40280    0.013    0.000    0.013    0.000 stream.py:553(__getitem__)
    39710    0.007    0.000    0.007    0.000 {method 'zero' of 'sage.rings.ring.Ring' objects}
  380/190    0.005    0.000   14.927    0.079 stream.py:1618(get_coefficient)
      190    0.004    0.000    0.004    0.000 lazy_series.py:2015(<lambda>)
      380    0.004    0.000    0.004    0.000 stream.py:170(__init__)
      380    0.001    0.000    0.007    0.000 stream.py:1356(__init__)
      380    0.001    0.000    0.005    0.000 stream.py:985(__init__)
      190    0.001    0.000   14.928    0.079 stream.py:1248(get_coefficient)
      190    0.001    0.000    0.001    0.000 lazy_series.py:1411(<lambda>)
      190    0.001    0.000   14.929    0.079 stream.py:1309(get_coefficient)
    191/1    0.001    0.000   15.195   15.195 stream.py:1922(get_coefficient)
      380    0.001    0.000    0.005    0.000 stream.py:773(get_coefficient)
     1140    0.000    0.000    0.000    0.000 {built-in method builtins.len}
      380    0.000    0.000    0.000    0.000 stream.py:111(__init__)
      380    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000   15.196   15.196 {built-in method builtins.exec}
      380    0.000    0.000    0.000    0.000 stream.py:1642(<genexpr>)
        1    0.000    0.000   15.195   15.195 lazy_series.py:199(__getitem__)
        1    0.000    0.000   15.195   15.195 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'parent' of 'sage.structure.element.Element' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}
        1    0.000    0.000    0.000    0.000 {method 'base_ring' of 'sage.structure.category_object.CategoryObject' objects}
```



---

Comment by tscrim created at 2022-08-12 11:08:07

Indeed, there is work that can likely be done. I wonder how much of it is because it is done in Python versus some of the other safety checks we do on objects versus actual implementation/algorithm. Seems that we are roughly 5x slower in this example.

My 2 cents of a wild guess where we can improve is in the composition. Perhaps we would be better squaring things to reduce the number of multiplications.


---

Comment by mantepse created at 2022-08-12 11:46:33

Renaming `stream.py` to `stream.pyx` reduces the time from 13s to 8.6s.

I don't think that FriCAS does anything extraordinarily intelligent.  It's just that the FriCAS language is much more efficient than python.


---

Comment by mantepse created at 2022-08-12 11:58:53

I just checked, I don't think FriCAS does anything special.  In case you are curious, the implementation for multivariate Taylor series is in `fricas/src/algebra/mts.spad`, `taylor.spad` and `sttaylor.spad`.  Here is the code for (Cauchy) multiplication.  Unfortunately, the original axiom team was fond of abbreviations: `ST` is for `Stream`, `A` is the ring, in our case multivariate polynomials, and `delay` is a special function that delays the computation.


```
    stmult(n0 : Integer, x0 : ST A, y0 : ST A, _
           ll0 : List A) : ST A == delay
        x := x0
        y := y0
        n := n0
        ll := ll0
        if empty? y then
             n < 0 => return empty()
             empty? x => return empty()
             x := rst x
        else
             c := frst y
             y := rst y
             if n < 0 and c = 0 then
                 return concat(0, stmult(n, x, y, ll))
             else
                 ll := cons(c, ll)
                 n := n + 1
        res : A := 0
        xp := x
        llp := ll
        for i in 0..n repeat
            empty? xp =>
                i = 0 => return empty()
                break
            res := res + frst xp * first(llp)
            llp := rest(llp)
            xp := rst xp
        -- make sure that when we multiply finite streams
        -- tail is explicitly empty
        explicitlyEmpty? rst x and
          explicitlyEmpty? y => concat(res, empty())
        concat(res, stmult(n, x, y, ll))

    (x : ST A) * (y : ST A) == delay
        empty? y => zro()
        empty? x => zro()
        stmult(-1, x, y, [])
```



---

Comment by mantepse created at 2022-08-12 12:20:21

Actually, I can only reproduce such a big difference with `sqrt`, but the FriCAS implementation seems to do exactly the same thing as we do.


---

Comment by mantepse created at 2022-08-12 12:28:27

I think I've got it: we use


```
        from .lazy_series_ring import LazyLaurentSeriesRing
        P = LazyLaurentSeriesRing(self.base_ring(), "z", sparse=self.parent()._sparse)
        exp = P(lambda k: 1/factorial(ZZ(k)), valuation=0)
        return exp(self.log() * n)
```


whereas FriCAS has a special implementation for rational powers.


---

Comment by tscrim created at 2022-08-12 13:26:18

We probably want to use

- for all rational powers: https://en.wikipedia.org/wiki/Nth_root#Infinite_series
- when the exponent is in the base ring: https://en.wikipedia.org/wiki/Binomial_approximation#Using_Taylor_Series

These will likely speed things up. Good for a followup ticket.


---

Comment by mantepse created at 2022-08-12 13:29:53

Here is the FriCAS implementation for rational powers.  (`RN` is `Fraction Integer`, `ST` is `Stream`,   `YS` is `Y$ParadoxicalCombinatorsForStreams(A)` and the top level function is `powern`)


```
      RATPOWERS : Boolean := A has "^": (A,RN) -> A

      smult : (RN, ST A) -> ST A
      smult(rn, x) == map(y +-> rn*y, x)

      powerrn : (RN, ST A, ST A) -> ST A
      powerrn(rn, x, c) == delay
        concat(1, integ(smult(rn + 1, c * deriv x)) - rst x * c)

      powern(rn, x) ==
        order : I := 0
        for n in 0.. repeat
          empty? x => return zro()
          not zero? frst x => (order := n; break)
          x := rst x
          n = 1000 =>
            error "^: series with many leading zero coefficients"
        (ord := (order exquo denom(rn))) case "failed" =>
          error "^: rational power does not exist"
        co := frst x
        if ord > 0 and rn < 0 then
           error "^: negative power does not exist"
        (invCo := recip co) case "failed" =>
           error "^ rational power of coefficient undefined"
-- This error message is misleading, isn't it? see sups.spad/cRationalPower
        power :=
          (co = 1) => YS(y +-> powerrn(rn, x, y))
          (denom rn) = 1 =>
            not negative?(num := numer rn) =>
-- It seems that this cannot happen, but I don't know why
              (co^num::NNI) * YS(y +-> powerrn(rn, (invCo::A)*x, y))
            (invCo::A)^((-num)::NNI) * YS(y +-> powerrn(rn, (invCo::A)*x, y))

          RATPOWERS => co^rn * YS(y +-> powerrn(rn, (invCo::A)*x, y))
          error "^ rational power of coefficient undefined"
        monom(1, (ord :: I) * numer(rn)) * power
```



---

Comment by mantepse created at 2022-08-12 13:36:39

See #34350


---

Comment by git created at 2022-08-12 14:00:10

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2022-08-12 14:00:10

Changing status from positive_review to needs_review.


---

Comment by mantepse created at 2022-08-12 14:00:25

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2022-08-13 10:07:55

Changing status from positive_review to needs_work.


---

Comment by chapoton created at 2022-08-13 10:07:55

hey, guys, the linter is not GREEN !

```
sage/rings/lazy_series.py:3472:9: E306 expected 1 blank line before a nested definition, found 0
1       E306 expected 1 blank line before a nested definition, found 0
```



---

Comment by git created at 2022-08-13 10:15:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-13 10:18:19

Frédéric, while I appreciate what you have done standardizing the code within Sage and trying to keep it consistent, I don't think this should warrant reverting a positive review for adding one blankline that, IMO, makes the code less readable because it disassociates the internal function definition from the use. Nevertheless, I have made the change requested.


---

Comment by tscrim created at 2022-08-13 10:18:19

Changing status from needs_work to positive_review.


---

Comment by chapoton created at 2022-08-13 11:00:55

oops, sorry for the inconvenience, apologies

I understand your point of view ; maybe we are going too far with the linter and should be more careful in choosing what to check.

My point is that the linter is going to be useful if and only if every single ticket makes sure not to break it again and again.


---

Comment by tscrim created at 2022-08-15 00:02:12

I broadly agree, but we should allow a certain amount of discretion to the ticket authors/reviewers. I really do not like that blankline required by the linter as it strongly affects the logical grouping of the code blocks.


---

Comment by mantepse created at 2022-08-15 10:29:50

On sage-devel several people were in favour of replacing Taylor with Power. While I a do not have a preference concerning the name, I would prefer a replacement to happen before the ticket is merged.


---

Comment by tscrim created at 2022-08-15 12:27:00

IMO that is best done as two separate tickets as the replacement might introduce bugs that are separate from this ticket. That ticket will also issue a formal deprecation of the LFPS.


---

Comment by mantepse created at 2022-08-15 12:30:37

Ok, But I d rather not go through a deprecation of lazy Taylor series


---

Comment by tscrim created at 2022-08-15 12:35:38

We can keep the alias since you want it )well, in the global namespace we would actually have LazyPowerSeriesRing be an alias for LazyTaylorSeriesRing). I have no objections to that (I am definitely not going to propose changing the class name in the file).


---

Comment by mantepse created at 2022-08-15 13:03:06

No, i do not want to keep an alias. I just do not want deprecations


---

Comment by vbraun created at 2022-08-30 19:05:29

Resolution: fixed
