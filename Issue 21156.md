# Issue 21156: Partial bindings for Ab polynomials with complex coefficients

Issue created by migration from https://trac.sagemath.org/ticket/21393

Original creator: mmezzarobba

Original creation time: 2016-09-01 16:00:07

CC:  cheuberg fredrik.johansson dkrenn

WIP


---

Comment by git created at 2016-09-04 08:58:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2016-09-04 09:05:39

Changing status from new to needs_review.


---

Comment by git created at 2016-09-05 12:17:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2016-09-13 21:54:03

What is the point of all these methods raising `NotImplementedError`?


---

Comment by vdelecroix created at 2016-09-13 21:56:33

You could check that `power_trunc` does work where `_power_trunc` has some overflow.


---

Comment by vdelecroix created at 2016-09-13 21:59:12

Changing status from needs_review to needs_work.


---

Comment by mmezzarobba created at 2016-09-14 07:53:41

Hi Vincent,

Thanks for your comments.

Replying to [comment:5 vdelecroix]:
> What is the point of all these methods raising `NotImplementedError`?

Documentation, mostly: I believe that every time a method can be implemented by several implementation variants of objects of some kind, there should be either a generic implementation or at least a stub raising `NotImplementedError` to specify the method name, arguments and semantics.

Replying to [comment:6 vdelecroix]:
> You could check that `power_trunc` does work where `_power_trunc` has some overflow.

Guessing you're thinking of `pol.power_trunc(very_large, small)`: no, it doesn't, because `polynomial_element.Polynomial` calls `_cmp_` on the coefficients calls `_cmp_` to check for equality, and that doesn't work with balls. There's a general problem here that goes well beyond the scope of this ticket. I could perhaps redefine comparison methods for polynomials with ball coefficients as a workaround, but I'd prefer to keep that for a separate ticket if you don't mind.


---

Comment by mmezzarobba created at 2016-09-14 07:53:41

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-09-14 07:59:30

Hi Marc,

Replying to [comment:8 mmezzarobba]:
> Hi Vincent,
> 
> Thanks for your comments.
> 
> Replying to [comment:5 vdelecroix]:
> > What is the point of all these methods raising `NotImplementedError`?
> 
> Documentation, mostly: I believe that every time a method can be implemented by several implementation variants of objects of some kind, there should be either a generic implementation or at least a stub raising `NotImplementedError` to specify the method name, arguments and semantics.

The problem with this approach is that you let these methods appear in the tab completion. With a well defined documentation. But these methods just not work. Not very user friendly.

> Replying to [comment:6 vdelecroix]:
> > You could check that `power_trunc` does work where `_power_trunc` has some overflow.
> 
> Guessing you're thinking of `pol.power_trunc(very_large, small)`: no, it doesn't, because `polynomial_element.Polynomial` calls `_cmp_` on the coefficients calls `_cmp_` to check for equality, and that doesn't work with balls. There's a general problem here that goes well beyond the scope of this ticket. I could perhaps redefine comparison methods for polynomials with ball coefficients as a workaround, but I'd prefer to keep that for a separate ticket if you don't mind.

Where in `power_trunc` you need to perform a call to `_cmp_`!? If some generic methods are broken, it should be mentioned somewhere. Or even overriden with `NotImplementedError`.


---

Comment by git created at 2016-09-14 08:52:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2016-09-14 08:52:33

Replying to [comment:9 vdelecroix]:
> > Documentation, mostly: I believe that every time a method can be implemented by several implementation variants of objects of some kind, there should be either a generic implementation or at least a stub raising `NotImplementedError` to specify the method name, arguments and semantics.
> 
> The problem with this approach is that you let these methods appear in the tab completion. With a well defined documentation. But these methods just not work. Not very user friendly.

I disagree: on the contrary, methods like `compose_trunc` are methods *of polynomials*, not of polynomials over whatever specific ring. They should ideally be implemented by all subclasses—they just aren't yet. It is much, much better IMO to have a method that doesn't work in all cases but has a docstring specifying what it is supposed to do *whenever* it works (allowing in particular to write generic code) than to have methods that make sense in all cases come and go (or exist but be inconsistent with each other) depending, e.g., what ring you are working on!

Besides, most of the stubs I added are for underscore methods, which the casual user isn't supposed to see in any case. That being said, I tried to improve the docstring of the public one to address your concern. What do you think?

> Where in `power_trunc` you need to perform a call to `_cmp_`!? If some generic methods are broken, it should be mentioned somewhere. Or even overriden with `NotImplementedError`.

Well, `generic_power_trunc` (which you wrote `:-)`) compares polynomials using `==`, which doesn't work over all coefficient rings, due to the way polynomial comparison is implemented—and to the general mess with comparisons. That's an issue that affects lots of operations with objects with interval or ball coefficients, I don't think it makes much sense to try to document it every time...
----
New commits:


---

Comment by vdelecroix created at 2016-09-14 09:05:14

Replying to [comment:11 mmezzarobba]:
> Replying to [comment:9 vdelecroix]:
> > > Documentation, mostly: I believe that every time a method can be implemented by several implementation variants of objects of some kind, there should be either a generic implementation or at least a stub raising `NotImplementedError` to specify the method name, arguments and semantics.
> > 
> > The problem with this approach is that you let these methods appear in the tab completion. With a well defined documentation. But these methods just not work. Not very user friendly.
> 
> I disagree: on the contrary, methods like `compose_trunc` are methods *of polynomials*, not of polynomials over whatever specific ring. They should ideally be implemented by all subclasses—they just aren't yet. It is much, much better IMO to have a method that doesn't work in all cases but has a docstring specifying what it is supposed to do *whenever* it works (allowing in particular to write generic code) than to have methods that make sense in all cases come and go (or exist but be inconsistent with each other) depending, e.g., what ring you are working on!
> 
> Besides, most of the stubs I added are for underscore methods, which the casual user isn't supposed to see in any case. That being said, I tried to improve the docstring of the public one to address your concern. What do you think?

At the end, the difference is

```
sage: my_object.my_method()  # current version
AttributeError
sage: my_object.my_method()  # your version
NotImplementedError
```

I do not see the real plus of what you did. The only reasonable way is to actually implement the generic version.

That being said, it is good that the base class defines the API for all the subclasses. But Python is not very suited for that purpose. I do not like methods that pretend to exist

```
def is_riemann_conjecture_true(self):
   r"""
   Answers whether the Riemann conjecture is valid
   """
   raise NotImplementedError
```


> > Where in `power_trunc` you need to perform a call to `_cmp_`!? If some generic methods are broken, it should be mentioned somewhere. Or even overriden with `NotImplementedError`.
> 
> Well, `generic_power_trunc` (which you wrote `:-)`) compares polynomials using `==`, which doesn't work over all coefficient rings, due to the way polynomial comparison is implemented—and to the general mess with comparisons. That's an issue that affects lots of operations with objects with interval or ball coefficients, I don't think it makes much sense to try to document it every time...

There is only one comparison of polynomials at

```
# check for idempotence, and store the result otherwise
cdef Polynomial a = p.truncate(prec)
cdef Polynomial aa = a._mul_trunc_(a, prec)
if aa == a:
    return a
```

If the answer is `False` for the comparison it does not matter at all.


---

Comment by mmezzarobba created at 2016-09-14 11:03:29

Replying to [comment:12 vdelecroix]:
> At the end, the difference is
> {{{
> sage: my_object.my_method()  # current version
> AttributeError
> sage: my_object.my_method()  # your version
> NotImplementedError
> }}}
> I do not see the real plus of what you did.

The main point is to define the API—both for the user and for implementers of subclasses, as you say yourself. Besides, to me, the first exception means “there's no such method”, period, while the second one means “the method makes sense, but doesn't work yet in the case you asked for”. It's no different from having a single generic implementation with several cases, only some of which are implemented.

> That being said, it is good that the base class defines the API for all the subclasses. But Python is not very suited for that purpose.

I agree with that `:-(`. And I'm not arguing that one should create such stub methods for things that are not implemented anywhere, only that, when one does implement something in one subclass with the intention that it could be generalized to other subclasses, it is a good idea to add a stub method in the common parent class where it makes sense (assuming there is one).


---

Comment by mmezzarobba created at 2016-09-14 12:29:58

Continuing my reply to [comment:12 vdelecroix]:
> There is only one comparison of polynomials at
> {{{
> # check for idempotence, and store the result otherwise
> cdef Polynomial a = p.truncate(prec)
> cdef Polynomial aa = a._mul_trunc_(a, prec)
> if aa == a:
>     return a
> }}}
> If the answer is `False` for the comparison it does not matter at all.

Sure, but that's not the problem. What happens is the following.


```
/home/marc/co/sage/src/sage/structure/element.pyx in sage.structure.element.Element._richcmp_ (build/cythonized/sage/structure/element.c:9542)()
    962         cdef int c
    963         try:
--> 964             c = left._cmp_(right)
    965         except NotImplementedError:
    966             # Check equality by id(), knowing that left is not right

/home/marc/co/sage/src/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial._cmp_ (build/cythonized/sage/rings/polynomial/polynomial_element.c:10924)()
    948         cdef int c
    949         for i in reversed(range(d1+1)):
--> 950             c = cmp(self[i], other[i])
    951             if c: return c
    952         return 0

/home/marc/co/sage/src/sage/structure/element.pyx in sage.structure.element.Element.__cmp__ (build/cythonized/sage/structure/element.c:9084)()
    871             if (<Element>left)._richcmp_(right, Py_EQ):
    872                 return 0
--> 873             if (<Element>left)._richcmp_(right, Py_LT):
    874                 return -1
    875             if (<Element>left)._richcmp_(right, Py_GT):

/home/marc/co/sage/src/sage/rings/complex_arb.pyx in sage.rings.complex_arb.ComplexBall._richcmp_ (build/cythonized/sage/rings/complex_arb.cpp:13232)()
   1567 
   1568         elif op == Py_GT or op == Py_GE or op == Py_LT or op == Py_LE:
-> 1569             raise TypeError("No order is defined for ComplexBalls.")
   1570 
   1571     def identical(self, ComplexBall other):

TypeError: No order is defined for ComplexBalls.
```


I'd say the main issue is that `Polynomial` implements `_cmp_()` rather than `_eq_()`, and does so by calling `cmp()` on the coefficients, even though the coefficient ring may not be totally ordered. But I don't think that's easy to fix, and in any case that's out of scope for this ticket.


---

Comment by tscrim created at 2016-09-14 15:17:04

Some quick comments. Instead of just returning a `NotImplementedError`, you should mark them with the ``@`abstract_method` decorator. That way `TestSuite(foo).run()` will fail saying not all methods are implemented. The doctests would then give a quick example of the working implementation. It at least is somewhat of a way to help get Python to have useful ABCs defining the API.


---

Comment by mmezzarobba created at 2016-09-14 15:36:18

Replying to [comment:15 tscrim]:
> Some quick comments. Instead of just returning a `NotImplementedError`, you should mark them with the ``@`abstract_method` decorator. That way `TestSuite(foo).run()` will fail saying not all methods are implemented. The doctests would then give a quick example of the working implementation. It at least is somewhat of a way to help get Python to have useful ABCs defining the API.

I'm not sure I understand: the documentation for ``@`abstract_method` says that (i) it is for methods that should be implemented by _all_ concrete derived classes (ii) it prevents from using `obj.method?` to access the documentation, while what I think I want is a method (i) that may be implemented by some derived classes only, and (ii) whose docstring can be accessed in the most standard possible way.


---

Comment by git created at 2016-10-11 15:06:50

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2016-10-12 14:22:17

Replying to [comment:16 mmezzarobba]:
> Replying to [comment:15 tscrim]:
> > Some quick comments. Instead of just returning a `NotImplementedError`, you should mark them with the ``@`abstract_method` decorator. That way `TestSuite(foo).run()` will fail saying not all methods are implemented. The doctests would then give a quick example of the working implementation. It at least is somewhat of a way to help get Python to have useful ABCs defining the API.
> 
> I'm not sure I understand: the documentation for ``@`abstract_method` says that (i) it is for methods that should be implemented by _all_ concrete derived classes (ii) it prevents from using `obj.method?` to access the documentation, while what I think I want is a method (i) that may be implemented by some derived classes only, and (ii) whose docstring can be accessed in the most standard possible way.

Sorry for not responding, I seem to have missed your post. In regards to (i), you can do ``@`abstract_method(optional=True)` to make it not mandatory. Doing this gives you a way to check if it is implemented (`obj.method == NotImplemented`), which is distinct from if something further down throws a `NotImplementedError`. For (ii), that is only when `obj.method` is not implemented by a concrete class, but otherwise it prevents `?` from getting the doc (which, because it is not implemented, it should not IMO).

However, all of those methods, implemented or not, do require at least one doctest.

I also don't see why you need the `_acb_poly_*` methods in the `.pxd` file, you don't call them anywhere in the code.

Similarly, you don't have any of the `_*_series` methods implemented. If you're trying to set the API for polynomials, I think that is better done on a separate ticket (since you aren't adding those methods here).


---

Comment by git created at 2016-10-12 17:58:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2016-10-12 18:09:39

Replying to [comment:19 tscrim]:
> Sorry for not responding, I seem to have missed your post. In regards to (i), you can do ``@`abstract_method(optional=True)` to make it not mandatory.

Oh, I didn't notice, thanks! However, ``@`abstract_method` doesn't seem to work on Cython code.

> For (ii), that is only when `obj.method` is not implemented by a concrete class, but otherwise it prevents `?` from getting the doc (which, because it is not implemented, it should not IMO).

I still disagree (because even in interactive use, I find it very important to know how general the methods you are calling are, what the siblings of the particular implementation you are calling are supposed to do, etc., so basically anything that makes this information more prominent is good to have from my point of view), but whatever.

> However, all of those methods, implemented or not, do require at least one doctest.

Added. I sometimes wonder how sage survives with such policies `:-/`...

> I also don't see why you need the `_acb_poly_*` methods in the `.pxd` file, you don't call them anywhere in the code.

I'm not sure I understand. If you're talking about the `.pwd` file under `libs/`, I put the complete API of `acb_poly` there (with some stuff commented e.g. when it depended on types I didn't want to import for no reason).

> Similarly, you don't have any of the `_*_series` methods implemented. If you're trying to set the API for polynomials, I think that is better done on a separate ticket (since you aren't adding those methods here).

I just took the opportunity to take care of the `_*_series` methods that already were implemented in other subclasses of `Polynomial` (cf. the commit message).

IMO the only thing that matters in the end are commits—tickets are just there to organize the review. But if you or anyone is willing to review some (reasonably consistent!) subset of the commits on this ticket, please say so, and I'll split the ticket (or just drop the remaining commits).
----
New commits:


---

Comment by git created at 2016-10-13 15:49:03

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2016-10-13 18:33:02

Replying to [comment:21 mmezzarobba]:
> Replying to [comment:19 tscrim]:
> > Sorry for not responding, I seem to have missed your post. In regards to (i), you can do ``@`abstract_method(optional=True)` to make it not mandatory.
> 
> Oh, I didn't notice, thanks! However, ``@`abstract_method` doesn't seem to work on Cython code.

Ah, crap, that's right. You can simply remove them because they (currently) don't work.

> > For (ii), that is only when `obj.method` is not implemented by a concrete class, but otherwise it prevents `?` from getting the doc (which, because it is not implemented, it should not IMO).
> 
> I still disagree (because even in interactive use, I find it very important to know how general the methods you are calling are, what the siblings of the particular implementation you are calling are supposed to do, etc., so basically anything that makes this information more prominent is good to have from my point of view), but whatever.

Well, it's moot for this ticket anyways.

> > However, all of those methods, implemented or not, do require at least one doctest.
> 
> Added. I sometimes wonder how sage survives with such policies `:-/`...

Well, it usually is a simple thing to do at least, but I can relate.

> > I also don't see why you need the `_acb_poly_*` methods in the `.pxd` file, you don't call them anywhere in the code.
> 
> I'm not sure I understand. If you're talking about the `.pwd` file under `libs/`, I put the complete API of `acb_poly` there (with some stuff commented e.g. when it depended on types I didn't want to import for no reason).

You only need to add things that you use into the `pxd` file since the library can handle its own internal calls. I think it makes it harder to maintain (more likely to get conflicts) and understand (more to sift through and confusing about what function to use).

> > Similarly, you don't have any of the `_*_series` methods implemented. If you're trying to set the API for polynomials, I think that is better done on a separate ticket (since you aren't adding those methods here).
> 
> I just took the opportunity to take care of the `_*_series` methods that already were implemented in other subclasses of `Polynomial` (cf. the commit message).

It's not clear that these should be included as part of the API of all polynomials, especially since they are hidden methods. Are they called indirectly by some (public) method of the base polynomial class?

> IMO the only thing that matters in the end are commits—tickets are just there to organize the review. But if you or anyone is willing to review some (reasonably consistent!) subset of the commits on this ticket, please say so, and I'll split the ticket (or just drop the remaining commits).

It's a matter of locality of searching trac tickets, but it's not that big of a deal.


---

Comment by git created at 2016-10-14 08:04:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2016-10-14 08:22:38

Replying to [comment:23 tscrim]:
> > > Sorry for not responding, I seem to have missed your post. In regards to (i), you can do ``@`abstract_method(optional=True)` to make it not mandatory.
> > 
> > Oh, I didn't notice, thanks! However, ``@`abstract_method` doesn't seem to work on Cython code.
> 
> Ah, crap, that's right. You can simply remove them because they (currently) don't work.

As you prefer.

> > I'm not sure I understand. If you're talking about the `.pwd` file under `libs/`, I put the complete API of `acb_poly` there (with some stuff commented e.g. when it depended on types I didn't want to import for no reason).
> 
> You only need to add things that you use into the `pxd` file since the library can handle its own internal calls. I think it makes it harder to maintain (more likely to get conflicts) and understand (more to sift through and confusing about what function to use).

Sorry, but I disagree again. We're talking about `.pxd` files _under `sage.libs`_: I believe these should reflect the API of the corresponding libraries or sub-libraries. I'm certainly planning to add more code using arb polynomials in the future, and I don't see the point of adding declarations from `acb_poly.h` one by one as I start to use them. Besides, users or external packages based on sage may very well want to call arb functions from cython too.

In fact, it would likely be a good idea to cut off these cython bindings from sage (once they are complete) and turn them into separate packages on which sage would depend (or work with the library developers to make them part of the upstream package), a bit like people seem to be doing with pari these days.

> > > Similarly, you don't have any of the `_*_series` methods implemented. If you're trying to set the API for polynomials, I think that is better done on a separate ticket (since you aren't adding those methods here).
> > 
> > I just took the opportunity to take care of the `_*_series` methods that already were implemented in other subclasses of `Polynomial` (cf. the commit message).
> 
> It's not clear that these should be included as part of the API of all polynomials, especially since they are hidden methods. Are they called indirectly by some (public) method of the base polynomial class?

Not exactly, but they are called (or at least intended to be callable, I don't know how things are standing now) by power series classes. So they certainly are part of the (sage-internal) API of polynomials.

Thanks again for your comments!


---

Comment by git created at 2016-11-17 09:05:47

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2016-11-17 09:06:55

(Rebased on top of 7.5β2, no other change.)


---

Comment by git created at 2016-11-23 09:44:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2016-11-23 09:44:57

The py3 plugin complains about `dict.iteritems()`, but I don't think it is appropriate to replace it, since it appears in a context where Cython can optimize it (while it apparently doesn't optimize `items()` or `six.iteritems()`). Any advice?


---

Comment by git created at 2016-12-02 13:52:37

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by tscrim created at 2016-12-02 15:02:18

IIRC, `iteritems` is okay in Cython files with Python3. So I believe you can ignore that.

I can accept the `_*_series` in that case. From looking at other files in `sage/libs`, I am okay with the `.pxd` file modulo the commented out lines: Either remove them or uncomment them.


---

Comment by tscrim created at 2016-12-02 15:02:41

PS - Sorry for letting this drop off my radar.


---

Comment by mmezzarobba created at 2016-12-02 15:19:24

Replying to [comment:31 tscrim]:
> I can accept the `_*_series` in that case. From looking at other files in `sage/libs`, I am okay with the `.pxd` file modulo the commented out lines: Either remove them or uncomment them.

Uncommenting them would require additional imports (that's why they were commented out), so I removed them. (This is inconsistent with what we did elsewhere under `sage/libs/arb`, however.)

Replying to [comment:32 tscrim]:
> PS - Sorry for letting this drop off my radar.

No problem! And thanks a lot for the review.


---

Comment by git created at 2016-12-02 15:22:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-12-02 15:26:25

Replying to [comment:33 mmezzarobba]:
> Replying to [comment:31 tscrim]:
> > I can accept the `_*_series` in that case. From looking at other files in `sage/libs`, I am okay with the `.pxd` file modulo the commented out lines: Either remove them or uncomment them.
> 
> Uncommenting them would require additional imports (that's why they were commented out), so I removed them. (This is inconsistent with what we did elsewhere under `sage/libs/arb`, however.)

I should have grep'ed rather than look by hand, and I see it in a few other places as well, e.g., `mpfr.pxd`. So you can revert that change and leave them in commented, sorry!


---

Comment by git created at 2016-12-02 15:34:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2016-12-02 15:57:49

Done.


---

Comment by tscrim created at 2016-12-02 16:20:50

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2016-12-02 16:20:50

Thank you.


---

Comment by vbraun created at 2016-12-03 08:14:53

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2016-12-03 08:14:53

On 32-bit:

```
7019sage -t --long src/sage/rings/polynomial/polynomial_complex_arb.pyx
7020**********************************************************************
7021File "src/sage/rings/polynomial/polynomial_complex_arb.pyx", line 545, in sage.rings.polynomial.polynomial_complex_arb.Polynomial_complex_arb._power_trunc
7022Failed example:
7023    (x^2 + 1)._power_trunc(10^10, 3)
7024Exception raised:
7025    Traceback (most recent call last):
7026      File "/home/buildbot/slave/sage_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 498, in _run
7027        self.compile_and_execute(example, compiler, test.globs)
7028      File "/home/buildbot/slave/sage_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 861, in compile_and_execute
7029        exec(compiled, globs)
7030      File "<doctest sage.rings.polynomial.polynomial_complex_arb.Polynomial_complex_arb._power_trunc[1]>", line 1, in <module>
7031        (x**Integer(2) + Integer(1))._power_trunc(Integer(10)**Integer(10), Integer(3))
7032      File "sage/rings/polynomial/polynomial_complex_arb.pyx", line 533, in sage.rings.polynomial.polynomial_complex_arb.Polynomial_complex_arb._power_trunc (/home/buildbot/slave/sage_git/build/src/build/cythonized/sage/rings/polynomial/polynomial_complex_arb.cpp:8624)
7033        cpdef Polynomial _power_trunc(self, unsigned long expo, long n):
7034    OverflowError: long int too large to convert
7035**********************************************************************
70361 item had failures:
7037   1 of   6 in sage.rings.polynomial.polynomial_complex_arb.Polynomial_complex_arb._power_trunc
7038    [113 tests, 1 failure, 0.31 s]
```



---

Comment by git created at 2016-12-03 09:59:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2016-12-03 10:02:42

Replying to [comment:39 vbraun]:
> On 32-bit:

Ooops! Thank you for the notice. I think this can go back to `positive_review`, but please complain if you disagree.


---

Comment by mmezzarobba created at 2016-12-03 10:02:42

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2016-12-05 00:44:29

Resolution: fixed
