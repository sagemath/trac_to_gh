# Issue 19828: Asymptotic Expansions: adaptive precision

Issue created by migration from Trac.

Original creator: cheuberg

Original creation time: 2016-02-16 15:12:03

CC:  dkrenn behackl

Keywords: performance

Try to predict the precision needed instead of relying on fixed default precision in order to speed up calulations.

Example:

```
sage: A.<n> = AsymptoticRing('n^QQ', QQ, default_prec=200)
sage: ex = 1/n + O(1/n^2); ex
n^(-1) + O(n^(-2))
sage: %time ex.subs(n=n+1)
CPU times: user 1min 4s, sys: 0 ns, total: 1min 4s
Wall time: 1min 4s
n^(-1) + O(n^(-2))
sage: A.<n> = AsymptoticRing('n^QQ', QQ, default_prec=5)
sage: ex = 1/n + O(1/n^2); ex
n^(-1) + O(n^(-2))
sage: %time ex.subs(n=n+1)
CPU times: user 56 ms, sys: 4 ms, total: 60 ms
Wall time: 51.5 ms
n^(-1) + O(n^(-2))
```

If inversion (or logarithm, exponentiation, generators of singularity analysis) accepted a parameter `initial_error` and started with this initial error instead of zero, then they would terminate much earlier (for inversion, logarithm, exponentiation) or could be modified to terminate much earlier (generators of singularity analysis). So substitution could start with the error terms and feed the current error into each successive step.
