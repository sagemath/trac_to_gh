# Issue 19828: Asymptotic Expansions: adaptive precision

archive/issues_019828.json:
```json
{
    "body": "CC:  dkrenn behackl\n\nKeywords: performance\n\nTry to predict the precision needed instead of relying on fixed default precision in order to speed up calulations.\n\nExample:\n\n```\nsage: A.<n> = AsymptoticRing('n^QQ', QQ, default_prec=200)\nsage: ex = 1/n + O(1/n^2); ex\nn^(-1) + O(n^(-2))\nsage: %time ex.subs(n=n+1)\nCPU times: user 1min 4s, sys: 0 ns, total: 1min 4s\nWall time: 1min 4s\nn^(-1) + O(n^(-2))\nsage: A.<n> = AsymptoticRing('n^QQ', QQ, default_prec=5)\nsage: ex = 1/n + O(1/n^2); ex\nn^(-1) + O(n^(-2))\nsage: %time ex.subs(n=n+1)\nCPU times: user 56 ms, sys: 4 ms, total: 60 ms\nWall time: 51.5 ms\nn^(-1) + O(n^(-2))\n```\n\nIf inversion (or logarithm, exponentiation, generators of singularity analysis) accepted a parameter `initial_error` and started with this initial error instead of zero, then they would terminate much earlier (for inversion, logarithm, exponentiation) or could be modified to terminate much earlier (generators of singularity analysis). So substitution could start with the error terms and feed the current error into each successive step.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20065\n\n",
    "created_at": "2016-02-16T15:12:03Z",
    "labels": [
        "asymptotic expansions",
        "major",
        "enhancement"
    ],
    "title": "Asymptotic Expansions: adaptive precision",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19828",
    "user": "cheuberg"
}
```
CC:  dkrenn behackl

Keywords: performance

Try to predict the precision needed instead of relying on fixed default precision in order to speed up calulations.

Example:

```
sage: A.<n> = AsymptoticRing('n^QQ', QQ, default_prec=200)
sage: ex = 1/n + O(1/n^2); ex
n^(-1) + O(n^(-2))
sage: %time ex.subs(n=n+1)
CPU times: user 1min 4s, sys: 0 ns, total: 1min 4s
Wall time: 1min 4s
n^(-1) + O(n^(-2))
sage: A.<n> = AsymptoticRing('n^QQ', QQ, default_prec=5)
sage: ex = 1/n + O(1/n^2); ex
n^(-1) + O(n^(-2))
sage: %time ex.subs(n=n+1)
CPU times: user 56 ms, sys: 4 ms, total: 60 ms
Wall time: 51.5 ms
n^(-1) + O(n^(-2))
```

If inversion (or logarithm, exponentiation, generators of singularity analysis) accepted a parameter `initial_error` and started with this initial error instead of zero, then they would terminate much earlier (for inversion, logarithm, exponentiation) or could be modified to terminate much earlier (generators of singularity analysis). So substitution could start with the error terms and feed the current error into each successive step.

Issue created by migration from https://trac.sagemath.org/ticket/20065


