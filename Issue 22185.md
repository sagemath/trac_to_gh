# Issue 22185: Laplace transform involving time-shifts

archive/issues_022185.json:
```json
{
    "body": "CC:  @kcrisman @paulmasson @frederichan-IMJPRG @rwst\n\nKeywords: laplace, transform, symbolics, giac, heaviside\n\nSage allows to compute the inverse Laplace transform through Maxima's `ilt` function,\n\n```\n    sage: var('s t')\n    sage: inverse_laplace(1/s, s, t)\n    1\n```\n\nAn unevaluated expression is returned when no explicit inverse Laplace transform is computed, as in\n\n```\n    sage: inverse_laplace(exp(-s)/s, s, t)\n    ilt(e^(-s)/s, s, t)\n```\nThe result in this case is h(t-1), where h is the Heaviside step function. In Sage it is available as `heaviside`.\n\nThis problem in this ticket is to extend the current behavior of `inverse_laplace` to provide explicit expressions for proper real-rational functions with any number of real exponentials linear in the transform variable s (time-shifts) in the numerator. For consistency, the direct Laplace transform with a heaviside should also work as well.\n\nThese are some approaches:\n\n(1) Implement an in-house solution, possibly in the lines of [this answer](https://ask.sagemath.org/question/36656/how-to-find-inverse-laplace-transform/).\n\n(2) Add an `algorithm` flag that allows to choose `sympy` (similar to integration).\n\n(3) Interface with Giac/XCAS. With this package installed, it is possible to do:\n\n```\nsage: giac('invlaplace(exp(-s)/s, s, t)')\nHeaviside(t-1)\n``` \n\nIMHO, a combination of (2)-(3) is the more robust approach. A small set of experiments show that (3) is, at the time of writing, more convenient than `inverse_laplace_transform` of SymPy in terms of quality of solution and execution time. Unfortunately, the [giac interface](http://doc.sagemath.org/html/en/reference/interfaces/sage/interfaces/giac.html) does not currently support automatic translation back to the symbolic ring, as it does with SymPy objects via SR(..).\n\nAny recommendations?\n\nSee also: \n\n- [How to find inverse Laplace transform](https://ask.sagemath.org/question/36656/how-to-find-inverse-laplace-transform/)\n- [laplace(heaviside(t),t,s) doesn't return 1/s](https://ask.sagemath.org/question/33152/laplaceheavisidetts-doesnt-return-1s/)\n- [Inverse Laplace transforms of shifts](https://ask.sagemath.org/question/9013/inverse-laplace-transforms-of-shifts/)\n\nIssue created by migration from https://trac.sagemath.org/ticket/22422\n\n",
    "created_at": "2017-02-23T10:57:12Z",
    "labels": [
        "component: calculus"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Laplace transform involving time-shifts",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22185",
    "user": "https://github.com/mforets"
}
```
CC:  @kcrisman @paulmasson @frederichan-IMJPRG @rwst

Keywords: laplace, transform, symbolics, giac, heaviside

Sage allows to compute the inverse Laplace transform through Maxima's `ilt` function,

```
    sage: var('s t')
    sage: inverse_laplace(1/s, s, t)
    1
```

An unevaluated expression is returned when no explicit inverse Laplace transform is computed, as in

```
    sage: inverse_laplace(exp(-s)/s, s, t)
    ilt(e^(-s)/s, s, t)
```
The result in this case is h(t-1), where h is the Heaviside step function. In Sage it is available as `heaviside`.

This problem in this ticket is to extend the current behavior of `inverse_laplace` to provide explicit expressions for proper real-rational functions with any number of real exponentials linear in the transform variable s (time-shifts) in the numerator. For consistency, the direct Laplace transform with a heaviside should also work as well.

These are some approaches:

(1) Implement an in-house solution, possibly in the lines of [this answer](https://ask.sagemath.org/question/36656/how-to-find-inverse-laplace-transform/).

(2) Add an `algorithm` flag that allows to choose `sympy` (similar to integration).

(3) Interface with Giac/XCAS. With this package installed, it is possible to do:

```
sage: giac('invlaplace(exp(-s)/s, s, t)')
Heaviside(t-1)
``` 

IMHO, a combination of (2)-(3) is the more robust approach. A small set of experiments show that (3) is, at the time of writing, more convenient than `inverse_laplace_transform` of SymPy in terms of quality of solution and execution time. Unfortunately, the [giac interface](http://doc.sagemath.org/html/en/reference/interfaces/sage/interfaces/giac.html) does not currently support automatic translation back to the symbolic ring, as it does with SymPy objects via SR(..).

Any recommendations?

See also: 

- [How to find inverse Laplace transform](https://ask.sagemath.org/question/36656/how-to-find-inverse-laplace-transform/)
- [laplace(heaviside(t),t,s) doesn't return 1/s](https://ask.sagemath.org/question/33152/laplaceheavisidetts-doesnt-return-1s/)
- [Inverse Laplace transforms of shifts](https://ask.sagemath.org/question/9013/inverse-laplace-transforms-of-shifts/)

Issue created by migration from https://trac.sagemath.org/ticket/22422





---

archive/issue_comments_307791.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2017-02-27T05:28:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307791",
    "user": "https://github.com/mforets"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_307792.json:
```json
{
    "body": "Needs info (please see commit message) to transform heaviside via `_giac_()`. Example:\n\n```\n    sage: f = heaviside(x); f, type(f)\n    (heaviside(x), <type 'sage.symbolic.expression.Expression'>)\n    sage: fg = f._giac_(); fg,  type(fg)\n    (heaviside(x), <class 'sage.interfaces.giac.GiacElement'>)\n```\nBut `heaviside(x)` doesn't seem to be understood by giac.\n\n---\nNew commits:",
    "created_at": "2017-02-27T05:28:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307792",
    "user": "https://github.com/mforets"
}
```

Needs info (please see commit message) to transform heaviside via `_giac_()`. Example:

```
    sage: f = heaviside(x); f, type(f)
    (heaviside(x), <type 'sage.symbolic.expression.Expression'>)
    sage: fg = f._giac_(); fg,  type(fg)
    (heaviside(x), <class 'sage.interfaces.giac.GiacElement'>)
```
But `heaviside(x)` doesn't seem to be understood by giac.

---
New commits:



---

archive/issue_comments_307793.json:
```json
{
    "body": "Code looking good so far but needs doctests for all code branches. Minor: you seem to change spacing, there are empty hunks in the patch, check your editor configuration.",
    "created_at": "2017-02-27T06:17:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307793",
    "user": "https://github.com/rwst"
}
```

Code looking good so far but needs doctests for all code branches. Minor: you seem to change spacing, there are empty hunks in the patch, check your editor configuration.



---

archive/issue_comments_307794.json:
```json
{
    "body": "Replying to [comment:3 mforets]:\n> Needs info (please see commit message) to transform heaviside via `_giac_()`. Example:\n> \n> ```\n>     sage: f = heaviside(x); f, type(f)\n>     (heaviside(x), <type 'sage.symbolic.expression.Expression'>)\n>     sage: fg = f._giac_(); fg,  type(fg)\n>     (heaviside(x), <class 'sage.interfaces.giac.GiacElement'>)\n> ```\n> But `heaviside(x)` doesn't seem to be understood by giac.\n\nin giac it looks to be Heaviside, so you need to either translate the string or define it in giac:\n\n```\ngiac(\"'heaviside:=Heaviside'\")\nsage: giac(f).integrate(x,-1,2)\n2\nsage: f\nheaviside(x)\nsage: type(f)\n<type 'sage.symbolic.expression.Expression'>\n```\nsimilar with giacpy_sage which have a raw conversion to sage:\n\n```\nsage: from giacpy_sage import *\n// Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/\n// Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/\nHelp file /home/fred-dev/sage/develop/sage.develop/local/share/giac/doc/fr/aide_cas not found\nAdded 0 synonyms\nsage: libgiac('heaviside:=Heaviside')\n'Heaviside'\nsage: f=heaviside(x)\nsage: fg=libgiac(f)\nsage: fg.integrate(x,-1,2)\n2\nsage: type(fg.integrate(x,-1,2))\n<type 'giacpy_sage.Pygen'>\nsage: SR(fg.integrate(x,-1,2))\n2\nsage: type(SR(fg.integrate(x,-1,2)))\n<type 'sage.symbolic.expression.Expression'>\nsage: (fg.integrate(x,-1,2)).sage()\n2\nsage: type((fg.integrate(x,-1,2)).sage())\n<type 'sage.rings.integer.Integer'>\n```\nbut with Heaviside will be sent to SR as a raw string so you will need some translation back to heaviside also.",
    "created_at": "2017-02-27T11:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307794",
    "user": "https://github.com/frederichan-IMJPRG"
}
```

Replying to [comment:3 mforets]:
> Needs info (please see commit message) to transform heaviside via `_giac_()`. Example:
> 
> ```
>     sage: f = heaviside(x); f, type(f)
>     (heaviside(x), <type 'sage.symbolic.expression.Expression'>)
>     sage: fg = f._giac_(); fg,  type(fg)
>     (heaviside(x), <class 'sage.interfaces.giac.GiacElement'>)
> ```
> But `heaviside(x)` doesn't seem to be understood by giac.

in giac it looks to be Heaviside, so you need to either translate the string or define it in giac:

```
giac("'heaviside:=Heaviside'")
sage: giac(f).integrate(x,-1,2)
2
sage: f
heaviside(x)
sage: type(f)
<type 'sage.symbolic.expression.Expression'>
```
similar with giacpy_sage which have a raw conversion to sage:

```
sage: from giacpy_sage import *
// Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/
// Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/
Help file /home/fred-dev/sage/develop/sage.develop/local/share/giac/doc/fr/aide_cas not found
Added 0 synonyms
sage: libgiac('heaviside:=Heaviside')
'Heaviside'
sage: f=heaviside(x)
sage: fg=libgiac(f)
sage: fg.integrate(x,-1,2)
2
sage: type(fg.integrate(x,-1,2))
<type 'giacpy_sage.Pygen'>
sage: SR(fg.integrate(x,-1,2))
2
sage: type(SR(fg.integrate(x,-1,2)))
<type 'sage.symbolic.expression.Expression'>
sage: (fg.integrate(x,-1,2)).sage()
2
sage: type((fg.integrate(x,-1,2)).sage())
<type 'sage.rings.integer.Integer'>
```
but with Heaviside will be sent to SR as a raw string so you will need some translation back to heaviside also.



---

archive/issue_comments_307795.json:
```json
{
    "body": "`@`rws: ok, I am learning such things as doctesting in days84. for the spacing issue good that you pointed this out, I'll be more careful. BTW I use Atom editor, and thanks for the prompt feedback.\n\n`@`frederichan: thanks for the insight! I see that I could use the conversion at the script level. but then each new Sage function which for some reason needs it, would have to handle the conversion. does it make sense to define this at the level of the giac.py interface?",
    "created_at": "2017-03-08T12:13:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307795",
    "user": "https://github.com/mforets"
}
```

`@`rws: ok, I am learning such things as doctesting in days84. for the spacing issue good that you pointed this out, I'll be more careful. BTW I use Atom editor, and thanks for the prompt feedback.

`@`frederichan: thanks for the insight! I see that I could use the conversion at the script level. but then each new Sage function which for some reason needs it, would have to handle the conversion. does it make sense to define this at the level of the giac.py interface?



---

archive/issue_comments_307796.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-10T08:34:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307796",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307797.json:
```json
{
    "body": "this is a patch that seems to work :) \n\n* borrowed the `un_camel` method from the mathematica interface, hence conversion back to lowercase heaviside is not done in place\n* extended the conversion dictionary at `functions/generalized.py`, it does the job when calling _giac_()\n* to-do: add doctests",
    "created_at": "2017-03-10T08:41:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307797",
    "user": "https://github.com/mforets"
}
```

this is a patch that seems to work :) 

* borrowed the `un_camel` method from the mathematica interface, hence conversion back to lowercase heaviside is not done in place
* extended the conversion dictionary at `functions/generalized.py`, it does the job when calling _giac_()
* to-do: add doctests



---

archive/issue_comments_307798.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2017-03-10T08:41:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307798",
    "user": "https://github.com/mforets"
}
```

Changing status from needs_info to needs_work.



---

archive/issue_comments_307799.json:
```json
{
    "body": "Replying to [comment:8 mforets]:\n> this is a patch that seems to work :) \n> \n> * borrowed the `un_camel` method from the mathematica interface, hence conversion back to lowercase heaviside is not done in place\n \nThis works for `heaviside` but wil create problems for Sage functions with capital letters like `bessel_J`.",
    "created_at": "2017-03-13T00:13:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307799",
    "user": "https://github.com/paulmasson"
}
```

Replying to [comment:8 mforets]:
> this is a patch that seems to work :) 
> 
> * borrowed the `un_camel` method from the mathematica interface, hence conversion back to lowercase heaviside is not done in place
 
This works for `heaviside` but wil create problems for Sage functions with capital letters like `bessel_J`.



---

archive/issue_comments_307800.json:
```json
{
    "body": "Replying to [comment:9 paulmasson]:\n> Replying to [comment:8 mforets]:\n> > this is a patch that seems to work :) \n> > \n> > * borrowed the `un_camel` method from the mathematica interface, hence conversion back to lowercase heaviside is not done in place\n \n> This works for `heaviside` but wil create problems for Sage functions with capital letters like `bessel_J`.\n\nok, good. so i suppose the correct way is to implement a basic parser, as suggested in giac.py interface (my comments in #):\n\n```\n    def _sage_(self):\n        r\"\"\"\n        Convert a giac expression back to a Sage expression.\n\n        This currently does not implement a parser for the Giac output language,\n        therefore only very simple expressions will convert successfully.\n        Warning: List conversion is slow.\n        ...\n\n        \"\"\"\n        result = repr(self) # this is a string representation\n        if str(self.type()) != 'DOM_LIST' :\n            try:\n                from sage.symbolic.all import SR\n                result = giac2sage(result) # pattern matching e.g. Heaviside -> heaviside\n                return SR(result)\n            except Exception:\n                raise NotImplementedError(\"Unable to parse Giac output: %s\" % result)\n        else:\n            return [entry.sage() for entry in self]\n```\n\na first search for this kind of conversion in some other module didn't give me anything useful yet.",
    "created_at": "2017-03-13T20:34:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307800",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:9 paulmasson]:
> Replying to [comment:8 mforets]:
> > this is a patch that seems to work :) 
> > 
> > * borrowed the `un_camel` method from the mathematica interface, hence conversion back to lowercase heaviside is not done in place
 
> This works for `heaviside` but wil create problems for Sage functions with capital letters like `bessel_J`.

ok, good. so i suppose the correct way is to implement a basic parser, as suggested in giac.py interface (my comments in #):

```
    def _sage_(self):
        r"""
        Convert a giac expression back to a Sage expression.

        This currently does not implement a parser for the Giac output language,
        therefore only very simple expressions will convert successfully.
        Warning: List conversion is slow.
        ...

        """
        result = repr(self) # this is a string representation
        if str(self.type()) != 'DOM_LIST' :
            try:
                from sage.symbolic.all import SR
                result = giac2sage(result) # pattern matching e.g. Heaviside -> heaviside
                return SR(result)
            except Exception:
                raise NotImplementedError("Unable to parse Giac output: %s" % result)
        else:
            return [entry.sage() for entry in self]
```

a first search for this kind of conversion in some other module didn't give me anything useful yet.



---

archive/issue_comments_307801.json:
```json
{
    "body": "for the new keyword argument's name, i would vote for `engine` instead of `algorithm`.\nthe former is used for example in [base.py](https://github.com/sagemath/sage/blob/master/src/sage/geometry/polyhedron/base.py). the keyword `algorithm` is misleading: a given computational engine may implement different algorithms.",
    "created_at": "2017-03-14T08:01:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307801",
    "user": "https://github.com/mforets"
}
```

for the new keyword argument's name, i would vote for `engine` instead of `algorithm`.
the former is used for example in [base.py](https://github.com/sagemath/sage/blob/master/src/sage/geometry/polyhedron/base.py). the keyword `algorithm` is misleading: a given computational engine may implement different algorithms.



---

archive/issue_comments_307802.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-15T09:29:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307802",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307803.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-03-15T09:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307803",
    "user": "https://github.com/mforets"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_307804.json:
```json
{
    "body": "Replying to [comment:11 mforets]:\n> for the new keyword argument's name, i would vote for `engine` instead of `algorithm`.\n> the former is used for example in [base.py](https://github.com/sagemath/sage/blob/master/src/sage/geometry/polyhedron/base.py). the keyword `algorithm` is misleading: a given computational engine may implement different algorithms.\n\nWhile the term `engine` is more accurate, `algorithm` is already established for a variety of commands, such as `integrate` and `limit`. Isn't consistency in Sage more important? Unless you're proposing we change all such instances to `engine`.",
    "created_at": "2017-03-19T23:34:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307804",
    "user": "https://github.com/paulmasson"
}
```

Replying to [comment:11 mforets]:
> for the new keyword argument's name, i would vote for `engine` instead of `algorithm`.
> the former is used for example in [base.py](https://github.com/sagemath/sage/blob/master/src/sage/geometry/polyhedron/base.py). the keyword `algorithm` is misleading: a given computational engine may implement different algorithms.

While the term `engine` is more accurate, `algorithm` is already established for a variety of commands, such as `integrate` and `limit`. Isn't consistency in Sage more important? Unless you're proposing we change all such instances to `engine`.



---

archive/issue_comments_307805.json:
```json
{
    "body": "In the function `_giac2sage`, rather than recreating the conversion dictionary why not use `symbol_table` from `sage.libs.pynac.pynac`? That dictionary already contains all the defined conversions.\n\nI'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?\n\nIf `_un_camel` is no longer used, please remove it.",
    "created_at": "2017-03-19T23:45:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307805",
    "user": "https://github.com/paulmasson"
}
```

In the function `_giac2sage`, rather than recreating the conversion dictionary why not use `symbol_table` from `sage.libs.pynac.pynac`? That dictionary already contains all the defined conversions.

I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?

If `_un_camel` is no longer used, please remove it.



---

archive/issue_comments_307806.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-03-20T06:15:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307806",
    "user": "https://github.com/mforets"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_307807.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-21T05:45:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307807",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307808.json:
```json
{
    "body": "Replying to [comment:14 paulmasson]:\n> Replying to [comment:11 mforets]:\n> > for the new keyword argument's name, i would vote for `engine` instead of `algorithm`.\n> > the former is used for example in [base.py](https://github.com/sagemath/sage/blob/master/src/sage/geometry/polyhedron/base.py). the keyword `algorithm` is misleading: a given computational engine may implement different algorithms.\n\n> While the term `engine` is more accurate, `algorithm` is already established for a variety of commands, such as `integrate` and `limit`. Isn't consistency in Sage more important? \n\nYes, good remark.\n\n> Unless you're proposing we change all such instances to `engine`.\n\n\nNot now. Perhaps a better one is `interface`, since this name is used in the code and in the documentation.",
    "created_at": "2017-03-21T06:17:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307808",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:14 paulmasson]:
> Replying to [comment:11 mforets]:
> > for the new keyword argument's name, i would vote for `engine` instead of `algorithm`.
> > the former is used for example in [base.py](https://github.com/sagemath/sage/blob/master/src/sage/geometry/polyhedron/base.py). the keyword `algorithm` is misleading: a given computational engine may implement different algorithms.

> While the term `engine` is more accurate, `algorithm` is already established for a variety of commands, such as `integrate` and `limit`. Isn't consistency in Sage more important? 

Yes, good remark.

> Unless you're proposing we change all such instances to `engine`.


Not now. Perhaps a better one is `interface`, since this name is used in the code and in the documentation.



---

archive/issue_comments_307809.json:
```json
{
    "body": "Replying to [comment:15 paulmasson]:\n> In the function `_giac2sage`, rather than recreating the conversion dictionary why not use `symbol_table` from `sage.libs.pynac.pynac`? That dictionary already contains all the defined conversions.\n\n\nInteresting! After a first look, I don't quite understand how to use it. While in giac.py, it uses `SR(result)`, in the mathematica interface (which does use `symbol_table`), it calls a `_sage_repr()` and then `symbolic_expression_from_string` which receives a `locals` dictionary. For our use case, do we need to specifically pass a `locals` translation dictionary for heaviside, or it is automatically added from the definition of the function? \n\n> I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?\n> \n\n\nI suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection \"Giac interface\" under https://trac.sagemath.org/wiki/symbolics\n\n> If `_un_camel` is no longer used, please remove it.\n\n\nDone.",
    "created_at": "2017-03-22T08:46:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307809",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:15 paulmasson]:
> In the function `_giac2sage`, rather than recreating the conversion dictionary why not use `symbol_table` from `sage.libs.pynac.pynac`? That dictionary already contains all the defined conversions.


Interesting! After a first look, I don't quite understand how to use it. While in giac.py, it uses `SR(result)`, in the mathematica interface (which does use `symbol_table`), it calls a `_sage_repr()` and then `symbolic_expression_from_string` which receives a `locals` dictionary. For our use case, do we need to specifically pass a `locals` translation dictionary for heaviside, or it is automatically added from the definition of the function? 

> I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?
> 


I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection "Giac interface" under https://trac.sagemath.org/wiki/symbolics

> If `_un_camel` is no longer used, please remove it.


Done.



---

archive/issue_comments_307810.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-25T20:59:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307810",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307811.json:
```json
{
    "body": "Replying to [comment:19 mforets]:\n> Replying to [comment:15 paulmasson]:\n> > In the function `_giac2sage`, rather than recreating the conversion dictionary why not use `symbol_table` from `sage.libs.pynac.pynac`? That dictionary already contains all the defined conversions.\n\n> \n> Interesting! After a first look, I don't quite understand how to use it. While in giac.py, it uses `SR(result)`, in the mathematica interface (which does use `symbol_table`), it calls a `_sage_repr()` and then `symbolic_expression_from_string` which receives a `locals` dictionary. For our use case, do we need to specifically pass a `locals` translation dictionary for heaviside, or it is automatically added from the definition of the function? \n> \n\n\nOh! it works out of the box!! \n\n```\nsage: from sage.libs.pynac.pynac import symbol_table\nsage: symbol_table['giac'].copy()\n\n{'(1+sqrt(5))/2': golden_ratio,\n 'Dirac': dirac_delta,\n 'Heaviside': heaviside,\n 'pi': pi}\n```\n\nHow does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. \n\n> > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?\n> > \n\n> \n> I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection \"Giac interface\" under https://trac.sagemath.org/wiki/symbolics\n> \n> > If `_un_camel` is no longer used, please remove it.\n\n> \n> Done.",
    "created_at": "2017-03-25T22:33:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307811",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:19 mforets]:
> Replying to [comment:15 paulmasson]:
> > In the function `_giac2sage`, rather than recreating the conversion dictionary why not use `symbol_table` from `sage.libs.pynac.pynac`? That dictionary already contains all the defined conversions.

> 
> Interesting! After a first look, I don't quite understand how to use it. While in giac.py, it uses `SR(result)`, in the mathematica interface (which does use `symbol_table`), it calls a `_sage_repr()` and then `symbolic_expression_from_string` which receives a `locals` dictionary. For our use case, do we need to specifically pass a `locals` translation dictionary for heaviside, or it is automatically added from the definition of the function? 
> 


Oh! it works out of the box!! 

```
sage: from sage.libs.pynac.pynac import symbol_table
sage: symbol_table['giac'].copy()

{'(1+sqrt(5))/2': golden_ratio,
 'Dirac': dirac_delta,
 'Heaviside': heaviside,
 'pi': pi}
```

How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. 

> > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?
> > 

> 
> I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection "Giac interface" under https://trac.sagemath.org/wiki/symbolics
> 
> > If `_un_camel` is no longer used, please remove it.

> 
> Done.



---

archive/issue_comments_307812.json:
```json
{
    "body": "Replying to [comment:5 frederichan]:\n> Replying to [comment:3 mforets]:\n> > Needs info (please see commit message) to transform heaviside via `_giac_()`. Example:\n> > \n> > ```\n> >     sage: f = heaviside(x); f, type(f)\n> >     (heaviside(x), <type 'sage.symbolic.expression.Expression'>)\n> >     sage: fg = f._giac_(); fg,  type(fg)\n> >     (heaviside(x), <class 'sage.interfaces.giac.GiacElement'>)\n> > ```\n> > But `heaviside(x)` doesn't seem to be understood by giac.\n\n> in giac it looks to be Heaviside, so you need to either translate the string or define it in giac:\n> {{{\n> giac(\"'heaviside:=Heaviside'\")\n> sage: giac(f).integrate(x,-1,2)\n> 2\n> sage: f\n> heaviside(x)\n> sage: type(f)\n> <type 'sage.symbolic.expression.Expression'>\n> }}}\n> similar with giacpy_sage which have a raw conversion to sage:\n> \n> ```\n> sage: from giacpy_sage import *\n> // Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/\n> // Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/\n> Help file /home/fred-dev/sage/develop/sage.develop/local/share/giac/doc/fr/aide_cas not found\n> Added 0 synonyms\n> sage: libgiac('heaviside:=Heaviside')\n> 'Heaviside'\n> sage: f=heaviside(x)\n> sage: fg=libgiac(f)\n> sage: fg.integrate(x,-1,2)\n> 2\n> sage: type(fg.integrate(x,-1,2))\n> <type 'giacpy_sage.Pygen'>\n> sage: SR(fg.integrate(x,-1,2))\n> 2\n> sage: type(SR(fg.integrate(x,-1,2)))\n> <type 'sage.symbolic.expression.Expression'>\n> sage: (fg.integrate(x,-1,2)).sage()\n> 2\n> sage: type((fg.integrate(x,-1,2)).sage())\n> <type 'sage.rings.integer.Integer'>\n> ```\n> but with Heaviside will be sent to SR as a raw string so you will need some translation back to heaviside also.\n\n\nHi Frederic, \n\ni have a question in relation to this. In the 2nd line of `src/sage/giac.py`, there is `(You should prefer the cython interface: giacpy_sage and its libgiac command)`. Is this recommendation relevant to this ticket? \n\nBy the way, the 2nd option above (`giacpy_sage`) in my local sage install doesn't work, clearly some package is missing (is this expected for a 'standard package'?):\n\n```\nsage: from giacpy_sage import *\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\n<ipython-input-1-c91665cb8326> in <module>()\n----> 1 from giacpy_sage import *\n\nImportError: No module named giacpy_sage\n```\n\nA couple more remarks: I've checked for further info [here](http://doc.sagemath.org/html/en/reference/libs/index.html) but we have no `libgiac`. In `libs/giac.py`, i didn't understand if this code is particular for Groebner basis computations, or it is meant to be used more generally. Thanks!",
    "created_at": "2017-03-26T20:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307812",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:5 frederichan]:
> Replying to [comment:3 mforets]:
> > Needs info (please see commit message) to transform heaviside via `_giac_()`. Example:
> > 
> > ```
> >     sage: f = heaviside(x); f, type(f)
> >     (heaviside(x), <type 'sage.symbolic.expression.Expression'>)
> >     sage: fg = f._giac_(); fg,  type(fg)
> >     (heaviside(x), <class 'sage.interfaces.giac.GiacElement'>)
> > ```
> > But `heaviside(x)` doesn't seem to be understood by giac.

> in giac it looks to be Heaviside, so you need to either translate the string or define it in giac:
> {{{
> giac("'heaviside:=Heaviside'")
> sage: giac(f).integrate(x,-1,2)
> 2
> sage: f
> heaviside(x)
> sage: type(f)
> <type 'sage.symbolic.expression.Expression'>
> }}}
> similar with giacpy_sage which have a raw conversion to sage:
> 
> ```
> sage: from giacpy_sage import *
> // Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/
> // Giac share root-directory:/home/fred-dev/sage/develop/sage.develop/local/share/giac/
> Help file /home/fred-dev/sage/develop/sage.develop/local/share/giac/doc/fr/aide_cas not found
> Added 0 synonyms
> sage: libgiac('heaviside:=Heaviside')
> 'Heaviside'
> sage: f=heaviside(x)
> sage: fg=libgiac(f)
> sage: fg.integrate(x,-1,2)
> 2
> sage: type(fg.integrate(x,-1,2))
> <type 'giacpy_sage.Pygen'>
> sage: SR(fg.integrate(x,-1,2))
> 2
> sage: type(SR(fg.integrate(x,-1,2)))
> <type 'sage.symbolic.expression.Expression'>
> sage: (fg.integrate(x,-1,2)).sage()
> 2
> sage: type((fg.integrate(x,-1,2)).sage())
> <type 'sage.rings.integer.Integer'>
> ```
> but with Heaviside will be sent to SR as a raw string so you will need some translation back to heaviside also.


Hi Frederic, 

i have a question in relation to this. In the 2nd line of `src/sage/giac.py`, there is `(You should prefer the cython interface: giacpy_sage and its libgiac command)`. Is this recommendation relevant to this ticket? 

By the way, the 2nd option above (`giacpy_sage`) in my local sage install doesn't work, clearly some package is missing (is this expected for a 'standard package'?):

```
sage: from giacpy_sage import *
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
<ipython-input-1-c91665cb8326> in <module>()
----> 1 from giacpy_sage import *

ImportError: No module named giacpy_sage
```

A couple more remarks: I've checked for further info [here](http://doc.sagemath.org/html/en/reference/libs/index.html) but we have no `libgiac`. In `libs/giac.py`, i didn't understand if this code is particular for Groebner basis computations, or it is meant to be used more generally. Thanks!



---

archive/issue_comments_307813.json:
```json
{
    "body": "giacpy_sage is an optional spkg, but you should be able to install it.\n\nAll the files in interfaces are pexpect interfaces for external programs. Among them some (ex: pari, gap, singular) also have a cython interface that works with the c or C++ library directly. There was a wish to prefer the cython interface when avaible.\n\nBut as giacpy_sage is optional while giac went standard recently, and as calculus have old entries with the pexepect interface of giac, I think that it is not a problem to do work like this.\nBut indeed it is not natural to work on the pexpect interface too much.\n\nthe cython interface to giac is giacpy_sage and it superseeds the pexpect one, but your translation table could be imported by both. So when things will be decided I will update giacpy_sage also if it doesn't slow down conversions of huge expressions.",
    "created_at": "2017-03-27T08:33:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307813",
    "user": "https://github.com/frederichan-IMJPRG"
}
```

giacpy_sage is an optional spkg, but you should be able to install it.

All the files in interfaces are pexpect interfaces for external programs. Among them some (ex: pari, gap, singular) also have a cython interface that works with the c or C++ library directly. There was a wish to prefer the cython interface when avaible.

But as giacpy_sage is optional while giac went standard recently, and as calculus have old entries with the pexepect interface of giac, I think that it is not a problem to do work like this.
But indeed it is not natural to work on the pexpect interface too much.

the cython interface to giac is giacpy_sage and it superseeds the pexpect one, but your translation table could be imported by both. So when things will be decided I will update giacpy_sage also if it doesn't slow down conversions of huge expressions.



---

archive/issue_comments_307814.json:
```json
{
    "body": "NB: is the local dictionnary usefull? \nor is it better to keep conversions in one place. It seems one can always do this\n\n```\nsage.libs.pynac.pynac.register_symbol(heaviside,{'giac':'Heaviside'})\n```\nif some keyword is missing.",
    "created_at": "2017-03-27T10:18:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307814",
    "user": "https://github.com/frederichan-IMJPRG"
}
```

NB: is the local dictionnary usefull? 
or is it better to keep conversions in one place. It seems one can always do this

```
sage.libs.pynac.pynac.register_symbol(heaviside,{'giac':'Heaviside'})
```
if some keyword is missing.



---

archive/issue_comments_307815.json:
```json
{
    "body": "Replying to [comment:21 mforets]:\n> Replying to [comment:19 mforets]:\n> > Replying to [comment:15 paulmasson]:\n\n> How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. \nWhere I'm seeing this error often is when an expression has extra powers of the variable of integration, as for example\n\n```\ninverse_laplace(s^2*exp(-s)/(s-1),s,t,algorithm='giac')\n```\n\nwhich returns a derivative of the Dirac delta. At some point we'll want to be able to parse an indefinite number of such derivatives: do you want to do that on this ticket or another?\n> > > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?\n> > > \n\n> > \n> > I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection \"Giac interface\" under https://trac.sagemath.org/wiki/symbolics\n\nSounds fine. I'd be willing to include more Giac translations for special functions on a separate ticket, if you can point me to where the official list of Giac names is located. I'd also like to do some code cleanup on nearby lines pertaining to LaTeX representations in Sage, so if that doesn't bother you we can kill two birds with one stone.",
    "created_at": "2017-03-29T01:24:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307815",
    "user": "https://github.com/paulmasson"
}
```

Replying to [comment:21 mforets]:
> Replying to [comment:19 mforets]:
> > Replying to [comment:15 paulmasson]:

> How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. 
Where I'm seeing this error often is when an expression has extra powers of the variable of integration, as for example

```
inverse_laplace(s^2*exp(-s)/(s-1),s,t,algorithm='giac')
```

which returns a derivative of the Dirac delta. At some point we'll want to be able to parse an indefinite number of such derivatives: do you want to do that on this ticket or another?
> > > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?
> > > 

> > 
> > I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection "Giac interface" under https://trac.sagemath.org/wiki/symbolics

Sounds fine. I'd be willing to include more Giac translations for special functions on a separate ticket, if you can point me to where the official list of Giac names is located. I'd also like to do some code cleanup on nearby lines pertaining to LaTeX representations in Sage, so if that doesn't bother you we can kill two birds with one stone.



---

archive/issue_comments_307816.json:
```json
{
    "body": "Replying to [comment:24 frederichan]:\n> NB: is the local dictionnary usefull? \n> or is it better to keep conversions in one place. It seems one can always do this\n> \n> ```\n> sage.libs.pynac.pynac.register_symbol(heaviside,{'giac':'Heaviside'})\n> ```\n> if some keyword is missing.\n\nI agree with Frederic on this: if there is an existing method for extending the Pynac dictionary, then we should use that instead of introducing an additional dictionary. This method should probably be added to the documentation in `calculus.py`.\n\nFYI your documentation doesn't build right now because of unbalanced double backticks. Also, single backticks are what we use for inline LaTeX rendering in ReST, not dollar signs.",
    "created_at": "2017-03-29T01:30:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307816",
    "user": "https://github.com/paulmasson"
}
```

Replying to [comment:24 frederichan]:
> NB: is the local dictionnary usefull? 
> or is it better to keep conversions in one place. It seems one can always do this
> 
> ```
> sage.libs.pynac.pynac.register_symbol(heaviside,{'giac':'Heaviside'})
> ```
> if some keyword is missing.

I agree with Frederic on this: if there is an existing method for extending the Pynac dictionary, then we should use that instead of introducing an additional dictionary. This method should probably be added to the documentation in `calculus.py`.

FYI your documentation doesn't build right now because of unbalanced double backticks. Also, single backticks are what we use for inline LaTeX rendering in ReST, not dollar signs.



---

archive/issue_comments_307817.json:
```json
{
    "body": "Replying to [comment:25 paulmasson]:\n> Replying to [comment:21 mforets]:\n> > Replying to [comment:19 mforets]:\n> > > Replying to [comment:15 paulmasson]:\n\n> > How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. \n> Where I'm seeing this error often is when an expression has extra powers of the variable of integration, as for example\n> \n> \n> ```\n> inverse_laplace(s^2*exp(-s)/(s-1),s,t,algorithm='giac')\n> ```\n> \n> which returns a derivative of the Dirac delta. At some point we'll want to be able to parse an indefinite number of such derivatives: do you want to do that on this ticket or another?\n> > > > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?\n> > > > \n\n> > > \n> > > I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection \"Giac interface\" under https://trac.sagemath.org/wiki/symbolics\n\n> Sounds fine. I'd be willing to include more Giac translations for special functions on a separate ticket, if you can point me to where the official list of Giac names is located.\n\nIn the file:\n`local/share/giac/doc/aide_cas`\nlines starting by # \nare keywords followed by synonyms, next lines are for small doc and see also.\nfor full doc it is there:\n\nhttp://www-fourier.ujf-grenoble.fr/~parisse/giac/doc/en/cascmd_en/cascmd_en.html",
    "created_at": "2017-03-29T05:27:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307817",
    "user": "https://github.com/frederichan-IMJPRG"
}
```

Replying to [comment:25 paulmasson]:
> Replying to [comment:21 mforets]:
> > Replying to [comment:19 mforets]:
> > > Replying to [comment:15 paulmasson]:

> > How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. 
> Where I'm seeing this error often is when an expression has extra powers of the variable of integration, as for example
> 
> 
> ```
> inverse_laplace(s^2*exp(-s)/(s-1),s,t,algorithm='giac')
> ```
> 
> which returns a derivative of the Dirac delta. At some point we'll want to be able to parse an indefinite number of such derivatives: do you want to do that on this ticket or another?
> > > > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?
> > > > 

> > > 
> > > I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection "Giac interface" under https://trac.sagemath.org/wiki/symbolics

> Sounds fine. I'd be willing to include more Giac translations for special functions on a separate ticket, if you can point me to where the official list of Giac names is located.

In the file:
`local/share/giac/doc/aide_cas`
lines starting by # 
are keywords followed by synonyms, next lines are for small doc and see also.
for full doc it is there:

http://www-fourier.ujf-grenoble.fr/~parisse/giac/doc/en/cascmd_en/cascmd_en.html



---

archive/issue_comments_307818.json:
```json
{
    "body": "Replying to [comment:23 frederichan]:\n> giacpy_sage is an optional spkg, but you should be able to install it.\n> \n> All the files in interfaces are pexpect interfaces for external programs. Among them some (ex: pari, gap, singular) also have a cython interface that works with the c or C++ library directly. There was a wish to prefer the cython interface when avaible.\n> \n> But as giacpy_sage is optional while giac went standard recently, and as calculus have old entries with the pexepect interface of giac, I think that it is not a problem to do work like this.\n> But indeed it is not natural to work on the pexpect interface too much.\n> \n> the cython interface to giac is giacpy_sage and it superseeds the pexpect one, but your translation table could be imported by both. So when things will be decided I will update giacpy_sage also if it doesn't slow down conversions of huge expressions. \n\n\ngreat, thanks for the detailed answer! \n\ni wasn't aware about `register_symbol`, yes we should use it.\n\non the other hand, i tried to see how `locals` dictionary is used in other interfaces. i have the impression that it may be handy in some use cases, in the interactive mode. this example is from `mathematica.py`:\n\ncompare \n\n```\nsage: ex = giac('myFun(x)')\nsage: ex._sage_({'myFun': sin})\nsin(x)\n```\n\nto \n\n```\nsage: ex = giac('myFun(x)')\nsage: sage.libs.pynac.pynac.register_symbol(sin, {'giac':'myFun'})\nsage: ex._sage_()\nsin(x)\n```\n\nthe long import list is.. complicated.",
    "created_at": "2017-03-29T07:44:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307818",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:23 frederichan]:
> giacpy_sage is an optional spkg, but you should be able to install it.
> 
> All the files in interfaces are pexpect interfaces for external programs. Among them some (ex: pari, gap, singular) also have a cython interface that works with the c or C++ library directly. There was a wish to prefer the cython interface when avaible.
> 
> But as giacpy_sage is optional while giac went standard recently, and as calculus have old entries with the pexepect interface of giac, I think that it is not a problem to do work like this.
> But indeed it is not natural to work on the pexpect interface too much.
> 
> the cython interface to giac is giacpy_sage and it superseeds the pexpect one, but your translation table could be imported by both. So when things will be decided I will update giacpy_sage also if it doesn't slow down conversions of huge expressions. 


great, thanks for the detailed answer! 

i wasn't aware about `register_symbol`, yes we should use it.

on the other hand, i tried to see how `locals` dictionary is used in other interfaces. i have the impression that it may be handy in some use cases, in the interactive mode. this example is from `mathematica.py`:

compare 

```
sage: ex = giac('myFun(x)')
sage: ex._sage_({'myFun': sin})
sin(x)
```

to 

```
sage: ex = giac('myFun(x)')
sage: sage.libs.pynac.pynac.register_symbol(sin, {'giac':'myFun'})
sage: ex._sage_()
sin(x)
```

the long import list is.. complicated.



---

archive/issue_comments_307819.json:
```json
{
    "body": "Replying to [comment:25 paulmasson]:\n> Replying to [comment:21 mforets]:\n> > Replying to [comment:19 mforets]:\n> > > Replying to [comment:15 paulmasson]:\n\n> > How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. \n> Where I'm seeing this error often is when an expression has extra powers of the variable of integration, as for example\n> \n> \n> ```\n> inverse_laplace(s^2*exp(-s)/(s-1),s,t,algorithm='giac')\n> ```\n> \n> which returns a derivative of the Dirac delta. At some point we'll want to be able to parse an indefinite number of such derivatives: do you want to do that on this ticket or another?\n> > > > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?\n> > > > \n\n> > > \n> > > I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection \"Giac interface\" under https://trac.sagemath.org/wiki/symbolics\n\n> Sounds fine. I'd be willing to include more Giac translations for special functions on a separate ticket, if you can point me to where the official list of Giac names is located. I'd also like to do some code cleanup on nearby lines pertaining to LaTeX representations in Sage, so if that doesn't bother you we can kill two birds with one stone.\n\nOK. Please see the new ticket #22706. I also created a new subsection at [symbolics wiki](https://trac.sagemath.org/wiki/symbolics) to group these tickets. \n\nGood finding about the missing support for derivatives of dirac delta! In my opinion it is ok to solve it in a separate ticket, since originally we begun to discuss about transforming proper functions (in the jargon of control theory, meaning that deg numerator <= deg denominator).",
    "created_at": "2017-03-29T08:33:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307819",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:25 paulmasson]:
> Replying to [comment:21 mforets]:
> > Replying to [comment:19 mforets]:
> > > Replying to [comment:15 paulmasson]:

> > How does the new commit look? In particular, do you suggest to add more functionality relevant for this ticket? Can you supply an example with the `Unable to parse Giac output` message?  Thanks. 
> Where I'm seeing this error often is when an expression has extra powers of the variable of integration, as for example
> 
> 
> ```
> inverse_laplace(s^2*exp(-s)/(s-1),s,t,algorithm='giac')
> ```
> 
> which returns a derivative of the Dirac delta. At some point we'll want to be able to parse an indefinite number of such derivatives: do you want to do that on this ticket or another?
> > > > I'm also getting the `Unable to parse Giac output` error often. Partly that's because more Giac conversions need to be defined. Will that happen on this ticket or a separate one?
> > > > 

> > > 
> > > I suggest that we move on with this ticket for the basic functionality described above, and to create separate tickets to enhance the symbolics with the giac interface in separate ones (also add limit, integrate, solve). If you agree we can create a new subsection "Giac interface" under https://trac.sagemath.org/wiki/symbolics

> Sounds fine. I'd be willing to include more Giac translations for special functions on a separate ticket, if you can point me to where the official list of Giac names is located. I'd also like to do some code cleanup on nearby lines pertaining to LaTeX representations in Sage, so if that doesn't bother you we can kill two birds with one stone.

OK. Please see the new ticket #22706. I also created a new subsection at [symbolics wiki](https://trac.sagemath.org/wiki/symbolics) to group these tickets. 

Good finding about the missing support for derivatives of dirac delta! In my opinion it is ok to solve it in a separate ticket, since originally we begun to discuss about transforming proper functions (in the jargon of control theory, meaning that deg numerator <= deg denominator).



---

archive/issue_comments_307820.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-29T21:30:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307820",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307821.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-03-30T07:16:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307821",
    "user": "https://github.com/mforets"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_307822.json:
```json
{
    "body": "Oh, and we discussed previously on the `locals` dictionary at `giac.py` interface, and the consensus was to remove it. Could you please confirm? Thanks",
    "created_at": "2017-03-30T07:45:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307822",
    "user": "https://github.com/mforets"
}
```

Oh, and we discussed previously on the `locals` dictionary at `giac.py` interface, and the consensus was to remove it. Could you please confirm? Thanks



---

archive/issue_comments_307823.json:
```json
{
    "body": "IF you like this locals then it is OK for me, but a comment in giac.py code to remind and recommend how to use the table would be nice.\n\nby the way why not just:\n`result = giac.laplace(ex, s, t)`\n(it looks that the conversion is also done)",
    "created_at": "2017-03-30T09:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307823",
    "user": "https://github.com/frederichan-IMJPRG"
}
```

IF you like this locals then it is OK for me, but a comment in giac.py code to remind and recommend how to use the table would be nice.

by the way why not just:
`result = giac.laplace(ex, s, t)`
(it looks that the conversion is also done)



---

archive/issue_comments_307824.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-30T20:54:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307824",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307825.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-30T20:59:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307825",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_058677.json:
```json
{
    "actor": "https://github.com/paulmasson",
    "created_at": "2017-04-01T20:58:43Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "milestone": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22185#event-58677"
}
```



---

archive/issue_comments_307826.json:
```json
{
    "body": "Doctests all pass and documentation builds.\n\nSingle backticks typeset math so they render regular words in italic. All of the code terms in `giac.py` should be inside double backticks. Similarly, in `calculus.py` the word \"cond\" should be inside double backticks and one instance of \"F\" needs single backticks.\n\nThe documentation added to `giac.py` doesn't appear in the built documents because `_sage_` is a private method. Is this a deliberate choice? How does one access the documentation for this method?",
    "created_at": "2017-04-01T20:58:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307826",
    "user": "https://github.com/paulmasson"
}
```

Doctests all pass and documentation builds.

Single backticks typeset math so they render regular words in italic. All of the code terms in `giac.py` should be inside double backticks. Similarly, in `calculus.py` the word "cond" should be inside double backticks and one instance of "F" needs single backticks.

The documentation added to `giac.py` doesn't appear in the built documents because `_sage_` is a private method. Is this a deliberate choice? How does one access the documentation for this method?



---

archive/issue_comments_307827.json:
```json
{
    "body": "Replying to [comment:36 paulmasson]:\n> Doctests all pass and documentation builds.\n> \n> Single backticks typeset math so they render regular words in italic. All of the code terms in `giac.py` should be inside double backticks. Similarly, in `calculus.py` the word \"cond\" should be inside double backticks and one instance of \"F\" needs single backticks.\n\n\nApart from these cosmetics I think this ticket is fine.\n\n> The documentation added to `giac.py` doesn't appear in the built documents because `_sage_` is a private method. Is this a deliberate choice? How does one access the documentation for this method?\n\n\nAs far as I know there is no way to display such docstrings (I have struggled myself with this in the past). If something important is there it should be moved to the global documentation at the top of the file.",
    "created_at": "2017-04-05T15:20:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307827",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:36 paulmasson]:
> Doctests all pass and documentation builds.
> 
> Single backticks typeset math so they render regular words in italic. All of the code terms in `giac.py` should be inside double backticks. Similarly, in `calculus.py` the word "cond" should be inside double backticks and one instance of "F" needs single backticks.


Apart from these cosmetics I think this ticket is fine.

> The documentation added to `giac.py` doesn't appear in the built documents because `_sage_` is a private method. Is this a deliberate choice? How does one access the documentation for this method?


As far as I know there is no way to display such docstrings (I have struggled myself with this in the past). If something important is there it should be moved to the global documentation at the top of the file.



---

archive/issue_comments_307828.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-04-06T09:02:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307828",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_307829.json:
```json
{
    "body": "Replying to [comment:36 paulmasson]:\n> Doctests all pass and documentation builds.\n> \n> Single backticks typeset math so they render regular words in italic. All of the code terms in `giac.py` should be inside double backticks. Similarly, in `calculus.py` the word \"cond\" should be inside double backticks and one instance of \"F\" needs single backticks.\n> \n> The documentation added to `giac.py` doesn't appear in the built documents because `_sage_` is a private method. Is this a deliberate choice? How does one access the documentation for this method?\n\n\nthanks for the feedback. for the proper string/latex formatting that's good to fix. the problem i have with ReST is that it is absurdly picky when whitespace messes up the proper format; i think it's too much for 2017 but that's way the way it is i guess..\n\nanyway, in the new commits, both remarks have been addressed, taking into account the suggestion by rws, and improve a bit the tutorial.",
    "created_at": "2017-04-06T09:12:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307829",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:36 paulmasson]:
> Doctests all pass and documentation builds.
> 
> Single backticks typeset math so they render regular words in italic. All of the code terms in `giac.py` should be inside double backticks. Similarly, in `calculus.py` the word "cond" should be inside double backticks and one instance of "F" needs single backticks.
> 
> The documentation added to `giac.py` doesn't appear in the built documents because `_sage_` is a private method. Is this a deliberate choice? How does one access the documentation for this method?


thanks for the feedback. for the proper string/latex formatting that's good to fix. the problem i have with ReST is that it is absurdly picky when whitespace messes up the proper format; i think it's too much for 2017 but that's way the way it is i guess..

anyway, in the new commits, both remarks have been addressed, taking into account the suggestion by rws, and improve a bit the tutorial.



---

archive/issue_comments_307830.json:
```json
{
    "body": "Replying to [comment:37 rws]:\n> As far as I know there is no way to display such docstrings (I have struggled myself with this in the past). If something important is there it should be moved to the global documentation at the top of the file.\n\n\nsorry for the noise but is there a ticket for this already? just discovered that the algorithm description of [solve_linear_de](http://doc.sagemath.org/html/en/reference/power_series/sage/rings/power_series_ring_element.html#sage.rings.power_series_ring_element.PowerSeries.solve_linear_de) is great, but it is hidden (!)",
    "created_at": "2017-04-06T15:35:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307830",
    "user": "https://github.com/mforets"
}
```

Replying to [comment:37 rws]:
> As far as I know there is no way to display such docstrings (I have struggled myself with this in the past). If something important is there it should be moved to the global documentation at the top of the file.


sorry for the noise but is there a ticket for this already? just discovered that the algorithm description of [solve_linear_de](http://doc.sagemath.org/html/en/reference/power_series/sage/rings/power_series_ring_element.html#sage.rings.power_series_ring_element.PowerSeries.solve_linear_de) is great, but it is hidden (!)



---

archive/issue_comments_307831.json:
```json
{
    "body": "Patchbot has one error but I cannot confirm it, so we're good. Paul, I dared to add your name to reviewers---just change if you don't want that.",
    "created_at": "2017-04-08T05:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307831",
    "user": "https://github.com/rwst"
}
```

Patchbot has one error but I cannot confirm it, so we're good. Paul, I dared to add your name to reviewers---just change if you don't want that.



---

archive/issue_comments_307832.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-04-08T05:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307832",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_307833.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-04-10T22:25:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22185#issuecomment-307833",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_058678.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-04-10T22:25:10Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/22185",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22185#event-58678"
}
```
