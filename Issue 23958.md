# Issue 23958: Construction of an extension of a finite field should also create a coercion map.

Issue created by migration from Trac.

Original creator: klee

Original creation time: 2017-11-10 19:49:11

CC:  defeo

In Sage, finite fields automatically form a lattice of subfields of an algebraic closure except those constructed with explicit generator names. However, the following is counter-intuitive.


```
sage: k=GF(4)
sage: K=k.extension(3, name='a')
sage: k.is_subring(K)
False
sage: L=k.extension(3)
sage: k.is_subring(L)
True
```


This is because K is explicitly constructed as an extension of the finite field k, thus it is expected that k is regarded as a subfield of K. That is, there should be a coercion map of k into K.




---

Comment by git created at 2017-11-10 21:55:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-11-10 21:57:58

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2017-11-11 10:43:29

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-11-11 10:43:29

A little bit further in the code you can see

```
        # Use the canonical map if it exists.
        f = E.coerce_map_from(self)
        if f is None:
            from sage.categories.homset import Hom
            f = Hom(self, E).an_element()
        return (E, f)
```

It would make more sense to factor it with what you have done.

Moreover, with your changes I believe that the conditional statement above is not used anymore.


---

Comment by git created at 2017-11-12 10:08:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-11-12 10:11:42

Now let's see if patchbots complain. Meanwhile, Vincent, you might be interested in a companion ticket:

https://trac.sagemath.org/ticket/24170


---

Comment by vdelecroix created at 2017-11-12 11:18:05

Instead of a try/except as you did, don't you prefer first checking if there is an embedding as it used to be the case?

This is very hackish condition `not (hasattr(E, '_prefix') and hasattr(self, '_prefix'))`. What are you exactly testing with it?


---

Comment by klee created at 2017-11-12 12:09:02

Replying to [comment:9 vdelecroix]:
> Instead of a try/except as you did, don't you prefer first checking if there is an embedding as it used to be the case?

How is it possible? As far as I know, trying to know if there is an embedding closes the possibility to add new coercion map...

> This is very hackish condition `not (hasattr(E, '_prefix') and hasattr(self, '_prefix'))`. What are you exactly testing with it?

You can find similar condition in other parts of the file. So it is "standard" in the file. The condition is to test whether the finite field is part of the lattice of subfields of an algebraic closure. Thus if the condition is true, an automatic coercion is provided by the ecosystem of finite fields, and so there is no need to provide one intentionally.


---

Comment by git created at 2017-11-13 08:50:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-11-13 08:51:03

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2017-11-13 11:03:37

Could you move

```
if self.is_conway(): # and E is Conway
    alpha = E.gen()**((E.order()-1)//(self.order()-1))
else:
    alpha = self.modulus().roots(E)[0][0]
```

out of the `try/except` block?


---

Comment by klee created at 2017-11-13 11:27:28

Replying to [comment:13 vdelecroix]:
> Could you move
> {{{
> if self.is_conway(): # and E is Conway
>     alpha = E.gen()**((E.order()-1)//(self.order()-1))
> else:
>     alpha = self.modulus().roots(E)[0][0]
> }}}
> out of the `try/except` block?

No. Without the `try/except` block, you will get an exception when you want to get the same extension again. Do you have an alternative way to avoid this?


---

Comment by klee created at 2017-11-13 11:31:07

Replying to [comment:13 vdelecroix]:
> Could you move
> {{{
> if self.is_conway(): # and E is Conway
>     alpha = E.gen()**((E.order()-1)//(self.order()-1))
> else:
>     alpha = self.modulus().roots(E)[0][0]
> }}}
> out of the `try/except` block?

Ah, I misunderstood your suggestion! Ok. That is possible :-)


---

Comment by git created at 2017-11-13 11:36:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-11-14 07:21:32

Why calling `root` instead of `f = Hom(self, E).an_element()` as it used to be the case? Is your version better or faster?


---

Comment by klee created at 2017-11-17 08:04:29

Replying to [comment:17 vdelecroix]:
> Why calling `root` instead of `f = Hom(self, E).an_element()` as it used to be the case? Is your version better or faster?

I didn't know that `f = Hom(self, E).an_element()` does (almost) the same thing with my code using `roots`.

Anyway the `an_element()` method does a few additional condition checkings, which are redundant for our case. But these additional checkings would take negligible time, perhaps a few micro seconds.

The `an_element()` method eventually resolves to `any_root()` method for the modulus polynomial. Comparing `any_root()` and `roots()`, I got these interesting timings:

```
sage: F=GF(16)
sage: E=F.extension(2)
sage: timeit('f.any_root(E,assume_squarefree=True)')
125 loops, best of 3: 2.85 ms per loop
sage: timeit('f.roots(E)[0][0]')
125 loops, best of 3: 2.77 ms per loop
sage: F=GF(16)
sage: E=F.extension(2)
sage: f=F.modulus()
sage: timeit('f.roots(E)[0][0]')
125 loops, best of 3: 2.78 ms per loop
sage: timeit('f.any_root(E,assume_squarefree=True)')
125 loops, best of 3: 2.87 ms per loop
sage: F=GF(81)
sage: E=F.extension(3)
sage: f=F.modulus()
sage: timeit('f.any_root(E,assume_squarefree=True)')
125 loops, best of 3: 7.46 ms per loop
sage: timeit('f.roots(E)[0][0]')
125 loops, best of 3: 7.42 ms per loop
sage: E=F.extension(5)
sage: f=F.modulus()
sage: timeit('f.any_root(E,assume_squarefree=True)')
125 loops, best of 3: 6.17 ms per loop
sage: timeit('f.roots(E)[0][0]')
125 loops, best of 3: 6.13 ms per loop
```


This seems to indicate that finding all roots actually takes less time than finding any one root! 

My conclusion is that it is slightly better to construct the homomorphism directly using either `roots()` or `any_root()` as in my code than to use `Hom(self, E).an_element()`.  But I don't have any preference either to `roots()` or `any_root()`.


---

Comment by vdelecroix created at 2017-11-17 08:28:03

Replying to [comment:18 klee]:
> Replying to [comment:17 vdelecroix]:
> > Why calling `root` instead of `f = Hom(self, E).an_element()` as it used to be the case? Is your version better or faster?
> 
> I didn't know that `f = Hom(self, E).an_element()` does (almost) the same thing with my code using `roots`.
> 
> Anyway the `an_element()` method does a few additional condition checkings, which are redundant for our case. But these additional checkings would take negligible time, perhaps a few micro seconds.
> 
> The `an_element()` method eventually resolves to `any_root()` method for the modulus polynomial. Comparing `any_root()` and `roots()`, I got these interesting timings:
> {{{
> SNIP
> }}}
> 
> This seems to indicate that finding all roots actually takes less time than finding any one root! 
> 
> My conclusion is that it is slightly better to construct the homomorphism directly using either `roots()` or `any_root()` as in my code than to use `Hom(self, E).an_element()`.  But I don't have any preference either to `roots()` or `any_root()`.

Just for clearer code I would advocate for `any_root`. In the future, there is a hope for this method to be faster than `all_roots`. If `any_root` is slower, its implementation should just be `return self.all_roots()[0]`.


---

Comment by git created at 2017-11-17 14:17:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-11-18 17:37:25

Thanks!


---

Comment by vdelecroix created at 2017-11-18 17:37:25

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-12-14 12:39:58

Resolution: fixed
