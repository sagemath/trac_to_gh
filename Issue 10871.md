# Issue 10871: The Hash function for matrices has many collisions with permutation matrices:

Issue created by migration from https://trac.sagemath.org/ticket/10950

Original creator: nthiery

Original creation time: 2011-03-16 18:02:58

Assignee: jason, was

CC:  sage-combinat

Keywords: Weyl groups

The current hash function for generic dense matrices suffers from hard
collisions with permutation matrices. For example: all permutation
matrices of size 4 have hash 0!


```
    sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m
    sage: [ hash(mat(p)) for p in Permutations(4) ]
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```


In general, we would hope to get n! below:


```
    sage: len(set([ hash(mat(p)) for p in Permutations(1) ]))
    1
    sage: len(set([ hash(mat(p)) for p in Permutations(2) ]))
    1
    sage: len(set([ hash(mat(p)) for p in Permutations(3) ]))
    5
    sage: len(set([ hash(mat(p)) for p in Permutations(4) ]))
    1
    sage: len(set([ hash(mat(p)) for p in Permutations(5) ]))
    16
    sage: len(set([ hash(mat(p)) for p in Permutations(6) ]))
    16
    sage: len(set([ hash(mat(p)) for p in Permutations(7) ]))
    32
    sage: len(set([ hash(mat(p)) for p in Permutations(8) ]))
    1
```


I stumbled on this when profiling some code using Weyl groups that
heavily used caching (the hash of a weyl group element is the hash of
the underlying matrix). I gained a speed factor of 10x by just
tweaking the hash of matrices as in the attached patch. Now, I have no
idea if in general that would be a good hash for matrices, so please
some expert write an appropriate patch.

Cheers,
				Nicolas


---

Attachment


---

Comment by jhpalmieri created at 2011-03-16 20:20:35

Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.


---

Comment by nthiery created at 2011-03-16 22:02:10

Replying to [comment:3 jhpalmieri]:
> Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.

Oops. I changed my examples at the last minute, thinking that permutation matrices would feel less exotic than Weyl groups, but I forgot to actually check that my patch fixed the problem for those. Thanks for pointing this out!


---

Comment by nthiery created at 2011-03-16 22:02:10

Changing keywords from "Weyl groups" to "Weyl groups, permutation matrices, hash".


---

Comment by nthiery created at 2011-03-17 08:12:47

Oops again ... Please ignore the second attachment; it's a duplicate of the first. Anyone with power: feel free to delete


---

Comment by nthiery created at 2011-03-17 08:12:47

Changing assignee from jason, was to nthiery.


---

Comment by nbruin created at 2016-07-04 16:02:57

This is still true. I'd say it's just true of "dense" collections of matrices:

```
def imm(A):
    A.set_immutable()
    return A
```



```
sage: V={imm(matrix([a,b,c,d])) for a in [-1..1] for b in [-1..1] for c in [-1..1] for d in [-1..1]}
sage: H={hash(v) for v in V}
sage: Ht={hash(tuple(v.list())) for v in V}
sage: len(V); len (H); len(Ht)
81
14
69
```

so I think this problem might need a little bump in priority.


---

Comment by vdelecroix created at 2017-10-22 09:21:37

I opened #19050 while not knowing about this one! Funny numbers.

It would be easy to design a robust hash for dense matrices. But we do want to have the same hash for sparse and dense matrices. As a consequence the hash should just be computed from the set {`(i,j,v)`} of nonzero values `v` at position `(i,j)`. We could do a reasonable hash by asking this list to be sorted lexicographically in `(i,j)` (that would cost a `log(num of entries)`).

For polynomials this is exactly the same setting with the list `(exponent, coefficient)`. See #21284.

The question: for sparse matrices (respectively sparse or multivariate polynomials), would it be reasonable to sort the indices in the hash function?


---

Comment by jhpalmieri created at 2017-10-22 21:59:16

This may be a silly question, but why does this happen?

```
sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))
True
```



---

Comment by tscrim created at 2017-10-23 03:44:31

How about just doing a `frozenset` instead of sorting the tuples?


---

Comment by vdelecroix created at 2017-10-23 10:16:12

`@`tscrim: using `frozenset`, the hash function would be less robust and, more importantly, would be very hard to optimize in specialized classes. You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).


---

Comment by tscrim created at 2017-10-23 13:20:07

Replying to [comment:10 vdelecroix]:
> `@`tscrim: using `frozenset`, the hash function would be less robust

I don't see how, but maybe I don't understand what you think it will be less robust with respect to.

> and, more importantly, would be very hard to optimize in specialized classes.

I don't see why you would need to optimize the hash function. The bottleneck would be iterating over the non-zero values, which is (would be?) a separate method.

> You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).

Do you really want to sort a list of triples every time for sparse matrices? Inserting n objects into a hash table is much faster than that: O(n) vs O(n log n) for sorting them. We might want to consider (continuing) to cache the `__hash__` as well.

I also don't see why polynomials should come into an argument here.

However, here is another thought for a hash function:

```python
temp = [0,0,0]
for i,j in self.nonzero_positions():
    temp[0] += i
    temp[1] += j
    temp[2] += self[i,j]
return hash(tuple(temp))
```



---

Comment by vdelecroix created at 2017-10-23 14:12:52

First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.

Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.

A situation for which caching might be useful is when you have a "combinatorial" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).

Do you have more concrete situations where hashing is involved?

For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.

Concerning collisions, I don't believe your hash function was a serious proposal. Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.

The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.


---

Comment by jdemeyer created at 2017-10-23 14:35:08

Replying to [comment:8 jhpalmieri]:
> This may be a silly question, but why does this happen?
> {{{
> sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))
> True
> }}}

Interesting. This is how Python implements hashing for tuples:

```
sage: def tuplehash(t):
....:     n = len(t)
....:     x = 3430008
....:     for i in range(n):
....:         h = hash(t[i])
....:         x = (x ^^ h) * (1000003 + (82520 + 2*n)*i)
....:     return x + 97531
```

The resulting value should be reduced mod 2<sup>32</sup> or 2<sup>64</sup> depending on the system.

The reason for the collision is that `N ^^ -2 == -N` for any odd `N`. The choice of a XOR operation there is strange, since most simple hash functions would use addition instead. See https://en.wikipedia.org/wiki/Universal_hashing#Constructions for example.


---

Comment by jdemeyer created at 2017-10-23 14:41:31

Replying to [comment:11 tscrim]:
> However, here is another thought for a hash function:
> {{{#!python
> temp = [0,0,0]
> for i,j in self.nonzero_positions():
>     temp[0] += i
>     temp[1] += j
>     temp[2] += self[i,j]
> return hash(tuple(temp))
> }}}

I like the idea but not the concrete implementation. It does avoid sorting but there needs to be more mixing. Something like

```python
h = 0
for i,j in self.nonzero_positions():
    h += H(i, j, self[i,j])
return h
```

where `H` is a simple hash function.


---

Comment by jdemeyer created at 2017-10-23 14:45:02

Let me give this a shot...


---

Comment by tscrim created at 2017-10-23 23:57:45

Replying to [comment:12 vdelecroix]:
> First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.
> 
> Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.

It depends on what you mean by "considerable waste." In terms of computational complexity, it just adds to the constant (or probably would not even be contributing asymptotically for dense matrices). However, I do agree that it effectively doubles the memory footprint for dense matrices.

> A situation for which caching might be useful is when you have a "combinatorial" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).
> 
> Do you have more concrete situations where hashing is involved?

As you mentioned, when they are used for keys of a module implemented as a `dict`, such for `CombinatorialFreeModule` elements, or for defining objects such as `FiniteDimensionalAlgebra`. Granted, in these situations the matrices are relatively small.

> For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.

I have been doing a bunch of stuff with sparse matrices recently (computing representations of Lie algebras) and have encountered things that are optimized for dense matrices that are used by sparse matrices as well. So I'd appreciate it if we didn't make the hash worse for sparse matrices just because it is better of dense matrices.

> Concerning collisions, I don't believe your hash function was a serious proposal.

It was just a thought on how to remove the dependence on the order and not fully fleshed out. I know I'm less experienced in this area, but I am legitimately trying to help.

> Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.

I agree that it would not perform well in this case. What do you think about Jeoren's modification. I think it works well for both dense and sparse matrices and should work better than my proposal.

> The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.

For the multivariate polynomials, it looks like what is used is Jeroen's proposal. Although we could have a completely different solution for polynomials because the data structure for dense univariate is 1D and sparse k-variate are kD, whereas matrices are strictly 2D.


---

Comment by git created at 2017-10-24 15:30:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-10-24 15:38:00

Feel free to comment. This is essentially "needs review" except that I haven't run all doctests yet.


---

Comment by vdelecroix created at 2017-10-24 15:55:13

Nice! Would be interesting to test in conjunction with #23706.


---

Comment by vdelecroix created at 2017-10-24 15:56:41

Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?


---

Comment by jdemeyer created at 2017-10-24 19:11:17

Replying to [comment:25 vdelecroix]:
> Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?

Please elaborate. Why should I do that?


---

Comment by git created at 2017-10-24 19:14:11

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-10-24 19:14:32

Changing status from new to needs_review.


---

Comment by git created at 2017-10-25 08:10:03

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-10-25 08:17:08

Reorganized the code a bit, added documentation in `matrix0.pyx` to explain why I did things the way I did.


---

Comment by git created at 2017-10-25 08:20:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2017-10-25 09:35:44

Replying to [comment:26 jdemeyer]:
> Replying to [comment:25 vdelecroix]:
> > Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?
> 
> Please elaborate. Why should I do that?

To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.


---

Comment by jdemeyer created at 2017-10-25 09:41:38

Replying to [comment:32 vdelecroix]:
> To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.

On the other hand, you force every `Matrix` class to implement yet another method...

I'm not really convinced... in any case, that can wait for a follow-up ticket.


---

Comment by vdelecroix created at 2017-10-25 09:43:30

Replying to [comment:33 jdemeyer]:
> Replying to [comment:32 vdelecroix]:
> > To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.
> 
> On the other hand, you force every `Matrix` class to implement yet another method...

It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.

> I'm not really convinced... in any case, that can wait for a follow-up ticket.

Agreed, it can wait.


---

Comment by jdemeyer created at 2017-10-25 10:19:35

Replying to [comment:34 vdelecroix]:
> It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.

But that would add an extra level of indirection in the general case, slowing that down.


---

Comment by tscrim created at 2017-10-25 22:57:13

I don't think there should be any Python object getting created by `_get_unsafe`, just a pointer to a Python object. What would be a use-case for implementing a custom `_entry_hash`?

Anyways, since you say it can wait for a followup and this is a good improvement, I am setting it to a positive review. If you still want to discuss things first, feel free to revert.


---

Comment by tscrim created at 2017-10-25 22:57:13

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2017-10-26 06:43:25

Replying to [comment:36 tscrim]:
> I don't think there should be any Python object getting created by `_get_unsafe`

...only if the entries of the matrix are stored as Python objects. For many specialized classes (matrices over ZZ or over finite fields), the entries are stored in some C array, so `_get_unsafe()` does need to create a Python object.


---

Comment by vbraun created at 2017-10-30 07:41:31

Resolution: fixed


---

Comment by jdemeyer created at 2017-10-30 16:35:56

Some more comments:

This hash function is a lot better than the old one. However, it is far from perfect:

```
sage: M = diagonal_matrix([0, 1, -2, 1]); M.set_immutable(); hash(M)
0
```

Still, it is the best hash that I could come up with which is very efficient for sparse matrices: it takes time `O(s)` with `s` the number of non-zero entries of a matrix (independent of the size of the matrix). If you are willing to sort the indices (as suggested in [comment:7]), you get a better hash but with a runtime of `O(s log(s))`.
