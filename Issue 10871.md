# Issue 10871: The hash function for matrices suffers from many collisions

archive/issues_010871.json:
```json
{
    "body": "Assignee: @nthiery\n\nCC:  sage-combinat\n\nKeywords: Weyl groups, permutation matrices, hash\n\nThe current hash function for generic dense matrices suffers from hard collisions with permutation matrices. For example: all permutation matrices of size 4 have hash 0!\n\n```\n    sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m\n    sage: [ hash(mat(p)) for p in Permutations(4) ]\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\nI stumbled on this when profiling some code using Weyl groups that\nheavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices.\n\nCheers,\n\t\t\t\tNicolas\n\n\nAfter applying this branch:\n\n```\nsage: def hashmat(p): m = p.to_matrix(); m.set_immutable(); return hash(m)\nsage: len(set(hashmat(p) for p in Permutations(1)))\n1\nsage: len(set(hashmat(p) for p in Permutations(2)))\n2\nsage: len(set(hashmat(p) for p in Permutations(3)))\n6\nsage: len(set(hashmat(p) for p in Permutations(4)))\n24\nsage: len(set(hashmat(p) for p in Permutations(5)))\n120\nsage: len(set(hashmat(p) for p in Permutations(6)))\n720\nsage: len(set(hashmat(p) for p in Permutations(7)))\n5040\nsage: len(set(hashmat(p) for p in Permutations(8)))\n40320\n```\n\nAs extra bonus, this branch ensures that scalar matrices have the same hash as the scalar. This means one extra case where `A == B` implies `hash(A) == hash(B)`.\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/10950\n\n",
    "closed_at": "2017-10-30T07:41:31Z",
    "created_at": "2011-03-16T18:02:58Z",
    "labels": [
        "component: linear algebra",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "The hash function for matrices suffers from many collisions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/10871",
    "user": "https://github.com/nthiery"
}
```
Assignee: @nthiery

CC:  sage-combinat

Keywords: Weyl groups, permutation matrices, hash

The current hash function for generic dense matrices suffers from hard collisions with permutation matrices. For example: all permutation matrices of size 4 have hash 0!

```
    sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m
    sage: [ hash(mat(p)) for p in Permutations(4) ]
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

I stumbled on this when profiling some code using Weyl groups that
heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices.

Cheers,
				Nicolas


After applying this branch:

```
sage: def hashmat(p): m = p.to_matrix(); m.set_immutable(); return hash(m)
sage: len(set(hashmat(p) for p in Permutations(1)))
1
sage: len(set(hashmat(p) for p in Permutations(2)))
2
sage: len(set(hashmat(p) for p in Permutations(3)))
6
sage: len(set(hashmat(p) for p in Permutations(4)))
24
sage: len(set(hashmat(p) for p in Permutations(5)))
120
sage: len(set(hashmat(p) for p in Permutations(6)))
720
sage: len(set(hashmat(p) for p in Permutations(7)))
5040
sage: len(set(hashmat(p) for p in Permutations(8)))
40320
```

As extra bonus, this branch ensures that scalar matrices have the same hash as the scalar. This means one extra case where `A == B` implies `hash(A) == hash(B)`.



Issue created by migration from https://trac.sagemath.org/ticket/10950





---

archive/issue_comments_115257.json:
```json
{
    "body": "Attachment [trac_10950-hash_matrices-nt.patch](tarball://root/attachments/some-uuid/ticket10950/trac_10950-hash_matrices-nt.patch) by @nthiery created at 2011-03-16 18:07:11",
    "created_at": "2011-03-16T18:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115257",
    "user": "https://github.com/nthiery"
}
```

Attachment [trac_10950-hash_matrices-nt.patch](tarball://root/attachments/some-uuid/ticket10950/trac_10950-hash_matrices-nt.patch) by @nthiery created at 2011-03-16 18:07:11



---

archive/issue_comments_115258.json:
```json
{
    "body": "Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.",
    "created_at": "2011-03-16T20:20:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115258",
    "user": "https://github.com/jhpalmieri"
}
```

Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.



---

archive/issue_comments_115259.json:
```json
{
    "body": "Replying to [comment:3 jhpalmieri]:\n> Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.\n\n\nOops. I changed my examples at the last minute, thinking that permutation matrices would feel less exotic than Weyl groups, but I forgot to actually check that my patch fixed the problem for those. Thanks for pointing this out!",
    "created_at": "2011-03-16T22:02:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115259",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:3 jhpalmieri]:
> Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.


Oops. I changed my examples at the last minute, thinking that permutation matrices would feel less exotic than Weyl groups, but I forgot to actually check that my patch fixed the problem for those. Thanks for pointing this out!



---

archive/issue_comments_115260.json:
```json
{
    "body": "Changing keywords from \"Weyl groups\" to \"Weyl groups, permutation matrices, hash\".",
    "created_at": "2011-03-16T22:02:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115260",
    "user": "https://github.com/nthiery"
}
```

Changing keywords from "Weyl groups" to "Weyl groups, permutation matrices, hash".



---

archive/issue_comments_115261.json:
```json
{
    "body": "Oops again ... Please ignore the second attachment; it's a duplicate of the first. Anyone with power: feel free to delete",
    "created_at": "2011-03-17T08:12:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115261",
    "user": "https://github.com/nthiery"
}
```

Oops again ... Please ignore the second attachment; it's a duplicate of the first. Anyone with power: feel free to delete



---

archive/issue_comments_115262.json:
```json
{
    "body": "Changing assignee from jason, was to @nthiery.",
    "created_at": "2011-03-17T08:12:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115262",
    "user": "https://github.com/nthiery"
}
```

Changing assignee from jason, was to @nthiery.



---

archive/issue_comments_115263.json:
```json
{
    "body": "This is still true. I'd say it's just true of \"dense\" collections of matrices:\n\n```\ndef imm(A):\n    A.set_immutable()\n    return A\n```\n\n```\nsage: V={imm(matrix([a,b,c,d])) for a in [-1..1] for b in [-1..1] for c in [-1..1] for d in [-1..1]}\nsage: H={hash(v) for v in V}\nsage: Ht={hash(tuple(v.list())) for v in V}\nsage: len(V); len (H); len(Ht)\n81\n14\n69\n```\nso I think this problem might need a little bump in priority.",
    "created_at": "2016-07-04T16:02:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115263",
    "user": "https://github.com/nbruin"
}
```

This is still true. I'd say it's just true of "dense" collections of matrices:

```
def imm(A):
    A.set_immutable()
    return A
```

```
sage: V={imm(matrix([a,b,c,d])) for a in [-1..1] for b in [-1..1] for c in [-1..1] for d in [-1..1]}
sage: H={hash(v) for v in V}
sage: Ht={hash(tuple(v.list())) for v in V}
sage: len(V); len (H); len(Ht)
81
14
69
```
so I think this problem might need a little bump in priority.



---

archive/issue_comments_115264.json:
```json
{
    "body": "I opened #19050 while not knowing about this one! Funny numbers.\n\nIt would be easy to design a robust hash for dense matrices. But we do want to have the same hash for sparse and dense matrices. As a consequence the hash should just be computed from the set {`(i,j,v)`} of nonzero values `v` at position `(i,j)`. We could do a reasonable hash by asking this list to be sorted lexicographically in `(i,j)` (that would cost a `log(num of entries)`).\n\nFor polynomials this is exactly the same setting with the list `(exponent, coefficient)`. See #21284.\n\nThe question: for sparse matrices (respectively sparse or multivariate polynomials), would it be reasonable to sort the indices in the hash function?",
    "created_at": "2017-10-22T09:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115264",
    "user": "https://github.com/videlec"
}
```

I opened #19050 while not knowing about this one! Funny numbers.

It would be easy to design a robust hash for dense matrices. But we do want to have the same hash for sparse and dense matrices. As a consequence the hash should just be computed from the set {`(i,j,v)`} of nonzero values `v` at position `(i,j)`. We could do a reasonable hash by asking this list to be sorted lexicographically in `(i,j)` (that would cost a `log(num of entries)`).

For polynomials this is exactly the same setting with the list `(exponent, coefficient)`. See #21284.

The question: for sparse matrices (respectively sparse or multivariate polynomials), would it be reasonable to sort the indices in the hash function?



---

archive/issue_comments_115265.json:
```json
{
    "body": "This may be a silly question, but why does this happen?\n\n```\nsage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))\nTrue\n```",
    "created_at": "2017-10-22T21:59:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115265",
    "user": "https://github.com/jhpalmieri"
}
```

This may be a silly question, but why does this happen?

```
sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))
True
```



---

archive/issue_comments_115266.json:
```json
{
    "body": "How about just doing a `frozenset` instead of sorting the tuples?",
    "created_at": "2017-10-23T03:44:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115266",
    "user": "https://github.com/tscrim"
}
```

How about just doing a `frozenset` instead of sorting the tuples?



---

archive/issue_comments_115267.json:
```json
{
    "body": "`@`tscrim: using `frozenset`, the hash function would be less robust and, more importantly, would be very hard to optimize in specialized classes. You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).",
    "created_at": "2017-10-23T10:16:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115267",
    "user": "https://github.com/videlec"
}
```

`@`tscrim: using `frozenset`, the hash function would be less robust and, more importantly, would be very hard to optimize in specialized classes. You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).



---

archive/issue_comments_115268.json:
```json
{
    "body": "Replying to [comment:10 vdelecroix]:\n> `@`tscrim: using `frozenset`, the hash function would be less robust\n\n\nI don't see how, but maybe I don't understand what you think it will be less robust with respect to.\n\n> and, more importantly, would be very hard to optimize in specialized classes.\n\n\nI don't see why you would need to optimize the hash function. The bottleneck would be iterating over the non-zero values, which is (would be?) a separate method.\n\n> You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).\n\n\nDo you really want to sort a list of triples every time for sparse matrices? Inserting n objects into a hash table is much faster than that: O(n) vs O(n log n) for sorting them. We might want to consider (continuing) to cache the `__hash__` as well.\n\nI also don't see why polynomials should come into an argument here.\n\nHowever, here is another thought for a hash function:\n\n```python\ntemp = [0,0,0]\nfor i,j in self.nonzero_positions():\n    temp[0] += i\n    temp[1] += j\n    temp[2] += self[i,j]\nreturn hash(tuple(temp))\n```",
    "created_at": "2017-10-23T13:20:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115268",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:10 vdelecroix]:
> `@`tscrim: using `frozenset`, the hash function would be less robust


I don't see how, but maybe I don't understand what you think it will be less robust with respect to.

> and, more importantly, would be very hard to optimize in specialized classes.


I don't see why you would need to optimize the hash function. The bottleneck would be iterating over the non-zero values, which is (would be?) a separate method.

> You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).


Do you really want to sort a list of triples every time for sparse matrices? Inserting n objects into a hash table is much faster than that: O(n) vs O(n log n) for sorting them. We might want to consider (continuing) to cache the `__hash__` as well.

I also don't see why polynomials should come into an argument here.

However, here is another thought for a hash function:

```python
temp = [0,0,0]
for i,j in self.nonzero_positions():
    temp[0] += i
    temp[1] += j
    temp[2] += self[i,j]
return hash(tuple(temp))
```



---

archive/issue_comments_115269.json:
```json
{
    "body": "First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.\n\nLet me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.\n\nA situation for which caching might be useful is when you have a \"combinatorial\" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).\n\nDo you have more concrete situations where hashing is involved?\n\nFor sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.\n\nConcerning collisions, I don't believe your hash function was a serious proposal. Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.\n\nThe relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.",
    "created_at": "2017-10-23T14:12:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115269",
    "user": "https://github.com/videlec"
}
```

First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.

Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.

A situation for which caching might be useful is when you have a "combinatorial" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).

Do you have more concrete situations where hashing is involved?

For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.

Concerning collisions, I don't believe your hash function was a serious proposal. Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.

The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.



---

archive/issue_comments_115270.json:
```json
{
    "body": "Replying to [comment:8 jhpalmieri]:\n> This may be a silly question, but why does this happen?\n> \n> ```\n> sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))\n> True\n> ```\n\n\nInteresting. This is how Python implements hashing for tuples:\n\n```\nsage: def tuplehash(t):\n....:     n = len(t)\n....:     x = 3430008\n....:     for i in range(n):\n....:         h = hash(t[i])\n....:         x = (x ^^ h) * (1000003 + (82520 + 2*n)*i)\n....:     return x + 97531\n```\nThe resulting value should be reduced mod 2<sup>32</sup> or 2<sup>64</sup> depending on the system.\n\nThe reason for the collision is that `N ^^ -2 == -N` for any odd `N`. The choice of a XOR operation there is strange, since most simple hash functions would use addition instead. See https://en.wikipedia.org/wiki/Universal_hashing#Constructions for example.",
    "created_at": "2017-10-23T14:35:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115270",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:8 jhpalmieri]:
> This may be a silly question, but why does this happen?
> 
> ```
> sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))
> True
> ```


Interesting. This is how Python implements hashing for tuples:

```
sage: def tuplehash(t):
....:     n = len(t)
....:     x = 3430008
....:     for i in range(n):
....:         h = hash(t[i])
....:         x = (x ^^ h) * (1000003 + (82520 + 2*n)*i)
....:     return x + 97531
```
The resulting value should be reduced mod 2<sup>32</sup> or 2<sup>64</sup> depending on the system.

The reason for the collision is that `N ^^ -2 == -N` for any odd `N`. The choice of a XOR operation there is strange, since most simple hash functions would use addition instead. See https://en.wikipedia.org/wiki/Universal_hashing#Constructions for example.



---

archive/issue_comments_115271.json:
```json
{
    "body": "Replying to [comment:11 tscrim]:\n> However, here is another thought for a hash function:\n> \n> ```python\n> temp = [0,0,0]\n> for i,j in self.nonzero_positions():\n>     temp[0] += i\n>     temp[1] += j\n>     temp[2] += self[i,j]\n> return hash(tuple(temp))\n> ```\n\n\nI like the idea but not the concrete implementation. It does avoid sorting but there needs to be more mixing. Something like\n\n```python\nh = 0\nfor i,j in self.nonzero_positions():\n    h += H(i, j, self[i,j])\nreturn h\n```\nwhere `H` is a simple hash function.",
    "created_at": "2017-10-23T14:41:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115271",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:11 tscrim]:
> However, here is another thought for a hash function:
> 
> ```python
> temp = [0,0,0]
> for i,j in self.nonzero_positions():
>     temp[0] += i
>     temp[1] += j
>     temp[2] += self[i,j]
> return hash(tuple(temp))
> ```


I like the idea but not the concrete implementation. It does avoid sorting but there needs to be more mixing. Something like

```python
h = 0
for i,j in self.nonzero_positions():
    h += H(i, j, self[i,j])
return h
```
where `H` is a simple hash function.



---

archive/issue_events_028381.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-10-23T14:45:02Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "milestone": "sage-8.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10871#event-28381"
}
```



---

archive/issue_comments_115272.json:
```json
{
    "body": "Let me give this a shot...",
    "created_at": "2017-10-23T14:45:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115272",
    "user": "https://github.com/jdemeyer"
}
```

Let me give this a shot...



---

archive/issue_comments_115273.json:
```json
{
    "body": "Replying to [comment:12 vdelecroix]:\n> First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.\n> \n> Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.\n\n\nIt depends on what you mean by \"considerable waste.\" In terms of computational complexity, it just adds to the constant (or probably would not even be contributing asymptotically for dense matrices). However, I do agree that it effectively doubles the memory footprint for dense matrices.\n\n> A situation for which caching might be useful is when you have a \"combinatorial\" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).\n> \n> Do you have more concrete situations where hashing is involved?\n\n\nAs you mentioned, when they are used for keys of a module implemented as a `dict`, such for `CombinatorialFreeModule` elements, or for defining objects such as `FiniteDimensionalAlgebra`. Granted, in these situations the matrices are relatively small.\n\n> For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.\n\n\nI have been doing a bunch of stuff with sparse matrices recently (computing representations of Lie algebras) and have encountered things that are optimized for dense matrices that are used by sparse matrices as well. So I'd appreciate it if we didn't make the hash worse for sparse matrices just because it is better of dense matrices.\n\n> Concerning collisions, I don't believe your hash function was a serious proposal.\n\n\nIt was just a thought on how to remove the dependence on the order and not fully fleshed out. I know I'm less experienced in this area, but I am legitimately trying to help.\n\n> Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.\n\n\nI agree that it would not perform well in this case. What do you think about Jeoren's modification. I think it works well for both dense and sparse matrices and should work better than my proposal.\n\n> The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.\n\n\nFor the multivariate polynomials, it looks like what is used is Jeroen's proposal. Although we could have a completely different solution for polynomials because the data structure for dense univariate is 1D and sparse k-variate are kD, whereas matrices are strictly 2D.",
    "created_at": "2017-10-23T23:57:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115273",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:12 vdelecroix]:
> First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.
> 
> Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.


It depends on what you mean by "considerable waste." In terms of computational complexity, it just adds to the constant (or probably would not even be contributing asymptotically for dense matrices). However, I do agree that it effectively doubles the memory footprint for dense matrices.

> A situation for which caching might be useful is when you have a "combinatorial" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).
> 
> Do you have more concrete situations where hashing is involved?


As you mentioned, when they are used for keys of a module implemented as a `dict`, such for `CombinatorialFreeModule` elements, or for defining objects such as `FiniteDimensionalAlgebra`. Granted, in these situations the matrices are relatively small.

> For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.


I have been doing a bunch of stuff with sparse matrices recently (computing representations of Lie algebras) and have encountered things that are optimized for dense matrices that are used by sparse matrices as well. So I'd appreciate it if we didn't make the hash worse for sparse matrices just because it is better of dense matrices.

> Concerning collisions, I don't believe your hash function was a serious proposal.


It was just a thought on how to remove the dependence on the order and not fully fleshed out. I know I'm less experienced in this area, but I am legitimately trying to help.

> Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.


I agree that it would not perform well in this case. What do you think about Jeoren's modification. I think it works well for both dense and sparse matrices and should work better than my proposal.

> The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.


For the multivariate polynomials, it looks like what is used is Jeroen's proposal. Although we could have a completely different solution for polynomials because the data structure for dense univariate is 1D and sparse k-variate are kD, whereas matrices are strictly 2D.



---

archive/issue_comments_115274.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-24T15:30:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115274",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_115275.json:
```json
{
    "body": "Feel free to comment. This is essentially \"needs review\" except that I haven't run all doctests yet.",
    "created_at": "2017-10-24T15:38:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115275",
    "user": "https://github.com/jdemeyer"
}
```

Feel free to comment. This is essentially "needs review" except that I haven't run all doctests yet.



---

archive/issue_comments_115276.json:
```json
{
    "body": "Nice! Would be interesting to test in conjunction with #23706.",
    "created_at": "2017-10-24T15:55:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115276",
    "user": "https://github.com/videlec"
}
```

Nice! Would be interesting to test in conjunction with #23706.



---

archive/issue_comments_115277.json:
```json
{
    "body": "Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?",
    "created_at": "2017-10-24T15:56:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115277",
    "user": "https://github.com/videlec"
}
```

Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?



---

archive/issue_comments_115278.json:
```json
{
    "body": "Replying to [comment:25 vdelecroix]:\n> Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?\n\n\nPlease elaborate. Why should I do that?",
    "created_at": "2017-10-24T19:11:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115278",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:25 vdelecroix]:
> Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?


Please elaborate. Why should I do that?



---

archive/issue_comments_115279.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-10-24T19:14:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115279",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_115280.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-10-24T19:14:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115280",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_115281.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-10-25T08:10:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115281",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_115282.json:
```json
{
    "body": "Reorganized the code a bit, added documentation in `matrix0.pyx` to explain why I did things the way I did.",
    "created_at": "2017-10-25T08:17:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115282",
    "user": "https://github.com/jdemeyer"
}
```

Reorganized the code a bit, added documentation in `matrix0.pyx` to explain why I did things the way I did.



---

archive/issue_comments_115283.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-10-25T08:20:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115283",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_115284.json:
```json
{
    "body": "Replying to [comment:26 jdemeyer]:\n> Replying to [comment:25 vdelecroix]:\n> > Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?\n\n> \n> Please elaborate. Why should I do that?\n\n\nTo make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.",
    "created_at": "2017-10-25T09:35:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115284",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:26 jdemeyer]:
> Replying to [comment:25 vdelecroix]:
> > Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?

> 
> Please elaborate. Why should I do that?


To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.



---

archive/issue_comments_115285.json:
```json
{
    "body": "Replying to [comment:32 vdelecroix]:\n> To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.\n\n\nOn the other hand, you force every `Matrix` class to implement yet another method...\n\nI'm not really convinced... in any case, that can wait for a follow-up ticket.",
    "created_at": "2017-10-25T09:41:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115285",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:32 vdelecroix]:
> To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.


On the other hand, you force every `Matrix` class to implement yet another method...

I'm not really convinced... in any case, that can wait for a follow-up ticket.



---

archive/issue_comments_115286.json:
```json
{
    "body": "Replying to [comment:33 jdemeyer]:\n> Replying to [comment:32 vdelecroix]:\n> > To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.\n\n> \n> On the other hand, you force every `Matrix` class to implement yet another method...\n\n\nIt would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.\n\n> I'm not really convinced... in any case, that can wait for a follow-up ticket.\n\n\nAgreed, it can wait.",
    "created_at": "2017-10-25T09:43:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115286",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:33 jdemeyer]:
> Replying to [comment:32 vdelecroix]:
> > To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.

> 
> On the other hand, you force every `Matrix` class to implement yet another method...


It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.

> I'm not really convinced... in any case, that can wait for a follow-up ticket.


Agreed, it can wait.



---

archive/issue_comments_115287.json:
```json
{
    "body": "Replying to [comment:34 vdelecroix]:\n> It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.\n\n\nBut that would add an extra level of indirection in the general case, slowing that down.",
    "created_at": "2017-10-25T10:19:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115287",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:34 vdelecroix]:
> It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.


But that would add an extra level of indirection in the general case, slowing that down.



---

archive/issue_comments_115288.json:
```json
{
    "body": "I don't think there should be any Python object getting created by `_get_unsafe`, just a pointer to a Python object. What would be a use-case for implementing a custom `_entry_hash`?\n\nAnyways, since you say it can wait for a followup and this is a good improvement, I am setting it to a positive review. If you still want to discuss things first, feel free to revert.",
    "created_at": "2017-10-25T22:57:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115288",
    "user": "https://github.com/tscrim"
}
```

I don't think there should be any Python object getting created by `_get_unsafe`, just a pointer to a Python object. What would be a use-case for implementing a custom `_entry_hash`?

Anyways, since you say it can wait for a followup and this is a good improvement, I am setting it to a positive review. If you still want to discuss things first, feel free to revert.



---

archive/issue_comments_115289.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-10-25T22:57:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115289",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_115290.json:
```json
{
    "body": "Replying to [comment:36 tscrim]:\n> I don't think there should be any Python object getting created by `_get_unsafe`\n\n\n...only if the entries of the matrix are stored as Python objects. For many specialized classes (matrices over ZZ or over finite fields), the entries are stored in some C array, so `_get_unsafe()` does need to create a Python object.",
    "created_at": "2017-10-26T06:43:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115290",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:36 tscrim]:
> I don't think there should be any Python object getting created by `_get_unsafe`


...only if the entries of the matrix are stored as Python objects. For many specialized classes (matrices over ZZ or over finite fields), the entries are stored in some C array, so `_get_unsafe()` does need to create a Python object.



---

archive/issue_events_028382.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-10-30T07:41:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10871#event-28382"
}
```



---

archive/issue_comments_115291.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-10-30T07:41:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115291",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_115292.json:
```json
{
    "body": "Some more comments:\n\nThis hash function is a lot better than the old one. However, it is far from perfect:\n\n```\nsage: M = diagonal_matrix([0, 1, -2, 1]); M.set_immutable(); hash(M)\n0\n```\nStill, it is the best hash that I could come up with which is very efficient for sparse matrices: it takes time `O(s)` with `s` the number of non-zero entries of a matrix (independent of the size of the matrix). If you are willing to sort the indices (as suggested in [comment:7]), you get a better hash but with a runtime of `O(s log(s))`.",
    "created_at": "2017-10-30T16:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10871",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10871#issuecomment-115292",
    "user": "https://github.com/jdemeyer"
}
```

Some more comments:

This hash function is a lot better than the old one. However, it is far from perfect:

```
sage: M = diagonal_matrix([0, 1, -2, 1]); M.set_immutable(); hash(M)
0
```
Still, it is the best hash that I could come up with which is very efficient for sparse matrices: it takes time `O(s)` with `s` the number of non-zero entries of a matrix (independent of the size of the matrix). If you are willing to sort the indices (as suggested in [comment:7]), you get a better hash but with a runtime of `O(s log(s))`.
