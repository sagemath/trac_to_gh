# Issue 19376: Implement basic representations of semigroups

Issue created by migration from https://trac.sagemath.org/ticket/19613

Original creator: tscrim

Original creation time: 2015-11-22 05:52:30

Assignee: sage-combinat

CC:  sage-combinat nthiery virmaux

Keywords: representation

We provide a basic implementation of representations of semigroups with a distinguished basis.


---

Comment by tscrim created at 2015-11-22 05:54:09

This is a first step to an implementation of group (co)homology.
----
New commits:


---

Comment by tscrim created at 2015-11-22 05:54:09

Changing status from new to needs_review.


---

Comment by darij created at 2016-01-22 03:06:57

This is promising to be really useful!

A few first impressions (Sage is compiling doc, so I can't really edit):

Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?

In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).

Does the `RegularRepresentation` allow both multiplying by elements of the semigroup and multiplying by elements of the semigroup algebra? (And if so, please doctest both.)

I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...


---

Comment by git created at 2016-01-23 21:41:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-01-23 21:47:26

Replying to [comment:2 darij]:
> Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?

Added.

> In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).

That isn't ducktyping (it's the python `sum` not the symbolic `sum` that is at the top-level interface). Also, all `self.base_ring().sum(elts)` does is call `sum(elts, self.zero())` so it involves one further level of indirection.

> Does the `RegularRepresentation` allow both multiplying by elements of the semigroup and multiplying by elements of the semigroup algebra? (And if so, please doctest both.)

Yes, and I added some doctests about this. I also caught a few bugs with these doctests.

> I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...

There is code in `algebras/finite_dimensional_algebras` which essentially does that. We probably could separate that code into the semigroup part and the algebra part (and combine it with your code). However, I think that is better for a separate ticket because it won't directly apply to this (could be good for extensive testing of this, but I think that could be overkill).


---

Comment by nthiery created at 2016-01-23 22:16:18

Hmm, I really need to get my pile of semigroup code into Sage. But this should not stop you from making progress in the mean time. In case you'd have the occasion to spend a couple days in Paris, I'd be happy to do a coding sprint with you on this topic.

For building a variety of semigroups, you can use `sage.monoids.automatic_semigroup.AutomaticSemigroup`.

For info: I am currently working on an improved GAP-Sage interface allowing to easily wrap all kind of GAP parents, including semigroups:

    https://github.com/nthiery/sage-gap-semantic-interface

But here again, don't hold your breath!

Cheers,


---

Comment by darij created at 2016-01-23 22:47:11

Replying to [comment:4 tscrim]:
> Replying to [comment:2 darij]:
> > Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?
> 
> Added.

OK, weird. Why do you call it `left` one time and `left_repr` another? Also, it is still undocumented one time in `semigroups.py` (there are two `regular_representation` methods in that file; sorry for missing that).

> > In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).
> 
> That isn't ducktyping (it's the python `sum` not the symbolic `sum` that is at the top-level interface). Also, all `self.base_ring().sum(elts)` does is call `sum(elts, self.zero())` so it involves one further level of indirection.

Ah, you're perfectly right.


> > I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...
> 
> There is code in `algebras/finite_dimensional_algebras` which essentially does that. We probably could separate that code into the semigroup part and the algebra part (and combine it with your code). However, I think that is better for a separate ticket because it won't directly apply to this (could be good for extensive testing of this, but I think that could be overkill).

I guess you're right -- groups are probably enough for doctesting.

I am aware of `algebras/finite_dimensional_algebras` being essentially the linear version of what I wanted to do. (This is what I ended up using in #19892, since I really cared about the face semigroup algebra, not the face semigroup.) Still I wanted the non-linear version, since having a semigroup algebra without its semigroup looks really weird.

Nicolas, is this something you have in your code?


---

Comment by darij created at 2016-01-23 22:47:11

Changing keywords from "representation" to "representation, semigroups,".


---

Comment by git created at 2016-01-24 03:50:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-01-24 04:05:27

`@`darij Now both methods use `left` and are documented.

What I am suggesting is refactor the multiplication code for the fin-dim algebras into a finite semigroup (well, really finite magma because the product does not have to be associative). Then we would make a fin-dim algebra to be the algebra of a finite semigroup (magma).

`@`nthiery I will should have some time before (and I think after but need to double-check) Days 74, and I would be happy to do some coding sprints with you.

PS - How were the Sage-GAP days?


---

Comment by nthiery created at 2016-01-24 13:10:49

Replying to [comment:8 tscrim]:
> What I am suggesting is refactor the multiplication code for the fin-dim algebras into a finite semigroup (well, really finite magma because the product does not have to be associative). Then we would make a fin-dim algebra to be the algebra of a finite semigroup (magma).

This is for darij specific use case, right? Not all fin dim algebra come from a finite semigroup/magma.
 
> `@`nthiery I will should have some time before (and I think after but need to double-check) Days 74, and I would be happy to do some coding sprints with you.

Sounds good!

> PS - How were the Sage-GAP days?

It was good to meet and share with the GAP people. And to have time to focus on one coding sprint!


---

Comment by git created at 2016-01-28 05:11:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-01-28 05:18:15

I've reviewed the ticket up to `TrivialRepresentation`. However, exposing `self._module` the way I've done it is incompatible with your implementation of `TrivialRepresentation`, and this is a design question I feel is in need of discussion. What do you think is the right way?

1. Unexpose `self._module`, since any method that uses linear algebra on `self._module` can just as well use it on `self`.

2. Set `self._module = self` for a `TrivialRepresentation`.

3. Implement `TrivialRepresentation` using the general `Representation` constructor.

I don't see anything wrong with either of these options, but I am not the one to judge. A caveat with 1 is that coders need to be dissuaded from using `self._module` in their code (and this is a tricky thing to do, because not everyone will have a `TrivialRepresentation` in their doctests). Option 2 might incur endless loops or unwanted memory persistence, but I don't know. Option 3 feels like overkill, but it's the most straightforward thing.

Speaking of endless loops, do you have an idea why this gives one?

```
sage: G = groups.permutation.Dihedral(4)
sage: R = G.regular_representation(left=False)
sage: x = R.an_element()
sage: x*x
```


Oh, and one more thing. I think `TrivialRepresentation` might need a `left` option. Even if the action itself doesn't care, future code might (e.g., taking the direct sum of two representations might start off by checking whether both have the same left-right-ness, and tada you've got a pointless error when you try to add a right representation to the trivial one).


---

Comment by tscrim created at 2016-01-28 05:55:26

Replying to [comment:11 darij]:
> I've reviewed the ticket up to `TrivialRepresentation`.

Thank you for doing the review. (I guess I should review your face semigroup ticket...)

> However, exposing `self._module` the way I've done it is incompatible with your implementation of `TrivialRepresentation`, and this is a design question I feel is in need of discussion. What do you think is the right way?
> 
> 1. Unexpose `self._module`, since any method that uses linear algebra on `self._module` can just as well use it on `self`.
> 
> 2. Set `self._module = self` for a `TrivialRepresentation`.
> 
> 3. Implement `TrivialRepresentation` using the general `Representation` constructor.

I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)

> Speaking of endless loops, do you have an idea why this gives one?
> {{{
> sage: G = groups.permutation.Dihedral(4)
> sage: R = G.regular_representation(left=False)
> sage: x = R.an_element()
> sage: x*x
> }}}

No, and from the code, there does not seem to be a reason why this should happen. (This should result in an error though.) I will investigate this.

> Oh, and one more thing. I think `TrivialRepresentation` might need a `left` option. Even if the action itself doesn't care, future code might (e.g., taking the direct sum of two representations might start off by checking whether both have the same left-right-ness, and tada you've got a pointless error when you try to add a right representation to the trivial one).

If future code cares, then the future code can deal with creating the error/extra complexity. However, we can consider it as simultaneously a right and left representation, so I don't think this would be an issue.

Actually, given these recent changes, it reminded me why I had `left_repr`. I actually think `left_repr` is more descriptive, and so we should change all of the `left` to `left_repr`. Your thoughts?


---

Comment by darij created at 2016-01-28 17:48:25

Replying to [comment:12 tscrim]:
> Replying to [comment:11 darij]:
> > I've reviewed the ticket up to `TrivialRepresentation`.
> 
> Thank you for doing the review. (I guess I should review your face semigroup ticket...)

I think that's already (almost) done, but thank you :)

> I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)

Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.

I have thought about these things again and here are my suggestions:

S1. It is fine for `Representation` to treat `self._module` as an implementation detail that might not get inherited, but please document this in the `init` sourcecode (just a # comment saying that `self._module` might not exist).

S2. Please document in the docstring that the trivial representation is both left and right.

S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?

S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?

> > Speaking of endless loops, do you have an idea why this gives one?
> > {{{
> > sage: G = groups.permutation.Dihedral(4)
> > sage: R = G.regular_representation(left=False)
> > sage: x = R.an_element()
> > sage: x*x
> > }}}
> 
> No, and from the code, there does not seem to be a reason why this should happen. (This should result in an error though.) I will investigate this.

Yes, it should result in an error, just not in an exceeded recursion limit. Not a bug per se, but hell does it smell fishy. Then again, a quick look at the implementation of coercion in `parent.pyx` convinced me to be amazed at the fact that coercion works at all... (EDIT for clarity: In no way does this need to be solved for a positive review of this ticket; this is really a different story.)

> If future code cares, then the future code can deal with creating the error/extra complexity. However, we can consider it as simultaneously a right and left representation, so I don't think this would be an issue.

Agreed -- just wanting it to be explicit.

> Actually, given these recent changes, it reminded me why I had `left_repr`. I actually think `left_repr` is more descriptive, and so we should change all of the `left` to `left_repr`. Your thoughts?

I'm fine with `left_repr` or with anything, as long as it is the same keyword everywhere.


---

Comment by tscrim created at 2016-01-28 20:00:14

Replying to [comment:13 darij]:
> Replying to [comment:12 tscrim]:
> > I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)
> 
> Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.

Why should it? They are completely different implementations. This isn't even ducktyping, it is just about having a common API because all it is really about is just overloading `*`. However, after thinking about it a bit, there is some benefit for having a common base class for `Representation` and `TrivialRepresentation`, but there is no strong reason to force common base classes. (Ideally, this would be handled with a category, but I think we need more discussion and examples to see what the best way to do this will be.)

> I have thought about these things again and here are my suggestions:
> 
> S1. It is fine for `Representation` to treat `self._module` as an implementation detail that might not get inherited, but please document this in the `init` sourcecode (just a # comment saying that `self._module` might not exist).

`self._module` will always exist because `TrivialRepresentation` will not inherit from `Representation`. `Representation` is a slight variant of what is sometimes called a [decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern), whereas `TrivialRepresentation` is a direct subclass of CFM. As they have very different implementations, there should not be a subclass relationship `Representation` to `TrivialRepresentation`.

> S2. Please document in the docstring that the trivial representation is both left and right.

Will do.

> S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?

If anything, this should be a method, not an (hidden) attribute. However, I do agree we need something. Althought AFAIK this is the first time we have a left but not necessarily a right module.

> S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?

This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.

(I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)


---

Comment by darij created at 2016-01-28 20:40:46

Replying to [comment:14 tscrim]:
> Replying to [comment:13 darij]:
> > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.
> 
> Why should it? They are completely different implementations.

Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?

> > S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?
> 
> If anything, this should be a method, not an (hidden) attribute. However, I do agree we need something. Althought AFAIK this is the first time we have a left but not necessarily a right module.
> 
> > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?
> 
> This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.

You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.
> 
> (I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)
I know that feeling :)


---

Comment by tscrim created at 2016-01-28 21:48:48

Replying to [comment:15 darij]:
> Replying to [comment:14 tscrim]:
> > Replying to [comment:13 darij]:
> > > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.
> > 
> > Why should it? They are completely different implementations.
> 
> Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?

That is more about having a common API. Anyways, `Representation` and `TrivialRepresentation` will have a common ABC, so I think this issue is moot.

> > > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?
> > 
> > This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.
> 
> You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.

`_from_dict` has an optional argument to check for removing zeros (whose default is `True`). So this isn't an issue.

> > (I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)
> I know that feeling :)

It is just released in fact.


---

Comment by darij created at 2016-01-28 21:50:02

Replying to [comment:16 tscrim]:
> Replying to [comment:15 darij]:
> > Replying to [comment:14 tscrim]:
> > > Replying to [comment:13 darij]:
> > > > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.
> > > 
> > > Why should it? They are completely different implementations.
> > 
> > Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?
> 
> That is more about having a common API. Anyways, `Representation` and `TrivialRepresentation` will have a common ABC, so I think this issue is moot.

Ah, perfect.

> > > > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?
> > > 
> > > This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.
> > 
> > You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.
> 
> `_from_dict` has an optional argument to check for removing zeros (whose default is `True`). So this isn't an issue.

Oh! I forgot the semantics of `_from_dict`; so it's not as low-level as I expected. You are right!


---

Comment by git created at 2016-01-29 06:08:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-01-29 06:14:43

Taken care of all of the above.

The `x * x` issue appears with just a combinatorial free module:

```
sage: C = CombinatorialFreeModule(ZZ, ['a','b'])
sage: x = C.an_element()
sage: x * x  # BOOM
```

so it is unrelated to this ticket.


---

Comment by nthiery created at 2016-01-29 08:45:06

Just a tiny comment: please use side="left" rather than left=True, for consistency with what's done elsewhere (Coxeter groups, cayley graphs, ...).

Cheers,


---

Comment by git created at 2016-01-29 15:28:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-01-29 15:29:45

Replying to [comment:20 nthiery]:
> Just a tiny comment: please use side="left" rather than left=True, for consistency with what's done elsewhere (Coxeter groups, cayley graphs, ...).

Done. I also added a method to `Representation` exposing the side.


---

Comment by git created at 2016-01-29 21:36:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-01-29 21:36:16

Shouldn't the `side` method be on the ABC rather than on the implementation? (It might well be an abstract method, but it should be available, at least if we are serious about the ABC.)

As far as everything else is concerned, this LGTM!
----
New commits:
----
New commits:


---

Comment by git created at 2016-01-30 02:10:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-01-30 02:13:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-01-30 02:14:00

Thank you! The code now LGTM. Does it LGTY?


---

Comment by tscrim created at 2016-01-30 02:14:43

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2016-01-30 02:14:43

Yes. Thank you for doing the review.


---

Comment by darij created at 2016-01-30 02:16:05

Thanks for one of the most useful 500-line patches Sage has!


---

Comment by vbraun created at 2016-01-30 21:04:55

Resolution: fixed
