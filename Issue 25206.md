# Issue 25206: bijections for set partitions

Issue created by migration from https://trac.sagemath.org/ticket/25443

Original creator: mantepse

Original creation time: 2018-05-25 05:35:26

CC:  sage-combinat tscrim




---

Comment by mantepse created at 2018-05-25 05:37:43

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2018-05-25 05:37:43

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2018-05-25 05:37:43

New commits:


---

Comment by git created at 2018-05-26 22:03:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-05-26 22:09:00

Changing status from new to needs_review.


---

Comment by git created at 2018-05-26 22:49:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-26 23:17:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-26 23:27:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-26 23:32:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2018-06-03 09:03:22

Could you update the ticket description?

In the methods `openers` and `closers`, why do you sort? (Note that you do not use these methods except in doctests in which you sort again)

Rook placement corresponds to position in a matrix. It is very unconvenient to have them start at 1...

What does the following has to do with the ticket!?

```
+        sage: from sage.combinat.q_analogues import q_int
+        sage: q = ZZ['q'].gen(); h = SymmetricFunctions(ZZ).h()
+        sage: n = 6;
+        sage: s = lambda k: {"x%s"%i: q_int(i+1) for i in range(k)}
+        sage: all(q_stirling_number2(n,k) == q^binomial(k,2)*h[n-k].expand(k, s(k).keys()).subs(**s(k)) for k in range(1,n))
+        True
```


Instead of things like `r = next(i for i,j in rooks if c == j)` you would better convert a rook placement into a dictionary `j -> i`.

In `from_rook_placement_gamma`, you would better use `set` rather than `list` and use the method `discard` for removing element.


---

Comment by vdelecroix created at 2018-06-17 09:38:56

Changing status from needs_review to needs_work.


---

Comment by mantepse created at 2018-06-18 06:43:37

(I have actually done the modifications, but was mostly without internet for the last two weeks)


---

Comment by git created at 2018-06-19 15:39:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-06-19 15:41:07

New commits:


---

Comment by mantepse created at 2018-06-19 15:52:57

Hi Vincent!

> In the methods `openers` and `closers`, why do you sort? (Note that you do not use these methods except in doctests in which you sort again)

I think of these as convenience methods for the user, so sorting seemed appropriate to me.  I wouldn't use them in library code, because there is little to be gained. In the doctest I have to sort again, because I am adding other elements.

I won't insist: I can remove the sorting, too.

> Rook placement corresponds to position in a matrix. It is very unconvenient to have them start at 1...

This is something I actually thought about for quite some time, with no really good conclusion.  There are several ways to turn a set partition into a rook placement, the most common is to take the set of arcs.  Most but not all papers think of a rook placement corresponding to a set partition as an upper triangular matrix, so that's the convention I followed.

The entries of the set partitions in sage are {1,...,n}, so I would have to subtract 1 from each entry.  Are you sure that this is more convenient in the end?  I think most of the time the user is going to convert from arc-like things, but I don't know.  I think `from_arcs` is convenient, should I simply add another method `from_rook_placement_arcs`, which is zero-based?

I followed all your other comments and found them very good!


---

Comment by git created at 2018-06-19 15:55:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-06-19 15:55:51

Changing status from needs_work to needs_review.


---

Comment by mantepse created at 2018-06-19 15:55:51

New commits:
----
New commits:


---

Comment by vdelecroix created at 2018-06-19 21:52:18

Perhaps it does not matter so much, but what you do in `to_restricted_growth_word_blocks` is quite inefficient

```
[next(i for i, B in enumerate(self) if j in B) for j in range(1, self.size()+1)]
```

You would better use the linear time

```
l = [0] * self.size()
for i,B in enumerate(S):
    for j in B:
        l[j-1] = i
```

(here agin the shift in indices `j-1` quite frustrating)


---

Comment by git created at 2018-06-20 05:06:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-08-26 22:03:39

ping?


---

Comment by git created at 2018-11-20 03:06:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2018-11-20 11:51:56

Marta Yip's article has been published: http://www.combinatorics.org/ojs/index.php/eljc/article/view/v25i1p68.

Beside, if the code does what you expect it to do, I would have one brief final look...


---

Comment by git created at 2018-11-20 12:03:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-11-20 12:03:40

Done!


---

Comment by stumpc5 created at 2018-11-20 12:07:23

> # we can assume that the blocks are sorted by minimal element

The constructor of set partitions does not promise this property. I am not sure it is worth assuming it and then getting into trouble in 10 years from now because someone changed the implementation (or factored this code out into a category).


---

Comment by mantepse created at 2018-11-20 12:21:34

I can replace

```
        for i, B in enumerate(self):
```

with

```
        for i, B in enumerate(sorted(self, key=min)):
```

but I would be surprised if this isn't used outside of the new code, too.

Do you want me to make this change?


---

Comment by stumpc5 created at 2018-11-20 12:36:47

I agree that this is probably done already somewhere. The question is just if you want to rely on this property that is not promised to hold. You decide.


---

Comment by mantepse created at 2018-11-20 13:04:01

Out of curiosity I tried what happens if I do not sort by minimal element in `SetPartition.__init__` (but do so only in `_repr_`).  Surprisingly, except for equality of set partitions, there are not so many failures.

However, I wonder where would you document that the internal representation keeps the blocks sorted by minimal element?  Would you put it into the docstring of `__init__`?


---

Comment by stumpc5 created at 2018-11-20 13:19:08

Maybe yes, into `__init__`. I do think it should be clarified *somewhere* whether or not `__iter__` promises anything about the order of the iterator.

This sorting is also assumed elsewhere, such as

```
def standard_form(self):
    return [sorted(_) for _ in self]
```

which only makes sense if self is sorted already.

Since this sorting is also used in other places, would you add a promise into the `__init__` so that everyone can rely on it ?


---

Comment by git created at 2018-11-20 13:51:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2018-11-21 10:40:36

Changing status from needs_review to positive_review.


---

Comment by stumpc5 created at 2018-11-21 10:40:36

okay, I think it's ready to go


---

Comment by mantepse created at 2018-11-21 11:31:41

Many thanks!


---

Comment by tscrim created at 2018-11-21 15:54:59

Reviewer name.


---

Comment by tscrim created at 2018-11-21 15:54:59

Changing status from positive_review to needs_work.


---

Comment by stumpc5 created at 2018-11-21 16:37:44

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2018-11-22 21:37:12

Resolution: fixed
