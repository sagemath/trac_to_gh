# Issue 26866: Farther improve Combinatorial Polyhedron for AVX but not AVX 2.

archive/issues_026866.json:
```json
{
    "body": "CC:  @sophiasage stumpc5 @hivert @slel @tscrim\n\nKeywords: CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector\n\nThe crucial calculation for pretty much everything in CombinatorialPolyhedron (#26887) is to check whether a face A is a (sub-)face of a different face B.\n\nOnce converted to Bits representing each vertex the question is A & ~B == 0.\n\nThis is fastly computed with processor intrinsics (_mm256_testc_si256 or _mm_testc_si128). AVX can do this with 256 bit chunks.\n\nTo compute e.g. the f-vector, one also needs the intersection of two faces or bitwise AND. AVX cannot do this with 256 bit chunks, but AVX2 can.\n\nCurrently the choice for AVX but not AVX2 is to compute with 128 bit chunks.\n\nAs the subset check is very much the bottle neck of the computations, we should split 256 bits again in two for intersection, when AVX is available but AVX2 is not. This should give a speedup of almost two on large Polyhedra.\n\nIssue created by migration from https://trac.sagemath.org/ticket/27103\n\n",
    "created_at": "2019-01-23T20:11:47Z",
    "labels": [
        "component: geometry",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.3",
    "title": "Farther improve Combinatorial Polyhedron for AVX but not AVX 2.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26866",
    "user": "https://github.com/kliem"
}
```
CC:  @sophiasage stumpc5 @hivert @slel @tscrim

Keywords: CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector

The crucial calculation for pretty much everything in CombinatorialPolyhedron (#26887) is to check whether a face A is a (sub-)face of a different face B.

Once converted to Bits representing each vertex the question is A & ~B == 0.

This is fastly computed with processor intrinsics (_mm256_testc_si256 or _mm_testc_si128). AVX can do this with 256 bit chunks.

To compute e.g. the f-vector, one also needs the intersection of two faces or bitwise AND. AVX cannot do this with 256 bit chunks, but AVX2 can.

Currently the choice for AVX but not AVX2 is to compute with 128 bit chunks.

As the subset check is very much the bottle neck of the computations, we should split 256 bits again in two for intersection, when AVX is available but AVX2 is not. This should give a speedup of almost two on large Polyhedra.

Issue created by migration from https://trac.sagemath.org/ticket/27103





---

archive/issue_comments_377467.json:
```json
{
    "body": "Changing keywords from \"CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector\" to \"CombinatorialPolyhedron, SIMD, intrinsics\".",
    "created_at": "2019-01-25T22:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377467",
    "user": "https://github.com/kliem"
}
```

Changing keywords from "CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector" to "CombinatorialPolyhedron, SIMD, intrinsics".



---

archive/issue_comments_377468.json:
```json
{
    "body": "This is a way, one could boost CombinatorialPolyhedron with intrinsics. Replace `is_subset`, `intersection` and `CountFaceBits` by those functions:\n\n\n```\n#if __AVX__\n    #include <immintrin.h>\n#elif __SSE4_1__\n    #include <emmintrin.h>\n    #include <smmintrin.h>\n#endif\n\n#if __POPCNT__\n    #include <immintrin.h>\n#endif\n\n\n// as of now, 512bit does not have something like _mm256_testc_si256,\n// which is the bottle neck of this function,\n// so it does not make sense to implement it\n\n// inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length)\n// the bottlen-neck is checking for subsets, which requires something as\n// _mm256_testc_si256, trying to determine, what is the best way of doing it:\n#if __AVX__\n    // 256-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in immintrin.h\n    const size_t chunksize = 256;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        // note that A,B need to be 32-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 4){\n            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);\n            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);\n            if (!_mm256_testc_si256(b, a)){ //need to be opposite order !!\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#elif __SSE4_1__\n    // 128-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in smmintrin.h and emmintrin.h\n    const size_t chunksize = 128;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        // note that A,B need to be 16-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 2){\n            __m128i a = _mm_load_si128((const __m128i*)&A[i]);\n            __m128i b = _mm_load_si128((const __m128i*)&B[i]);\n            if (!_mm_testc_si128(b, a)){ //need to be opposite order !!\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#else\n    // no intrinsics\n    const size_t chunksize = 64;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        size_t i;\n        for (i = 0; i < face_length; i++){\n            if (A[i] & ~B[i]){\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#endif\n\n// inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C,\n//                          size_t face_length)\n// now determining, how to do insersection\n#if __AVX2__\n    // 256-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in immintrin.h\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        // note that A,B,C need to be 32-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 4){\n            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);\n            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);\n            __m256i c = _mm256_and_si256(a, b);\n            _mm256_store_si256((__m256i*)&C[i],c);\n        }\n    }\n\n#elif __SSE4_1__\n    // actually SSE2 would be fine, but we don't want to force greater chunks,\n    // because of intersection, which is not the bottleneck\n    // 128-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrinsics defined in emmintrin.h\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        // note that A,B,C need to be 16-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 2){\n            __m128i a = _mm_load_si128((const __m128i*)&A[i]);\n            __m128i b = _mm_load_si128((const __m128i*)&B[i]);\n            __m128i c = _mm_and_si128(a, b);\n            _mm_store_si128((__m128i*)&C[i],c);\n        }\n    }\n\n#else\n    // commands, without intrinsics\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        size_t i;\n        for (i = 0; i < face_length; i++){\n            C[i] = A[i] & B[i];\n        }\n    }\n\n#endif\n\n// inline size_t CountFaceBits(uint64_t* A, size_t face_length)\n// determine the best way to count the set bits in uint64_t *\n#if (__POPCNT__) && (INTPTR_MAX == INT64_MAX) // 64-bit and popcnt\n    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {\n        // counts the number of vertices in a face by counting bits set to one\n        // `face_length` is the length of A in terms of uint64_t\n        size_t i;\n        unsigned int count = 0;\n        for (i=0; i<face_length; i++){\n            count += (size_t) _mm_popcnt_u64(A[i]);\n        }\n        return count;\n    }\n\n#else // popcount without intrinsics\n    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {\n        // counts the number of vertices in a face by counting bits set to one\n        // `face_length` is the length of A in terms of uint64_t\n        size_t i;\n        unsigned int count = 0;\n        for (i=0; i<face_length; i++){\n            uint64_t a = A[i];\n            while (a){\n                count += a & 1;\n                a >>= 1;\n            }\n        }\n        return count;\n    }\n\n#endif\n```\n",
    "created_at": "2019-02-20T15:45:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377468",
    "user": "https://github.com/kliem"
}
```

This is a way, one could boost CombinatorialPolyhedron with intrinsics. Replace `is_subset`, `intersection` and `CountFaceBits` by those functions:


```
#if __AVX__
    #include <immintrin.h>
#elif __SSE4_1__
    #include <emmintrin.h>
    #include <smmintrin.h>
#endif

#if __POPCNT__
    #include <immintrin.h>
#endif


// as of now, 512bit does not have something like _mm256_testc_si256,
// which is the bottle neck of this function,
// so it does not make sense to implement it

// inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length)
// the bottlen-neck is checking for subsets, which requires something as
// _mm256_testc_si256, trying to determine, what is the best way of doing it:
#if __AVX__
    // 256-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in immintrin.h
    const size_t chunksize = 256;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        // note that A,B need to be 32-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 4){
            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);
            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);
            if (!_mm256_testc_si256(b, a)){ //need to be opposite order !!
                return 0;
            }
        }
        return 1;
    }

#elif __SSE4_1__
    // 128-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in smmintrin.h and emmintrin.h
    const size_t chunksize = 128;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        // note that A,B need to be 16-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 2){
            __m128i a = _mm_load_si128((const __m128i*)&A[i]);
            __m128i b = _mm_load_si128((const __m128i*)&B[i]);
            if (!_mm_testc_si128(b, a)){ //need to be opposite order !!
                return 0;
            }
        }
        return 1;
    }

#else
    // no intrinsics
    const size_t chunksize = 64;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        size_t i;
        for (i = 0; i < face_length; i++){
            if (A[i] & ~B[i]){
                return 0;
            }
        }
        return 1;
    }

#endif

// inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C,
//                          size_t face_length)
// now determining, how to do insersection
#if __AVX2__
    // 256-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in immintrin.h
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        // note that A,B,C need to be 32-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 4){
            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);
            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);
            __m256i c = _mm256_and_si256(a, b);
            _mm256_store_si256((__m256i*)&C[i],c);
        }
    }

#elif __SSE4_1__
    // actually SSE2 would be fine, but we don't want to force greater chunks,
    // because of intersection, which is not the bottleneck
    // 128-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrinsics defined in emmintrin.h
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        // note that A,B,C need to be 16-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 2){
            __m128i a = _mm_load_si128((const __m128i*)&A[i]);
            __m128i b = _mm_load_si128((const __m128i*)&B[i]);
            __m128i c = _mm_and_si128(a, b);
            _mm_store_si128((__m128i*)&C[i],c);
        }
    }

#else
    // commands, without intrinsics
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        size_t i;
        for (i = 0; i < face_length; i++){
            C[i] = A[i] & B[i];
        }
    }

#endif

// inline size_t CountFaceBits(uint64_t* A, size_t face_length)
// determine the best way to count the set bits in uint64_t *
#if (__POPCNT__) && (INTPTR_MAX == INT64_MAX) // 64-bit and popcnt
    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {
        // counts the number of vertices in a face by counting bits set to one
        // `face_length` is the length of A in terms of uint64_t
        size_t i;
        unsigned int count = 0;
        for (i=0; i<face_length; i++){
            count += (size_t) _mm_popcnt_u64(A[i]);
        }
        return count;
    }

#else // popcount without intrinsics
    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {
        // counts the number of vertices in a face by counting bits set to one
        // `face_length` is the length of A in terms of uint64_t
        size_t i;
        unsigned int count = 0;
        for (i=0; i<face_length; i++){
            uint64_t a = A[i];
            while (a){
                count += a & 1;
                a >>= 1;
            }
        }
        return count;
    }

#endif
```




---

archive/issue_comments_377469.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2019-03-11T14:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377469",
    "user": "https://github.com/kliem"
}
```

Last 10 new commits:



---

archive/issue_comments_377470.json:
```json
{
    "body": "Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)",
    "created_at": "2019-03-25T10:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377470",
    "user": "https://github.com/embray"
}
```

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)



---

archive/issue_comments_377471.json:
```json
{
    "body": "As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).",
    "created_at": "2019-06-14T14:54:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377471",
    "user": "https://github.com/embray"
}
```

As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).



---

archive/issue_comments_377472.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-10-23T07:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377472",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_377473.json:
```json
{
    "body": "for popcount, you can use something like this when builtin popcount is not available:\n\n```\ncdef inline int popcount64(uint64_t i):\n   \"\"\"\n   Return the number of '1' bits in a 64-bits integer.\n   \"\"\"\n   i = i - ((i >> 1) & 0x5555555555555555ULL)\n   i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)\n   return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56\n```\n\n\nEDIT: removed inappropriate comment (bad copy/paste)",
    "created_at": "2019-10-23T10:57:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377473",
    "user": "https://github.com/dcoudert"
}
```

for popcount, you can use something like this when builtin popcount is not available:

```
cdef inline int popcount64(uint64_t i):
   """
   Return the number of '1' bits in a 64-bits integer.
   """
   i = i - ((i >> 1) & 0x5555555555555555ULL)
   i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)
   return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56
```


EDIT: removed inappropriate comment (bad copy/paste)



---

archive/issue_comments_377474.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-23T11:44:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377474",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377475.json:
```json
{
    "body": "Thanks. Was a nice exercise to go through it.\n\nReplying to [comment:10 dcoudert]:\n> for popcount, you can use something like this when builtin popcount is not available:\n> {{{\n> cdef inline int popcount64(uint64_t i):\n>    \"\"\"\n>    Return the number of '1' bits in a 64-bits integer.\n>    \"\"\"\n>    i = i - ((i >> 1) & 0x5555555555555555ULL)\n>    i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)\n>    return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56\n> }}}\n> \n> EDIT: removed inappropriate comment (bad copy/paste)",
    "created_at": "2019-10-23T11:45:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377475",
    "user": "https://github.com/kliem"
}
```

Thanks. Was a nice exercise to go through it.

Replying to [comment:10 dcoudert]:
> for popcount, you can use something like this when builtin popcount is not available:
> {{{
> cdef inline int popcount64(uint64_t i):
>    """
>    Return the number of '1' bits in a 64-bits integer.
>    """
>    i = i - ((i >> 1) & 0x5555555555555555ULL)
>    i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)
>    return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56
> }}}
> 
> EDIT: removed inappropriate comment (bad copy/paste)



---

archive/issue_comments_377476.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-10-23T17:50:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377476",
    "user": "https://github.com/kliem"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_377477.json:
```json
{
    "body": "You could add an how to help reviewing this ticket. I can test it on OSX, but I assume it's far from enough.\n\nPS: no need to add me as an author. I just gave a small trick from hakmem 169. See e.g. [http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html](http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html)",
    "created_at": "2019-10-24T12:42:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377477",
    "user": "https://github.com/dcoudert"
}
```

You could add an how to help reviewing this ticket. I can test it on OSX, but I assume it's far from enough.

PS: no need to add me as an author. I just gave a small trick from hakmem 169. See e.g. [http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html](http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html)



---

archive/issue_comments_377478.json:
```json
{
    "body": "It works for me.\n\n- Operating System: Debian GNU/Linux 10 (buster)\n- Kernel: Linux 4.19.0-6-amd64\n- Architecture: x86-64\n- CPU Model name: Intel(R) Core(TM) i7-7700 CPU `@` 3.60GHz\n- sse4.1, avx, avx2, popcnt",
    "created_at": "2019-10-25T09:14:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377478",
    "user": "https://github.com/kliem"
}
```

It works for me.

- Operating System: Debian GNU/Linux 10 (buster)
- Kernel: Linux 4.19.0-6-amd64
- Architecture: x86-64
- CPU Model name: Intel(R) Core(TM) i7-7700 CPU `@` 3.60GHz
- sse4.1, avx, avx2, popcnt



---

archive/issue_comments_377479.json:
```json
{
    "body": "System:\n- Operating System: OS X 10.14.6\n- Kernel: Darwin Kernel Version 18.7.0\n- Architecture: x86-64\n- CPU Model name: Intel(R) Core(TM) i7-4650U CPU `@` 1.70GHz\n- sse4.1, avx2, popcnt\n\n\nTiming using py3:\n- 0.08155608177185059\nWith this ticket (`git trac checkout 27103`) and CFLAGS set:\n- 0.024885177612304688\n\n\nand all tests pass.",
    "created_at": "2019-10-25T16:30:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377479",
    "user": "https://github.com/dcoudert"
}
```

System:
- Operating System: OS X 10.14.6
- Kernel: Darwin Kernel Version 18.7.0
- Architecture: x86-64
- CPU Model name: Intel(R) Core(TM) i7-4650U CPU `@` 1.70GHz
- sse4.1, avx2, popcnt


Timing using py3:
- 0.08155608177185059
With this ticket (`git trac checkout 27103`) and CFLAGS set:
- 0.024885177612304688


and all tests pass.



---

archive/issue_comments_377480.json:
```json
{
    "body": "If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.",
    "created_at": "2019-10-26T03:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377480",
    "user": "https://github.com/videlec"
}
```

If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.



---

archive/issue_comments_377481.json:
```json
{
    "body": "Works on\n\n- Operating System: Ubuntu 18.04.3 LTS\n- Kernel: Linux 4.15.0-65-generic\n- Architecture: x86-64\n- Model name:          Intel(R) Core(TM) i5-7200U CPU `@` 2.50GHz\n- sse4_1 avx avx2 popcnt\n\nBefore:\n- 0.05162477493286133\nAfter\n- 0.02220010757446289",
    "created_at": "2019-10-26T11:11:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377481",
    "user": "https://github.com/kliem"
}
```

Works on

- Operating System: Ubuntu 18.04.3 LTS
- Kernel: Linux 4.15.0-65-generic
- Architecture: x86-64
- Model name:          Intel(R) Core(TM) i5-7200U CPU `@` 2.50GHz
- sse4_1 avx avx2 popcnt

Before:
- 0.05162477493286133
After
- 0.02220010757446289



---

archive/issue_comments_377482.json:
```json
{
    "body": "Replying to [comment:19 vdelecroix]:\n> If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.\n\nYes...\n\nThat is going to be some project, but it definitely makes sense.\n\nOne problem with bitset (to my understanding) so far is, that it is not overaligned. If it is overaligned, loads and stores are supposedly much faster (when using intrinsics).\n\nProbably the best way to find out, is to see how the performance of my code actually changes, when I use bitsets instead of my own implementation.\n\nBtw, if you have a specific example in mind, where calculations with bitsets are the bottle neck, I would be interested.",
    "created_at": "2019-10-26T11:52:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377482",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:19 vdelecroix]:
> If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.

Yes...

That is going to be some project, but it definitely makes sense.

One problem with bitset (to my understanding) so far is, that it is not overaligned. If it is overaligned, loads and stores are supposedly much faster (when using intrinsics).

Probably the best way to find out, is to see how the performance of my code actually changes, when I use bitsets instead of my own implementation.

Btw, if you have a specific example in mind, where calculations with bitsets are the bottle neck, I would be interested.



---

archive/issue_comments_377483.json:
```json
{
    "body": "For examples, have a look in the graph code `sage/graphs/` (e.g. iteration over vertex covers, etc). Apparently there are stuff in `sage/combinat/` as well. More generally\n\n```\n$ git grep -l bitset\n```\n",
    "created_at": "2019-10-26T14:54:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377483",
    "user": "https://github.com/videlec"
}
```

For examples, have a look in the graph code `sage/graphs/` (e.g. iteration over vertex covers, etc). Apparently there are stuff in `sage/combinat/` as well. More generally

```
$ git grep -l bitset
```




---

archive/issue_comments_377484.json:
```json
{
    "body": "Works on top of #27122, itrself on top of Python 3-based 9.0.beta2 on :\n\n- Operating System: Debian GNU/Linux bullseye/sid\n- Kernel: Linux 5.2.0-3-amd64\n- Architecture: x86-64\n- Nom de mod\u00e8le : Intel(R) Core(TM) i7-8550U CPU `@` 1.80GHz\n\nBefore: `0.046399831771850586`\n\nAfter: `0.016237735748291016`\n\nAll polyhedra-related tests pass.\n\nHTH,",
    "created_at": "2019-10-26T15:56:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377484",
    "user": "https://github.com/EmmanuelCharpentier"
}
```

Works on top of #27122, itrself on top of Python 3-based 9.0.beta2 on :

- Operating System: Debian GNU/Linux bullseye/sid
- Kernel: Linux 5.2.0-3-amd64
- Architecture: x86-64
- Nom de modèle : Intel(R) Core(TM) i7-8550U CPU `@` 1.80GHz

Before: `0.046399831771850586`

After: `0.016237735748291016`

All polyhedra-related tests pass.

HTH,



---

archive/issue_comments_377485.json:
```json
{
    "body": "I'm almost certain that this is applicable to `sage/data_structures/bitset.pxi`. I ran the following test:\n\n```\nsage: def fill_bitset():\n....:     for _ in range(1000000):\n....:         yield randint(0,10000000000)\n....:     yield 10000000000\n....:     \nsage: a = FrozenBitset(fill_bitset())\nsage: cython('''\n....: from sage.data_structures.bitset cimport bitset_t, FrozenBitset\n....: def intersect(FrozenBitset a, FrozenBitset b):\n....:     a.intersection(b)\n....: ''')\nsage: %timeit intersect(a,a)\n```\n\n\nWith the current implementation via GMP this takes about 781 ms (best of 3).\n\n```\nmpn_and_n(r.bits, a.bits, b.bits, b.limbs)\n```\n\nI replaced this by:\n\n```\ncdef mp_size_t i\ncdef mp_limb_t *rb = r.bits, *ab = a.bits, *bb = b.bits\nfor i from 0 <= i < a.limbs:\n    rb[i] = ab[i] & bb[i]\n```\n\nand it seems to be about the same.\n\nOf course this is a very brief naive test, but there seems to be no reason to use GMP for this specific function. Notice, that this doesn't even use intrinsics.",
    "created_at": "2019-10-26T20:31:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377485",
    "user": "https://github.com/kliem"
}
```

I'm almost certain that this is applicable to `sage/data_structures/bitset.pxi`. I ran the following test:

```
sage: def fill_bitset():
....:     for _ in range(1000000):
....:         yield randint(0,10000000000)
....:     yield 10000000000
....:     
sage: a = FrozenBitset(fill_bitset())
sage: cython('''
....: from sage.data_structures.bitset cimport bitset_t, FrozenBitset
....: def intersect(FrozenBitset a, FrozenBitset b):
....:     a.intersection(b)
....: ''')
sage: %timeit intersect(a,a)
```


With the current implementation via GMP this takes about 781 ms (best of 3).

```
mpn_and_n(r.bits, a.bits, b.bits, b.limbs)
```

I replaced this by:

```
cdef mp_size_t i
cdef mp_limb_t *rb = r.bits, *ab = a.bits, *bb = b.bits
for i from 0 <= i < a.limbs:
    rb[i] = ab[i] & bb[i]
```

and it seems to be about the same.

Of course this is a very brief naive test, but there seems to be no reason to use GMP for this specific function. Notice, that this doesn't even use intrinsics.



---

archive/issue_comments_377486.json:
```json
{
    "body": "If you can make `data_structures/bitset.pxi` better this is wonderful. What I want to avoid is two different piece of code that achieve the same thing. Please put your code in `data_structures/` rather than in `polyhedron` and make it as generic as possible. That way it will benefit to others.\n\nAlso, note that not all functions in `bitset.pxi` use GMP/MPIR. Where it does it should be fast. That is comparison (`mpn_cmp`), intersection (`mpn_and_n`), union (`mpn_ior_n`), etc. You might want to have a look at how these are implemented [GMP](https://gmplib.org/)/[MPIR](http://mpir.org/).",
    "created_at": "2019-10-26T21:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377486",
    "user": "https://github.com/videlec"
}
```

If you can make `data_structures/bitset.pxi` better this is wonderful. What I want to avoid is two different piece of code that achieve the same thing. Please put your code in `data_structures/` rather than in `polyhedron` and make it as generic as possible. That way it will benefit to others.

Also, note that not all functions in `bitset.pxi` use GMP/MPIR. Where it does it should be fast. That is comparison (`mpn_cmp`), intersection (`mpn_and_n`), union (`mpn_ior_n`), etc. You might want to have a look at how these are implemented [GMP](https://gmplib.org/)/[MPIR](http://mpir.org/).



---

archive/issue_comments_377487.json:
```json
{
    "body": "Things are complicated and a lot more complicated than I thought.\n\n- To my knowledge, I cannot do something as `#if __AVX__` in cython, can I? This would mean, we would have to rewrite bitset in C or C++ to use intrinsics.\n- So far I'm only reimplementing very basic functions.\n- I cannot write simple tests, where intrinsics are much faster. For intersection I don't see an improvement, for subset checks I'm maybe 10% faster. Here is, why I think this might be the case:\n\n  Loading registers takes a lot of time. In many cases this might be the bottle neck. Sure intrinsics need only one processor step instead of four to do bitwise `AND` of two registers. However, when I'm mostly waiting on read/write this does not help. Without intrinsics the processor can still process registers as fast as they can be loaded and stored again (don't forget that the result blocks another register while it is being stored).\n\n  Now in my scenario with subset checks things are a bit different. Nothings needs to be stored after the computation (this would explain why subset check with intrinsics is 10% faster than without). But more importantly seems to be the exact scenario I'm in:\n\n  I'm checking whether `A` is a subset of any of `B_1,...,B_n`. In most cases only the first 256 vertices are needed to discover that `A` is not a subset of `B_i`. So the first register of `A` can be reused a lot of times.\n\n  So, intrinsics might be useful in other scenarios for bitsets in sage, but it's definitly not a no-brainer. One won't lose. That I'm pretty sure of.",
    "created_at": "2019-10-28T10:17:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377487",
    "user": "https://github.com/kliem"
}
```

Things are complicated and a lot more complicated than I thought.

- To my knowledge, I cannot do something as `#if __AVX__` in cython, can I? This would mean, we would have to rewrite bitset in C or C++ to use intrinsics.
- So far I'm only reimplementing very basic functions.
- I cannot write simple tests, where intrinsics are much faster. For intersection I don't see an improvement, for subset checks I'm maybe 10% faster. Here is, why I think this might be the case:

  Loading registers takes a lot of time. In many cases this might be the bottle neck. Sure intrinsics need only one processor step instead of four to do bitwise `AND` of two registers. However, when I'm mostly waiting on read/write this does not help. Without intrinsics the processor can still process registers as fast as they can be loaded and stored again (don't forget that the result blocks another register while it is being stored).

  Now in my scenario with subset checks things are a bit different. Nothings needs to be stored after the computation (this would explain why subset check with intrinsics is 10% faster than without). But more importantly seems to be the exact scenario I'm in:

  I'm checking whether `A` is a subset of any of `B_1,...,B_n`. In most cases only the first 256 vertices are needed to discover that `A` is not a subset of `B_i`. So the first register of `A` can be reused a lot of times.

  So, intrinsics might be useful in other scenarios for bitsets in sage, but it's definitly not a no-brainer. One won't lose. That I'm pretty sure of.



---

archive/issue_comments_377488.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-04T15:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377488",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377489.json:
```json
{
    "body": "I will probably move those improvements to `data_structures/bitset.pxi`, once #27122 is done.\n\nIn the mean time, one can of course still pull the attached branch, if one wants to improve the f-vector computation.",
    "created_at": "2020-04-27T07:14:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377489",
    "user": "https://github.com/kliem"
}
```

I will probably move those improvements to `data_structures/bitset.pxi`, once #27122 is done.

In the mean time, one can of course still pull the attached branch, if one wants to improve the f-vector computation.



---

archive/issue_comments_377490.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2020-04-27T07:14:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377490",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_377491.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-08-25T08:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377491",
    "user": "https://github.com/kliem"
}
```

New commits:



---

archive/issue_comments_377492.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2020-08-25T12:42:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377492",
    "user": "https://github.com/kliem"
}
```

Last 10 new commits:



---

archive/issue_comments_377493.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-28T14:35:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377493",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377494.json:
```json
{
    "body": "Changes in #30040.\n----\nLast 10 new commits:",
    "created_at": "2020-08-30T06:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377494",
    "user": "https://github.com/kliem"
}
```

Changes in #30040.
----
Last 10 new commits:



---

archive/issue_comments_377495.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-02T06:39:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377495",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377496.json:
```json
{
    "body": "Changing keywords from \"CombinatorialPolyhedron, SIMD, intrinsics\" to \"bitsets, CombinatorialPolyhedron, SIMD, intrinsics\".",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377496",
    "user": "https://github.com/kliem"
}
```

Changing keywords from "CombinatorialPolyhedron, SIMD, intrinsics" to "bitsets, CombinatorialPolyhedron, SIMD, intrinsics".



---

archive/issue_comments_377497.json:
```json
{
    "body": "I will update the description yet, but this is basically ready for review.\n\nI got three failing doctests, but I don't think they are related:\n\n\n```\nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/sources.py  # 1 doctest failed                                                                              \nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/forker.py  # 1 doctest failed                                                                               \nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/interfaces/singular.py  # Killed due to segmentation fault  \n```\n\n\nOtherwise on my machine everything passes (with AVX2).\n\n(in the above two each time `FDS.in_lib` fails, so that doesn't seem to be related, also the singular timout doesn't seem to be related).\n----\nNew commits:",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377497",
    "user": "https://github.com/kliem"
}
```

I will update the description yet, but this is basically ready for review.

I got three failing doctests, but I don't think they are related:


```
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/sources.py  # 1 doctest failed                                                                              
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/forker.py  # 1 doctest failed                                                                               
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/interfaces/singular.py  # Killed due to segmentation fault  
```


Otherwise on my machine everything passes (with AVX2).

(in the above two each time `FDS.in_lib` fails, so that doesn't seem to be related, also the singular timout doesn't seem to be related).
----
New commits:



---

archive/issue_comments_377498.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377498",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_377499.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-15T18:49:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377499",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377500.json:
```json
{
    "body": "Replying to [comment:39 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[db11a45](https://git.sagemath.org/sage.git/commit/?id=db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)||`enable intrinsics for bitsets`||\n\nForgot to commit.",
    "created_at": "2021-01-15T18:49:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377500",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:39 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[db11a45](https://git.sagemath.org/sage.git/commit/?id=db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)||`enable intrinsics for bitsets`||

Forgot to commit.



---

archive/issue_comments_377501.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-15T18:55:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377501",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377502.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-15T21:19:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377502",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_377503.json:
```json
{
    "body": "Also works for me with\n\n- Operating System: Ubuntu 18.04.5 LTS\n- Kernel: Linux 4.15.0-112-generic\n- Architecture: x86-64\n- Model: Intel(R) Core(TM) i7-8700 CPU `@` 3.20GHz\n- sse4_1, sse4_2, avx, avx2 in cpu flags\n\nBased on this, the patchbots, and the previous comments, I am setting this to a positive review.",
    "created_at": "2021-01-17T02:13:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377503",
    "user": "https://github.com/tscrim"
}
```

Also works for me with

- Operating System: Ubuntu 18.04.5 LTS
- Kernel: Linux 4.15.0-112-generic
- Architecture: x86-64
- Model: Intel(R) Core(TM) i7-8700 CPU `@` 3.20GHz
- sse4_1, sse4_2, avx, avx2 in cpu flags

Based on this, the patchbots, and the previous comments, I am setting this to a positive review.



---

archive/issue_comments_377504.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-01-17T02:13:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377504",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_377505.json:
```json
{
    "body": "Thank you.",
    "created_at": "2021-01-17T08:36:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377505",
    "user": "https://github.com/kliem"
}
```

Thank you.



---

archive/issue_comments_377506.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-01-31T20:53:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26866",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26866#issuecomment-377506",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
