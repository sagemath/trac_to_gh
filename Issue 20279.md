# Issue 20279: Generating non-isomorphic lattices

archive/issues_020279.json:
```json
{
    "body": "CC:  tscrim chapoton\n\nPeter Jipsen gave a permission to incorporate his lattice generation code to Sage. We should think where to put it and what should be the interface.\n\nThere are codes for generating all lattices, modular lattices and vertically indecomposable lattices, and at least some paper is about distributive lattices. Also for example lattice with given maximal height of width should be easy to make. But basically lattice is special type of poset, and so class lattice of maximal height `n` is a poset with two restrictions.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20516\n\n",
    "created_at": "2016-04-29T10:55:58Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "title": "Generating non-isomorphic lattices",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20279",
    "user": "jmantysalo"
}
```
CC:  tscrim chapoton

Peter Jipsen gave a permission to incorporate his lattice generation code to Sage. We should think where to put it and what should be the interface.

There are codes for generating all lattices, modular lattices and vertically indecomposable lattices, and at least some paper is about distributive lattices. Also for example lattice with given maximal height of width should be easy to make. But basically lattice is special type of poset, and so class lattice of maximal height `n` is a poset with two restrictions.

Issue created by migration from https://trac.sagemath.org/ticket/20516





---

archive/issue_comments_279404.json:
```json
{
    "body": "I just mechanically copied the code and checked that it seems to work inside Sage.\n\nI am interested in generation of special classess of posets and lattices, and have already made a modification to generate only atomic lattices. But before those we should think about interface, and for that I ask help.\n\nPlease note that this lattice code starts with empty lattice and add elements; poset generation starts with antichain and adds covering relations. So for lattices it has no extra cost to generate lattices up to give size instead of given size.",
    "created_at": "2016-04-29T11:06:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279404",
    "user": "jmantysalo"
}
```

I just mechanically copied the code and checked that it seems to work inside Sage.

I am interested in generation of special classess of posets and lattices, and have already made a modification to generate only atomic lattices. But before those we should think about interface, and for that I ask help.

Please note that this lattice code starts with empty lattice and add elements; poset generation starts with antichain and adds covering relations. So for lattices it has no extra cost to generate lattices up to give size instead of given size.



---

archive/issue_comments_279405.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2016-04-29T11:06:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279405",
    "user": "jmantysalo"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_279406.json:
```json
{
    "body": "Changing keywords from \"\" to \"latticeposet\".",
    "created_at": "2016-04-29T11:06:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279406",
    "user": "jmantysalo"
}
```

Changing keywords from "" to "latticeposet".



---

archive/issue_comments_279407.json:
```json
{
    "body": "Just pinging this up to ask \"anybody interested at least a little?\".",
    "created_at": "2016-08-20T05:14:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279407",
    "user": "jmantysalo"
}
```

Just pinging this up to ask "anybody interested at least a little?".



---

archive/issue_comments_279408.json:
```json
{
    "body": "From a quick look, it seems more like the generation code should be an iterator class: it also would avoid the `globals` (which would become instance variables) and could be an iterator proper (which is lighter weight for loops).\n\nSome other small comments, you should use Python3 compatible `print` statements and be more PEP8 compliant (in particular, things like this should be 2 lines `except: print i, orb, p, L, le`).",
    "created_at": "2016-08-21T16:00:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279408",
    "user": "tscrim"
}
```

From a quick look, it seems more like the generation code should be an iterator class: it also would avoid the `globals` (which would become instance variables) and could be an iterator proper (which is lighter weight for loops).

Some other small comments, you should use Python3 compatible `print` statements and be more PEP8 compliant (in particular, things like this should be 2 lines `except: print i, orb, p, L, le`).



---

archive/issue_comments_279409.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n> From a quick look, it seems more like the generation code should be an iterator class: it also would avoid the `globals` (which would become instance variables) and could be an iterator proper (which is lighter weight for loops).\n\nOK. Now, if we do it as a real class, what about `in`? Try\n\n\n```\nprint DiGraph({0: [1]}) in digraphs(2)\nprint DiGraph({1: [0]}) in digraphs(2)\nprint Poset({0: [1]}) in Posets(2)\nprint Poset({1: [0]}) in Posets(2)\n```\n\n\nDo we want \"filter-usable class\", something like `L = LatticePosets(10, properties=['selfdual', 'modular']); . . .; if x in L: . . .`? It would be easier to just make a generator function.",
    "created_at": "2016-08-21T18:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279409",
    "user": "jmantysalo"
}
```

Replying to [comment:4 tscrim]:
> From a quick look, it seems more like the generation code should be an iterator class: it also would avoid the `globals` (which would become instance variables) and could be an iterator proper (which is lighter weight for loops).

OK. Now, if we do it as a real class, what about `in`? Try


```
print DiGraph({0: [1]}) in digraphs(2)
print DiGraph({1: [0]}) in digraphs(2)
print Poset({0: [1]}) in Posets(2)
print Poset({1: [0]}) in Posets(2)
```


Do we want "filter-usable class", something like `L = LatticePosets(10, properties=['selfdual', 'modular']); . . .; if x in L: . . .`? It would be easier to just make a generator function.



---

archive/issue_comments_279410.json:
```json
{
    "body": "With all of the extra functions and cross usage of variables, it's a (IMO big) \"technical debt\" and could be a maintenance headache down the road. If you don't want to do the extra work, at least have a separate class to do the iteration and then return a list over that iterator.",
    "created_at": "2016-08-22T00:53:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279410",
    "user": "tscrim"
}
```

With all of the extra functions and cross usage of variables, it's a (IMO big) "technical debt" and could be a maintenance headache down the road. If you don't want to do the extra work, at least have a separate class to do the iteration and then return a list over that iterator.



---

archive/issue_comments_279411.json:
```json
{
    "body": "Replying to [comment:6 tscrim]:\n> With all of the extra functions and cross usage of variables, it's a (IMO big) \"technical debt\" and could be a maintenance headache down the road. If you don't want to do the extra work, at least have a separate class to do the iteration and then return a list over that iterator.\n\nOK, can be done. But still I don't see the point of making a class instead of just a top-level function with internal subfunctions.",
    "created_at": "2016-08-22T03:18:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279411",
    "user": "jmantysalo"
}
```

Replying to [comment:6 tscrim]:
> With all of the extra functions and cross usage of variables, it's a (IMO big) "technical debt" and could be a maintenance headache down the road. If you don't want to do the extra work, at least have a separate class to do the iteration and then return a list over that iterator.

OK, can be done. But still I don't see the point of making a class instead of just a top-level function with internal subfunctions.



---

archive/issue_comments_279412.json:
```json
{
    "body": "It's because there are so many subfunctions and lines like\n\n```\nglobal m, Bk, Sk, As, M # avoid passing a lot of parameter into achains\n```\n\nBy doing it this way, it makes it so that there was no way to confuse variables and scope. You also get a very minor speed bump for not passing so many parameters and it becomes much easier to Cythonize.\n\nAlso, while you are moving stuff, it is faster to use `not b` instead of `b == []` and `while base: ` instead of `while len(base)!=0:`.",
    "created_at": "2016-08-22T03:25:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20279",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20279#issuecomment-279412",
    "user": "tscrim"
}
```

It's because there are so many subfunctions and lines like

```
global m, Bk, Sk, As, M # avoid passing a lot of parameter into achains
```

By doing it this way, it makes it so that there was no way to confuse variables and scope. You also get a very minor speed bump for not passing so many parameters and it becomes much easier to Cythonize.

Also, while you are moving stuff, it is faster to use `not b` instead of `b == []` and `while base: ` instead of `while len(base)!=0:`.
