# Issue 26277: clean centrality.pyx

Issue created by migration from https://trac.sagemath.org/ticket/26514

Original creator: dcoudert

Original creation time: 2018-10-20 09:38:58

CC:  tscrim chapoton slabbe

Keywords: py3, graph

Done in this ticket:
- secure sorts for py3
- avoid lots of compilation warnings initializing some pointers to NULL
- clean the code (PEP8)


---

Comment by dcoudert created at 2018-10-20 09:43:19

New commits:


---

Comment by dcoudert created at 2018-10-20 09:43:19

Changing status from new to needs_review.


---

Comment by git created at 2018-10-20 15:08:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-10-21 09:11:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-21 09:13:45

Thanks to #26447, we can now specify an ordering of the vertices to `init_short_digraph`.


---

Comment by tscrim created at 2018-10-23 15:50:28

I disagree with these changes:

```diff
-    Then, for each vertex ``v``, we set ``reachL[v]=L(C)``, where ``C`` is
-    the strongly connected component containing ``v``.
+    Then, for each vertex `v`, we set `reachL[v]=L(C)`, where `C` is the
+    strongly connected component containing `v`.
```


```diff
-    ``reachL``, ``reachU``: two arrays that should be allocated outside
-    this function and that should have size at least ``g.n``. At the end,
-    ``reachL[v]`` (resp., ``reachU[v]``) will contain the lower (resp., upper)
-    bound on the number of reachable vertices from ``v``.
+    `reachL`, `reachU`: two arrays that should be allocated outside this
+    function and that should have size at least `g.n`. At the end, `reachL[v]`
+    (resp., `reachU[v]`) will contain the lower (resp., upper) bound on the
+    number of reachable vertices from `v`.
```


```diff
-    For each vertex ``v``, computes the number of vertices reachable from ``v``.
+    For each vertex `v`, compute the number of vertices reachable from `v`.
 
-    The number of vertices reachable from ``v`` (which is the size of the
-    connected component containing ``v``) is stored in variable
-    ``reachable[v]``. The array ``reachable`` is assumed to be allocated
-    outside this function, and it is assumed to have size at least ``g.n``.
+    The number of vertices reachable from `v` (which is the size of the
+    connected component containing `v`) is stored in variable
+    `reachable[v]`. The array `reachable` is assumed to be allocated outside
+    this function, and it is assumed to have size at least `g.n`.
```

as they are now using latex formatting instead of code formatting. I also think the `k` in `centrality_closeness_top_k` is better in code formatting as it refers to the input `k`.

Why did you add the `key` here:

```diff
-    if k >= G.num_verts():
-        closeness_dict = G.centrality_closeness(by_weight=False,algorithm='BFS')
-        return sorted([(closz, z) for z,closz in closeness_dict.iteritems()], reverse=True)
-    if G.num_verts()==0 or G.num_verts()==1:
+    if k >= G.order():
+        closeness_dict = G.centrality_closeness(by_weight=False, algorithm='BFS')
+        return sorted([(closz, z) for z, closz in closeness_dict.items()],
+                          reverse=True, key=lambda zz: zz[0])
```

Is it to avoid comparisons of vertex labels? Are the values of `closeness_dict` guaranteed to be distinct?

Typo: `futur`


---

Comment by git created at 2018-10-24 06:30:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-24 06:34:59

I have implemented your comments.

Concerning the `key` in the sorting: yes, it is to avoid comparison of vertex labels as several vertices may have the same centrality. For instance

```
sage: G = graphs.PetersenGraph()
sage: print(G.centrality_closeness(by_weight=False, algorithm='BFS'))
{0: 0.6, 1: 0.6, 2: 0.6, 3: 0.6, 4: 0.6, 5: 0.6, 6: 0.6, 7: 0.6, 8: 0.6, 9: 0.6}
```



---

Comment by tscrim created at 2018-10-24 13:51:40

That is what I thought. The problem is that sorting like that will not necessarily get consistent results. So we need to do something slightly more here. I think we need to try sorting as before, and if that fails, fallback on sorting by just the centrality.


---

Comment by git created at 2018-10-24 14:07:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-24 14:07:57

Something like that ?


---

Comment by tscrim created at 2018-10-24 14:14:02

Yes, but don't use a bare `except:`; I think it should be a `TypeError` (maybe a `ValueError`, but I don't think so).


---

Comment by git created at 2018-10-24 14:29:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-10-24 14:31:50

Let's try that.


---

Comment by tscrim created at 2018-10-24 20:28:59

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2018-10-24 20:28:59

Thanks. LGTM.


---

Comment by vbraun created at 2018-10-25 06:47:00

Resolution: fixed
