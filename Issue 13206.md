# Issue 13206: Do not cache the non-existence of coerce/convert map too often, and do not pretend that there is a conversion where it doesn't make sense at all

archive/issues_013206.json:
```json
{
    "body": "Assignee: @robertwb\n\nCC:  @nbruin jpflori\n\nKeywords: coercion conversion object cache\n\nSorry for the long ticket title.\n\nAbout the first part of the title:\n\n```\nsage: P.<x,y> = QQ[]\nsage: P.is_coercion_cached(x)\nFalse\nsage: P.coerce_map_from(x)\nsage: P.is_coercion_cached(x)\nTrue\n```\nHence, there is a reference to x in the coercion cache for P. OK, by #715 and friends, the reference is weak --- unless x does not allow weak references, in which case the reference will be strong, and x would not be collectable. Hence, a potential memory leak.\n\nAbout the second part:\n\n```\nsage: ZZ.convert_map_from(1)\nConversion map:\n  From: Set of Python objects of \n  To:   Integer Ring\n```\nor\n\n```\nsage: P.convert_map_from(x)\nTraceback (most recent call last):\n...\nTypeError: Cannot convert sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular to sage.structure.parent.Parent\n```\nIn both cases, I believe the answer should be \"None\".\n\nIssue created by migration from https://trac.sagemath.org/ticket/13378\n\n",
    "created_at": "2012-08-18T12:04:11Z",
    "labels": [
        "component: coercion",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.7",
    "title": "Do not cache the non-existence of coerce/convert map too often, and do not pretend that there is a conversion where it doesn't make sense at all",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13206",
    "user": "https://github.com/simon-king-jena"
}
```
Assignee: @robertwb

CC:  @nbruin jpflori

Keywords: coercion conversion object cache

Sorry for the long ticket title.

About the first part of the title:

```
sage: P.<x,y> = QQ[]
sage: P.is_coercion_cached(x)
False
sage: P.coerce_map_from(x)
sage: P.is_coercion_cached(x)
True
```
Hence, there is a reference to x in the coercion cache for P. OK, by #715 and friends, the reference is weak --- unless x does not allow weak references, in which case the reference will be strong, and x would not be collectable. Hence, a potential memory leak.

About the second part:

```
sage: ZZ.convert_map_from(1)
Conversion map:
  From: Set of Python objects of 
  To:   Integer Ring
```
or

```
sage: P.convert_map_from(x)
Traceback (most recent call last):
...
TypeError: Cannot convert sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular to sage.structure.parent.Parent
```
In both cases, I believe the answer should be "None".

Issue created by migration from https://trac.sagemath.org/ticket/13378





---

archive/issue_comments_161200.json:
```json
{
    "body": "Are you sure\n\n```\nZZ.convert_map_from(10)\n```\nshould not raise an error? Shouldn't the argument be a parent? Something like:\n\n```\n    if not(isinstance(S,type) or isinstance(type(S),sage.structure.parent.Parent):\n        raise TypeError('convert maps only exist from parents')\n```\nThis has the potential for getting hairy if you want this to work:\n\n```\nsage: A=AdditiveGroups()\nsage: A(ZZ)\nFree commutative group on generators [1]\n```\nbecause then `parent(ZZ)` should be a Parent and it's not. However, this doesn't seem to be the way categories work anyway and it's probably wise to keep a strict separation between sets (parents) and categories. It actually makes me wonder if parent(ZZ) should even work.\n\nI know this all flies in the face of duck typing, but so does the whole category framework. I'm afraid that a fully duck typed computer algebra system would about as bad as an untyped one.",
    "created_at": "2012-08-18T17:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161200",
    "user": "https://github.com/nbruin"
}
```

Are you sure

```
ZZ.convert_map_from(10)
```
should not raise an error? Shouldn't the argument be a parent? Something like:

```
    if not(isinstance(S,type) or isinstance(type(S),sage.structure.parent.Parent):
        raise TypeError('convert maps only exist from parents')
```
This has the potential for getting hairy if you want this to work:

```
sage: A=AdditiveGroups()
sage: A(ZZ)
Free commutative group on generators [1]
```
because then `parent(ZZ)` should be a Parent and it's not. However, this doesn't seem to be the way categories work anyway and it's probably wise to keep a strict separation between sets (parents) and categories. It actually makes me wonder if parent(ZZ) should even work.

I know this all flies in the face of duck typing, but so does the whole category framework. I'm afraid that a fully duck typed computer algebra system would about as bad as an untyped one.



---

archive/issue_comments_161201.json:
```json
{
    "body": "Replying to [comment:2 nbruin]:\n> Are you sure\n> \n> ```\n> ZZ.convert_map_from(10)\n> ```\n> should not raise an error?\n\n\nNo, I am not sure.\n\n> Shouldn't the argument be a parent?\n\n\nOr a type, because we want a coercion (not just a conversion) between Python ints and Sage integers.\n\n> This has the potential for getting hairy if you want this to work:\n> \n> ```\n> sage: A=AdditiveGroups()\n> sage: A(ZZ)\n> Free commutative group on generators [1]\n> ```\n\n\nThat's totally separate. `AdditiveGroups()`, which doesn't exist yet, is a category and not a parent. It would be desirable, though, to have\n\n```\nsage: ZZ.category() # current behaviour\nCategory of euclidean domains\nsage: AdditiveGroups()(ZZ).category()  # not implemented\nCategory of additive groups\n```\n\n> because then `parent(ZZ)`\n\n\nZZ has no parent, it *is* a parent. Elements have a parent, but parents have a category.\n\n> It actually makes me wonder if parent(ZZ) should even work.\n\n\nparent(X) currently returns the type of X, if X has no method `X.parent()`. This is in order to make `int(1)+1` work. I don't think one should slow it down by distinguishing cases like \"if X is a parent then parent(X) should raise an error, but if X is anything else then either return X.parent() or type(X)\".\n\nAnyway. I tried to introduce a shortcut for `Parent.coerce_map_from`, such that `None` is returned (without caching) if the argument is neither a `CategoryObject` nor a type. Similarly, I introduced a shortcut for `Parent.convert_map_from`, but had to be more relaxed, because apparently convert maps also need to exist from sequences (which are `SageObject`, but not `CategoryObject`).\n\nResult: It nearly worked. There was one segfault in sage.rings.polynomial.infinite_polynomial_element (which I wrote) and one doctest error.",
    "created_at": "2012-08-18T19:53:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161201",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:2 nbruin]:
> Are you sure
> 
> ```
> ZZ.convert_map_from(10)
> ```
> should not raise an error?


No, I am not sure.

> Shouldn't the argument be a parent?


Or a type, because we want a coercion (not just a conversion) between Python ints and Sage integers.

> This has the potential for getting hairy if you want this to work:
> 
> ```
> sage: A=AdditiveGroups()
> sage: A(ZZ)
> Free commutative group on generators [1]
> ```


That's totally separate. `AdditiveGroups()`, which doesn't exist yet, is a category and not a parent. It would be desirable, though, to have

```
sage: ZZ.category() # current behaviour
Category of euclidean domains
sage: AdditiveGroups()(ZZ).category()  # not implemented
Category of additive groups
```

> because then `parent(ZZ)`


ZZ has no parent, it *is* a parent. Elements have a parent, but parents have a category.

> It actually makes me wonder if parent(ZZ) should even work.


parent(X) currently returns the type of X, if X has no method `X.parent()`. This is in order to make `int(1)+1` work. I don't think one should slow it down by distinguishing cases like "if X is a parent then parent(X) should raise an error, but if X is anything else then either return X.parent() or type(X)".

Anyway. I tried to introduce a shortcut for `Parent.coerce_map_from`, such that `None` is returned (without caching) if the argument is neither a `CategoryObject` nor a type. Similarly, I introduced a shortcut for `Parent.convert_map_from`, but had to be more relaxed, because apparently convert maps also need to exist from sequences (which are `SageObject`, but not `CategoryObject`).

Result: It nearly worked. There was one segfault in sage.rings.polynomial.infinite_polynomial_element (which I wrote) and one doctest error.



---

archive/issue_comments_161202.json:
```json
{
    "body": "Replying to [comment:2 nbruin]:\n> I know this all flies in the face of duck typing, but so does the whole category framework.\n\n\nOne could say that the category framework is the opposite of duck typing: In duck typing, you'd test whether certain methods are available for X, and conclude that X belongs to the category of ducks. In the category framework, you would at some point initialise X as an object of the category of ducks, and the category then provides X with methods like \"quack()\", \"swim()\", \"fly()\" --- or, if the category framework can not provide generic methods, it does require that these methods are implemented.\n\nBut I actually think that's a strength of the category framework. And note that after category initialisation of X, it would to some extent be possible to determine `X.category()` from the methods X provides.",
    "created_at": "2012-08-18T20:00:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161202",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:2 nbruin]:
> I know this all flies in the face of duck typing, but so does the whole category framework.


One could say that the category framework is the opposite of duck typing: In duck typing, you'd test whether certain methods are available for X, and conclude that X belongs to the category of ducks. In the category framework, you would at some point initialise X as an object of the category of ducks, and the category then provides X with methods like "quack()", "swim()", "fly()" --- or, if the category framework can not provide generic methods, it does require that these methods are implemented.

But I actually think that's a strength of the category framework. And note that after category initialisation of X, it would to some extent be possible to determine `X.category()` from the methods X provides.



---

archive/issue_comments_161203.json:
```json
{
    "body": "> ZZ has no parent, it *is* a parent. Elements have a parent, but parents have a category.\n\nAh yes, keeping that distinction strict is probably a good idea, even if it's\nnot always desirable from a strictly mathematical point of view:\n\n```\nsage: I=ZZ.ideal(3)\nsage: I(6)\nTypeError: 'Ideal_pid' object is not callable\nsage: parent(I)\nMonoid of ideals of Integer Ring\nsage: category(I)\nCategory of ring ideals in Integer Ring\n```\nso an ideal is an element and not a parent (although mathematically it's also a\na non-unitary ring and at the very least a ZZ-module). What's that category\ndoing on `I` though? Do elements have a parent *as well as* a category?\n\n```\nsage: V=FreeModule(ZZ,1)\nsage: W=V.span([3*V.0])\nsage: parent(W)\n<class 'sage.modules.free_module.FreeModule_submodule_pid_with_category'>\nsage: category(W)\nCategory of modules with basis over Integer Ring\n```\nAnd here we're not getting a parent \"... of submodules of V\", whatever the ...\nshould be.\n\nAlong these lines, by the way:\n\n```\nsage: NumberField(x^2+1,name='i').ideal(3)\nFractional ideal (3)\nsage: QQ.ideal(3)\nPrincipal ideal (1) of Rational Field\n```\nillustrating the usual schism between algebraists and number theorists.\n\nI don't think I'm really trying to make any point here. I'm just checking to\nwhat degree Sage agrees with my mathematical intuition.",
    "created_at": "2012-08-18T21:31:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161203",
    "user": "https://github.com/nbruin"
}
```

> ZZ has no parent, it *is* a parent. Elements have a parent, but parents have a category.

Ah yes, keeping that distinction strict is probably a good idea, even if it's
not always desirable from a strictly mathematical point of view:

```
sage: I=ZZ.ideal(3)
sage: I(6)
TypeError: 'Ideal_pid' object is not callable
sage: parent(I)
Monoid of ideals of Integer Ring
sage: category(I)
Category of ring ideals in Integer Ring
```
so an ideal is an element and not a parent (although mathematically it's also a
a non-unitary ring and at the very least a ZZ-module). What's that category
doing on `I` though? Do elements have a parent *as well as* a category?

```
sage: V=FreeModule(ZZ,1)
sage: W=V.span([3*V.0])
sage: parent(W)
<class 'sage.modules.free_module.FreeModule_submodule_pid_with_category'>
sage: category(W)
Category of modules with basis over Integer Ring
```
And here we're not getting a parent "... of submodules of V", whatever the ...
should be.

Along these lines, by the way:

```
sage: NumberField(x^2+1,name='i').ideal(3)
Fractional ideal (3)
sage: QQ.ideal(3)
Principal ideal (1) of Rational Field
```
illustrating the usual schism between algebraists and number theorists.

I don't think I'm really trying to make any point here. I'm just checking to
what degree Sage agrees with my mathematical intuition.



---

archive/issue_comments_161204.json:
```json
{
    "body": "Attachment [trac_13378-convert_map_shortcut.patch](tarball://root/attachments/some-uuid/ticket13378/trac_13378-convert_map_shortcut.patch) by @simon-king-jena created at 2012-08-28 09:52:00\n\nTest validity of input before a (failing) construction of coercion",
    "created_at": "2012-08-28T09:52:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161204",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_13378-convert_map_shortcut.patch](tarball://root/attachments/some-uuid/ticket13378/trac_13378-convert_map_shortcut.patch) by @simon-king-jena created at 2012-08-28 09:52:00

Test validity of input before a (failing) construction of coercion



---

archive/issue_comments_161205.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-08-28T09:55:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161205",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_161206.json:
```json
{
    "body": "I am not totally sure if the patch has dependencies, but let's test. With the patch, it is tested whether the input is valid as the domain of a conversion map or a coercion map. There is a difference between the two cases! Namely, Sequences are OK for a conversion map, but not for a coercion map.\n\nIf the input S is invalid, `P.coerce_map_from(S)` returns None, which is the expected answer if there is no coercion (hence, no error is raised). Because the short-cut is quick enough and in order to not pollute the cache, the answer is *not* cached.",
    "created_at": "2012-08-28T09:55:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161206",
    "user": "https://github.com/simon-king-jena"
}
```

I am not totally sure if the patch has dependencies, but let's test. With the patch, it is tested whether the input is valid as the domain of a conversion map or a coercion map. There is a difference between the two cases! Namely, Sequences are OK for a conversion map, but not for a coercion map.

If the input S is invalid, `P.coerce_map_from(S)` returns None, which is the expected answer if there is no coercion (hence, no error is raised). Because the short-cut is quick enough and in order to not pollute the cache, the answer is *not* cached.



---

archive/issue_comments_161207.json:
```json
{
    "body": "Could you clarify under what circumstances not having this code pollutes the cache? In particular, it seems that [coerce|convert]_map_from is always called with parent(x) which should always return a Parent or type? Perhaps what I'm asking is what object violate this in their parent() method.",
    "created_at": "2013-01-15T08:19:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161207",
    "user": "https://github.com/robertwb"
}
```

Could you clarify under what circumstances not having this code pollutes the cache? In particular, it seems that [coerce|convert]_map_from is always called with parent(x) which should always return a Parent or type? Perhaps what I'm asking is what object violate this in their parent() method.



---

archive/issue_comments_161208.json:
```json
{
    "body": "Replying to [comment:8 robertwb]:\n> Could you clarify under what circumstances not having this code pollutes the cache?\n\n\nUnfortunately, I did not write in the ticket description what use case made me create this ticket. But probably it was some experimental code on the computation of Ext algebras of basic algebras (i.e., finite-dimensional path algebra quotients).\n\nAnyway. The problem is that in the coercion code one quite typically has\n\n```\n    if self.has_coerce_map_from(P):\n        ...\n```\nwithout checking whether P really is a category object or type. And that means trouble, if P happens to be, say, an element (Yes, that did occur! But I don't know where I had originally found it). See the ticket description for an example.\n\nOf course, if P is neither a category object nor a type, then there is no coercion map from P to self. And as you know, the coercion framework would not only cache a coercion map from P to self, but it would also cache the non-existence of a coercion map from P to self.\n\nSo, the trouble starts if P runs over many elements that are not weakreffable. For each element P, the coercion framework would store the value ``None`` in self's coercion dictionary. And since the element is not weakreffable, the entry will stay in cache forever, and I think this may even prevent self from being garbage collected.",
    "created_at": "2013-01-15T08:41:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161208",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:8 robertwb]:
> Could you clarify under what circumstances not having this code pollutes the cache?


Unfortunately, I did not write in the ticket description what use case made me create this ticket. But probably it was some experimental code on the computation of Ext algebras of basic algebras (i.e., finite-dimensional path algebra quotients).

Anyway. The problem is that in the coercion code one quite typically has

```
    if self.has_coerce_map_from(P):
        ...
```
without checking whether P really is a category object or type. And that means trouble, if P happens to be, say, an element (Yes, that did occur! But I don't know where I had originally found it). See the ticket description for an example.

Of course, if P is neither a category object nor a type, then there is no coercion map from P to self. And as you know, the coercion framework would not only cache a coercion map from P to self, but it would also cache the non-existence of a coercion map from P to self.

So, the trouble starts if P runs over many elements that are not weakreffable. For each element P, the coercion framework would store the value ``None`` in self's coercion dictionary. And since the element is not weakreffable, the entry will stay in cache forever, and I think this may even prevent self from being garbage collected.



---

archive/issue_comments_161209.json:
```json
{
    "body": "PS: If P is not a category object nor a type, it is impossible that there is a coercion map from P to self. Therefore the patch introduces a short cut: ``self.coerce_map_from(P)`` immediately returns None, and does not try to find a coercion map by a costly backtrack algorithm.",
    "created_at": "2013-01-15T08:47:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161209",
    "user": "https://github.com/simon-king-jena"
}
```

PS: If P is not a category object nor a type, it is impossible that there is a coercion map from P to self. Therefore the patch introduces a short cut: ``self.coerce_map_from(P)`` immediately returns None, and does not try to find a coercion map by a costly backtrack algorithm.



---

archive/issue_comments_161210.json:
```json
{
    "body": "Didn't it happen with integer ? (I think python ints.)",
    "created_at": "2013-01-15T08:56:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161210",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Didn't it happen with integer ? (I think python ints.)



---

archive/issue_comments_161211.json:
```json
{
    "body": "Some info here http://trac.sagemath.org/sage_trac/ticket/13400#comment:31 but this ticket was opened before so...",
    "created_at": "2013-01-15T08:59:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161211",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Some info here http://trac.sagemath.org/sage_trac/ticket/13400#comment:31 but this ticket was opened before so...



---

archive/issue_comments_161212.json:
```json
{
    "body": "Thank you, Jean-Pierre! Yes, it seems `ZZ.ideal(5)` is a real-world-example in which the coercion framework caches the trivial fact that there is no coercion map whose domain is the *number* 5. In addition, 5 is not weakreffable, and finally the Sage integer 5 is not unique -- but the coercion cache compares its keys by uniqueness and not by equality.\n\nSo, doing `ZZ.ideal(5)` repeatedly will fill up the coercion cache (post #715, at least) with trivialities.",
    "created_at": "2013-01-15T09:20:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161212",
    "user": "https://github.com/simon-king-jena"
}
```

Thank you, Jean-Pierre! Yes, it seems `ZZ.ideal(5)` is a real-world-example in which the coercion framework caches the trivial fact that there is no coercion map whose domain is the *number* 5. In addition, 5 is not weakreffable, and finally the Sage integer 5 is not unique -- but the coercion cache compares its keys by uniqueness and not by equality.

So, doing `ZZ.ideal(5)` repeatedly will fill up the coercion cache (post #715, at least) with trivialities.



---

archive/issue_comments_161213.json:
```json
{
    "body": "Too bad/good, I just tested it with sage-5.6.beta1:\n\n```\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 147 \u00b5s per loop\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 144 \u00b5s per loop\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 147 \u00b5s per loop\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 148 \u00b5s per loop\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 146 \u00b5s per loop\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 147 \u00b5s per loop\nsage: %timeit a = ZZ.ideal(5)\n625 loops, best of 3: 148 \u00b5s per loop\nsage: %timeit a = ZZ.has_coerce_map_from(5)\n625 loops, best of 3: 82.1 \u00b5s per loop\nsage: %timeit a = ZZ.has_coerce_map_from(5)\n625 loops, best of 3: 81.4 \u00b5s per loop\nsage: %timeit a = ZZ.has_coerce_map_from(5)\n625 loops, best of 3: 81.3 \u00b5s per loop\n```\nSo, the problem mentioned at #13400 does currently not exist.\n\nWe should investigate why it is not a problem.",
    "created_at": "2013-01-15T09:24:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161213",
    "user": "https://github.com/simon-king-jena"
}
```

Too bad/good, I just tested it with sage-5.6.beta1:

```
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 147 µs per loop
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 144 µs per loop
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 147 µs per loop
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 148 µs per loop
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 146 µs per loop
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 147 µs per loop
sage: %timeit a = ZZ.ideal(5)
625 loops, best of 3: 148 µs per loop
sage: %timeit a = ZZ.has_coerce_map_from(5)
625 loops, best of 3: 82.1 µs per loop
sage: %timeit a = ZZ.has_coerce_map_from(5)
625 loops, best of 3: 81.4 µs per loop
sage: %timeit a = ZZ.has_coerce_map_from(5)
625 loops, best of 3: 81.3 µs per loop
```
So, the problem mentioned at #13400 does currently not exist.

We should investigate why it is not a problem.



---

archive/issue_comments_161214.json:
```json
{
    "body": "Did you apply #12313?\nIt seems after a really quick read that #13400 is a follow up to #12313 to mitigate a speed regression.",
    "created_at": "2013-01-15T10:01:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161214",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Did you apply #12313?
It seems after a really quick read that #13400 is a follow up to #12313 to mitigate a speed regression.



---

archive/issue_comments_161215.json:
```json
{
    "body": "Replying to [comment:15 jpflori]:\n> Did you apply #12313?\n\n\nNope.\n\n> It seems after a really quick read that #13400 is a follow up to #12313 to mitigate a speed regression.\n\n\nOK, what would explain it. Sorry, I will only be able to resume work tomorrow.",
    "created_at": "2013-01-15T10:44:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161215",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:15 jpflori]:
> Did you apply #12313?


Nope.

> It seems after a really quick read that #13400 is a follow up to #12313 to mitigate a speed regression.


OK, what would explain it. Sorry, I will only be able to resume work tomorrow.



---

archive/issue_comments_161216.json:
```json
{
    "body": "Replying to [comment:15 jpflori]:\n> Did you apply #12313?\n> It seems after a really quick read that #13400 is a follow up to #12313 to mitigate a speed regression.\n\n\nOK, I confirm that the problem with `ZZ.ideal(5)` becoming incrementally slower really exists with #12313. hence, this here *is* needed.",
    "created_at": "2013-01-18T17:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161216",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:15 jpflori]:
> Did you apply #12313?
> It seems after a really quick read that #13400 is a follow up to #12313 to mitigate a speed regression.


OK, I confirm that the problem with `ZZ.ideal(5)` becoming incrementally slower really exists with #12313. hence, this here *is* needed.



---

archive/issue_comments_161217.json:
```json
{
    "body": "Straightforward patch that applies (with slight whitespace fuzz for me) and doctests succeed. Plus it solves a real regression. At this pace, Sage 5.7 will have a negative memory footprint! yay.\n\nPositive review.",
    "created_at": "2013-01-18T20:14:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161217",
    "user": "https://github.com/nbruin"
}
```

Straightforward patch that applies (with slight whitespace fuzz for me) and doctests succeed. Plus it solves a real regression. At this pace, Sage 5.7 will have a negative memory footprint! yay.

Positive review.



---

archive/issue_events_037111.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2013-01-18T20:15:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "milestone": "sage-5.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13206#event-37111"
}
```



---

archive/issue_comments_161218.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-01-18T20:15:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161218",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_161219.json:
```json
{
    "body": "Please don't add dependencies that aren't required for the patches to apply. The fix here can be applied independently of other tickets and makes sense too. It might solve a problem that doesn't become quite as apparent without those other tickets, but that has little to do with its applicability.\n\nWe've had problems before where tickets were unnecessarily dequeued due to superfluous dependencies on tickets that turned out to need further work. Also, #12313 already states it's dependent on #12215, so there's no need to repeat that dependence here.",
    "created_at": "2013-01-19T20:29:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161219",
    "user": "https://github.com/nbruin"
}
```

Please don't add dependencies that aren't required for the patches to apply. The fix here can be applied independently of other tickets and makes sense too. It might solve a problem that doesn't become quite as apparent without those other tickets, but that has little to do with its applicability.

We've had problems before where tickets were unnecessarily dequeued due to superfluous dependencies on tickets that turned out to need further work. Also, #12313 already states it's dependent on #12215, so there's no need to repeat that dependence here.



---

archive/issue_comments_161220.json:
```json
{
    "body": "Yes, neither #12313 nor #12215 are dependencies for my patch. They should be merged together, because #13378 avoids a regression that #12313 would introduce, but #13378 makes perfectly sense without #12313.",
    "created_at": "2013-01-19T20:37:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161220",
    "user": "https://github.com/simon-king-jena"
}
```

Yes, neither #12313 nor #12215 are dependencies for my patch. They should be merged together, because #13378 avoids a regression that #12313 would introduce, but #13378 makes perfectly sense without #12313.



---

archive/issue_comments_161221.json:
```json
{
    "body": "I guess it's a matter of definitions.  I consider \"merge with\" as an equivalence relation (symmetric and transitive).  Given that #12313 is to be merged with #13378 and #12215 is to be merged with #12313, the logical conclusion is that these 3 tickets need to be merged together.  I didn't use the phrase \"merge with\" here, only to make the order of merging more clear (first #12215, then #12313, then #13378).\n\n> no need to repeat that dependence here.\n\nI find it easier to have the full set of dependencies written down.  Consider tickets A, B and C where A and B have positive review, C needs review, A depends on B and B depends on C.  If the implicit dependency of A on C is not written down, then it's not obvious to the release manager that A cannot currently be merged.",
    "created_at": "2013-01-19T20:44:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161221",
    "user": "https://github.com/jdemeyer"
}
```

I guess it's a matter of definitions.  I consider "merge with" as an equivalence relation (symmetric and transitive).  Given that #12313 is to be merged with #13378 and #12215 is to be merged with #12313, the logical conclusion is that these 3 tickets need to be merged together.  I didn't use the phrase "merge with" here, only to make the order of merging more clear (first #12215, then #12313, then #13378).

> no need to repeat that dependence here.

I find it easier to have the full set of dependencies written down.  Consider tickets A, B and C where A and B have positive review, C needs review, A depends on B and B depends on C.  If the implicit dependency of A on C is not written down, then it's not obvious to the release manager that A cannot currently be merged.



---

archive/issue_comments_161222.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-01-22T07:40:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13206#issuecomment-161222",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_037112.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-22T07:40:50Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13206",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13206#event-37112"
}
```
