# Issue 23089: Use Cython language_level=3 when using Python 3

archive/issues_022852.json:
```json
{
    "body": "to enable Python 3 source code semantics.\n\nhttps://cython.readthedocs.io/en/latest/src/reference/compilation.html#compiler-directives\n\nKeywords: python3\n\nReviewer: Jeroen Demeyer, Andr\u00e9 Apitzsch\n\nBranch: u/aapitzsch/23089\n\nCommit: 33ce8cf2e00635a3560f168a145a73f9ba265517\n\nResolution: wontfix\n\nIssue created by migration from https://trac.sagemath.org/ticket/23089\n\n",
    "closed_at": "2017-07-13T07:54:31Z",
    "created_at": "2017-05-27T09:59:54Z",
    "labels": [
        "component: cython"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Use Cython language_level=3 when using Python 3",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23089",
    "user": "https://github.com/a-andre"
}
```
to enable Python 3 source code semantics.

https://cython.readthedocs.io/en/latest/src/reference/compilation.html#compiler-directives

Keywords: python3

Reviewer: Jeroen Demeyer, Andr√© Apitzsch

Branch: u/aapitzsch/23089

Commit: 33ce8cf2e00635a3560f168a145a73f9ba265517

Resolution: wontfix

Issue created by migration from https://trac.sagemath.org/ticket/23089





---

archive/issue_comments_432854.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-05-27T10:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432854",
    "user": "https://github.com/a-andre"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_432855.json:
```json
{
    "body": "Changing commit from \"\" to \"33ce8cf2e00635a3560f168a145a73f9ba265517\"",
    "created_at": "2017-05-27T10:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432855",
    "user": "https://github.com/a-andre"
}
```

Changing commit from "" to "33ce8cf2e00635a3560f168a145a73f9ba265517"



---

archive/issue_comments_432856.json:
```json
{
    "body": "Changing branch from \"\" to \"u/aapitzsch/23089\"",
    "created_at": "2017-05-27T10:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432856",
    "user": "https://github.com/a-andre"
}
```

Changing branch from "" to "u/aapitzsch/23089"



---

archive/issue_comments_432857.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2017-05-27T10:36:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432857",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_432858.json:
```json
{
    "body": "<a id='comment:2'></a>Why?",
    "created_at": "2017-05-27T10:36:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432858",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>Why?



---

archive/issue_comments_432859.json:
```json
{
    "body": "<a id='comment:3'></a>In other words: which problem does this solve?",
    "created_at": "2017-05-27T10:37:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432859",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>In other words: which problem does this solve?



---

archive/issue_comments_432860.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Jeroen Demeyer\"",
    "created_at": "2017-05-27T10:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432860",
    "user": "https://github.com/jdemeyer"
}
```

Changing reviewer from "" to "Jeroen Demeyer"



---

archive/issue_comments_432861.json:
```json
{
    "body": "<a id='comment:5'></a>> Unprefixed string literals become **str** objects when compiling with language level 2 and **unicode** objects (i.e. Python 3 **str**) with language level 3.\n\n\nhttps://cython.readthedocs.io/en/latest/src/tutorial/strings.html",
    "created_at": "2017-05-27T10:45:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432861",
    "user": "https://github.com/a-andre"
}
```

<a id='comment:5'></a>> Unprefixed string literals become **str** objects when compiling with language level 2 and **unicode** objects (i.e. Python 3 **str**) with language level 3.


https://cython.readthedocs.io/en/latest/src/tutorial/strings.html



---

archive/issue_comments_432862.json:
```json
{
    "body": "<a id='comment:6'></a>That doesn't answer my question.\n\nLet me rephrase my question: there are 3 reasonable choices for the `language_level` option.\n\n(A) Always `language_level=2` *(the current situation)*\n\n(B) Always `language_level=3`\n\n(C) `language_level=2` on Python 2 and `language_level=3` on Python 3\n\n**Why** is (C) better than (A)?\n\nAnd there is an additional question: why is (C) better than (B)?",
    "created_at": "2017-05-27T10:53:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432862",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>That doesn't answer my question.

Let me rephrase my question: there are 3 reasonable choices for the `language_level` option.

(A) Always `language_level=2` *(the current situation)*

(B) Always `language_level=3`

(C) `language_level=2` on Python 2 and `language_level=3` on Python 3

**Why** is (C) better than (A)?

And there is an additional question: why is (C) better than (B)?



---

archive/issue_comments_432863.json:
```json
{
    "body": "<a id='comment:7'></a>I haven't looked at (B) because I didn't want to change the behaviour of Sage on Python 2.\n\nSetting `language_level=3` on Python 3 helped to discover (some) import errors already at compile time and not at runtime. And I assume (haven't tested) that using `language_level=3` could lead to less `unicode` problems than using `language_level=2` and could simplify the way to Sage on Python 3.\n\nJeroen, you have more experience with Cython, so I assume you can provide more knowledge-based arguments for one or the other.",
    "created_at": "2017-05-27T20:27:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432863",
    "user": "https://github.com/a-andre"
}
```

<a id='comment:7'></a>I haven't looked at (B) because I didn't want to change the behaviour of Sage on Python 2.

Setting `language_level=3` on Python 3 helped to discover (some) import errors already at compile time and not at runtime. And I assume (haven't tested) that using `language_level=3` could lead to less `unicode` problems than using `language_level=2` and could simplify the way to Sage on Python 3.

Jeroen, you have more experience with Cython, so I assume you can provide more knowledge-based arguments for one or the other.



---

archive/issue_comments_432864.json:
```json
{
    "body": "<a id='comment:8'></a>Replying to [comment:7 aapitzsch]:\n> Jeroen, you have more experience with Cython, so I assume you can provide more knowledge-based arguments for one or the other.\n\n\nIt's not really a Cython-specific thing, it's a more general philosophy. When writing Python code, you can try to\n\n(A) use Python 2 semantics as much as possible\n\n(B) use Python 3 semantics as much as possible\n\n(C) use Python 2 semantics on Python 2 and Python 3 semantics on Python 3\n\nFor plain Python, (A) is not possible in many cases because Python 3 removes a feature (for example: `__cmp__`, string literals interpreted as `bytes`, `dict.iteritems`). With Cython, the sitation for (A) is better because some Python 2 features are supported by Cython regardless of Python version.\n\nFor plain Python, (B) is often possible (using `from __future__` imports or packages like `six`).\n\nAnd (C) is usually where trouble lies (strings interpreted as `bytes`/`unicode` depending on the Python version, different division semantics...).\n\nBased on this, I believe that (C) is the worst option. Of course, this is just a personal opinion...",
    "created_at": "2017-05-27T21:54:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432864",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>Replying to [comment:7 aapitzsch]:
> Jeroen, you have more experience with Cython, so I assume you can provide more knowledge-based arguments for one or the other.


It's not really a Cython-specific thing, it's a more general philosophy. When writing Python code, you can try to

(A) use Python 2 semantics as much as possible

(B) use Python 3 semantics as much as possible

(C) use Python 2 semantics on Python 2 and Python 3 semantics on Python 3

For plain Python, (A) is not possible in many cases because Python 3 removes a feature (for example: `__cmp__`, string literals interpreted as `bytes`, `dict.iteritems`). With Cython, the sitation for (A) is better because some Python 2 features are supported by Cython regardless of Python version.

For plain Python, (B) is often possible (using `from __future__` imports or packages like `six`).

And (C) is usually where trouble lies (strings interpreted as `bytes`/`unicode` depending on the Python version, different division semantics...).

Based on this, I believe that (C) is the worst option. Of course, this is just a personal opinion...



---

archive/issue_comments_432865.json:
```json
{
    "body": "<a id='comment:9'></a>Any more suggestions here? If not, should we close this as wontfix?",
    "created_at": "2017-06-09T12:30:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432865",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>Any more suggestions here? If not, should we close this as wontfix?



---

archive/issue_comments_432866.json:
```json
{
    "body": "<a id='comment:10'></a>I tried to compile sage on Python 2 with `language_level=3`. There are some issues like\n\n```\nUnicode objects only support coercion to Py_UNICODE*.\n```\nwhich should be easily fixable.\nA bigger problem are errors like\n\n```\nnames = ['A{}'.format(''.join(str(x) for x in sorted(F))) for F in flats]  \n                                                     ^\n\nsage/matroids/matroid.pyx:7527:66: local variable 'F' referenced before assignment\n```\nhttps://github.com/cython/cython/issues/1159\n\nhttps://github.com/cython/cython/issues/1351\n\nIf we don't want to switch now, we should at least make the sage code as much level 3 compatible as possible to allow an easier transition later.",
    "created_at": "2017-06-10T10:04:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432866",
    "user": "https://github.com/a-andre"
}
```

<a id='comment:10'></a>I tried to compile sage on Python 2 with `language_level=3`. There are some issues like

```
Unicode objects only support coercion to Py_UNICODE*.
```
which should be easily fixable.
A bigger problem are errors like

```
names = ['A{}'.format(''.join(str(x) for x in sorted(F))) for F in flats]  
                                                     ^

sage/matroids/matroid.pyx:7527:66: local variable 'F' referenced before assignment
```
https://github.com/cython/cython/issues/1159

https://github.com/cython/cython/issues/1351

If we don't want to switch now, we should at least make the sage code as much level 3 compatible as possible to allow an easier transition later.



---

archive/issue_comments_432867.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:10 aapitzsch]:\n> If we don't want to switch now, we should at least make the sage code as much level 3 compatible as possible to allow an easier transition later.\n\n\nI agree in principle. On the other hand, I think this should literally be the last of our Python 3 worries. There is nothing really wrong with the status quo and there are plenty of other things which still need to be fixed for Python 3.\n\nSo I suggest to close this ticket as wontfix for now.",
    "created_at": "2017-06-20T15:17:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432867",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:11'></a>Replying to [comment:10 aapitzsch]:
> If we don't want to switch now, we should at least make the sage code as much level 3 compatible as possible to allow an easier transition later.


I agree in principle. On the other hand, I think this should literally be the last of our Python 3 worries. There is nothing really wrong with the status quo and there are plenty of other things which still need to be fixed for Python 3.

So I suggest to close this ticket as wontfix for now.



---

archive/issue_comments_432868.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2017-06-25T21:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432868",
    "user": "https://github.com/a-andre"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_events_059740.json:
```json
{
    "actor": "https://github.com/a-andre",
    "created_at": "2017-06-25T21:07:11Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23089#event-59740"
}
```



---

archive/issue_comments_432869.json:
```json
{
    "body": "Changing author from \"Andr\u00e9 Apitzsch\" to \"\"",
    "created_at": "2017-06-26T07:40:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432869",
    "user": "https://github.com/jdemeyer"
}
```

Changing author from "Andr√© Apitzsch" to ""



---

archive/issue_comments_432870.json:
```json
{
    "body": "Changing reviewer from \"Jeroen Demeyer\" to \"Jeroen Demeyer, Andr\u00e9 Apitzsch\"",
    "created_at": "2017-06-26T07:40:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432870",
    "user": "https://github.com/jdemeyer"
}
```

Changing reviewer from "Jeroen Demeyer" to "Jeroen Demeyer, Andr√© Apitzsch"



---

archive/issue_comments_432871.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-06-26T07:40:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432871",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_432872.json:
```json
{
    "body": "<a id='comment:14'></a>Closing tickets in the sage-duplicate/invalid/wontfix module with positive_review (i.e. someone has confirmed they should be closed).",
    "created_at": "2017-07-13T07:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432872",
    "user": "https://github.com/embray"
}
```

<a id='comment:14'></a>Closing tickets in the sage-duplicate/invalid/wontfix module with positive_review (i.e. someone has confirmed they should be closed).



---

archive/issue_events_059741.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2017-07-13T07:54:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23089#event-59741"
}
```



---

archive/issue_comments_432873.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2017-07-13T07:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432873",
    "user": "https://github.com/embray"
}
```

Resolution: wontfix



---

archive/issue_comments_432874.json:
```json
{
    "body": "<a id='comment:15'></a>I definitely think this is the right way to go.  It's terribly confusing when trying to port to Python 3 if you have Python 2/3 straddling pure Python code that behaves like Python 2 on Python 2 and like Python 3 on Python 3, but then totally different semantics when you cross over into Cython land.  \n\nThat said, until the Cython issue is fixed it will be hard to get very far into this.  In the short term I could write a hacky workaround by rewriting some list comprehensions as for loops (after all, in Cython there's not as much immediate benefit to list comprehensions, I don't think).  But it would be best not to do that just because Cython has a bug...",
    "created_at": "2017-09-08T08:02:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432874",
    "user": "https://github.com/embray"
}
```

<a id='comment:15'></a>I definitely think this is the right way to go.  It's terribly confusing when trying to port to Python 3 if you have Python 2/3 straddling pure Python code that behaves like Python 2 on Python 2 and like Python 3 on Python 3, but then totally different semantics when you cross over into Cython land.  

That said, until the Cython issue is fixed it will be hard to get very far into this.  In the short term I could write a hacky workaround by rewriting some list comprehensions as for loops (after all, in Cython there's not as much immediate benefit to list comprehensions, I don't think).  But it would be best not to do that just because Cython has a bug...



---

archive/issue_comments_432875.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [comment:15 embray]:\n> I definitely think this is the right way to go.  It's terribly confusing when trying to port to Python 3 if you have Python 2/3 straddling pure Python code that behaves like Python 2 on Python 2 and like Python 3 on Python 3, but then totally different semantics when you cross over into Cython land.\n\n\nI would argue that the confusion is more in the Python land than in the Cython land.\n\nYou are saying that we should make the code behave *more different* in Python 2 and Python 3 and that will make our life easier?  I say it's a bad thing and we should be happy that Cython allows us to worry less about Python 2/3 compatibility.",
    "created_at": "2017-09-08T08:46:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432875",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:16'></a>Replying to [comment:15 embray]:
> I definitely think this is the right way to go.  It's terribly confusing when trying to port to Python 3 if you have Python 2/3 straddling pure Python code that behaves like Python 2 on Python 2 and like Python 3 on Python 3, but then totally different semantics when you cross over into Cython land.


I would argue that the confusion is more in the Python land than in the Cython land.

You are saying that we should make the code behave *more different* in Python 2 and Python 3 and that will make our life easier?  I say it's a bad thing and we should be happy that Cython allows us to worry less about Python 2/3 compatibility.



---

archive/issue_comments_432876.json:
```json
{
    "body": "<a id='comment:17'></a>It's a problem from a maintenance standpoint.  It's bad enough going between Python and Cython as it is, and having to remember their (sometimes subtle) differences.  Now it's saying \"even if you're developing for Python 3 you have to go back to Python 2 (sort of) when you're editing Cython code\".  It also means that the idioms used to support Python 2 and 3 shift when going between Python and Cython, and it also means that extra special care is needed when passing string-like objects at the interface between Python and Cython (which, in most cases, is not an interface one should be thinking about at all).",
    "created_at": "2017-09-08T08:53:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432876",
    "user": "https://github.com/embray"
}
```

<a id='comment:17'></a>It's a problem from a maintenance standpoint.  It's bad enough going between Python and Cython as it is, and having to remember their (sometimes subtle) differences.  Now it's saying "even if you're developing for Python 3 you have to go back to Python 2 (sort of) when you're editing Cython code".  It also means that the idioms used to support Python 2 and 3 shift when going between Python and Cython, and it also means that extra special care is needed when passing string-like objects at the interface between Python and Cython (which, in most cases, is not an interface one should be thinking about at all).



---

archive/issue_comments_432877.json:
```json
{
    "body": "<a id='comment:18'></a>Replying to [comment:17 embray]:\n> it also means that extra special care is needed when passing string-like objects at the interface between Python and Cython\n\n\nI thought we discussed this on sage-devel. Cython knows that `str = unicode` on Python 3 and string literals are `str = unicode` on Python 3, regardless of `language_level`.\n\nNote that using `language_level=3` does turn on `from __future__ import unicode_literals`. But on Python 3, that doesn't change anything.",
    "created_at": "2017-09-08T09:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432877",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:18'></a>Replying to [comment:17 embray]:
> it also means that extra special care is needed when passing string-like objects at the interface between Python and Cython


I thought we discussed this on sage-devel. Cython knows that `str = unicode` on Python 3 and string literals are `str = unicode` on Python 3, regardless of `language_level`.

Note that using `language_level=3` does turn on `from __future__ import unicode_literals`. But on Python 3, that doesn't change anything.



---

archive/issue_comments_432878.json:
```json
{
    "body": "<a id='comment:19'></a>I agree that there are many issues with `bytes` vs. `unicode` in Cython code in Python 3. I agree so far. But few or none of those issues are fixed with `language_level=3`. It's a red herring, the `language_level` really doesn't change that much.",
    "created_at": "2017-09-08T09:09:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432878",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:19'></a>I agree that there are many issues with `bytes` vs. `unicode` in Cython code in Python 3. I agree so far. But few or none of those issues are fixed with `language_level=3`. It's a red herring, the `language_level` really doesn't change that much.



---

archive/issue_comments_432879.json:
```json
{
    "body": "<a id='comment:20'></a>Just to make sure I'm clear about this, I'm only talking about enabling `language_level=3` on python3, not python2.  The fact that all string literals become unicode on Python 3 does make a big difference in porting sanity.",
    "created_at": "2017-09-08T09:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432879",
    "user": "https://github.com/embray"
}
```

<a id='comment:20'></a>Just to make sure I'm clear about this, I'm only talking about enabling `language_level=3` on python3, not python2.  The fact that all string literals become unicode on Python 3 does make a big difference in porting sanity.



---

archive/issue_comments_432880.json:
```json
{
    "body": "<a id='comment:21'></a>I think I'm confused about this line in the docs:\n\n> Unprefixed string literals become str objects when compiling with language level 2 and unicode objects (i.e. Python 3 str) with language level 3.\n\n\nThe first part of the sentence doesn't specify what they mean by \"str\", because this doesn't seem to agree with my experience of turning on `language_level=3` (where suddenly string literals were being treated as unicode and breaking whenever passed to an interface that expects `char *`).\n\nAnyways, another reason to do this is that we'll probably want to use other Python 3 features eventually so it would be good to enable.",
    "created_at": "2017-09-08T09:39:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432880",
    "user": "https://github.com/embray"
}
```

<a id='comment:21'></a>I think I'm confused about this line in the docs:

> Unprefixed string literals become str objects when compiling with language level 2 and unicode objects (i.e. Python 3 str) with language level 3.


The first part of the sentence doesn't specify what they mean by "str", because this doesn't seem to agree with my experience of turning on `language_level=3` (where suddenly string literals were being treated as unicode and breaking whenever passed to an interface that expects `char *`).

Anyways, another reason to do this is that we'll probably want to use other Python 3 features eventually so it would be good to enable.



---

archive/issue_comments_432881.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:21 embray]:\n> I think I'm confused about this line in the docs:\n> \n> > Unprefixed string literals become str objects when compiling with language level 2 and unicode objects (i.e. Python 3 str) with language level 3.\n\n\nIn Cython code, it's best to think of `bytes`, `str` and `unicode` as three distinct types (that's what Cython does internally). It just happes that `str is bytes` on Python 2 and `str is unicode` on Python 3.\n\nSo then, unprefixed string literals are `str` with `language_level=2` (exactly the same as in plain Python), they are `unicode` with `language_level=3` (exactly the same as in plain Python with `from __future__ import unicode_literals`).",
    "created_at": "2017-09-08T10:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432881",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:22'></a>Replying to [comment:21 embray]:
> I think I'm confused about this line in the docs:
> 
> > Unprefixed string literals become str objects when compiling with language level 2 and unicode objects (i.e. Python 3 str) with language level 3.


In Cython code, it's best to think of `bytes`, `str` and `unicode` as three distinct types (that's what Cython does internally). It just happes that `str is bytes` on Python 2 and `str is unicode` on Python 3.

So then, unprefixed string literals are `str` with `language_level=2` (exactly the same as in plain Python), they are `unicode` with `language_level=3` (exactly the same as in plain Python with `from __future__ import unicode_literals`).



---

archive/issue_comments_432882.json:
```json
{
    "body": "<a id='comment:23'></a>Yes, that matches my understanding, but `s/plain Python/plain Python 2/`.  On Python 3 unprefixed strings are also \"unicode\" type, so `language_level=3` is just consistent with Python 3 in this regard and better for use in conjunction with plain Python 3 code.\n\nAnyways, this is all a moot point until and unless the issues in Cython are fixed, which may be difficult.  I'm working on it but it's not high priority now.  I agree with you that it's not a big deal either way, but I do think using `language_level=2` with Python 3 is confusing and error-prone.",
    "created_at": "2017-10-18T15:32:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432882",
    "user": "https://github.com/embray"
}
```

<a id='comment:23'></a>Yes, that matches my understanding, but `s/plain Python/plain Python 2/`.  On Python 3 unprefixed strings are also "unicode" type, so `language_level=3` is just consistent with Python 3 in this regard and better for use in conjunction with plain Python 3 code.

Anyways, this is all a moot point until and unless the issues in Cython are fixed, which may be difficult.  I'm working on it but it's not high priority now.  I agree with you that it's not a big deal either way, but I do think using `language_level=2` with Python 3 is confusing and error-prone.



---

archive/issue_comments_432883.json:
```json
{
    "body": "<a id='comment:24'></a>Replying to [comment:23 embray]:\n> Yes, that matches my understanding, but `s/plain Python/plain Python 2/`.\n\n\nWhat I wrote in [comment:22] is true both for Python 2 and Python 3.",
    "created_at": "2017-10-18T18:26:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432883",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:24'></a>Replying to [comment:23 embray]:
> Yes, that matches my understanding, but `s/plain Python/plain Python 2/`.


What I wrote in [comment:22] is true both for Python 2 and Python 3.



---

archive/issue_comments_432884.json:
```json
{
    "body": "<a id='comment:25'></a>You wrote \"they are `unicode` with `language_level=3`\" which doesn't make sense because there is no type called \"unicode\" in Python 3.  That statement only makes sense on Python 2.",
    "created_at": "2017-10-19T10:09:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432884",
    "user": "https://github.com/embray"
}
```

<a id='comment:25'></a>You wrote "they are `unicode` with `language_level=3`" which doesn't make sense because there is no type called "unicode" in Python 3.  That statement only makes sense on Python 2.



---

archive/issue_comments_432885.json:
```json
{
    "body": "<a id='comment:26'></a>Replying to [comment:25 embray]:\n> You wrote \"they are `unicode` with `language_level=3`\" which doesn't make sense because there is no type called \"unicode\" in Python 3.\n\n\nIt does make sense if you first read the first paragraph of my comment in [comment:22]",
    "created_at": "2017-10-20T09:41:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432885",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:26'></a>Replying to [comment:25 embray]:
> You wrote "they are `unicode` with `language_level=3`" which doesn't make sense because there is no type called "unicode" in Python 3.


It does make sense if you first read the first paragraph of my comment in [comment:22]



---

archive/issue_comments_432886.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:26 jdemeyer]:\n> Replying to [comment:25 embray]:\n> > You wrote \"they are `unicode` with `language_level=3`\" which doesn't make sense because there is no type called \"unicode\" in Python 3.\n\n> \n> It does make sense if you first read the first paragraph of my comment in [comment:22]\n\n\nMaybe I did read that paragraph and *it* didn't make sense.",
    "created_at": "2017-10-23T08:15:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432886",
    "user": "https://github.com/embray"
}
```

<a id='comment:27'></a>Replying to [comment:26 jdemeyer]:
> Replying to [comment:25 embray]:
> > You wrote "they are `unicode` with `language_level=3`" which doesn't make sense because there is no type called "unicode" in Python 3.

> 
> It does make sense if you first read the first paragraph of my comment in [comment:22]


Maybe I did read that paragraph and *it* didn't make sense.



---

archive/issue_comments_432887.json:
```json
{
    "body": "<a id='comment:28'></a>Let me clarify: when Cython compiles Cython code to C, it doesn't yet know if the C code will be compiled as Python 2 and Python 3. So when it sees a `\"string\"` literal, it doesn't really know what king of string it will be. To solve this, Cython internally really has 3 string types: `bytes`, `str` and `unicode`. Both `bytes` and `unicode` are easy to deal with, since they refer to the same type on Python 2 and Python 3 (*). To deal with `str`, it uses macros like\n\n```\n#if PY_MAJOR_VERSION >= 3\n  #define PyBaseString_Type            PyUnicode_Type\n  #define PyStringObject               PyUnicodeObject\n  #define PyString_Type                PyUnicode_Type\n  #define PyString_Check               PyUnicode_Check\n  #define PyString_CheckExact          PyUnicode_CheckExact\n#endif\n```\n\n(*) I know that they renamed `unicode` to `str` on Python 3, but that is really a superficial change in the Python language. The C API function names start with `PyUnicode`, and that is what Cython really cares about.",
    "created_at": "2017-10-23T08:31:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432887",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:28'></a>Let me clarify: when Cython compiles Cython code to C, it doesn't yet know if the C code will be compiled as Python 2 and Python 3. So when it sees a `"string"` literal, it doesn't really know what king of string it will be. To solve this, Cython internally really has 3 string types: `bytes`, `str` and `unicode`. Both `bytes` and `unicode` are easy to deal with, since they refer to the same type on Python 2 and Python 3 (*). To deal with `str`, it uses macros like

```
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
```

(*) I know that they renamed `unicode` to `str` on Python 3, but that is really a superficial change in the Python language. The C API function names start with `PyUnicode`, and that is what Cython really cares about.



---

archive/issue_comments_432888.json:
```json
{
    "body": "<a id='comment:29'></a>I didn't realize that even when compiling Python 3 sources Cython still defines \"unicode\" as a built-in, which is surprising--that's part of my confusion.\n\nI was looking at the code myself just now, and I think my confusion with your explanation comes from the fact that you're referring to \"three distinct types\".  And it's true, that it has the *names* `unicode`, `str`, and `bytes` in all cases.  But that doesn't mean there are three distinct types.  On any given Python there are only two distinct types and all we're talking about is changing around which labels we assign to which types.  I'm confused when you speak of \"distinct types\" because it makes me think that Cython is reimplementing Python 2 `str`s in Python 3 which doesn't make sense to do, and I was pretty sure *wasn't* done.\n\nAnyways we're in agreement that language_level doesn't do much in the end.  It does also make some difference in how string literals are parsed which might lead to confusion somewhere, but I don't think it's critical.",
    "created_at": "2017-10-23T08:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432888",
    "user": "https://github.com/embray"
}
```

<a id='comment:29'></a>I didn't realize that even when compiling Python 3 sources Cython still defines "unicode" as a built-in, which is surprising--that's part of my confusion.

I was looking at the code myself just now, and I think my confusion with your explanation comes from the fact that you're referring to "three distinct types".  And it's true, that it has the *names* `unicode`, `str`, and `bytes` in all cases.  But that doesn't mean there are three distinct types.  On any given Python there are only two distinct types and all we're talking about is changing around which labels we assign to which types.  I'm confused when you speak of "distinct types" because it makes me think that Cython is reimplementing Python 2 `str`s in Python 3 which doesn't make sense to do, and I was pretty sure *wasn't* done.

Anyways we're in agreement that language_level doesn't do much in the end.  It does also make some difference in how string literals are parsed which might lead to confusion somewhere, but I don't think it's critical.



---

archive/issue_comments_432889.json:
```json
{
    "body": "<a id='comment:30'></a>Replying to [comment:29 embray]:\n> But that doesn't mean there are three distinct types.\n\n\nFrom Cython's point of view, there really are 3 types because Cython doesn't know whether the C code will be compiled as Python 2 or Python 3. It is only after the fact that it \"happens\" that str maps to bytes or unicode.\n\nBut the Cython compiler has 3 classes `BytesNode`, `UnicodeNode` and `StringNode` to deal with the 3 kinds of string constants. And this is where the `from __future__ import unicode_literals` (which is implied by `language_level=3`) comes in: unprefixed `\"string\"` literals becomes `UnicodeNode` instead of `StringNode`.",
    "created_at": "2017-10-23T08:57:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432889",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:30'></a>Replying to [comment:29 embray]:
> But that doesn't mean there are three distinct types.


From Cython's point of view, there really are 3 types because Cython doesn't know whether the C code will be compiled as Python 2 or Python 3. It is only after the fact that it "happens" that str maps to bytes or unicode.

But the Cython compiler has 3 classes `BytesNode`, `UnicodeNode` and `StringNode` to deal with the 3 kinds of string constants. And this is where the `from __future__ import unicode_literals` (which is implied by `language_level=3`) comes in: unprefixed `"string"` literals becomes `UnicodeNode` instead of `StringNode`.



---

archive/issue_comments_432890.json:
```json
{
    "body": "<a id='comment:31'></a>FWIW this is also helpful:\n\n```\n    builtin_entries = {\n\n        \"type\":   [\"((PyObject*)&PyType_Type)\", py_object_type],\n\n        \"bool\":   [\"((PyObject*)&PyBool_Type)\", py_object_type],\n        \"int\":    [\"((PyObject*)&PyInt_Type)\", py_object_type],\n        \"long\":   [\"((PyObject*)&PyLong_Type)\", py_object_type],\n        \"float\":  [\"((PyObject*)&PyFloat_Type)\", py_object_type],\n        \"complex\":[\"((PyObject*)&PyComplex_Type)\", py_object_type],\n\n        \"bytes\":  [\"((PyObject*)&PyBytes_Type)\", py_object_type],\n        \"bytearray\":   [\"((PyObject*)&PyByteArray_Type)\", py_object_type],\n        \"str\":    [\"((PyObject*)&PyString_Type)\", py_object_type],\n        \"unicode\":[\"((PyObject*)&PyUnicode_Type)\", py_object_type],\n        ...\n```\n\nThis is how it determines certain built-in names.  Incidentally Python 2 has `#define PyBytes_Type PyString_Type` in its headers, but Python 3 does not have `#define PyString_Type PyUnicode_Type` which is why Cython has to include that explicitly.\n\nI disagree with your read on the situation.  The parser/compiler may have three Node types which makes sense, but there aren't three distinct types at runtime ever.",
    "created_at": "2017-10-23T09:03:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432890",
    "user": "https://github.com/embray"
}
```

<a id='comment:31'></a>FWIW this is also helpful:

```
    builtin_entries = {

        "type":   ["((PyObject*)&PyType_Type)", py_object_type],

        "bool":   ["((PyObject*)&PyBool_Type)", py_object_type],
        "int":    ["((PyObject*)&PyInt_Type)", py_object_type],
        "long":   ["((PyObject*)&PyLong_Type)", py_object_type],
        "float":  ["((PyObject*)&PyFloat_Type)", py_object_type],
        "complex":["((PyObject*)&PyComplex_Type)", py_object_type],

        "bytes":  ["((PyObject*)&PyBytes_Type)", py_object_type],
        "bytearray":   ["((PyObject*)&PyByteArray_Type)", py_object_type],
        "str":    ["((PyObject*)&PyString_Type)", py_object_type],
        "unicode":["((PyObject*)&PyUnicode_Type)", py_object_type],
        ...
```

This is how it determines certain built-in names.  Incidentally Python 2 has `#define PyBytes_Type PyString_Type` in its headers, but Python 3 does not have `#define PyString_Type PyUnicode_Type` which is why Cython has to include that explicitly.

I disagree with your read on the situation.  The parser/compiler may have three Node types which makes sense, but there aren't three distinct types at runtime ever.



---

archive/issue_comments_432891.json:
```json
{
    "body": "<a id='comment:32'></a>See #26403 for a related ticket that I'm working on.",
    "created_at": "2018-10-04T15:27:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23089",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23089#issuecomment-432891",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:32'></a>See #26403 for a related ticket that I'm working on.
