# Issue 23505: Lattice precision for p-adics

archive/issues_023268.json:
```json
{
    "body": "In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).\n\nFor much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf\n\nThe aim of this ticket is to propose a rough implementation of these ideas. \n\nYou can play with the latest version of this by clicking on launch binder [here](https://github.com/saraedum/sage-binder-env/tree/t-23505-lattice-precision).\n\nBelow is a small demo (extracted from the doctest).\n\n```\n\n   Below is a small demo of the features by this model of precision:\n\n      sage: R = ZpLP(3, print_mode='terse')\n      sage: x = R(1,10)\n\n   Of course, when we multiply by 3, we gain one digit of absolute\n   precision:\n\n      sage: 3*x\n      3 + O(3^11)\n\n   The lattice precision machinery sees this even if we decompose the\n   computation into several steps:\n\n      sage: y = x+x\n      sage: y\n      2 + O(3^10)\n      sage: x + y\n      3 + O(3^11)\n\n   The same works for the multiplication:\n\n      sage: z = x^2\n      sage: z\n      1 + O(3^10)\n      sage: x*z\n      1 + O(3^11)\n\n   This comes more funny when we are working with elements given at\n   different precisions:\n\n      sage: R = ZpLP(2, print_mode='terse')\n      sage: x = R(1,10)\n      sage: y = R(1,5)\n      sage: z = x+y; z\n      2 + O(2^5)\n      sage: t = x-y; t\n      0 + O(2^5)\n      sage: z+t  # observe that z+t = 2*x\n      2 + O(2^11)\n      sage: z-t  # observe that z-t = 2*y\n      2 + O(2^6)\n\n      sage: x = R(28888,15)\n      sage: y = R(204,10)\n      sage: z = x/y; z\n      242 + O(2^9)\n      sage: z*y  # which is x\n      28888 + O(2^15)\n\n   The SOMOS sequence is the sequence defined by the recurrence:\n\n      ..MATH::\n\n      u_n =  rac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}\n\n   It is known for its numerical instability. On the one hand, one can\n   show that if the initial values are invertible in mathbb{Z}_p and\n   known at precision O(p^N) then all the next terms of the SOMOS\n   sequence will be known at the same precision as well. On the other\n   hand, because of the division, when we unroll the recurrence, we\n   loose a lot of precision. Observe:\n\n      sage: R = Zp(2, 30, print_mode='terse')\n      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      4 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      13 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      55 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      21975 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      6639 + O(2^13)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      7186 + O(2^13)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      569 + O(2^13)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      253 + O(2^13)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      4149 + O(2^13)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      2899 + O(2^12)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      3072 + O(2^12)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      349 + O(2^12)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      619 + O(2^12)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      243 + O(2^12)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      3 + O(2^2)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      2 + O(2^2)\n\n   If instead, we use the lattice precision, everything goes well:\n\n      sage: R = ZpLP(2, 30, print_mode='terse')\n      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      4 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      13 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      55 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      21975 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      23023 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      31762 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      16953 + O(2^15)\n      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n      16637 + O(2^15)\n\n      sage: for _ in range(100):\n      ....:     a,b,c,d = b,c,d,(b*d+c*c)/a\n      sage: a\n      15519 + O(2^15)\n      sage: b\n      32042 + O(2^15)\n      sage: c\n      17769 + O(2^15)\n      sage: d\n      20949 + O(2^15)\n\n   BEHIND THE SCENE:\n\n   The precision is global. It is encoded by a lattice in a huge\n   vector space whose dimension is the number of elements having this\n   parent.\n\n   Concretely, this precision datum is an instance of the class\n   \"sage.rings.padic.lattice_precision.PrecisionLattice\". It is\n   attached to the parent and is created at the same time as the\n   parent. (It is actually a bit more subtle because two different\n   parents may share the same instance; this happens for instance for\n   a p-adic ring and its field of fractions.)\n\n   This precision datum is accessible through the method\n   \"precision()\":\n\n      sage: R = ZpLP(5, print_mode='terse')\n      sage: prec = R.precision()\n      sage: prec\n      Precision Lattice on 0 object\n\n   This instance knows about all elements of the parent, it is\n   automatically updated when a new element (of this parent) is\n   created:\n\n      sage: x = R(3513,10)\n      sage: prec\n      Precision Lattice on 1 object\n      sage: y = R(176,5)\n      sage: prec\n      Precision Lattice on 2 objects\n      sage: z = R.random_element()\n      sage: prec\n      Precision Lattice on 3 objects\n\n   The method \"tracked_elements()\" provides the list of all tracked\n   elements:\n\n      sage: prec.tracked_elements()\n      [3513 + O(5^10), 176 + O(5^5), ...]\n\n   Similarly, when a variable is collected by the garbage collector,\n   the precision lattice is updated. Note however that the update\n   might be delayed. We can force it with the method \"del_elements()\":\n\n      sage: z = 0\n      sage: prec\n      Precision Lattice on 3 objects\n      sage: prec.del_elements()\n      sage: prec\n      Precision Lattice on 2 objects\n\n   The method \"precision_lattice()\" returns (a matrix defining) the\n   lattice that models the precision. Here we have:\n\n      sage: prec.precision_lattice()\n      [9765625       0]\n      [      0    3125]\n\n   Observe that 5^10 = 9765625 and 5^5 = 3125. The above matrix then\n   reflects the precision on x and y.\n\n   Now, observe how the precision lattice changes while performing\n   computations:\n\n      sage: x, y = 3*x+2*y, 2*(x-y)\n      sage: prec.del_elements()\n      sage: prec.precision_lattice()\n      [    3125 48825000]\n      [       0 48828125]\n\n   The matrix we get is no longer diagonal, meaning that some digits\n   of precision are diffused among the two new elements x and y. They\n   nevertheless show up when we compute for instance x+y:\n\n      sage: x\n      1516 + O(5^5)\n      sage: y\n      424 + O(5^5)\n      sage: x+y\n      17565 + O(5^11)\n\n   It is these diffused digits of precision (which are tracked but do\n   not appear on the printing) that allow to be always sharp on\n   precision.\n\n   PERFORMANCES:\n\n   Each elementary operation requires significant manipulations on the\n   lattice precision and then is costly. Precisely:\n\n   * The creation of a new element has a cost O(n) when n is the\n     number of tracked elements.\n\n   * The destruction of one element has a cost O(m^2) when m is the\n     distance between the destroyed element and the last one.\n     Fortunately, it seems that m tends to be small in general (the\n     dynamics of the list of tracked elements is rather close to that\n     of a stack).\n\n   It is nevertheless still possible to manipulate several hundred\n   variables (e.g. squares matrices of size 5 or polynomials of degree\n   20 are accessible).\n\n   The class \"PrecisionLattice\" provides several features for\n   introspection (especially concerning timings). If enables, it\n   maintains an history of all actions and stores the wall time of\n   each of them:\n\n      sage: R = ZpLP(3)\n      sage: prec = R.precision()\n      sage: prec.history_enable()\n      sage: M = random_matrix(R, 5)\n      sage: d = M.determinant()\n      sage: print prec.history()  # somewhat random\n         ---\n      0.004212s  oooooooooooooooooooooooooooooooooooo\n      0.000003s  oooooooooooooooooooooooooooooooooo~~\n      0.000010s  oooooooooooooooooooooooooooooooooo\n      0.001560s  ooooooooooooooooooooooooooooooooooooooooo\n      0.000004s  ooooooooooooooooooooooooooooo~oooo~oooo~o\n      0.002168s  oooooooooooooooooooooooooooooooooooooo\n      0.001787s  ooooooooooooooooooooooooooooooooooooooooo\n      0.000004s  oooooooooooooooooooooooooooooooooooooo~~o\n      0.000198s  ooooooooooooooooooooooooooooooooooooooo\n      0.001152s  ooooooooooooooooooooooooooooooooooooooooo\n      0.000005s  ooooooooooooooooooooooooooooooooo~oooo~~o\n      0.000853s  oooooooooooooooooooooooooooooooooooooo\n      0.000610s  ooooooooooooooooooooooooooooooooooooooo\n      ...\n      0.003879s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.000006s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~\n      0.000036s  oooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.006737s  oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.000005s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~ooooo\n      0.002637s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.007118s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.000008s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~o~~~~oooo\n      0.003504s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.005371s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.000006s  ooooooooooooooooooooooooooooooooooooooooooooooooooooo~~~o~~~ooo\n      0.001858s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.003584s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.000004s  oooooooooooooooooooooooooooooooooooooooooooooooooooooo~~o~~oo\n      0.000801s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.001916s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n      0.000022s  ooooooooooooooooooooooooooooo~~~~~~~~~~~~~~~~~~~~~~oooo~o~o\n      0.014705s  ooooooooooooooooooooooooooooooooooo\n      0.001292s  ooooooooooooooooooooooooooooooooooooo\n      0.000002s  ooooooooooooooooooooooooooooooooooo~o\n\n   The symbol o symbolized a tracked element. The symbol ~ means that\n   the element is marked for deletion.\n\n   The global timings are also accessible as follows:\n\n      sage: prec.timings()   # somewhat random\n      {'add': 0.25049376487731934,\n       'del': 0.11911273002624512,\n       'mark': 0.0004909038543701172,\n       'partial reduce': 0.0917658805847168}\n\n```\n\n\nCC:  @roed314 tristanvaccon @saraedum @mezzarobba swewers\n\nKeywords: sd87\n\nReviewer: David Roe, Julian R\u00fcth\n\nAuthor: Xavier Caruso\n\nBranch: f29502ee1739ae2013f273ffae063cb0820b5fbc\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/23505\n\n",
    "closed_at": "2018-03-08T00:02:48Z",
    "created_at": "2017-07-21T05:39:49Z",
    "labels": [
        "component: padics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "Lattice precision for p-adics",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23505",
    "user": "https://github.com/xcaruso"
}
```
In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).

For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf

The aim of this ticket is to propose a rough implementation of these ideas. 

You can play with the latest version of this by clicking on launch binder [here](https://github.com/saraedum/sage-binder-env/tree/t-23505-lattice-precision).

Below is a small demo (extracted from the doctest).

```

   Below is a small demo of the features by this model of precision:

      sage: R = ZpLP(3, print_mode='terse')
      sage: x = R(1,10)

   Of course, when we multiply by 3, we gain one digit of absolute
   precision:

      sage: 3*x
      3 + O(3^11)

   The lattice precision machinery sees this even if we decompose the
   computation into several steps:

      sage: y = x+x
      sage: y
      2 + O(3^10)
      sage: x + y
      3 + O(3^11)

   The same works for the multiplication:

      sage: z = x^2
      sage: z
      1 + O(3^10)
      sage: x*z
      1 + O(3^11)

   This comes more funny when we are working with elements given at
   different precisions:

      sage: R = ZpLP(2, print_mode='terse')
      sage: x = R(1,10)
      sage: y = R(1,5)
      sage: z = x+y; z
      2 + O(2^5)
      sage: t = x-y; t
      0 + O(2^5)
      sage: z+t  # observe that z+t = 2*x
      2 + O(2^11)
      sage: z-t  # observe that z-t = 2*y
      2 + O(2^6)

      sage: x = R(28888,15)
      sage: y = R(204,10)
      sage: z = x/y; z
      242 + O(2^9)
      sage: z*y  # which is x
      28888 + O(2^15)

   The SOMOS sequence is the sequence defined by the recurrence:

      ..MATH::

      u_n =  rac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}

   It is known for its numerical instability. On the one hand, one can
   show that if the initial values are invertible in mathbb{Z}_p and
   known at precision O(p^N) then all the next terms of the SOMOS
   sequence will be known at the same precision as well. On the other
   hand, because of the division, when we unroll the recurrence, we
   loose a lot of precision. Observe:

      sage: R = Zp(2, 30, print_mode='terse')
      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      4 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      13 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      55 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      21975 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      6639 + O(2^13)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      7186 + O(2^13)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      569 + O(2^13)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      253 + O(2^13)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      4149 + O(2^13)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      2899 + O(2^12)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      3072 + O(2^12)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      349 + O(2^12)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      619 + O(2^12)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      243 + O(2^12)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      3 + O(2^2)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      2 + O(2^2)

   If instead, we use the lattice precision, everything goes well:

      sage: R = ZpLP(2, 30, print_mode='terse')
      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      4 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      13 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      55 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      21975 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      23023 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      31762 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      16953 + O(2^15)
      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
      16637 + O(2^15)

      sage: for _ in range(100):
      ....:     a,b,c,d = b,c,d,(b*d+c*c)/a
      sage: a
      15519 + O(2^15)
      sage: b
      32042 + O(2^15)
      sage: c
      17769 + O(2^15)
      sage: d
      20949 + O(2^15)

   BEHIND THE SCENE:

   The precision is global. It is encoded by a lattice in a huge
   vector space whose dimension is the number of elements having this
   parent.

   Concretely, this precision datum is an instance of the class
   "sage.rings.padic.lattice_precision.PrecisionLattice". It is
   attached to the parent and is created at the same time as the
   parent. (It is actually a bit more subtle because two different
   parents may share the same instance; this happens for instance for
   a p-adic ring and its field of fractions.)

   This precision datum is accessible through the method
   "precision()":

      sage: R = ZpLP(5, print_mode='terse')
      sage: prec = R.precision()
      sage: prec
      Precision Lattice on 0 object

   This instance knows about all elements of the parent, it is
   automatically updated when a new element (of this parent) is
   created:

      sage: x = R(3513,10)
      sage: prec
      Precision Lattice on 1 object
      sage: y = R(176,5)
      sage: prec
      Precision Lattice on 2 objects
      sage: z = R.random_element()
      sage: prec
      Precision Lattice on 3 objects

   The method "tracked_elements()" provides the list of all tracked
   elements:

      sage: prec.tracked_elements()
      [3513 + O(5^10), 176 + O(5^5), ...]

   Similarly, when a variable is collected by the garbage collector,
   the precision lattice is updated. Note however that the update
   might be delayed. We can force it with the method "del_elements()":

      sage: z = 0
      sage: prec
      Precision Lattice on 3 objects
      sage: prec.del_elements()
      sage: prec
      Precision Lattice on 2 objects

   The method "precision_lattice()" returns (a matrix defining) the
   lattice that models the precision. Here we have:

      sage: prec.precision_lattice()
      [9765625       0]
      [      0    3125]

   Observe that 5^10 = 9765625 and 5^5 = 3125. The above matrix then
   reflects the precision on x and y.

   Now, observe how the precision lattice changes while performing
   computations:

      sage: x, y = 3*x+2*y, 2*(x-y)
      sage: prec.del_elements()
      sage: prec.precision_lattice()
      [    3125 48825000]
      [       0 48828125]

   The matrix we get is no longer diagonal, meaning that some digits
   of precision are diffused among the two new elements x and y. They
   nevertheless show up when we compute for instance x+y:

      sage: x
      1516 + O(5^5)
      sage: y
      424 + O(5^5)
      sage: x+y
      17565 + O(5^11)

   It is these diffused digits of precision (which are tracked but do
   not appear on the printing) that allow to be always sharp on
   precision.

   PERFORMANCES:

   Each elementary operation requires significant manipulations on the
   lattice precision and then is costly. Precisely:

   * The creation of a new element has a cost O(n) when n is the
     number of tracked elements.

   * The destruction of one element has a cost O(m^2) when m is the
     distance between the destroyed element and the last one.
     Fortunately, it seems that m tends to be small in general (the
     dynamics of the list of tracked elements is rather close to that
     of a stack).

   It is nevertheless still possible to manipulate several hundred
   variables (e.g. squares matrices of size 5 or polynomials of degree
   20 are accessible).

   The class "PrecisionLattice" provides several features for
   introspection (especially concerning timings). If enables, it
   maintains an history of all actions and stores the wall time of
   each of them:

      sage: R = ZpLP(3)
      sage: prec = R.precision()
      sage: prec.history_enable()
      sage: M = random_matrix(R, 5)
      sage: d = M.determinant()
      sage: print prec.history()  # somewhat random
         ---
      0.004212s  oooooooooooooooooooooooooooooooooooo
      0.000003s  oooooooooooooooooooooooooooooooooo~~
      0.000010s  oooooooooooooooooooooooooooooooooo
      0.001560s  ooooooooooooooooooooooooooooooooooooooooo
      0.000004s  ooooooooooooooooooooooooooooo~oooo~oooo~o
      0.002168s  oooooooooooooooooooooooooooooooooooooo
      0.001787s  ooooooooooooooooooooooooooooooooooooooooo
      0.000004s  oooooooooooooooooooooooooooooooooooooo~~o
      0.000198s  ooooooooooooooooooooooooooooooooooooooo
      0.001152s  ooooooooooooooooooooooooooooooooooooooooo
      0.000005s  ooooooooooooooooooooooooooooooooo~oooo~~o
      0.000853s  oooooooooooooooooooooooooooooooooooooo
      0.000610s  ooooooooooooooooooooooooooooooooooooooo
      ...
      0.003879s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.000006s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~
      0.000036s  oooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.006737s  oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.000005s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~ooooo
      0.002637s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.007118s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.000008s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~o~~~~oooo
      0.003504s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.005371s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.000006s  ooooooooooooooooooooooooooooooooooooooooooooooooooooo~~~o~~~ooo
      0.001858s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.003584s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.000004s  oooooooooooooooooooooooooooooooooooooooooooooooooooooo~~o~~oo
      0.000801s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.001916s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
      0.000022s  ooooooooooooooooooooooooooooo~~~~~~~~~~~~~~~~~~~~~~oooo~o~o
      0.014705s  ooooooooooooooooooooooooooooooooooo
      0.001292s  ooooooooooooooooooooooooooooooooooooo
      0.000002s  ooooooooooooooooooooooooooooooooooo~o

   The symbol o symbolized a tracked element. The symbol ~ means that
   the element is marked for deletion.

   The global timings are also accessible as follows:

      sage: prec.timings()   # somewhat random
      {'add': 0.25049376487731934,
       'del': 0.11911273002624512,
       'mark': 0.0004909038543701172,
       'partial reduce': 0.0917658805847168}

```


CC:  @roed314 tristanvaccon @saraedum @mezzarobba swewers

Keywords: sd87

Reviewer: David Roe, Julian Rüth

Author: Xavier Caruso

Branch: f29502ee1739ae2013f273ffae063cb0820b5fbc

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/23505





---

archive/issue_comments_346601.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2017-07-22T04:09:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346601",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_346602.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -2,129 +2,144 @@\n \n For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf\n \n-The aim of this ticket is to propose to implement these ideas in [SageMath](SageMath). \n-More precisely, I propose to create a new parent `QpLP` (LP for \"lattice precision\") for which the precision is tracked using lattices. This leads to some difficulties:\n-- Since a lattice does not in general split properly, the precision datum is a global object which must be handled by the parent (and not by its elements). For this reason, the parent has to manage the precision itself for all its elements. In particular, he has to maintain an up-to-date list of all its elements (and should be then informed whenever one of its elements is collected by the garbage collector).\n-- If f is not surjective, df_x(H) is no longer a lattice. However, dealing with general Zp-submodules (and not only lattices) is more complicated for several reasons (the first one is that they are not exact objects whereas lattices are). For this reason, we introduce a `working_precision_cap` and feel free to add to our precision lattice any multiple of `p^working_precision_cap` if needed.\n+The aim of this ticket is to propose a rough implementation of these ideas. \n \n-## About implementation\n-\n-The pseudo-code below gives some hints about the implementation I have in mind. Comments are welcome! \n+Below is a small demo (extracted from the doctest).\n \n ```\n \n-# The parent\n-############\n+    sage: R = ZpLP(3)\n+    sage: x = R(1,10)\n \n-class pAdicFieldLattice(pAdicRingBaseGeneric):\n-    # Internal variables:\n-    #  . self._working_precision_cap\n-    #    a cap for the working precision\n-    #    meaning that the precision lattice always contains p^(self._working_precision_cap)\n-    #  . self._elements\n-    #    list of weak references of elements in this parent\n-    #  . self._precision_lattice\n-    #    a matrix over ZZ representing the lattice of precision\n-    #    (its columns are indexed by self._elements)\n+Of course, when we multiply by 3, we gain one digit of absolute\n+precision::\n \n-    def __init__(self, p, working_precision_cap, print_mode):\n-        # Initialize variables here\n+    sage: 3*x\n+    3 + O(3^11)\n \n-    def _echelonize(self):\n-        # Echelonize the matrix giving the precision lattice\n+The lattice precision machinery sees this even if we decompose\n+the computation into several steps::\n \n-    def _add_element(self, elt, prec):\n-        # A new element in the parent has just been created\n-        # We should:\n-        #  . add a weak reference to it to the list self._elements\n-        #  . add a column to self._precision_lattice\n-        #    and update this matrix according to prec \n-        #    (and possibly the working precision cap)\n-        # NOTE: prec be either an integer or a formal linear combinaison\n-        # of the precision on the other elements of this parent\n+    sage: y = x+x\n+    sage: y\n+    2 + O(3^10)\n+    sage: x+y\n+    3 + O(3^11)\n \n-    def _del_element(self, elt):\n-        # The element elt has just been garbage collected\n-        # We should:\n-        #  . remove it to the list self._elements\n-        #  . remove the corresponding column of self._precision_lattice\n+The same works for the multiplication::\n \n-    def precision_absolute(self, elt):\n-        # Return the (optimal) absolute precision of the element elt\n-        # This precision can be read off on self._precision_lattice:\n-        # it is the smallest valuation of an entry of the column of\n-        # self._precision_lattice corresponding to the element elt\n+    sage: z = x^2\n+    sage: z\n+    1 + O(3^10)\n+    sage: x*z\n+    1 + O(3^11)\n \n-    def working_precision(self, elt):\n-        # Return the working precision of the element elt\n-        # This precision can be read off on the precision lattice:\n-        # it is the smallest integer n for which the precision\n-        # lattice contains p^n*[elt] where [elt] denotes the \n-        # basis vector corresponding to elt\n+This comes more funny when we are working with elements given\n+at different precisions::\n \n-    def _element_constructor_(self, x, prec):\n-        # We ask for the creation of an element in this parent\n-        # We should:\n-        #  . create this element (called elt hereafter) from x\n-        #    Note: elt is an instance of the class pAdicLatticeElement below\n-        #  . call the method _new_element(elt, prec)\n-        #  . install a callback so that when elt will be collected\n-        #    by the garbage collector, the method _del_element will\n-        #    be called\n+    sage: R = ZpLP(2)\n+    sage: x = R(1,10)\n+    sage: y = R(1,5)\n+    sage: z = x+y; z\n+    2 + O(2^5)\n+    sage: t = x-y; t\n+    0 + O(2^5)\n+    sage: z+t  # observe that z+t = 2*x\n+    2 + O(2^11)\n+    sage: z-t  # observe that z-t = 2*y\n+    2 + O(2^6)\n \n-QpLP = pAdicFieldLattice\n+    sage: x = R(28888,15)\n+    sage: y = R(204,10)\n+    sage: z = x/y; z\n+    242 + O(2^9)\n+    sage: z*y  # which is x\n+    28888 + O(2^15)\n \n+The SOMOS sequence is the sequence defined by the recurrence::\n \n-# The elements\n-##############\n+..MATH::\n \n-class pAdicLatticeElement(Element):\n-    # Internal variable:\n-    #  . self._approximation\n-    #    an approximation of this p-adic number\n-    #    it is defined modulo p^(working_precision)\n+    u_n = \\frac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}\n \n-    def working_precision(self):\n-        return self.parent().working_precision(self)\n+It is known for its numerical instability.\n+On the one hand, one can show that if the initial values are\n+invertible in `\\mathbb{Z}_p` and known at precision `O(p^N)`\n+then all the next terms of the SOMOS sequence will be known\n+at the same precision as well.\n+On the other hand, because of the division, when we unroll\n+the recurrence, we loose a lot of precision. Observe::\n \n-    def approximation(self):\n-        # We should:\n-        #  . reduce self._approximation modulo p^(self.working_precision())\n-        #    (and update self._approximation accordingly)\n-        #  . return the result\n+    sage: R = Zp(2, print_mode='terse')\n+    sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    4 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    13 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    55 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    21975 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    6639 + O(2^13)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    7186 + O(2^13)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    569 + O(2^13)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    253 + O(2^13)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    4149 + O(2^13)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    2899 + O(2^12)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    3072 + O(2^12)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    349 + O(2^12)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    619 + O(2^12)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    243 + O(2^12)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    3 + O(2^2)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    2 + O(2^2)\n \n-    def precision_absolute(self):\n-        return self.parent().precision_absolute(self)\n+If instead, we use the lattice precision, everything goes well::\n \n-    def valuation(self, secure=False):\n-        # We should:\n-        #  . compute the valuation of self.approximation()\n-        #  . compare it to the self.precision_absolute()\n-        #  . if the former is less than the latter, we return the former\n-        #  . otherwise, if secure is False, we return the latter\n-        #               if secure is True, we raise an error\n+    sage: R = ZpLP(2)\n+    sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    4 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    13 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    55 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    21975 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    23023 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    31762 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    16953 + O(2^15)\n+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+    16637 + O(2^15)\n \n-    def precision_relative(self, secure=False):\n-        return self.precision_absolute() - self.valuation(secure=secure)\n-\n-    def _repr_(self):\n-        # Print like this:\n-        #   self.approximation() + O(p^self.precision_absolute())\n-\n-\n-    def _add_(self, other):\n-        # We should:\n-        #  . compute app = self.approximation() + other.approximation()\n-        #  . create a new element from app and the precision given by the differential:\n-        #    dapp = dself + dother\n-\n-    def _mul_(self, other):\n-        # We should:\n-        #  . compute app = self.approximation() * other.approximation()\n-        #  . create a new element from app and the precision given by the differential:\n-        #    dapp = self*dother + other*dself\n+    sage: for _ in range(100):\n+    ....:     a,b,c,d = b,c,d,(b*d+c*c)/a\n+    sage: a\n+    15519 + O(2^15)\n+    sage: b\n+    32042 + O(2^15)\n+    sage: c\n+    17769 + O(2^15)\n+    sage: d\n+    20949 + O(2^15)\n \n ```\n+\n+PS: For now, the code is far from being ready for review. Any help will be of course quite appreciated.\n \n Comment: 1\n \n```\n",
    "created_at": "2017-07-22T04:09:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346602",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
```diff
--- 
+++ 
@@ -2,129 +2,144 @@
 
 For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf
 
-The aim of this ticket is to propose to implement these ideas in [SageMath](SageMath). 
-More precisely, I propose to create a new parent `QpLP` (LP for "lattice precision") for which the precision is tracked using lattices. This leads to some difficulties:
-- Since a lattice does not in general split properly, the precision datum is a global object which must be handled by the parent (and not by its elements). For this reason, the parent has to manage the precision itself for all its elements. In particular, he has to maintain an up-to-date list of all its elements (and should be then informed whenever one of its elements is collected by the garbage collector).
-- If f is not surjective, df_x(H) is no longer a lattice. However, dealing with general Zp-submodules (and not only lattices) is more complicated for several reasons (the first one is that they are not exact objects whereas lattices are). For this reason, we introduce a `working_precision_cap` and feel free to add to our precision lattice any multiple of `p^working_precision_cap` if needed.
+The aim of this ticket is to propose a rough implementation of these ideas. 
 
-## About implementation
-
-The pseudo-code below gives some hints about the implementation I have in mind. Comments are welcome! 
+Below is a small demo (extracted from the doctest).
 
 ```
 
-# The parent
-############
+    sage: R = ZpLP(3)
+    sage: x = R(1,10)
 
-class pAdicFieldLattice(pAdicRingBaseGeneric):
-    # Internal variables:
-    #  . self._working_precision_cap
-    #    a cap for the working precision
-    #    meaning that the precision lattice always contains p^(self._working_precision_cap)
-    #  . self._elements
-    #    list of weak references of elements in this parent
-    #  . self._precision_lattice
-    #    a matrix over ZZ representing the lattice of precision
-    #    (its columns are indexed by self._elements)
+Of course, when we multiply by 3, we gain one digit of absolute
+precision::
 
-    def __init__(self, p, working_precision_cap, print_mode):
-        # Initialize variables here
+    sage: 3*x
+    3 + O(3^11)
 
-    def _echelonize(self):
-        # Echelonize the matrix giving the precision lattice
+The lattice precision machinery sees this even if we decompose
+the computation into several steps::
 
-    def _add_element(self, elt, prec):
-        # A new element in the parent has just been created
-        # We should:
-        #  . add a weak reference to it to the list self._elements
-        #  . add a column to self._precision_lattice
-        #    and update this matrix according to prec 
-        #    (and possibly the working precision cap)
-        # NOTE: prec be either an integer or a formal linear combinaison
-        # of the precision on the other elements of this parent
+    sage: y = x+x
+    sage: y
+    2 + O(3^10)
+    sage: x+y
+    3 + O(3^11)
 
-    def _del_element(self, elt):
-        # The element elt has just been garbage collected
-        # We should:
-        #  . remove it to the list self._elements
-        #  . remove the corresponding column of self._precision_lattice
+The same works for the multiplication::
 
-    def precision_absolute(self, elt):
-        # Return the (optimal) absolute precision of the element elt
-        # This precision can be read off on self._precision_lattice:
-        # it is the smallest valuation of an entry of the column of
-        # self._precision_lattice corresponding to the element elt
+    sage: z = x^2
+    sage: z
+    1 + O(3^10)
+    sage: x*z
+    1 + O(3^11)
 
-    def working_precision(self, elt):
-        # Return the working precision of the element elt
-        # This precision can be read off on the precision lattice:
-        # it is the smallest integer n for which the precision
-        # lattice contains p^n*[elt] where [elt] denotes the 
-        # basis vector corresponding to elt
+This comes more funny when we are working with elements given
+at different precisions::
 
-    def _element_constructor_(self, x, prec):
-        # We ask for the creation of an element in this parent
-        # We should:
-        #  . create this element (called elt hereafter) from x
-        #    Note: elt is an instance of the class pAdicLatticeElement below
-        #  . call the method _new_element(elt, prec)
-        #  . install a callback so that when elt will be collected
-        #    by the garbage collector, the method _del_element will
-        #    be called
+    sage: R = ZpLP(2)
+    sage: x = R(1,10)
+    sage: y = R(1,5)
+    sage: z = x+y; z
+    2 + O(2^5)
+    sage: t = x-y; t
+    0 + O(2^5)
+    sage: z+t  # observe that z+t = 2*x
+    2 + O(2^11)
+    sage: z-t  # observe that z-t = 2*y
+    2 + O(2^6)
 
-QpLP = pAdicFieldLattice
+    sage: x = R(28888,15)
+    sage: y = R(204,10)
+    sage: z = x/y; z
+    242 + O(2^9)
+    sage: z*y  # which is x
+    28888 + O(2^15)
 
+The SOMOS sequence is the sequence defined by the recurrence::
 
-# The elements
-##############
+..MATH::
 
-class pAdicLatticeElement(Element):
-    # Internal variable:
-    #  . self._approximation
-    #    an approximation of this p-adic number
-    #    it is defined modulo p^(working_precision)
+    u_n = \frac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}
 
-    def working_precision(self):
-        return self.parent().working_precision(self)
+It is known for its numerical instability.
+On the one hand, one can show that if the initial values are
+invertible in `\mathbb{Z}_p` and known at precision `O(p^N)`
+then all the next terms of the SOMOS sequence will be known
+at the same precision as well.
+On the other hand, because of the division, when we unroll
+the recurrence, we loose a lot of precision. Observe::
 
-    def approximation(self):
-        # We should:
-        #  . reduce self._approximation modulo p^(self.working_precision())
-        #    (and update self._approximation accordingly)
-        #  . return the result
+    sage: R = Zp(2, print_mode='terse')
+    sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    4 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    13 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    55 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    21975 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    6639 + O(2^13)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    7186 + O(2^13)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    569 + O(2^13)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    253 + O(2^13)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    4149 + O(2^13)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    2899 + O(2^12)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    3072 + O(2^12)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    349 + O(2^12)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    619 + O(2^12)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    243 + O(2^12)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    3 + O(2^2)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    2 + O(2^2)
 
-    def precision_absolute(self):
-        return self.parent().precision_absolute(self)
+If instead, we use the lattice precision, everything goes well::
 
-    def valuation(self, secure=False):
-        # We should:
-        #  . compute the valuation of self.approximation()
-        #  . compare it to the self.precision_absolute()
-        #  . if the former is less than the latter, we return the former
-        #  . otherwise, if secure is False, we return the latter
-        #               if secure is True, we raise an error
+    sage: R = ZpLP(2)
+    sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    4 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    13 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    55 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    21975 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    23023 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    31762 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    16953 + O(2^15)
+    sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+    16637 + O(2^15)
 
-    def precision_relative(self, secure=False):
-        return self.precision_absolute() - self.valuation(secure=secure)
-
-    def _repr_(self):
-        # Print like this:
-        #   self.approximation() + O(p^self.precision_absolute())
-
-
-    def _add_(self, other):
-        # We should:
-        #  . compute app = self.approximation() + other.approximation()
-        #  . create a new element from app and the precision given by the differential:
-        #    dapp = dself + dother
-
-    def _mul_(self, other):
-        # We should:
-        #  . compute app = self.approximation() * other.approximation()
-        #  . create a new element from app and the precision given by the differential:
-        #    dapp = self*dother + other*dself
+    sage: for _ in range(100):
+    ....:     a,b,c,d = b,c,d,(b*d+c*c)/a
+    sage: a
+    15519 + O(2^15)
+    sage: b
+    32042 + O(2^15)
+    sage: c
+    17769 + O(2^15)
+    sage: d
+    20949 + O(2^15)
 
 ```
+
+PS: For now, the code is far from being ready for review. Any help will be of course quite appreciated.
 
 Comment: 1
 
```




---

archive/issue_comments_346603.json:
```json
{
    "body": "<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-22T04:09:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346603",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346604.json:
```json
{
    "body": "<a id='comment:5'></a>I've worked more on my implementation and, at least, it seems now to be usable.\n\nIt still requires a lot of work (convert to Cython, write templates, write doctests, rewrite completely the class `pRational` which is a hack, etc). I however post it because I think that some people might have fun  playing with it and discovering what lattice precision can do. Enjoy :-)\n\n`@`mmezzarobba: I add your name in Cc because I think that you could be interested. If you're not, feel free to remove it.",
    "created_at": "2017-08-01T23:54:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346604",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:5'></a>I've worked more on my implementation and, at least, it seems now to be usable.

It still requires a lot of work (convert to Cython, write templates, write doctests, rewrite completely the class `pRational` which is a hack, etc). I however post it because I think that some people might have fun  playing with it and discovering what lattice precision can do. Enjoy :-)

`@`mmezzarobba: I add your name in Cc because I think that you could be interested. If you're not, feel free to remove it.



---

archive/issue_comments_346605.json:
```json
{
    "body": "Changing type from task to enhancement.",
    "created_at": "2017-08-01T23:54:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346605",
    "user": "https://github.com/xcaruso"
}
```

Changing type from task to enhancement.



---

archive/issue_comments_346606.json:
```json
{
    "body": "<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-01T23:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346606",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346607.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,306 @@\n+In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).\n+\n+For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf\n+\n+The aim of this ticket is to propose a rough implementation of these ideas. \n+\n+Below is a small demo (extracted from the doctest).\n+\n+```\n+\n+   Below is a small demo of the features by this model of precision:\n+\n+      sage: R = ZpLP(3, print_mode='terse')\n+      sage: x = R(1,10)\n+\n+   Of course, when we multiply by 3, we gain one digit of absolute\n+   precision:\n+\n+      sage: 3*x\n+      3 + O(3^11)\n+\n+   The lattice precision machinery sees this even if we decompose the\n+   computation into several steps:\n+\n+      sage: y = x+x\n+      sage: y\n+      2 + O(3^10)\n+      sage: x + y\n+      3 + O(3^11)\n+\n+   The same works for the multiplication:\n+\n+      sage: z = x^2\n+      sage: z\n+      1 + O(3^10)\n+      sage: x*z\n+      1 + O(3^11)\n+\n+   This comes more funny when we are working with elements given at\n+   different precisions:\n+\n+      sage: R = ZpLP(2, print_mode='terse')\n+      sage: x = R(1,10)\n+      sage: y = R(1,5)\n+      sage: z = x+y; z\n+      2 + O(2^5)\n+      sage: t = x-y; t\n+      0 + O(2^5)\n+      sage: z+t  # observe that z+t = 2*x\n+      2 + O(2^11)\n+      sage: z-t  # observe that z-t = 2*y\n+      2 + O(2^6)\n+\n+      sage: x = R(28888,15)\n+      sage: y = R(204,10)\n+      sage: z = x/y; z\n+      242 + O(2^9)\n+      sage: z*y  # which is x\n+      28888 + O(2^15)\n+\n+   The SOMOS sequence is the sequence defined by the recurrence:\n+\n+      ..MATH::\n+\n+      u_n =  rac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}\n+\n+   It is known for its numerical instability. On the one hand, one can\n+   show that if the initial values are invertible in mathbb{Z}_p and\n+   known at precision O(p^N) then all the next terms of the SOMOS\n+   sequence will be known at the same precision as well. On the other\n+   hand, because of the division, when we unroll the recurrence, we\n+   loose a lot of precision. Observe:\n+\n+      sage: R = Zp(2, 30, print_mode='terse')\n+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      4 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      13 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      55 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      21975 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      6639 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      7186 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      569 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      253 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      4149 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      2899 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      3072 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      349 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      619 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      243 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      3 + O(2^2)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      2 + O(2^2)\n+\n+   If instead, we use the lattice precision, everything goes well:\n+\n+      sage: R = ZpLP(2, 30, print_mode='terse')\n+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      4 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      13 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      55 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      21975 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      23023 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      31762 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      16953 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      16637 + O(2^15)\n+\n+      sage: for _ in range(100):\n+      ....:     a,b,c,d = b,c,d,(b*d+c*c)/a\n+      sage: a\n+      15519 + O(2^15)\n+      sage: b\n+      32042 + O(2^15)\n+      sage: c\n+      17769 + O(2^15)\n+      sage: d\n+      20949 + O(2^15)\n+\n+   BEHIND THE SCENE:\n+\n+   The precision is global. It is encoded by a lattice in a huge\n+   vector space whose dimension is the number of elements having this\n+   parent.\n+\n+   Concretely, this precision datum is an instance of the class\n+   \"sage.rings.padic.lattice_precision.PrecisionLattice\". It is\n+   attached to the parent and is created at the same time as the\n+   parent. (It is actually a bit more subtle because two different\n+   parents may share the same instance; this happens for instance for\n+   a p-adic ring and its field of fractions.)\n+\n+   This precision datum is accessible through the method\n+   \"precision()\":\n+\n+      sage: R = ZpLP(5, print_mode='terse')\n+      sage: prec = R.precision()\n+      sage: prec\n+      Precision Lattice on 0 object\n+\n+   This instance knows about all elements of the parent, it is\n+   automatically updated when a new element (of this parent) is\n+   created:\n+\n+      sage: x = R(3513,10)\n+      sage: prec\n+      Precision Lattice on 1 object\n+      sage: y = R(176,5)\n+      sage: prec\n+      Precision Lattice on 2 objects\n+      sage: z = R.random_element()\n+      sage: prec\n+      Precision Lattice on 3 objects\n+\n+   The method \"tracked_elements()\" provides the list of all tracked\n+   elements:\n+\n+      sage: prec.tracked_elements()\n+      [3513 + O(5^10), 176 + O(5^5), ...]\n+\n+   Similarly, when a variable is collected by the garbage collector,\n+   the precision lattice is updated. Note however that the update\n+   might be delayed. We can force it with the method \"del_elements()\":\n+\n+      sage: z = 0\n+      sage: prec\n+      Precision Lattice on 3 objects\n+      sage: prec.del_elements()\n+      sage: prec\n+      Precision Lattice on 2 objects\n+\n+   The method \"precision_lattice()\" returns (a matrix defining) the\n+   lattice that models the precision. Here we have:\n+\n+      sage: prec.precision_lattice()\n+      [9765625       0]\n+      [      0    3125]\n+\n+   Observe that 5^10 = 9765625 and 5^5 = 3125. The above matrix then\n+   reflects the precision on x and y.\n+\n+   Now, observe how the precision lattice changes while performing\n+   computations:\n+\n+      sage: x, y = 3*x+2*y, 2*(x-y)\n+      sage: prec.del_elements()\n+      sage: prec.precision_lattice()\n+      [    3125 48825000]\n+      [       0 48828125]\n+\n+   The matrix we get is no longer diagonal, meaning that some digits\n+   of precision are diffused among the two new elements x and y. They\n+   nevertheless show up when we compute for instance x+y:\n+\n+      sage: x\n+      1516 + O(5^5)\n+      sage: y\n+      424 + O(5^5)\n+      sage: x+y\n+      17565 + O(5^11)\n+\n+   It is these diffused digits of precision (which are tracked but do\n+   not appear on the printing) that allow to be always sharp on\n+   precision.\n+\n+   PERFORMANCES:\n+\n+   Each elementary operation requires significant manipulations on the\n+   lattice precision and then is costly. Precisely:\n+\n+   * The creation of a new element has a cost O(n) when n is the\n+     number of tracked elements.\n+\n+   * The destruction of one element has a cost O(m^2) when m is the\n+     distance between the destroyed element and the last one.\n+     Fortunately, it seems that m tends to be small in general (the\n+     dynamics of the list of tracked elements is rather close to that\n+     of a stack).\n+\n+   It is nevertheless still possible to manipulate several hundred\n+   variables (e.g. squares matrices of size 5 or polynomials of degree\n+   20 are accessible).\n+\n+   The class \"PrecisionLattice\" provides several features for\n+   introspection (especially concerning timings). If enables, it\n+   maintains an history of all actions and stores the wall time of\n+   each of them:\n+\n+      sage: R = ZpLP(3)\n+      sage: prec = R.precision()\n+      sage: prec.history_enable()\n+      sage: M = random_matrix(R, 5)\n+      sage: d = M.determinant()\n+      sage: print prec.history()  # somewhat random\n+         ---\n+      0.004212s  oooooooooooooooooooooooooooooooooooo\n+      0.000003s  oooooooooooooooooooooooooooooooooo~~\n+      0.000010s  oooooooooooooooooooooooooooooooooo\n+      0.001560s  ooooooooooooooooooooooooooooooooooooooooo\n+      0.000004s  ooooooooooooooooooooooooooooo~oooo~oooo~o\n+      0.002168s  oooooooooooooooooooooooooooooooooooooo\n+      0.001787s  ooooooooooooooooooooooooooooooooooooooooo\n+      0.000004s  oooooooooooooooooooooooooooooooooooooo~~o\n+      0.000198s  ooooooooooooooooooooooooooooooooooooooo\n+      0.001152s  ooooooooooooooooooooooooooooooooooooooooo\n+      0.000005s  ooooooooooooooooooooooooooooooooo~oooo~~o\n+      0.000853s  oooooooooooooooooooooooooooooooooooooo\n+      0.000610s  ooooooooooooooooooooooooooooooooooooooo\n+      ...\n+      0.003879s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000006s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~\n+      0.000036s  oooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.006737s  oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000005s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~ooooo\n+      0.002637s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.007118s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000008s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~o~~~~oooo\n+      0.003504s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.005371s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000006s  ooooooooooooooooooooooooooooooooooooooooooooooooooooo~~~o~~~ooo\n+      0.001858s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.003584s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000004s  oooooooooooooooooooooooooooooooooooooooooooooooooooooo~~o~~oo\n+      0.000801s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.001916s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000022s  ooooooooooooooooooooooooooooo~~~~~~~~~~~~~~~~~~~~~~oooo~o~o\n+      0.014705s  ooooooooooooooooooooooooooooooooooo\n+      0.001292s  ooooooooooooooooooooooooooooooooooooo\n+      0.000002s  ooooooooooooooooooooooooooooooooooo~o\n+\n+   The symbol o symbolized a tracked element. The symbol ~ means that\n+   the element is marked for deletion.\n+\n+   The global timings are also accessible as follows:\n+\n+      sage: prec.timings()   # somewhat random\n+      {'add': 0.25049376487731934,\n+       'del': 0.11911273002624512,\n+       'mark': 0.0004909038543701172,\n+       'partial reduce': 0.0917658805847168}\n+\n+```\n \n \n Comment: 1\n```\n",
    "created_at": "2017-08-02T00:00:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346607",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,306 @@
+In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).
+
+For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf
+
+The aim of this ticket is to propose a rough implementation of these ideas. 
+
+Below is a small demo (extracted from the doctest).
+
+```
+
+   Below is a small demo of the features by this model of precision:
+
+      sage: R = ZpLP(3, print_mode='terse')
+      sage: x = R(1,10)
+
+   Of course, when we multiply by 3, we gain one digit of absolute
+   precision:
+
+      sage: 3*x
+      3 + O(3^11)
+
+   The lattice precision machinery sees this even if we decompose the
+   computation into several steps:
+
+      sage: y = x+x
+      sage: y
+      2 + O(3^10)
+      sage: x + y
+      3 + O(3^11)
+
+   The same works for the multiplication:
+
+      sage: z = x^2
+      sage: z
+      1 + O(3^10)
+      sage: x*z
+      1 + O(3^11)
+
+   This comes more funny when we are working with elements given at
+   different precisions:
+
+      sage: R = ZpLP(2, print_mode='terse')
+      sage: x = R(1,10)
+      sage: y = R(1,5)
+      sage: z = x+y; z
+      2 + O(2^5)
+      sage: t = x-y; t
+      0 + O(2^5)
+      sage: z+t  # observe that z+t = 2*x
+      2 + O(2^11)
+      sage: z-t  # observe that z-t = 2*y
+      2 + O(2^6)
+
+      sage: x = R(28888,15)
+      sage: y = R(204,10)
+      sage: z = x/y; z
+      242 + O(2^9)
+      sage: z*y  # which is x
+      28888 + O(2^15)
+
+   The SOMOS sequence is the sequence defined by the recurrence:
+
+      ..MATH::
+
+      u_n =  rac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}
+
+   It is known for its numerical instability. On the one hand, one can
+   show that if the initial values are invertible in mathbb{Z}_p and
+   known at precision O(p^N) then all the next terms of the SOMOS
+   sequence will be known at the same precision as well. On the other
+   hand, because of the division, when we unroll the recurrence, we
+   loose a lot of precision. Observe:
+
+      sage: R = Zp(2, 30, print_mode='terse')
+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      4 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      13 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      55 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      21975 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      6639 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      7186 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      569 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      253 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      4149 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      2899 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      3072 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      349 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      619 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      243 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      3 + O(2^2)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      2 + O(2^2)
+
+   If instead, we use the lattice precision, everything goes well:
+
+      sage: R = ZpLP(2, 30, print_mode='terse')
+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      4 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      13 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      55 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      21975 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      23023 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      31762 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      16953 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      16637 + O(2^15)
+
+      sage: for _ in range(100):
+      ....:     a,b,c,d = b,c,d,(b*d+c*c)/a
+      sage: a
+      15519 + O(2^15)
+      sage: b
+      32042 + O(2^15)
+      sage: c
+      17769 + O(2^15)
+      sage: d
+      20949 + O(2^15)
+
+   BEHIND THE SCENE:
+
+   The precision is global. It is encoded by a lattice in a huge
+   vector space whose dimension is the number of elements having this
+   parent.
+
+   Concretely, this precision datum is an instance of the class
+   "sage.rings.padic.lattice_precision.PrecisionLattice". It is
+   attached to the parent and is created at the same time as the
+   parent. (It is actually a bit more subtle because two different
+   parents may share the same instance; this happens for instance for
+   a p-adic ring and its field of fractions.)
+
+   This precision datum is accessible through the method
+   "precision()":
+
+      sage: R = ZpLP(5, print_mode='terse')
+      sage: prec = R.precision()
+      sage: prec
+      Precision Lattice on 0 object
+
+   This instance knows about all elements of the parent, it is
+   automatically updated when a new element (of this parent) is
+   created:
+
+      sage: x = R(3513,10)
+      sage: prec
+      Precision Lattice on 1 object
+      sage: y = R(176,5)
+      sage: prec
+      Precision Lattice on 2 objects
+      sage: z = R.random_element()
+      sage: prec
+      Precision Lattice on 3 objects
+
+   The method "tracked_elements()" provides the list of all tracked
+   elements:
+
+      sage: prec.tracked_elements()
+      [3513 + O(5^10), 176 + O(5^5), ...]
+
+   Similarly, when a variable is collected by the garbage collector,
+   the precision lattice is updated. Note however that the update
+   might be delayed. We can force it with the method "del_elements()":
+
+      sage: z = 0
+      sage: prec
+      Precision Lattice on 3 objects
+      sage: prec.del_elements()
+      sage: prec
+      Precision Lattice on 2 objects
+
+   The method "precision_lattice()" returns (a matrix defining) the
+   lattice that models the precision. Here we have:
+
+      sage: prec.precision_lattice()
+      [9765625       0]
+      [      0    3125]
+
+   Observe that 5^10 = 9765625 and 5^5 = 3125. The above matrix then
+   reflects the precision on x and y.
+
+   Now, observe how the precision lattice changes while performing
+   computations:
+
+      sage: x, y = 3*x+2*y, 2*(x-y)
+      sage: prec.del_elements()
+      sage: prec.precision_lattice()
+      [    3125 48825000]
+      [       0 48828125]
+
+   The matrix we get is no longer diagonal, meaning that some digits
+   of precision are diffused among the two new elements x and y. They
+   nevertheless show up when we compute for instance x+y:
+
+      sage: x
+      1516 + O(5^5)
+      sage: y
+      424 + O(5^5)
+      sage: x+y
+      17565 + O(5^11)
+
+   It is these diffused digits of precision (which are tracked but do
+   not appear on the printing) that allow to be always sharp on
+   precision.
+
+   PERFORMANCES:
+
+   Each elementary operation requires significant manipulations on the
+   lattice precision and then is costly. Precisely:
+
+   * The creation of a new element has a cost O(n) when n is the
+     number of tracked elements.
+
+   * The destruction of one element has a cost O(m^2) when m is the
+     distance between the destroyed element and the last one.
+     Fortunately, it seems that m tends to be small in general (the
+     dynamics of the list of tracked elements is rather close to that
+     of a stack).
+
+   It is nevertheless still possible to manipulate several hundred
+   variables (e.g. squares matrices of size 5 or polynomials of degree
+   20 are accessible).
+
+   The class "PrecisionLattice" provides several features for
+   introspection (especially concerning timings). If enables, it
+   maintains an history of all actions and stores the wall time of
+   each of them:
+
+      sage: R = ZpLP(3)
+      sage: prec = R.precision()
+      sage: prec.history_enable()
+      sage: M = random_matrix(R, 5)
+      sage: d = M.determinant()
+      sage: print prec.history()  # somewhat random
+         ---
+      0.004212s  oooooooooooooooooooooooooooooooooooo
+      0.000003s  oooooooooooooooooooooooooooooooooo~~
+      0.000010s  oooooooooooooooooooooooooooooooooo
+      0.001560s  ooooooooooooooooooooooooooooooooooooooooo
+      0.000004s  ooooooooooooooooooooooooooooo~oooo~oooo~o
+      0.002168s  oooooooooooooooooooooooooooooooooooooo
+      0.001787s  ooooooooooooooooooooooooooooooooooooooooo
+      0.000004s  oooooooooooooooooooooooooooooooooooooo~~o
+      0.000198s  ooooooooooooooooooooooooooooooooooooooo
+      0.001152s  ooooooooooooooooooooooooooooooooooooooooo
+      0.000005s  ooooooooooooooooooooooooooooooooo~oooo~~o
+      0.000853s  oooooooooooooooooooooooooooooooooooooo
+      0.000610s  ooooooooooooooooooooooooooooooooooooooo
+      ...
+      0.003879s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000006s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~
+      0.000036s  oooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.006737s  oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000005s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~ooooo
+      0.002637s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.007118s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000008s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~o~~~~oooo
+      0.003504s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.005371s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000006s  ooooooooooooooooooooooooooooooooooooooooooooooooooooo~~~o~~~ooo
+      0.001858s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.003584s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000004s  oooooooooooooooooooooooooooooooooooooooooooooooooooooo~~o~~oo
+      0.000801s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.001916s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000022s  ooooooooooooooooooooooooooooo~~~~~~~~~~~~~~~~~~~~~~oooo~o~o
+      0.014705s  ooooooooooooooooooooooooooooooooooo
+      0.001292s  ooooooooooooooooooooooooooooooooooooo
+      0.000002s  ooooooooooooooooooooooooooooooooooo~o
+
+   The symbol o symbolized a tracked element. The symbol ~ means that
+   the element is marked for deletion.
+
+   The global timings are also accessible as follows:
+
+      sage: prec.timings()   # somewhat random
+      {'add': 0.25049376487731934,
+       'del': 0.11911273002624512,
+       'mark': 0.0004909038543701172,
+       'partial reduce': 0.0917658805847168}
+
+```
 
 
 Comment: 1
```




---

archive/issue_comments_346608.json:
```json
{
    "body": "<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-02T09:04:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346608",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346609.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-02T09:14:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346609",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346610.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-21T04:49:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346610",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346611.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-22T18:36:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346611",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346612.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-11-30T03:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346612",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346613.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-12-19T19:36:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346613",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346614.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-12-20T17:24:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346614",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346615.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-12-23T06:42:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346615",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346616.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-01-06T10:28:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346616",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346617.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-01-07T17:13:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346617",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346618.json:
```json
{
    "body": "<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-01-17T14:46:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346618",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346619.json:
```json
{
    "body": "<a id='comment:24'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-01-18T16:44:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346619",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:24'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346620.json:
```json
{
    "body": "<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-01-21T08:49:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346620",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346621.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-05T06:43:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346621",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346622.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-05T06:44:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346622",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346623.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-06T16:45:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346623",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346624.json:
```json
{
    "body": "<a id='comment:29'></a>I guess that this ticket is now more or less ready for a first review.",
    "created_at": "2018-02-06T16:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346624",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:29'></a>I guess that this ticket is now more or less ready for a first review.



---

archive/issue_comments_346625.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-02-06T16:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346625",
    "user": "https://github.com/xcaruso"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_346626.json:
```json
{
    "body": "<a id='comment:30'></a>I would be happy to help with reviewing this. Since this is quite a lot of code, would you mind to push the code to github/gitlab where it is much easier to comment on lines of code? I can also push it to a repository there myself if you don't mind.",
    "created_at": "2018-02-07T13:41:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346626",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:30'></a>I would be happy to help with reviewing this. Since this is quite a lot of code, would you mind to push the code to github/gitlab where it is much easier to comment on lines of code? I can also push it to a repository there myself if you don't mind.



---

archive/issue_comments_346627.json:
```json
{
    "body": "<a id='comment:31'></a>Do you document somewhere why this does not follow the usual linkage pattern used elsewhere in the p-adics code?",
    "created_at": "2018-02-07T13:47:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346627",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:31'></a>Do you document somewhere why this does not follow the usual linkage pattern used elsewhere in the p-adics code?



---

archive/issue_comments_346628.json:
```json
{
    "body": "<a id='comment:32'></a>Replying to [comment:31 saraedum]:\n> Do you document somewhere why this does not follow the usual linkage pattern used elsewhere in the p-adics code?\n\n\nI think the main answer is that it just hasn't been switched to the linkage pattern, but it should be.  The pRational will take some work to make this happen.  I'll be busy in the next few weeks working on an ANTS paper, but we can talk about this in Rennes.  In the mean time, I think if you want to push the code to github/gitlab that should be fine.",
    "created_at": "2018-02-07T17:48:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346628",
    "user": "https://github.com/roed314"
}
```

<a id='comment:32'></a>Replying to [comment:31 saraedum]:
> Do you document somewhere why this does not follow the usual linkage pattern used elsewhere in the p-adics code?


I think the main answer is that it just hasn't been switched to the linkage pattern, but it should be.  The pRational will take some work to make this happen.  I'll be busy in the next few weeks working on an ANTS paper, but we can talk about this in Rennes.  In the mean time, I think if you want to push the code to github/gitlab that should be fine.



---

archive/issue_comments_346629.json:
```json
{
    "body": "<a id='comment:34'></a>I pushed Xavier's code to https://gitlab.com/saraedum/sage/merge_requests/1/diffs for easier review.\n\n---\nNew commits:",
    "created_at": "2018-02-09T19:34:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346629",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:34'></a>I pushed Xavier's code to https://gitlab.com/saraedum/sage/merge_requests/1/diffs for easier review.

---
New commits:



---

archive/issue_comments_346630.json:
```json
{
    "body": "<a id='comment:35'></a>see patchbot report for several issues (including important python3 compatibility)",
    "created_at": "2018-02-12T12:55:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346630",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:35'></a>see patchbot report for several issues (including important python3 compatibility)



---

archive/issue_comments_346631.json:
```json
{
    "body": "<a id='comment:36'></a>I'm getting a maximum recursion depth exceeded:\n\n```\nsage: Q2 = QpLC(2,print_mode='digits')\nsage: R.<x,y,z> = PolynomialRing(Q2, order = 'invlex')\nsage: F = [ Q2(2,10)*x + Q2(1,10)*z,\n....:      Q2(1,10)*x^2 + Q2(1,10)*y^2 - Q2(2,10)*z^2,\n....:      Q2(4,10)*y^2 + Q2(1,10)*y*z + Q2(8,10)*z^2 ]\nsage: from sage.rings.polynomial.toy_buchberger import buchberger_improved\nsage: g = buchberger_improved(ideal(F));\nsage: g.sort()\nsage: L.number_of_diffused_digits([g[1].coefficient(x^2),\n....:                              g[2].coefficient(x^2),g[3].coefficient(x)])\n/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in number_of_diffused_digits(self, elements)\n    563             17\n    564         \"\"\"\n--> 565         M = self.precision_lattice(elements)\n    566         n = M.nrows()\n    567         if M.ncols() > n:\n/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in precision_lattice(self, elements)\n   1551             elements = self._elements\n   1552         else:\n-> 1553             elements = list_of_padics(elements)\n   1554         n = len(self._elements)\n   1555         rows = [ ]; val = 0\n/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in list_of_padics(elements)\n    234     ans = [ ]\n    235     for x in elements:\n--> 236         ans += list_of_padics(x)\n    237     return ans\n    238 \n```",
    "created_at": "2018-02-20T05:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346631",
    "user": "https://github.com/roed314"
}
```

<a id='comment:36'></a>I'm getting a maximum recursion depth exceeded:

```
sage: Q2 = QpLC(2,print_mode='digits')
sage: R.<x,y,z> = PolynomialRing(Q2, order = 'invlex')
sage: F = [ Q2(2,10)*x + Q2(1,10)*z,
....:      Q2(1,10)*x^2 + Q2(1,10)*y^2 - Q2(2,10)*z^2,
....:      Q2(4,10)*y^2 + Q2(1,10)*y*z + Q2(8,10)*z^2 ]
sage: from sage.rings.polynomial.toy_buchberger import buchberger_improved
sage: g = buchberger_improved(ideal(F));
sage: g.sort()
sage: L.number_of_diffused_digits([g[1].coefficient(x^2),
....:                              g[2].coefficient(x^2),g[3].coefficient(x)])
/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in number_of_diffused_digits(self, elements)
    563             17
    564         """
--> 565         M = self.precision_lattice(elements)
    566         n = M.nrows()
    567         if M.ncols() > n:
/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in precision_lattice(self, elements)
   1551             elements = self._elements
   1552         else:
-> 1553             elements = list_of_padics(elements)
   1554         n = len(self._elements)
   1555         rows = [ ]; val = 0
/home/user/sage-8.1/local/lib/python2.7/site-packages/sage/rings/padics/lattice_precision.pyc in list_of_padics(elements)
    234     ans = [ ]
    235     for x in elements:
--> 236         ans += list_of_padics(x)
    237     return ans
    238 
```



---

archive/issue_comments_346632.json:
```json
{
    "body": "<a id='comment:38'></a>Replying to [comment:36 roed]:\n> I'm getting a maximum recursion depth exceeded:\n\n\nThe reason is that (1) `coefficient` returns a multivariate polynomial and (2) if P is a multivariate polynomial, `list(P)` contains some multivariate polynomials in it as well.\n\nThe last commit fixes the bug. But I'm not sure that it's the correct way to do this.\n\n```\nsage: Q2 = QpLC(2,print_mode='digits')\nsage: L = Q2.precision()\nsage: R.<x,y,z> = PolynomialRing(Q2, order = 'invlex')\nsage: F = [ Q2(2,10)*x + Q2(1,10)*z,\n....:       Q2(1,10)*x^2 + Q2(1,10)*y^2 - Q2(2,10)*z^2,\n....:       Q2(4,10)*y^2 + Q2(1,10)*y*z + Q2(8,10)*z^2 ]\nsage: from sage.rings.polynomial.toy_buchberger import buchberger_improved\nsage: g = buchberger_improved(ideal(F));\nsage: g.sort()\nsage: L.number_of_diffused_digits([g[1].coefficient(x^2),\n                                   g[2].coefficient(x^2),\n                                   g[3].coefficient(x)])\n0\n```",
    "created_at": "2018-02-21T19:57:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346632",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:38'></a>Replying to [comment:36 roed]:
> I'm getting a maximum recursion depth exceeded:


The reason is that (1) `coefficient` returns a multivariate polynomial and (2) if P is a multivariate polynomial, `list(P)` contains some multivariate polynomials in it as well.

The last commit fixes the bug. But I'm not sure that it's the correct way to do this.

```
sage: Q2 = QpLC(2,print_mode='digits')
sage: L = Q2.precision()
sage: R.<x,y,z> = PolynomialRing(Q2, order = 'invlex')
sage: F = [ Q2(2,10)*x + Q2(1,10)*z,
....:       Q2(1,10)*x^2 + Q2(1,10)*y^2 - Q2(2,10)*z^2,
....:       Q2(4,10)*y^2 + Q2(1,10)*y*z + Q2(8,10)*z^2 ]
sage: from sage.rings.polynomial.toy_buchberger import buchberger_improved
sage: g = buchberger_improved(ideal(F));
sage: g.sort()
sage: L.number_of_diffused_digits([g[1].coefficient(x^2),
                                   g[2].coefficient(x^2),
                                   g[3].coefficient(x)])
0
```



---

archive/issue_comments_346633.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-02-23T20:22:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346633",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_346634.json:
```json
{
    "body": "<a id='comment:40'></a>You need to fix all the patchbot's warnings, including the incompatibilities with python3.",
    "created_at": "2018-02-23T20:22:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346634",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:40'></a>You need to fix all the patchbot's warnings, including the incompatibilities with python3.



---

archive/issue_comments_346635.json:
```json
{
    "body": "<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-26T03:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346635",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_346636.json:
```json
{
    "body": "<a id='comment:42'></a>`@`caruso: I merged your commits into the repository on gitlab. (I had sent you the instructions on how to push to gitlab several times on zulip but apparently zulip has silently not been working for quite a while\u2026so, to push your changes there in the future: `git fetch git`@`gitlab.com:saraedum/sage.git t/23505/lattice_precision && git merge FETCH_HEAD && git push git`@`gitlab.com:saraedum/sage.git HEAD:t/23505/lattice_precision`. There are also more convenient commands for this, I can show you later.)",
    "created_at": "2018-02-26T07:59:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346636",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:42'></a>`@`caruso: I merged your commits into the repository on gitlab. (I had sent you the instructions on how to push to gitlab several times on zulip but apparently zulip has silently not been working for quite a while…so, to push your changes there in the future: `git fetch git`@`gitlab.com:saraedum/sage.git t/23505/lattice_precision && git merge FETCH_HEAD && git push git`@`gitlab.com:saraedum/sage.git HEAD:t/23505/lattice_precision`. There are also more convenient commands for this, I can show you later.)



---

archive/issue_comments_346637.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,308 @@\n+In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).\n+\n+For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf\n+\n+The aim of this ticket is to propose a rough implementation of these ideas. \n+\n+You can play with the latest version of this by clicking on launch binder [here](https://github.com/saraedum/sage-binder-env/tree/t-23505-lattice-precision).\n+\n+Below is a small demo (extracted from the doctest).\n+\n+```\n+\n+   Below is a small demo of the features by this model of precision:\n+\n+      sage: R = ZpLP(3, print_mode='terse')\n+      sage: x = R(1,10)\n+\n+   Of course, when we multiply by 3, we gain one digit of absolute\n+   precision:\n+\n+      sage: 3*x\n+      3 + O(3^11)\n+\n+   The lattice precision machinery sees this even if we decompose the\n+   computation into several steps:\n+\n+      sage: y = x+x\n+      sage: y\n+      2 + O(3^10)\n+      sage: x + y\n+      3 + O(3^11)\n+\n+   The same works for the multiplication:\n+\n+      sage: z = x^2\n+      sage: z\n+      1 + O(3^10)\n+      sage: x*z\n+      1 + O(3^11)\n+\n+   This comes more funny when we are working with elements given at\n+   different precisions:\n+\n+      sage: R = ZpLP(2, print_mode='terse')\n+      sage: x = R(1,10)\n+      sage: y = R(1,5)\n+      sage: z = x+y; z\n+      2 + O(2^5)\n+      sage: t = x-y; t\n+      0 + O(2^5)\n+      sage: z+t  # observe that z+t = 2*x\n+      2 + O(2^11)\n+      sage: z-t  # observe that z-t = 2*y\n+      2 + O(2^6)\n+\n+      sage: x = R(28888,15)\n+      sage: y = R(204,10)\n+      sage: z = x/y; z\n+      242 + O(2^9)\n+      sage: z*y  # which is x\n+      28888 + O(2^15)\n+\n+   The SOMOS sequence is the sequence defined by the recurrence:\n+\n+      ..MATH::\n+\n+      u_n =  rac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}\n+\n+   It is known for its numerical instability. On the one hand, one can\n+   show that if the initial values are invertible in mathbb{Z}_p and\n+   known at precision O(p^N) then all the next terms of the SOMOS\n+   sequence will be known at the same precision as well. On the other\n+   hand, because of the division, when we unroll the recurrence, we\n+   loose a lot of precision. Observe:\n+\n+      sage: R = Zp(2, 30, print_mode='terse')\n+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      4 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      13 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      55 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      21975 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      6639 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      7186 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      569 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      253 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      4149 + O(2^13)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      2899 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      3072 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      349 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      619 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      243 + O(2^12)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      3 + O(2^2)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      2 + O(2^2)\n+\n+   If instead, we use the lattice precision, everything goes well:\n+\n+      sage: R = ZpLP(2, 30, print_mode='terse')\n+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      4 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      13 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      55 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      21975 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      23023 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      31762 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      16953 + O(2^15)\n+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d\n+      16637 + O(2^15)\n+\n+      sage: for _ in range(100):\n+      ....:     a,b,c,d = b,c,d,(b*d+c*c)/a\n+      sage: a\n+      15519 + O(2^15)\n+      sage: b\n+      32042 + O(2^15)\n+      sage: c\n+      17769 + O(2^15)\n+      sage: d\n+      20949 + O(2^15)\n+\n+   BEHIND THE SCENE:\n+\n+   The precision is global. It is encoded by a lattice in a huge\n+   vector space whose dimension is the number of elements having this\n+   parent.\n+\n+   Concretely, this precision datum is an instance of the class\n+   \"sage.rings.padic.lattice_precision.PrecisionLattice\". It is\n+   attached to the parent and is created at the same time as the\n+   parent. (It is actually a bit more subtle because two different\n+   parents may share the same instance; this happens for instance for\n+   a p-adic ring and its field of fractions.)\n+\n+   This precision datum is accessible through the method\n+   \"precision()\":\n+\n+      sage: R = ZpLP(5, print_mode='terse')\n+      sage: prec = R.precision()\n+      sage: prec\n+      Precision Lattice on 0 object\n+\n+   This instance knows about all elements of the parent, it is\n+   automatically updated when a new element (of this parent) is\n+   created:\n+\n+      sage: x = R(3513,10)\n+      sage: prec\n+      Precision Lattice on 1 object\n+      sage: y = R(176,5)\n+      sage: prec\n+      Precision Lattice on 2 objects\n+      sage: z = R.random_element()\n+      sage: prec\n+      Precision Lattice on 3 objects\n+\n+   The method \"tracked_elements()\" provides the list of all tracked\n+   elements:\n+\n+      sage: prec.tracked_elements()\n+      [3513 + O(5^10), 176 + O(5^5), ...]\n+\n+   Similarly, when a variable is collected by the garbage collector,\n+   the precision lattice is updated. Note however that the update\n+   might be delayed. We can force it with the method \"del_elements()\":\n+\n+      sage: z = 0\n+      sage: prec\n+      Precision Lattice on 3 objects\n+      sage: prec.del_elements()\n+      sage: prec\n+      Precision Lattice on 2 objects\n+\n+   The method \"precision_lattice()\" returns (a matrix defining) the\n+   lattice that models the precision. Here we have:\n+\n+      sage: prec.precision_lattice()\n+      [9765625       0]\n+      [      0    3125]\n+\n+   Observe that 5^10 = 9765625 and 5^5 = 3125. The above matrix then\n+   reflects the precision on x and y.\n+\n+   Now, observe how the precision lattice changes while performing\n+   computations:\n+\n+      sage: x, y = 3*x+2*y, 2*(x-y)\n+      sage: prec.del_elements()\n+      sage: prec.precision_lattice()\n+      [    3125 48825000]\n+      [       0 48828125]\n+\n+   The matrix we get is no longer diagonal, meaning that some digits\n+   of precision are diffused among the two new elements x and y. They\n+   nevertheless show up when we compute for instance x+y:\n+\n+      sage: x\n+      1516 + O(5^5)\n+      sage: y\n+      424 + O(5^5)\n+      sage: x+y\n+      17565 + O(5^11)\n+\n+   It is these diffused digits of precision (which are tracked but do\n+   not appear on the printing) that allow to be always sharp on\n+   precision.\n+\n+   PERFORMANCES:\n+\n+   Each elementary operation requires significant manipulations on the\n+   lattice precision and then is costly. Precisely:\n+\n+   * The creation of a new element has a cost O(n) when n is the\n+     number of tracked elements.\n+\n+   * The destruction of one element has a cost O(m^2) when m is the\n+     distance between the destroyed element and the last one.\n+     Fortunately, it seems that m tends to be small in general (the\n+     dynamics of the list of tracked elements is rather close to that\n+     of a stack).\n+\n+   It is nevertheless still possible to manipulate several hundred\n+   variables (e.g. squares matrices of size 5 or polynomials of degree\n+   20 are accessible).\n+\n+   The class \"PrecisionLattice\" provides several features for\n+   introspection (especially concerning timings). If enables, it\n+   maintains an history of all actions and stores the wall time of\n+   each of them:\n+\n+      sage: R = ZpLP(3)\n+      sage: prec = R.precision()\n+      sage: prec.history_enable()\n+      sage: M = random_matrix(R, 5)\n+      sage: d = M.determinant()\n+      sage: print prec.history()  # somewhat random\n+         ---\n+      0.004212s  oooooooooooooooooooooooooooooooooooo\n+      0.000003s  oooooooooooooooooooooooooooooooooo~~\n+      0.000010s  oooooooooooooooooooooooooooooooooo\n+      0.001560s  ooooooooooooooooooooooooooooooooooooooooo\n+      0.000004s  ooooooooooooooooooooooooooooo~oooo~oooo~o\n+      0.002168s  oooooooooooooooooooooooooooooooooooooo\n+      0.001787s  ooooooooooooooooooooooooooooooooooooooooo\n+      0.000004s  oooooooooooooooooooooooooooooooooooooo~~o\n+      0.000198s  ooooooooooooooooooooooooooooooooooooooo\n+      0.001152s  ooooooooooooooooooooooooooooooooooooooooo\n+      0.000005s  ooooooooooooooooooooooooooooooooo~oooo~~o\n+      0.000853s  oooooooooooooooooooooooooooooooooooooo\n+      0.000610s  ooooooooooooooooooooooooooooooooooooooo\n+      ...\n+      0.003879s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000006s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~\n+      0.000036s  oooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.006737s  oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000005s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~ooooo\n+      0.002637s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.007118s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000008s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~o~~~~oooo\n+      0.003504s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.005371s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000006s  ooooooooooooooooooooooooooooooooooooooooooooooooooooo~~~o~~~ooo\n+      0.001858s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.003584s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000004s  oooooooooooooooooooooooooooooooooooooooooooooooooooooo~~o~~oo\n+      0.000801s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.001916s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n+      0.000022s  ooooooooooooooooooooooooooooo~~~~~~~~~~~~~~~~~~~~~~oooo~o~o\n+      0.014705s  ooooooooooooooooooooooooooooooooooo\n+      0.001292s  ooooooooooooooooooooooooooooooooooooo\n+      0.000002s  ooooooooooooooooooooooooooooooooooo~o\n+\n+   The symbol o symbolized a tracked element. The symbol ~ means that\n+   the element is marked for deletion.\n+\n+   The global timings are also accessible as follows:\n+\n+      sage: prec.timings()   # somewhat random\n+      {'add': 0.25049376487731934,\n+       'del': 0.11911273002624512,\n+       'mark': 0.0004909038543701172,\n+       'partial reduce': 0.0917658805847168}\n+\n+```\n \n \n Comment: 1\n```\n",
    "created_at": "2018-02-26T15:05:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346637",
    "user": "https://github.com/saraedum"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,308 @@
+In several recent papers, David Roe, Tristan Vaccon and I explain that lattices allow a sharp track of precision: if f is a function we want to evaluate and x is an input given with some uncertainty modeled by a lattice H, then the uncertainty on the output f(x) is exactly df_x(H).
+
+For much more details, I refer to my lecture notes http://xavier.toonywood.org/papers/publis/course-padic.pdf
+
+The aim of this ticket is to propose a rough implementation of these ideas. 
+
+You can play with the latest version of this by clicking on launch binder [here](https://github.com/saraedum/sage-binder-env/tree/t-23505-lattice-precision).
+
+Below is a small demo (extracted from the doctest).
+
+```
+
+   Below is a small demo of the features by this model of precision:
+
+      sage: R = ZpLP(3, print_mode='terse')
+      sage: x = R(1,10)
+
+   Of course, when we multiply by 3, we gain one digit of absolute
+   precision:
+
+      sage: 3*x
+      3 + O(3^11)
+
+   The lattice precision machinery sees this even if we decompose the
+   computation into several steps:
+
+      sage: y = x+x
+      sage: y
+      2 + O(3^10)
+      sage: x + y
+      3 + O(3^11)
+
+   The same works for the multiplication:
+
+      sage: z = x^2
+      sage: z
+      1 + O(3^10)
+      sage: x*z
+      1 + O(3^11)
+
+   This comes more funny when we are working with elements given at
+   different precisions:
+
+      sage: R = ZpLP(2, print_mode='terse')
+      sage: x = R(1,10)
+      sage: y = R(1,5)
+      sage: z = x+y; z
+      2 + O(2^5)
+      sage: t = x-y; t
+      0 + O(2^5)
+      sage: z+t  # observe that z+t = 2*x
+      2 + O(2^11)
+      sage: z-t  # observe that z-t = 2*y
+      2 + O(2^6)
+
+      sage: x = R(28888,15)
+      sage: y = R(204,10)
+      sage: z = x/y; z
+      242 + O(2^9)
+      sage: z*y  # which is x
+      28888 + O(2^15)
+
+   The SOMOS sequence is the sequence defined by the recurrence:
+
+      ..MATH::
+
+      u_n =  rac {u_{n-1} u_{n-3} + u_{n-2}^2} {u_{n-4}}
+
+   It is known for its numerical instability. On the one hand, one can
+   show that if the initial values are invertible in mathbb{Z}_p and
+   known at precision O(p^N) then all the next terms of the SOMOS
+   sequence will be known at the same precision as well. On the other
+   hand, because of the division, when we unroll the recurrence, we
+   loose a lot of precision. Observe:
+
+      sage: R = Zp(2, 30, print_mode='terse')
+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      4 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      13 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      55 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      21975 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      6639 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      7186 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      569 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      253 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      4149 + O(2^13)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      2899 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      3072 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      349 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      619 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      243 + O(2^12)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      3 + O(2^2)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      2 + O(2^2)
+
+   If instead, we use the lattice precision, everything goes well:
+
+      sage: R = ZpLP(2, 30, print_mode='terse')
+      sage: a,b,c,d = R(1,15), R(1,15), R(1,15), R(3,15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      4 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      13 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      55 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      21975 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      23023 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      31762 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      16953 + O(2^15)
+      sage: a,b,c,d = b,c,d,(b*d+c*c)/a; print d
+      16637 + O(2^15)
+
+      sage: for _ in range(100):
+      ....:     a,b,c,d = b,c,d,(b*d+c*c)/a
+      sage: a
+      15519 + O(2^15)
+      sage: b
+      32042 + O(2^15)
+      sage: c
+      17769 + O(2^15)
+      sage: d
+      20949 + O(2^15)
+
+   BEHIND THE SCENE:
+
+   The precision is global. It is encoded by a lattice in a huge
+   vector space whose dimension is the number of elements having this
+   parent.
+
+   Concretely, this precision datum is an instance of the class
+   "sage.rings.padic.lattice_precision.PrecisionLattice". It is
+   attached to the parent and is created at the same time as the
+   parent. (It is actually a bit more subtle because two different
+   parents may share the same instance; this happens for instance for
+   a p-adic ring and its field of fractions.)
+
+   This precision datum is accessible through the method
+   "precision()":
+
+      sage: R = ZpLP(5, print_mode='terse')
+      sage: prec = R.precision()
+      sage: prec
+      Precision Lattice on 0 object
+
+   This instance knows about all elements of the parent, it is
+   automatically updated when a new element (of this parent) is
+   created:
+
+      sage: x = R(3513,10)
+      sage: prec
+      Precision Lattice on 1 object
+      sage: y = R(176,5)
+      sage: prec
+      Precision Lattice on 2 objects
+      sage: z = R.random_element()
+      sage: prec
+      Precision Lattice on 3 objects
+
+   The method "tracked_elements()" provides the list of all tracked
+   elements:
+
+      sage: prec.tracked_elements()
+      [3513 + O(5^10), 176 + O(5^5), ...]
+
+   Similarly, when a variable is collected by the garbage collector,
+   the precision lattice is updated. Note however that the update
+   might be delayed. We can force it with the method "del_elements()":
+
+      sage: z = 0
+      sage: prec
+      Precision Lattice on 3 objects
+      sage: prec.del_elements()
+      sage: prec
+      Precision Lattice on 2 objects
+
+   The method "precision_lattice()" returns (a matrix defining) the
+   lattice that models the precision. Here we have:
+
+      sage: prec.precision_lattice()
+      [9765625       0]
+      [      0    3125]
+
+   Observe that 5^10 = 9765625 and 5^5 = 3125. The above matrix then
+   reflects the precision on x and y.
+
+   Now, observe how the precision lattice changes while performing
+   computations:
+
+      sage: x, y = 3*x+2*y, 2*(x-y)
+      sage: prec.del_elements()
+      sage: prec.precision_lattice()
+      [    3125 48825000]
+      [       0 48828125]
+
+   The matrix we get is no longer diagonal, meaning that some digits
+   of precision are diffused among the two new elements x and y. They
+   nevertheless show up when we compute for instance x+y:
+
+      sage: x
+      1516 + O(5^5)
+      sage: y
+      424 + O(5^5)
+      sage: x+y
+      17565 + O(5^11)
+
+   It is these diffused digits of precision (which are tracked but do
+   not appear on the printing) that allow to be always sharp on
+   precision.
+
+   PERFORMANCES:
+
+   Each elementary operation requires significant manipulations on the
+   lattice precision and then is costly. Precisely:
+
+   * The creation of a new element has a cost O(n) when n is the
+     number of tracked elements.
+
+   * The destruction of one element has a cost O(m^2) when m is the
+     distance between the destroyed element and the last one.
+     Fortunately, it seems that m tends to be small in general (the
+     dynamics of the list of tracked elements is rather close to that
+     of a stack).
+
+   It is nevertheless still possible to manipulate several hundred
+   variables (e.g. squares matrices of size 5 or polynomials of degree
+   20 are accessible).
+
+   The class "PrecisionLattice" provides several features for
+   introspection (especially concerning timings). If enables, it
+   maintains an history of all actions and stores the wall time of
+   each of them:
+
+      sage: R = ZpLP(3)
+      sage: prec = R.precision()
+      sage: prec.history_enable()
+      sage: M = random_matrix(R, 5)
+      sage: d = M.determinant()
+      sage: print prec.history()  # somewhat random
+         ---
+      0.004212s  oooooooooooooooooooooooooooooooooooo
+      0.000003s  oooooooooooooooooooooooooooooooooo~~
+      0.000010s  oooooooooooooooooooooooooooooooooo
+      0.001560s  ooooooooooooooooooooooooooooooooooooooooo
+      0.000004s  ooooooooooooooooooooooooooooo~oooo~oooo~o
+      0.002168s  oooooooooooooooooooooooooooooooooooooo
+      0.001787s  ooooooooooooooooooooooooooooooooooooooooo
+      0.000004s  oooooooooooooooooooooooooooooooooooooo~~o
+      0.000198s  ooooooooooooooooooooooooooooooooooooooo
+      0.001152s  ooooooooooooooooooooooooooooooooooooooooo
+      0.000005s  ooooooooooooooooooooooooooooooooo~oooo~~o
+      0.000853s  oooooooooooooooooooooooooooooooooooooo
+      0.000610s  ooooooooooooooooooooooooooooooooooooooo
+      ...
+      0.003879s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000006s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~
+      0.000036s  oooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.006737s  oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000005s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~~ooooo
+      0.002637s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.007118s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000008s  oooooooooooooooooooooooooooooooooooooooooooooooooooo~~~~o~~~~oooo
+      0.003504s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.005371s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000006s  ooooooooooooooooooooooooooooooooooooooooooooooooooooo~~~o~~~ooo
+      0.001858s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.003584s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000004s  oooooooooooooooooooooooooooooooooooooooooooooooooooooo~~o~~oo
+      0.000801s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.001916s  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+      0.000022s  ooooooooooooooooooooooooooooo~~~~~~~~~~~~~~~~~~~~~~oooo~o~o
+      0.014705s  ooooooooooooooooooooooooooooooooooo
+      0.001292s  ooooooooooooooooooooooooooooooooooooo
+      0.000002s  ooooooooooooooooooooooooooooooooooo~o
+
+   The symbol o symbolized a tracked element. The symbol ~ means that
+   the element is marked for deletion.
+
+   The global timings are also accessible as follows:
+
+      sage: prec.timings()   # somewhat random
+      {'add': 0.25049376487731934,
+       'del': 0.11911273002624512,
+       'mark': 0.0004909038543701172,
+       'partial reduce': 0.0917658805847168}
+
+```
 
 
 Comment: 1
```




---

archive/issue_comments_346638.json:
```json
{
    "body": "<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2018-02-27T00:15:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346638",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_346639.json:
```json
{
    "body": "<a id='comment:46'></a>IMHO, not a good idea at all to merge the \"binder\" branch with this ticket. The patchbots will not longer look at it, because it is now unsafe.",
    "created_at": "2018-02-27T09:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346639",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:46'></a>IMHO, not a good idea at all to merge the "binder" branch with this ticket. The patchbots will not longer look at it, because it is now unsafe.



---

archive/issue_comments_346640.json:
```json
{
    "body": "<a id='comment:47'></a>I agree, I merged them accidentally.\nI will remove them later. For now, the ticket is not quite ready for review; I just wanted to check whether the patchbot is happy with my changes.",
    "created_at": "2018-02-27T09:33:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346640",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:47'></a>I agree, I merged them accidentally.
I will remove them later. For now, the ticket is not quite ready for review; I just wanted to check whether the patchbot is happy with my changes.



---

archive/issue_comments_346641.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-02-27T10:13:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346641",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_346642.json:
```json
{
    "body": "<a id='comment:49'></a>As I said, as long as the branch is messed up, patchbots will refuse to run..",
    "created_at": "2018-02-27T10:17:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346642",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:49'></a>As I said, as long as the branch is messed up, patchbots will refuse to run..



---

archive/issue_comments_346643.json:
```json
{
    "body": "<a id='comment:50'></a>`@`chapoton: Thanks for clarifying how the patchbots work here. We'll take the binder out at the end and squash the other commits. We use the CI integration because we are developing this on [GitLab](GitLab) and also because we wanted to see a sandbox environment to play with this.\n\n`@`caruso: I'll run doctests on [GitLab](GitLab), they should be available in a couple of hours.",
    "created_at": "2018-02-27T10:31:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346643",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:50'></a>`@`chapoton: Thanks for clarifying how the patchbots work here. We'll take the binder out at the end and squash the other commits. We use the CI integration because we are developing this on [GitLab](GitLab) and also because we wanted to see a sandbox environment to play with this.

`@`caruso: I'll run doctests on [GitLab](GitLab), they should be available in a couple of hours.



---

archive/issue_comments_346644.json:
```json
{
    "body": "<a id='comment:51'></a>Ok. Thanks to both of you!",
    "created_at": "2018-02-27T10:46:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346644",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:51'></a>Ok. Thanks to both of you!



---

archive/issue_comments_346645.json:
```json
{
    "body": "<a id='comment:54'></a>New commits:",
    "created_at": "2018-03-06T00:18:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346645",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:54'></a>New commits:



---

archive/issue_comments_346646.json:
```json
{
    "body": "<a id='comment:56'></a>This has a positive review, once https://gitlab.com/saraedum/sage/-/jobs/55854321 has completed without errors.",
    "created_at": "2018-03-06T00:40:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346646",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:56'></a>This has a positive review, once https://gitlab.com/saraedum/sage/-/jobs/55854321 has completed without errors.



---

archive/issue_comments_346647.json:
```json
{
    "body": "<a id='comment:57'></a>Replying to [comment:56 saraedum]:\n> This has a positive review, once https://gitlab.com/saraedum/sage/-/jobs/55854321 has completed without errors.\n\n\nJob's log exceeded limit of 4194304 bytes.",
    "created_at": "2018-03-06T00:44:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346647",
    "user": "https://github.com/roed314"
}
```

<a id='comment:57'></a>Replying to [comment:56 saraedum]:
> This has a positive review, once https://gitlab.com/saraedum/sage/-/jobs/55854321 has completed without errors.


Job's log exceeded limit of 4194304 bytes.



---

archive/issue_comments_346648.json:
```json
{
    "body": "<a id='comment:58'></a>\n```\nsage -t --long src/sage/interacts/test_jupyter.rst\n**********************************************************************\nFile \"src/sage/interacts/test_jupyter.rst\", line 288, in sage.interacts.test_jupyter\nFailed example:\n    test(interacts.statistics.coin)\nExpected:\n    Interactive function <function coin at ...> with 2 widgets\n      n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)\n      interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)\n    doctest:...: UserWarning: Attempting to set identical bottom==top results\n    in singular transformations; automatically expanding.\n    bottom=0.0, top=0.0\nGot:\n    doctest:... UserWarning: Attempting to set identical bottom==top results\n    in singular transformations; automatically expanding.\n    bottom=0.0, top=0.0\n    Interactive function <function coin at 0x7fb48b00d7d0> with 2 widgets\n      n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)\n      interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)\n```\n\nShould we fix this?",
    "created_at": "2018-03-06T07:13:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346648",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:58'></a>
```
sage -t --long src/sage/interacts/test_jupyter.rst
**********************************************************************
File "src/sage/interacts/test_jupyter.rst", line 288, in sage.interacts.test_jupyter
Failed example:
    test(interacts.statistics.coin)
Expected:
    Interactive function <function coin at ...> with 2 widgets
      n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
      interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
    doctest:...: UserWarning: Attempting to set identical bottom==top results
    in singular transformations; automatically expanding.
    bottom=0.0, top=0.0
Got:
    doctest:... UserWarning: Attempting to set identical bottom==top results
    in singular transformations; automatically expanding.
    bottom=0.0, top=0.0
    Interactive function <function coin at 0x7fb48b00d7d0> with 2 widgets
      n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
      interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
```

Should we fix this?



---

archive/issue_comments_346649.json:
```json
{
    "body": "<a id='comment:59'></a>patchbot here is still not 100% happy",
    "created_at": "2018-03-06T07:22:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346649",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:59'></a>patchbot here is still not 100% happy



---

archive/issue_comments_346650.json:
```json
{
    "body": "<a id='comment:61'></a>I fixed some failures but I think that this ticket is not responsible for the doctest failure in `interacts/test_jupyter.rst`. What should I do with it?\n\n---\nNew commits:",
    "created_at": "2018-03-06T07:29:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346650",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:61'></a>I fixed some failures but I think that this ticket is not responsible for the doctest failure in `interacts/test_jupyter.rst`. What should I do with it?

---
New commits:



---

archive/issue_comments_346651.json:
```json
{
    "body": "<a id='comment:62'></a>I am not sure what this is about. I don't think that's a problem coming from the changes here, so we should not fix it here.\n\nReplying to [comment:58 caruso]:\n> {{{\n> sage -t --long src/sage/interacts/test_jupyter.rst\n> **********************************************************************\n> File \"src/sage/interacts/test_jupyter.rst\", line 288, in sage.interacts.test_jupyter\n> Failed example:\n>     test(interacts.statistics.coin)\n> Expected:\n>     Interactive function <function coin at ...> with 2 widgets\n>       n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)\n>       interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)\n>     doctest:...: UserWarning: Attempting to set identical bottom==top results\n>     in singular transformations; automatically expanding.\n>     bottom=0.0, top=0.0\n> Got:\n> doctest:... UserWarning: Attempting to set identical bottom==top results\n>     in singular transformations; automatically expanding.\n>     bottom=0.0, top=0.0\n>     Interactive function <function coin at 0x7fb48b00d7d0> with 2 widgets\n>       n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)\n>       interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)\n> }}}\n> \n> Should we fix this?",
    "created_at": "2018-03-06T08:53:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346651",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:62'></a>I am not sure what this is about. I don't think that's a problem coming from the changes here, so we should not fix it here.

Replying to [comment:58 caruso]:
> {{{
> sage -t --long src/sage/interacts/test_jupyter.rst
> **********************************************************************
> File "src/sage/interacts/test_jupyter.rst", line 288, in sage.interacts.test_jupyter
> Failed example:
>     test(interacts.statistics.coin)
> Expected:
>     Interactive function <function coin at ...> with 2 widgets
>       n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
>       interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
>     doctest:...: UserWarning: Attempting to set identical bottom==top results
>     in singular transformations; automatically expanding.
>     bottom=0.0, top=0.0
> Got:
> doctest:... UserWarning: Attempting to set identical bottom==top results
>     in singular transformations; automatically expanding.
>     bottom=0.0, top=0.0
>     Interactive function <function coin at 0x7fb48b00d7d0> with 2 widgets
>       n: IntSlider(value=1000, description=u'Number of Tosses', max=10000, min=2, step=100)
>       interval: IntRangeSlider(value=(0, 0), description=u'Plotting range (y)', max=1)
> }}}
> 
> Should we fix this?



---

archive/issue_comments_346652.json:
```json
{
    "body": "<a id='comment:63'></a>So now, only the failure in `interacts/test_jupyter.rst` remains...",
    "created_at": "2018-03-06T10:43:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346652",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:63'></a>So now, only the failure in `interacts/test_jupyter.rst` remains...



---

archive/issue_comments_346653.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-03-06T14:08:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346653",
    "user": "https://github.com/saraedum"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_346654.json:
```json
{
    "body": "<a id='comment:64'></a>The PDF reference manual builds. The German \"A Tour of Sage\" fails to build but I can't imagine that this ticket is responsible for this:\n\n```\n[a_tour_of] loading translations [de]... done\n[a_tour_of] Compiling the master document\n[a_tour_of] building [mo]: targets for 0 po files that are out of date\n[a_tour_of] building [latex]: all documents\n[a_tour_of] Merging environment/index files...\n[a_tour_of] ... done (0 todos, 1 index, 0 citations, 0 modules)\n[a_tour_of] Saved pickle file: citations.pickle\n[a_tour_of] processing a_tour_of_sage.tex...index\n[a_tour_of] resolving references...\n[a_tour_of] writing... done\n[a_tour_of] copying images... [ 50%] sin_plot.png\n[a_tour_of] copying images... [100%] eigen_plot.png\n[a_tour_of] copying TeX support files...\n[a_tour_of] done\n[a_tour_of] build succeeded.\nlatexmk -pdf -dvi- -ps-  'a_tour_of_sage.tex'\nLatexmk: applying rule 'pdflatex'...\nThis is pdfTeX, Version 3.14159265-2.6-1.40.16 (TeX Live 2015/Debian) (preloaded format=pdflatex)\n restricted \\write18 enabled.\nentering extended mode\n(./a_tour_of_sage.tex\nLaTeX2e <2016/02/01>\nBabel <3.9q> and hyphenation patterns for 3 language(s) loaded.\n(./sphinxmanual.cls\nDocument Class: sphinxmanual 2017/03/26 v1.6 Document class (Sphinx manual)\n(/usr/share/texlive/texmf-dist/tex/latex/base/report.cls\nDocument Class: report 2014/09/29 v1.4h Standard LaTeX document class\n(/usr/share/texlive/texmf-dist/tex/latex/base/size10.clo)))\n(/usr/share/texlive/texmf-dist/tex/latex/base/inputenc.sty\n(/usr/share/texlive/texmf-dist/tex/latex/base/utf8.def\n(/usr/share/texlive/texmf-dist/tex/latex/base/t1enc.dfu)\n(/usr/share/texlive/texmf-dist/tex/latex/base/ot1enc.dfu)\n(/usr/share/texlive/texmf-dist/tex/latex/base/omsenc.dfu)))\n(/usr/share/texlive/texmf-dist/tex/latex/cmap/cmap.sty)\n(/usr/share/texlive/texmf-dist/tex/latex/base/fontenc.sty\n(/usr/share/texlive/texmf-dist/tex/latex/base/t1enc.def)<<t1.cmap>>)\n(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsmath.sty\nFor additional information on amsmath, use the `?' option.\n(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amstext.sty\n(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsgen.sty))\n(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsbsy.sty)\n(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsopn.sty))\n(/usr/share/texlive/texmf-dist/tex/latex/amsfonts/amssymb.sty\n(/usr/share/texlive/texmf-dist/tex/latex/amsfonts/amsfonts.sty))\n(/usr/share/texlive/texmf-dist/tex/generic/babel/babel.sty\n\n! Package babel Error: You haven't specified a language option.\n\nSee the babel package documentation for explanation.\nType  H <return>  for immediate help.\n ...\n\nl.343 ...ry to proceed from here, type x to quit.}\n\n?\n! Emergency stop.\n ...\n\nl.343 ...ry to proceed from here, type x to quit.}\n\n!  ==> Fatal error occurred, no output PDF file produced!\nTranscript written on a_tour_of_sage.log.\nLatexmk: Errors, so I did not complete making targets\nMakefile:33: recipe for target 'a_tour_of_sage.pdf' failed\n```",
    "created_at": "2018-03-06T14:08:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346654",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:64'></a>The PDF reference manual builds. The German "A Tour of Sage" fails to build but I can't imagine that this ticket is responsible for this:

```
[a_tour_of] loading translations [de]... done
[a_tour_of] Compiling the master document
[a_tour_of] building [mo]: targets for 0 po files that are out of date
[a_tour_of] building [latex]: all documents
[a_tour_of] Merging environment/index files...
[a_tour_of] ... done (0 todos, 1 index, 0 citations, 0 modules)
[a_tour_of] Saved pickle file: citations.pickle
[a_tour_of] processing a_tour_of_sage.tex...index
[a_tour_of] resolving references...
[a_tour_of] writing... done
[a_tour_of] copying images... [ 50%] sin_plot.png
[a_tour_of] copying images... [100%] eigen_plot.png
[a_tour_of] copying TeX support files...
[a_tour_of] done
[a_tour_of] build succeeded.
latexmk -pdf -dvi- -ps-  'a_tour_of_sage.tex'
Latexmk: applying rule 'pdflatex'...
This is pdfTeX, Version 3.14159265-2.6-1.40.16 (TeX Live 2015/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(./a_tour_of_sage.tex
LaTeX2e <2016/02/01>
Babel <3.9q> and hyphenation patterns for 3 language(s) loaded.
(./sphinxmanual.cls
Document Class: sphinxmanual 2017/03/26 v1.6 Document class (Sphinx manual)
(/usr/share/texlive/texmf-dist/tex/latex/base/report.cls
Document Class: report 2014/09/29 v1.4h Standard LaTeX document class
(/usr/share/texlive/texmf-dist/tex/latex/base/size10.clo)))
(/usr/share/texlive/texmf-dist/tex/latex/base/inputenc.sty
(/usr/share/texlive/texmf-dist/tex/latex/base/utf8.def
(/usr/share/texlive/texmf-dist/tex/latex/base/t1enc.dfu)
(/usr/share/texlive/texmf-dist/tex/latex/base/ot1enc.dfu)
(/usr/share/texlive/texmf-dist/tex/latex/base/omsenc.dfu)))
(/usr/share/texlive/texmf-dist/tex/latex/cmap/cmap.sty)
(/usr/share/texlive/texmf-dist/tex/latex/base/fontenc.sty
(/usr/share/texlive/texmf-dist/tex/latex/base/t1enc.def)<<t1.cmap>>)
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsmath.sty
For additional information on amsmath, use the `?' option.
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amstext.sty
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsgen.sty))
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsbsy.sty)
(/usr/share/texlive/texmf-dist/tex/latex/amsmath/amsopn.sty))
(/usr/share/texlive/texmf-dist/tex/latex/amsfonts/amssymb.sty
(/usr/share/texlive/texmf-dist/tex/latex/amsfonts/amsfonts.sty))
(/usr/share/texlive/texmf-dist/tex/generic/babel/babel.sty

! Package babel Error: You haven't specified a language option.

See the babel package documentation for explanation.
Type  H <return>  for immediate help.
 ...

l.343 ...ry to proceed from here, type x to quit.}

?
! Emergency stop.
 ...

l.343 ...ry to proceed from here, type x to quit.}

!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on a_tour_of_sage.log.
Latexmk: Errors, so I did not complete making targets
Makefile:33: recipe for target 'a_tour_of_sage.pdf' failed
```



---

archive/issue_events_060283.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-03-08T00:02:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23505#event-60283"
}
```



---

archive/issue_comments_346655.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-03-08T00:02:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346655",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_346656.json:
```json
{
    "body": "<a id='comment:66'></a>There are issues with python3 division in lattice_precision:\n\n```\nsource ./local/bin/sage-env\npython -Qnew ./local/bin/sage-runtests src/sage/rings/padics\n```\nreports many failing doctests.\nThis can be seen also when adding\n\n```\nfrom __future__ import division\n```\nin the file.",
    "created_at": "2018-04-30T09:06:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346656",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:66'></a>There are issues with python3 division in lattice_precision:

```
source ./local/bin/sage-env
python -Qnew ./local/bin/sage-runtests src/sage/rings/padics
```
reports many failing doctests.
This can be seen also when adding

```
from __future__ import division
```
in the file.



---

archive/issue_comments_346657.json:
```json
{
    "body": "<a id='comment:67'></a>and you also introduced some \"has_key\", so please review #25280",
    "created_at": "2018-05-02T09:33:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346657",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:67'></a>and you also introduced some "has_key", so please review #25280



---

archive/issue_comments_346658.json:
```json
{
    "body": "<a id='comment:68'></a>Replying to [comment:66 chapoton]:\n> There are issues with python3 division in lattice_precision:\n> \n> ```\n> source ./local/bin/sage-env\n> python -Qnew ./local/bin/sage-runtests src/sage/rings/padics\n> ```\n> reports many failing doctests.\n> This can be seen also when adding\n> \n> ```\n> from __future__ import division\n> ```\n> in the file.\n\n\nAdding the line:\n\n`__truediv__ = __div__`\n\nin the defintion of the class `pRational` resolves this issue. Is it the right way to fix this or should I do something else?",
    "created_at": "2018-05-02T21:27:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346658",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:68'></a>Replying to [comment:66 chapoton]:
> There are issues with python3 division in lattice_precision:
> 
> ```
> source ./local/bin/sage-env
> python -Qnew ./local/bin/sage-runtests src/sage/rings/padics
> ```
> reports many failing doctests.
> This can be seen also when adding
> 
> ```
> from __future__ import division
> ```
> in the file.


Adding the line:

`__truediv__ = __div__`

in the defintion of the class `pRational` resolves this issue. Is it the right way to fix this or should I do something else?



---

archive/issue_comments_346659.json:
```json
{
    "body": "<a id='comment:69'></a>code from this ticket seems to trigger `TimeOut` errors on several machines running sage 8.3.b0, please investigate !\n\nhttps://patchbot.sagemath.org/log/0/Ubuntu/18.04/x86_64/4.15.0-20-generic/petitbonum/2018-05-11%2012:03:31?short",
    "created_at": "2018-05-12T07:14:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346659",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:69'></a>code from this ticket seems to trigger `TimeOut` errors on several machines running sage 8.3.b0, please investigate !

https://patchbot.sagemath.org/log/0/Ubuntu/18.04/x86_64/4.15.0-20-generic/petitbonum/2018-05-11%2012:03:31?short



---

archive/issue_comments_346660.json:
```json
{
    "body": "<a id='comment:70'></a>Thanks for pointing this out. I created a followup #25431.",
    "created_at": "2018-05-23T11:49:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346660",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:70'></a>Thanks for pointing this out. I created a followup #25431.



---

archive/issue_comments_346661.json:
```json
{
    "body": "<a id='comment:71'></a>The file `padic_lattice_element.py` is now one of the last 3 files (see #26212) having more than 100 failing doctests in python3:\n\n```\nsage -t --long src/sage/rings/padics/padic_lattice_element.py  # 167 doctests failed\n```\nIt would be appreciated if the authors of this code could handle the task of making all this compatible with python3.",
    "created_at": "2018-10-27T16:34:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346661",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:71'></a>The file `padic_lattice_element.py` is now one of the last 3 files (see #26212) having more than 100 failing doctests in python3:

```
sage -t --long src/sage/rings/padics/padic_lattice_element.py  # 167 doctests failed
```
It would be appreciated if the authors of this code could handle the task of making all this compatible with python3.



---

archive/issue_comments_346662.json:
```json
{
    "body": "<a id='comment:72'></a>I'll take a look.  I've opened #26576.",
    "created_at": "2018-10-28T02:07:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346662",
    "user": "https://github.com/roed314"
}
```

<a id='comment:72'></a>I'll take a look.  I've opened #26576.



---

archive/issue_comments_346663.json:
```json
{
    "body": "<a id='comment:73'></a>I'd be happy to contribute as well but I don't know so much about Python3 (which explains why this ticket has so many failures...)\n\nIn particular, what should I do if I want to run doctests with the python3 interpretor. Do I need to install a new copy of sage compiled with python3 or is there something more clever?",
    "created_at": "2018-10-28T03:14:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346663",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:73'></a>I'd be happy to contribute as well but I don't know so much about Python3 (which explains why this ticket has so many failures...)

In particular, what should I do if I want to run doctests with the python3 interpretor. Do I need to install a new copy of sage compiled with python3 or is there something more clever?



---

archive/issue_comments_346664.json:
```json
{
    "body": "<a id='comment:74'></a>There are these doctests errors:\n\n```\nFile \"src/sage/rings/padics/padic_lattice_element.py\", line 31, in sage.rings.padics.padic_lattice_element\nFailed example:\n    R = QpLF(2) # py3\nExpected:\n    doctest:...: FutureWarning: This class/method/function is marked as experimental. It, its functionality or its interface might change without a formal deprecation.\n    See http://trac.sagemath.org/23505 for details.\nGot:\n    <BLANKLINE>\n```\n\nSo it there anything \"experimental\" left almost 2 years since this ticket has been closed?\nCan these tags or whatever be removed?",
    "created_at": "2020-01-14T14:33:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23505",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23505#issuecomment-346664",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:74'></a>There are these doctests errors:

```
File "src/sage/rings/padics/padic_lattice_element.py", line 31, in sage.rings.padics.padic_lattice_element
Failed example:
    R = QpLF(2) # py3
Expected:
    doctest:...: FutureWarning: This class/method/function is marked as experimental. It, its functionality or its interface might change without a formal deprecation.
    See http://trac.sagemath.org/23505 for details.
Got:
    <BLANKLINE>
```

So it there anything "experimental" left almost 2 years since this ticket has been closed?
Can these tags or whatever be removed?
