# Issue 23324: surprising behaviour of Set

archive/issues_023087.json:
```json
{
    "body": "\n```\nsage: Set([[], []]).cardinality()\n2\n```\n\nIn earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.\n\n`cardinality` should raise an error if the elements of the set are unhashable.\n\n**Branch:** [u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set)\n\n**Commit:** [ba613e9de4136b386c156e6c1cb1c8fceebc9ecf](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)\n\n**Author:** Martin Rubey\n\nIssue created by migration from https://trac.sagemath.org/ticket/23324\n\n",
    "created_at": "2017-06-25T19:04:35Z",
    "labels": [
        "component: misc",
        "bug",
        "needs work"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-8.0",
    "title": "surprising behaviour of Set",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/23324",
    "user": "https://github.com/mantepse"
}
```

```
sage: Set([[], []]).cardinality()
2
```

In earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.

`cardinality` should raise an error if the elements of the set are unhashable.

**Branch:** [u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set)

**Commit:** [ba613e9de4136b386c156e6c1cb1c8fceebc9ecf](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)

**Author:** Martin Rubey

Issue created by migration from https://trac.sagemath.org/ticket/23324





---

archive/issue_comments_352548.json:
```json
{
    "body": "<a id='comment:1'></a>\nThe Set should not even be created.",
    "created_at": "2017-06-25T22:36:07Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352548",
    "user": "https://github.com/videlec"
}
```

<a id='comment:1'></a>
The Set should not even be created.



---

archive/issue_comments_352549.json:
```json
{
    "body": "<a id='comment:2'></a>\nThe problem is that we *do* want to support certain infinite sets which cannot be listed, so simply listing all elements is not a solution.",
    "created_at": "2017-06-26T08:55:42Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352549",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
The problem is that we *do* want to support certain infinite sets which cannot be listed, so simply listing all elements is not a solution.



---

archive/issue_comments_352550.json:
```json
{
    "body": "<a id='comment:3'></a>\nI don't understand your point, the problematic code is `sage/sets/set.py` line 206-211\n\n```\n    try:\n        X = frozenset(X)\n    except TypeError:\n        return Set_object(X)\n    else:\n        return Set_object_enumerated(X)\n```\nIt does expand `X` whatever it is. If the input `X` contains some non hashable object, a kind of lazy set is returned (`Set_object`) and not a proper finite set\n\n```\nsage: S = Set([1,1,1,[]])\nsage: S\nSet of elements of [1, 1, 1, []]\nsage: S.cardinality()\n4\n```\nAnd I think it should just raise a `TypeError` as it used to be. Support for non hashable elements should not be dealt with in the main constructor.",
    "created_at": "2017-06-26T09:06:39Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352550",
    "user": "https://github.com/videlec"
}
```

<a id='comment:3'></a>
I don't understand your point, the problematic code is `sage/sets/set.py` line 206-211

```
    try:
        X = frozenset(X)
    except TypeError:
        return Set_object(X)
    else:
        return Set_object_enumerated(X)
```
It does expand `X` whatever it is. If the input `X` contains some non hashable object, a kind of lazy set is returned (`Set_object`) and not a proper finite set

```
sage: S = Set([1,1,1,[]])
sage: S
Set of elements of [1, 1, 1, []]
sage: S.cardinality()
4
```
And I think it should just raise a `TypeError` as it used to be. Support for non hashable elements should not be dealt with in the main constructor.



---

archive/issue_comments_352551.json:
```json
{
    "body": "<a id='comment:4'></a>\nReplying to [vdelecroix](#comment%3A3):\n> it should just raise a `TypeError` as it used to be.\n\nThis \"used to be\" the case only for certain specific types (which included `list`). It really makes no sense to say \"for these specific types, we require that the elements of the set are hashable, but for other types not\". The only sensible options are to have such requirement never (which is the current implementation) or always.",
    "created_at": "2017-06-26T09:13:39Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352551",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
Replying to [vdelecroix](#comment%3A3):
> it should just raise a `TypeError` as it used to be.

This "used to be" the case only for certain specific types (which included `list`). It really makes no sense to say "for these specific types, we require that the elements of the set are hashable, but for other types not". The only sensible options are to have such requirement never (which is the current implementation) or always.



---

archive/issue_comments_352552.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -4,9 +4,6 @@\n 2\n ```\n \n-In earlier versions, a `TypeError: unhashable type: 'list'` was raised.\n+In earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.\n \n-I think the behaviour was modified in #22597.\n-\n-`cardinality` should raise an error if the elements of the set are unhashable or mutable.\n-\n+`cardinality` should raise an error if the elements of the set are unhashable.\n``````\n",
    "created_at": "2017-06-26T09:13:39Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352552",
    "user": "https://github.com/jdemeyer"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -4,9 +4,6 @@
 2
 ```
 
-In earlier versions, a `TypeError: unhashable type: 'list'` was raised.
+In earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.
 
-I think the behaviour was modified in #22597.
-
-`cardinality` should raise an error if the elements of the set are unhashable or mutable.
-
+`cardinality` should raise an error if the elements of the set are unhashable.
``````




---

archive/issue_comments_352553.json:
```json
{
    "body": "<a id='comment:5'></a>\nDoes the following make sense!?\n\n```\nsage: Set([1, 1, 2])\n{1, 2}\nsage: Set([[], 1, 1, 2])\nSet of elements of [[], 1, 1, 2]\n```\nor\n\n```\nsage: Set([1,2]) == Set([2,1])\nTrue\nsage: Set([[],1]) == Set([1,[]])\nFalse\n```\nor\n\n```\nsage: l1 = []\nsage: l2 = []\nsage: S1 = Set([l1])\nsage: S2 = Set([l2])\nsage: S1 == S2\nTrue\nsage: l1.append('hello')\nsage: S1 == S2\nFalse\n```\nThe `Set` function is a globally available factory for constructing mathematical sets. It is useful and possible to have mathematical sets made of Python lists. However, I do think that the `Set` constructor should not be used for that purpose.",
    "created_at": "2017-06-26T09:37:54Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352553",
    "user": "https://github.com/videlec"
}
```

<a id='comment:5'></a>
Does the following make sense!?

```
sage: Set([1, 1, 2])
{1, 2}
sage: Set([[], 1, 1, 2])
Set of elements of [[], 1, 1, 2]
```
or

```
sage: Set([1,2]) == Set([2,1])
True
sage: Set([[],1]) == Set([1,[]])
False
```
or

```
sage: l1 = []
sage: l2 = []
sage: S1 = Set([l1])
sage: S2 = Set([l2])
sage: S1 == S2
True
sage: l1.append('hello')
sage: S1 == S2
False
```
The `Set` function is a globally available factory for constructing mathematical sets. It is useful and possible to have mathematical sets made of Python lists. However, I do think that the `Set` constructor should not be used for that purpose.



---

archive/issue_comments_352554.json:
```json
{
    "body": "<a id='comment:6'></a>\nReplying to [vdelecroix](#comment%3A5):\n> Does the following make sense!?\n\nOf course not. I never said that the current behaviour makes sense. I just wanted to defend #22597 and to point out that it's more complicated than you think, that's all.\n\nThe current behaviour is because of the need to support infinite sets:\n\n```\nsage: Set(RR)\nSet of elements of Real Field with 53 bits of precision\n```\nWe could of course disallow that and simply always call `frozenset(X)`.",
    "created_at": "2017-06-26T09:44:27Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352554",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>
Replying to [vdelecroix](#comment%3A5):
> Does the following make sense!?

Of course not. I never said that the current behaviour makes sense. I just wanted to defend #22597 and to point out that it's more complicated than you think, that's all.

The current behaviour is because of the need to support infinite sets:

```
sage: Set(RR)
Set of elements of Real Field with 53 bits of precision
```
We could of course disallow that and simply always call `frozenset(X)`.



---

archive/issue_comments_352555.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [jdemeyer](#comment%3A6):\n> Replying to [vdelecroix](#comment%3A5):\n> The current behaviour is because of the need to support infinite sets:\n\nIn your example, I don't even understand why `RR` is not itself returned.\n\nA more sensible behavior would be\n- if `X` is a `Parent` whose category is a subcategory of `Set` then returns it (or possibly a wrapper around it)\n- otherwise return a finite mathematical set corresponding to `frozenset(X)`\n\nIt just boils down to replace the code metioned in [comment:3](#comment%3A3) into\n\n```\n    return Set_object_enumerated(frozenset(X))\n```\n(the part for infinite stuff is already done at this stage)",
    "created_at": "2017-06-26T09:50:40Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352555",
    "user": "https://github.com/videlec"
}
```

<a id='comment:7'></a>
Replying to [jdemeyer](#comment%3A6):
> Replying to [vdelecroix](#comment%3A5):
> The current behaviour is because of the need to support infinite sets:

In your example, I don't even understand why `RR` is not itself returned.

A more sensible behavior would be
- if `X` is a `Parent` whose category is a subcategory of `Set` then returns it (or possibly a wrapper around it)
- otherwise return a finite mathematical set corresponding to `frozenset(X)`

It just boils down to replace the code metioned in [comment:3](#comment%3A3) into

```
    return Set_object_enumerated(frozenset(X))
```
(the part for infinite stuff is already done at this stage)



---

archive/issue_comments_352556.json:
```json
{
    "body": "**Branch:** [u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set)",
    "created_at": "2018-06-02T11:12:12Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352556",
    "user": "https://github.com/mantepse"
}
```

**Branch:** [u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set)



---

archive/issue_comments_352557.json:
```json
{
    "body": "**Commit:** [ba613e9de4136b386c156e6c1cb1c8fceebc9ecf](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)",
    "created_at": "2018-06-02T11:12:41Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352557",
    "user": "https://github.com/mantepse"
}
```

**Commit:** [ba613e9de4136b386c156e6c1cb1c8fceebc9ecf](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)



---

archive/issue_comments_352558.json:
```json
{
    "body": "<a id='comment:9'></a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf\">ba613e9</a></td><td><code>refuse to make Sets with unhashable objects</code></td></tr></table>\n",
    "created_at": "2018-06-02T11:12:41Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352558",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:9'></a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf">ba613e9</a></td><td><code>refuse to make Sets with unhashable objects</code></td></tr></table>




---

archive/issue_events_207573.json:
```json
{
    "actor": "https://github.com/mantepse",
    "created_at": "2018-06-02T11:12:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-207573"
}
```



---

archive/issue_comments_352559.json:
```json
{
    "body": "**Author:** Martin Rubey",
    "created_at": "2018-06-02T11:12:41Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352559",
    "user": "https://github.com/mantepse"
}
```

**Author:** Martin Rubey



---

archive/issue_events_207574.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-06-02T13:56:07Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-207574"
}
```



---

archive/issue_events_207575.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-06-02T13:56:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-207575"
}
```



---

archive/issue_comments_352560.json:
```json
{
    "body": "<a id='comment:10'></a>\n-1 from me. There should be a natural object in Sage that behaves like a set but that the (casual) user doesn't have to learn what \"hashable\" means.",
    "created_at": "2018-06-02T13:56:07Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352560",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:10'></a>
-1 from me. There should be a natural object in Sage that behaves like a set but that the (casual) user doesn't have to learn what "hashable" means.



---

archive/issue_comments_352561.json:
```json
{
    "body": "<a id='comment:11'></a>\nHm, I don't see how unhashable (more precisely: mutable) objects can possibly be turned into a set.  Just to make sure: the current `Set` does not behave like a mathematical set at all:\n\n```\nsage: s = Set([[1,2],[1,2]]); s\nSet of elements of [[1, 2], [1, 2]]\nsage: s.cardinality()\n2\nsage: s == Set([[1,2]])\nFalse\n```\n\nHow about telling the user explicitely what to do in the error message?  Something like\n\n```\nsage: Set([QQ, [3, 1], 5])\nValueError: the elements of a Set must be immutable, use tuples instead of lists.\n```",
    "created_at": "2018-06-02T18:31:06Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352561",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:11'></a>
Hm, I don't see how unhashable (more precisely: mutable) objects can possibly be turned into a set.  Just to make sure: the current `Set` does not behave like a mathematical set at all:

```
sage: s = Set([[1,2],[1,2]]); s
Set of elements of [[1, 2], [1, 2]]
sage: s.cardinality()
2
sage: s == Set([[1,2]])
False
```

How about telling the user explicitely what to do in the error message?  Something like

```
sage: Set([QQ, [3, 1], 5])
ValueError: the elements of a Set must be immutable, use tuples instead of lists.
```



---

archive/issue_comments_352562.json:
```json
{
    "body": "<a id='comment:12'></a>\nNote that unhashable does not necessarily mean mutable in the sense that `==` changes. For instance, it may not be possible to devise a (reasonable) hash function such that `a == b` implies `hash(a) == hash(b)`.\n\nNote that I am not saying that it does not have bugs (and some features should be used sparingly), but removing something that is useful to the causal user (in a way, python breaks its own conventions with its builtin classes) and could potentially have use-cases in the wild is why this is a -1.",
    "created_at": "2018-06-03T07:58:29Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352562",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:12'></a>
Note that unhashable does not necessarily mean mutable in the sense that `==` changes. For instance, it may not be possible to devise a (reasonable) hash function such that `a == b` implies `hash(a) == hash(b)`.

Note that I am not saying that it does not have bugs (and some features should be used sparingly), but removing something that is useful to the causal user (in a way, python breaks its own conventions with its builtin classes) and could potentially have use-cases in the wild is why this is a -1.



---

archive/issue_comments_352563.json:
```json
{
    "body": "<a id='comment:13'></a>\nWell, I reported this, because it hit me as a casual user.  I did a (research) experiment, where I was counting the number of elements in a set.  I then found that the number that `Set` reported did not agree with my conjecture.\n\nLuckily, I found out that `Set` was wrong, not my conjecture.\n\nI think it would be good to have a use case where one really wants to make a `Set` of unhashable objects, so that we can incorporate it.\n\nI hope you agree that elements of a set should be immutable?",
    "created_at": "2018-06-03T09:47:57Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352563",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:13'></a>
Well, I reported this, because it hit me as a casual user.  I did a (research) experiment, where I was counting the number of elements in a set.  I then found that the number that `Set` reported did not agree with my conjecture.

Luckily, I found out that `Set` was wrong, not my conjecture.

I think it would be good to have a use case where one really wants to make a `Set` of unhashable objects, so that we can incorporate it.

I hope you agree that elements of a set should be immutable?



---

archive/issue_comments_352564.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [mantepse](#comment%3A13):\n> I hope you agree that elements of a set should be immutable?\n\nThat is far too loaded of a question to get a fair answer.\n\nI am somewhat leaning against it as it would be too difficult to enforce (e.g., a tuple with a list is mutable). Plus there is no way (at least AFAIK in Python) to distinguish hashable and mutable.",
    "created_at": "2018-06-04T00:37:25Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352564",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:14'></a>
Replying to [mantepse](#comment%3A13):
> I hope you agree that elements of a set should be immutable?

That is far too loaded of a question to get a fair answer.

I am somewhat leaning against it as it would be too difficult to enforce (e.g., a tuple with a list is mutable). Plus there is no way (at least AFAIK in Python) to distinguish hashable and mutable.



---

archive/issue_comments_352565.json:
```json
{
    "body": "<a id='comment:15'></a>\nI'm afraid I have a communication problem (on my part), sorry for that. What I meant to ask is: what should the output of the following be:\n\n```\nsage: l = [1,2]; s = Set([l,[1,2]]); s\n\nsage: s.cardinality()\n\nsage: s == Set([[1,2]])\n\nsage: l.append(3)\n\nsage: s\n```\nActually, I think that it makes sense to ask for hashable objects, and I do not think that this is a great burden on the user.  In case of doubt, we could make the error message more explict.\n\nEven more so, because I cannot see any set-like behaviour in `Set` with non-hashable objects.  To me, it looks like a list.  Am I missing something?",
    "created_at": "2018-06-04T07:42:38Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352565",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:15'></a>
I'm afraid I have a communication problem (on my part), sorry for that. What I meant to ask is: what should the output of the following be:

```
sage: l = [1,2]; s = Set([l,[1,2]]); s

sage: s.cardinality()

sage: s == Set([[1,2]])

sage: l.append(3)

sage: s
```
Actually, I think that it makes sense to ask for hashable objects, and I do not think that this is a great burden on the user.  In case of doubt, we could make the error message more explict.

Even more so, because I cannot see any set-like behaviour in `Set` with non-hashable objects.  To me, it looks like a list.  Am I missing something?



---

archive/issue_comments_352566.json:
```json
{
    "body": "<a id='comment:16'></a>\nYou are equating two separate things:\n\n1. The incorrect behavior of `Set` not giving unique objects.\n2. The hashability of objects in `Set`.\n\nI agree that the first one is a bug and should be fixed so that you at least have to start doing something much more evil to break it. This might mean a new class with extra overhead for trying to enforce the uniqueness of the elements.\n\nI do not think it makes sense to force a generic user to care about hashability.Try explaining that to a math undergrad without saying (im)mutable who just wants to create a finite set of vectors. I think it is a much bigger burden than you realize.\n\nRemember, I am thinking of this as a convenience class and not something meant for doing real computations. At that point you should learn/know about hashablity and be using Python's `(frozen)set` directly.",
    "created_at": "2018-06-05T01:07:48Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352566",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>
You are equating two separate things:

1. The incorrect behavior of `Set` not giving unique objects.
2. The hashability of objects in `Set`.

I agree that the first one is a bug and should be fixed so that you at least have to start doing something much more evil to break it. This might mean a new class with extra overhead for trying to enforce the uniqueness of the elements.

I do not think it makes sense to force a generic user to care about hashability.Try explaining that to a math undergrad without saying (im)mutable who just wants to create a finite set of vectors. I think it is a much bigger burden than you realize.

Remember, I am thinking of this as a convenience class and not something meant for doing real computations. At that point you should learn/know about hashablity and be using Python's `(frozen)set` directly.



---

archive/issue_comments_352567.json:
```json
{
    "body": "<a id='comment:17'></a>\n> You are equating two separate things:\n\n>\n>1. The incorrect behavior of Set not giving unique objects.\n>2. The hashability of objects in Set. \n\nIndeed, I do not see how one could separate these two items.  Please explain!\n\nPerhaps more importantly: is there anything one currently can do with `s` below?\n\n```\nsage: s = Set([vector(range(i)) for i in range(5)]); s\nSet of elements of [(), (0), (0, 1), (0, 1, 2), (0, 1, 2, 3)]\n```\n(I tried: `subsets`, which raises an error about unhashability, and `difference` and `union` which actually don't do anything.)\n\nConcerning your (great!) example I think it would be more practical to have an easy way to create vectors immutable, other than\n\n```\nsage: l = [vector(range(i)) for i in range(5)]; map(lambda v: v.set_immutable(), l); set(l)\n[None, None, None, None, None]\n{(0, 1, 2, 3), (0, 1), (0, 1, 2), (), (0)}\n```\n\nFor example (maybe the error message could be better):\n\n```\nsage: set([Graph(i) for i in range(5)])\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n...\nTypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`\nsage: set([Graph(i, immutable=True) for i in range(5)])\n{Graph on 0 vertices,\n Graph on 1 vertex,\n Graph on 2 vertices,\n Graph on 3 vertices,\n Graph on 4 vertices}\n```\n\nThe fundamental problem I see with requiring immutability (instead of hashability) is that there seems to be no way to check whether an object is immutable.  So, the only thing I can think of is to wrap every non-hashable object with\n\n```\nclass SetElement(SageObject):\n    def __init__(self, x):\n        self._elt = copy(x)\n    def _repr_(self):\n        return repr(self._elt)\n```\nI don't know how generic `copy` is.\n\nHowever, I think that it is much safer to point to the documentation, for example, https://stackoverflow.com/questions/14084317/python-mutable-vectors-are-unhashable-error",
    "created_at": "2018-06-05T07:24:50Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352567",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:17'></a>
> You are equating two separate things:

>
>1. The incorrect behavior of Set not giving unique objects.
>2. The hashability of objects in Set. 

Indeed, I do not see how one could separate these two items.  Please explain!

Perhaps more importantly: is there anything one currently can do with `s` below?

```
sage: s = Set([vector(range(i)) for i in range(5)]); s
Set of elements of [(), (0), (0, 1), (0, 1, 2), (0, 1, 2, 3)]
```
(I tried: `subsets`, which raises an error about unhashability, and `difference` and `union` which actually don't do anything.)

Concerning your (great!) example I think it would be more practical to have an easy way to create vectors immutable, other than

```
sage: l = [vector(range(i)) for i in range(5)]; map(lambda v: v.set_immutable(), l); set(l)
[None, None, None, None, None]
{(0, 1, 2, 3), (0, 1), (0, 1, 2), (), (0)}
```

For example (maybe the error message could be better):

```
sage: set([Graph(i) for i in range(5)])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`
sage: set([Graph(i, immutable=True) for i in range(5)])
{Graph on 0 vertices,
 Graph on 1 vertex,
 Graph on 2 vertices,
 Graph on 3 vertices,
 Graph on 4 vertices}
```

The fundamental problem I see with requiring immutability (instead of hashability) is that there seems to be no way to check whether an object is immutable.  So, the only thing I can think of is to wrap every non-hashable object with

```
class SetElement(SageObject):
    def __init__(self, x):
        self._elt = copy(x)
    def _repr_(self):
        return repr(self._elt)
```
I don't know how generic `copy` is.

However, I think that it is much safer to point to the documentation, for example, https://stackoverflow.com/questions/14084317/python-mutable-vectors-are-unhashable-error



---

archive/issue_comments_352568.json:
```json
{
    "body": "<a id='comment:18'></a>\nYou can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc. That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.\n\nIf you wrap objects, you're likely in for a whole host of other problems, e.g., \"why cannot I add two vectors in this set?\"\n\nI do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.\n\n+1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket.",
    "created_at": "2018-06-05T09:10:47Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352568",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:18'></a>
You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc. That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.

If you wrap objects, you're likely in for a whole host of other problems, e.g., "why cannot I add two vectors in this set?"

I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.

+1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket.



---

archive/issue_comments_352569.json:
```json
{
    "body": "<a id='comment:19'></a>\n> +1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket. \n\nI created #25509.\n\n> You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.\n\nI don't see how this could work.  You might get:\n\n```\nsage: l = [1]; s = Set([l, [1,2]]); s\n{[1], [1,2]}\nsage: l.append(2); s\n{[1,2], [1,2]}\nsage: l.add([1,2])\n{[1,2]}\n```\nI think that this would be even more confusing.\n\n> That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.\n\n> If you wrap objects, you're likely in for a whole host of other problems, e.g., \"why cannot I add two vectors in this set?\"\n\nI agree.\n\n> I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.\n\nI don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?",
    "created_at": "2018-06-05T09:43:06Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352569",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:19'></a>
> +1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket. 

I created #25509.

> You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.

I don't see how this could work.  You might get:

```
sage: l = [1]; s = Set([l, [1,2]]); s
{[1], [1,2]}
sage: l.append(2); s
{[1,2], [1,2]}
sage: l.add([1,2])
{[1,2]}
```
I think that this would be even more confusing.

> That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.

> If you wrap objects, you're likely in for a whole host of other problems, e.g., "why cannot I add two vectors in this set?"

I agree.

> I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.

I don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?



---

archive/issue_comments_352570.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [mantepse](#comment%3A19):\n> > You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.\n\n> \n> I don't see how this could work.  You might get:\n> \n> ```\n> sage: l = [1]; s = Set([l, [1,2]]); s\n> {[1], [1,2]}\n> sage: l.append(2); s\n> {[1,2], [1,2]}\n> sage: l.add([1,2])\n> {[1,2]}\n> ```\n> I think that this would be even more confusing.\n\nThat is a deliberate misuse, something that is generally not likely to happen, and essentially impossible to prevent. Now you are going to see that as reason to enforce hashability, but I do not think that is the utility of having this class handle finite sets.\n\n> > I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.\n\n> \n> I don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?\n\nSay you have two bases and you want to compute their common vectors (think matroids):\n\n```\nsage: X = Set([[1,2],[3,4]])\nsage: X\nSet of elements of [[1, 2], [3, 4]]\nsage: X.difference(X)\n{}\nsage: X.difference(Set([[1,2]]))\nSet-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]\nsage: list(_)\n[[3, 4]]\n```\nSo things work much more than you say.\n\nI am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.",
    "created_at": "2018-06-07T06:22:58Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352570",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:20'></a>
Replying to [mantepse](#comment%3A19):
> > You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.

> 
> I don't see how this could work.  You might get:
> 
> ```
> sage: l = [1]; s = Set([l, [1,2]]); s
> {[1], [1,2]}
> sage: l.append(2); s
> {[1,2], [1,2]}
> sage: l.add([1,2])
> {[1,2]}
> ```
> I think that this would be even more confusing.

That is a deliberate misuse, something that is generally not likely to happen, and essentially impossible to prevent. Now you are going to see that as reason to enforce hashability, but I do not think that is the utility of having this class handle finite sets.

> > I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.

> 
> I don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?

Say you have two bases and you want to compute their common vectors (think matroids):

```
sage: X = Set([[1,2],[3,4]])
sage: X
Set of elements of [[1, 2], [3, 4]]
sage: X.difference(X)
{}
sage: X.difference(Set([[1,2]]))
Set-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]
sage: list(_)
[[3, 4]]
```
So things work much more than you say.

I am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.



---

archive/issue_comments_352571.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [tscrim](#comment%3A20):\n\n> Say you have two bases and you want to compute their common vectors (think matroids):\n> \n> ```\n> sage: X = Set([[1,2],[3,4]])\n> sage: X\n> Set of elements of [[1, 2], [3, 4]]\n> sage: X.difference(X)\n> {}\n> sage: X.difference(Set([[1,2]]))\n> Set-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]\n> sage: list(_)\n> [[3, 4]]\n> ```\n> So things work much more than you say.\n\nOK, thanks, I didn't know that this works.\n \n> I am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.\n\nI guess we should have a beer or something. I didn't realize that I'm making you angry, sorry about that.",
    "created_at": "2018-06-07T07:38:27Z",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-352571",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:21'></a>
Replying to [tscrim](#comment%3A20):

> Say you have two bases and you want to compute their common vectors (think matroids):
> 
> ```
> sage: X = Set([[1,2],[3,4]])
> sage: X
> Set of elements of [[1, 2], [3, 4]]
> sage: X.difference(X)
> {}
> sage: X.difference(Set([[1,2]]))
> Set-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]
> sage: list(_)
> [[3, 4]]
> ```
> So things work much more than you say.

OK, thanks, I didn't know that this works.
 
> I am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.

I guess we should have a beer or something. I didn't realize that I'm making you angry, sorry about that.
