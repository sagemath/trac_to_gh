# Issue 23324: surprising behaviour of Set

archive/issues_023087.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\n\n```\nsage: Set([[], []]).cardinality()\n2\n```\n\nIn earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.\n\n`cardinality` should raise an error if the elements of the set are unhashable.\n\nComponent: **misc**\n\nAuthor: **Martin Rubey**\n\nBranch/Commit: **[u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set) @ [`ba613e9`](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/23324_\n\n",
    "created_at": "2017-06-25T19:04:35Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "surprising behaviour of Set",
    "type": "issue",
    "updated_at": "2022-12-29T01:39:18Z",
    "url": "https://github.com/sagemath/sage/issues/23324",
    "user": "https://github.com/mantepse"
}
```
<div id="comment:0"></div>


```
sage: Set([[], []]).cardinality()
2
```

In earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.

`cardinality` should raise an error if the elements of the set are unhashable.

Component: **misc**

Author: **Martin Rubey**

Branch/Commit: **[u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set) @ [`ba613e9`](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)**

_Issue created by migration from https://trac.sagemath.org/ticket/23324_





---

archive/issue_events_321899.json:
```json
{
    "actor": "https://github.com/mantepse",
    "created_at": "2017-06-25T19:04:35Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "milestone_number": null,
    "milestone_title": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321899"
}
```



---

archive/issue_events_321900.json:
```json
{
    "actor": "https://github.com/mantepse",
    "created_at": "2017-06-25T19:04:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321900"
}
```



---

archive/issue_events_321901.json:
```json
{
    "actor": "https://github.com/mantepse",
    "created_at": "2017-06-25T19:04:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321901"
}
```



---

archive/issue_comments_349932.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nThe Set should not even be created.",
    "created_at": "2017-06-25T22:36:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349932",
    "user": "https://github.com/videlec"
}
```

<div id="comment:1" align="right">comment:1</div>

The Set should not even be created.



---

archive/issue_comments_349933.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nThe problem is that we *do* want to support certain infinite sets which cannot be listed, so simply listing all elements is not a solution.",
    "created_at": "2017-06-26T08:55:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349933",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:2" align="right">comment:2</div>

The problem is that we *do* want to support certain infinite sets which cannot be listed, so simply listing all elements is not a solution.



---

archive/issue_comments_349934.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI don't understand your point, the problematic code is `sage/sets/set.py` line 206-211\n\n```\n    try:\n        X = frozenset(X)\n    except TypeError:\n        return Set_object(X)\n    else:\n        return Set_object_enumerated(X)\n```\nIt does expand `X` whatever it is. If the input `X` contains some non hashable object, a kind of lazy set is returned (`Set_object`) and not a proper finite set\n\n```\nsage: S = Set([1,1,1,[]])\nsage: S\nSet of elements of [1, 1, 1, []]\nsage: S.cardinality()\n4\n```\nAnd I think it should just raise a `TypeError` as it used to be. Support for non hashable elements should not be dealt with in the main constructor.",
    "created_at": "2017-06-26T09:06:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349934",
    "user": "https://github.com/videlec"
}
```

<div id="comment:3" align="right">comment:3</div>

I don't understand your point, the problematic code is `sage/sets/set.py` line 206-211

```
    try:
        X = frozenset(X)
    except TypeError:
        return Set_object(X)
    else:
        return Set_object_enumerated(X)
```
It does expand `X` whatever it is. If the input `X` contains some non hashable object, a kind of lazy set is returned (`Set_object`) and not a proper finite set

```
sage: S = Set([1,1,1,[]])
sage: S
Set of elements of [1, 1, 1, []]
sage: S.cardinality()
4
```
And I think it should just raise a `TypeError` as it used to be. Support for non hashable elements should not be dealt with in the main constructor.



---

archive/issue_comments_349935.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [@videlec](#comment%3A3):\n> it should just raise a `TypeError` as it used to be.\n\nThis \"used to be\" the case only for certain specific types (which included `list`). It really makes no sense to say \"for these specific types, we require that the elements of the set are hashable, but for other types not\". The only sensible options are to have such requirement never (which is the current implementation) or always.",
    "created_at": "2017-06-26T09:13:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349935",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [@videlec](#comment%3A3):
> it should just raise a `TypeError` as it used to be.

This "used to be" the case only for certain specific types (which included `list`). It really makes no sense to say "for these specific types, we require that the elements of the set are hashable, but for other types not". The only sensible options are to have such requirement never (which is the current implementation) or always.



---

archive/issue_comments_349936.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -4,9 +4,6 @@\n 2\n ```\n \n-In earlier versions, a `TypeError: unhashable type: 'list'` was raised.\n+In earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.\n \n-I think the behaviour was modified in https://github.com/sagemath/sage/issues/22597.\n-\n-`cardinality` should raise an error if the elements of the set are unhashable or mutable.\n-\n+`cardinality` should raise an error if the elements of the set are unhashable.\n``````\n",
    "created_at": "2017-06-26T09:13:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349936",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -4,9 +4,6 @@
 2
 ```
 
-In earlier versions, a `TypeError: unhashable type: 'list'` was raised.
+In earlier versions (before #22597), a `TypeError: unhashable type: 'list'` was raised.
 
-I think the behaviour was modified in https://github.com/sagemath/sage/issues/22597.
-
-`cardinality` should raise an error if the elements of the set are unhashable or mutable.
-
+`cardinality` should raise an error if the elements of the set are unhashable.
``````




---

archive/issue_comments_349937.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nDoes the following make sense!?\n\n```\nsage: Set([1, 1, 2])\n{1, 2}\nsage: Set([[], 1, 1, 2])\nSet of elements of [[], 1, 1, 2]\n```\nor\n\n```\nsage: Set([1,2]) == Set([2,1])\nTrue\nsage: Set([[],1]) == Set([1,[]])\nFalse\n```\nor\n\n```\nsage: l1 = []\nsage: l2 = []\nsage: S1 = Set([l1])\nsage: S2 = Set([l2])\nsage: S1 == S2\nTrue\nsage: l1.append('hello')\nsage: S1 == S2\nFalse\n```\nThe `Set` function is a globally available factory for constructing mathematical sets. It is useful and possible to have mathematical sets made of Python lists. However, I do think that the `Set` constructor should not be used for that purpose.",
    "created_at": "2017-06-26T09:37:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349937",
    "user": "https://github.com/videlec"
}
```

<div id="comment:5" align="right">comment:5</div>

Does the following make sense!?

```
sage: Set([1, 1, 2])
{1, 2}
sage: Set([[], 1, 1, 2])
Set of elements of [[], 1, 1, 2]
```
or

```
sage: Set([1,2]) == Set([2,1])
True
sage: Set([[],1]) == Set([1,[]])
False
```
or

```
sage: l1 = []
sage: l2 = []
sage: S1 = Set([l1])
sage: S2 = Set([l2])
sage: S1 == S2
True
sage: l1.append('hello')
sage: S1 == S2
False
```
The `Set` function is a globally available factory for constructing mathematical sets. It is useful and possible to have mathematical sets made of Python lists. However, I do think that the `Set` constructor should not be used for that purpose.



---

archive/issue_comments_349938.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nReplying to [@videlec](#comment%3A5):\n> Does the following make sense!?\n\nOf course not. I never said that the current behaviour makes sense. I just wanted to defend #22597 and to point out that it's more complicated than you think, that's all.\n\nThe current behaviour is because of the need to support infinite sets:\n\n```\nsage: Set(RR)\nSet of elements of Real Field with 53 bits of precision\n```\nWe could of course disallow that and simply always call `frozenset(X)`.",
    "created_at": "2017-06-26T09:44:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349938",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:6" align="right">comment:6</div>

Replying to [@videlec](#comment%3A5):
> Does the following make sense!?

Of course not. I never said that the current behaviour makes sense. I just wanted to defend #22597 and to point out that it's more complicated than you think, that's all.

The current behaviour is because of the need to support infinite sets:

```
sage: Set(RR)
Set of elements of Real Field with 53 bits of precision
```
We could of course disallow that and simply always call `frozenset(X)`.



---

archive/issue_comments_349939.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nReplying to [@jdemeyer](#comment%3A6):\n> Replying to [@videlec](#comment%3A5):\n> The current behaviour is because of the need to support infinite sets:\n\nIn your example, I don't even understand why `RR` is not itself returned.\n\nA more sensible behavior would be\n- if `X` is a `Parent` whose category is a subcategory of `Set` then returns it (or possibly a wrapper around it)\n- otherwise return a finite mathematical set corresponding to `frozenset(X)`\n\nIt just boils down to replace the code metioned in [comment:3](#comment%3A3) into\n\n```\n    return Set_object_enumerated(frozenset(X))\n```\n(the part for infinite stuff is already done at this stage)",
    "created_at": "2017-06-26T09:50:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349939",
    "user": "https://github.com/videlec"
}
```

<div id="comment:7" align="right">comment:7</div>

Replying to [@jdemeyer](#comment%3A6):
> Replying to [@videlec](#comment%3A5):
> The current behaviour is because of the need to support infinite sets:

In your example, I don't even understand why `RR` is not itself returned.

A more sensible behavior would be
- if `X` is a `Parent` whose category is a subcategory of `Set` then returns it (or possibly a wrapper around it)
- otherwise return a finite mathematical set corresponding to `frozenset(X)`

It just boils down to replace the code metioned in [comment:3](#comment%3A3) into

```
    return Set_object_enumerated(frozenset(X))
```
(the part for infinite stuff is already done at this stage)



---

archive/issue_comments_349940.json:
```json
{
    "body": "Branch: **[u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set)**",
    "created_at": "2018-06-02T11:12:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349940",
    "user": "https://github.com/mantepse"
}
```

Branch: **[u/mantepse/surprising_behaviour_of_set](https://github.com/sagemath/sagetrac-mirror/tree/u/mantepse/surprising_behaviour_of_set)**



---

archive/issue_events_321902.json:
```json
{
    "actor": "https://github.com/mantepse",
    "created_at": "2018-06-02T11:12:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321902"
}
```



---

archive/issue_comments_349941.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf\"><code>ba613e9</code></a></td><td><code>refuse to make Sets with unhashable objects</code></td></tr></table>\n",
    "created_at": "2018-06-02T11:12:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349941",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:9"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf"><code>ba613e9</code></a></td><td><code>refuse to make Sets with unhashable objects</code></td></tr></table>




---

archive/issue_comments_349942.json:
```json
{
    "body": "Author: **Martin Rubey**",
    "created_at": "2018-06-02T11:12:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349942",
    "user": "https://github.com/mantepse"
}
```

Author: **Martin Rubey**



---

archive/issue_comments_349943.json:
```json
{
    "body": "Commit: **[`ba613e9`](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)**",
    "created_at": "2018-06-02T11:12:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349943",
    "user": "https://github.com/mantepse"
}
```

Commit: **[`ba613e9`](https://github.com/sagemath/sagetrac-mirror/commit/ba613e9de4136b386c156e6c1cb1c8fceebc9ecf)**



---

archive/issue_events_321903.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-06-02T13:56:07Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321903"
}
```



---

archive/issue_events_321904.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-06-02T13:56:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321904"
}
```



---

archive/issue_comments_349944.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\n-1 from me. There should be a natural object in Sage that behaves like a set but that the (casual) user doesn't have to learn what \"hashable\" means.",
    "created_at": "2018-06-02T13:56:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349944",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:10" align="right">comment:10</div>

-1 from me. There should be a natural object in Sage that behaves like a set but that the (casual) user doesn't have to learn what "hashable" means.



---

archive/issue_comments_349945.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nHm, I don't see how unhashable (more precisely: mutable) objects can possibly be turned into a set.  Just to make sure: the current `Set` does not behave like a mathematical set at all:\n\n```\nsage: s = Set([[1,2],[1,2]]); s\nSet of elements of [[1, 2], [1, 2]]\nsage: s.cardinality()\n2\nsage: s == Set([[1,2]])\nFalse\n```\n\nHow about telling the user explicitely what to do in the error message?  Something like\n\n```\nsage: Set([QQ, [3, 1], 5])\nValueError: the elements of a Set must be immutable, use tuples instead of lists.\n```",
    "created_at": "2018-06-02T18:31:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349945",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:11" align="right">comment:11</div>

Hm, I don't see how unhashable (more precisely: mutable) objects can possibly be turned into a set.  Just to make sure: the current `Set` does not behave like a mathematical set at all:

```
sage: s = Set([[1,2],[1,2]]); s
Set of elements of [[1, 2], [1, 2]]
sage: s.cardinality()
2
sage: s == Set([[1,2]])
False
```

How about telling the user explicitely what to do in the error message?  Something like

```
sage: Set([QQ, [3, 1], 5])
ValueError: the elements of a Set must be immutable, use tuples instead of lists.
```



---

archive/issue_comments_349946.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nNote that unhashable does not necessarily mean mutable in the sense that `==` changes. For instance, it may not be possible to devise a (reasonable) hash function such that `a == b` implies `hash(a) == hash(b)`.\n\nNote that I am not saying that it does not have bugs (and some features should be used sparingly), but removing something that is useful to the causal user (in a way, python breaks its own conventions with its builtin classes) and could potentially have use-cases in the wild is why this is a -1.",
    "created_at": "2018-06-03T07:58:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349946",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:12" align="right">comment:12</div>

Note that unhashable does not necessarily mean mutable in the sense that `==` changes. For instance, it may not be possible to devise a (reasonable) hash function such that `a == b` implies `hash(a) == hash(b)`.

Note that I am not saying that it does not have bugs (and some features should be used sparingly), but removing something that is useful to the causal user (in a way, python breaks its own conventions with its builtin classes) and could potentially have use-cases in the wild is why this is a -1.



---

archive/issue_comments_349947.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nWell, I reported this, because it hit me as a casual user.  I did a (research) experiment, where I was counting the number of elements in a set.  I then found that the number that `Set` reported did not agree with my conjecture.\n\nLuckily, I found out that `Set` was wrong, not my conjecture.\n\nI think it would be good to have a use case where one really wants to make a `Set` of unhashable objects, so that we can incorporate it.\n\nI hope you agree that elements of a set should be immutable?",
    "created_at": "2018-06-03T09:47:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349947",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:13" align="right">comment:13</div>

Well, I reported this, because it hit me as a casual user.  I did a (research) experiment, where I was counting the number of elements in a set.  I then found that the number that `Set` reported did not agree with my conjecture.

Luckily, I found out that `Set` was wrong, not my conjecture.

I think it would be good to have a use case where one really wants to make a `Set` of unhashable objects, so that we can incorporate it.

I hope you agree that elements of a set should be immutable?



---

archive/issue_comments_349948.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [@mantepse](#comment%3A13):\n> I hope you agree that elements of a set should be immutable?\n\nThat is far too loaded of a question to get a fair answer.\n\nI am somewhat leaning against it as it would be too difficult to enforce (e.g., a tuple with a list is mutable). Plus there is no way (at least AFAIK in Python) to distinguish hashable and mutable.",
    "created_at": "2018-06-04T00:37:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349948",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [@mantepse](#comment%3A13):
> I hope you agree that elements of a set should be immutable?

That is far too loaded of a question to get a fair answer.

I am somewhat leaning against it as it would be too difficult to enforce (e.g., a tuple with a list is mutable). Plus there is no way (at least AFAIK in Python) to distinguish hashable and mutable.



---

archive/issue_comments_349949.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nI'm afraid I have a communication problem (on my part), sorry for that. What I meant to ask is: what should the output of the following be:\n\n```\nsage: l = [1,2]; s = Set([l,[1,2]]); s\n\nsage: s.cardinality()\n\nsage: s == Set([[1,2]])\n\nsage: l.append(3)\n\nsage: s\n```\nActually, I think that it makes sense to ask for hashable objects, and I do not think that this is a great burden on the user.  In case of doubt, we could make the error message more explict.\n\nEven more so, because I cannot see any set-like behaviour in `Set` with non-hashable objects.  To me, it looks like a list.  Am I missing something?",
    "created_at": "2018-06-04T07:42:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349949",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:15" align="right">comment:15</div>

I'm afraid I have a communication problem (on my part), sorry for that. What I meant to ask is: what should the output of the following be:

```
sage: l = [1,2]; s = Set([l,[1,2]]); s

sage: s.cardinality()

sage: s == Set([[1,2]])

sage: l.append(3)

sage: s
```
Actually, I think that it makes sense to ask for hashable objects, and I do not think that this is a great burden on the user.  In case of doubt, we could make the error message more explict.

Even more so, because I cannot see any set-like behaviour in `Set` with non-hashable objects.  To me, it looks like a list.  Am I missing something?



---

archive/issue_comments_349950.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nYou are equating two separate things:\n\n1. The incorrect behavior of `Set` not giving unique objects.\n2. The hashability of objects in `Set`.\n\nI agree that the first one is a bug and should be fixed so that you at least have to start doing something much more evil to break it. This might mean a new class with extra overhead for trying to enforce the uniqueness of the elements.\n\nI do not think it makes sense to force a generic user to care about hashability.Try explaining that to a math undergrad without saying (im)mutable who just wants to create a finite set of vectors. I think it is a much bigger burden than you realize.\n\nRemember, I am thinking of this as a convenience class and not something meant for doing real computations. At that point you should learn/know about hashablity and be using Python's `(frozen)set` directly.",
    "created_at": "2018-06-05T01:07:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349950",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:16" align="right">comment:16</div>

You are equating two separate things:

1. The incorrect behavior of `Set` not giving unique objects.
2. The hashability of objects in `Set`.

I agree that the first one is a bug and should be fixed so that you at least have to start doing something much more evil to break it. This might mean a new class with extra overhead for trying to enforce the uniqueness of the elements.

I do not think it makes sense to force a generic user to care about hashability.Try explaining that to a math undergrad without saying (im)mutable who just wants to create a finite set of vectors. I think it is a much bigger burden than you realize.

Remember, I am thinking of this as a convenience class and not something meant for doing real computations. At that point you should learn/know about hashablity and be using Python's `(frozen)set` directly.



---

archive/issue_comments_349951.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\n> You are equating two separate things:\n>\n>\n>1. The incorrect behavior of Set not giving unique objects.\n>2. The hashability of objects in Set. \n\nIndeed, I do not see how one could separate these two items.  Please explain!\n\nPerhaps more importantly: is there anything one currently can do with `s` below?\n\n```\nsage: s = Set([vector(range(i)) for i in range(5)]); s\nSet of elements of [(), (0), (0, 1), (0, 1, 2), (0, 1, 2, 3)]\n```\n(I tried: `subsets`, which raises an error about unhashability, and `difference` and `union` which actually don't do anything.)\n\nConcerning your (great!) example I think it would be more practical to have an easy way to create vectors immutable, other than\n\n```\nsage: l = [vector(range(i)) for i in range(5)]; map(lambda v: v.set_immutable(), l); set(l)\n[None, None, None, None, None]\n{(0, 1, 2, 3), (0, 1), (0, 1, 2), (), (0)}\n```\n\nFor example (maybe the error message could be better):\n\n```\nsage: set([Graph(i) for i in range(5)])\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n...\nTypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`\nsage: set([Graph(i, immutable=True) for i in range(5)])\n{Graph on 0 vertices,\n Graph on 1 vertex,\n Graph on 2 vertices,\n Graph on 3 vertices,\n Graph on 4 vertices}\n```\n\nThe fundamental problem I see with requiring immutability (instead of hashability) is that there seems to be no way to check whether an object is immutable.  So, the only thing I can think of is to wrap every non-hashable object with\n\n```\nclass SetElement(SageObject):\n    def __init__(self, x):\n        self._elt = copy(x)\n    def _repr_(self):\n        return repr(self._elt)\n```\nI don't know how generic `copy` is.\n\nHowever, I think that it is much safer to point to the documentation, for example, https://stackoverflow.com/questions/14084317/python-mutable-vectors-are-unhashable-error",
    "created_at": "2018-06-05T07:24:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349951",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:17" align="right">comment:17</div>

> You are equating two separate things:
>
>
>1. The incorrect behavior of Set not giving unique objects.
>2. The hashability of objects in Set. 

Indeed, I do not see how one could separate these two items.  Please explain!

Perhaps more importantly: is there anything one currently can do with `s` below?

```
sage: s = Set([vector(range(i)) for i in range(5)]); s
Set of elements of [(), (0), (0, 1), (0, 1, 2), (0, 1, 2, 3)]
```
(I tried: `subsets`, which raises an error about unhashability, and `difference` and `union` which actually don't do anything.)

Concerning your (great!) example I think it would be more practical to have an easy way to create vectors immutable, other than

```
sage: l = [vector(range(i)) for i in range(5)]; map(lambda v: v.set_immutable(), l); set(l)
[None, None, None, None, None]
{(0, 1, 2, 3), (0, 1), (0, 1, 2), (), (0)}
```

For example (maybe the error message could be better):

```
sage: set([Graph(i) for i in range(5)])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: This graph is mutable, and thus not hashable. Create an immutable copy by `g.copy(immutable=True)`
sage: set([Graph(i, immutable=True) for i in range(5)])
{Graph on 0 vertices,
 Graph on 1 vertex,
 Graph on 2 vertices,
 Graph on 3 vertices,
 Graph on 4 vertices}
```

The fundamental problem I see with requiring immutability (instead of hashability) is that there seems to be no way to check whether an object is immutable.  So, the only thing I can think of is to wrap every non-hashable object with

```
class SetElement(SageObject):
    def __init__(self, x):
        self._elt = copy(x)
    def _repr_(self):
        return repr(self._elt)
```
I don't know how generic `copy` is.

However, I think that it is much safer to point to the documentation, for example, https://stackoverflow.com/questions/14084317/python-mutable-vectors-are-unhashable-error



---

archive/issue_comments_349952.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nYou can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc. That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.\n\nIf you wrap objects, you're likely in for a whole host of other problems, e.g., \"why cannot I add two vectors in this set?\"\n\nI do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.\n\n+1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket.",
    "created_at": "2018-06-05T09:10:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349952",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:18" align="right">comment:18</div>

You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc. That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.

If you wrap objects, you're likely in for a whole host of other problems, e.g., "why cannot I add two vectors in this set?"

I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.

+1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket.



---

archive/issue_comments_349953.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\n> +1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket. \n\nI created #25509.\n\n> You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.\n\nI don't see how this could work.  You might get:\n\n```\nsage: l = [1]; s = Set([l, [1,2]]); s\n{[1], [1,2]}\nsage: l.append(2); s\n{[1,2], [1,2]}\nsage: l.add([1,2])\n{[1,2]}\n```\nI think that this would be even more confusing.\n\n> That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.\n\n> If you wrap objects, you're likely in for a whole host of other problems, e.g., \"why cannot I add two vectors in this set?\"\n\nI agree.\n\n> I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.\n\nI don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?",
    "created_at": "2018-06-05T09:43:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349953",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:19" align="right">comment:19</div>

> +1 for having a better way to construct immutable vectors, matrices, etc. Separate ticket. 

I created #25509.

> You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.

I don't see how this could work.  You might get:

```
sage: l = [1]; s = Set([l, [1,2]]); s
{[1], [1,2]}
sage: l.append(2); s
{[1,2], [1,2]}
sage: l.add([1,2])
{[1,2]}
```
I think that this would be even more confusing.

> That's not to say that enforcing the hashability does not solve 1, but they are two different discussions.

> If you wrap objects, you're likely in for a whole host of other problems, e.g., "why cannot I add two vectors in this set?"

I agree.

> I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.

I don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?



---

archive/issue_comments_349954.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nReplying to [@mantepse](#comment%3A19):\n> > You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.\n> \n> \n> I don't see how this could work.  You might get:\n> \n> ```\n> sage: l = [1]; s = Set([l, [1,2]]); s\n> {[1], [1,2]}\n> sage: l.append(2); s\n> {[1,2], [1,2]}\n> sage: l.add([1,2])\n> {[1,2]}\n> ```\n> I think that this would be even more confusing.\n\nThat is a deliberate misuse, something that is generally not likely to happen, and essentially impossible to prevent. Now you are going to see that as reason to enforce hashability, but I do not think that is the utility of having this class handle finite sets.\n\n> > I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.\n> \n> \n> I don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?\n\nSay you have two bases and you want to compute their common vectors (think matroids):\n\n```\nsage: X = Set([[1,2],[3,4]])\nsage: X\nSet of elements of [[1, 2], [3, 4]]\nsage: X.difference(X)\n{}\nsage: X.difference(Set([[1,2]]))\nSet-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]\nsage: list(_)\n[[3, 4]]\n```\nSo things work much more than you say.\n\nI am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.",
    "created_at": "2018-06-07T06:22:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349954",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:20" align="right">comment:20</div>

Replying to [@mantepse](#comment%3A19):
> > You can work towards solving 1 by doing things like removing duplicates on construction, adding elements, etc.
> 
> 
> I don't see how this could work.  You might get:
> 
> ```
> sage: l = [1]; s = Set([l, [1,2]]); s
> {[1], [1,2]}
> sage: l.append(2); s
> {[1,2], [1,2]}
> sage: l.add([1,2])
> {[1,2]}
> ```
> I think that this would be even more confusing.

That is a deliberate misuse, something that is generally not likely to happen, and essentially impossible to prevent. Now you are going to see that as reason to enforce hashability, but I do not think that is the utility of having this class handle finite sets.

> > I do not think you can get around the non-hashability issue out by simply documenting hashability/immutability either. There is both too much to document/enforce/explain. Again, IMSO, such a user should not have to know/care about these things.
> 
> 
> I don't really understand this paragraph.  Currently, non-hashable objects in 'Set' do not raise an error, but do not work at all.  There is not a single operation which does something sensible in this case.  Yes, the casual user could create a set of vectors, but what could she do then with it thereafter?

Say you have two bases and you want to compute their common vectors (think matroids):

```
sage: X = Set([[1,2],[3,4]])
sage: X
Set of elements of [[1, 2], [3, 4]]
sage: X.difference(X)
{}
sage: X.difference(Set([[1,2]]))
Set-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]
sage: list(_)
[[3, 4]]
```
So things work much more than you say.

I am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.



---

archive/issue_comments_349955.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@tscrim](#comment%3A20):\n\n> Say you have two bases and you want to compute their common vectors (think matroids):\n> \n> ```\n> sage: X = Set([[1,2],[3,4]])\n> sage: X\n> Set of elements of [[1, 2], [3, 4]]\n> sage: X.difference(X)\n> {}\n> sage: X.difference(Set([[1,2]]))\n> Set-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]\n> sage: list(_)\n> [[3, 4]]\n> ```\n> So things work much more than you say.\n\nOK, thanks, I didn't know that this works.\n \n> I am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.\n\nI guess we should have a beer or something. I didn't realize that I'm making you angry, sorry about that.",
    "created_at": "2018-06-07T07:38:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/23324#issuecomment-349955",
    "user": "https://github.com/mantepse"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@tscrim](#comment%3A20):

> Say you have two bases and you want to compute their common vectors (think matroids):
> 
> ```
> sage: X = Set([[1,2],[3,4]])
> sage: X
> Set of elements of [[1, 2], [3, 4]]
> sage: X.difference(X)
> {}
> sage: X.difference(Set([[1,2]]))
> Set-theoretic difference of Set of elements of [[1, 2], [3, 4]] and Set of elements of [[1, 2]]
> sage: list(_)
> [[3, 4]]
> ```
> So things work much more than you say.

OK, thanks, I didn't know that this works.
 
> I am tired of arguing about this. I am getting far too angry and frustrated. Do whatever you want.

I guess we should have a beer or something. I didn't realize that I'm making you angry, sorry about that.



---

archive/issue_events_321905.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:39:18Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/23324",
    "milestone_number": null,
    "milestone_title": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/23324#event-321905"
}
```
