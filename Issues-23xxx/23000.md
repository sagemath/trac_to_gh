# Issue 23000: Fix inconsistency in `Modules.FiniteDimensional.extra_super_categories`

archive/issues_022763.json:
```json
{
    "body": "Finite dimensional modules over a finite field are known to Sage to be finite:\n\n```\n    sage: Modules(GF(3)).FiniteDimensional().is_subcategory(Sets().Finite())\n    True\n```\n\nHowever this piece of knowledge was ignored if a\nbase ring category instead of a base ring was passed to `Modules`:\n\n```\n    sage: Modules(Field().Finite()).FiniteDimensional().is_subcategory(Sets().Finite())\n    True\n```\n\nThis ticket fixes this.\n\n## Comments\n\nThis is yet another avatar of the current lack of robustness of\ncategories over base rings. With #20962 which will make module\ncategories singletons, this kind of inconsistency won't be possible\nanymore.\n\nThis issue was discovered while tracking a bug in #18700 which\nimplemented a new category `AdditiveGroups.Finite`, which triggered\nthe following doctest failure:\n\n```\nsage: K = simplicial_complexes.Simplex(2)\nsage: H = Hom(K,K)\nsage: id = H.identity()\nsage: id.induced_homology_morphism(GF(13)).base_ring()\nTraceback (most recent call last)\n.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()\n    936                     heads[j] = X\n    937                     tailset = tailsets[j]\n--> 938                     tailset.remove(key(X))\n    939                 else:\n    940                     del heads[j]\n\nKeyError: (258, 65)\n```\n\n## Detailed analysis\n\nRecall that:\n\n- categories are endowed with a total order which is used to ensure\n  that the Method Resolution Orders chosen by Python are always\n  consistent. This total order shall refine the subcategory relation.\n  This is achieved by assigning a comparison key to each category\n  according to the order in which they are created (and some further\n  data)\n\n- To avoid creating many copies of the same hierarchy of classes,\n  parametrized categories may share their parent/element/... classes,\n  and therefore the same comparison key.\n\nIn the case at hand,\n`C1=Modules(Fields().Finite().FiniteDimensional()` was created first.\nSince it was not a subcategory of `A=AdditiveGroups().Finite()`, there\nwas no constraint on their relative comparison keys; it then turned\nout that `C` was assigned a comparison key smaller than that of `A`.\n\nLater on, when `C2=Modules(GF(3)).FiniteDimensional()` got created, it\ngot the same comparison key as `C1` while simultaneously deriving from\n`A`, breaking the assumption.\n\n\nCC:  @tscrim\n\nBranch/Commit: fc766203eaecbbf86767571c68dc569a02b2582c\n\nReviewer: Travis Scrimshaw\n\nAuthor: Nicolas M. Thi\u00e9ry\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/23000\n\n",
    "closed_at": "2017-05-20T20:07:40Z",
    "created_at": "2017-05-15T02:28:07Z",
    "labels": [
        "component: categories",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Fix inconsistency in `Modules.FiniteDimensional.extra_super_categories`",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23000",
    "user": "https://github.com/nthiery"
}
```
Finite dimensional modules over a finite field are known to Sage to be finite:

```
    sage: Modules(GF(3)).FiniteDimensional().is_subcategory(Sets().Finite())
    True
```

However this piece of knowledge was ignored if a
base ring category instead of a base ring was passed to `Modules`:

```
    sage: Modules(Field().Finite()).FiniteDimensional().is_subcategory(Sets().Finite())
    True
```

This ticket fixes this.

## Comments

This is yet another avatar of the current lack of robustness of
categories over base rings. With #20962 which will make module
categories singletons, this kind of inconsistency won't be possible
anymore.

This issue was discovered while tracking a bug in #18700 which
implemented a new category `AdditiveGroups.Finite`, which triggered
the following doctest failure:

```
sage: K = simplicial_complexes.Simplex(2)
sage: H = Hom(K,K)
sage: id = H.identity()
sage: id.induced_homology_morphism(GF(13)).base_ring()
Traceback (most recent call last)
.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()
    936                     heads[j] = X
    937                     tailset = tailsets[j]
--> 938                     tailset.remove(key(X))
    939                 else:
    940                     del heads[j]

KeyError: (258, 65)
```

## Detailed analysis

Recall that:

- categories are endowed with a total order which is used to ensure
  that the Method Resolution Orders chosen by Python are always
  consistent. This total order shall refine the subcategory relation.
  This is achieved by assigning a comparison key to each category
  according to the order in which they are created (and some further
  data)

- To avoid creating many copies of the same hierarchy of classes,
  parametrized categories may share their parent/element/... classes,
  and therefore the same comparison key.

In the case at hand,
`C1=Modules(Fields().Finite().FiniteDimensional()` was created first.
Since it was not a subcategory of `A=AdditiveGroups().Finite()`, there
was no constraint on their relative comparison keys; it then turned
out that `C` was assigned a comparison key smaller than that of `A`.

Later on, when `C2=Modules(GF(3)).FiniteDimensional()` got created, it
got the same comparison key as `C1` while simultaneously deriving from
`A`, breaking the assumption.


CC:  @tscrim

Branch/Commit: fc766203eaecbbf86767571c68dc569a02b2582c

Reviewer: Travis Scrimshaw

Author: Nicolas M. ThiÃ©ry

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/23000





---

archive/issue_comments_430834.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,58 @@\n+#18700 implements a new category `AdditiveGroups.Finite`. Without\n+further change, this triggered the following doctest failure:\n+\n+```\n+sage: K = simplicial_complexes.Simplex(2)\n+sage: H = Hom(K,K)\n+sage: id = H.identity()\n+sage: id.induced_homology_morphism(GF(13)).base_ring()\n+Traceback (most recent call last)\n+.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()\n+    936                     heads[j] = X\n+    937                     tailset = tailsets[j]\n+--> 938                     tailset.remove(key(X))\n+    939                 else:\n+    940                     del heads[j]\n+\n+KeyError: (258, 65)\n+```\n+\n+This is yet another avatar of lack of robustness of categories over\n+base rings, which will be fixed by #20962 when module categories will\n+be singleton. To get the ball rolling for #18700 which is otherwise\n+ready, this ticket provides a quick workaround which should be robust\n+enough for now.\n+\n+\n+## Detailed analysis\n+\n+Recall that\n+\n+- categories are endowed with a total order which is used to ensure\n+  that the Method Resolution Orders chosen by Python are always\n+  consistent. This total order shall refine the subcategory relation.\n+  This is achieved by assigning a comparison key to each category\n+  according to the order in which they are created.\n+\n+- To make the total order more reproducible from one session to the\n+  other, the first piece of the comparison key is given by a bit array\n+  of flags which are set according to whether the category is a\n+  subcategory of some \"atom categories\": `FacadeSets`, `FiniteSets`, ...\n+\n+- To avoid creating many copies of the same hierarchy of classes,\n+  parametrized categories may share their parent/element/... classes,\n+  and therefore the same comparison key.\n+\n+  In the case at hand, depending on the order in which categories were\n+  created, the assumption of refining the subcategory relation got\n+  broken (I still need to analyze this precisely):\n+  `Modules(GF(3)).FiniteDimensional()` got a key smaller than its\n+  super category `AdditiveGroup().Finite()`\n+\n+This risk will vanish by itself when module categories will be\n+singleton. In the mean time, adding \"Modules\" to the list of atom\n+categories guarantee that `AdditiveGroups().Finite()` gets a strictly\n+smaller key.\n \n \n Comment: 1\n``````\n",
    "created_at": "2017-05-15T03:13:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430834",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,58 @@
+#18700 implements a new category `AdditiveGroups.Finite`. Without
+further change, this triggered the following doctest failure:
+
+```
+sage: K = simplicial_complexes.Simplex(2)
+sage: H = Hom(K,K)
+sage: id = H.identity()
+sage: id.induced_homology_morphism(GF(13)).base_ring()
+Traceback (most recent call last)
+.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()
+    936                     heads[j] = X
+    937                     tailset = tailsets[j]
+--> 938                     tailset.remove(key(X))
+    939                 else:
+    940                     del heads[j]
+
+KeyError: (258, 65)
+```
+
+This is yet another avatar of lack of robustness of categories over
+base rings, which will be fixed by #20962 when module categories will
+be singleton. To get the ball rolling for #18700 which is otherwise
+ready, this ticket provides a quick workaround which should be robust
+enough for now.
+
+
+## Detailed analysis
+
+Recall that
+
+- categories are endowed with a total order which is used to ensure
+  that the Method Resolution Orders chosen by Python are always
+  consistent. This total order shall refine the subcategory relation.
+  This is achieved by assigning a comparison key to each category
+  according to the order in which they are created.
+
+- To make the total order more reproducible from one session to the
+  other, the first piece of the comparison key is given by a bit array
+  of flags which are set according to whether the category is a
+  subcategory of some "atom categories": `FacadeSets`, `FiniteSets`, ...
+
+- To avoid creating many copies of the same hierarchy of classes,
+  parametrized categories may share their parent/element/... classes,
+  and therefore the same comparison key.
+
+  In the case at hand, depending on the order in which categories were
+  created, the assumption of refining the subcategory relation got
+  broken (I still need to analyze this precisely):
+  `Modules(GF(3)).FiniteDimensional()` got a key smaller than its
+  super category `AdditiveGroup().Finite()`
+
+This risk will vanish by itself when module categories will be
+singleton. In the mean time, adding "Modules" to the list of atom
+categories guarantee that `AdditiveGroups().Finite()` gets a strictly
+smaller key.
 
 
 Comment: 1
``````




---

archive/issue_comments_430835.json:
```json
{
    "body": "Changing branch from \"\" to \"u/nthiery/add_trivial__additivegroups_finite__category__and_workaround_mro_issue\"",
    "created_at": "2017-05-15T03:24:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430835",
    "user": "https://github.com/nthiery"
}
```

Changing branch from "" to "u/nthiery/add_trivial__additivegroups_finite__category__and_workaround_mro_issue"



---

archive/issue_comments_430836.json:
```json
{
    "body": "<a id='comment:3'></a>All tests passed on my machine.\n\nNot yet \"needs review\" for I want to dig once more in to check a detail I did not quite fully understand yet in the failure.\n\n---\nNew commits:",
    "created_at": "2017-05-15T03:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430836",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>All tests passed on my machine.

Not yet "needs review" for I want to dig once more in to check a detail I did not quite fully understand yet in the failure.

---
New commits:



---

archive/issue_comments_430837.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2017-05-15T03:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430837",
    "user": "https://github.com/nthiery"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_430838.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2017-05-15T03:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430838",
    "user": "https://github.com/nthiery"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_430839.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to categories.",
    "created_at": "2017-05-15T03:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430839",
    "user": "https://github.com/nthiery"
}
```

Changing component from PLEASE CHANGE to categories.



---

archive/issue_comments_430840.json:
```json
{
    "body": "Changing commit from \"\" to \"da3ddcd201fd481431881083266cdea0a42c6453\"",
    "created_at": "2017-05-15T03:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430840",
    "user": "https://github.com/nthiery"
}
```

Changing commit from "" to "da3ddcd201fd481431881083266cdea0a42c6453"



---

archive/issue_comments_430841.json:
```json
{
    "body": "<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-05-15T03:27:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430841",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_430842.json:
```json
{
    "body": "Changing commit from \"da3ddcd201fd481431881083266cdea0a42c6453\" to \"bc94ce675b1b3c380c1aef09cd036f9c41dacef4\"",
    "created_at": "2017-05-15T03:27:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430842",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "da3ddcd201fd481431881083266cdea0a42c6453" to "bc94ce675b1b3c380c1aef09cd036f9c41dacef4"



---

archive/issue_comments_430843.json:
```json
{
    "body": "<a id='comment:5'></a>(force repushed after fixing the commit message).",
    "created_at": "2017-05-15T03:28:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430843",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>(force repushed after fixing the commit message).



---

archive/issue_comments_430844.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,58 @@\n+#18700 implements a new category `AdditiveGroups.Finite`. Without\n+further change, this triggered the following doctest failure:\n+\n+```\n+sage: K = simplicial_complexes.Simplex(2)\n+sage: H = Hom(K,K)\n+sage: id = H.identity()\n+sage: id.induced_homology_morphism(GF(13)).base_ring()\n+Traceback (most recent call last)\n+.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()\n+    936                     heads[j] = X\n+    937                     tailset = tailsets[j]\n+--> 938                     tailset.remove(key(X))\n+    939                 else:\n+    940                     del heads[j]\n+\n+KeyError: (258, 65)\n+```\n+\n+This is yet another avatar of lack of robustness of categories over\n+base rings, which will be fixed by #22962 when module categories will\n+be singleton. To get the ball rolling for #18700 which is otherwise\n+ready, this ticket provides a quick workaround which should be robust\n+enough for now.\n+\n+\n+## Detailed analysis\n+\n+Recall that\n+\n+- categories are endowed with a total order which is used to ensure\n+  that the Method Resolution Orders chosen by Python are always\n+  consistent. This total order shall refine the subcategory relation.\n+  This is achieved by assigning a comparison key to each category\n+  according to the order in which they are created.\n+\n+- To make the total order more reproducible from one session to the\n+  other, the first piece of the comparison key is given by a bit array\n+  of flags which are set according to whether the category is a\n+  subcategory of some \"atom categories\": `FacadeSets`, `FiniteSets`, ...\n+\n+- To avoid creating many copies of the same hierarchy of classes,\n+  parametrized categories may share their parent/element/... classes,\n+  and therefore the same comparison key.\n+\n+  In the case at hand, depending on the order in which categories were\n+  created, the assumption of refining the subcategory relation got\n+  broken (I still need to analyze this precisely):\n+  `Modules(GF(3)).FiniteDimensional()` got a key smaller than its\n+  super category `AdditiveGroup().Finite()`\n+\n+This risk will vanish by itself when module categories will be\n+singleton. In the mean time, adding \"Modules\" to the list of atom\n+categories guarantee that `AdditiveGroups().Finite()` gets a strictly\n+smaller key.\n \n \n Comment: 1\n``````\n",
    "created_at": "2017-05-15T16:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430844",
    "user": "https://github.com/tscrim"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,58 @@
+#18700 implements a new category `AdditiveGroups.Finite`. Without
+further change, this triggered the following doctest failure:
+
+```
+sage: K = simplicial_complexes.Simplex(2)
+sage: H = Hom(K,K)
+sage: id = H.identity()
+sage: id.induced_homology_morphism(GF(13)).base_ring()
+Traceback (most recent call last)
+.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()
+    936                     heads[j] = X
+    937                     tailset = tailsets[j]
+--> 938                     tailset.remove(key(X))
+    939                 else:
+    940                     del heads[j]
+
+KeyError: (258, 65)
+```
+
+This is yet another avatar of lack of robustness of categories over
+base rings, which will be fixed by #22962 when module categories will
+be singleton. To get the ball rolling for #18700 which is otherwise
+ready, this ticket provides a quick workaround which should be robust
+enough for now.
+
+
+## Detailed analysis
+
+Recall that
+
+- categories are endowed with a total order which is used to ensure
+  that the Method Resolution Orders chosen by Python are always
+  consistent. This total order shall refine the subcategory relation.
+  This is achieved by assigning a comparison key to each category
+  according to the order in which they are created.
+
+- To make the total order more reproducible from one session to the
+  other, the first piece of the comparison key is given by a bit array
+  of flags which are set according to whether the category is a
+  subcategory of some "atom categories": `FacadeSets`, `FiniteSets`, ...
+
+- To avoid creating many copies of the same hierarchy of classes,
+  parametrized categories may share their parent/element/... classes,
+  and therefore the same comparison key.
+
+  In the case at hand, depending on the order in which categories were
+  created, the assumption of refining the subcategory relation got
+  broken (I still need to analyze this precisely):
+  `Modules(GF(3)).FiniteDimensional()` got a key smaller than its
+  super category `AdditiveGroup().Finite()`
+
+This risk will vanish by itself when module categories will be
+singleton. In the mean time, adding "Modules" to the list of atom
+categories guarantee that `AdditiveGroups().Finite()` gets a strictly
+smaller key.
 
 
 Comment: 1
``````




---

archive/issue_comments_430845.json:
```json
{
    "body": "<a id='comment:6'></a>Okay, I think I understand why this change is needed. Did you manage to track down the detail you mentioned in comment:3?",
    "created_at": "2017-05-15T16:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430845",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>Okay, I think I understand why this change is needed. Did you manage to track down the detail you mentioned in comment:3?



---

archive/issue_comments_430846.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,71 @@\n+Finite dimensional modules over a finite field are known to Sage to be finite:\n+\n+```\n+    sage: Modules(GF(3)).FiniteDimensional().is_subcategory(Sets().Finite())\n+    True\n+```\n+\n+However this piece of knowledge was ignored if a\n+base ring category instead of a base ring was passed to `Modules`:\n+\n+```\n+    sage: Modules(Field().Finite()).FiniteDimensional().is_subcategory(Sets().Finite())\n+    True\n+```\n+\n+This ticket fixes this.\n+\n+## Comments\n+\n+This is yet another avatar of the current lack of robustness of\n+categories over base rings. With #20962 which will make module\n+categories singletons, this kind of inconsistency won't be possible\n+anymore.\n+\n+This issue was discovered while tracking a bug in #18700 which\n+implemented a new category `AdditiveGroups.Finite`, which triggered\n+the following doctest failure:\n+\n+```\n+sage: K = simplicial_complexes.Simplex(2)\n+sage: H = Hom(K,K)\n+sage: id = H.identity()\n+sage: id.induced_homology_morphism(GF(13)).base_ring()\n+Traceback (most recent call last)\n+.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()\n+    936                     heads[j] = X\n+    937                     tailset = tailsets[j]\n+--> 938                     tailset.remove(key(X))\n+    939                 else:\n+    940                     del heads[j]\n+\n+KeyError: (258, 65)\n+```\n+\n+## Detailed analysis\n+\n+Recall that:\n+\n+- categories are endowed with a total order which is used to ensure\n+  that the Method Resolution Orders chosen by Python are always\n+  consistent. This total order shall refine the subcategory relation.\n+  This is achieved by assigning a comparison key to each category\n+  according to the order in which they are created (and some further\n+  data)\n+\n+- To avoid creating many copies of the same hierarchy of classes,\n+  parametrized categories may share their parent/element/... classes,\n+  and therefore the same comparison key.\n+\n+In the case at hand,\n+`C1=Modules(Fields().Finite().FiniteDimensional()` was created first.\n+Since it was not a subcategory of `A=AdditiveGroups().Finite()`, there\n+was no constraint on their relative comparison keys; it then turned\n+out that `C` was assigned a comparison key smaller than that of `A`.\n+\n+Later on, when `C2=Modules(GF(3)).FiniteDimensional()` got created, it\n+got the same comparison key as `C1` while simultaneously deriving from\n+`A`, breaking the assumption.\n \n \n Comment: 1\n``````\n",
    "created_at": "2017-05-15T22:26:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430846",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,71 @@
+Finite dimensional modules over a finite field are known to Sage to be finite:
+
+```
+    sage: Modules(GF(3)).FiniteDimensional().is_subcategory(Sets().Finite())
+    True
+```
+
+However this piece of knowledge was ignored if a
+base ring category instead of a base ring was passed to `Modules`:
+
+```
+    sage: Modules(Field().Finite()).FiniteDimensional().is_subcategory(Sets().Finite())
+    True
+```
+
+This ticket fixes this.
+
+## Comments
+
+This is yet another avatar of the current lack of robustness of
+categories over base rings. With #20962 which will make module
+categories singletons, this kind of inconsistency won't be possible
+anymore.
+
+This issue was discovered while tracking a bug in #18700 which
+implemented a new category `AdditiveGroups.Finite`, which triggered
+the following doctest failure:
+
+```
+sage: K = simplicial_complexes.Simplex(2)
+sage: H = Hom(K,K)
+sage: id = H.identity()
+sage: id.induced_homology_morphism(GF(13)).base_ring()
+Traceback (most recent call last)
+.../opt/sage-git2/src/sage/misc/c3_controlled.pyx in sage.misc.c3_controlled.C3_sorted_merge (/opt/sage-git2/src/build/cythonized/sage/misc/c3_controlled.c:5151)()
+    936                     heads[j] = X
+    937                     tailset = tailsets[j]
+--> 938                     tailset.remove(key(X))
+    939                 else:
+    940                     del heads[j]
+
+KeyError: (258, 65)
+```
+
+## Detailed analysis
+
+Recall that:
+
+- categories are endowed with a total order which is used to ensure
+  that the Method Resolution Orders chosen by Python are always
+  consistent. This total order shall refine the subcategory relation.
+  This is achieved by assigning a comparison key to each category
+  according to the order in which they are created (and some further
+  data)
+
+- To avoid creating many copies of the same hierarchy of classes,
+  parametrized categories may share their parent/element/... classes,
+  and therefore the same comparison key.
+
+In the case at hand,
+`C1=Modules(Fields().Finite().FiniteDimensional()` was created first.
+Since it was not a subcategory of `A=AdditiveGroups().Finite()`, there
+was no constraint on their relative comparison keys; it then turned
+out that `C` was assigned a comparison key smaller than that of `A`.
+
+Later on, when `C2=Modules(GF(3)).FiniteDimensional()` got created, it
+got the same comparison key as `C1` while simultaneously deriving from
+`A`, breaking the assumption.
 
 
 Comment: 1
``````




---

archive/issue_comments_430847.json:
```json
{
    "body": "Changing commit from \"bc94ce675b1b3c380c1aef09cd036f9c41dacef4\" to \"70e23f4c5f769dd6ce8dc9502e8ecfdb5f5ff15e\"",
    "created_at": "2017-05-15T22:30:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430847",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "bc94ce675b1b3c380c1aef09cd036f9c41dacef4" to "70e23f4c5f769dd6ce8dc9502e8ecfdb5f5ff15e"



---

archive/issue_comments_430848.json:
```json
{
    "body": "<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-05-15T22:30:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430848",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_430849.json:
```json
{
    "body": "Changing commit from \"70e23f4c5f769dd6ce8dc9502e8ecfdb5f5ff15e\" to \"fc766203eaecbbf86767571c68dc569a02b2582c\"",
    "created_at": "2017-05-16T01:55:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430849",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "70e23f4c5f769dd6ce8dc9502e8ecfdb5f5ff15e" to "fc766203eaecbbf86767571c68dc569a02b2582c"



---

archive/issue_comments_430850.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-05-16T01:55:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430850",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_430851.json:
```json
{
    "body": "<a id='comment:10'></a>My analysis was actually incorrect. The culprit really was in the categories, not the infrastructure, and is fixed now. The infrastructure just made it easy to screw up and hard to track. This later point should be fixed with #22962.\n\nAll long tests pass.",
    "created_at": "2017-05-16T01:58:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430851",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:10'></a>My analysis was actually incorrect. The culprit really was in the categories, not the infrastructure, and is fixed now. The infrastructure just made it easy to screw up and hard to track. This later point should be fixed with #22962.

All long tests pass.



---

archive/issue_comments_430852.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2017-05-16T01:58:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430852",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_430853.json:
```json
{
    "body": "<a id='comment:12'></a>I'll now rebase #18700 on top of this one.",
    "created_at": "2017-05-16T01:59:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430853",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:12'></a>I'll now rebase #18700 on top of this one.



---

archive/issue_comments_430854.json:
```json
{
    "body": "<a id='comment:13'></a>Somehow this change and why it wasn't working seems like something we should have realized sooner. I don't think this check is done elsewhere. Positive review.",
    "created_at": "2017-05-16T03:24:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430854",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:13'></a>Somehow this change and why it wasn't working seems like something we should have realized sooner. I don't think this check is done elsewhere. Positive review.



---

archive/issue_comments_430855.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-05-16T03:24:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430855",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_430856.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Travis Scrimshaw\"",
    "created_at": "2017-05-16T03:24:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430856",
    "user": "https://github.com/tscrim"
}
```

Changing reviewer from "" to "Travis Scrimshaw"



---

archive/issue_comments_430857.json:
```json
{
    "body": "Changing author from \"\" to \"Nicolas M. Thi\u00e9ry\"",
    "created_at": "2017-05-16T03:24:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430857",
    "user": "https://github.com/tscrim"
}
```

Changing author from "" to "Nicolas M. ThiÃ©ry"



---

archive/issue_comments_430858.json:
```json
{
    "body": "<a id='comment:14'></a>Thanks for the review!\n\nI had done a quick search for other `extra_super_categories` where similar checks, and indeed did not find any.",
    "created_at": "2017-05-16T03:52:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430858",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:14'></a>Thanks for the review!

I had done a quick search for other `extra_super_categories` where similar checks, and indeed did not find any.



---

archive/issue_comments_430859.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-05-20T20:07:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430859",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_059588.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-05-20T20:07:40Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23000#event-59588"
}
```



---

archive/issue_comments_430860.json:
```json
{
    "body": "Changing branch from \"u/nthiery/add_trivial__additivegroups_finite__category__and_workaround_mro_issue\" to \"fc766203eaecbbf86767571c68dc569a02b2582c\"",
    "created_at": "2017-05-20T20:07:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23000",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23000#issuecomment-430860",
    "user": "https://github.com/vbraun"
}
```

Changing branch from "u/nthiery/add_trivial__additivegroups_finite__category__and_workaround_mro_issue" to "fc766203eaecbbf86767571c68dc569a02b2582c"
