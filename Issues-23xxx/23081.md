# Issue 23081: Matchings in multigraphs

archive/issues_022844.json:
```json
{
    "body": "Enabling the graph matching method to work with multiple edges turned on.\n\nOnce this is sorted, I will create another ticket for bipartite matchings.\n\nCC:  @dcoudert @tscrim\n\nKeywords: matching\n\nReviewer: Travis Scrimshaw, David Coudert\n\nAuthor: Zach Gershkoff\n\nBranch: 19bf18cf5ab6f6bb932974aace55082cea0b719e\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/23081\n\n",
    "closed_at": "2017-06-13T06:51:19Z",
    "created_at": "2017-05-25T23:35:46Z",
    "labels": [
        "component: graph theory",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Matchings in multigraphs",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23081",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```
Enabling the graph matching method to work with multiple edges turned on.

Once this is sorted, I will create another ticket for bipartite matchings.

CC:  @dcoudert @tscrim

Keywords: matching

Reviewer: Travis Scrimshaw, David Coudert

Author: Zach Gershkoff

Branch: 19bf18cf5ab6f6bb932974aace55082cea0b719e

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/23081





---

archive/issue_comments_319076.json:
```json
{
    "body": "Changing priority from major to minor.",
    "created_at": "2017-05-26T23:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319076",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

Changing priority from major to minor.



---

archive/issue_comments_319077.json:
```json
{
    "body": "Changing keywords from \"\" to \"matching\".",
    "created_at": "2017-05-26T23:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319077",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

Changing keywords from "" to "matching".



---

archive/issue_comments_319078.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to graph theory.",
    "created_at": "2017-05-26T23:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319078",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

Changing component from PLEASE CHANGE to graph theory.



---

archive/issue_comments_319079.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2017-05-26T23:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319079",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_319080.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2017-05-26T23:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319080",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_319081.json:
```json
{
    "body": "<a id='comment:2'></a>My initial attempt was to build a new list of edges to spare the expense of creating a new graph, but when I saw how complicated that would be because of all the methods and data structures associated with the graph (an edge list, an edge iterator, a dictionary with vertex pairs as keys and edge labels as values), I decided to keep it simple, and I reset my earlier commits.\n\nIt works now, but it's a little inconsistent, and I'm not sure how to best resolve it. The problem is when the set of edge labels is a mix of other types. For simple graphs G, if an edge label is not in RR, the weight of that edge is set to `1`. Otherwise the label is used as the edge weight. (Incidentally, I need to go back to bipartite matchings and make it act like this too.) If G allows multiple edges, however, `G.allow_multiple_edges(False, keep_label='max')` will directly compare the labels of parallel edges and keep the highest one *without* first setting the weight of strings or `None` to `1`.\n\nThe solution I'm considering is to modify the code of `allow_multiple_edges` so it assigns edges a weight before comparing them, the way `matching` does now. However, this seems like it could be too broad of a change. Another solution is to trust the user to make their edge labels consistent before trying to take a weighted matching. I don't know if that is in line with the [SageMath](SageMath) design philosphy.\n\n---\nNew commits:",
    "created_at": "2017-05-26T23:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319081",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

<a id='comment:2'></a>My initial attempt was to build a new list of edges to spare the expense of creating a new graph, but when I saw how complicated that would be because of all the methods and data structures associated with the graph (an edge list, an edge iterator, a dictionary with vertex pairs as keys and edge labels as values), I decided to keep it simple, and I reset my earlier commits.

It works now, but it's a little inconsistent, and I'm not sure how to best resolve it. The problem is when the set of edge labels is a mix of other types. For simple graphs G, if an edge label is not in RR, the weight of that edge is set to `1`. Otherwise the label is used as the edge weight. (Incidentally, I need to go back to bipartite matchings and make it act like this too.) If G allows multiple edges, however, `G.allow_multiple_edges(False, keep_label='max')` will directly compare the labels of parallel edges and keep the highest one *without* first setting the weight of strings or `None` to `1`.

The solution I'm considering is to modify the code of `allow_multiple_edges` so it assigns edges a weight before comparing them, the way `matching` does now. However, this seems like it could be too broad of a change. Another solution is to trust the user to make their edge labels consistent before trying to take a weighted matching. I don't know if that is in line with the [SageMath](SageMath) design philosphy.

---
New commits:



---

archive/issue_comments_319082.json:
```json
{
    "body": "<a id='comment:4'></a>Working with loops, multiple edges and weights is a mess. The behavior and the terminology (`use_edge_labels` or `by_weights` or etc.) should be unified. For instance, you can pass a `weight_function` to `shortest_path`. This is convenient and forces the user to be careful with the kind of labels and how to use it. Such improvement is however a hard task.\n\nA problem with loops:\nI don't no why the matching method uses `self._scream_if_not_simple(allow_loops=True)`. It is not documented and it causes the following issue:\n\n```\nsage: G = Graph([(0,0),(0,1),(1,1)], loops=True)\nsage: G.matching(algorithm='LP')\n[(0, 0, None), (1, 1, None)]\nsage: G.matching(algorithm='Edmonds')\n[(0, 1, None)]\n```\n\n\nNow, if you want to make the matching method work with multiple edges, you can avoid a copy of the graph as follows. This is certainly not the most elegant method, but it's working.\n\n```\n        #self._scream_if_not_simple(allow_loops=True)\n        from sage.rings.real_mpfr import RR\n        def weight(x):\n            if x in RR:\n                return x\n            else:\n                return 1\n\n        def reorder(u, v):\n            if u < v:\n                return u, v\n            else:\n                return v, u\n\n        W = dict()\n        for u,v,l in self.edge_iterator():\n            u, v = reorder(u, v)\n            if u is v:\n                continue\n            if use_edge_labels:\n                l = weight(l)\n            if not (u, v) in W or ( (u, v) in W and use_edge_labels and W[u, v] < l ):\n                W[u, v] = l\n\n        if algorithm == \"Edmonds\":\n            import networkx\n            g = networkx.Graph()\n            if use_edge_labels:\n                for u, v in W:\n                    g.add_edge(u, v, attr_dict={\"weight\": W[u, v]})\n            else:\n                for u, v in W:\n                    g.add_edge(u, v)\n            d = networkx.max_weight_matching(g)\n            if value_only:\n                if use_edge_labels:\n                    return sum(W[u, v] for u, v in six.iteritems(d) if u < v)\n                else:\n                    return Integer(len(d) // 2)\n            else:\n                return [(u, v, W[u, v]) for u, v in six.iteritems(d) if u < v]\n\n        elif algorithm == \"LP\":\n            from sage.numerical.mip import MixedIntegerLinearProgram\n            # returns the weight of an edge considering it may not be\n            # weighted ...\n            p = MixedIntegerLinearProgram(maximization=True, solver=solver)\n            b = p.new_variable(binary=True)\n            if use_edge_labels:\n                p.set_objective( p.sum( W[u, v] * b[u, v] for u, v in W ) )\n            else:\n                p.set_objective( p.sum( b[u, v] for u, v in W ) )\n            # for any vertex v, there is at most one edge incident to v in\n            # the maximum matching\n            for v in g.vertex_iterator():\n                p.add_constraint(\n                    p.sum(b[reorder(u, v)]\n                          for u in self.neighbors(v) if u != v), max=1)\n            if value_only:\n                if use_edge_labels:\n                    return p.solve(objective_only=True, log=verbose)\n                else:\n                    return Integer(round(p.solve(objective_only=True, log=verbose)))\n            else:\n                p.solve(log=verbose)\n                b = p.get_values(b)\n                return [(u, v, W[u, v]) for u, v in W if b[u, v] == 1]\n\n        else:\n            raise ValueError('algorithm must be set to either \"Edmonds\" or \"LP\"')\n```",
    "created_at": "2017-05-27T09:23:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319082",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:4'></a>Working with loops, multiple edges and weights is a mess. The behavior and the terminology (`use_edge_labels` or `by_weights` or etc.) should be unified. For instance, you can pass a `weight_function` to `shortest_path`. This is convenient and forces the user to be careful with the kind of labels and how to use it. Such improvement is however a hard task.

A problem with loops:
I don't no why the matching method uses `self._scream_if_not_simple(allow_loops=True)`. It is not documented and it causes the following issue:

```
sage: G = Graph([(0,0),(0,1),(1,1)], loops=True)
sage: G.matching(algorithm='LP')
[(0, 0, None), (1, 1, None)]
sage: G.matching(algorithm='Edmonds')
[(0, 1, None)]
```


Now, if you want to make the matching method work with multiple edges, you can avoid a copy of the graph as follows. This is certainly not the most elegant method, but it's working.

```
        #self._scream_if_not_simple(allow_loops=True)
        from sage.rings.real_mpfr import RR
        def weight(x):
            if x in RR:
                return x
            else:
                return 1

        def reorder(u, v):
            if u < v:
                return u, v
            else:
                return v, u

        W = dict()
        for u,v,l in self.edge_iterator():
            u, v = reorder(u, v)
            if u is v:
                continue
            if use_edge_labels:
                l = weight(l)
            if not (u, v) in W or ( (u, v) in W and use_edge_labels and W[u, v] < l ):
                W[u, v] = l

        if algorithm == "Edmonds":
            import networkx
            g = networkx.Graph()
            if use_edge_labels:
                for u, v in W:
                    g.add_edge(u, v, attr_dict={"weight": W[u, v]})
            else:
                for u, v in W:
                    g.add_edge(u, v)
            d = networkx.max_weight_matching(g)
            if value_only:
                if use_edge_labels:
                    return sum(W[u, v] for u, v in six.iteritems(d) if u < v)
                else:
                    return Integer(len(d) // 2)
            else:
                return [(u, v, W[u, v]) for u, v in six.iteritems(d) if u < v]

        elif algorithm == "LP":
            from sage.numerical.mip import MixedIntegerLinearProgram
            # returns the weight of an edge considering it may not be
            # weighted ...
            p = MixedIntegerLinearProgram(maximization=True, solver=solver)
            b = p.new_variable(binary=True)
            if use_edge_labels:
                p.set_objective( p.sum( W[u, v] * b[u, v] for u, v in W ) )
            else:
                p.set_objective( p.sum( b[u, v] for u, v in W ) )
            # for any vertex v, there is at most one edge incident to v in
            # the maximum matching
            for v in g.vertex_iterator():
                p.add_constraint(
                    p.sum(b[reorder(u, v)]
                          for u in self.neighbors(v) if u != v), max=1)
            if value_only:
                if use_edge_labels:
                    return p.solve(objective_only=True, log=verbose)
                else:
                    return Integer(round(p.solve(objective_only=True, log=verbose)))
            else:
                p.solve(log=verbose)
                b = p.get_values(b)
                return [(u, v, W[u, v]) for u, v in W if b[u, v] == 1]

        else:
            raise ValueError('algorithm must be set to either "Edmonds" or "LP"')
```



---

archive/issue_comments_319083.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-05-30T01:46:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319083",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319084.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2017-05-30T01:54:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319084",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_319085.json:
```json
{
    "body": "<a id='comment:6'></a>I like that implementation-- I wish I had kept mine so I could compare it, but it does seem to be much faster than copying the graph. I took out the `reorder` method because it seems that the edges are stored in an ordered way. (That is, they were ordered in all the tests I did, and digging through the sagemath and networkx code didn't prove otherwise.) The `LP` method wasn't working correctly, but it seems to be working after I put in the business about `min(u,v), max(u,v)`.\n\nI also added a test for computing the matching of a multigraph, and it passes the doctest fine.\n\nI'm a little mystified as to why some of the changes I did seemed to make it slower. David's algorithm ran at a time comparable to the old one, but around when I added the `L` dictionary, the run time practically doubled. Perhaps there were background programs on my computer that started consuming more resources.",
    "created_at": "2017-05-30T01:54:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319085",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

<a id='comment:6'></a>I like that implementation-- I wish I had kept mine so I could compare it, but it does seem to be much faster than copying the graph. I took out the `reorder` method because it seems that the edges are stored in an ordered way. (That is, they were ordered in all the tests I did, and digging through the sagemath and networkx code didn't prove otherwise.) The `LP` method wasn't working correctly, but it seems to be working after I put in the business about `min(u,v), max(u,v)`.

I also added a test for computing the matching of a multigraph, and it passes the doctest fine.

I'm a little mystified as to why some of the changes I did seemed to make it slower. David's algorithm ran at a time comparable to the old one, but around when I added the `L` dictionary, the run time practically doubled. Perhaps there were background programs on my computer that started consuming more resources.



---

archive/issue_comments_319086.json:
```json
{
    "body": "<a id='comment:7'></a>I should clarify that the doctests for graphs passed. When I tried everything, there were some problems, but the problem is likely with my installation and not with changes to `graph.py`.",
    "created_at": "2017-05-30T02:27:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319086",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

<a id='comment:7'></a>I should clarify that the doctests for graphs passed. When I tried everything, there were some problems, but the problem is likely with my installation and not with changes to `graph.py`.



---

archive/issue_comments_319087.json:
```json
{
    "body": "<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-06-02T21:26:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319087",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319088.json:
```json
{
    "body": "<a id='comment:9'></a>In the LP, the only place where you need to use `min(u,v), max(u,v)` is `p.sum(b[min(u, v), max(u,v)] for u in self.neighbors(v) if u != v), max=1)`. Here you have no guarantee that `u < v`, but each time you use `for u, v in W`,  we know that `u < v`.\n\nYou can remove the line `#self._scream_if_not_simple(allow_loops=True)`.",
    "created_at": "2017-06-03T11:14:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319088",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:9'></a>In the LP, the only place where you need to use `min(u,v), max(u,v)` is `p.sum(b[min(u, v), max(u,v)] for u in self.neighbors(v) if u != v), max=1)`. Here you have no guarantee that `u < v`, but each time you use `for u, v in W`,  we know that `u < v`.

You can remove the line `#self._scream_if_not_simple(allow_loops=True)`.



---

archive/issue_comments_319089.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-06-05T00:01:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319089",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319090.json:
```json
{
    "body": "<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-06-05T00:24:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319090",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319091.json:
```json
{
    "body": "<a id='comment:12'></a>In the case, I've put the reorder method back.\n\nI do think this ticket needs to be completed (or loops need to be disallowed, because they caused false results as you've pointed out) but I'm still confused as to how my changes have made it so much slower.",
    "created_at": "2017-06-05T00:28:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319091",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

<a id='comment:12'></a>In the case, I've put the reorder method back.

I do think this ticket needs to be completed (or loops need to be disallowed, because they caused false results as you've pointed out) but I'm still confused as to how my changes have made it so much slower.



---

archive/issue_comments_319092.json:
```json
{
    "body": "<a id='comment:13'></a>Actually, I think I see it now. I'll fix it shortly.",
    "created_at": "2017-06-05T00:31:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319092",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

<a id='comment:13'></a>Actually, I think I see it now. I'll fix it shortly.



---

archive/issue_comments_319093.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-06-05T00:53:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319093",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319094.json:
```json
{
    "body": "<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-06-05T00:55:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319094",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319095.json:
```json
{
    "body": "<a id='comment:16'></a>While combining the dictionaries does somewhat reduce the memory footprint, the extra step of extracting from a list is probably adding up as you probably surmised. However, the extra Python calls to `reorder` might also have a detrimental effect compared to the essentially system call of `min`. It might be worthwhile to run it through `%lprun` (and `%prun`) and see what lines in particular are taking the time. Do you have a particular medium sized example that is non-trivial but not-to-big that you are testing with?",
    "created_at": "2017-06-05T01:53:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319095",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>While combining the dictionaries does somewhat reduce the memory footprint, the extra step of extracting from a list is probably adding up as you probably surmised. However, the extra Python calls to `reorder` might also have a detrimental effect compared to the essentially system call of `min`. It might be worthwhile to run it through `%lprun` (and `%prun`) and see what lines in particular are taking the time. Do you have a particular medium sized example that is non-trivial but not-to-big that you are testing with?



---

archive/issue_comments_319096.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-06-05T02:16:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319096",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_319097.json:
```json
{
    "body": "<a id='comment:18'></a>When I changed it to only call `weight(l)` if `allow_edge_labels` is `True`, it sped up significantly.\n\nThe example I've been using for a baseline reading is `G = graphs.CompleteGraph(500)`, which takes 1.05 seconds with `timeit()` on the develop branch, and 1.15 seconds on this branch. When I do `G.matching(allow_edge_labels=True)`, both branches take about 2.25 seconds. Since you suggested a non-trivial one, I tried `H = graphs.GeneralizedPetersenGraph(500,5)`. This one takes about 400ms on either branch regardless of edge labels.",
    "created_at": "2017-06-05T02:29:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319097",
    "user": "https://trac.sagemath.org/admin/accounts/users/zgershkoff"
}
```

<a id='comment:18'></a>When I changed it to only call `weight(l)` if `allow_edge_labels` is `True`, it sped up significantly.

The example I've been using for a baseline reading is `G = graphs.CompleteGraph(500)`, which takes 1.05 seconds with `timeit()` on the develop branch, and 1.15 seconds on this branch. When I do `G.matching(allow_edge_labels=True)`, both branches take about 2.25 seconds. Since you suggested a non-trivial one, I tried `H = graphs.GeneralizedPetersenGraph(500,5)`. This one takes about 400ms on either branch regardless of edge labels.



---

archive/issue_comments_319098.json:
```json
{
    "body": "<a id='comment:19'></a>On\n\n```\nsage: H = graphs.GeneralizedPetersenGraph(600,8)\nsage: %lprun -f H.matching H.matching(use_edge_labels=True)\n```\nover 99% of the time is spent on the call to networkx:\n\n```\n  4418         1      6946726 6946726.0     99.4              d = networkx.max_weight_matching(g)\n```\nSimilarly when `use_edge_labels=False`. When I do `algorithm='LP'`, similar amount of time is spent doing the LP stuff.\n\nConclusion: There is almost no speed to be gained except on really small graphs. So there is nothing else to really optimize out, at least by these examples.",
    "created_at": "2017-06-05T05:34:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319098",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:19'></a>On

```
sage: H = graphs.GeneralizedPetersenGraph(600,8)
sage: %lprun -f H.matching H.matching(use_edge_labels=True)
```
over 99% of the time is spent on the call to networkx:

```
  4418         1      6946726 6946726.0     99.4              d = networkx.max_weight_matching(g)
```
Similarly when `use_edge_labels=False`. When I do `algorithm='LP'`, similar amount of time is spent doing the LP stuff.

Conclusion: There is almost no speed to be gained except on really small graphs. So there is nothing else to really optimize out, at least by these examples.



---

archive/issue_comments_319099.json:
```json
{
    "body": "<a id='comment:20'></a>The patch is now good to go (passes all tests, etc.). I agree with Travis that it would be a lot of work to save small computation time.",
    "created_at": "2017-06-05T08:26:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319099",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:20'></a>The patch is now good to go (passes all tests, etc.). I agree with Travis that it would be a lot of work to save small computation time.



---

archive/issue_comments_319100.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-06-05T08:26:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319100",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_059732.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-06-13T06:51:19Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23081#event-59732"
}
```



---

archive/issue_comments_319101.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-06-13T06:51:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23081",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23081#issuecomment-319101",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
