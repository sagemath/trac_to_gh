# Issue 23877: allow bypassing checks in setpartition

archive/issues_023640.json:
```json
{
    "body": "This patch makes the `check` argument of `SetPartition` useful:\n\n```\nsage: SetPartition([[2,3],[1]], check=False)\n{{1}, {2, 3}}\nsage: SetPartition([[2,3],[1,2]], check=False)\n{{1, 2}, {2, 3}}\n\nsage: l = [D.to_noncrossing_partition() for D in DyckWords(8)]\nsage: timeit(\"[SetPartition(p, check=False) for p in l]\", number=1, repeat=1)\n1 loops, best of 1: 959 ms per loop\nsage: timeit(\"[SetPartition(p, check=True) for p in l]\", number=1, repeat=1)\n1 loops, best of 1: 2.15 s per loop\n```\n\nBranch/Commit: bd5b2f87fee0f1635bc0ca3c9d930c99fcf8ae67\n\nReviewer: Travis Scrimshaw\n\nAuthor: Martin Rubey\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/23877\n\n",
    "closed_at": "2017-10-01T00:19:01Z",
    "created_at": "2017-09-18T07:26:56Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "allow bypassing checks in setpartition",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23877",
    "user": "https://github.com/mantepse"
}
```
This patch makes the `check` argument of `SetPartition` useful:

```
sage: SetPartition([[2,3],[1]], check=False)
{{1}, {2, 3}}
sage: SetPartition([[2,3],[1,2]], check=False)
{{1, 2}, {2, 3}}

sage: l = [D.to_noncrossing_partition() for D in DyckWords(8)]
sage: timeit("[SetPartition(p, check=False) for p in l]", number=1, repeat=1)
1 loops, best of 1: 959 ms per loop
sage: timeit("[SetPartition(p, check=True) for p in l]", number=1, repeat=1)
1 loops, best of 1: 2.15 s per loop
```

Branch/Commit: bd5b2f87fee0f1635bc0ca3c9d930c99fcf8ae67

Reviewer: Travis Scrimshaw

Author: Martin Rubey

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/23877





---

archive/issue_comments_352427.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,4 +1,17 @@\n+This patch makes the `check` argument of `SetPartition` useful:\n \n+```\n+sage: SetPartition([[2,3],[1]], check=False)\n+{{1}, {2, 3}}\n+sage: SetPartition([[2,3],[1,2]], check=False)\n+{{1, 2}, {2, 3}}\n+\n+sage: l = [D.to_noncrossing_partition() for D in DyckWords(8)]\n+sage: timeit(\"[SetPartition(p, check=False) for p in l]\", number=1, repeat=1)\n+1 loops, best of 1: 959 ms per loop\n+sage: timeit(\"[SetPartition(p, check=True) for p in l]\", number=1, repeat=1)\n+1 loops, best of 1: 2.15 s per loop\n+```\n \n Comment: 1\n \n```\n",
    "created_at": "2017-09-18T07:33:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352427",
    "user": "https://github.com/mantepse"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,4 +1,17 @@
+This patch makes the `check` argument of `SetPartition` useful:
 
+```
+sage: SetPartition([[2,3],[1]], check=False)
+{{1}, {2, 3}}
+sage: SetPartition([[2,3],[1,2]], check=False)
+{{1, 2}, {2, 3}}
+
+sage: l = [D.to_noncrossing_partition() for D in DyckWords(8)]
+sage: timeit("[SetPartition(p, check=False) for p in l]", number=1, repeat=1)
+1 loops, best of 1: 959 ms per loop
+sage: timeit("[SetPartition(p, check=True) for p in l]", number=1, repeat=1)
+1 loops, best of 1: 2.15 s per loop
+```
 
 Comment: 1
 
```




---

archive/issue_comments_352428.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2017-09-18T07:33:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352428",
    "user": "https://github.com/mantepse"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_352429.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2017-09-18T07:33:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352429",
    "user": "https://github.com/mantepse"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_352430.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-09-18T07:33:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352430",
    "user": "https://github.com/mantepse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_352431.json:
```json
{
    "body": "<a id='comment:3'></a>I must admit that I am not at all happy with the speedup, but most of the time is now spent in creating the sets, more precisely, in `Set_object.__init__`.  I am not sure whether this is necessary:\n\n```\nsage: l = [D.to_noncrossing_partition() for D in DyckWords(9)]\nsage: %prun [SetPartition(p, check=False) for p in l]\n         388963 function calls in 5.327 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    24310    3.269    0.000    4.352    0.000 set.py:255(__init__)\n    24310    0.726    0.000    0.726    0.000 {hasattr}\n    24310    0.232    0.000    0.245    0.000 dynamic_class.py:127(dynamic_class)\n    24310    0.206    0.000    4.797    0.000 set.py:88(Set)\n    24310    0.173    0.000    4.525    0.000 set.py:733(__init__)\n    97240    0.134    0.000    0.134    0.000 {isinstance}\n        1    0.109    0.109    5.327    5.327 <string>:1(<module>)\n     4862    0.105    0.000    0.239    0.000 {sorted}\n     4862    0.063    0.000    4.859    0.001 {map}\n    24310    0.057    0.000    0.070    0.000 set.py:864(set)\n     4862    0.053    0.000    5.151    0.001 set_partition.py:134(__init__)\n    24310    0.052    0.000    0.134    0.000 set.py:796(__iter__)\n    24310    0.048    0.000    0.774    0.000 sets_cat.py:950(_element_constructor_)\n     4862    0.044    0.000    5.217    0.001 set_partition.py:119(__classcall_private__)\n     4862    0.022    0.000    0.022    0.000 set_partition.py:1328(__classcall_private__)\n    24310    0.013    0.000    0.013    0.000 {iter}\n    24310    0.012    0.000    0.012    0.000 set.py:696(object)\n    24310    0.009    0.000    0.009    0.000 {sage.rings.integer.is_Integer}\n        1    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```",
    "created_at": "2017-09-18T07:37:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352431",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:3'></a>I must admit that I am not at all happy with the speedup, but most of the time is now spent in creating the sets, more precisely, in `Set_object.__init__`.  I am not sure whether this is necessary:

```
sage: l = [D.to_noncrossing_partition() for D in DyckWords(9)]
sage: %prun [SetPartition(p, check=False) for p in l]
         388963 function calls in 5.327 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    24310    3.269    0.000    4.352    0.000 set.py:255(__init__)
    24310    0.726    0.000    0.726    0.000 {hasattr}
    24310    0.232    0.000    0.245    0.000 dynamic_class.py:127(dynamic_class)
    24310    0.206    0.000    4.797    0.000 set.py:88(Set)
    24310    0.173    0.000    4.525    0.000 set.py:733(__init__)
    97240    0.134    0.000    0.134    0.000 {isinstance}
        1    0.109    0.109    5.327    5.327 <string>:1(<module>)
     4862    0.105    0.000    0.239    0.000 {sorted}
     4862    0.063    0.000    4.859    0.001 {map}
    24310    0.057    0.000    0.070    0.000 set.py:864(set)
     4862    0.053    0.000    5.151    0.001 set_partition.py:134(__init__)
    24310    0.052    0.000    0.134    0.000 set.py:796(__iter__)
    24310    0.048    0.000    0.774    0.000 sets_cat.py:950(_element_constructor_)
     4862    0.044    0.000    5.217    0.001 set_partition.py:119(__classcall_private__)
     4862    0.022    0.000    0.022    0.000 set_partition.py:1328(__classcall_private__)
    24310    0.013    0.000    0.013    0.000 {iter}
    24310    0.012    0.000    0.012    0.000 set.py:696(object)
    24310    0.009    0.000    0.009    0.000 {sage.rings.integer.is_Integer}
        1    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```



---

archive/issue_comments_352432.json:
```json
{
    "body": "<a id='comment:4'></a>Here is the profile for `Set_object.__init__` - I don't know what `Parent.__init__` is doing:\n\n```\nsage: %lprun -f sage.sets.set.Set_object.__init__ [SetPartition(p, check=False) for p in l]\nTimer unit: 1e-06 s\n\nTotal time: 4.54096 s\nFile: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/sets/set.py\nFunction: __init__ at line 255\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   255                                               def __init__(self, X, category=None):\n   ...\n   278     24310       365197     15.0      8.0          from sage.rings.integer import is_Integer\n   279     24310       141019      5.8      3.1          if isinstance(X, integer_types) or is_Integer(X):\n   280                                                       # The coercion model will try to call Set_object(0)\n   281                                                       raise ValueError('underlying object cannot be an integer')\n   282                                           \n   283     24310        52419      2.2      1.2          if category is None:\n   284                                                       category = Sets()\n   285     24310      3897130    160.3     85.8          Parent.__init__(self, category=category)\n   286     24310        85191      3.5      1.9          self.__object = X\nsage: \n```",
    "created_at": "2017-09-18T07:40:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352432",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:4'></a>Here is the profile for `Set_object.__init__` - I don't know what `Parent.__init__` is doing:

```
sage: %lprun -f sage.sets.set.Set_object.__init__ [SetPartition(p, check=False) for p in l]
Timer unit: 1e-06 s

Total time: 4.54096 s
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/sets/set.py
Function: __init__ at line 255

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   255                                               def __init__(self, X, category=None):
   ...
   278     24310       365197     15.0      8.0          from sage.rings.integer import is_Integer
   279     24310       141019      5.8      3.1          if isinstance(X, integer_types) or is_Integer(X):
   280                                                       # The coercion model will try to call Set_object(0)
   281                                                       raise ValueError('underlying object cannot be an integer')
   282                                           
   283     24310        52419      2.2      1.2          if category is None:
   284                                                       category = Sets()
   285     24310      3897130    160.3     85.8          Parent.__init__(self, category=category)
   286     24310        85191      3.5      1.9          self.__object = X
sage: 
```



---

archive/issue_comments_352433.json:
```json
{
    "body": "<a id='comment:5'></a>If I understand your example correctly, you are creating many parents of a very similar kind. Problem: `Parent.__init__` involves `self._init_category_(category)`, which involves creating the parent class. Granted, it is a dynamic class and thus cached. Looking up the dynamic class in the cache involves formatting a string. It is very little time per parent. But perhaps that's the culprit? The lines\n\n```\n    24310    3.269    0.000    4.352    0.000 set.py:255(__init__)\n    24310    0.726    0.000    0.726    0.000 {hasattr}\n    24310    0.232    0.000    0.245    0.000 dynamic_class.py:127(dynamic_class)\n```\nseem to indicate it. By the way, can you tell me where `hasattr` is called? It contributes a substantial amount of time, but I cannot locate it.\n\nIt could be a solution to create *one* parent, store its class, and then create all new SetPartition instances using `.__new__()` and imitating the other actions of `__init__` (assigning the category to the attribute `._category`, assigning to the attribute `._base` if there is any, assign the generator names if there are any, set the element constructor). Don't forget to take into account `__init_extra__`. And of course it is under the assumption that all parents belong to the same category, otherwise the parent classes were different.",
    "created_at": "2017-09-18T08:49:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352433",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>If I understand your example correctly, you are creating many parents of a very similar kind. Problem: `Parent.__init__` involves `self._init_category_(category)`, which involves creating the parent class. Granted, it is a dynamic class and thus cached. Looking up the dynamic class in the cache involves formatting a string. It is very little time per parent. But perhaps that's the culprit? The lines

```
    24310    3.269    0.000    4.352    0.000 set.py:255(__init__)
    24310    0.726    0.000    0.726    0.000 {hasattr}
    24310    0.232    0.000    0.245    0.000 dynamic_class.py:127(dynamic_class)
```
seem to indicate it. By the way, can you tell me where `hasattr` is called? It contributes a substantial amount of time, but I cannot locate it.

It could be a solution to create *one* parent, store its class, and then create all new SetPartition instances using `.__new__()` and imitating the other actions of `__init__` (assigning the category to the attribute `._category`, assigning to the attribute `._base` if there is any, assign the generator names if there are any, set the element constructor). Don't forget to take into account `__init_extra__`. And of course it is under the assumption that all parents belong to the same category, otherwise the parent classes were different.



---

archive/issue_comments_352434.json:
```json
{
    "body": "<a id='comment:6'></a>I tried to use `trace(\"SetPartition([[2,3],[1]], check=False)\")` but after few steps trace showed me \n**nothing**! That has never occurred before. Explanation: After the first \"s\" in the following session, I was hitting return repeatedly, thus, trace should keep stepping through the code.\n\n```\nsage: trace(\"SetPartition([[2,3],[1]], check=False)\")\n> <string>(1)<module>()\n\nipdb> \nipdb> s\n--Call--\n> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(119)__classcall_private__()\n    117         Set partitions\n    118     \"\"\"\n--> 119     @staticmethod\n    120     def __classcall_private__(cls, parts, check=True):\n    121         \"\"\"\n\nipdb> \n> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(131)__classcall_private__()\n    129             Set partitions\n    130         \"\"\"\n--> 131         P = SetPartitions()\n    132         return P.element_class(P, parts)\n    133 \n\nipdb> \n--Call--\n> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(1328)__classcall_private__()\n   1326     - :wikipedia:`Partition_of_a_set`\n   1327     \"\"\"\n-> 1328     @staticmethod\n   1329     def __classcall_private__(cls, s=None, part=None):\n   1330         \"\"\"\n\nipdb> \nipdb> \nipdb> \nipdb> \nipdb> \nipdb> \nipdb> quit\n```\n\nSo, I still don't know in what place \"hasattr\" is used.",
    "created_at": "2017-09-18T09:39:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352434",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>I tried to use `trace("SetPartition([[2,3],[1]], check=False)")` but after few steps trace showed me 
**nothing**! That has never occurred before. Explanation: After the first "s" in the following session, I was hitting return repeatedly, thus, trace should keep stepping through the code.

```
sage: trace("SetPartition([[2,3],[1]], check=False)")
> <string>(1)<module>()

ipdb> 
ipdb> s
--Call--
> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(119)__classcall_private__()
    117         Set partitions
    118     """
--> 119     @staticmethod
    120     def __classcall_private__(cls, parts, check=True):
    121         """

ipdb> 
> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(131)__classcall_private__()
    129             Set partitions
    130         """
--> 131         P = SetPartitions()
    132         return P.element_class(P, parts)
    133 

ipdb> 
--Call--
> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(1328)__classcall_private__()
   1326     - :wikipedia:`Partition_of_a_set`
   1327     """
-> 1328     @staticmethod
   1329     def __classcall_private__(cls, s=None, part=None):
   1330         """

ipdb> 
ipdb> 
ipdb> 
ipdb> 
ipdb> 
ipdb> 
ipdb> quit
```

So, I still don't know in what place "hasattr" is used.



---

archive/issue_comments_352435.json:
```json
{
    "body": "<a id='comment:7'></a>Possibly the tracer is confused because `s` denotes a local variable in `__classcall_private__`.  Using `step` instead I find that `hasattr` is used in `ParentMethods._element_constructor_` (line 974 of `sets_cat.py`).\n\nBut maybe it's better to profile just `Set([1,2,3])`?",
    "created_at": "2017-09-18T10:31:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352435",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:7'></a>Possibly the tracer is confused because `s` denotes a local variable in `__classcall_private__`.  Using `step` instead I find that `hasattr` is used in `ParentMethods._element_constructor_` (line 974 of `sets_cat.py`).

But maybe it's better to profile just `Set([1,2,3])`?



---

archive/issue_comments_352436.json:
```json
{
    "body": "<a id='comment:8'></a>Indeed, the profile of just calling `Set` looks very similar:\n\n```\nsage: S = Subsets(range(10))\nsage: l = [list(S.random_element()) for i in range(1000)]\nsage: %prun [Set(b) for b in l]\n         11003 function calls in 0.643 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     1000    0.471    0.000    0.583    0.001 set.py:255(__init__)\n     1000    0.076    0.000    0.076    0.000 {hasattr}\n     1000    0.023    0.000    0.024    0.000 dynamic_class.py:127(dynamic_class)\n     1000    0.022    0.000    0.631    0.001 set.py:88(Set)\n     1000    0.019    0.000    0.602    0.001 set.py:733(__init__)\n     4000    0.014    0.000    0.014    0.000 {isinstance}\n        1    0.012    0.012    0.643    0.643 <string>:1(<module>)\n     1000    0.005    0.000    0.081    0.000 sets_cat.py:950(_element_constructor_)\n     1000    0.001    0.000    0.001    0.000 {sage.rings.integer.is_Integer}\n        1    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```",
    "created_at": "2017-09-18T10:40:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352436",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:8'></a>Indeed, the profile of just calling `Set` looks very similar:

```
sage: S = Subsets(range(10))
sage: l = [list(S.random_element()) for i in range(1000)]
sage: %prun [Set(b) for b in l]
         11003 function calls in 0.643 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1000    0.471    0.000    0.583    0.001 set.py:255(__init__)
     1000    0.076    0.000    0.076    0.000 {hasattr}
     1000    0.023    0.000    0.024    0.000 dynamic_class.py:127(dynamic_class)
     1000    0.022    0.000    0.631    0.001 set.py:88(Set)
     1000    0.019    0.000    0.602    0.001 set.py:733(__init__)
     4000    0.014    0.000    0.014    0.000 {isinstance}
        1    0.012    0.012    0.643    0.643 <string>:1(<module>)
     1000    0.005    0.000    0.081    0.000 sets_cat.py:950(_element_constructor_)
     1000    0.001    0.000    0.001    0.000 {sage.rings.integer.is_Integer}
        1    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```



---

archive/issue_comments_352437.json:
```json
{
    "body": "<a id='comment:9'></a>Thank you. I suppose the comment right in front of the parent method should be taken into account: We should find a way to simplify the logic.\n\nCurrently, we have for Parent:\n\n```python\n    def __init__(...):\n        ...\n        if element_constructor is None:\n            self._set_element_constructor()\n        else:\n            self._element_constructor = element_constructor\n            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)\n```\nand\n\n```python\n    def _set_element_constructor(self):\n        \"\"\"\n        This function is used in translating from the old to the new coercion model.\n        \"\"\"\n        try: #if hasattr(self, '_element_constructor_'):\n            _element_constructor_ = self._element_constructor_\n        except (AttributeError, TypeError):\n            # Remark: A TypeError can actually occur;\n            # it is a possible reason for \"hasattr\" to return False\n            return\n        assert callable(_element_constructor_)\n        self._element_constructor = _element_constructor_\n        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)\n```\nand in the parent methods of `Sets()` we have\n\n```python\n        @lazy_attribute\n        def _element_constructor_(self):\n            if hasattr(self, \"element_class\"):\n                return self._element_constructor_from_element_class\n            else:\n                return NotImplemented\n```\nThat's quite contorted. `__init__` calls `set_element_constructor` (after initialisation of the category framework, by the way), which tries whether self has the attribute `_element_constructor_`. By virtue of the category framework, self actually has `_element_constructor_ `; if it has this attribute, then it assigns this attribute to an attribute `_element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.\n\nBizarre. I guess it would be a good idea to open a ticket for it.\n\nBy the way: It is simply not true that `_set_element_constructor` \"is used in translating from the old to the new coercion model\". It is called unless the argument `element_constructor` is passed to `Parent.__init__`, which I guess is very rarely the case.",
    "created_at": "2017-09-18T11:02:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352437",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>Thank you. I suppose the comment right in front of the parent method should be taken into account: We should find a way to simplify the logic.

Currently, we have for Parent:

```python
    def __init__(...):
        ...
        if element_constructor is None:
            self._set_element_constructor()
        else:
            self._element_constructor = element_constructor
            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)
```
and

```python
    def _set_element_constructor(self):
        """
        This function is used in translating from the old to the new coercion model.
        """
        try: #if hasattr(self, '_element_constructor_'):
            _element_constructor_ = self._element_constructor_
        except (AttributeError, TypeError):
            # Remark: A TypeError can actually occur;
            # it is a possible reason for "hasattr" to return False
            return
        assert callable(_element_constructor_)
        self._element_constructor = _element_constructor_
        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
```
and in the parent methods of `Sets()` we have

```python
        @lazy_attribute
        def _element_constructor_(self):
            if hasattr(self, "element_class"):
                return self._element_constructor_from_element_class
            else:
                return NotImplemented
```
That's quite contorted. `__init__` calls `set_element_constructor` (after initialisation of the category framework, by the way), which tries whether self has the attribute `_element_constructor_`. By virtue of the category framework, self actually has `_element_constructor_ `; if it has this attribute, then it assigns this attribute to an attribute `_element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.

Bizarre. I guess it would be a good idea to open a ticket for it.

By the way: It is simply not true that `_set_element_constructor` "is used in translating from the old to the new coercion model". It is called unless the argument `element_constructor` is passed to `Parent.__init__`, which I guess is very rarely the case.



---

archive/issue_comments_352438.json:
```json
{
    "body": "<a id='comment:10'></a>I'm afraid this is now going beyond my skills.  I wouldn't even know how to call the ticket...\n\nI noticed the following in `Parent._init_category_` - no idea whether it's relevant:\n\n```\n    def _init_category_(self, category):\n        \"\"\"\n        Initialize the category framework\n\n        Most parents initialize their category upon construction, and\n        this is the recommended behavior. For example, this happens\n        when the constructor calls :meth:`Parent.__init__` directly or\n        indirectly. However, some parents defer this for performance\n        reasons. For example,\n        :mod:`sage.matrix.matrix_space.MatrixSpace` does not.\n\n```\n\nFinally, I just prepared a profile of `dynamic_class`, maybe that's helpful, too:\n\n```\nFile: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/structure/dynamic_class.py\nFunction: dynamic_class at line 127\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   127                                           def dynamic_class(name, bases, cls=None, reduction=None, doccls=None,\n   128                                                             prepend_cls_bases=True, cache=True):\n   ...\n   311     10000        90562      9.1     19.0      bases = tuple(bases)\n   312                                               #assert(len(bases) > 0 )\n   313     10000        46540      4.7      9.8      try:\n   314     10000        70064      7.0     14.7          name = str(name)\n   315                                               except UnicodeEncodeError:\n   316                                                   pass\n   317     10000        64202      6.4     13.5      assert(isinstance(name, str))\n   318                                               #    assert(cls is None or issubtype(type(cls), type) or type(cls) is classobj)\n   319     10000        48504      4.9     10.2      if cache is True:\n   320     10000       157171     15.7     32.9          return dynamic_class_internal(name, bases, cls, reduction, doccls, prepend_cls_bases)\n   321                                               elif cache is False:\n   322                                                   # bypass the cached method\n   323                                                   return dynamic_class_internal.f(name, bases, cls, reduction, doccls, prepend_cls_bases)\n   324                                               else: # cache = \"ignore_reduction\"\n   325                                                   result = dynamic_class_internal(name, bases, cls, False, doccls, prepend_cls_bases)\n   326                                                   if result._reduction is False:\n   327                                                       result._reduction = reduction\n   328                                                   return result\n```",
    "created_at": "2017-09-18T11:10:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352438",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:10'></a>I'm afraid this is now going beyond my skills.  I wouldn't even know how to call the ticket...

I noticed the following in `Parent._init_category_` - no idea whether it's relevant:

```
    def _init_category_(self, category):
        """
        Initialize the category framework

        Most parents initialize their category upon construction, and
        this is the recommended behavior. For example, this happens
        when the constructor calls :meth:`Parent.__init__` directly or
        indirectly. However, some parents defer this for performance
        reasons. For example,
        :mod:`sage.matrix.matrix_space.MatrixSpace` does not.

```

Finally, I just prepared a profile of `dynamic_class`, maybe that's helpful, too:

```
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/structure/dynamic_class.py
Function: dynamic_class at line 127

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   127                                           def dynamic_class(name, bases, cls=None, reduction=None, doccls=None,
   128                                                             prepend_cls_bases=True, cache=True):
   ...
   311     10000        90562      9.1     19.0      bases = tuple(bases)
   312                                               #assert(len(bases) > 0 )
   313     10000        46540      4.7      9.8      try:
   314     10000        70064      7.0     14.7          name = str(name)
   315                                               except UnicodeEncodeError:
   316                                                   pass
   317     10000        64202      6.4     13.5      assert(isinstance(name, str))
   318                                               #    assert(cls is None or issubtype(type(cls), type) or type(cls) is classobj)
   319     10000        48504      4.9     10.2      if cache is True:
   320     10000       157171     15.7     32.9          return dynamic_class_internal(name, bases, cls, reduction, doccls, prepend_cls_bases)
   321                                               elif cache is False:
   322                                                   # bypass the cached method
   323                                                   return dynamic_class_internal.f(name, bases, cls, reduction, doccls, prepend_cls_bases)
   324                                               else: # cache = "ignore_reduction"
   325                                                   result = dynamic_class_internal(name, bases, cls, False, doccls, prepend_cls_bases)
   326                                                   if result._reduction is False:
   327                                                       result._reduction = reduction
   328                                                   return result
```



---

archive/issue_comments_352439.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:10 mantepse]:\n> I'm afraid this is now going beyond my skills.  I wouldn't even know how to call the ticket...\n\n\nThat would be for a different ticket. Actually I'd be happy with the speedup you are getting here (50%).",
    "created_at": "2017-09-18T11:16:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352439",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>Replying to [comment:10 mantepse]:
> I'm afraid this is now going beyond my skills.  I wouldn't even know how to call the ticket...


That would be for a different ticket. Actually I'd be happy with the speedup you are getting here (50%).



---

archive/issue_comments_352440.json:
```json
{
    "body": "<a id='comment:12'></a>OK, could you open the other ticket?  I'll then make #23873 depend of that other ticket...",
    "created_at": "2017-09-18T11:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352440",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:12'></a>OK, could you open the other ticket?  I'll then make #23873 depend of that other ticket...



---

archive/issue_comments_352441.json:
```json
{
    "body": "<a id='comment:13'></a>Simon opened #23880 following up the discussion above.",
    "created_at": "2017-09-18T12:12:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352441",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:13'></a>Simon opened #23880 following up the discussion above.



---

archive/issue_comments_352442.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-09-18T13:15:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352442",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352443.json:
```json
{
    "body": "<a id='comment:15'></a>I added the same thing to `_element_constructor_` (the removal of the other case is because it would never happen because of the coercion framework). If my changes look good, then positive review.\n\n---\nNew commits:",
    "created_at": "2017-09-29T02:09:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352443",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:15'></a>I added the same thing to `_element_constructor_` (the removal of the other case is because it would never happen because of the coercion framework). If my changes look good, then positive review.

---
New commits:



---

archive/issue_comments_352444.json:
```json
{
    "body": "<a id='comment:16'></a>Thank you!",
    "created_at": "2017-09-29T07:37:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352444",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:16'></a>Thank you!



---

archive/issue_comments_352445.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-09-29T07:37:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352445",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_060824.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-10-01T00:19:01Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23877#event-60824"
}
```



---

archive/issue_comments_352446.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-10-01T00:19:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23877",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23877#issuecomment-352446",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
