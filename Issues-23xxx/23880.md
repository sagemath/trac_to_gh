# Issue 23880: Untangle customisation of element creation

archive/issues_023643.json:
```json
{
    "body": "Currently, we have in `Parent.__init__`:\n\n```python\n    def __init__(...):\n        ...\n        if element_constructor is None:\n            self._set_element_constructor()\n        else:\n            self._element_constructor = element_constructor\n            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)\n```\nand `Parent._set_element_constructor`:\n\n```python\n    def _set_element_constructor(self):\n        \"\"\"\n        This function is used in translating from the old to the new coercion model.\n        \"\"\"\n        try: #if hasattr(self, '_element_constructor_'):\n            _element_constructor_ = self._element_constructor_\n        except (AttributeError, TypeError):\n            # Remark: A TypeError can actually occur;\n            # it is a possible reason for \"hasattr\" to return False\n            return\n        assert callable(_element_constructor_)\n        self._element_constructor = _element_constructor_\n        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)\n```\nand in the parent methods of `Sets()` we have\n\n```python\n        @lazy_attribute\n        def _element_constructor_(self):\n            if hasattr(self, \"element_class\"):\n                return self._element_constructor_from_element_class\n            else:\n                return NotImplemented\n```\nThat's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.\n\nThen, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.\n\nThat's bizarre and should be simplified.\n\nCurrently, it seems that there are too many ways to customize element creation: Overriding `Parent.__call__` (very bad), overriding `_element_constructor`, overriding `_element_constructor_`, overriding `element_class`, definition `.Element`. I suppose some of these ways just exist for historic reasons and should be removed.\n\nSee: #23881, #23917, #24348, #24363, #26879\n\nCC:  @nthiery @koffie @mantepse @tscrim\n\nKeywords: element constructor\n\nStatus: new\n\nIssue created by migration from https://trac.sagemath.org/ticket/23880\n\n",
    "created_at": "2017-09-18T11:29:05Z",
    "labels": [
        "component: coercion"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Untangle customisation of element creation",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23880",
    "user": "https://github.com/simon-king-jena"
}
```
Currently, we have in `Parent.__init__`:

```python
    def __init__(...):
        ...
        if element_constructor is None:
            self._set_element_constructor()
        else:
            self._element_constructor = element_constructor
            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)
```
and `Parent._set_element_constructor`:

```python
    def _set_element_constructor(self):
        """
        This function is used in translating from the old to the new coercion model.
        """
        try: #if hasattr(self, '_element_constructor_'):
            _element_constructor_ = self._element_constructor_
        except (AttributeError, TypeError):
            # Remark: A TypeError can actually occur;
            # it is a possible reason for "hasattr" to return False
            return
        assert callable(_element_constructor_)
        self._element_constructor = _element_constructor_
        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
```
and in the parent methods of `Sets()` we have

```python
        @lazy_attribute
        def _element_constructor_(self):
            if hasattr(self, "element_class"):
                return self._element_constructor_from_element_class
            else:
                return NotImplemented
```
That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.

Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.

That's bizarre and should be simplified.

Currently, it seems that there are too many ways to customize element creation: Overriding `Parent.__call__` (very bad), overriding `_element_constructor`, overriding `_element_constructor_`, overriding `element_class`, definition `.Element`. I suppose some of these ways just exist for historic reasons and should be removed.

See: #23881, #23917, #24348, #24363, #26879

CC:  @nthiery @koffie @mantepse @tscrim

Keywords: element constructor

Status: new

Issue created by migration from https://trac.sagemath.org/ticket/23880





---

archive/issue_comments_352467.json:
```json
{
    "body": "<a id='comment:1'></a>By the way: It is simply not true that _set_element_constructor \"is used in translating from the old to the new coercion model\". It is called unless the argument element_constructor is passed to `Parent.__init__`, which I guess is very rarely the case.",
    "created_at": "2017-09-18T11:29:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352467",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>By the way: It is simply not true that _set_element_constructor "is used in translating from the old to the new coercion model". It is called unless the argument element_constructor is passed to `Parent.__init__`, which I guess is very rarely the case.



---

archive/issue_comments_352468.json:
```json
{
    "body": "<a id='comment:2'></a>As a first step, one could define a copy of `Sets.ParentMethods._element_constructor_` directly for `Parent`. Or actually remove it from the category framework: If an object belongs to the category of sets, it is supposed to be implemented as a sub-class of `Parent`, not just of `CategoryObject`.",
    "created_at": "2017-09-18T11:34:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352468",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>As a first step, one could define a copy of `Sets.ParentMethods._element_constructor_` directly for `Parent`. Or actually remove it from the category framework: If an object belongs to the category of sets, it is supposed to be implemented as a sub-class of `Parent`, not just of `CategoryObject`.



---

archive/issue_comments_352469.json:
```json
{
    "body": "<a id='comment:3'></a>Just pointing out that defining `class Element` or `element_class` will not work in all cases since a few parents (homsets are a good example) allow multiple element classes.",
    "created_at": "2017-09-18T11:37:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352469",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>Just pointing out that defining `class Element` or `element_class` will not work in all cases since a few parents (homsets are a good example) allow multiple element classes.



---

archive/issue_comments_352470.json:
```json
{
    "body": "<a id='comment:4'></a>Regarding\n\n```\nself._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)\n```\nI always found this a bad hack. One simplification would be to always require passing the parent.",
    "created_at": "2017-09-18T11:50:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352470",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>Regarding

```
self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
```
I always found this a bad hack. One simplification would be to always require passing the parent.



---

archive/issue_comments_352471.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [comment:3 jdemeyer]:\n> Just pointing out that defining `class Element` or `element_class` will not work in all cases since a few parents (homsets are a good example) allow multiple element classes.\n\n\nOf course we have to discuss what customization we shall allow. The minimum we want to have is this:\n\n- If `_element_constructor_` is defined by the user, then it will be used for element construction. If multiple element classes are involved (homsets), then that's what one has to do.\n\n- If `.Element` is assigned and the category framework is invoked, then `element_class` should be available as well and it should be a possible way to implement element creation.\n\nBut I am not so sure whether we should allow to override the default implementation of `element_class`. If we could agree that defining `_element_constructor_` or `.Element` are the **only** customisation hooks, we would already have a substantial simplification.",
    "created_at": "2017-09-18T11:50:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352471",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>Replying to [comment:3 jdemeyer]:
> Just pointing out that defining `class Element` or `element_class` will not work in all cases since a few parents (homsets are a good example) allow multiple element classes.


Of course we have to discuss what customization we shall allow. The minimum we want to have is this:

- If `_element_constructor_` is defined by the user, then it will be used for element construction. If multiple element classes are involved (homsets), then that's what one has to do.

- If `.Element` is assigned and the category framework is invoked, then `element_class` should be available as well and it should be a possible way to implement element creation.

But I am not so sure whether we should allow to override the default implementation of `element_class`. If we could agree that defining `_element_constructor_` or `.Element` are the **only** customisation hooks, we would already have a substantial simplification.



---

archive/issue_comments_352472.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:4 jdemeyer]:\n> Regarding\n> \n> ```\n> self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)\n> ```\n> I always found this a bad hack. One simplification would be to always require passing the parent.\n\n\nIt depends. If you allow, as one way of customisation, to pass `element_constructor` as an argument of `Parent.__init__` or to `populate_coercion_lists` (which, I believe, should not be the allowed!), then you need that check sooner or later.",
    "created_at": "2017-09-18T11:54:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352472",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>Replying to [comment:4 jdemeyer]:
> Regarding
> 
> ```
> self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
> ```
> I always found this a bad hack. One simplification would be to always require passing the parent.


It depends. If you allow, as one way of customisation, to pass `element_constructor` as an argument of `Parent.__init__` or to `populate_coercion_lists` (which, I believe, should not be the allowed!), then you need that check sooner or later.



---

archive/issue_comments_352473.json:
```json
{
    "body": "<a id='comment:7'></a>Example:\nDo we want this?\n\n```\nsrc/sage/modular/quatalg/brandt.py:        self._populate_coercion_lists_(coerce_list=[self.free_module()], element_constructor=BrandtModuleElement)\n```\nIf it is possible to use the category framework then one should simply assign `Element`. Or one should define `_element_constructor_` by returning an instance of BrandtModuleElement.",
    "created_at": "2017-09-18T11:58:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352473",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>Example:
Do we want this?

```
src/sage/modular/quatalg/brandt.py:        self._populate_coercion_lists_(coerce_list=[self.free_module()], element_constructor=BrandtModuleElement)
```
If it is possible to use the category framework then one should simply assign `Element`. Or one should define `_element_constructor_` by returning an instance of BrandtModuleElement.



---

archive/issue_comments_352474.json:
```json
{
    "body": "<a id='comment:8'></a>I would argue that `Parent._element_constructor` is the way how a `Parent` internally stores how to construct elements. There is nothing wrong with an attribute like that, but it should be considered very private.",
    "created_at": "2017-09-18T12:09:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352474",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>I would argue that `Parent._element_constructor` is the way how a `Parent` internally stores how to construct elements. There is nothing wrong with an attribute like that, but it should be considered very private.



---

archive/issue_comments_352475.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:8 jdemeyer]:\n> I would argue that `Parent._element_constructor` is the way how a `Parent` internally stores how to construct elements. There is nothing wrong with an attribute like that, but it should be considered very private.\n\n\nBut what is `Parent._element_constructor`? It either is a callable that is passed during `Parent.__init__` or `Parent._populate_coercion_lists`, or it is the same as `_element_constructor_`. If we disallowed passing an element constructor as an argument, there would be no difference between the version with and without trailing underscore.\n\nDoes the following scheme make sense to you?\n\n- `_element_constructor` (without trailing underscore) should be removed.\n- There should be a default implementation of `_element_constructor_` for `Parent` (it currently does not exist). As a backup, we might keep a copy in `Sets.ParentMethods`. The default implementation passes the arguments to `self.element_class` and add `parent` to these arguments. It is one hook for customisation.\n- The comment \"This probably should go into Sets().Parent\" should be removed. All objects in the category of sets should be implemented as a subclass of `Parent`. The default implementation of `element_class` should stay as it is, thus, rely on `Element`, which is one hook for customisation (the category used in initialising the parent is another hook). The element class has to accept `parent` as a named argument.\n- Remove `guess_pass_parent`. `self(*args,**kwds)` should (after coercion) call `self._element_constructor_`, and this has the responsibility to pass `self` to whatever class is used for the elements.",
    "created_at": "2017-09-18T12:14:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352475",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>Replying to [comment:8 jdemeyer]:
> I would argue that `Parent._element_constructor` is the way how a `Parent` internally stores how to construct elements. There is nothing wrong with an attribute like that, but it should be considered very private.


But what is `Parent._element_constructor`? It either is a callable that is passed during `Parent.__init__` or `Parent._populate_coercion_lists`, or it is the same as `_element_constructor_`. If we disallowed passing an element constructor as an argument, there would be no difference between the version with and without trailing underscore.

Does the following scheme make sense to you?

- `_element_constructor` (without trailing underscore) should be removed.
- There should be a default implementation of `_element_constructor_` for `Parent` (it currently does not exist). As a backup, we might keep a copy in `Sets.ParentMethods`. The default implementation passes the arguments to `self.element_class` and add `parent` to these arguments. It is one hook for customisation.
- The comment "This probably should go into Sets().Parent" should be removed. All objects in the category of sets should be implemented as a subclass of `Parent`. The default implementation of `element_class` should stay as it is, thus, rely on `Element`, which is one hook for customisation (the category used in initialising the parent is another hook). The element class has to accept `parent` as a named argument.
- Remove `guess_pass_parent`. `self(*args,**kwds)` should (after coercion) call `self._element_constructor_`, and this has the responsibility to pass `self` to whatever class is used for the elements.



---

archive/issue_comments_352476.json:
```json
{
    "body": "<a id='comment:11'></a>Why do you think #23881 is needed?",
    "created_at": "2017-09-18T12:15:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352476",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>Why do you think #23881 is needed?



---

archive/issue_comments_352477.json:
```json
{
    "body": "<a id='comment:12'></a>I was thinking of #23881 as an intermediate step. You could even think of it as an \"exercise\" to understand this stuff better.",
    "created_at": "2017-09-18T12:20:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352477",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:12'></a>I was thinking of #23881 as an intermediate step. You could even think of it as an "exercise" to understand this stuff better.



---

archive/issue_comments_352478.json:
```json
{
    "body": "<a id='comment:13'></a>But if you don't like #23881, I won't insist (but then don't expect much help from me on #23880 either).",
    "created_at": "2017-09-18T12:20:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352478",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:13'></a>But if you don't like #23881, I won't insist (but then don't expect much help from me on #23880 either).



---

archive/issue_comments_352479.json:
```json
{
    "body": "<a id='comment:15'></a>Isn't one of the reasons we have this is because we still have some old-style parents not setting their category lingering around?\n\nAlso, all categories are (currently) subcategories of `Sets` (i.e., are concrete categories), and to be a parent, you have to be in the category of `Sets`. So I removed the \"usually\" in the description.",
    "created_at": "2017-09-19T18:11:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352479",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:15'></a>Isn't one of the reasons we have this is because we still have some old-style parents not setting their category lingering around?

Also, all categories are (currently) subcategories of `Sets` (i.e., are concrete categories), and to be a parent, you have to be in the category of `Sets`. So I removed the "usually" in the description.



---

archive/issue_comments_352480.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -36,7 +36,7 @@\n             else:\n                 return NotImplemented\n ```\n-That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which usually is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.\n+That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.\n \n Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.\n \n```\n",
    "created_at": "2017-09-19T18:11:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352480",
    "user": "https://github.com/tscrim"
}
```

Description changed:
```diff
--- 
+++ 
@@ -36,7 +36,7 @@
             else:
                 return NotImplemented
 ```
-That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which usually is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.
+That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.
 
 Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.
 
```




---

archive/issue_comments_352481.json:
```json
{
    "body": "<a id='comment:16'></a>What do categories have to do with this?",
    "created_at": "2017-09-20T06:57:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352481",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:16'></a>What do categories have to do with this?



---

archive/issue_comments_352482.json:
```json
{
    "body": "<a id='comment:17'></a>Replying to [comment:15 tscrim]:\n> Isn't one of the reasons we have this is because we still have some old-style parents not setting their category lingering around?\n> \n> Also, all categories are (currently) subcategories of `Sets` (i.e., are concrete categories), and to be a parent, you have to be in the category of `Sets`.\n\n\n```\nsage: Objects().is_subcategory(Sets())\nFalse\n```\nThat's why I had it in the description.",
    "created_at": "2017-09-20T07:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352482",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>Replying to [comment:15 tscrim]:
> Isn't one of the reasons we have this is because we still have some old-style parents not setting their category lingering around?
> 
> Also, all categories are (currently) subcategories of `Sets` (i.e., are concrete categories), and to be a parent, you have to be in the category of `Sets`.


```
sage: Objects().is_subcategory(Sets())
False
```
That's why I had it in the description.



---

archive/issue_comments_352483.json:
```json
{
    "body": "<a id='comment:18'></a>I am adding back the dependency on #23881. Even if it's not strictly a dependency, see it at least as a pointer: it contains some discussion and further dependencies.",
    "created_at": "2017-09-20T07:50:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352483",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:18'></a>I am adding back the dependency on #23881. Even if it's not strictly a dependency, see it at least as a pointer: it contains some discussion and further dependencies.



---

archive/issue_comments_352484.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:16 jdemeyer]:\n> What do categories have to do with this?\n\n\nSee description. This ticket is about simplifying the customisation logic of element construction. It seems that the underlying reason for the current contortion is that the current implementation makes it possible to let the category framework be involved.\n\nLet me elaborate on it.\n- One can imagine that it makes sense to provide a generic `_element_constructor_` for some categories.\n- But methods of `Parent` would have precedence over `WhateverCategory.ParentMethods`.\n- Supposedly the above was the reason to *not* implement the most generic `_element_constructor_` in `Parent`: A customisation via categories is only possible if `Parent` does not have a generic implementation.\n\nSo, we have first to answer this question: Do we want that an object gets its element constructor from its category? Currently, the category framework provides `_element_constructor_\" in semigroups, sets and facade_sets. The one from sets belongs (I believe) to Parent. I didn't look at the other two yet. In any case, the current category framework makes little use of that possibility.",
    "created_at": "2017-09-20T08:06:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352484",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>Replying to [comment:16 jdemeyer]:
> What do categories have to do with this?


See description. This ticket is about simplifying the customisation logic of element construction. It seems that the underlying reason for the current contortion is that the current implementation makes it possible to let the category framework be involved.

Let me elaborate on it.
- One can imagine that it makes sense to provide a generic `_element_constructor_` for some categories.
- But methods of `Parent` would have precedence over `WhateverCategory.ParentMethods`.
- Supposedly the above was the reason to *not* implement the most generic `_element_constructor_` in `Parent`: A customisation via categories is only possible if `Parent` does not have a generic implementation.

So, we have first to answer this question: Do we want that an object gets its element constructor from its category? Currently, the category framework provides `_element_constructor_" in semigroups, sets and facade_sets. The one from sets belongs (I believe) to Parent. I didn't look at the other two yet. In any case, the current category framework makes little use of that possibility.



---

archive/issue_comments_352485.json:
```json
{
    "body": "<a id='comment:22'></a>In the ticket description is not mentioned why I opened the ticket. I think it was because of a slowness in parent creation that a user observed. But I cannot find the relevant sage-devel or sage-support thread. Can you help me with that?\n\nIf there is actually no slowness in *parent* creation and all contortion just serves at providing a fast *element* creation (by having a `cdef __create_element` attribute) that is customisable on the level of categories, then perhaps #23881 and related tickets are enough and this ticket is invalid. What do you think?",
    "created_at": "2017-09-20T08:26:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352485",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>In the ticket description is not mentioned why I opened the ticket. I think it was because of a slowness in parent creation that a user observed. But I cannot find the relevant sage-devel or sage-support thread. Can you help me with that?

If there is actually no slowness in *parent* creation and all contortion just serves at providing a fast *element* creation (by having a `cdef __create_element` attribute) that is customisable on the level of categories, then perhaps #23881 and related tickets are enough and this ticket is invalid. What do you think?



---

archive/issue_comments_352486.json:
```json
{
    "body": "<a id='comment:24'></a>Regardless of the reason why you opened the ticket, it's true that the current situation is a mess. I am generally +1 on cleaning things up, even if it serves no higher purpose.",
    "created_at": "2017-09-20T08:32:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352486",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:24'></a>Regardless of the reason why you opened the ticket, it's true that the current situation is a mess. I am generally +1 on cleaning things up, even if it serves no higher purpose.



---

archive/issue_comments_352487.json:
```json
{
    "body": "<a id='comment:26'></a>Replying to [comment:24 jdemeyer]:\n> Regardless of the reason why you opened the ticket, it's true that the current situation is a mess. I am generally +1 on cleaning things up, even if it serves no higher purpose.\n\n\nAgreed. However, if \"cleaning up the mess\" is only possible by making it impossible to customise element creation via categories, then I'd be against it - unless the clean up also implies a speed up.\n\nHence, without an example of a slow parent creation, I would think that #23881 and the other tickets do provide a simplification of the customisation logic and that it is not needed, e.g., to have a default `Parent._element_constructor_`.",
    "created_at": "2017-09-20T08:46:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352487",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>Replying to [comment:24 jdemeyer]:
> Regardless of the reason why you opened the ticket, it's true that the current situation is a mess. I am generally +1 on cleaning things up, even if it serves no higher purpose.


Agreed. However, if "cleaning up the mess" is only possible by making it impossible to customise element creation via categories, then I'd be against it - unless the clean up also implies a speed up.

Hence, without an example of a slow parent creation, I would think that #23881 and the other tickets do provide a simplification of the customisation logic and that it is not needed, e.g., to have a default `Parent._element_constructor_`.



---

archive/issue_comments_352488.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:26 SimonKing]:\n> Hence, without an example of a slow parent creation, I would think that #23881 and the other tickets do provide a simplification of the customisation logic...\n\n\nOr perhaps not. For example, removing the `element_constructor` argument from `Parent.__init__` and `Parent._populate_coercion_lists` is not covered by the other tickets and could be done here. `Parent._element_constructor_` is a different story.",
    "created_at": "2017-09-20T08:49:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352488",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:27'></a>Replying to [comment:26 SimonKing]:
> Hence, without an example of a slow parent creation, I would think that #23881 and the other tickets do provide a simplification of the customisation logic...


Or perhaps not. For example, removing the `element_constructor` argument from `Parent.__init__` and `Parent._populate_coercion_lists` is not covered by the other tickets and could be done here. `Parent._element_constructor_` is a different story.



---

archive/issue_comments_352489.json:
```json
{
    "body": "<a id='comment:28'></a>Replying to [comment:22 SimonKing]:\n> In the ticket description is not mentioned why I opened the ticket. I think it was because of a slowness in parent creation that a user observed. But I cannot find the relevant sage-devel or sage-support thread. Can you help me with that?\n\n\nThat was me (Martin Rubey = mantepse), the slowness I observed is *where the time is spent*in `Set([1,2,3])`, originally in #23873 and, more precisely in #23877#comment:9 and the comments above that.",
    "created_at": "2017-09-20T09:25:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352489",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:28'></a>Replying to [comment:22 SimonKing]:
> In the ticket description is not mentioned why I opened the ticket. I think it was because of a slowness in parent creation that a user observed. But I cannot find the relevant sage-devel or sage-support thread. Can you help me with that?


That was me (Martin Rubey = mantepse), the slowness I observed is *where the time is spent*in `Set([1,2,3])`, originally in #23873 and, more precisely in #23877#comment:9 and the comments above that.



---

archive/issue_comments_352490.json:
```json
{
    "body": "<a id='comment:29'></a>Let me just repeat the (possibly) relevant profiles.  If I read it correctly, almost all the time is spent in `Parent.__init__`.\n\n```\nsage: S = Subsets(range(100))\nsage: l = [list(S.random_element()) for i in range(1000)]\nsage: %prun [Set(b) for b in l]\n         11005 function calls in 0.179 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     1000    0.101    0.000    0.146    0.000 set.py:255(__init__)\n     1000    0.029    0.000    0.029    0.000 {hasattr}\n     1000    0.015    0.000    0.171    0.000 set.py:88(Set)\n     1000    0.010    0.000    0.011    0.000 dynamic_class.py:127(dynamic_class)\n     1000    0.008    0.000    0.153    0.000 set.py:733(__init__)\n        1    0.008    0.008    0.179    0.179 <string>:1(<module>)\n     4000    0.006    0.000    0.006    0.000 {isinstance}\n     1000    0.002    0.000    0.031    0.000 sets_cat.py:950(_element_constructor_)\n     1000    0.000    0.000    0.000    0.000 {sage.rings.integer.is_Integer}\n        3    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n sage: \nsage: %lprun -f sage.sets.set.Set_object.__init__ [Set(b) for b in l]\nTimer unit: 1e-06 s\n\nTotal time: 0.158186 s\nFile: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/sets/set.py\nFunction: __init__ at line 255\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n   255                                               def __init__(self, X, category=None):\n   ...\n   278      1000        18493     18.5     11.7          from sage.rings.integer import is_Integer\n   279      1000         6255      6.3      4.0          if isinstance(X, integer_types) or is_Integer(X):\n   280                                                       # The coercion model will try to call Set_object(0)\n   281                                                       raise ValueError('underlying object cannot be an integer')\n   282                                           \n   283      1000         2248      2.2      1.4          if category is None:\n   284                                                       category = Sets()\n   285      1000       127575    127.6     80.6          Parent.__init__(self, category=category)\n   286      1000         3615      3.6      2.3          self.__object = X\n```",
    "created_at": "2017-09-20T09:33:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352490",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:29'></a>Let me just repeat the (possibly) relevant profiles.  If I read it correctly, almost all the time is spent in `Parent.__init__`.

```
sage: S = Subsets(range(100))
sage: l = [list(S.random_element()) for i in range(1000)]
sage: %prun [Set(b) for b in l]
         11005 function calls in 0.179 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1000    0.101    0.000    0.146    0.000 set.py:255(__init__)
     1000    0.029    0.000    0.029    0.000 {hasattr}
     1000    0.015    0.000    0.171    0.000 set.py:88(Set)
     1000    0.010    0.000    0.011    0.000 dynamic_class.py:127(dynamic_class)
     1000    0.008    0.000    0.153    0.000 set.py:733(__init__)
        1    0.008    0.008    0.179    0.179 <string>:1(<module>)
     4000    0.006    0.000    0.006    0.000 {isinstance}
     1000    0.002    0.000    0.031    0.000 sets_cat.py:950(_element_constructor_)
     1000    0.000    0.000    0.000    0.000 {sage.rings.integer.is_Integer}
        3    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
 sage: 
sage: %lprun -f sage.sets.set.Set_object.__init__ [Set(b) for b in l]
Timer unit: 1e-06 s

Total time: 0.158186 s
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/sets/set.py
Function: __init__ at line 255

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   255                                               def __init__(self, X, category=None):
   ...
   278      1000        18493     18.5     11.7          from sage.rings.integer import is_Integer
   279      1000         6255      6.3      4.0          if isinstance(X, integer_types) or is_Integer(X):
   280                                                       # The coercion model will try to call Set_object(0)
   281                                                       raise ValueError('underlying object cannot be an integer')
   282                                           
   283      1000         2248      2.2      1.4          if category is None:
   284                                                       category = Sets()
   285      1000       127575    127.6     80.6          Parent.__init__(self, category=category)
   286      1000         3615      3.6      2.3          self.__object = X
```



---

archive/issue_comments_352491.json:
```json
{
    "body": "<a id='comment:30'></a>Various tickets need review: #23884, #23899, #23900, #23902, #23903.\n\nThese are all very simple tickets, each changing one very specific thing.",
    "created_at": "2017-09-20T09:38:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352491",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:30'></a>Various tickets need review: #23884, #23899, #23900, #23902, #23903.

These are all very simple tickets, each changing one very specific thing.



---

archive/issue_comments_352492.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,4 +1,50 @@\n+Currently, we have in `Parent.__init__`:\n \n+```python\n+    def __init__(...):\n+        ...\n+        if element_constructor is None:\n+            self._set_element_constructor()\n+        else:\n+            self._element_constructor = element_constructor\n+            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)\n+```\n+and `Parent._set_element_constructor`:\n+\n+```python\n+    def _set_element_constructor(self):\n+        \"\"\"\n+        This function is used in translating from the old to the new coercion model.\n+        \"\"\"\n+        try: #if hasattr(self, '_element_constructor_'):\n+            _element_constructor_ = self._element_constructor_\n+        except (AttributeError, TypeError):\n+            # Remark: A TypeError can actually occur;\n+            # it is a possible reason for \"hasattr\" to return False\n+            return\n+        assert callable(_element_constructor_)\n+        self._element_constructor = _element_constructor_\n+        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)\n+```\n+and in the parent methods of `Sets()` we have\n+\n+```python\n+        @lazy_attribute\n+        def _element_constructor_(self):\n+            if hasattr(self, \"element_class\"):\n+                return self._element_constructor_from_element_class\n+            else:\n+                return NotImplemented\n+```\n+That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.\n+\n+Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.\n+\n+That's bizarre and should be simplified.\n+\n+Currently, it seems that there are too many ways to customize element creation: Overriding `Parent.__call__` (very bad), overriding `_element_constructor`, overriding `_element_constructor_`, overriding `element_class`, definition `.Element`. I suppose some of these ways just exist for historic reasons and should be removed.\n+\n+See: #23881, #23917, #24348, #24363\n \n Comment: 1\n \n```\n",
    "created_at": "2017-12-10T17:37:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352492",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,4 +1,50 @@
+Currently, we have in `Parent.__init__`:
 
+```python
+    def __init__(...):
+        ...
+        if element_constructor is None:
+            self._set_element_constructor()
+        else:
+            self._element_constructor = element_constructor
+            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)
+```
+and `Parent._set_element_constructor`:
+
+```python
+    def _set_element_constructor(self):
+        """
+        This function is used in translating from the old to the new coercion model.
+        """
+        try: #if hasattr(self, '_element_constructor_'):
+            _element_constructor_ = self._element_constructor_
+        except (AttributeError, TypeError):
+            # Remark: A TypeError can actually occur;
+            # it is a possible reason for "hasattr" to return False
+            return
+        assert callable(_element_constructor_)
+        self._element_constructor = _element_constructor_
+        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
+```
+and in the parent methods of `Sets()` we have
+
+```python
+        @lazy_attribute
+        def _element_constructor_(self):
+            if hasattr(self, "element_class"):
+                return self._element_constructor_from_element_class
+            else:
+                return NotImplemented
+```
+That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.
+
+Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.
+
+That's bizarre and should be simplified.
+
+Currently, it seems that there are too many ways to customize element creation: Overriding `Parent.__call__` (very bad), overriding `_element_constructor`, overriding `_element_constructor_`, overriding `element_class`, definition `.Element`. I suppose some of these ways just exist for historic reasons and should be removed.
+
+See: #23881, #23917, #24348, #24363
 
 Comment: 1
 
```




---

archive/issue_comments_352493.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,4 +1,50 @@\n+Currently, we have in `Parent.__init__`:\n \n+```python\n+    def __init__(...):\n+        ...\n+        if element_constructor is None:\n+            self._set_element_constructor()\n+        else:\n+            self._element_constructor = element_constructor\n+            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)\n+```\n+and `Parent._set_element_constructor`:\n+\n+```python\n+    def _set_element_constructor(self):\n+        \"\"\"\n+        This function is used in translating from the old to the new coercion model.\n+        \"\"\"\n+        try: #if hasattr(self, '_element_constructor_'):\n+            _element_constructor_ = self._element_constructor_\n+        except (AttributeError, TypeError):\n+            # Remark: A TypeError can actually occur;\n+            # it is a possible reason for \"hasattr\" to return False\n+            return\n+        assert callable(_element_constructor_)\n+        self._element_constructor = _element_constructor_\n+        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)\n+```\n+and in the parent methods of `Sets()` we have\n+\n+```python\n+        @lazy_attribute\n+        def _element_constructor_(self):\n+            if hasattr(self, \"element_class\"):\n+                return self._element_constructor_from_element_class\n+            else:\n+                return NotImplemented\n+```\n+That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.\n+\n+Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.\n+\n+That's bizarre and should be simplified.\n+\n+Currently, it seems that there are too many ways to customize element creation: Overriding `Parent.__call__` (very bad), overriding `_element_constructor`, overriding `_element_constructor_`, overriding `element_class`, definition `.Element`. I suppose some of these ways just exist for historic reasons and should be removed.\n+\n+See: #23881, #23917, #24348, #24363, #26879\n \n Comment: 1\n \n```\n",
    "created_at": "2018-12-11T21:45:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23880#issuecomment-352493",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,4 +1,50 @@
+Currently, we have in `Parent.__init__`:
 
+```python
+    def __init__(...):
+        ...
+        if element_constructor is None:
+            self._set_element_constructor()
+        else:
+            self._element_constructor = element_constructor
+            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)
+```
+and `Parent._set_element_constructor`:
+
+```python
+    def _set_element_constructor(self):
+        """
+        This function is used in translating from the old to the new coercion model.
+        """
+        try: #if hasattr(self, '_element_constructor_'):
+            _element_constructor_ = self._element_constructor_
+        except (AttributeError, TypeError):
+            # Remark: A TypeError can actually occur;
+            # it is a possible reason for "hasattr" to return False
+            return
+        assert callable(_element_constructor_)
+        self._element_constructor = _element_constructor_
+        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
+```
+and in the parent methods of `Sets()` we have
+
+```python
+        @lazy_attribute
+        def _element_constructor_(self):
+            if hasattr(self, "element_class"):
+                return self._element_constructor_from_element_class
+            else:
+                return NotImplemented
+```
+That's quite contorted. `__init__` calls `set_element_constructor`. If the category framework is used, then at that point we have initialised the category, which is a sub-category of `Sets()`. Therefore, by virtue of the category framework, self actually has `_element_constructor_ `, from `Sets.ParentMethods`.
+
+Then, `_set_element_constructor` assigns `self._element_constructor_` to `self._element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.
+
+That's bizarre and should be simplified.
+
+Currently, it seems that there are too many ways to customize element creation: Overriding `Parent.__call__` (very bad), overriding `_element_constructor`, overriding `_element_constructor_`, overriding `element_class`, definition `.Element`. I suppose some of these ways just exist for historic reasons and should be removed.
+
+See: #23881, #23917, #24348, #24363, #26879
 
 Comment: 1
 
```




---

archive/issue_events_060828.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-16T19:15:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/23880",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23880#event-60828"
}
```
