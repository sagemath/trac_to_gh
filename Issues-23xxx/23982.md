# Issue 23982: perfect matchings and containment

archive/issues_023745.json:
```json
{
    "body": "Perfect matchings are special set partitions, therefore they should inherit from those.  As a side effect, perfect matchings have a good hashing function now.\n\nThis opens the opportunity to provide crossings and nestings for set partitions, and do some cleaning.\n\nOld description:\n\nPerfect matchings are not \"normalised\", that is, the pairs are not sorted.  Although that's sometimes annoying it's OK, because equality works.\n\nHowever, there is a problem with containment:\n\n```\nsage: M = PerfectMatching([(2, 3), (4, 1)]); M\n[(2, 3), (4, 1)]\nsage: M in PerfectMatchings(4)\nTrue\nsage: set(PerfectMatchings(4))\n{[(1, 2), (3, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 3)]}\nsage: M in set(PerfectMatchings(4))\nFalse\n```\nThis is because the set containment is done using the hash, and the hash is computed as the hash of the list representation of the matching.  The list representation of the matching is not sorted, so the hashes of `[(2, 3), (4, 1)]` and `[(1, 4), (2, 3)]` are different.\n\nIssue created by migration from https://trac.sagemath.org/ticket/23982\n\n",
    "closed_at": "2017-11-01T18:07:41Z",
    "created_at": "2017-10-07T09:06:55Z",
    "labels": [
        "component: combinatorics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "perfect matchings and containment",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23982",
    "user": "https://github.com/mantepse"
}
```
Perfect matchings are special set partitions, therefore they should inherit from those.  As a side effect, perfect matchings have a good hashing function now.

This opens the opportunity to provide crossings and nestings for set partitions, and do some cleaning.

Old description:

Perfect matchings are not "normalised", that is, the pairs are not sorted.  Although that's sometimes annoying it's OK, because equality works.

However, there is a problem with containment:

```
sage: M = PerfectMatching([(2, 3), (4, 1)]); M
[(2, 3), (4, 1)]
sage: M in PerfectMatchings(4)
True
sage: set(PerfectMatchings(4))
{[(1, 2), (3, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 3)]}
sage: M in set(PerfectMatchings(4))
False
```
This is because the set containment is done using the hash, and the hash is computed as the hash of the list representation of the matching.  The list representation of the matching is not sorted, so the hashes of `[(2, 3), (4, 1)]` and `[(1, 4), (2, 3)]` are different.

Issue created by migration from https://trac.sagemath.org/ticket/23982





---

archive/issue_comments_332293.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-10-07T21:07:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332293",
    "user": "https://github.com/mantepse"
}
```

New commits:



---

archive/issue_comments_332294.json:
```json
{
    "body": "That was stupid, now the hash of all matchings is the same.  I'm afraid, I have to sort.",
    "created_at": "2017-10-07T21:08:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332294",
    "user": "https://github.com/mantepse"
}
```

That was stupid, now the hash of all matchings is the same.  I'm afraid, I have to sort.



---

archive/issue_comments_332295.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-07T21:11:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332295",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332296.json:
```json
{
    "body": "In fact, I think it would be better to normalize the matching upon creation.  I'm not sure how this would be done - I guess by introducing an `_element_constructor_`?",
    "created_at": "2017-10-07T21:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332296",
    "user": "https://github.com/mantepse"
}
```

In fact, I think it would be better to normalize the matching upon creation.  I'm not sure how this would be done - I guess by introducing an `_element_constructor_`?



---

archive/issue_comments_332297.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-07T21:30:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332297",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332298.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-10-07T21:31:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332298",
    "user": "https://github.com/mantepse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_332299.json:
```json
{
    "body": "How about using the hash of a `frozenset`?",
    "created_at": "2017-10-08T01:54:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332299",
    "user": "https://github.com/tscrim"
}
```

How about using the hash of a `frozenset`?



---

archive/issue_comments_332300.json:
```json
{
    "body": "Are you saying I should convert the matching into a `frozenset` of `frozenset`s?\n\nIf so, I still think that this should be done when the matching is created.  I think that this would minimize the overhead.\n\nBut I'm not quite sure how to do it correctly - should I do it as in `SetPartition`?  I don't understand why `SetPartition` inherits from `ClonableArray` whereas `PerfectMatching` inherits from `ElementWrapper`.",
    "created_at": "2017-10-08T05:46:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332300",
    "user": "https://github.com/mantepse"
}
```

Are you saying I should convert the matching into a `frozenset` of `frozenset`s?

If so, I still think that this should be done when the matching is created.  I think that this would minimize the overhead.

But I'm not quite sure how to do it correctly - should I do it as in `SetPartition`?  I don't understand why `SetPartition` inherits from `ClonableArray` whereas `PerfectMatching` inherits from `ElementWrapper`.



---

archive/issue_comments_332301.json:
```json
{
    "body": "Replying to [comment:9 mantepse]:\n> Are you saying I should convert the matching into a `frozenset` of `frozenset`s?\n\n\nOnly for the hashing.\n\n> If so, I still think that this should be done when the matching is created.  I think that this would minimize the overhead.\n\n\nNo, we want things like `__getitem__` to work and to have more list-like behavior.\n\n> But I'm not quite sure how to do it correctly - should I do it as in `SetPartition`?  I don't understand why `SetPartition` inherits from `ClonableArray` whereas `PerfectMatching` inherits from `ElementWrapper`.\n\n\nAgain, only in the `__hash__` (which we can cache if the hashing is really, actually a bottleneck).",
    "created_at": "2017-10-08T07:46:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332301",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:9 mantepse]:
> Are you saying I should convert the matching into a `frozenset` of `frozenset`s?


Only for the hashing.

> If so, I still think that this should be done when the matching is created.  I think that this would minimize the overhead.


No, we want things like `__getitem__` to work and to have more list-like behavior.

> But I'm not quite sure how to do it correctly - should I do it as in `SetPartition`?  I don't understand why `SetPartition` inherits from `ClonableArray` whereas `PerfectMatching` inherits from `ElementWrapper`.


Again, only in the `__hash__` (which we can cache if the hashing is really, actually a bottleneck).



---

archive/issue_comments_332302.json:
```json
{
    "body": "Can you give me one reason why we should not sort at creation time - if you want to have list-like behaviour?\n\nI use perfect matchings quite a lot, and I must say that having\n\n```\nsage: PerfectMatching([[3,1],[2,4]])\n[(3, 1), (2, 4)]\n```\nis a pain.  I'm willing to live with it, but having list-like behaviour is actually counter productive, because you are not warned that the output is random.",
    "created_at": "2017-10-08T08:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332302",
    "user": "https://github.com/mantepse"
}
```

Can you give me one reason why we should not sort at creation time - if you want to have list-like behaviour?

I use perfect matchings quite a lot, and I must say that having

```
sage: PerfectMatching([[3,1],[2,4]])
[(3, 1), (2, 4)]
```
is a pain.  I'm willing to live with it, but having list-like behaviour is actually counter productive, because you are not warned that the output is random.



---

archive/issue_comments_332303.json:
```json
{
    "body": "Setting to \"needs work\", because I am now convinced that matchings should be normalised, when possible.",
    "created_at": "2017-10-08T13:12:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332303",
    "user": "https://github.com/mantepse"
}
```

Setting to "needs work", because I am now convinced that matchings should be normalised, when possible.



---

archive/issue_comments_332304.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-10-08T13:12:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332304",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_332305.json:
```json
{
    "body": "I agree that there is definite work to be done here. One reason to not sort at creation time is because sorting can be slow and you may not need to sort. Another reason is that sorting might not be defined.\n\nI feel like `PerfectMatching` should inherit from `SetPartition` and likewise for the parent.",
    "created_at": "2017-10-08T15:13:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332305",
    "user": "https://github.com/tscrim"
}
```

I agree that there is definite work to be done here. One reason to not sort at creation time is because sorting can be slow and you may not need to sort. Another reason is that sorting might not be defined.

I feel like `PerfectMatching` should inherit from `SetPartition` and likewise for the parent.



---

archive/issue_comments_332306.json:
```json
{
    "body": "Replying to [comment:13 tscrim]:\n> I agree that there is definite work to be done here. One reason to not sort at creation time is because sorting can be slow and you may not need to sort.\n\n\nI agree, but that calls for a `check=False` parameter.\n\n> Another reason is that sorting might not be defined.\n\n\nI agree.  I would hope that it is possible to have the internal representation depend on this.\n\n> I feel like `PerfectMatching` should inherit from `SetPartition` and likewise for the parent.\n\n\nOK, if this doesn't pose huge problems, I'm all for it.  The current internal representation of set partition is a (sorted) `ClonableArray` of `Set`.\n\nI think it would be best to have a sorted `ClonableArray` of sorted `Set`, so that openers are `[p[0] for p in P]` and closers are `[p[-1] for p in P]` whenever there is a total order available.\n\nUnfortunately, `Set` was broken recently, see #23324.",
    "created_at": "2017-10-08T16:17:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332306",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:13 tscrim]:
> I agree that there is definite work to be done here. One reason to not sort at creation time is because sorting can be slow and you may not need to sort.


I agree, but that calls for a `check=False` parameter.

> Another reason is that sorting might not be defined.


I agree.  I would hope that it is possible to have the internal representation depend on this.

> I feel like `PerfectMatching` should inherit from `SetPartition` and likewise for the parent.


OK, if this doesn't pose huge problems, I'm all for it.  The current internal representation of set partition is a (sorted) `ClonableArray` of `Set`.

I think it would be best to have a sorted `ClonableArray` of sorted `Set`, so that openers are `[p[0] for p in P]` and closers are `[p[-1] for p in P]` whenever there is a total order available.

Unfortunately, `Set` was broken recently, see #23324.



---

archive/issue_comments_332307.json:
```json
{
    "body": "That turned out to be quite easy!  I'll have a patch ready pretty soon - I just need to make sure all the old tests pass.",
    "created_at": "2017-10-08T18:21:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332307",
    "user": "https://github.com/mantepse"
}
```

That turned out to be quite easy!  I'll have a patch ready pretty soon - I just need to make sure all the old tests pass.



---

archive/issue_comments_332308.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-08T21:25:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332308",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332309.json:
```json
{
    "body": "Could you have a brief look?\n\nI think the following items need adressing:\n\n* the error messages are not explicit anymore.  For example, `PerfectMatching([This is the Trac macro *1,2,3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,3-macro))` now just raises an `AssertionError` without any explanation.  I don't know where to customize that yet.\n\n* I want that `SetPartition` sorts the parts.  We now have \n  {{{\n  sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n\n        [(1, 3), (8, 2), (4, 7), (5, 6)]\n  }}}\n  which is terrible.\n\n* as you can see, I did not change the `_repr_` of `PerfectMatching` for backwards compatibility.\n\n* There is some functionality in `PerfectMatching`, for example, `random_element` and `conjugate_by_permutation`which really belongs into `SetPartition`.",
    "created_at": "2017-10-08T21:34:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332309",
    "user": "https://github.com/mantepse"
}
```

Could you have a brief look?

I think the following items need adressing:

* the error messages are not explicit anymore.  For example, `PerfectMatching([This is the Trac macro *1,2,3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,3-macro))` now just raises an `AssertionError` without any explanation.  I don't know where to customize that yet.

* I want that `SetPartition` sorts the parts.  We now have 
  {{{
  sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n
        [(1, 3), (8, 2), (4, 7), (5, 6)]
  }}}
  which is terrible.

* as you can see, I did not change the `_repr_` of `PerfectMatching` for backwards compatibility.

* There is some functionality in `PerfectMatching`, for example, `random_element` and `conjugate_by_permutation`which really belongs into `SetPartition`.



---

archive/issue_comments_332310.json:
```json
{
    "body": "Just noticed that we have\n\n* `SetPartition.is_noncrossing` and `PerfectMatching.is_non_crossing`\n* `SetPartition.to_permutation` and `PerfectMatching.to_permutation`\n* `SetPartition.apply_permutation` and `PerfectMatching.conjugate_by_permutation`\n\nand probably some more.  Crossings and nestings could go into set partitions, too.",
    "created_at": "2017-10-08T21:56:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332310",
    "user": "https://github.com/mantepse"
}
```

Just noticed that we have

* `SetPartition.is_noncrossing` and `PerfectMatching.is_non_crossing`
* `SetPartition.to_permutation` and `PerfectMatching.to_permutation`
* `SetPartition.apply_permutation` and `PerfectMatching.conjugate_by_permutation`

and probably some more.  Crossings and nestings could go into set partitions, too.



---

archive/issue_comments_332311.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-08T22:06:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332311",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332312.json:
```json
{
    "body": "another question: `SetPartition.standardization()` is useful and makes sense for perfect matchings also, but returns a set partition.  (In fact, it always returns a generic set partition, not the more specialized `SetPartitions_set`)\n\nCan we make it return the appropriate parent always - or should I simply repeat the definition in `PerfectMatching`?\n\n---\nNew commits:",
    "created_at": "2017-10-08T22:12:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332312",
    "user": "https://github.com/mantepse"
}
```

another question: `SetPartition.standardization()` is useful and makes sense for perfect matchings also, but returns a set partition.  (In fact, it always returns a generic set partition, not the more specialized `SetPartitions_set`)

Can we make it return the appropriate parent always - or should I simply repeat the definition in `PerfectMatching`?

---
New commits:



---

archive/issue_comments_332313.json:
```json
{
    "body": "Replying to [comment:17 mantepse]:\n> Could you have a brief look?\n> \n> I think the following items need adressing:\n> \n> * the error messages are not explicit anymore.  For example, `PerfectMatching([This is the Trac macro *1,2,3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,3-macro))` now just raises an `AssertionError` without any explanation.  I don't know where to customize that yet.\n\n\nAs the traceback shows, you can implement a more refined `check` method. However, this will result in code duplication (well...essentially) and more of a maintenance burden.\n\n> * I want that `SetPartition` sorts the parts.  We now have \n>   {{{\n>   sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n\n>         [(1, 3), (8, 2), (4, 7), (5, 6)]\n>   }}}\n>   which is terrible.\n\n\nPlease be a little more explicit with the problem and avoid general (sensationalist) statements.\nI do agree that there is a problem with the output of `(8, 2)`. However, there is some consistency:\n\n```\nsage: PerfectMatching([(1, 3), (2, 8), (4, 7), (5, 6)])\n[(1, 3), (8, 2), (4, 7), (5, 6)]\n```\nThis seems to be a problem with the current implementation of `__classcall_private__`. This should *not* handle normalizing input in this case; instead that is best left to `__init__` of `SetPartition` as all code paths must go through there.\n\n> * There is some functionality in `PerfectMatching`, for example, `random_element` and `conjugate_by_permutation`which really belongs into `SetPartition`. \n\n\nNot necessarily. At least `random_element` seems specific to perfect matchings.",
    "created_at": "2017-10-08T23:28:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332313",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:17 mantepse]:
> Could you have a brief look?
> 
> I think the following items need adressing:
> 
> * the error messages are not explicit anymore.  For example, `PerfectMatching([This is the Trac macro *1,2,3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,3-macro))` now just raises an `AssertionError` without any explanation.  I don't know where to customize that yet.


As the traceback shows, you can implement a more refined `check` method. However, this will result in code duplication (well...essentially) and more of a maintenance burden.

> * I want that `SetPartition` sorts the parts.  We now have 
>   {{{
>   sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n
>         [(1, 3), (8, 2), (4, 7), (5, 6)]
>   }}}
>   which is terrible.


Please be a little more explicit with the problem and avoid general (sensationalist) statements.
I do agree that there is a problem with the output of `(8, 2)`. However, there is some consistency:

```
sage: PerfectMatching([(1, 3), (2, 8), (4, 7), (5, 6)])
[(1, 3), (8, 2), (4, 7), (5, 6)]
```
This seems to be a problem with the current implementation of `__classcall_private__`. This should *not* handle normalizing input in this case; instead that is best left to `__init__` of `SetPartition` as all code paths must go through there.

> * There is some functionality in `PerfectMatching`, for example, `random_element` and `conjugate_by_permutation`which really belongs into `SetPartition`. 


Not necessarily. At least `random_element` seems specific to perfect matchings.



---

archive/issue_comments_332314.json:
```json
{
    "body": "Replying to [comment:20 mantepse]:\n> another question: `SetPartition.standardization()` is useful and makes sense for perfect matchings also, but returns a set partition.  (In fact, it always returns a generic set partition, not the more specialized `SetPartitions_set`)\n> \n> Can we make it return the appropriate parent always - or should I simply repeat the definition in `PerfectMatching`?\n\n\nI don't think so as it is not worth the computation to find the \"best\" parent. Also, is it useful for it to be a `PerfectMatching`? If so, then it should just be\n\n```python\ndef standardization(self):\n    \"\"\"\n    Return the standardization of ``self``.\n\n    See :meth:`SetPartition.standardization` for details.\n\n    EXAMPLES::\n\n        sage: ...\n    \"\"\"\n    return PerfectMatchings()(SetPartition.standardization(self))\n```",
    "created_at": "2017-10-08T23:33:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332314",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:20 mantepse]:
> another question: `SetPartition.standardization()` is useful and makes sense for perfect matchings also, but returns a set partition.  (In fact, it always returns a generic set partition, not the more specialized `SetPartitions_set`)
> 
> Can we make it return the appropriate parent always - or should I simply repeat the definition in `PerfectMatching`?


I don't think so as it is not worth the computation to find the "best" parent. Also, is it useful for it to be a `PerfectMatching`? If so, then it should just be

```python
def standardization(self):
    """
    Return the standardization of ``self``.

    See :meth:`SetPartition.standardization` for details.

    EXAMPLES::

        sage: ...
    """
    return PerfectMatchings()(SetPartition.standardization(self))
```



---

archive/issue_comments_332315.json:
```json
{
    "body": "Many many thanks for looking!\n\nReplying to [comment:21 tscrim]:\n\n> > * I want that `SetPartition` sorts the parts.  We now have \n> >   {{{\n> >   sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n\n> >         [(1, 3), (8, 2), (4, 7), (5, 6)]\n> >   }}}\n> >   which is terrible.\n \n> \n> Please be a little more explicit with the problem and avoid general (sensationalist) statements.\n> I do agree that there is a problem with the output of `(8, 2)`. However, there is some consistency:\n> \n> ```\n> sage: PerfectMatching([(1, 3), (2, 8), (4, 7), (5, 6)])\n> [(1, 3), (8, 2), (4, 7), (5, 6)]\n> ```\n> This seems to be a problem with the current implementation of `__classcall_private__`. This should *not* handle normalizing input in this case; instead that is best left to `__init__` of `SetPartition` as all code paths must go through there.\n\n\nYes, I was not explicit enough.  I should have written: `SetPartition.__init__` calls        \n\n```\nClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)\n```\nand unfortunately\n\n```\nsage: Set([2,8])\n{8, 2}\n```\nI do think that this is terrible, though :-)  What I don't understand is the following:\n\n```\nsage: repr(frozenset([2,8]))\n'frozenset([8, 2])'\nsage: str(frozenset([2,8]))\n'frozenset([8, 2])'\nsage: frozenset([2,8])\nfrozenset({2, 8})\n```\n\nRemark to myself: we cannot simply sort at output, because of\n\n```\nsage: Set([2,8])[0]\n8\n```",
    "created_at": "2017-10-09T05:12:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332315",
    "user": "https://github.com/mantepse"
}
```

Many many thanks for looking!

Replying to [comment:21 tscrim]:

> > * I want that `SetPartition` sorts the parts.  We now have 
> >   {{{
> >   sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n
> >         [(1, 3), (8, 2), (4, 7), (5, 6)]
> >   }}}
> >   which is terrible.
 
> 
> Please be a little more explicit with the problem and avoid general (sensationalist) statements.
> I do agree that there is a problem with the output of `(8, 2)`. However, there is some consistency:
> 
> ```
> sage: PerfectMatching([(1, 3), (2, 8), (4, 7), (5, 6)])
> [(1, 3), (8, 2), (4, 7), (5, 6)]
> ```
> This seems to be a problem with the current implementation of `__classcall_private__`. This should *not* handle normalizing input in this case; instead that is best left to `__init__` of `SetPartition` as all code paths must go through there.


Yes, I was not explicit enough.  I should have written: `SetPartition.__init__` calls        

```
ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)
```
and unfortunately

```
sage: Set([2,8])
{8, 2}
```
I do think that this is terrible, though :-)  What I don't understand is the following:

```
sage: repr(frozenset([2,8]))
'frozenset([8, 2])'
sage: str(frozenset([2,8]))
'frozenset([8, 2])'
sage: frozenset([2,8])
frozenset({2, 8})
```

Remark to myself: we cannot simply sort at output, because of

```
sage: Set([2,8])[0]
8
```



---

archive/issue_comments_332316.json:
```json
{
    "body": "OK, I did some digging, and partially understand the issue now, it's a python thing.  It is quite confusing that `Set` supports indexing, I think that this should be turned off.  This is probably related to #12955.\n\nIn fact, turning off indexing in `Set`s, one could output them in sorted order :-)\n\nI must admit that I do not completely understand the purpose of `Set`.",
    "created_at": "2017-10-09T05:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332316",
    "user": "https://github.com/mantepse"
}
```

OK, I did some digging, and partially understand the issue now, it's a python thing.  It is quite confusing that `Set` supports indexing, I think that this should be turned off.  This is probably related to #12955.

In fact, turning off indexing in `Set`s, one could output them in sorted order :-)

I must admit that I do not completely understand the purpose of `Set`.



---

archive/issue_comments_332317.json:
```json
{
    "body": "I think I am done.  Let me list the possibly more controversial modifications:\n\n* I deprecated `non_crossing` and `non_nesting` in favour of `noncrossing` and `nonnesting`, because this is slightly more common.  If you prefer, I'd be fine with doing it the other way round, but I think consistency is desirable.  All of these work also on set partitions now.  Therefore, some doctests in `SetPartition` involve `PerfectMatching`.\n\n* I also deprecated `conjugate_by_permutation` in favour of `apply_permutation`.\n\n* I added (relatively stupid) random generation for set partitions of a given set and set partitions into a given number of parts.  I needed these for testing performance.\n\n* I kept the old printing format for perfect matchings, although the one for set partitions is probably better.\n\n* I do not know what ``@`add_metaclass(InheritComparisonClasscallMetaclass)` is for, is this still needed for perfect matchings?\n\n* I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.",
    "created_at": "2017-10-09T22:51:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332317",
    "user": "https://github.com/mantepse"
}
```

I think I am done.  Let me list the possibly more controversial modifications:

* I deprecated `non_crossing` and `non_nesting` in favour of `noncrossing` and `nonnesting`, because this is slightly more common.  If you prefer, I'd be fine with doing it the other way round, but I think consistency is desirable.  All of these work also on set partitions now.  Therefore, some doctests in `SetPartition` involve `PerfectMatching`.

* I also deprecated `conjugate_by_permutation` in favour of `apply_permutation`.

* I added (relatively stupid) random generation for set partitions of a given set and set partitions into a given number of parts.  I needed these for testing performance.

* I kept the old printing format for perfect matchings, although the one for set partitions is probably better.

* I do not know what ``@`add_metaclass(InheritComparisonClasscallMetaclass)` is for, is this still needed for perfect matchings?

* I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.



---

archive/issue_comments_332318.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-09T22:59:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332318",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332319.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-10-09T23:00:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332319",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_332320.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-10T07:03:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332320",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332321.json:
```json
{
    "body": "Replying to [comment:24 mantepse]:\n> OK, I did some digging, and partially understand the issue now, it's a python thing.  It is quite confusing that `Set` supports indexing, I think that this should be turned off.  This is probably related to #12955.\n\n\nNo, it is not related.\n\n> In fact, turning off indexing in `Set`s, one could output them in sorted order :-)\n\n\nNo, it would not. In fact, this is consistent what Python does with `set`, which *is* iterable.\n\n> I must admit that I do not completely understand the purpose of `Set`.\n\n\nIt is a Sage version of `set` and supports non-hashable elements and is a parent.",
    "created_at": "2017-10-12T06:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332321",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:24 mantepse]:
> OK, I did some digging, and partially understand the issue now, it's a python thing.  It is quite confusing that `Set` supports indexing, I think that this should be turned off.  This is probably related to #12955.


No, it is not related.

> In fact, turning off indexing in `Set`s, one could output them in sorted order :-)


No, it would not. In fact, this is consistent what Python does with `set`, which *is* iterable.

> I must admit that I do not completely understand the purpose of `Set`.


It is a Sage version of `set` and supports non-hashable elements and is a parent.



---

archive/issue_comments_332322.json:
```json
{
    "body": "Replying to [comment:25 mantepse]:\n> * I deprecated `non_crossing` and `non_nesting` in favour of `noncrossing` and `nonnesting`, because this is slightly more common.  If you prefer, I'd be fine with doing it the other way round, but I think consistency is desirable.  All of these work also on set partitions now.  Therefore, some doctests in `SetPartition` involve `PerfectMatching`.\n\n\nI have no preference. Darij and Christian are probably better people to solicit.\n\n> * I also deprecated `conjugate_by_permutation` in favour of `apply_permutation`.\n\n\nSame as above.\n\n> * I added (relatively stupid) random generation for set partitions of a given set and set partitions into a given number of parts.  I needed these for testing performance.\n\n\nI don't see why this would be controversial.\n\n> * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.\n\n\nI would just change it; it doesn't make sense to have a separate `_repr_`.\n\n> * I do not know what ``@`add_metaclass(InheritComparisonClasscallMetaclass)` is for, is this still needed for perfect matchings?\n\n\nYes, but it is inherited from `SetPartition`.\n\n> * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.\n\n\nHuh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.",
    "created_at": "2017-10-12T06:44:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332322",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:25 mantepse]:
> * I deprecated `non_crossing` and `non_nesting` in favour of `noncrossing` and `nonnesting`, because this is slightly more common.  If you prefer, I'd be fine with doing it the other way round, but I think consistency is desirable.  All of these work also on set partitions now.  Therefore, some doctests in `SetPartition` involve `PerfectMatching`.


I have no preference. Darij and Christian are probably better people to solicit.

> * I also deprecated `conjugate_by_permutation` in favour of `apply_permutation`.


Same as above.

> * I added (relatively stupid) random generation for set partitions of a given set and set partitions into a given number of parts.  I needed these for testing performance.


I don't see why this would be controversial.

> * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.


I would just change it; it doesn't make sense to have a separate `_repr_`.

> * I do not know what ``@`add_metaclass(InheritComparisonClasscallMetaclass)` is for, is this still needed for perfect matchings?


Yes, but it is inherited from `SetPartition`.

> * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.


Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.



---

archive/issue_comments_332323.json:
```json
{
    "body": "Some things that I do not like are:\n\n- A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.\n\n- `iter_aux` should be a separate standalone function.\n\n- I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.\n\n- This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.",
    "created_at": "2017-10-12T07:00:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332323",
    "user": "https://github.com/tscrim"
}
```

Some things that I do not like are:

- A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.

- `iter_aux` should be a separate standalone function.

- I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.

- This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.



---

archive/issue_comments_332324.json:
```json
{
    "body": "Replying to [comment:31 tscrim]:\n\n> > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.\n \n> \n> I would just change it; it doesn't make sense to have a separate `_repr_`.\n\n\nWell, I happen to know that it will break foreign code.  But if you insist, I'll remove it.\n\n> > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.\n \n> \n> Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.\n\n\nSorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)",
    "created_at": "2017-10-12T07:00:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332324",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:31 tscrim]:

> > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
 
> 
> I would just change it; it doesn't make sense to have a separate `_repr_`.


Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.

> > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.
 
> 
> Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.


Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)



---

archive/issue_comments_332325.json:
```json
{
    "body": "> - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.\n\n\nso these should all become `__init__` methods?\n\n> - `iter_aux` should be a separate standalone function.\n\n\nwhy?\n\n> \n> - I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.\n\n\nI did not introduce any, which ones do you mean?  (Besides, personally, I find `try-except-else` *much* easier to read.  Possibly because I grew up with Pascal and Lisp.)\n\n> - This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.\n\n\nOK, but only after I understand what you want...",
    "created_at": "2017-10-12T07:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332325",
    "user": "https://github.com/mantepse"
}
```

> - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.


so these should all become `__init__` methods?

> - `iter_aux` should be a separate standalone function.


why?

> 
> - I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.


I did not introduce any, which ones do you mean?  (Besides, personally, I find `try-except-else` *much* easier to read.  Possibly because I grew up with Pascal and Lisp.)

> - This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.


OK, but only after I understand what you want...



---

archive/issue_comments_332326.json:
```json
{
    "body": "Replying to [comment:33 mantepse]:\n> Replying to [comment:31 tscrim]:\n> \n> > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.\n \n> > \n> > I would just change it; it doesn't make sense to have a separate `_repr_`.\n\n> \n> Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.\n\n\nWhat do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).\n\n> > > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.\n \n> > \n> > Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.\n\n> \n> Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)\n\n\nNo, I do not think you should change anything in `check`. I just do not understand what this had to do with `PerfectMatching._repr_` and what tolerance you are referring to.\n\nA side issue, the lack of an error message previously was fine because of the traceback. However, it should be a `ValueError` and not an `AssertionError`.",
    "created_at": "2017-10-12T07:26:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332326",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:33 mantepse]:
> Replying to [comment:31 tscrim]:
> 
> > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
 
> > 
> > I would just change it; it doesn't make sense to have a separate `_repr_`.

> 
> Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.


What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).

> > > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.
 
> > 
> > Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.

> 
> Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)


No, I do not think you should change anything in `check`. I just do not understand what this had to do with `PerfectMatching._repr_` and what tolerance you are referring to.

A side issue, the lack of an error message previously was fine because of the traceback. However, it should be a `ValueError` and not an `AssertionError`.



---

archive/issue_comments_332327.json:
```json
{
    "body": "Replying to [comment:34 mantepse]:\n> \n> > - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.\n \n> \n> so these should all become `__init__` methods?\n\n\nNo, I would just not have a `check` parameter in `__classcall_private__` (but it is good to have it in `__init__`). In case you are asking a slightly different question, in Sage code, instead of doing `PerfectMatching(foo)`, I feel we should do `PerfectMatchings()(foo, check=False)` (or whatever the appropriate parent is) as it has less indirection (i.e., is more explicit).\n\n> > - `iter_aux` should be a separate standalone function.\n \n> \n> why?\n\n\nBecause it is faster if someone needs to iterate and only have lists, it would be better documented, and works as a standalone.\n\n> > - I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.\n \n> \n> I did not introduce any, which ones do you mean?  (Besides, personally, I find `try-except-else` *much* easier to read.  Possibly because I grew up with Pascal and Lisp.)\n\n\nI guess these do all come from the old perfect matching code. The:\n\n```python\n        try:\n            next(it)\n        except StopIteration:\n            return True\n        else:\n            return False\n```\nWhat makes this more complicated to me is that exceptions generally do special behavior and program flow should continue at the same level after things are processed. So the `else` block is (typically) vacuous as exceptions should typically not dictate program flow (Python makes this unavoidable at times). It is more stylistic, but I'm (overly) opinionated.\n\n> > - This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.\n \n> \n> OK, but only after I understand what you want...\n\n\nFor example:\n\n```\n    def nestings_iterator(self):\n        r\"\"\"\n        INPUT:\n\n            A perfect matching on a *totally ordered* ground set.\n\n        OUTPUT:\n\n            We place the elements of the ground set in order on a\n            line and draw the set partition by linking consecutive\n            elements of each block in the upper half-plane. This\n            function returns an iterator over the pairs of nesting\n            lines (as a line correspond to a pair, the iterator\n            produces pairs of pairs).\n```\nis missing the one-line description, the `INPUT` and `OUTPUT` blocks should not be intended, `INPUT` should not be there as `self` is not an input, etc.",
    "created_at": "2017-10-12T07:38:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332327",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:34 mantepse]:
> 
> > - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.
 
> 
> so these should all become `__init__` methods?


No, I would just not have a `check` parameter in `__classcall_private__` (but it is good to have it in `__init__`). In case you are asking a slightly different question, in Sage code, instead of doing `PerfectMatching(foo)`, I feel we should do `PerfectMatchings()(foo, check=False)` (or whatever the appropriate parent is) as it has less indirection (i.e., is more explicit).

> > - `iter_aux` should be a separate standalone function.
 
> 
> why?


Because it is faster if someone needs to iterate and only have lists, it would be better documented, and works as a standalone.

> > - I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.
 
> 
> I did not introduce any, which ones do you mean?  (Besides, personally, I find `try-except-else` *much* easier to read.  Possibly because I grew up with Pascal and Lisp.)


I guess these do all come from the old perfect matching code. The:

```python
        try:
            next(it)
        except StopIteration:
            return True
        else:
            return False
```
What makes this more complicated to me is that exceptions generally do special behavior and program flow should continue at the same level after things are processed. So the `else` block is (typically) vacuous as exceptions should typically not dictate program flow (Python makes this unavoidable at times). It is more stylistic, but I'm (overly) opinionated.

> > - This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.
 
> 
> OK, but only after I understand what you want...


For example:

```
    def nestings_iterator(self):
        r"""
        INPUT:

            A perfect matching on a *totally ordered* ground set.

        OUTPUT:

            We place the elements of the ground set in order on a
            line and draw the set partition by linking consecutive
            elements of each block in the upper half-plane. This
            function returns an iterator over the pairs of nesting
            lines (as a line correspond to a pair, the iterator
            produces pairs of pairs).
```
is missing the one-line description, the `INPUT` and `OUTPUT` blocks should not be intended, `INPUT` should not be there as `self` is not an input, etc.



---

archive/issue_comments_332328.json:
```json
{
    "body": "> > > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.\n \n> > > \n> > > I would just change it; it doesn't make sense to have a separate `_repr_`.\n\n> > \n> > Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.\n\n> \n> What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).\n\n\nit's not a big thing:  FindStat uses the repr of perfect matchings also for input, but this can be changed easily.  I guess in the long run it's better, the only drawback being that you cannot use the output as input anymore.\n\n> > > > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.\n \n> > > \n> > > Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.\n\n> > \n> > Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)\n\n> \n> No, I do not think you should change anything in `check`. I just do not understand what this had to do with `PerfectMatching._repr_` and what tolerance you are referring to.\n\n\nThe code in check is `raise ValueError(\"%s is not an element of %s\"%(self, self.parent()))`.  For some reason, at this point, `self` is already an instance of `PerfectMatching`, so the `_repr_` should be able to print it even if the number of parts is not always two.\n\nI admit that this is a hack, but that's not my fault.\n \n> A side issue, the lack of an error message previously was fine because of the traceback.\n\n\nI disagree - for me, the tracebacks are a pain if there cause is at top level.",
    "created_at": "2017-10-12T08:02:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332328",
    "user": "https://github.com/mantepse"
}
```

> > > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
 
> > > 
> > > I would just change it; it doesn't make sense to have a separate `_repr_`.

> > 
> > Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.

> 
> What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).


it's not a big thing:  FindStat uses the repr of perfect matchings also for input, but this can be changed easily.  I guess in the long run it's better, the only drawback being that you cannot use the output as input anymore.

> > > > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.
 
> > > 
> > > Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.

> > 
> > Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)

> 
> No, I do not think you should change anything in `check`. I just do not understand what this had to do with `PerfectMatching._repr_` and what tolerance you are referring to.


The code in check is `raise ValueError("%s is not an element of %s"%(self, self.parent()))`.  For some reason, at this point, `self` is already an instance of `PerfectMatching`, so the `_repr_` should be able to print it even if the number of parts is not always two.

I admit that this is a hack, but that's not my fault.
 
> A side issue, the lack of an error message previously was fine because of the traceback.


I disagree - for me, the tracebacks are a pain if there cause is at top level.



---

archive/issue_comments_332329.json:
```json
{
    "body": "Replying to [comment:36 tscrim]:\n> Replying to [comment:34 mantepse]:\n> > \n> > > - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.\n \n> > \n> > so these should all become `__init__` methods?\n\n> \n> No, I would just not have a `check` parameter in `__classcall_private__` (but it is good to have it in `__init__`).\n\n\nIn `SetPartition`, we do have an `__init__`.  But `__classcall_private__` calls `SetPartitions.element_class`, passing the parameter `check`.  What should it pass if `check` is not available?  Or should it be `return P.element_class(P, *args, **kwds)`?\n\nIn `PerfectMatching`, currently there is no `__init__`, but I think it would make sense, because we have the special preprocessing for involutions.\n\n> In case you are asking a slightly different question, in Sage code, instead of doing `PerfectMatching(foo)`, I feel we should do `PerfectMatchings()(foo, check=False)` (or whatever the appropriate parent is) as it has less indirection (i.e., is more explicit).\n\n\nI agree with this one, as you probably know :-)",
    "created_at": "2017-10-12T08:11:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332329",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:36 tscrim]:
> Replying to [comment:34 mantepse]:
> > 
> > > - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.
 
> > 
> > so these should all become `__init__` methods?

> 
> No, I would just not have a `check` parameter in `__classcall_private__` (but it is good to have it in `__init__`).


In `SetPartition`, we do have an `__init__`.  But `__classcall_private__` calls `SetPartitions.element_class`, passing the parameter `check`.  What should it pass if `check` is not available?  Or should it be `return P.element_class(P, *args, **kwds)`?

In `PerfectMatching`, currently there is no `__init__`, but I think it would make sense, because we have the special preprocessing for involutions.

> In case you are asking a slightly different question, in Sage code, instead of doing `PerfectMatching(foo)`, I feel we should do `PerfectMatchings()(foo, check=False)` (or whatever the appropriate parent is) as it has less indirection (i.e., is more explicit).


I agree with this one, as you probably know :-)



---

archive/issue_comments_332330.json:
```json
{
    "body": "ping?\n\n(I don't know what I'm supposed to do in `__classcall_private__`, whether I should introduce `PerfectMatching.__init__`)",
    "created_at": "2017-10-14T17:57:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332330",
    "user": "https://github.com/mantepse"
}
```

ping?

(I don't know what I'm supposed to do in `__classcall_private__`, whether I should introduce `PerfectMatching.__init__`)



---

archive/issue_comments_332331.json:
```json
{
    "body": "Replying to [comment:37 mantepse]:\n> > > > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.\n \n> > > > \n> > > > I would just change it; it doesn't make sense to have a separate `_repr_`.\n\n> > > \n> > > Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.\n\n> > \n> > What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).\n\n> \n> it's not a big thing:  FindStat uses the repr of perfect matchings also for input, but this can be changed easily.  I guess in the long run it's better, the only drawback being that you cannot use the output as input anymore.\n\n\nFor the free input box I'm guessing. Well, it is very close. I leave the final decision up to you. I don't strongly care either way.\n\n> The code in check is `raise ValueError(\"%s is not an element of %s\"%(self, self.parent()))`.  For some reason, at this point, `self` is already an instance of `PerfectMatching`, so the `_repr_` should be able to print it even if the number of parts is not always two.\n\n\nOh, I see.\n\n> I admit that this is a hack, but that's not my fault.\n\n\nWell, its only really an issue because of the custom `_repr_` and if that is making assumptions, but those are very easy to work around (if the code gets that far).\n\n> > A side issue, the lack of an error message previously was fine because of the traceback.\n\n> \n> I disagree - for me, the tracebacks are a pain if there cause is at top level.\n\n\nThe traceback is clear and it is the final part of it that gives the fault (just not the precise reason for it failing to be a set partition). This just becomes more code to maintain.\n\n---\n\nI've done a bit of cleanup of the perfect matchings and some of set partitions (much more is needed there) and taken care of duplicated code, the `__init__` issues, and improved the doc formatting.\n\nI personally don't generally like `foo()` and `foo_iterator()` methods (well, both public), but that is another issue for another ticket.\n\nIf my changes look good, then positive review.\n\n---\nNew commits:",
    "created_at": "2017-10-16T22:15:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332331",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:37 mantepse]:
> > > > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
 
> > > > 
> > > > I would just change it; it doesn't make sense to have a separate `_repr_`.

> > > 
> > > Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.

> > 
> > What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).

> 
> it's not a big thing:  FindStat uses the repr of perfect matchings also for input, but this can be changed easily.  I guess in the long run it's better, the only drawback being that you cannot use the output as input anymore.


For the free input box I'm guessing. Well, it is very close. I leave the final decision up to you. I don't strongly care either way.

> The code in check is `raise ValueError("%s is not an element of %s"%(self, self.parent()))`.  For some reason, at this point, `self` is already an instance of `PerfectMatching`, so the `_repr_` should be able to print it even if the number of parts is not always two.


Oh, I see.

> I admit that this is a hack, but that's not my fault.


Well, its only really an issue because of the custom `_repr_` and if that is making assumptions, but those are very easy to work around (if the code gets that far).

> > A side issue, the lack of an error message previously was fine because of the traceback.

> 
> I disagree - for me, the tracebacks are a pain if there cause is at top level.


The traceback is clear and it is the final part of it that gives the fault (just not the precise reason for it failing to be a set partition). This just becomes more code to maintain.

---

I've done a bit of cleanup of the perfect matchings and some of set partitions (much more is needed there) and taken care of duplicated code, the `__init__` issues, and improved the doc formatting.

I personally don't generally like `foo()` and `foo_iterator()` methods (well, both public), but that is another issue for another ticket.

If my changes look good, then positive review.

---
New commits:



---

archive/issue_comments_332332.json:
```json
{
    "body": "Could you please explain why the `check` parameter in `PerfectMatching.__classcall_private__` is wrong?\n\nI added a `check` parameter to `AlternatingSignMatrix.__classcall_private__` in #23819, which makes me wonder what's correct.",
    "created_at": "2017-10-17T18:25:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332332",
    "user": "https://github.com/mantepse"
}
```

Could you please explain why the `check` parameter in `PerfectMatching.__classcall_private__` is wrong?

I added a `check` parameter to `AlternatingSignMatrix.__classcall_private__` in #23819, which makes me wonder what's correct.



---

archive/issue_comments_332333.json:
```json
{
    "body": "Replying to [comment:41 mantepse]:\n> Could you please explain why the `check` parameter in `PerfectMatching.__classcall_private__` is wrong?\n\n\nI do not like it as user input should generally always be checked. Saying it is wrong is debatable, but I am not in favor of bypassing safety checks in a user-specific function.\n\n> I added a `check` parameter to `AlternatingSignMatrix.__classcall_private__` in #23819, which makes me wonder what's correct.\n\n\nI didn't catch that when I looked over #23819. I don't like it there either.",
    "created_at": "2017-10-18T04:45:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332333",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:41 mantepse]:
> Could you please explain why the `check` parameter in `PerfectMatching.__classcall_private__` is wrong?


I do not like it as user input should generally always be checked. Saying it is wrong is debatable, but I am not in favor of bypassing safety checks in a user-specific function.

> I added a `check` parameter to `AlternatingSignMatrix.__classcall_private__` in #23819, which makes me wonder what's correct.


I didn't catch that when I looked over #23819. I don't like it there either.



---

archive/issue_comments_332334.json:
```json
{
    "body": "So, if Alice needs to bypass checks for performance, she should do `AlternatingSignMatrices(3)(m, check=False)`?",
    "created_at": "2017-10-18T06:18:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332334",
    "user": "https://github.com/mantepse"
}
```

So, if Alice needs to bypass checks for performance, she should do `AlternatingSignMatrices(3)(m, check=False)`?



---

archive/issue_comments_332335.json:
```json
{
    "body": "Replying to [comment:43 mantepse]:\n> So, if Alice needs to bypass checks for performance, she should do `AlternatingSignMatrices(3)(m, check=False)`?\n\n\nYes, that is correct (or avoiding more indirection with `P.element_class(m, check=False)`).",
    "created_at": "2017-10-18T15:54:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332335",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:43 mantepse]:
> So, if Alice needs to bypass checks for performance, she should do `AlternatingSignMatrices(3)(m, check=False)`?


Yes, that is correct (or avoiding more indirection with `P.element_class(m, check=False)`).



---

archive/issue_comments_332336.json:
```json
{
    "body": "Thanks, I'll decide the `repr` thing tomorrow morning (slightly leaning towards removing the special handling for perfect matchings) and then set it to positive review, if you do not protest :-)\n\nThanks a lot for the collaboration!",
    "created_at": "2017-10-18T16:23:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332336",
    "user": "https://github.com/mantepse"
}
```

Thanks, I'll decide the `repr` thing tomorrow morning (slightly leaning towards removing the special handling for perfect matchings) and then set it to positive review, if you do not protest :-)

Thanks a lot for the collaboration!



---

archive/issue_comments_332337.json:
```json
{
    "body": "Replying to [comment:45 mantepse]:\n> Thanks, I'll decide the `repr` thing tomorrow morning (slightly leaning towards removing the special handling for perfect matchings) and then set it to positive review, if you do not protest :-)\n\n\nJust let me give it a quick look-over, but I do not expect to object to anything.\n\n> Thanks a lot for the collaboration!\n\n\nThank you for your continued work.",
    "created_at": "2017-10-18T16:24:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332337",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:45 mantepse]:
> Thanks, I'll decide the `repr` thing tomorrow morning (slightly leaning towards removing the special handling for perfect matchings) and then set it to positive review, if you do not protest :-)


Just let me give it a quick look-over, but I do not expect to object to anything.

> Thanks a lot for the collaboration!


Thank you for your continued work.



---

archive/issue_comments_332338.json:
```json
{
    "body": "Sorry to bother you again, Travis: `P.element_class(m, check=False)` does not work.  It seems one should do\n\n```   \n   m = my_matrix\n   m.set_immutable()\n   P = AlternatingSignMatrices(m.nrows())\n   return P.element_class(P, m)\n```\nI am a bit worried about this pattern, however, because effectively one needs to know very exactly how the data is initialised - eg., here it is not sufficient to pass a matrix, one must make it immutable, too.\n\nHaving the parameter `check` seemed a bit like a middle ground - the internal representation remains hidden, only the checks are switched off.\n\nI'd like to sort this out properly.",
    "created_at": "2017-10-19T11:17:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332338",
    "user": "https://github.com/mantepse"
}
```

Sorry to bother you again, Travis: `P.element_class(m, check=False)` does not work.  It seems one should do

```   
   m = my_matrix
   m.set_immutable()
   P = AlternatingSignMatrices(m.nrows())
   return P.element_class(P, m)
```
I am a bit worried about this pattern, however, because effectively one needs to know very exactly how the data is initialised - eg., here it is not sufficient to pass a matrix, one must make it immutable, too.

Having the parameter `check` seemed a bit like a middle ground - the internal representation remains hidden, only the checks are switched off.

I'd like to sort this out properly.



---

archive/issue_comments_332339.json:
```json
{
    "body": "IMO, this is essentially irrelevant to this ticket, but let's work through it now. First, `P.element_class(m, check=False)` will not work because I made a typo; it should have been `P.element_class(P, m, check=False)`. Yet, in this case the check is actually done by the `_element_constructor_`, not in the actual element class. Because you are directly using `P.element_class`, you are expected to be much more careful and know what you are doing, including whether or not the matrix is immutable or not (and side effects). So again, I want to remove the `check` in the `__classcall_private__` because that is not the way to construct elements for speed reasons.",
    "created_at": "2017-10-19T15:14:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332339",
    "user": "https://github.com/tscrim"
}
```

IMO, this is essentially irrelevant to this ticket, but let's work through it now. First, `P.element_class(m, check=False)` will not work because I made a typo; it should have been `P.element_class(P, m, check=False)`. Yet, in this case the check is actually done by the `_element_constructor_`, not in the actual element class. Because you are directly using `P.element_class`, you are expected to be much more careful and know what you are doing, including whether or not the matrix is immutable or not (and side effects). So again, I want to remove the `check` in the `__classcall_private__` because that is not the way to construct elements for speed reasons.



---

archive/issue_comments_332340.json:
```json
{
    "body": "I admit that I had no idea which method is actually invoked when I call `element_class` - apparently it's `__init__`.  I find the number of initialisation methods very confusing.  Sticking with the `A = AlternatingSignMatrices(1)` example for concreteness:\n\n* `A([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` invokes `__element_constructor__`, then `__init__`\n* `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` calls `__classcall_private__`, then `__init__`, then `__element_constructor__`, then `__init__` again.\n* calling `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` again, the first call to `__init__` is omitted...\n\nIs there any documentation on this?\n\n```\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-129-ec4b906ad823> in <module>()\n----> 1 A.element_class(A, [[Integer(1)]], check=False)\n\n/home/martin/sage-develop/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1607)()\n    331         else:\n    332             # Fast version of type.__call__(cls, *args, **kwds)\n--> 333             return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n    334 \n    335     def __get__(cls, instance, owner):\n\nTypeError: __init__() got an unexpected keyword argument 'check'\n```",
    "created_at": "2017-10-19T17:32:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332340",
    "user": "https://github.com/mantepse"
}
```

I admit that I had no idea which method is actually invoked when I call `element_class` - apparently it's `__init__`.  I find the number of initialisation methods very confusing.  Sticking with the `A = AlternatingSignMatrices(1)` example for concreteness:

* `A([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` invokes `__element_constructor__`, then `__init__`
* `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` calls `__classcall_private__`, then `__init__`, then `__element_constructor__`, then `__init__` again.
* calling `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` again, the first call to `__init__` is omitted...

Is there any documentation on this?

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-129-ec4b906ad823> in <module>()
----> 1 A.element_class(A, [[Integer(1)]], check=False)

/home/martin/sage-develop/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1607)()
    331         else:
    332             # Fast version of type.__call__(cls, *args, **kwds)
--> 333             return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    334 
    335     def __get__(cls, instance, owner):

TypeError: __init__() got an unexpected keyword argument 'check'
```



---

archive/issue_comments_332341.json:
```json
{
    "body": "Replying to [comment:50 mantepse]:\n> I admit that I had no idea which method is actually invoked when I call `element_class` - apparently it's `__init__`.  I find the number of initialisation methods very confusing.  Sticking with the `A = AlternatingSignMatrices(1)` example for concreteness:\n> * `A([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` invokes `__element_constructor__`, then `__init__`\n\n\nSingle underscore `_element_constructor_`, but functionally yes (there is the indirection through `AlternatingSignMatrices.__call__` and the coercion framework).\n\n> * `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` calls `__classcall_private__`, then `__init__`, then `__element_constructor__`, then `__init__` again.\n\n\nNot true. This calls `AlternatingSignMatrix.__classcall_private__`, which really can call anything it wants to. In this case, it creates a parent, and then passes the data `[This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro)` off to that `AlternatingSignMatrices.__call__` -> `AlternatingSignMatrices._element_constructor_` -> `AlternatingSignMatrix.__init__`.\n\n> * calling `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` again, the first call to `__init__` is omitted...\n\n\nNo, that is false (well, possibly depending on which `__init__` you are referring to). There was never a first call to `AlternatingSignMatrix.__init__`. There is a construction of the parent, but that may or may not be (re)created depending on if it has been cleared from the cache or not.\n\n> Is there any documentation on this?\n\n\nThis is in the `misc/classcall_metaclass.pyx` where it is defined (and imported).\n\n> {{{\n> \n> ---\n> TypeError                                 Traceback (most recent call last)\n> <ipython-input-129-ec4b906ad823> in <module>()\n> \n> ---\n> \n> /home/martin/sage-develop/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1607)()\n>     331         else:\n>     332             # Fast version of type.__call__(cls, *args, **kwds)\n> --> 333             return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n>     334 \n>     335     def __get__(cls, instance, owner):\n> \n> TypeError: __init__() got an unexpected keyword argument 'check'\n> }}}\n\n\nThis is in the `__new__` and so many things in Sage have a similar traceback for bad (keyword) arguments. The error message at the end of the traceback tells you exactly what the problem is.",
    "created_at": "2017-10-20T00:39:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332341",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:50 mantepse]:
> I admit that I had no idea which method is actually invoked when I call `element_class` - apparently it's `__init__`.  I find the number of initialisation methods very confusing.  Sticking with the `A = AlternatingSignMatrices(1)` example for concreteness:
> * `A([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` invokes `__element_constructor__`, then `__init__`


Single underscore `_element_constructor_`, but functionally yes (there is the indirection through `AlternatingSignMatrices.__call__` and the coercion framework).

> * `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` calls `__classcall_private__`, then `__init__`, then `__element_constructor__`, then `__init__` again.


Not true. This calls `AlternatingSignMatrix.__classcall_private__`, which really can call anything it wants to. In this case, it creates a parent, and then passes the data `[This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro)` off to that `AlternatingSignMatrices.__call__` -> `AlternatingSignMatrices._element_constructor_` -> `AlternatingSignMatrix.__init__`.

> * calling `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` again, the first call to `__init__` is omitted...


No, that is false (well, possibly depending on which `__init__` you are referring to). There was never a first call to `AlternatingSignMatrix.__init__`. There is a construction of the parent, but that may or may not be (re)created depending on if it has been cleared from the cache or not.

> Is there any documentation on this?


This is in the `misc/classcall_metaclass.pyx` where it is defined (and imported).

> {{{
> 
> ---
> TypeError                                 Traceback (most recent call last)
> <ipython-input-129-ec4b906ad823> in <module>()
> 
> ---
> 
> /home/martin/sage-develop/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1607)()
>     331         else:
>     332             # Fast version of type.__call__(cls, *args, **kwds)
> --> 333             return (<PyTypeObject*>type).tp_call(cls, args, kwds)
>     334 
>     335     def __get__(cls, instance, owner):
> 
> TypeError: __init__() got an unexpected keyword argument 'check'
> }}}


This is in the `__new__` and so many things in Sage have a similar traceback for bad (keyword) arguments. The error message at the end of the traceback tells you exactly what the problem is.



---

archive/issue_comments_332342.json:
```json
{
    "body": "> Not true. [...]\n> No, that is false (well, possibly depending on which `__init__` you are referring to). \n\n\nTravis, I included a print statement in `AlternatingSignMatrix.__init__`, likewise in `AlternatingSignMatrix.__classcall_private__` and `AlternatingSignMatrices._elemente_constructor_`.  That's what I get:\n\n```\nsage: A = AlternatingSignMatrices(1)\nsage: A([[1]])\nelement_constructor\ninit\n[1]\nsage: AlternatingSignMatrix([[1,0],[0,1]])\nclasscall_private\ninit\nelement_constructor\ninit\n\n[1 0]\n[0 1]\nsage: AlternatingSignMatrix([[1,0],[0,1]])\nclasscall_private\nelement_constructor\ninit\n\n[1 0]\n[0 1]\n```",
    "created_at": "2017-10-20T05:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332342",
    "user": "https://github.com/mantepse"
}
```

> Not true. [...]
> No, that is false (well, possibly depending on which `__init__` you are referring to). 


Travis, I included a print statement in `AlternatingSignMatrix.__init__`, likewise in `AlternatingSignMatrix.__classcall_private__` and `AlternatingSignMatrices._elemente_constructor_`.  That's what I get:

```
sage: A = AlternatingSignMatrices(1)
sage: A([[1]])
element_constructor
init
[1]
sage: AlternatingSignMatrix([[1,0],[0,1]])
classcall_private
init
element_constructor
init

[1 0]
[0 1]
sage: AlternatingSignMatrix([[1,0],[0,1]])
classcall_private
element_constructor
init

[1 0]
[0 1]
```



---

archive/issue_comments_332343.json:
```json
{
    "body": "No, it's not. You're too focused on the output to think about what else is going on and the program flow. In this case, it is the coercion framework (I printed `asm`):\n\n```\nsage: M = matrix(ZZ, [[0,1],[1,0]])\nsage: M\n[0 1]\n[1 0]\nsage: ASM = AlternatingSignMatrices(M.nrows())\nsage: _ = ASM(M)\ninit\n[1 0]\n[0 1]\ninit\n[0 1]\n[1 0]\n```\nThe first one is from initializing `ASM.an_element()` for the coercion framework test:\n\n```\nsage: ASM.an_element()\n[1 0]\n[0 1]\n```",
    "created_at": "2017-10-20T05:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332343",
    "user": "https://github.com/tscrim"
}
```

No, it's not. You're too focused on the output to think about what else is going on and the program flow. In this case, it is the coercion framework (I printed `asm`):

```
sage: M = matrix(ZZ, [[0,1],[1,0]])
sage: M
[0 1]
[1 0]
sage: ASM = AlternatingSignMatrices(M.nrows())
sage: _ = ASM(M)
init
[1 0]
[0 1]
init
[0 1]
[1 0]
```
The first one is from initializing `ASM.an_element()` for the coercion framework test:

```
sage: ASM.an_element()
[1 0]
[0 1]
```



---

archive/issue_comments_332344.json:
```json
{
    "body": "Thank you, that makes it a little clearer.  I find the documentation in `classcall_metaclass.pyx` very hard to read, I am not sure I want to learn what a metaclass really is.  I was hoping for clear instructions, ideally by a few examples, what to implement in which method.  Since `AlternatingSignMatrix` looks quite simple, I thought I'd take it...\n\nI need an hour now...\n\nThanks again!",
    "created_at": "2017-10-20T05:46:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332344",
    "user": "https://github.com/mantepse"
}
```

Thank you, that makes it a little clearer.  I find the documentation in `classcall_metaclass.pyx` very hard to read, I am not sure I want to learn what a metaclass really is.  I was hoping for clear instructions, ideally by a few examples, what to implement in which method.  Since `AlternatingSignMatrix` looks quite simple, I thought I'd take it...

I need an hour now...

Thanks again!



---

archive/issue_comments_332345.json:
```json
{
    "body": "Replying to [comment:54 mantepse]:\n> I need an hour now...\n\n\nI might be asleep then (or not doing any problem).\n\n> Thanks again!\n\n\nNo problem.",
    "created_at": "2017-10-20T05:47:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332345",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:54 mantepse]:
> I need an hour now...


I might be asleep then (or not doing any problem).

> Thanks again!


No problem.



---

archive/issue_comments_332346.json:
```json
{
    "body": "In the end I decided against changing the `_repr_` of perfect matchings.  There is some benefit in being able to copy-pasting the output.\n\nTravis, could you please set it to positive review.\n\nOnce I have enough energy, I'll open a metaticket for unifying `check` in sage :-)",
    "created_at": "2017-10-30T13:54:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332346",
    "user": "https://github.com/mantepse"
}
```

In the end I decided against changing the `_repr_` of perfect matchings.  There is some benefit in being able to copy-pasting the output.

Travis, could you please set it to positive review.

Once I have enough energy, I'll open a metaticket for unifying `check` in sage :-)



---

archive/issue_comments_332347.json:
```json
{
    "body": "Thank you for your continued work.",
    "created_at": "2017-10-30T20:28:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332347",
    "user": "https://github.com/tscrim"
}
```

Thank you for your continued work.



---

archive/issue_comments_332348.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-10-30T20:28:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332348",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_332349.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-11-01T18:07:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23982#issuecomment-332349",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_061010.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-11-01T18:07:41Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23982",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23982#event-61010"
}
```
