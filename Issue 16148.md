# Issue 16148: Fix rounding ZZ -> Python float

archive/issues_016148.json:
```json
{
    "body": "CC:  @zimmermann6\n\nConsider the following conversions:\nA. Sage `Integer` -> Python `float` (or Sage `RDF`)\nB. Python `int` -> Python `float`\nC. Sage `Integer` -> Sage `RR`\nD. C `unsigned long` -> C `double`\n\nConversion A rounds to zero, while the others round to nearest (by default). We should make A consistent with the rest.\n\nCurrently, `Integer` -> `float` uses `mpz_get_d()` which rounds to zero. Doing the conversion via `mpfr` should fix this.\n\nIssue created by migration from https://trac.sagemath.org/ticket/16385\n\n",
    "created_at": "2014-05-21T15:44:49Z",
    "labels": [
        "basic arithmetic",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Fix rounding ZZ -> Python float",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16148",
    "user": "@jdemeyer"
}
```
CC:  @zimmermann6

Consider the following conversions:
A. Sage `Integer` -> Python `float` (or Sage `RDF`)
B. Python `int` -> Python `float`
C. Sage `Integer` -> Sage `RR`
D. C `unsigned long` -> C `double`

Conversion A rounds to zero, while the others round to nearest (by default). We should make A consistent with the rest.

Currently, `Integer` -> `float` uses `mpz_get_d()` which rounds to zero. Doing the conversion via `mpfr` should fix this.

Issue created by migration from https://trac.sagemath.org/ticket/16385





---

archive/issue_comments_210802.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-05-22T14:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16148#issuecomment-210802",
    "user": "@jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_210803.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-05-22T14:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16148#issuecomment-210803",
    "user": "@jdemeyer"
}
```

New commits:



---

archive/issue_comments_210804.json:
```json
{
    "body": "Looks good to me. But Christoph Lauter sitting next to me noticed that expressions like `1.0/0.0` raise the *Division by zero* FP exception, while IEEE-754 conversions are supposed to raise *Overflow* when the result is too large to be represented in the target format.\n\nAnother minor issue is that your `mpz_get_d_nearest` actually assumes that the current hardware rounding mode is round-to-nearest, because the final call to `ldexp` can overflow:\n\n```\nsage: b = 2^1024-1\nsage: float(b)\ninf\nsage: from ctypes import cdll                                                                 \nsage: from ctypes.util import find_library                                                    \nsage: libm = cdll.LoadLibrary(find_library('m'))                                              \nsage: FE_TOWARDZERO = int(0xc00)                                                              \nsage: libm.fesetround(FE_TOWARDZERO)\n0\nsage: float(b)\n1.7976931348623157e+308\n```\n\n\nBut I don't know if we really want to go into this kind of business in sage, and your patch clearly improves the previous implementation. So I'll give it positive review and let you decide if you want to support FP flags and non-default rounding modes.\n\nChristoph also suggests to simplify the code a bit by remplacing the part that rounds from 64 to 63 bits by something like\n\n```\nd = <double> ((q64 << 1 ) | !remainder_is_zero)\n```\n\n(Of course, this version also assumes that the FPU rounds to nearest.)",
    "created_at": "2014-05-27T13:49:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16148#issuecomment-210804",
    "user": "@mezzarobba"
}
```

Looks good to me. But Christoph Lauter sitting next to me noticed that expressions like `1.0/0.0` raise the *Division by zero* FP exception, while IEEE-754 conversions are supposed to raise *Overflow* when the result is too large to be represented in the target format.

Another minor issue is that your `mpz_get_d_nearest` actually assumes that the current hardware rounding mode is round-to-nearest, because the final call to `ldexp` can overflow:

```
sage: b = 2^1024-1
sage: float(b)
inf
sage: from ctypes import cdll                                                                 
sage: from ctypes.util import find_library                                                    
sage: libm = cdll.LoadLibrary(find_library('m'))                                              
sage: FE_TOWARDZERO = int(0xc00)                                                              
sage: libm.fesetround(FE_TOWARDZERO)
0
sage: float(b)
1.7976931348623157e+308
```


But I don't know if we really want to go into this kind of business in sage, and your patch clearly improves the previous implementation. So I'll give it positive review and let you decide if you want to support FP flags and non-default rounding modes.

Christoph also suggests to simplify the code a bit by remplacing the part that rounds from 64 to 63 bits by something like

```
d = <double> ((q64 << 1 ) | !remainder_is_zero)
```

(Of course, this version also assumes that the FPU rounds to nearest.)



---

archive/issue_comments_210805.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-27T13:49:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16148#issuecomment-210805",
    "user": "@mezzarobba"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_210806.json:
```json
{
    "body": "Another minor point in case you decide to further improve the implementation: why test it with `ZZ((2^53 - 3/4) * 2^971)` rather than `ZZ((2^53 - 1/2) * 2^971) - 1`?",
    "created_at": "2014-05-27T13:53:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16148#issuecomment-210806",
    "user": "@mezzarobba"
}
```

Another minor point in case you decide to further improve the implementation: why test it with `ZZ((2^53 - 3/4) * 2^971)` rather than `ZZ((2^53 - 1/2) * 2^971) - 1`?



---

archive/issue_comments_210807.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-05-29T14:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16148#issuecomment-210807",
    "user": "@vbraun"
}
```

Resolution: fixed
