# Issue 31214: Faster version of longest_increasing_subsequences

Issue created by migration from https://trac.sagemath.org/ticket/31451

Original creator: @petermoraw

Original creation time: 2021-03-03 23:08:54

CC:  nadialafreniere enadeau tscrim

Keywords: permutation, subsequences

The algorithm for the longest_increasing_subsequences function for permutations is currently very inefficient. I worked on a new version that vastly improves the run time of the function. 
New version:


```
sage: %timeit Permutations(30).random_element().longest_increasing_subsequences()                                     
19.6 ms ± 2.28 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```


Old version:


```
sage: %timeit Permutations(30).random_element().longest_increasing_subsequences()                                     
The slowest run took 10.40 times longer than the fastest. This could mean that an intermediate result is being cached.
3min 34s ± 2min 47s per loop (mean ± std. dev. of 7 runs, 1 loop each)
```



---

Comment by nadialafreniere created at 2021-03-03 23:37:51

New commits:


---

Comment by nadialafreniere created at 2021-03-03 23:37:51

Changing status from new to needs_review.


---

Comment by chapoton created at 2021-03-04 07:46:19

* when citing a reference, you should append an underscore, like this

```
[Sch1961]_
```


* Do not use "Returns" in the first line of doc, but "Return"


---

Comment by chapoton created at 2021-03-04 15:13:17

and patchbot complains about

```
src/doc/en/reference/references/index.rst  # Tab character found
```



---

Comment by tscrim created at 2021-03-06 03:47:00

I think `seq == sorted(seq)` would be better replaced by

```
all(seq[i] <= seq[i+1] for i in range(len(seq)-1))
```


Also, is there a way you can avoid all of the calls to `index` here:

```
self.index(seq[j]) < self.index(seq[j+1]):
```

I feel like there should be a better way to track things, otherwise this could run in `O(len(seq)^2)` (maybe `O(log(len(seq)*len(seq))`) time.

You can remove this useless list

```diff
-        potential_sequences = list(itertools.product(*s))
-        for seq in potential_sequences:
+        for seq in itertools.product(*s):
```


I think it is cleaner to write `j += 1` instead of `j = j+1`. It might also be marginally faster.


---

Comment by git created at 2021-03-15 04:04:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2021-03-15 08:48:43

you still have not fixed comment:3 and comment:4


---

Comment by tscrim created at 2021-03-15 22:33:07

Nor have you commented on why you did not implement all of the suggestions from comment:6.


---

Comment by nadialafreniere created at 2021-03-16 12:28:03

Changing status from needs_review to needs_work.


---

Comment by git created at 2021-03-17 17:40:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by enadeau created at 2021-03-18 10:29:31

About comment:6, you actually don't need to use `index` at all. You can do a single pass on your permutation to check if the element of seq appear in the right order in your permutation.


---

Comment by mkoeppe created at 2021-03-24 02:04:25

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.


---

Comment by kdilks created at 2021-07-05 23:05:32

There's a clever Python way to check if one sequence is a subsequence of another with a single pass ( https://stackoverflow.com/questions/24017363/how-to-test-if-one-string-is-a-subsequence-of-another ):


```
def is_subseq(x, y):
    it = iter(y)
    return all(c in it for c in x)
```


Short enough that you could eliminate the helper function and go with


```
it = iter(self)
if seq == sorted(seq) and all(c in it for c in seq):
```


though including the helper function with the name may make code more transparent.

Were there any other lingering concerns besides fixing that helper function? If no other concerns and no preference between in-line vs helper function, I'll pick one, push the change and set to 'needs review'.


---

Comment by nadialafreniere created at 2021-07-07 15:06:04

I tried to implement Kevin's solution, but it runs slower than Peter's proposed solution on my computer. I agree that the code would look better, though.
I think that Peter is working on a clever and much faster solution that would involve a directed graph to store the potential increasing subsequences. That would reduce the number of sequences to check, and they would automatically be subsequences of the permutation (so there would be no need to check that they indeed are; getting rid of the problem pointed out here).

Maybe Peter can confirm my thoughts and update us with where he is in the process.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by nadialafreniere created at 2022-07-15 16:22:54

Changing status from needs_work to needs_review.


---

Comment by nadialafreniere created at 2022-07-15 16:22:54

Peter decided to leave the project. I took his ideas as well as some ideas from Finn Hulse, another student I had in my class, to write the patch that should solve the problem. Instead of listing all potential longest increasing subsequences and checking for their presence in the sequence, it uses a directed graph in which all the paths from a source vertex to a sink are longest increasing subsequences.

As for speeding up the solution, I get the following results:

```
sage: %timeit Permutations(30).random_element().longest_increasing_subsequences()
416 µs ± 6.73 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit Permutations(100).random_element().longest_increasing_subsequences()
3.34 ms ± 291 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```


In comparison, with the code currently in Sage 9.7.beta5, I get

```
sage: %timeit Permutations(30).random_element().longest_increasing_subsequences()
The slowest run took 34.93 times longer than the fastest. This could mean that an intermediate result is being cached.
6min 27s ± 6min 38s per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

----
New commits:


---

Comment by nadialafreniere created at 2022-07-15 19:33:40

Sorry, I realized I push the wrong branch. Will push the correct one soon.


---

Comment by nadialafreniere created at 2022-07-15 20:07:29

Fixed the branch issue.


---

Comment by vdelecroix created at 2022-07-21 21:02:08

I think the end would be clearer as

```diff
-        increasing_subsequences = []
    
        for i in columns[0]:
            D.add_edge(0, i)  # 0 is source
        for i in columns[-1]:
            D.add_edge(i, n+1) # n+1 is sink

-        for p in D.all_paths(0, n+1):
-            increasing_subsequences.append(p[1:-1])
+        increasing_subsequences = [p[1:-1] for p in D.all_paths(0, n+1)]
```



---

Comment by vdelecroix created at 2022-07-21 21:06:00

Another detail,

```
        increasing_subsequences.sort()
        increasing_subsequences.reverse()
```

would better be

```
        increasing_subsequences.sort(reverse=True)
```



---

Comment by vdelecroix created at 2022-07-21 21:12:18

Wouldn't it be more efficient to keep the lists in `columns` sorted so that one can do early stop

```
for k in columns[j-1]:
    if k >= self[i]:
        break
    D.add_edge(k, self[i])
```

Of course keeping them sorted imposes a `log(|size|)` for insertion + something smarter than a list as a data structure.


---

Comment by git created at 2022-07-22 16:23:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nadialafreniere created at 2022-07-22 16:24:12

Thanks, Vincent, for your comments. I implemented the changes to the end of the code. I believe it is more readable now.

Replying to [comment:25 vdelecroix]:
> Wouldn't it be more efficient to keep the lists in `columns` sorted so that one can do early stop
> {{{
> for k in columns[j-1]:
>     if k >= self[i]:
>         break
>     D.add_edge(k, self[i])
> }}}
> Of course keeping them sorted imposes a `log(|size|)` for insertion + something smarter than a list as a data structure.

That would indeed be more efficient. I'm trying to think of the appropriate data structure for it, but I'm not sure how to handle this in order to keep it efficient. Did you have anything in mind?


---

Comment by dcoudert created at 2022-07-23 10:07:33

You can maintain the elements in a column sorted using

```
sage: from bisect import insort
sage: L = []
sage: for e in Permutations(30).random_element():
....:     insort(L, e)
sage: print(L)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]
```


You can also avoid the call to method `self.longest_increasing_subsequence_length` and ensure that both `use `first_row_p_tableau` and `columns[j]` are sorted. Overall this is faster than your current code.

```
def longest_increasing_subsequences(self):
    r"""
    """
    n = self.size()
    if not n:
        return([[]])

    from bisect import insort

    # getting the column in which each element is inserted
    first_row_p_tableau = []
    columns = []
    D = DiGraph(n+2)
    for x in self:
        j = bisect(first_row_p_tableau, x)
        if j == len(first_row_p_tableau):
            if columns:
                for k in columns[-1]:
                    if k >= x:
                        break
                    D.add_edge(k, x)
            first_row_p_tableau.append(x)
            columns.append([x])
        else:
            first_row_p_tableau[j] = x
            insort(columns[j], x)
            if j:
                for k in columns[j-1]:
                    if k >= x:
                        break
                    D.add_edge(k, x)

    for i in columns[0]:
        D.add_edge(0, i)  # 0 is source
    for i in columns[-1]:
        D.add_edge(i, n+1)  # n+1 is sink

    return sorted([p[1:-1] for p in D.all_paths(0, n+1)], reverse=True)
```



---

Comment by vdelecroix created at 2022-07-25 07:29:52

I did not know about `bisect.insort`. The Python implementation of list uses contiguous array so that insertion is `O(n)` and not `O(log n)`. A priori, using balanced search tree would be more efficient here : iterating through them is `O(1)` per element and insertion is `O(log n)`. Browsing quickly, I found https://pypi.org/project/blist/. But since we are dealing with integers, I would go with the `bstree` from `boost` in C++. Not sure it is worth implementing it, but it could be mentioned as a remark in the code.


---

Comment by dcoudert created at 2022-07-25 08:43:15

Right, insort is `O(n)`.  What we need here is a data structure with quick insert and enabling to iterate over the elements in increasing order without extra cost...


---

Comment by git created at 2022-07-25 15:58:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nadialafreniere created at 2022-07-25 16:03:59

Thanks, David. I did not know about bisect either. That's a great improvement!
I left the columns into sorted lists and did not implement the BST mostly because I think that the code is easier to read this way and because the code is still pretty fast. Given how slow it used to be, I doubt anyone ever used this code on large permutations. As suggested by Vincent, I added a note to the docstring about it. If others think a more efficient data structure is worth implementing, I would also be fine with it.


---

Comment by vdelecroix created at 2022-07-25 16:30:51

Nadia, you need a line break after `.. NOTE::` as in

```
        .. NOTE::

            This algorithm could be made faster using a balanced search tree
            for each column instead of sorted lists. See discussion on
            :trac:`31451`.
```



---

Comment by vdelecroix created at 2022-07-25 16:32:47

The rest looks perfectly good to me. Thanks.


---

Comment by dcoudert created at 2022-07-25 16:40:42

and also 2 spaces before comments. Just a coding style.

```diff
-            D.add_edge(i, n+1) # n+1 is sink
+            D.add_edge(i, n+1)  # n+1 is sink
```


I also think that this code is good enough for now.


---

Comment by git created at 2022-07-25 17:24:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nadialafreniere created at 2022-07-25 17:25:33

Replying to [comment:35 vdelecroix]:
> The rest looks perfectly good to me. Thanks.


Thanks, Vincent. I just fixed the formatting.


---

Comment by vdelecroix created at 2022-07-25 17:27:50

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-08-01 20:23:14

Resolution: fixed
