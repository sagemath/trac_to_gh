# Issue 15472: silent conversion of mod to int

archive/issues_015472.json:
```json
{
    "body": "CC:  mmezzarobba jakobkroeker\n\nFrom the [google notebook bug reports](https://spreadsheets.google.com/pub?key=pCwvGVwSMxTzT6E2xNdo5fA)\n\n```\n# I lost several hours because Sage silently converted a number defined mod n to an integer \n# when it appeared as an exponent.\n# I was working in a different cyclotomic field, but the problem is right here in the complex numbers.\n# I believe I should have to explicitly convert to an integer unless the answer only depends on the value mod n.\na=Mod(3,2)\nprint type(a),a,2*a,(i^2)^a,i^(2*a)\n\nOutput:\n<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'> 1 0 -1 1\n```\n\n\n*This must surely have been discussed before. I would have tried to look up the discussion if I thought there was any hope that someone could convince me that this is not actually a bug.*\n\n*Mod is not a synonym for remainder, and Sage is very good about not making the answer an integer. By later silently converting the answer into a remainder it has forsaken me, and undermined my trust.*\n\n(P.S.: The \"I\" above is not me. -ppurka)\n\nIssue created by migration from https://trac.sagemath.org/ticket/15709\n\n",
    "created_at": "2014-01-22T16:40:57Z",
    "labels": [
        "coercion",
        "major",
        "bug"
    ],
    "title": "silent conversion of mod to int",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15472",
    "user": "ppurka"
}
```
CC:  mmezzarobba jakobkroeker

From the [google notebook bug reports](https://spreadsheets.google.com/pub?key=pCwvGVwSMxTzT6E2xNdo5fA)

```
# I lost several hours because Sage silently converted a number defined mod n to an integer 
# when it appeared as an exponent.
# I was working in a different cyclotomic field, but the problem is right here in the complex numbers.
# I believe I should have to explicitly convert to an integer unless the answer only depends on the value mod n.
a=Mod(3,2)
print type(a),a,2*a,(i^2)^a,i^(2*a)

Output:
<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'> 1 0 -1 1
```


*This must surely have been discussed before. I would have tried to look up the discussion if I thought there was any hope that someone could convince me that this is not actually a bug.*

*Mod is not a synonym for remainder, and Sage is very good about not making the answer an integer. By later silently converting the answer into a remainder it has forsaken me, and undermined my trust.*

(P.S.: The "I" above is not me. -ppurka)

Issue created by migration from https://trac.sagemath.org/ticket/15709





---

archive/issue_comments_199918.json:
```json
{
    "body": "Actually, I don't see what is the problem with the output. `2*a = 0 mod 2`, so `i^0` is 1. And `i^2 = -1`, so the outputs seem correct. Was the OP expecting an error from taking the power?",
    "created_at": "2014-01-23T03:57:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199918",
    "user": "ppurka"
}
```

Actually, I don't see what is the problem with the output. `2*a = 0 mod 2`, so `i^0` is 1. And `i^2 = -1`, so the outputs seem correct. Was the OP expecting an error from taking the power?



---

archive/issue_comments_199919.json:
```json
{
    "body": "Replying to [comment:1 ppurka]:\n> Actually, I don't see what is the problem with the output. `2*a = 0 mod 2`, so `i^0` is 1. And `i^2 = -1`, so the outputs seem correct. Was the OP expecting an error from taking the power?\nI think his issue is with the last entry, `i^(2*a)==1`. I think he expected an error because the exponent is in `Z/2Z` and not in `Z/4Z`.\n\nIt would indeed be nicer if sage would refuse to let `Z/nZ` act on the right on rings by exponentiation. It's not well-defined, unless you're looking at an `d`-th root of unity, where `d` is a divisor of `n`.",
    "created_at": "2014-01-23T05:47:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199919",
    "user": "nbruin"
}
```

Replying to [comment:1 ppurka]:
> Actually, I don't see what is the problem with the output. `2*a = 0 mod 2`, so `i^0` is 1. And `i^2 = -1`, so the outputs seem correct. Was the OP expecting an error from taking the power?
I think his issue is with the last entry, `i^(2*a)==1`. I think he expected an error because the exponent is in `Z/2Z` and not in `Z/4Z`.

It would indeed be nicer if sage would refuse to let `Z/nZ` act on the right on rings by exponentiation. It's not well-defined, unless you're looking at an `d`-th root of unity, where `d` is a divisor of `n`.



---

archive/issue_comments_199920.json:
```json
{
    "body": "So, I suppose this should be fixed for complex numbers and some cyclotomic fields. Where the `__pow__` method raises `ValueError` if the exponent does not belong to `(ZZ, int, float, RR, RDF, CC, CDF)` - can there be any other field in that tuple?",
    "created_at": "2014-01-23T15:22:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199920",
    "user": "ppurka"
}
```

So, I suppose this should be fixed for complex numbers and some cyclotomic fields. Where the `__pow__` method raises `ValueError` if the exponent does not belong to `(ZZ, int, float, RR, RDF, CC, CDF)` - can there be any other field in that tuple?



---

archive/issue_comments_199921.json:
```json
{
    "body": "Replying to [comment:3 ppurka]:\n> So, I suppose this should be fixed for complex numbers and some cyclotomic fields. Where the `__pow__` method raises `ValueError` if the exponent does not belong to `(ZZ, int, float, RR, RDF, CC, CDF)` - can there be any other field in that tuple?\n\nIs the code that specific? For a general ring, we'd probably want that the exponent is coercible into ZZ. For rings where fractional exponents are meaningful it would be QQ (but multivaluedness of the result is always an issue of course). For some analytic objects we can support even more general exponents. So in SR the issue probably remains, because one can wrap an element of ZZ/2ZZ in a symbolic expression.\n\nWhat happens now is probably that the code asks whether the exponent can be *turned into* an integer (i.e., asks for a conversion). Of course there is a conversion from ZZ/2ZZ to ZZ.",
    "created_at": "2014-01-23T16:36:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199921",
    "user": "nbruin"
}
```

Replying to [comment:3 ppurka]:
> So, I suppose this should be fixed for complex numbers and some cyclotomic fields. Where the `__pow__` method raises `ValueError` if the exponent does not belong to `(ZZ, int, float, RR, RDF, CC, CDF)` - can there be any other field in that tuple?

Is the code that specific? For a general ring, we'd probably want that the exponent is coercible into ZZ. For rings where fractional exponents are meaningful it would be QQ (but multivaluedness of the result is always an issue of course). For some analytic objects we can support even more general exponents. So in SR the issue probably remains, because one can wrap an element of ZZ/2ZZ in a symbolic expression.

What happens now is probably that the code asks whether the exponent can be *turned into* an integer (i.e., asks for a conversion). Of course there is a conversion from ZZ/2ZZ to ZZ.



---

archive/issue_comments_199922.json:
```json
{
    "body": "Yes, the `__pow__` method seems different between RR, CC, QQ, number fields -- and these are the ones I checked just now. I have no idea how to fix this method in general.",
    "created_at": "2014-01-23T16:48:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199922",
    "user": "ppurka"
}
```

Yes, the `__pow__` method seems different between RR, CC, QQ, number fields -- and these are the ones I checked just now. I have no idea how to fix this method in general.



---

archive/issue_comments_199923.json:
```json
{
    "body": "In addition I suggest to print for each result its parent (or related type) like Macaulay2 does:\n\n```\ni1 : QQ[x]\no1 = QQ[x]\no1 : PolynomialRing\ni2 : x\no2 = x\no2 : QQ[x]\n}}",
    "created_at": "2017-03-03T23:10:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199923",
    "user": "jakobkroeker"
}
```

In addition I suggest to print for each result its parent (or related type) like Macaulay2 does:

```
i1 : QQ[x]
o1 = QQ[x]
o1 : PolynomialRing
i2 : x
o2 = x
o2 : QQ[x]
}}



---

archive/issue_comments_199924.json:
```json
{
    "body": "I added a pointer from #24247 to here. Disallowing powering by `IntegerMod` elements is easy.\n\nThe hard part is allowing `x ^ Mod(a, n)` only where it makes sense. If we do that, ideally it should be done using generic code. Something like:\n\n```\ndef pow_intmod(x, a, n):\n    if x^n != 1:\n        raise ArithmeticError(\"power not defined\")\n    return x^a\n```\n\nThe problem is that checking `x^n != 1` costs performance and that it might not work properly in non-exact rings.",
    "created_at": "2018-01-08T14:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15472",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15472#issuecomment-199924",
    "user": "jdemeyer"
}
```

I added a pointer from #24247 to here. Disallowing powering by `IntegerMod` elements is easy.

The hard part is allowing `x ^ Mod(a, n)` only where it makes sense. If we do that, ideally it should be done using generic code. Something like:

```
def pow_intmod(x, a, n):
    if x^n != 1:
        raise ArithmeticError("power not defined")
    return x^a
```

The problem is that checking `x^n != 1` costs performance and that it might not work properly in non-exact rings.
