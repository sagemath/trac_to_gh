# Issue 15472: silent conversion of mod to int

Issue created by migration from Trac.

Original creator: ppurka

Original creation time: 2014-01-22 16:40:57

CC:  mmezzarobba jakobkroeker

From the [google notebook bug reports](https://spreadsheets.google.com/pub?key=pCwvGVwSMxTzT6E2xNdo5fA)

```
# I lost several hours because Sage silently converted a number defined mod n to an integer 
# when it appeared as an exponent.
# I was working in a different cyclotomic field, but the problem is right here in the complex numbers.
# I believe I should have to explicitly convert to an integer unless the answer only depends on the value mod n.
a=Mod(3,2)
print type(a),a,2*a,(i^2)^a,i^(2*a)

Output:
<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'> 1 0 -1 1
```


_This must surely have been discussed before. I would have tried to look up the discussion if I thought there was any hope that someone could convince me that this is not actually a bug._

_Mod is not a synonym for remainder, and Sage is very good about not making the answer an integer. By later silently converting the answer into a remainder it has forsaken me, and undermined my trust._

(P.S.: The "I" above is not me. -ppurka)


---

Comment by ppurka created at 2014-01-23 03:57:26

Actually, I don't see what is the problem with the output. `2*a = 0 mod 2`, so `i^0` is 1. And `i^2 = -1`, so the outputs seem correct. Was the OP expecting an error from taking the power?


---

Comment by nbruin created at 2014-01-23 05:47:12

Replying to [comment:1 ppurka]:
> Actually, I don't see what is the problem with the output. `2*a = 0 mod 2`, so `i^0` is 1. And `i^2 = -1`, so the outputs seem correct. Was the OP expecting an error from taking the power?
I think his issue is with the last entry, `i^(2*a)==1`. I think he expected an error because the exponent is in `Z/2Z` and not in `Z/4Z`.

It would indeed be nicer if sage would refuse to let `Z/nZ` act on the right on rings by exponentiation. It's not well-defined, unless you're looking at an `d`-th root of unity, where `d` is a divisor of `n`.


---

Comment by ppurka created at 2014-01-23 15:22:11

So, I suppose this should be fixed for complex numbers and some cyclotomic fields. Where the `__pow__` method raises `ValueError` if the exponent does not belong to `(ZZ, int, float, RR, RDF, CC, CDF)` - can there be any other field in that tuple?


---

Comment by nbruin created at 2014-01-23 16:36:12

Replying to [comment:3 ppurka]:
> So, I suppose this should be fixed for complex numbers and some cyclotomic fields. Where the `__pow__` method raises `ValueError` if the exponent does not belong to `(ZZ, int, float, RR, RDF, CC, CDF)` - can there be any other field in that tuple?

Is the code that specific? For a general ring, we'd probably want that the exponent is coercible into ZZ. For rings where fractional exponents are meaningful it would be QQ (but multivaluedness of the result is always an issue of course). For some analytic objects we can support even more general exponents. So in SR the issue probably remains, because one can wrap an element of ZZ/2ZZ in a symbolic expression.

What happens now is probably that the code asks whether the exponent can be *turned into* an integer (i.e., asks for a conversion). Of course there is a conversion from ZZ/2ZZ to ZZ.


---

Comment by ppurka created at 2014-01-23 16:48:07

Yes, the `__pow__` method seems different between RR, CC, QQ, number fields -- and these are the ones I checked just now. I have no idea how to fix this method in general.


---

Comment by jakobkroeker created at 2017-03-03 23:10:26

In addition I suggest to print for each result its parent (or related type) like Macaulay2 does:

```
i1 : QQ[x]
o1 = QQ[x]
o1 : PolynomialRing
i2 : x
o2 = x
o2 : QQ[x]
}}


---

Comment by jdemeyer created at 2018-01-08 14:54:47

I added a pointer from #24247 to here. Disallowing powering by `IntegerMod` elements is easy.

The hard part is allowing `x ^ Mod(a, n)` only where it makes sense. If we do that, ideally it should be done using generic code. Something like:

```
def pow_intmod(x, a, n):
    if x^n != 1:
        raise ArithmeticError("power not defined")
    return x^a
```

The problem is that checking `x^n != 1` costs performance and that it might not work properly in non-exact rings.
