# Issue 16643: even faster prime_powers

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2014-08-26 11:09:37

CC:  ncohen jdemeyer

The cythonization of `prime_powers` is much faster (around x4 in the timings). We also introduce the keyword `py_ints` as in `prime_range` in order to be able to use Python int instead of Sage integers.

Note: I do not like the convention that the name are different `prime_powers` vs `prime_range`... why not using `primes` or `prime_power_range`?


---

Comment by ncohen created at 2014-08-26 11:29:54

+1 for "primes"


---

Comment by vdelecroix created at 2014-08-26 11:54:42

Changing status from new to needs_review.


---

Comment by git created at 2014-08-26 12:01:20

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2014-08-28 20:23:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2014-08-28 20:25:27

Rebased on 6.4.beta2, no dependency anymore...

Vincent


---

Comment by git created at 2014-08-30 16:36:55

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2014-08-30 16:39:19

And with timings

using `prime_powers` (EDIT: only for commit at a3195f7 and not at e3be1ce)

```
sage: timeit("prime_powers(1000)", number=4000)
4000 loops, best of 3: 86.7 µs per loop
sage: timeit("prime_powers(5000)", number=2000)
2000 loops, best of 3: 314 µs per loop
```


using `prime_power_range` instead

```
sage: timeit("prime_power_range(1000)", number=4000)
4000 loops, best of 3: 17.6 µs per loop
sage:  timeit("prime_power_range(5000)", number=2000)
2000 loops, best of 3: 72.3 µs per loop
```


using `prime_power_range` with `py_ints=True`

```
sage: timeit("prime_power_range(1000,py_ints=True)", number=4000)
4000 loops, best of 3: 14.6 µs per loop
sage:  timeit("prime_power_range(5000,py_ints=True)", number=2000)
2000 loops, best of 3: 33.9 µs per loop
```



---

Comment by git created at 2014-08-31 09:44:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2014-08-31 09:45:41

It looks more natural to me to follow what `primes` and `prime_range` do... this is what I did in e3be1ce.

Vincent


---

Comment by jdemeyer created at 2015-03-09 09:30:21

Needs rebase.


---

Comment by jdemeyer created at 2015-03-09 09:30:21

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-03-21 17:07:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by vdelecroix created at 2015-03-21 17:10:11

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-03-21 18:08:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-25 10:51:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-04-25 11:20:45

I split the other parts to different tickets: #18298 and #18299.


---

Comment by jdemeyer created at 2015-04-28 09:11:30

1. I don't know if `lesser or equal than` is proper English. How about `less than or equal to`?

2. `PARI` instead of `Pari`.

3. In `next_prime_power` and `previous_prime_power`, a small optimization is possible: you can replace

```
mpz_set(n.value, self.value)
mpz_add_ui(n.value, n.value, 1)
```

by

```
mpz_add_ui(n.value, self.value, 1)
```


and in `next_prime_power`, replace

```
if mpz_cmp_ui(n.value, 2) < 0:
    mpz_set_ui(n.value, 2)
    return n
```

by

```
if mpz_cmp_ui(self.value, 2) < 0:
    return smallInteger(2)
```


4. Another algorithmic comment for `next_prime_power` (an analogous comment holds for `previous_prime_power`): instead of computing the next power of 2 and doing

```
while mpz_cmp(m.value, n.value) == 1:
```

I would instead check if `mpz_sizeinbase(n.value, 2)` increases during the loop. In that case, we know that we skipped a power of 2.


---

Comment by jdemeyer created at 2015-04-28 09:11:39

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-04-28 10:44:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-04-28 10:54:56

Replying to [comment:20 jdemeyer]:
 
> 4. Another algorithmic comment for `next_prime_power` (an analogous comment holds for `previous_prime_power`): instead of computing the next power of 2 and doing
> {{{
> while mpz_cmp(m.value, n.value) == 1:
> }}}
> I would instead check if `mpz_sizeinbase(n.value, 2)` increases during the loop. In that case, we know that we skipped a power of 2.

I used `mpz_tstbit` instead. Should be the fastest.

Potential micro optimization that would need to use `mpn_*` functions
 - the call to `mpz_sizeinbase` can be replaced by `mpn_count_leading_zeros` and some arithmetic
 - we can avoid a useless bit shift in `mpz_tstbit` by only considering the `&` with the most significant limb. Moreover, the allocation of the limbs will not change inside the loop. So we can already use the good pointer to the concerned limb.

I think this is too much for a naive algorithm...


---

Comment by vdelecroix created at 2015-04-28 10:54:56

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2015-04-28 11:20:52

`skept` -> `skipped`

This should be moved _after_ the comparison with 2 (and `self` should be compared with 2):

```
cdef Integer n = PY_NEW(Integer)
```


Another simplification that I missed: you can skip the block

```
    if mpz_even_p(n.value):
    if n.is_prime_power(proof=proof):
    return n
    mpz_add_ui(n.value, n.value, 1)
```

if you instead just add 2 if `self` was odd:

```
mpz_add_ui(n.value, self.value, 1 if mpz_even_p(self.value) else 2)
```


Then the `bit_index` should be based on the value of `self`, such that the check works correctly if `self` was `2^n - 1`.


---

Comment by jdemeyer created at 2015-04-28 11:20:52

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-04-28 11:51:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-04-28 11:52:20

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2015-04-28 15:24:25

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-04-29 03:13:45

Resolution: fixed


---

Comment by leif created at 2015-05-06 07:16:06

Some copy/paste accidents (could probably be corrected on the follow-ups):


```
+    def previous_prime(self, proof=None):
+        r"""
+        Returns the previous prime before self.
+
+        This method calls the PARI ``precprime`` function.
+
+        INPUT:
+
+        - ``proof`` - if ``True`` ensure that the returned value is the next
+          prime power and if set to ``False`` uses probabilistic methods
+          (i.e. the result is not guaranteed). By default it uses global
+          configuration variables to determine which alternative to use (see
+          :mod:`proof.arithmetic` or :mod:`sage.structure.proof`).
```


```
+    def previous_prime_power(self, proof=None):
+        r"""
+        Return the previous prime power before self.
+
+        INPUT:
+
+        - ``proof`` - if ``True`` ensure that the returned value is the next
+          prime power and if set to ``False`` uses probabilistic methods
+          (i.e. the result is not guaranteed). By default it uses global
+          configuration variables to determine which alternative to use (see
+          :mod:`proof.arithmetic` or :mod:`sage.structure.proof`).
```



---

Comment by vdelecroix created at 2015-05-06 07:18:27

Replying to [comment:29 leif]:
> Some copy/paste accidents (could probably be corrected on the follow-ups):

Ha right.
