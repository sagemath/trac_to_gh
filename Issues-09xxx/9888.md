# Issue 9888: matrix multiplication over integer mod ring is slow

archive/issues_009887.json:
```json
{
    "assignees": [],
    "body": "Sage 4.5.3, 2.6GHz Opteron, Linux\n\nThis is ok:\n\n```\nsage: M1 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])\nsage: M2 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])\nsage: timeit(\"M3 = M1 * M2\")\n5 loops, best of 3: 45.6 ms per loop\n```\n\n(That's about 4 times slower than Magma, but I can put up with that, that's a ticket for another day.)\n\nHere is the problem:\n\n```\nsage: R = Integers(3^20)\nsage: M1 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])\nsage: M2 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])\nsage: timeit(\"M3 = M1 * M2\")\n5 loops, best of 3: 877 ms per loop\n```\n\nIn other words, I can multiply the matrices over R roughly 20x faster by multiplying over Z and then reducing! That's ridiculous!\n\n\nKeywords: **sd90**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/9888_\n\n",
    "created_at": "2010-09-09T16:21:26Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/performance",
        "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "matrix multiplication over integer mod ring is slow",
    "type": "issue",
    "updated_at": "2017-10-24T04:22:51Z",
    "url": "https://github.com/sagemath/sage/issues/9888",
    "user": "https://github.com/sagetrac-dmharvey"
}
```
Sage 4.5.3, 2.6GHz Opteron, Linux

This is ok:

```
sage: M1 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])
sage: M2 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])
sage: timeit("M3 = M1 * M2")
5 loops, best of 3: 45.6 ms per loop
```

(That's about 4 times slower than Magma, but I can put up with that, that's a ticket for another day.)

Here is the problem:

```
sage: R = Integers(3^20)
sage: M1 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])
sage: M2 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])
sage: timeit("M3 = M1 * M2")
5 loops, best of 3: 877 ms per loop
```

In other words, I can multiply the matrices over R roughly 20x faster by multiplying over Z and then reducing! That's ridiculous!


Keywords: **sd90**

_Issue created by migration from https://trac.sagemath.org/ticket/9888_





---

archive/issue_events_117092.json:
```json
{
    "actor": "https://github.com/sagetrac-dmharvey",
    "created_at": "2010-09-09T16:21:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "label": "https://github.com/sagemath/sage/labels/performance",
    "label_color": "696969",
    "label_name": "performance",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/9888#event-117092"
}
```



---

archive/issue_events_117093.json:
```json
{
    "actor": "https://github.com/sagetrac-dmharvey",
    "created_at": "2010-09-09T16:21:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/9888#event-117093"
}
```



---

archive/issue_events_117094.json:
```json
{
    "actor": "https://github.com/sagetrac-dmharvey",
    "created_at": "2010-09-09T16:21:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/9888#event-117094"
}
```



---

archive/issue_comments_090796.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">Comment 1</div>\n\nI don't think anything has gone into non-word-sized modulus, so this is probably using totally generic per-element wrapping code :(. Should be an easy fix to get better than this, doing something real would be a bit more work.",
    "created_at": "2010-09-09T16:29:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/9888#issuecomment-90796",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:1" align="right">Comment 1</div>

I don't think anything has gone into non-word-sized modulus, so this is probably using totally generic per-element wrapping code :(. Should be an easy fix to get better than this, doing something real would be a bit more work.



---

archive/issue_comments_090797.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">Comment 2</div>\n\nI just tried the timings again:\n\n```\nsage: sage: M1 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])\nsage: sage: M2 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])\nsage: sage: timeit(\"M3 = M1 * M2\")\n125 loops, best of 3: 5.62 ms per loop\nsage: sage: R = Integers(3^20)\nsage: sage: M1 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])\nsage: sage: M2 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])\nsage: sage: timeit(\"M3 = M1 * M2\")\n5 loops, best of 3: 530 ms per loop\n```\nso now the discrepancy is up to a factor of 100!\n\nMy recollection is that lifting the multiplication up to Z is in fact the correct algorithmic approach. In practice, this hands the problem off to FLINT, where (in this size range) the multiplication is done multimodular.",
    "created_at": "2016-04-10T04:02:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/9888#issuecomment-90797",
    "user": "https://github.com/kedlaya"
}
```

<div id="comment:2" align="right">Comment 2</div>

I just tried the timings again:

```
sage: sage: M1 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])
sage: sage: M2 = Matrix([[randrange(3^20) for i in range(100)] for j in range(100)])
sage: sage: timeit("M3 = M1 * M2")
125 loops, best of 3: 5.62 ms per loop
sage: sage: R = Integers(3^20)
sage: sage: M1 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])
sage: sage: M2 = Matrix([[R.random_element() for i in range(100)] for j in range(100)])
sage: sage: timeit("M3 = M1 * M2")
5 loops, best of 3: 530 ms per loop
```
so now the discrepancy is up to a factor of 100!

My recollection is that lifting the multiplication up to Z is in fact the correct algorithmic approach. In practice, this hands the problem off to FLINT, where (in this size range) the multiplication is done multimodular.



---

archive/issue_comments_090798.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">Comment 3</div>\n\nSee #12177 for a related discussion.",
    "created_at": "2016-08-17T01:08:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/9888#issuecomment-90798",
    "user": "https://github.com/kedlaya"
}
```

<div id="comment:3" align="right">Comment 3</div>

See #12177 for a related discussion.



---

archive/issue_comments_090799.json:
```json
{
    "body": "Changed keywords from none to **sd90**",
    "created_at": "2017-10-22T18:32:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/9888#issuecomment-90799",
    "user": "https://github.com/adeines"
}
```

Changed keywords from none to **sd90**



---

archive/issue_comments_090800.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">Comment 5</div>\n\nThere appears to be special-purpose code using Linbox for modulus up to 2<sup>23</sup> in `sage/matrix/matrix_modn_dense_double.pyx` and `sage/matrix/matrix_modn_dense_float.pyx`. To handle this issue, it would be best to create a file `sage/matrix/matrix_modn_dense.pyx` in which we create the class `Matrix_modn_dense` with a special `_mul_` method. But we should make sure not to create a regression by disconnecting the existing code for smaller moduli.",
    "created_at": "2017-10-24T04:22:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/9888",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/9888#issuecomment-90800",
    "user": "https://github.com/kedlaya"
}
```

<div id="comment:5" align="right">Comment 5</div>

There appears to be special-purpose code using Linbox for modulus up to 2<sup>23</sup> in `sage/matrix/matrix_modn_dense_double.pyx` and `sage/matrix/matrix_modn_dense_float.pyx`. To handle this issue, it would be best to create a file `sage/matrix/matrix_modn_dense.pyx` in which we create the class `Matrix_modn_dense` with a special `_mul_` method. But we should make sure not to create a regression by disconnecting the existing code for smaller moduli.
