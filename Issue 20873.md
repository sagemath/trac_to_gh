# Issue 20873: Py3 : Handle the changes to "next()" again

archive/issues_020873.json:
```json
{
    "body": "as a re-play of #16075\n\nIssue created by migration from https://trac.sagemath.org/ticket/21110\n\n",
    "created_at": "2016-07-28T10:12:25Z",
    "labels": [
        "component: python3"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.3",
    "title": "Py3 : Handle the changes to \"next()\" again",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20873",
    "user": "https://github.com/fchapoton"
}
```
as a re-play of #16075

Issue created by migration from https://trac.sagemath.org/ticket/21110





---

archive/issue_comments_288267.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-07-28T10:13:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288267",
    "user": "https://github.com/fchapoton"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_288268.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-07-28T10:13:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288268",
    "user": "https://github.com/fchapoton"
}
```

New commits:



---

archive/issue_comments_288269.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-07-28T17:13:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288269",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_288270.json:
```json
{
    "body": "If I search the source for `'\\.next('`, I find lots of matches. Do some of these need to be changed, also? (Some may depend on #18802, I guess.)\n\n```\n./arith/srange.pyx:                first = more.next()\n./categories/enumerated_sets.py:       - ``S.next(e)``: the object of the set which follows ``e``; It is\n./categories/enumerated_sets.py:            # Check if .first() and .next(x) are overridden in the subclass\n./categories/enumerated_sets.py:            ``self.next(e)`` returns the element of the set ``self`` which\n./categories/enumerated_sets.py:                    f = self.next(f)\n./categories/examples/infinite_enumerated_sets.py:            sage: NN.next(3)\n./categories/examples/sets_cat.py:            sage: x = P.next(P.an_element()); x\n./categories/examples/sets_cat.py:            x = self.next(x)\n./categories/examples/sets_cat.py:                sage: p.next()\n./categories/examples/sets_cat.py:            return self.parent().next(self)\n./categories/examples/sets_cat.py:        sage: z = P.next(x); z\n./categories/examples/sets_cat.py:        sage: z = P.next(x); z\n./categories/examples/sets_cat.py:        sage: z = P.next(x); z\n./categories/examples/sets_cat.py:        sage: pf.next()\n./categories/examples/sets_cat.py:        sage: pw.next()\n./categories/examples/sets_cat.py:        sage: pi.next()\n./coding/punctured_code.py:            values = I.next()\n./coding/punctured_code.py:                    values = I.next()\n./coding/reed_muller_code.py:                xcoordinate = iterator.next()\n./combinat/combinat.py:        An iterator to use when the .first() and .next(x) methods are provided.\n./combinat/combinat.py:                f = self.next(f)\n./combinat/combinat.py:        # Check whether .first() and .next(x) are overridden in the subclass\n./combinat/combinat.py:            sage: C.next(2) # indirect doctest\n./combinat/composition.py:        sage: Compositions(4).next([1,1,2])\n./combinat/integer_vector.py:            sage: IntegerVectors(2,3,min_slope=0).next(a)\n./combinat/misc.py:            sage: dll.next(1)\n./combinat/misc.py:            sage: dll.next(1)\n./combinat/necklace.py:            j = dll.next(j)\n./combinat/necklace.py:            j = dll.next(j)\n./combinat/partition.py:Using the method ``.next(p)``, we can calculate the 'next' partition\n./combinat/partition.py:    sage: Partitions(4).next([4])\n./combinat/partition.py:    sage: Partitions(4).next([1,1,1,1]) is None\n./combinat/partition.py:            sage: Partitions(4).next([4])\n./combinat/partition.py:            sage: Partitions(4).next([1,1,1,1]) is None\n./combinat/partition.py:            sage: Partitions(3, starting=[2,1]).next(Partition([2,1]))\n./combinat/partition.py:            sage: Partitions(4, ending=[1,1,1,1]).next(Partition([4]))\n./combinat/partition.py:            sage: Partitions(4, ending=[1,1,1,1]).next(Partition([1,1,1,1])) is None\n./combinat/partition_algebra.py:            sage: y = A2p5.next(x); y\n./combinat/posets/hasse_diagram.py:            sage: it.next()\n./combinat/posets/hasse_diagram.py:            sage: it.next()\n./data_structures/bitset.pyx:        a.next(n)           4\n./data_structures/bitset.pyx:        a.next(n)           2\n./data_structures/bitset.pyx:        a.next(n)           -1\n./data_structures/bitset.pyx:        a.next(n)           71\n./data_structures/bitset.pyx:    print(\"a.next(n)          \", bitset_next(a, n))\n./graphs/strongly_regular_db.pyx:                    return twograph_descendant(g, g.vertex_iterator().next(), name=True)\n./groups/perm_gps/partn_ref/canonical_augmentation.pyx:        aug = cur_iter.next( cur_iter.data, &cgd.degree_stack[cgd.level], &cgd.mem_err )\n./groups/perm_gps/partn_ref/refinement_graphs.pyx:        edge_candidate = <subset *> degd.edge_iterator.next(degd.edge_iterator.data, NULL, &mem_err_sub)\n./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)\n./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)\n./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)\n./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)\n./groups/perm_gps/partn_ref/refinement_sets.pyx:        thing = <subset *> subset_iterator.next(subset_iterator.data, NULL, &mem_err)\n./homology/simplicial_complex.py:                F = it[-1].next()\n./misc/parser.pyx:        sage: token_to_str(t.next())\n./misc/parser.pyx:        sage: token_to_str(t.next())\n./misc/parser.pyx:        cdef int token = self.next()\n./misc/parser.pyx:            token = self.next()\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            sage: token_to_str(t.next())\n./misc/parser.pyx:            tokens.next()\n./misc/parser.pyx:        if tokens.next() != EOS:\n./misc/parser.pyx:        if tokens.next() != EOS:\n./misc/parser.pyx:        if tokens.next() != EOS:\n./misc/parser.pyx:        if tokens.next() == '(':\n./misc/parser.pyx:                token = tokens.next()\n./misc/parser.pyx:                tokens.next()\n./misc/parser.pyx:                tokens.next()\n./misc/parser.pyx:            token = tokens.next()\n./misc/parser.pyx:        cdef int token = tokens.next()\n./misc/parser.pyx:        token = tokens.next()\n./misc/parser.pyx:        cdef int token = tokens.next()\n./misc/parser.pyx:        token = tokens.next()\n./misc/parser.pyx:        cdef int op = tokens.next()\n./misc/parser.pyx:        op = tokens.next()\n./misc/parser.pyx:            op = tokens.next()\n./misc/parser.pyx:        op = tokens.next()\n./misc/parser.pyx:            op = tokens.next()\n./misc/parser.pyx:        cdef int token = tokens.next()\n./misc/parser.pyx:        cdef int token = tokens.next()\n./misc/parser.pyx:                tokens.next()\n./misc/parser.pyx:        cdef int token = tokens.next()\n./misc/parser.pyx:            token = tokens.next()\n./misc/parser.pyx:                token = tokens.next()\n./misc/parser.pyx:            token = tokens.next()\n./misc/parser.pyx:            token = tokens.next()\n./misc/parser.pyx:        cdef int token = tokens.next()\n./misc/parser.pyx:            tokens.next()\n./parallel/map_reduce.py:            sage: it.next()\n./parallel/map_reduce.py:                node = newnodes.next()\n./parallel/map_reduce.py:            sage: it.next() # random\n./parallel/map_reduce.py:            sage: it.next() # random\n./rings/fraction_field_FpT.pyx:            ....:     a = a.next()\n./rings/polynomial/pbori.pyx:        self._iter.next()\n./rings/polynomial/pbori.pyx:        self._iter.next()\n./rings/polynomial/pbori.pyx:            d = iter(M).next().degree()\n./rings/polynomial/pbori.pyx:        self._iter.next()\n./rings/polynomial/pbori.pyx:        self._iter.next()\n./rings/polynomial/pbori.pyx:        self._iter.next()\n./rings/polynomial/pbori.pyx:        start = start.next()\n./rings/polynomial/pbori.pyx:        it = it.next()\n./schemes/projective/endPN_automorphism_group.py:    p = primes.next(ZZ(prime_lower_bound))\n./schemes/projective/endPN_automorphism_group.py:        p = primes.next(p)\n./sets/integer_range.py:            sage: (I.next(0), I.next(10), I.next(-10), I.next(20), I.next(-100))\n./sets/integer_range.py:            sage: (I.next(0), I.next(10), I.next(-10), I.next(20), I.next(-100))\n./sets/integer_range.py:            sage: I.next(1)\n./sets/integer_range.py:            n = self.next(n)\n./sets/non_negative_integers.py:            sage: NN.next(3)\n./sets/primes.py:            sage: P.next(5)\n```\n",
    "created_at": "2016-07-28T18:03:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288270",
    "user": "https://github.com/jhpalmieri"
}
```

If I search the source for `'\.next('`, I find lots of matches. Do some of these need to be changed, also? (Some may depend on #18802, I guess.)

```
./arith/srange.pyx:                first = more.next()
./categories/enumerated_sets.py:       - ``S.next(e)``: the object of the set which follows ``e``; It is
./categories/enumerated_sets.py:            # Check if .first() and .next(x) are overridden in the subclass
./categories/enumerated_sets.py:            ``self.next(e)`` returns the element of the set ``self`` which
./categories/enumerated_sets.py:                    f = self.next(f)
./categories/examples/infinite_enumerated_sets.py:            sage: NN.next(3)
./categories/examples/sets_cat.py:            sage: x = P.next(P.an_element()); x
./categories/examples/sets_cat.py:            x = self.next(x)
./categories/examples/sets_cat.py:                sage: p.next()
./categories/examples/sets_cat.py:            return self.parent().next(self)
./categories/examples/sets_cat.py:        sage: z = P.next(x); z
./categories/examples/sets_cat.py:        sage: z = P.next(x); z
./categories/examples/sets_cat.py:        sage: z = P.next(x); z
./categories/examples/sets_cat.py:        sage: pf.next()
./categories/examples/sets_cat.py:        sage: pw.next()
./categories/examples/sets_cat.py:        sage: pi.next()
./coding/punctured_code.py:            values = I.next()
./coding/punctured_code.py:                    values = I.next()
./coding/reed_muller_code.py:                xcoordinate = iterator.next()
./combinat/combinat.py:        An iterator to use when the .first() and .next(x) methods are provided.
./combinat/combinat.py:                f = self.next(f)
./combinat/combinat.py:        # Check whether .first() and .next(x) are overridden in the subclass
./combinat/combinat.py:            sage: C.next(2) # indirect doctest
./combinat/composition.py:        sage: Compositions(4).next([1,1,2])
./combinat/integer_vector.py:            sage: IntegerVectors(2,3,min_slope=0).next(a)
./combinat/misc.py:            sage: dll.next(1)
./combinat/misc.py:            sage: dll.next(1)
./combinat/necklace.py:            j = dll.next(j)
./combinat/necklace.py:            j = dll.next(j)
./combinat/partition.py:Using the method ``.next(p)``, we can calculate the 'next' partition
./combinat/partition.py:    sage: Partitions(4).next([4])
./combinat/partition.py:    sage: Partitions(4).next([1,1,1,1]) is None
./combinat/partition.py:            sage: Partitions(4).next([4])
./combinat/partition.py:            sage: Partitions(4).next([1,1,1,1]) is None
./combinat/partition.py:            sage: Partitions(3, starting=[2,1]).next(Partition([2,1]))
./combinat/partition.py:            sage: Partitions(4, ending=[1,1,1,1]).next(Partition([4]))
./combinat/partition.py:            sage: Partitions(4, ending=[1,1,1,1]).next(Partition([1,1,1,1])) is None
./combinat/partition_algebra.py:            sage: y = A2p5.next(x); y
./combinat/posets/hasse_diagram.py:            sage: it.next()
./combinat/posets/hasse_diagram.py:            sage: it.next()
./data_structures/bitset.pyx:        a.next(n)           4
./data_structures/bitset.pyx:        a.next(n)           2
./data_structures/bitset.pyx:        a.next(n)           -1
./data_structures/bitset.pyx:        a.next(n)           71
./data_structures/bitset.pyx:    print("a.next(n)          ", bitset_next(a, n))
./graphs/strongly_regular_db.pyx:                    return twograph_descendant(g, g.vertex_iterator().next(), name=True)
./groups/perm_gps/partn_ref/canonical_augmentation.pyx:        aug = cur_iter.next( cur_iter.data, &cgd.degree_stack[cgd.level], &cgd.mem_err )
./groups/perm_gps/partn_ref/refinement_graphs.pyx:        edge_candidate = <subset *> degd.edge_iterator.next(degd.edge_iterator.data, NULL, &mem_err_sub)
./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)
./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)
./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)
./groups/perm_gps/partn_ref/refinement_graphs.pyx:            thing = graph_iterator.next(graph_iterator.data, NULL, &mem_err)
./groups/perm_gps/partn_ref/refinement_sets.pyx:        thing = <subset *> subset_iterator.next(subset_iterator.data, NULL, &mem_err)
./homology/simplicial_complex.py:                F = it[-1].next()
./misc/parser.pyx:        sage: token_to_str(t.next())
./misc/parser.pyx:        sage: token_to_str(t.next())
./misc/parser.pyx:        cdef int token = self.next()
./misc/parser.pyx:            token = self.next()
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            sage: token_to_str(t.next())
./misc/parser.pyx:            tokens.next()
./misc/parser.pyx:        if tokens.next() != EOS:
./misc/parser.pyx:        if tokens.next() != EOS:
./misc/parser.pyx:        if tokens.next() != EOS:
./misc/parser.pyx:        if tokens.next() == '(':
./misc/parser.pyx:                token = tokens.next()
./misc/parser.pyx:                tokens.next()
./misc/parser.pyx:                tokens.next()
./misc/parser.pyx:            token = tokens.next()
./misc/parser.pyx:        cdef int token = tokens.next()
./misc/parser.pyx:        token = tokens.next()
./misc/parser.pyx:        cdef int token = tokens.next()
./misc/parser.pyx:        token = tokens.next()
./misc/parser.pyx:        cdef int op = tokens.next()
./misc/parser.pyx:        op = tokens.next()
./misc/parser.pyx:            op = tokens.next()
./misc/parser.pyx:        op = tokens.next()
./misc/parser.pyx:            op = tokens.next()
./misc/parser.pyx:        cdef int token = tokens.next()
./misc/parser.pyx:        cdef int token = tokens.next()
./misc/parser.pyx:                tokens.next()
./misc/parser.pyx:        cdef int token = tokens.next()
./misc/parser.pyx:            token = tokens.next()
./misc/parser.pyx:                token = tokens.next()
./misc/parser.pyx:            token = tokens.next()
./misc/parser.pyx:            token = tokens.next()
./misc/parser.pyx:        cdef int token = tokens.next()
./misc/parser.pyx:            tokens.next()
./parallel/map_reduce.py:            sage: it.next()
./parallel/map_reduce.py:                node = newnodes.next()
./parallel/map_reduce.py:            sage: it.next() # random
./parallel/map_reduce.py:            sage: it.next() # random
./rings/fraction_field_FpT.pyx:            ....:     a = a.next()
./rings/polynomial/pbori.pyx:        self._iter.next()
./rings/polynomial/pbori.pyx:        self._iter.next()
./rings/polynomial/pbori.pyx:            d = iter(M).next().degree()
./rings/polynomial/pbori.pyx:        self._iter.next()
./rings/polynomial/pbori.pyx:        self._iter.next()
./rings/polynomial/pbori.pyx:        self._iter.next()
./rings/polynomial/pbori.pyx:        start = start.next()
./rings/polynomial/pbori.pyx:        it = it.next()
./schemes/projective/endPN_automorphism_group.py:    p = primes.next(ZZ(prime_lower_bound))
./schemes/projective/endPN_automorphism_group.py:        p = primes.next(p)
./sets/integer_range.py:            sage: (I.next(0), I.next(10), I.next(-10), I.next(20), I.next(-100))
./sets/integer_range.py:            sage: (I.next(0), I.next(10), I.next(-10), I.next(20), I.next(-100))
./sets/integer_range.py:            sage: I.next(1)
./sets/integer_range.py:            n = self.next(n)
./sets/non_negative_integers.py:            sage: NN.next(3)
./sets/primes.py:            sage: P.next(5)
```




---

archive/issue_comments_288271.json:
```json
{
    "body": "Replying to [comment:3 jhpalmieri]:\n> If I search the source for `'\\.next('`, I find lots of matches. Do some of these need to be changed, also? (Some may depend on #18802, I guess.)\n\nOnly the instances of \".next()\" with no arguments need to be considered. I have carefully looked at all of them to see when they involved an iterator. There is just once case where it seems that one could use the `next(bla)` syntax, but which does not work. I have marked it with \"bug\" in my branch. This may be the subject of a follow-up ticket.",
    "created_at": "2016-07-28T18:18:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288271",
    "user": "https://github.com/fchapoton"
}
```

Replying to [comment:3 jhpalmieri]:
> If I search the source for `'\.next('`, I find lots of matches. Do some of these need to be changed, also? (Some may depend on #18802, I guess.)

Only the instances of ".next()" with no arguments need to be considered. I have carefully looked at all of them to see when they involved an iterator. There is just once case where it seems that one could use the `next(bla)` syntax, but which does not work. I have marked it with "bug" in my branch. This may be the subject of a follow-up ticket.



---

archive/issue_comments_288272.json:
```json
{
    "body": "Those might come from the enumerative sets category too.",
    "created_at": "2016-07-28T18:37:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288272",
    "user": "https://github.com/tscrim"
}
```

Those might come from the enumerative sets category too.



---

archive/issue_comments_288273.json:
```json
{
    "body": "Perhaps more explanation would be useful. There is a `foo.next(bar)` method that returns the next item after `bar` in `foo`.",
    "created_at": "2016-07-28T19:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288273",
    "user": "https://github.com/tscrim"
}
```

Perhaps more explanation would be useful. There is a `foo.next(bar)` method that returns the next item after `bar` in `foo`.



---

archive/issue_comments_288274.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-08-07T20:01:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20873",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20873#issuecomment-288274",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
