# Issue 11949: floor/ceil can be very slow at integral values

Issue created by migration from https://trac.sagemath.org/ticket/12121

Original creator: dsm

Original creation time: 2011-12-06 15:35:19

Assignee: AlexGhitza

CC:  kcrisman jdemeyer pelegm

Reported (in slightly different form) on [ask.sagemath.org](http://ask.sagemath.org/question/964/lenlist-ceillog42-bugs):



```
sage: %timeit floor(log(3)/log(2))
625 loops, best of 3: 586 µs per loop
sage: %timeit floor(log(4)/log(2))
5 loops, best of 3: 3.79 s per loop
sage: %timeit ceil(log(3)/log(2))
625 loops, best of 3: 586 µs per loop
sage: %timeit ceil(log(4)/log(2))
5 loops, best of 3: 3.79 s per loop
```


This happens because ceil and floor first try to increase the precision of a coercion of the input argument to a `RealInterval` by 100 bits from 53 to 20000 before finally trying a full_simplify, which succeeds.

One possible solution would be to try


```
sage: %timeit bool(log(4)/log(2) == round(log(4)/log(2)))
125 loops, best of 3: 5.57 ms per loop
```


after some number (maybe even 1?) of `RealInterval` attempts, and then get back to increasing the precision.  Trying to think of use cases, ceil and floor are probably called 95%+ of the time on things which only require a round or two at most to determine the answer, so it makes sense to optimize that end. 

As well, the "+100 bits" approach (rather than going up by some factor each time, say) probably penalizes numbers requiring lots of bits too much relative to those requiring only a few, but the integer case is probably more important.


---

Comment by dsm created at 2012-03-03 16:43:37

Note to self (and others): we can use is_int to decide when we should test for equality.  Test (once) the first time there's only one integer in the interval.  If you have equality there, you're done.  If not, you never will (or won't be able to prove it, anyway) and can carry on.


---

Comment by kini created at 2012-06-22 19:10:45

Apparently [is_int is deprecated](http://thread.gmane.org/gmane.comp.mathematics.sage.devel/57910/).


---

Comment by zimmerma created at 2015-07-07 12:22:34

I'm not sure if this should go to this ticket, but the following never returns:

```
sage: z
(11/9*sqrt(3)*sqrt(2) + 3)^(1/3) + 1/3/(11/9*sqrt(3)*sqrt(2) + 3)^(1/3) - 1
sage: floor(z)
```

Even `floor(z, maximum_bits=53)` loops infinitely.
Should I open a separate ticket?


---

Comment by ajagekar.akshay created at 2016-02-11 20:17:44

Changing status from new to needs_review.


---

Comment by ajagekar.akshay created at 2016-02-11 20:17:44

New commits:


---

Comment by vdelecroix created at 2016-03-09 18:53:08

Replying to [comment:9 zimmerma]:
> I'm not sure if this should go to this ticket, but the following never returns:
> {{{
> sage: z
> (11/9*sqrt(3)*sqrt(2) + 3)^(1/3) + 1/3/(11/9*sqrt(3)*sqrt(2) + 3)^(1/3) - 1
> sage: floor(z)
> }}}
> Even `floor(z, maximum_bits=53)` loops infinitely.

Whereas the following actually works

```
sage: bool(z == 1)
True
```


> Should I open a separate ticket?

I think that "very slow" includes "infinite amount of time". For me it is worth it to also fix this kind of endless loops in this ticket.


---

Comment by vdelecroix created at 2016-03-09 18:56:16

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2016-03-09 18:56:16

`@`ajagekar.akshay: why did you remove your branch? The commit lacks some examples (as the one of [comment:9 comment:9]).


---

Comment by ajagekar.akshay created at 2016-03-09 19:06:20

Replying to [comment:14 vdelecroix]:
> `@`ajagekar.akshay: why did you remove your branch? The commit lacks some examples (as the one of [comment:9 comment:9]).
Sorry but I pushed that branch without testing, some tests failed.


---

Comment by vdelecroix created at 2016-03-09 19:08:53

Replying to [comment:15 ajagekar.akshay]:
> Replying to [comment:14 vdelecroix]:
> > `@`ajagekar.akshay: why did you remove your branch? The commit lacks some examples (as the one of [comment:9 comment:9]).
> Sorry but I pushed that branch without testing, some tests failed.

That is not a problem. Tickets can have different status: `closed`, `positive_review`, `needs_review`, `needs_work`, `new`. If there is no branch associated to a ticket it makes no sense to keep it into "needs review" state. (I already changed it to needs_work)


---

Comment by vdelecroix created at 2016-03-09 19:14:08

Indeed, your code was good... and there is a bug somewhere else in the conversion from `SR` to the real interval fields:

```
sage: RealIntervalField(256)(SR(10^50 + 10^(-50))).is_int()
(True, 100000000000000000000000000000000000000000000000000)
```


Sorry, I was wrong. The method `is_int` is *not* intended to test if the interval is actually restricted to one integer! It only tests if the interval contains only one integer.


---

Comment by vdelecroix created at 2016-03-09 19:46:23

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-03-09 19:46:23

New commits:


---

Comment by git created at 2016-03-09 19:58:27

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2016-03-10 02:44:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-03-10 02:45:38

I pushed a tiny fix because we currently have

```
sage: log(8) / log(2) == 3
False
```

See the discussion at [this sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/xAlQmUF_cdU).


---

Comment by mmezzarobba created at 2016-03-24 14:35:11

#15786 is a partial duplicate. I find the fix posted there a bit cleaner, though it needs to be rebased.


---

Comment by vdelecroix created at 2016-03-24 14:41:43

Rebased on what!?

There is one thing I am not happy with. I think we should try to make the interval much smaller than 1 in

```
while x_interval.absolute_diameter() >= 1:
    bits *= 2
    x_interval = RealIntervalField(bits)(x)
```

before trying to simplify the expression. I guess that 2<sup>-30</sup> would be much more reasonable and avoid many attempts of (costly) simplification. What do you think?


---

Comment by mmezzarobba created at 2016-03-24 14:46:23

Sorry if I wasn't clear. I'm saying that the _other_ branch (the one at #15786) should be rebased.


---

Comment by rws created at 2016-03-24 14:59:09

Be aware you might be using symbolics when doing bool( == ). To not end up with surprises you might want to break out the actual functionality you need out of `Expression.__nonzero__` or review #16397 and use `cmp`.


---

Comment by git created at 2016-03-24 15:52:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-03-24 15:55:02

Replying to [comment:25 rws]:
> Be aware you might be using symbolics when doing bool( == ). To not end up with surprises you might want to break out the actual functionality you need out of `Expression.__nonzero__` or review #16397 and use `cmp`.

You mean that there is no way to check that `expr1 == expr2`? I do not want to copy/paste anything from other place. If testing equality is not available, there is a big problem.

Using `cmp` for that purpose is a bad idea. The purpose of `cmp` in Python 2 is to sort things out. Not to compare.


---

Comment by rws created at 2016-03-24 16:11:44

Testing equality of symbolics in general is undecidable. If you remove all expressions with variables however, it is easy: convert symbolic constants and function expressions to float as in `N()`, compare. Of course there are precision problems but that's nothing in comparison to what you get with variables.

The idea to abuse `cmp` is not mine. Somewhere here `RLF(1) < RLF(sqrt(2))` for example, symbolic `cmp` is called. Should I file a bug report for such usage?

EDIT: typos


---

Comment by mmezzarobba created at 2016-03-24 16:19:05

Replying to [comment:28 rws]:
> Testing equality of symbolics in general is undecidable. If you remove all expressions with variables however, it is easy

It is unknown if it is decidable (afaik) even without variables.

> The idea to abuse `cmp` is not mine. Somewhere here `RLF(1) < RLF(sqrt(2))` for example, symbolic `cmp` is called. Should I file a bug report for such usage?

I'd say it probably is a bug. As to whether you should file a bug report, I don't know—I doubt anyone really reads them, and the issue is probably already covered somewhere in the myriad of known bugs with comparisons...


---

Comment by vdelecroix created at 2016-03-24 16:20:13

Replying to [comment:28 rws]:
> Testing equality of symbolics in general is undecidable. If you remove all expressions with variables however, it is easy: convert symbolic constants and function expressions to float as in `N()`, compare. Of course there are precision problems but that's nothing in comparison to what you get with variables.

What I need is a method that either returns a reliable answer `True` or `False` or raise an error which can either be `This comparison is meaningless` or `I don't know how to compare this`.


---

Comment by rws created at 2016-03-24 16:39:57

Replying to [comment:30 vdelecroix]:
> What I need is a method that either returns a reliable answer `True` or `False` or raise an error which can either be `This comparison is meaningless` or `I don't know how to compare this`.
Then `bool( == )` is right for the moment and may be replaced with #19040. As said don't be surprised if it takes a long time.


---

Comment by git created at 2016-03-24 18:20:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-03-24 18:21:53

Replying to [comment:31 rws]:
> Replying to [comment:30 vdelecroix]:
> > What I need is a method that either returns a reliable answer `True` or `False` or raise an error which can either be `This comparison is meaningless` or `I don't know how to compare this`.
> Then `bool( == )` is right for the moment and may be replaced with #19040. As said don't be surprised if it takes a long time.

I added a note about #19040.


---

Comment by mmezzarobba created at 2016-03-25 15:59:45

Hi Vincent,

Sorry for my unclear comments above, I didn't look closely enough at your code before posting them.

Beside the issue with comparisons raised by Ralf, I find the code on your branch a bit complicated, and I don't like the fact that you drop the `maximum_bits` parameters at the risk of looping forever if you cannot prove that the input is an integer. I pushed to `u/mmezzarobba/12121-ceil` a rough attempt to fix these issues (in the case of `ceil` only at the moment, and not well tested yet), please tell me what you think of it.


---

Comment by mmezzarobba created at 2016-03-25 15:59:45

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-04-05 21:11:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2016-04-05 21:12:38

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-04-05 21:12:38

All right. I factorized the two implementations in a new function `incremental_rounding`. It is cleaner and the parameter `maximum_bits` is reintroduced.


---

Comment by git created at 2016-04-06 01:57:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2016-04-06 08:41:07

I fear I won't have time to review your new version in the next few days at least, but from a quick look at it there are a lot of things I don't understand. In no particular order:
* why do you make `maximum_bits` an `Integer`?
* what don't you like about `unique_integer()`?
* is it really better to have an absolute bound for the diameter that makes us suspect we found an exact integer, rather than something that depends on the precision?
* why do you insist on using `==` on symbolic expressions instead of `is_trivial_zero()`?
* are you sure you want to raise an error when `maximum_bits` does not suffice to conclude? this is a symbolic function that may be buried deep in the middle of a symbolic expression; returning unevaluated seems more reasonable to me...
* do we really need two loops that do essentially the same thing (including raising errors with the exact same message)?


---

Comment by git created at 2016-04-06 17:17:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-04-06 17:18:35

I removed the `__call__` in both `Function_floor` and `Function_ceil`. The code is now much simpler. Though there was some adaptation needed in `symbolic/expression.pyx`.

Replying to [comment:39 mmezzarobba]:
> I fear I won't have time to review your new version in the next few days at least, but from a quick look at it there are a lot of things I don't understand. In no particular order:
> * why do you make `maximum_bits` an `Integer`?

all right. `int` is fine as well.

> * what don't you like about `unique_integer()`?

an `assert` does not cost anything. And `unique_integer` silently fails if the interval does not enclose a unique integer.

> * is it really better to have an absolute bound for the diameter that makes us suspect we found an exact integer, rather than something that depends on the precision?

the precision of what? there is the field used for the evaluation which is different from the diameter of the interval. If you have more than one integer in your interval which one are you using to test equality?

> * why do you insist on using `==` on symbolic expressions instead of `is_trivial_zero()`?

Because I want to check equality with an integer. Not if it is a trivial equality.

> * are you sure you want to raise an error when `maximum_bits` does not suffice to conclude? this is a symbolic function that may be buried deep in the middle of a symbolic expression; returning unevaluated seems more reasonable to me...

Done with an example.

> * do we really need two loops that do essentially the same thing (including raising errors with the exact same message)?

The equality test is potentially costly. And we want to avoid it as much as possible. In particular, it makes no sense to test this equality within each step of the loop as it is in your version. On a related note, I noticed that for `round` you need to test equality with elements of `ZZ + 1/2`.


---

Comment by vdelecroix created at 2016-04-06 19:06:24

Replying to [comment:41 vdelecroix]:
> Replying to [comment:39 mmezzarobba]:
> > * do we really need two loops that do essentially the same thing (including raising errors with the exact same message)?
> 
> The equality test is potentially costly. And we want to avoid it as much as possible. In particular, it makes no sense to test this equality within each step of the loop as it is in your version. On a related note, I noticed that for `round` you need to test equality with elements of `ZZ + 1/2`. 

And I also would like to use the very same function `incremental_rounding` for elements of `QQbar`. For the very same reason, you only want very lately the equality test.


---

Comment by git created at 2016-04-06 19:31:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-04-28 22:49:33

ping?!


---

Comment by mmezzarobba created at 2016-04-29 11:27:34

Sorry, I have about zero time for Sage development before at least 1-2 weeks. All I can say is that I wasn't completely convinced by your answers and would need to think things over more carefully. If someone wants to review the ticket in the meantime, please do.


---

Comment by git created at 2016-05-08 02:45:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2016-05-08 02:45:56

rebased on 7-2.rc1


---

Comment by mmezzarobba created at 2016-05-17 13:42:19

Okay, I'm back. Sorry that it took so long.

Replying to [comment:41 vdelecroix]:
> > * what don't you like about `unique_integer()`?
> 
> an `assert` does not cost anything. And `unique_integer` silently fails if the interval does not enclose a unique integer.

Uh? No, it doesn't.

> > * is it really better to have an absolute bound for the diameter that makes us suspect we found an exact integer, rather than something that depends on the precision?
> 
> the precision of what? there is the field used for the evaluation which is different from the diameter of the interval. If you have more than one integer in your interval which one are you using to test equality?

The precision of the interval computation, i.e. `bits`. The idea being that if we found an interval of width (say) 2⁻²⁰ containing an integer by computing with 1000 bits of precision, we may want to see if the width of the interval keeps decreasing when the precision increases and only run the symbolic part of the algorithm if that's the case. But I agree that this is a very minor issue at best.

> > * why do you insist on using `==` on symbolic expressions instead of `is_trivial_zero()`?
> 
> Because I want to check equality with an integer. Not if it is a trivial equality.

I mean using `is_trivial_zero()` after calling `full_simplify()` & co, as in my version: this is safer than relying on `==` and essentially as powerful.

> > * do we really need two loops that do essentially the same thing (including raising errors with the exact same message)?
> 
> The equality test is potentially costly. And we want to avoid it as much as possible. In particular, it makes no sense to test this equality within each step of the loop as it is in your version.

Yes—as I said, my version was just a rough sketch of the changes I'd b tempted to make, nothing finished. As the code I was starting with used to loop forever in the typical situation where mine would do the symbolic test repeatedly (that is, `x` ∈ ℤ integer but we don't manage to prove it), I thought the additional cost would be acceptable. `;-)` But anyway, it is not hard to do the test only once while avoiding the code duplication.

> On a related note, I noticed that for `round` you need to test equality with elements of `ZZ + 1/2`. 

Couldn't you just compute ceil(x-1/2)?

------

Now for some comments on the current code:

* To summarize the above, I still think the main logic in `incremental_rounding()` could be shortened to something like (not tested):

```
    unique_rounding = getattr(RealIntervalFieldElement, 'unique_' + mode)
    r = RR.one() >> 20

    bits = 64
    candidate = None
    while bits < maximum_bits:
        interval = RealIntervalField(bits)(x) # may raise a TypeError
        try:
            return unique_rounding(interval)
        except ValueError:
            pass
        if candidate is None and interval.absolute_diameter() > r:
            candidate = interval.unique_integer()
            try:
                delta = x - candidate
                if (delta.is_zero()
                        or SR(delta).full_simplify().canonicalize_radical()
                                    .is_trivial_zero()
                        or QQbar(delta).is_zero()):
                    return candidate
                except (TypeError, ValueError):
                    pass
        bits *= 2
```


* I'd also make `incremental_rounding()` private and dispense with the argument checking (and perhaps move it to `real_mpfi` if your plan is to use it from elsewhere)—but I'm okay with keeping it as it is. An advantage of making it private is that you could take the “unique rounding” function on intervals as input instead of accessing it via `getattr()`. Another option would be to introduce a common base class for `Function_floor`, `Function_ceil` and `Function_round`.

* I'm a little uneasy about the changes you made to `BuiltinFunction.__call__()`. The fact that it used to convert non-Element inputs to Elements looks intentional and pretty reasonable to me. Is it really necessary to change that behavior? That being said, I'm a bit lost in the maze of `Function.__call__`, `BuiltinFunction.__call__`, `_eval_`, `_evalf_`, `_evalf_try_` and friends, so if you tell me you are confident that the change is correct I'll trust you!

* If these changes stay, then I guess this

```
if module is not None:
    func = getattr(module, self._name, None)
    if func is None and self._alt_name is not None:
        func = getattr(module, self._name, None)
                                    ^^^^^
```

  should be `_alt_name`.

* Note that these changes also make

```
sage: sin(numpy.int32(0))
0.0
```

  which is at odds with

```
sage: sin(ZZ(0)).parent()
Integer Ring
```

  (perhaps not ideal, but predictable at least).

* In `Function_*`, what is the point of calling `_evalf_()` from `_eval_()`?

* And why isn't the logic for choosing `maximum_bits` in `_evalf_()` the same in `floor`, `ceil` and `round`?

* I wouldn't bother with checking that `x` is not a relation. First, `_eval_()` methods of individual functions are probably not the right place for that (either `BuiltinFunction.__call__()` or perhaps methods `ceil()`, `floor()` etc. in a future subclass `RelationalExpression` of `Expression` would be more reasonable). Besides, various other nonsensical inputs (e.g. series, booleans) are accepted without error, so it is a bit strange to have an ad hoc check dealing with this one.


---

Comment by mmezzarobba created at 2016-05-17 13:42:19

Changing status from needs_review to needs_work.


---

Comment by nbruin created at 2016-05-19 02:38:44

You may be interested in #20624. It looks like implementing `_evalf_` by calling `_eval_` is VERY bad: currently evaluation of `ceil` may lead to running out the python call stack before doing anything useful. Obviously, this takes some time. Inheriting from `BuiltinFunction` is a real bugtrap: its init reassigns a whole bunch of methods.


---

Comment by rws created at 2016-05-19 05:39:25

Replying to [comment:50 nbruin]:
> Inheriting from `BuiltinFunction` is a real bugtrap: its init reassigns a whole bunch of methods.
That must be the reason why Sage crashes all the time. Seriously, I agree the construction of functions is messy and it limits the developer somewhat, see "other symbolic function tickets" in http://trac.sagemath.org/wiki/symbolics/functions. Note also there are a bunch of tickets needing review there. However, I think the design is sound. You just have to read how other functions (the more recently implemented) are using it. In the end, I or someone will be transferring the Python you write to Pynac, anyway.

Cc: the author of the `_evalf_try_` mechanism.


---

Comment by rws created at 2016-06-11 15:43:43

Replying to [comment:50 nbruin]:
> You may be interested in #20624. It looks like implementing `_evalf_` by calling `_eval_` is VERY bad: currently evaluation of `ceil` may lead to running out the python call stack before doing anything useful.

I may be mistaken but actually `_eval_` calls `_evalf_` here which is a completely different matter.
----
New commits:


---

Comment by vdelecroix created at 2016-07-13 15:48:41

Replying to [comment:49 mmezzarobba]:
> > On a related note, I noticed that for `round` you need to test equality with elements of `ZZ + 1/2`. 
> 
> Couldn't you just compute ceil(x-1/2)?


```
sage: x = 0.5
sage: print x.round() == (x-0.5).ceil()
False
```



---

Comment by vdelecroix created at 2016-07-13 16:23:00

Replying to [comment:49 mmezzarobba]:
> * In `Function_*`, what is the point of calling `_evalf_()` from `_eval_()`?

Because I want the answer of `floor(pi)` to be `3`.


---

Comment by vdelecroix created at 2016-07-13 16:39:19

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-07-13 16:39:50

New commits:


---

Comment by rws created at 2016-07-14 06:08:02

`Function` mechanics looking very good. Can't comment on the `incremental_rounding()` function part.


---

Comment by vdelecroix created at 2016-08-10 23:16:56

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-08-17 21:54:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2016-08-17 21:55:41

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-08-17 21:55:41

Rebased on the last beta (which includes #21216).

I slightly modified `incremental_rounding`. The simplification part is implemented outside. As soon as there is a reliable `is_zero` available for elements of SR (as it is the case for `QQbar` with `is_zero`) we could make it cleaner.


---

Comment by mmezzarobba created at 2016-09-16 09:59:41

Hi Vincent,

Sorry for taking so long to reply once again. The code is starting to look really good to me overall, but calling the buggy `is_zero()` causes regressions such as:

```
sage: foo = sin(1 + 10^(-30)) - sin(1)
sage: ceil(foo)
0
sage: floor(foo)
0
```

I know we already talked about that above, but are you sure you don't want `incremental_rounding()` to use `is_trivial_zero()` (probably after some simplification) instead?


---

Comment by mmezzarobba created at 2016-09-16 09:59:41

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2016-09-17 07:05:43

I definitely want a `incremental_rounding` that is symbolic ring agnostic. A solution would be to have an optional argument `is_zero`. What do you think?


---

Comment by vdelecroix created at 2016-09-17 07:14:26

(of course the argument would have default "the_object.is_zero")


---

Comment by mmezzarobba created at 2016-09-17 11:09:12

Replying to [comment:63 vdelecroix]:
> I definitely want a `incremental_rounding` that is symbolic ring agnostic. A solution would be to have an optional argument `is_zero`. What do you think?

That sounds good.


---

Comment by vdelecroix created at 2016-09-17 11:31:46

And `is_trivial_zero` could not be a solution anyway

```
sage: delta = (11/9*sqrt(3)*sqrt(2) + 3)^(1/3) + 1/3/(11/9*sqrt(3)*sqrt(2) + 3)^(1/3) - 2
sage: delta.is_zero()
True
sage: delta.is_trivial_zero()
False
sage: delta2 = delta.full_simplify().canonicalize_radical()
sage: delta2.is_zero()
True
sage: delta2.is_trivial_zero()
False
```



---

Comment by vdelecroix created at 2016-09-17 11:44:28

Even better

```
sage: (sin(1 - 10^(-100)) - sin(1)).is_zero()
True
age: bool(sin(1 - 10^(-100)) - sin(1) == 0)
True
```

I thought that we should only worry about false negatives...


---

Comment by vdelecroix created at 2016-09-17 11:50:27

See the following thread

    https://groups.google.com/forum/#!topic/sage-devel/qitYHanQiEo


---

Comment by git created at 2016-09-17 13:51:29

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2016-09-17 13:53:18

Changing status from needs_work to needs_review.


---

Comment by rws created at 2016-09-17 14:14:01

You removed the symbolic property of `frac()` and you didn't give any justification for it.


---

Comment by rws created at 2016-09-17 14:24:16

Changing status from needs_review to needs_work.


---

Comment by rws created at 2016-09-17 14:24:16

Please try to fix your code so previous frac doctests work.


---

Comment by git created at 2016-09-17 16:19:27

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2016-09-17 16:24:05

Ralf, what do you call the "symbolic property" of `frac`?

On the other hand I have comments about the previous code of `frac`
- it is the role of the function `floor` to call the method `floor` if needed. There is no need to redo it now and then
- special casing `int` and `float` when the generic `x - floor(x)` does work is weird (not mentioning that this was not tested). In this case I would prefer that it behaves like floor and ceil (ie frac(float) returning float). The previous version returned Sage integer, why is that?

I let the `frac(x + y)` not be transformed in `x + y - floor(x + y)` in my new last commit. Please tell me if you like it better.


---

Comment by vdelecroix created at 2016-09-17 16:24:15

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2016-09-17 17:04:42

Replying to [comment:66 vdelecroix]:
> And `is_trivial_zero` could not be a solution anyway
> {{{
> sage: delta = (11/9*sqrt(3)*sqrt(2) + 3)^(1/3) + 1/3/(11/9*sqrt(3)*sqrt(2) + 3)^(1/3) - 2
> }}}

Well, of course there will always be examples where the zero-test fails! Above I suggested to try both simplification followed by `is_trivial_zero()` and conversion to `QQbar`, this would take care of this example.


---

Comment by mmezzarobba created at 2016-09-17 17:07:11

Replying to [comment:67 vdelecroix]:
> Even better
> {{{
> sage: (sin(1 - 10^(-100)) - sin(1)).is_zero()
> True
> age: bool(sin(1 - 10^(-100)) - sin(1) == 0)
> True
> }}}

Yes; I thought that was what the comment about `is_zero()` being unreliable was about.


---

Comment by vdelecroix created at 2016-09-17 19:03:59

Replying to [comment:77 mmezzarobba]:
> Replying to [comment:67 vdelecroix]:
> > Even better
> > {{{
> > sage: (sin(1 - 10^(-100)) - sin(1)).is_zero()
> > True
> > age: bool(sin(1 - 10^(-100)) - sin(1) == 0)
> > True
> > }}}
> 
> Yes; I thought that was what the comment about `is_zero()` being unreliable was about.

For me unreliable was "sometimes there are false negative". But it is not only that as there are "false positive". Meaning that

```
def is_zero(x):
    return randint(0, 1)
```

is equally good.


---

Comment by vdelecroix created at 2016-09-17 19:04:34

If you have a `reliable_is_zero_for_SR` I will of course include it ;-)


---

Comment by rws created at 2016-09-18 06:18:29

Replying to [comment:74 vdelecroix]:
> Ralf, what do you call the "symbolic property" of `frac`?

That it can be part of expressions. In the first version of your "fix frac" commit you unconditionally expanded `frac(...)` and forced the user to use `hold=True` to get the symbolic `frac()`.

> I let the `frac(x + y)` not be transformed in `x + y - floor(x + y)` in my new last commit. Please tell me if you like it better.

I do!

Marc:
> Well, of course there will always be examples where the zero-test fails! Above I suggested to try both simplification followed by is_trivial_zero() and conversion to QQbar, this would take care of this example.

In #16397 I implemented this already in https://github.com/sagemath/sage/blob/master/src/sage/symbolic/comparison.pyx#L291 to have some code usable for `__nonzero__` later.


---

Comment by mmezzarobba created at 2016-09-20 07:50:31

Changing status from needs_review to needs_work.


---

Comment by mmezzarobba created at 2016-09-20 08:01:09

A minor suggestion: perhaps make `rounding()` to `_rounding()`?

Also, I'm not sure how bad the existing implementation of `floor()` and friends is, but unless it is really terrible, I'd prefer to either avoid relying on `is_zero()` (even with known bugs marked as such) or to have `is_zero()` fixed before merging this ticket.


---

Comment by mmezzarobba created at 2016-09-20 08:18:48

Replying to [comment:80 rws]:
> > Well, of course there will always be examples where the zero-test fails! Above I suggested to try both simplification followed by is_trivial_zero() and conversion to QQbar, this would take care of this example.
> 
> In #16397 I implemented this already in https://github.com/sagemath/sage/blob/master/src/sage/symbolic/comparison.pyx#L291 to have some code usable for `__nonzero__` later.

I think I don't follow you, sorry. The code you link to looks like it is intended to sort expressions for printing etc., not to provide reliable mathematical results, isn't it? Besides (but this is starting to be off-topic for this ticket), I'm tempted to think that, for non-relational expressions at least, `__nonzero__()` should simply be the negation of `is_trivial_zero()`. As far as I understand, what `__nonzero__()` is intended to test is whether something is “empty”, “trivial”; it should be as fast as possible, and there is no expectation that it tries hard to prove the nullity of its argument. For a “mathematical” example, I'd find it entirely reasonable to have `(x - x)*y + 1 ∈ SR[y]` be considered a polynomial of degree **one**—and that's the kind of things `__nonzero__()` is for. I'm less certain about _relational_ expressions: perhaps `bool(expr == 0)`, unlike `bool(expr)`, should keep trying hard to show that `expr` is zero.


---

Comment by mmezzarobba created at 2016-12-19 19:58:30

See also #22079.


---

Comment by mmezzarobba created at 2017-09-04 14:23:33

Rebased following the discussion at #22079.
----
New commits:


---

Comment by jdemeyer created at 2017-09-04 15:04:35

I have an implementation fixing `floor()`/`ceil()` at #22079.


---

Comment by jdemeyer created at 2017-11-29 15:53:32

This branch does a whole lot more than fixing `floor()`/`ceil()`. Now that this has been fixed in #22079, feel free to change the purpose of this ticket.
