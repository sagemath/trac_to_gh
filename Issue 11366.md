# Issue 11366: Improve efficiency of fgp_module over integers

archive/issues_011366.json:
```json
{
    "body": "Assignee: tbd\n\nCC:  rbeezer\n\nThe functionality of fgp_module is excellent, but its performance for FG modules over integers is not very good. Given how (finite) abelian groups could really be worked with in this setting, it's probably worthwhile specializing this case, which allows it to be vastly more efficient. Just as an example, consider the following code:\n\n```\nZ3=ZZ^3\nF=Z3/Z3.span([])\nG=F/F.submodule([12*F.0,4*F.1+8*F.2,16*F.2])\nH=G/G.submodule([2*g for g in G.gens()])\nphi=G.hom([H(g) for g in G.gens()])\ndef faster_hom(phi):\n    dom=phi.domain()\n    codom=phi.codomain()\n    M=matrix([vector(phi(g)) for g in G.gens()])\n    inv=codom.invariants()\n    r=len(inv)\n    def fast_hom(v):\n        w=vector(v)*M\n        return codom([w[i] % inv[i] for i in xrange(r)])\n    return fast_hom\nfaster_phi=faster_hom(phi)           \ntimeit(\"phi(G.random_element())\")\ntimeit(\"faster_phi(G.random_element())\")\n```\n\nwith results\n\n```\n125 loops, best of 3: 2.03 ms per loop\n625 loops, best of 3: 907 \u00b5s per loop\n```\n\nThat's already a factor of 2. And that's only replacing it with python code! (though it is assuming the codomain is in \"optimized\" form, but that is clearly what one should ensure)\nA little profiling shows that calling \"phi\" incurs 5 calls to\n`sage.matrix.matrix0.Matrix.linear_combination_of_rows`. \n\nIssue created by migration from https://trac.sagemath.org/ticket/11538\n\n",
    "created_at": "2011-06-23T21:06:48Z",
    "labels": [
        "performance",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Improve efficiency of fgp_module over integers",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11366",
    "user": "nbruin"
}
```
Assignee: tbd

CC:  rbeezer

The functionality of fgp_module is excellent, but its performance for FG modules over integers is not very good. Given how (finite) abelian groups could really be worked with in this setting, it's probably worthwhile specializing this case, which allows it to be vastly more efficient. Just as an example, consider the following code:

```
Z3=ZZ^3
F=Z3/Z3.span([])
G=F/F.submodule([12*F.0,4*F.1+8*F.2,16*F.2])
H=G/G.submodule([2*g for g in G.gens()])
phi=G.hom([H(g) for g in G.gens()])
def faster_hom(phi):
    dom=phi.domain()
    codom=phi.codomain()
    M=matrix([vector(phi(g)) for g in G.gens()])
    inv=codom.invariants()
    r=len(inv)
    def fast_hom(v):
        w=vector(v)*M
        return codom([w[i] % inv[i] for i in xrange(r)])
    return fast_hom
faster_phi=faster_hom(phi)           
timeit("phi(G.random_element())")
timeit("faster_phi(G.random_element())")
```

with results

```
125 loops, best of 3: 2.03 ms per loop
625 loops, best of 3: 907 Âµs per loop
```

That's already a factor of 2. And that's only replacing it with python code! (though it is assuming the codomain is in "optimized" form, but that is clearly what one should ensure)
A little profiling shows that calling "phi" incurs 5 calls to
`sage.matrix.matrix0.Matrix.linear_combination_of_rows`. 

Issue created by migration from https://trac.sagemath.org/ticket/11538


