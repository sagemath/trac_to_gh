# Issue 13850: Cythoned UniqueRepresentation

archive/issues_013850.json:
```json
{
    "body": "Assignee: tbd\n\nCC:  @nthiery\n\nKeywords: cython UniqueRepresentation\n\n`UniqueRepresentation` provides a comfortable way to create unique parent structures, and automatically provides a hash and certain comparison methods. Problem: It relies on a metaclass, namely `ClasscallMetaclass` and thus has to be a Python class. That's bad for speed.\n\nHere, I suggest to create a new cdef class `UniqueRepresentation_c` that provides hash and comparison, and let `UniqueRepresentation` inherit from it, just adding the classcall method.\n\nThe problem is that `UniqueRepresentation` relies on cached_method, and this decorator had problems to work on methods defined in Cython with varargs and keywords arguments. That is fixed in #14017, which is thus a dependency.\n\nIssue created by migration from https://trac.sagemath.org/ticket/14054\n\n",
    "created_at": "2013-02-03T22:08:02Z",
    "labels": [
        "component: performance"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.8",
    "title": "Cythoned UniqueRepresentation",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13850",
    "user": "https://github.com/simon-king-jena"
}
```
Assignee: tbd

CC:  @nthiery

Keywords: cython UniqueRepresentation

`UniqueRepresentation` provides a comfortable way to create unique parent structures, and automatically provides a hash and certain comparison methods. Problem: It relies on a metaclass, namely `ClasscallMetaclass` and thus has to be a Python class. That's bad for speed.

Here, I suggest to create a new cdef class `UniqueRepresentation_c` that provides hash and comparison, and let `UniqueRepresentation` inherit from it, just adding the classcall method.

The problem is that `UniqueRepresentation` relies on cached_method, and this decorator had problems to work on methods defined in Cython with varargs and keywords arguments. That is fixed in #14017, which is thus a dependency.

Issue created by migration from https://trac.sagemath.org/ticket/14054





---

archive/issue_comments_171855.json:
```json
{
    "body": "Attachment [trac_14054_cythoned_unique_representation.patch](tarball://root/attachments/some-uuid/ticket14054/trac_14054_cythoned_unique_representation.patch) by @simon-king-jena created at 2013-02-03 22:09:46",
    "created_at": "2013-02-03T22:09:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171855",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_14054_cythoned_unique_representation.patch](tarball://root/attachments/some-uuid/ticket14054/trac_14054_cythoned_unique_representation.patch) by @simon-king-jena created at 2013-02-03 22:09:46



---

archive/issue_comments_171856.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-02-03T22:16:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171856",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_171857.json:
```json
{
    "body": "Note that the patch also needed to change some auxiliary class `CartanType_simple_finite`, which is used to unpickle some old data. It used to inherit from `object`, but for an incompatibility of Cython types it has to inherit from `UniqueRepresentation` instead.\n\nFor the timings, I use `MatrixSpace`, which inherits from `UniqueRepresentation`:\n\n```\nsage: isinstance(MatrixSpace(GF(3),2,3), UniqueRepresentation)\nTrue\n```\n\nWith sage-5.6.rc0 plus #14017:\n\n```\nsage: %time L = [MatrixSpace(GF(3),n) for n in range(10000)]\nCPU times: user 1.94 s, sys: 0.05 s, total: 2.00 s\nWall time: 2.00 s\nsage: %time D = dict(zip(L,range(len(L))))\nCPU times: user 0.01 s, sys: 0.00 s, total: 0.01 s\nWall time: 0.01 s\nsage: MS = MatrixSpace(GF(3),10000)\nsage: MS in D\nFalse\nsage: timeit(\"MS in D\", number = 10^6)\n1000000 loops, best of 3: 552 ns per loop\nsage: MS = L[5000]\nsage: MS in D\nTrue\nsage: timeit(\"MS in D\", number = 10^6)\n1000000 loops, best of 3: 540 ns per loop\n```\n\nAdding the patch from here:\n\n```\nsage: %time L = [MatrixSpace(GF(3),n) for n in range(10000)]\nCPU times: user 1.96 s, sys: 0.04 s, total: 2.00 s\nWall time: 2.00 s\nsage: %time D = dict(zip(L,range(len(L))))\nCPU times: user 0.01 s, sys: 0.00 s, total: 0.01 s\nWall time: 0.01 s\nsage: MS = MatrixSpace(GF(3),10000)\nsage: MS in D\nFalse\nsage: timeit(\"MS in D\", number = 10^6)\n1000000 loops, best of 3: 187 ns per loop\nsage: MS = L[5000]\nsage: MS in D\nTrue\nsage: timeit(\"MS in D\", number = 10^6)\n1000000 loops, best of 3: 176 ns per loop\n```\n\nHence, the time drops by 2/3. I did run make ptest successfully. Needs review!",
    "created_at": "2013-02-03T22:16:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171857",
    "user": "https://github.com/simon-king-jena"
}
```

Note that the patch also needed to change some auxiliary class `CartanType_simple_finite`, which is used to unpickle some old data. It used to inherit from `object`, but for an incompatibility of Cython types it has to inherit from `UniqueRepresentation` instead.

For the timings, I use `MatrixSpace`, which inherits from `UniqueRepresentation`:

```
sage: isinstance(MatrixSpace(GF(3),2,3), UniqueRepresentation)
True
```

With sage-5.6.rc0 plus #14017:

```
sage: %time L = [MatrixSpace(GF(3),n) for n in range(10000)]
CPU times: user 1.94 s, sys: 0.05 s, total: 2.00 s
Wall time: 2.00 s
sage: %time D = dict(zip(L,range(len(L))))
CPU times: user 0.01 s, sys: 0.00 s, total: 0.01 s
Wall time: 0.01 s
sage: MS = MatrixSpace(GF(3),10000)
sage: MS in D
False
sage: timeit("MS in D", number = 10^6)
1000000 loops, best of 3: 552 ns per loop
sage: MS = L[5000]
sage: MS in D
True
sage: timeit("MS in D", number = 10^6)
1000000 loops, best of 3: 540 ns per loop
```

Adding the patch from here:

```
sage: %time L = [MatrixSpace(GF(3),n) for n in range(10000)]
CPU times: user 1.96 s, sys: 0.04 s, total: 2.00 s
Wall time: 2.00 s
sage: %time D = dict(zip(L,range(len(L))))
CPU times: user 0.01 s, sys: 0.00 s, total: 0.01 s
Wall time: 0.01 s
sage: MS = MatrixSpace(GF(3),10000)
sage: MS in D
False
sage: timeit("MS in D", number = 10^6)
1000000 loops, best of 3: 187 ns per loop
sage: MS = L[5000]
sage: MS in D
True
sage: timeit("MS in D", number = 10^6)
1000000 loops, best of 3: 176 ns per loop
```

Hence, the time drops by 2/3. I did run make ptest successfully. Needs review!



---

archive/issue_comments_171858.json:
```json
{
    "body": "Cc to Nicolas as the original author of `UniqueRepresentation`.",
    "created_at": "2013-02-04T10:06:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171858",
    "user": "https://github.com/simon-king-jena"
}
```

Cc to Nicolas as the original author of `UniqueRepresentation`.



---

archive/issue_comments_171859.json:
```json
{
    "body": "I just did some experiments with the tp_hash function from Python's C-API: It is 1/3 faster than a cythoned hash. I'll try to do similar things with the comparison methods.",
    "created_at": "2013-02-15T16:15:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171859",
    "user": "https://github.com/simon-king-jena"
}
```

I just did some experiments with the tp_hash function from Python's C-API: It is 1/3 faster than a cythoned hash. I'll try to do similar things with the comparison methods.



---

archive/issue_comments_171860.json:
```json
{
    "body": "While we are at speeding up `UniqueRepresentation`, I think we should actually refactor it. Namely, `UniqueRepresentation` serves two purposes, namely (1) caching, and (2) comparison and hash by identity.\n\nSome classes misuse `UniqueRepresentation` by only using feature (1), overriding comparison in a way that violates the unique representation condition. See my monologue at [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/EOWWTK-bUm8).\n\nI suggest to split the two features.",
    "created_at": "2013-02-17T11:30:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171860",
    "user": "https://github.com/simon-king-jena"
}
```

While we are at speeding up `UniqueRepresentation`, I think we should actually refactor it. Namely, `UniqueRepresentation` serves two purposes, namely (1) caching, and (2) comparison and hash by identity.

Some classes misuse `UniqueRepresentation` by only using feature (1), overriding comparison in a way that violates the unique representation condition. See my monologue at [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/EOWWTK-bUm8).

I suggest to split the two features.



---

archive/issue_comments_171861.json:
```json
{
    "body": "FWIW, I finished a more experimental and rather intrusive version of `UniqueRepresentation`.\n\nIdea:\n\n- Create a cdef function, that results in faster C code than what Cython makes of\n  {{{\ndef __hash__(self):\n    return id(self)\n  }}}\n- Override tp_hash with this function, for every instance of `UniqueRepresentation`. Likewise for tp_richcompare.\n\nIt remains possible to override those parts of comparison that can't be decided by looking at identity (such as \"a<b\" if \"a is not b\").\n\nIt would be great to just define the fast hash and comparison for `UniqueRepresentation` itself, but alas it seems that subclasses forget these settings, whether they override `__hash__` or not. See the comments on sage-devel.\n\nI still think it is a good idea to separate `UniqueRepresentation` from `CachedRepresentation`, but I am not so sure about *enforcing* the uniqueness behaviour, without the possibility to override it---this wouldn't be pythonic...\n\nLet the patchbot do some work:\n\nApply trac14054_fast_methods.patch",
    "created_at": "2013-02-18T06:30:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171861",
    "user": "https://github.com/simon-king-jena"
}
```

FWIW, I finished a more experimental and rather intrusive version of `UniqueRepresentation`.

Idea:

- Create a cdef function, that results in faster C code than what Cython makes of
  {{{
def __hash__(self):
    return id(self)
  }}}
- Override tp_hash with this function, for every instance of `UniqueRepresentation`. Likewise for tp_richcompare.

It remains possible to override those parts of comparison that can't be decided by looking at identity (such as "a<b" if "a is not b").

It would be great to just define the fast hash and comparison for `UniqueRepresentation` itself, but alas it seems that subclasses forget these settings, whether they override `__hash__` or not. See the comments on sage-devel.

I still think it is a good idea to separate `UniqueRepresentation` from `CachedRepresentation`, but I am not so sure about *enforcing* the uniqueness behaviour, without the possibility to override it---this wouldn't be pythonic...

Let the patchbot do some work:

Apply trac14054_fast_methods.patch



---

archive/issue_comments_171862.json:
```json
{
    "body": "From [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/EOWWTK-bUm8), I understand that people think that separating the cache feature from the uniqueness feature of `UniqueRepresentation` is a good idea.\n\nHowever, in my old patch, I was *enforcing* uniqueness behaviour for instances of `UniqueRepresentation`. This isn't pythonic. Hence, I do differently in the new patch version.\n\n**__Question__**\n\nIn the current implementation, inheritance from `UniqueRepresentation` will overload rich comparison (==, >=, !=, etc.) inherited from a base class, but it will not overload comparison (cmp). Do you think that *both* should be overloaded?\n\nPatchbot reported two failures with the previous patch version. I guess that's because of an additional dependency. So, as soon as I have a decent internet connection, I'll download the latest beta, and rebase on top of it.\n\nApply trac14054_fast_methods.patch",
    "created_at": "2013-02-19T08:52:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171862",
    "user": "https://github.com/simon-king-jena"
}
```

From [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/EOWWTK-bUm8), I understand that people think that separating the cache feature from the uniqueness feature of `UniqueRepresentation` is a good idea.

However, in my old patch, I was *enforcing* uniqueness behaviour for instances of `UniqueRepresentation`. This isn't pythonic. Hence, I do differently in the new patch version.

**__Question__**

In the current implementation, inheritance from `UniqueRepresentation` will overload rich comparison (==, >=, !=, etc.) inherited from a base class, but it will not overload comparison (cmp). Do you think that *both* should be overloaded?

Patchbot reported two failures with the previous patch version. I guess that's because of an additional dependency. So, as soon as I have a decent internet connection, I'll download the latest beta, and rebase on top of it.

Apply trac14054_fast_methods.patch



---

archive/issue_comments_171863.json:
```json
{
    "body": "Other question: Does `provide_hash_by_id` really make sense to have?",
    "created_at": "2013-02-19T09:41:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171863",
    "user": "https://github.com/simon-king-jena"
}
```

Other question: Does `provide_hash_by_id` really make sense to have?



---

archive/issue_comments_171864.json:
```json
{
    "body": "The updated patch should make the coverage script happy, but three tests with 5.7.rc0 currently fail. I am downloading 5.7.rc0 now.\n\nApply trac14054_fast_methods.patch",
    "created_at": "2013-02-19T10:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171864",
    "user": "https://github.com/simon-king-jena"
}
```

The updated patch should make the coverage script happy, but three tests with 5.7.rc0 currently fail. I am downloading 5.7.rc0 now.

Apply trac14054_fast_methods.patch



---

archive/issue_comments_171865.json:
```json
{
    "body": "I am not qualified to look over this ticket, but glancing at it I spotted this\n\n```\n308\t        complete = complete = self.complete() \n```\nwhich looks like a typo.",
    "created_at": "2013-02-19T12:38:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171865",
    "user": "https://trac.sagemath.org/admin/accounts/users/jlopez"
}
```

I am not qualified to look over this ticket, but glancing at it I spotted this

```
308	        complete = complete = self.complete() 
```
which looks like a typo.



---

archive/issue_comments_171866.json:
```json
{
    "body": "Replying to [comment:9 jlopez]:\n> I am not qualified to look over this ticket, but glancing at it I spotted this\n> \n> ```\n> 308\t        complete = complete = self.complete() \n> ```\n> which looks like a typo.\n\n\nYes, thank you for spotting it! Will remove it when I rebase the patch against 5.7.rc0.",
    "created_at": "2013-02-19T12:47:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171866",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:9 jlopez]:
> I am not qualified to look over this ticket, but glancing at it I spotted this
> 
> ```
> 308	        complete = complete = self.complete() 
> ```
> which looks like a typo.


Yes, thank you for spotting it! Will remove it when I rebase the patch against 5.7.rc0.



---

archive/issue_comments_171867.json:
```json
{
    "body": "Hey Simon,\n\nLet me know when this is ready for review again.\n\nBest,\n\nTravis",
    "created_at": "2013-02-19T15:24:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171867",
    "user": "https://github.com/tscrim"
}
```

Hey Simon,

Let me know when this is ready for review again.

Best,

Travis



---

archive/issue_comments_171868.json:
```json
{
    "body": "The patch should now be ready for review.\n\nTwo questions that I'd like to have addressed:\n\n1. I introduce `provide_hash_by_id`, but I don't use it. Shall it be deleted?\n2. Is it enough to override the rich comparison methods? Currently, one can have `hash(a)!=hash(b)` but `cmp(a,b)==0`. Does this violate the contract of hash functions? Or is it enough that `hash(a)!=hash(b)` implies `a!=b`?\n\nPathbot:\n\nApply trac14054_fast_methods.patch",
    "created_at": "2013-02-19T16:00:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171868",
    "user": "https://github.com/simon-king-jena"
}
```

The patch should now be ready for review.

Two questions that I'd like to have addressed:

1. I introduce `provide_hash_by_id`, but I don't use it. Shall it be deleted?
2. Is it enough to override the rich comparison methods? Currently, one can have `hash(a)!=hash(b)` but `cmp(a,b)==0`. Does this violate the contract of hash functions? Or is it enough that `hash(a)!=hash(b)` implies `a!=b`?

Pathbot:

Apply trac14054_fast_methods.patch



---

archive/issue_comments_171869.json:
```json
{
    "body": "To answer the question about the hash contract:\n\nApparently dictionaries use the rich comparison methods and not cmp:\n\n```\nsage: class Bla(object):\n....:     def __hash__(self):\n....:         return 2\n....:     def __cmp__(self, other):\n....:         return 0\n....:     def __eq__(self, other):\n....:         return self is other\n....:     def __ne__(self, other):\n....:         return self is not other\n....:     \nsage: a = Bla()\nsage: b = Bla()\nsage: a==b\nFalse\nsage: hash(a)==hash(b)\nTrue\nsage: cmp(a,b)\n0\nsage: D = {a:1}\n```\n\nSince `hash(a)==hash(b)`, a and b belong to the same hash bucket of the dictionary. And comparison by cmp tells that they are equal. But we still have:\n\n```\nsage: D[b]\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n<ipython-input-8-6cf1ee6b63d5> in <module>()\n----> 1 D[b]\n\nKeyError: <__main__.Bla object at 0x5064310>\n```\n\nHence, dictionaries use comparison by `==`, and thus my patch does the right thing, IMHO.",
    "created_at": "2013-02-19T16:04:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171869",
    "user": "https://github.com/simon-king-jena"
}
```

To answer the question about the hash contract:

Apparently dictionaries use the rich comparison methods and not cmp:

```
sage: class Bla(object):
....:     def __hash__(self):
....:         return 2
....:     def __cmp__(self, other):
....:         return 0
....:     def __eq__(self, other):
....:         return self is other
....:     def __ne__(self, other):
....:         return self is not other
....:     
sage: a = Bla()
sage: b = Bla()
sage: a==b
False
sage: hash(a)==hash(b)
True
sage: cmp(a,b)
0
sage: D = {a:1}
```

Since `hash(a)==hash(b)`, a and b belong to the same hash bucket of the dictionary. And comparison by cmp tells that they are equal. But we still have:

```
sage: D[b]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-8-6cf1ee6b63d5> in <module>()
----> 1 D[b]

KeyError: <__main__.Bla object at 0x5064310>
```

Hence, dictionaries use comparison by `==`, and thus my patch does the right thing, IMHO.



---

archive/issue_comments_171870.json:
```json
{
    "body": "Replying to [comment:12 SimonKing]:\n> 1. I introduce `provide_hash_by_id`, but I don't use it. Shall it be deleted?\n\n\nYes, you should. I'm pretty sure changing `type->tp_hash` after calling `PyType_Ready()` is not supported by the Python C-API (see the inheritance problems we saw).\n\n> 2. Is it enough to override the rich comparison methods? Currently, one can have `hash(a)!=hash(b)` but `cmp(a,b)==0`.\n\n\n> Does this violate the contract of hash functions? Or is it enough that `hash(a)!=hash(b)` implies `a!=b`?\n\n\nI think Python requires `hash(a)!=hash(b)` implies `not(a==b)`, which Python does not enforce to be the same thing. In any case, I'm pretty sure that \"rich comparison\" is fully exhausted before trying to use `__cmp__`, which is only there because of backward compatibility.\n\nThere's another peculiarity for membership and lookup in python:\n\n```\nsage: class neq(object):\n....:     def __eq__(self,other):\n....:         return False\n....:     def __ne__(self,other):\n....:         return True\n....:     \nsage: a=neq()\nsage: V={a}\nsage: a in V\nTrue\nsage: sage: [a == v for v in V]\n[False]\n```\nThey explicitly mention this in the documentation: because hash collisions are rare, they first test \"is\" for dict lookup before trying \"==\" (it's cheaper).",
    "created_at": "2013-02-19T17:25:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171870",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:12 SimonKing]:
> 1. I introduce `provide_hash_by_id`, but I don't use it. Shall it be deleted?


Yes, you should. I'm pretty sure changing `type->tp_hash` after calling `PyType_Ready()` is not supported by the Python C-API (see the inheritance problems we saw).

> 2. Is it enough to override the rich comparison methods? Currently, one can have `hash(a)!=hash(b)` but `cmp(a,b)==0`.


> Does this violate the contract of hash functions? Or is it enough that `hash(a)!=hash(b)` implies `a!=b`?


I think Python requires `hash(a)!=hash(b)` implies `not(a==b)`, which Python does not enforce to be the same thing. In any case, I'm pretty sure that "rich comparison" is fully exhausted before trying to use `__cmp__`, which is only there because of backward compatibility.

There's another peculiarity for membership and lookup in python:

```
sage: class neq(object):
....:     def __eq__(self,other):
....:         return False
....:     def __ne__(self,other):
....:         return True
....:     
sage: a=neq()
sage: V={a}
sage: a in V
True
sage: sage: [a == v for v in V]
[False]
```
They explicitly mention this in the documentation: because hash collisions are rare, they first test "is" for dict lookup before trying "==" (it's cheaper).



---

archive/issue_comments_171871.json:
```json
{
    "body": "Replying to [comment:14 nbruin]:\n> Replying to [comment:12 SimonKing]:\n> > 1. I introduce `provide_hash_by_id`, but I don't use it. Shall it be deleted?\n  \n> \n> Yes, you should.\n\n\nOK.\n\n> > Does this violate the contract of hash functions? Or is it enough that `hash(a)!=hash(b)` implies `a!=b`?\n\n> \n> I think Python requires `hash(a)!=hash(b)` implies `not(a==b)`,\n\n\nRight, that's a difference.\n\n> In any case, I'm pretty sure that \"rich comparison\" is fully exhausted before trying to use `__cmp__`, which is only there because of backward compatibility.\n\n\nNope! See my post on [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/EOWWTK-bUm8).\n\nIf you have a non-cdef class, then it seems `__richcmp__` is simply ignored (but methods like `__eq__` have precedence over `__cmp__`). In a cdef class, `__richcmp__` has priority over `__cmp__` when deciding binary relations such as ==, <, <=, etc. But for cmp(*,*), `__cmp__` will be used, even if there is `__richcmp__`!\n\nSo, the decisive question is: Do dictionaries compare stuff by cmp(a,b)==0 or by a==b?\n\nIt is the latter, and thus making `__richcmp__` compatible with `__hash__` was the right thing to do.\n\nFor now, it needs work, because I will delete the C API hack, and apparently some script of the patchbot has a complaint...",
    "created_at": "2013-02-19T17:45:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171871",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:14 nbruin]:
> Replying to [comment:12 SimonKing]:
> > 1. I introduce `provide_hash_by_id`, but I don't use it. Shall it be deleted?
  
> 
> Yes, you should.


OK.

> > Does this violate the contract of hash functions? Or is it enough that `hash(a)!=hash(b)` implies `a!=b`?

> 
> I think Python requires `hash(a)!=hash(b)` implies `not(a==b)`,


Right, that's a difference.

> In any case, I'm pretty sure that "rich comparison" is fully exhausted before trying to use `__cmp__`, which is only there because of backward compatibility.


Nope! See my post on [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/EOWWTK-bUm8).

If you have a non-cdef class, then it seems `__richcmp__` is simply ignored (but methods like `__eq__` have precedence over `__cmp__`). In a cdef class, `__richcmp__` has priority over `__cmp__` when deciding binary relations such as ==, <, <=, etc. But for cmp(*,*), `__cmp__` will be used, even if there is `__richcmp__`!

So, the decisive question is: Do dictionaries compare stuff by cmp(a,b)==0 or by a==b?

It is the latter, and thus making `__richcmp__` compatible with `__hash__` was the right thing to do.

For now, it needs work, because I will delete the C API hack, and apparently some script of the patchbot has a complaint...



---

archive/issue_comments_171872.json:
```json
{
    "body": "Attachment [trac14054_fast_methods.patch](tarball://root/attachments/some-uuid/ticket14054/trac14054_fast_methods.patch) by @simon-king-jena created at 2013-02-19 17:50:20\n\nSeparate cache and uniqueness.",
    "created_at": "2013-02-19T17:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171872",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac14054_fast_methods.patch](tarball://root/attachments/some-uuid/ticket14054/trac14054_fast_methods.patch) by @simon-king-jena created at 2013-02-19 17:50:20

Separate cache and uniqueness.



---

archive/issue_comments_171873.json:
```json
{
    "body": "Done!\n\nIt seems that the patchbot complains about an increased startup time. How did that happen? Is it because of a slightly longer mro for `UniqueRepresentation`?\n\nPatchbot:\n\nApply trac14054_fast_methods.patch",
    "created_at": "2013-02-19T17:51:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171873",
    "user": "https://github.com/simon-king-jena"
}
```

Done!

It seems that the patchbot complains about an increased startup time. How did that happen? Is it because of a slightly longer mro for `UniqueRepresentation`?

Patchbot:

Apply trac14054_fast_methods.patch



---

archive/issue_comments_171874.json:
```json
{
    "body": "What's your rationale to define 'a < b' etc. when `a is b`? I agree that it's likely that your answers are what any ordering override will want, but Python does not mandate any particular properties of semantics of these operators. So I think the proper thing is to just not do anything there. It's going to be a rare occasion anyway, so a little speed gain won't be very noticeable anyway.\n\nThe behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.\n\nI think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way. Your motivation here seems to be as much to provide conceptual units in preference of just technical implementation tools as to provide more efficient implementations. Someone writing a Python class may not know what \"richcomp\" is, and doesn't need to.",
    "created_at": "2013-02-20T17:51:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171874",
    "user": "https://github.com/nbruin"
}
```

What's your rationale to define 'a < b' etc. when `a is b`? I agree that it's likely that your answers are what any ordering override will want, but Python does not mandate any particular properties of semantics of these operators. So I think the proper thing is to just not do anything there. It's going to be a rare occasion anyway, so a little speed gain won't be very noticeable anyway.

The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.

I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way. Your motivation here seems to be as much to provide conceptual units in preference of just technical implementation tools as to provide more efficient implementations. Someone writing a Python class may not know what "richcomp" is, and doesn't need to.



---

archive/issue_comments_171875.json:
```json
{
    "body": "Hey,\n\nReplying to [comment:17 nbruin]:\n> What's your rationale to define 'a < b' etc. when `a is b`? I agree that it's likely that your answers are what any ordering override will want, but Python does not mandate any particular properties of semantics of these operators. So I think the proper thing is to just not do anything there. It's going to be a rare occasion anyway, so a little speed gain won't be very noticeable anyway.\n\n\nSo how would you want comparisons in the complex numbers to behave? In python, they return an error:\n\n```\nsage: complex(2+2*i) < complex(2-2*i)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-2-ce2e269601f6> in <module>()\n----> 1 complex(Integer(2)+Integer(2)*i) < complex(Integer(2)-Integer(2)*i)\n\nTypeError: no ordering relation is defined for complex numbers\n```\nHowever in sage they are not so well-behaved (see #14088):\n\n```\nsage: CC(1+2*i) < CC(2-2*i)\nTrue\n```\nso there's no prescribed sage way.\n\nAs far as the actual comparison code, I think it would be better to do something like\n\n```\nif m == 2:\n    return True\nelif m == 3:\n    return False\nelse:\n    return m == 1 or m == 5\n```\nbut this is a micro-optimization, so feel free to ignore this.\n\n> The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.\n> \n> I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way. Your motivation here seems to be as much to provide conceptual units in preference of just technical implementation tools as to provide more efficient implementations. Someone writing a Python class may not know what \"richcomp\" is, and doesn't need to.\n\n\nI believe the response to both of these points depends on how we want to do comparison between objects (when there is not a [natural] ordering).\n\nLast thing for now, shouldn't we issue a deprecation warning for `FastHashable_class` since it has changed locations?\n\nThanks,\n\nTravis",
    "created_at": "2013-02-20T20:03:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171875",
    "user": "https://github.com/tscrim"
}
```

Hey,

Replying to [comment:17 nbruin]:
> What's your rationale to define 'a < b' etc. when `a is b`? I agree that it's likely that your answers are what any ordering override will want, but Python does not mandate any particular properties of semantics of these operators. So I think the proper thing is to just not do anything there. It's going to be a rare occasion anyway, so a little speed gain won't be very noticeable anyway.


So how would you want comparisons in the complex numbers to behave? In python, they return an error:

```
sage: complex(2+2*i) < complex(2-2*i)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-2-ce2e269601f6> in <module>()
----> 1 complex(Integer(2)+Integer(2)*i) < complex(Integer(2)-Integer(2)*i)

TypeError: no ordering relation is defined for complex numbers
```
However in sage they are not so well-behaved (see #14088):

```
sage: CC(1+2*i) < CC(2-2*i)
True
```
so there's no prescribed sage way.

As far as the actual comparison code, I think it would be better to do something like

```
if m == 2:
    return True
elif m == 3:
    return False
else:
    return m == 1 or m == 5
```
but this is a micro-optimization, so feel free to ignore this.

> The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.
> 
> I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way. Your motivation here seems to be as much to provide conceptual units in preference of just technical implementation tools as to provide more efficient implementations. Someone writing a Python class may not know what "richcomp" is, and doesn't need to.


I believe the response to both of these points depends on how we want to do comparison between objects (when there is not a [natural] ordering).

Last thing for now, shouldn't we issue a deprecation warning for `FastHashable_class` since it has changed locations?

Thanks,

Travis



---

archive/issue_comments_171876.json:
```json
{
    "body": "The issue is that if someone wants to define\n\n```\nclass C(WithEqualityById):\n    def __cmp__(self,other):\n        return -1\n```\nthey will find that\n\n```\nsage: a=C()\nsage: a < a\nFalse\n```\nwhich might surprise them, because they thought that `WithEqualityById` only affected (in)equality testing and let ordering comparisons fall through to `__cmp__` if implemented. With the current code, this is not the case if the two arguments are identical.\n\nThere have been extensive discussions about what inequality testing SHOULD be in sage and for the most part the implementation here is staying clear of the topic (which I think is a good thing). There's just this one small optimization that's probably usually OK, but if left out makes for much more predictable behaviour.",
    "created_at": "2013-02-20T20:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171876",
    "user": "https://github.com/nbruin"
}
```

The issue is that if someone wants to define

```
class C(WithEqualityById):
    def __cmp__(self,other):
        return -1
```
they will find that

```
sage: a=C()
sage: a < a
False
```
which might surprise them, because they thought that `WithEqualityById` only affected (in)equality testing and let ordering comparisons fall through to `__cmp__` if implemented. With the current code, this is not the case if the two arguments are identical.

There have been extensive discussions about what inequality testing SHOULD be in sage and for the most part the implementation here is staying clear of the topic (which I think is a good thing). There's just this one small optimization that's probably usually OK, but if left out makes for much more predictable behaviour.



---

archive/issue_comments_171877.json:
```json
{
    "body": "Replying to [comment:17 nbruin]:\n> What's your rationale to define 'a < b' etc. when `a is b`? I agree that it's likely that your answers are what any ordering override will want, but Python does not mandate any particular properties of semantics of these operators.\n\n\nPython does not. But I think \"comparison by identity\" implies a semantics. And that is: `a < a` is False, `a <= a` is True.\n\n> The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.\n\n\nOK. \n\n> I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way.\n\n\nGood idea.\n\nReplying to [comment:18 tscrim]:\n> Last thing for now, shouldn't we issue a deprecation warning for `FastHashable_class` since it has changed locations?\n\n\nI think I introduced it. But when? Or what ticket? I don't think anyone used it.",
    "created_at": "2013-02-20T21:56:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171877",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:17 nbruin]:
> What's your rationale to define 'a < b' etc. when `a is b`? I agree that it's likely that your answers are what any ordering override will want, but Python does not mandate any particular properties of semantics of these operators.


Python does not. But I think "comparison by identity" implies a semantics. And that is: `a < a` is False, `a <= a` is True.

> The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.


OK. 

> I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way.


Good idea.

Replying to [comment:18 tscrim]:
> Last thing for now, shouldn't we issue a deprecation warning for `FastHashable_class` since it has changed locations?


I think I introduced it. But when? Or what ticket? I don't think anyone used it.



---

archive/issue_comments_171878.json:
```json
{
    "body": "Replying to [comment:20 SimonKing]:\n> > The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.\n\n> \n> OK. \n> \n> > I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way.\n\n> \n> Good idea.\n\n\nNote: I would not like the name \"`WithCmpById`\", because `cmp` relies on `__cmp__` (which is not touched) even if `__richcmp__` exists.\n \n> Replying to [comment:18 tscrim]:\n> > Last thing for now, shouldn't we issue a deprecation warning for `FastHashable_class` since it has changed locations?\n\n> \n> I think I introduced it. But when? Or what ticket? I don't think anyone used it.\n\n\n\nIt was in #11900. We could of course keep it in sage.categories.category_singleton, but I think that's not the right place. Note that I remove the dependency of `CategorySingleton` on `FastHashable_class`, because the new cythoned hash is slightly faster.",
    "created_at": "2013-02-21T11:10:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171878",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:20 SimonKing]:
> > The behaviour you are implementing is much easier to explain if you don't override those cases: Then you can just say that `WithRichCmpById` provides `__hash__`, `__eq__` and `__ne__`, period.

> 
> OK. 
> 
> > I think `WithEqualityById` would make a better conceptual name that is less dependent on the implementation, by the way.

> 
> Good idea.


Note: I would not like the name "`WithCmpById`", because `cmp` relies on `__cmp__` (which is not touched) even if `__richcmp__` exists.
 
> Replying to [comment:18 tscrim]:
> > Last thing for now, shouldn't we issue a deprecation warning for `FastHashable_class` since it has changed locations?

> 
> I think I introduced it. But when? Or what ticket? I don't think anyone used it.



It was in #11900. We could of course keep it in sage.categories.category_singleton, but I think that's not the right place. Note that I remove the dependency of `CategorySingleton` on `FastHashable_class`, because the new cythoned hash is slightly faster.



---

archive/issue_comments_171879.json:
```json
{
    "body": "This will not go into 5.7 anyway. Hence, I was rebasing against #6495 (which is a minor change anyway). In addition, I took into account your comments:\n\n- I rename the new class into `WithEqualityById`.\n- I move `FastHashable_class` back into category_singleton (wrong as this may be...)\n\nI hope this addresses all complaints.\n\nApply trac14054_fast_methods-5.8.patch",
    "created_at": "2013-02-21T17:47:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171879",
    "user": "https://github.com/simon-king-jena"
}
```

This will not go into 5.7 anyway. Hence, I was rebasing against #6495 (which is a minor change anyway). In addition, I took into account your comments:

- I rename the new class into `WithEqualityById`.
- I move `FastHashable_class` back into category_singleton (wrong as this may be...)

I hope this addresses all complaints.

Apply trac14054_fast_methods-5.8.patch



---

archive/issue_comments_171880.json:
```json
{
    "body": "Oops, I forgot to rename two occurrences of `WithRichCmpById` into `WithEqualityById`...\n\nShould now pass all tests.\n\nApply trac14054_fast_methods-5.8.patch",
    "created_at": "2013-02-22T13:15:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171880",
    "user": "https://github.com/simon-king-jena"
}
```

Oops, I forgot to rename two occurrences of `WithRichCmpById` into `WithEqualityById`...

Should now pass all tests.

Apply trac14054_fast_methods-5.8.patch



---

archive/issue_comments_171881.json:
```json
{
    "body": "Strange. I can not replicate the error reported by the patchbot.",
    "created_at": "2013-02-22T23:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171881",
    "user": "https://github.com/simon-king-jena"
}
```

Strange. I can not replicate the error reported by the patchbot.



---

archive/issue_comments_171882.json:
```json
{
    "body": "Neither can I by hand or testing the individual files. It has to be something since the testbot can reproduce it... Have you tried running testall by chance? I ran tests in the `categories` folder than on `free_module.py` and that passed.\n\nIt must have something to testing things in the right order...I'm wondering if the problem lies with `free_module.tensor_constructor()` being a cached_method and something is being improperly stored...",
    "created_at": "2013-02-23T16:26:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171882",
    "user": "https://github.com/tscrim"
}
```

Neither can I by hand or testing the individual files. It has to be something since the testbot can reproduce it... Have you tried running testall by chance? I ran tests in the `categories` folder than on `free_module.py` and that passed.

It must have something to testing things in the right order...I'm wondering if the problem lies with `free_module.tensor_constructor()` being a cached_method and something is being improperly stored...



---

archive/issue_comments_171883.json:
```json
{
    "body": "Replying to [comment:25 tscrim]:\n> It must have something to testing things in the right order...I'm wondering if the problem lies with `free_module.tensor_constructor()` being a cached_method and something is being improperly stored...\n\n\nThe failing assertion is\n\n```\n      File \"/mnt/storage2TB/patchbot/Sage/sage-5.8.beta0/local/lib/python/site-packages/sage/categories/modules_with_basis.py\", line 1387, in __call__\n        assert(x.parent() is self.domain())\n```\n\nI can hardly imagine that there is yet another premature deallocation via weak references in play. After all, both `x._parent` and `self._domain` are just plain strong references.",
    "created_at": "2013-02-23T18:58:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171883",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:25 tscrim]:
> It must have something to testing things in the right order...I'm wondering if the problem lies with `free_module.tensor_constructor()` being a cached_method and something is being improperly stored...


The failing assertion is

```
      File "/mnt/storage2TB/patchbot/Sage/sage-5.8.beta0/local/lib/python/site-packages/sage/categories/modules_with_basis.py", line 1387, in __call__
        assert(x.parent() is self.domain())
```

I can hardly imagine that there is yet another premature deallocation via weak references in play. After all, both `x._parent` and `self._domain` are just plain strong references.



---

archive/issue_comments_171884.json:
```json
{
    "body": "This parent mismatch happens in a morphism call. If a morphism gets registered in the wrong slot in a conversion/coercion then it could indeed end up getting mismatched input (shouldn't `__call__` be a little more permissive about its arguments by the way? Certainly, an error would be more appropriate than an assert if this is something that actually can go wrong)\n\nAnyway, `TripleDict` does store homomorphisms and we've recently seen it's not entirely safe wrt. garbage collections that can happen during update procedures. That can cause homomorphisms to get registered under the wrong domain/codomain keys.\n\nI think it's extremely unlikely that this is happening in this particular situation, but if all other conceivable alternatives are impossible ... (since the corruption would be dependent on a GC happening at just the wrong time, it would be extremely fickle behaviour that is very hard to reproduce).\n\nOf course, if this test is using a map that wasn't retrieved from a `TripleDict` or a `MonoDict` the above explanation is impossible.",
    "created_at": "2013-02-23T19:32:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171884",
    "user": "https://github.com/nbruin"
}
```

This parent mismatch happens in a morphism call. If a morphism gets registered in the wrong slot in a conversion/coercion then it could indeed end up getting mismatched input (shouldn't `__call__` be a little more permissive about its arguments by the way? Certainly, an error would be more appropriate than an assert if this is something that actually can go wrong)

Anyway, `TripleDict` does store homomorphisms and we've recently seen it's not entirely safe wrt. garbage collections that can happen during update procedures. That can cause homomorphisms to get registered under the wrong domain/codomain keys.

I think it's extremely unlikely that this is happening in this particular situation, but if all other conceivable alternatives are impossible ... (since the corruption would be dependent on a GC happening at just the wrong time, it would be extremely fickle behaviour that is very hard to reproduce).

Of course, if this test is using a map that wasn't retrieved from a `TripleDict` or a `MonoDict` the above explanation is impossible.



---

archive/issue_comments_171885.json:
```json
{
    "body": "Replying to [comment:27 nbruin]:\n> This parent mismatch happens in a morphism call. If a morphism gets registered in the wrong slot in a conversion/coercion then it could indeed end up getting mismatched input\n\n\nIf it is in a wrong slot (you mean: Addressed by a non-identic copy of a parent?) then it should simply not occur here, because `TripleDict` would compare by identity.\n\n> (shouldn't `__call__` be a little more permissive about its arguments by the way? Certainly, an error would be more appropriate than an assert if this is something that actually can go wrong)\n\n\nNo, I think an assertion is the right thing to do here. Perhaps one could provide the assertion with an error message that names the two parents that don't match. In that way, we could at least see what two parents are involved.\n\nNote that my patch changes `CombinatorialFreeModule` from `UniqueRepresentation` to `CachedRepresentation`, since it overrides the equality tests. So, it could actually be that the two parents are genuinely non-unique. And since a cached_method is involved here, which does comparison by equality and not identity, we could really be in trouble here.\n\nOf course, it could be that changing to `CachedRepresentation` was wrong in this case.",
    "created_at": "2013-02-23T19:44:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171885",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:27 nbruin]:
> This parent mismatch happens in a morphism call. If a morphism gets registered in the wrong slot in a conversion/coercion then it could indeed end up getting mismatched input


If it is in a wrong slot (you mean: Addressed by a non-identic copy of a parent?) then it should simply not occur here, because `TripleDict` would compare by identity.

> (shouldn't `__call__` be a little more permissive about its arguments by the way? Certainly, an error would be more appropriate than an assert if this is something that actually can go wrong)


No, I think an assertion is the right thing to do here. Perhaps one could provide the assertion with an error message that names the two parents that don't match. In that way, we could at least see what two parents are involved.

Note that my patch changes `CombinatorialFreeModule` from `UniqueRepresentation` to `CachedRepresentation`, since it overrides the equality tests. So, it could actually be that the two parents are genuinely non-unique. And since a cached_method is involved here, which does comparison by equality and not identity, we could really be in trouble here.

Of course, it could be that changing to `CachedRepresentation` was wrong in this case.



---

archive/issue_comments_171886.json:
```json
{
    "body": "Replying to [comment:28 SimonKing]:\n> If it is in a wrong slot (you mean: Addressed by a non-identic copy of a parent?) then it should simply not occur here, because `TripleDict` would compare by identity.\n\n\nNo, what I meant is: bucket position to write value into gets determined, dictionary gets changed due to a GC, value gets placed into bucket position determined earlier, which now belongs to an entirely different key triple. Without #13387 we couldn't strictly exclude that from happening, but it would need extreme bad luck.\n\nYour hypothesis sounds much more probable.",
    "created_at": "2013-02-24T02:46:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171886",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:28 SimonKing]:
> If it is in a wrong slot (you mean: Addressed by a non-identic copy of a parent?) then it should simply not occur here, because `TripleDict` would compare by identity.


No, what I meant is: bucket position to write value into gets determined, dictionary gets changed due to a GC, value gets placed into bucket position determined earlier, which now belongs to an entirely different key triple. Without #13387 we couldn't strictly exclude that from happening, but it would need extreme bad luck.

Your hypothesis sounds much more probable.



---

archive/issue_comments_171887.json:
```json
{
    "body": "By the way: One reason for removing `FastHashable_class` from sage.categories.category_singleton is the fact that the hash inherited from the cythoned version of `UniqueRepresentation` is faster than what was provided by `FastHashable_class`.",
    "created_at": "2013-02-24T21:49:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171887",
    "user": "https://github.com/simon-king-jena"
}
```

By the way: One reason for removing `FastHashable_class` from sage.categories.category_singleton is the fact that the hash inherited from the cythoned version of `UniqueRepresentation` is faster than what was provided by `FastHashable_class`.



---

archive/issue_comments_171888.json:
```json
{
    "body": "Replying to [comment:30 SimonKing]:\n> By the way: One reason for removing `FastHashable_class` from sage.categories.category_singleton is the fact that the hash inherited from the cythoned version of `UniqueRepresentation` is faster than what was provided by `FastHashable_class`.\n\n\nI didn't want it to not be removed, but I thought it was suppose to have a deprecation warning saying the class had moved/changed namespaces?",
    "created_at": "2013-02-25T04:02:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171888",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:30 SimonKing]:
> By the way: One reason for removing `FastHashable_class` from sage.categories.category_singleton is the fact that the hash inherited from the cythoned version of `UniqueRepresentation` is faster than what was provided by `FastHashable_class`.


I didn't want it to not be removed, but I thought it was suppose to have a deprecation warning saying the class had moved/changed namespaces?



---

archive/issue_comments_171889.json:
```json
{
    "body": "Replying to [comment:31 tscrim]:\n> I didn't want it to not be removed, but I thought it was suppose to have a deprecation warning saying the class had moved/changed namespaces?\n\n\nWould you mind to just leave it in its original space (being an orphan, though)?\n\nOtherwise: How does one deprecate a class that has no init method?",
    "created_at": "2013-02-25T06:29:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171889",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:31 tscrim]:
> I didn't want it to not be removed, but I thought it was suppose to have a deprecation warning saying the class had moved/changed namespaces?


Would you mind to just leave it in its original space (being an orphan, though)?

Otherwise: How does one deprecate a class that has no init method?



---

archive/issue_comments_171890.json:
```json
{
    "body": "Replying to [comment:32 SimonKing]: \n> Otherwise: How does one deprecate a class that has no init method?\n\n\n\"Had\" no init method, I should say.\n\nAnyway, if I move it to a different file, then the import statement \"`from sage.categories.category_singleton import FastHashable_class`\" should result in a deprecation warning. How can this be achieved?",
    "created_at": "2013-02-25T06:31:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171890",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:32 SimonKing]: 
> Otherwise: How does one deprecate a class that has no init method?


"Had" no init method, I should say.

Anyway, if I move it to a different file, then the import statement "`from sage.categories.category_singleton import FastHashable_class`" should result in a deprecation warning. How can this be achieved?



---

archive/issue_comments_171891.json:
```json
{
    "body": "Let's test whether the safer use of callbacks for weak references to Homsets stored in a `TripleDict` from #14159 will fix the problem here.\n\nApply http://trac.sagemath.org/sage_trac/raw-attachment/ticket/14054/trac14054_fast_methods-5.8.patch",
    "created_at": "2013-02-25T12:06:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171891",
    "user": "https://github.com/simon-king-jena"
}
```

Let's test whether the safer use of callbacks for weak references to Homsets stored in a `TripleDict` from #14159 will fix the problem here.

Apply http://trac.sagemath.org/sage_trac/raw-attachment/ticket/14054/trac14054_fast_methods-5.8.patch



---

archive/issue_comments_171892.json:
```json
{
    "body": "Patchbot,\n\nApply trac14054_fast_methods-5.8.patch",
    "created_at": "2013-02-25T13:14:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171892",
    "user": "https://github.com/simon-king-jena"
}
```

Patchbot,

Apply trac14054_fast_methods-5.8.patch



---

archive/issue_comments_171893.json:
```json
{
    "body": "Hooray, I can reproduce the assertion error (it only occurs with the patch from here)! So, that should make it possible to debug it.",
    "created_at": "2013-02-25T13:35:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171893",
    "user": "https://github.com/simon-king-jena"
}
```

Hooray, I can reproduce the assertion error (it only occurs with the patch from here)! So, that should make it possible to debug it.



---

archive/issue_comments_171894.json:
```json
{
    "body": "Replying to [comment:32 SimonKing]:\n> Would you mind to just leave it in its original space (being an orphan, though)?\n> \n> Otherwise: How does one deprecate a class that has no init method?\n\n\nWhat I've done is turned the class into a function and have that function return the desired class after issuing the deprecation warning. I guess an alternative would be to implement a custom __call__ which does the same as above.\n\nHow are you reproducing the assertion error?",
    "created_at": "2013-02-25T13:46:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171894",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:32 SimonKing]:
> Would you mind to just leave it in its original space (being an orphan, though)?
> 
> Otherwise: How does one deprecate a class that has no init method?


What I've done is turned the class into a function and have that function return the desired class after issuing the deprecation warning. I guess an alternative would be to implement a custom __call__ which does the same as above.

How are you reproducing the assertion error?



---

archive/issue_comments_171895.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> How are you reproducing the assertion error?\n\n\nBy running `./sage -t  -force_lib devel/sage/sage/combinat/free_module.py` with sage-5.8.beta0 plus #12313, #13387, #14159 and #14054.",
    "created_at": "2013-02-25T13:55:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171895",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:37 tscrim]:
> How are you reproducing the assertion error?


By running `./sage -t  -force_lib devel/sage/sage/combinat/free_module.py` with sage-5.8.beta0 plus #12313, #13387, #14159 and #14054.



---

archive/issue_comments_171896.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> Replying to [comment:32 SimonKing]:\n> What I've done is turned the class into a function and have that function return the desired class after issuing the deprecation warning.\n\n\n\nPerhaps like this:\n\n```\n            sage: from sage.misc.superseded import deprecated_function_alias\n            sage: g = deprecated_function_alias(13109, number_of_partitions)\n```",
    "created_at": "2013-02-25T13:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171896",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:37 tscrim]:
> Replying to [comment:32 SimonKing]:
> What I've done is turned the class into a function and have that function return the desired class after issuing the deprecation warning.



Perhaps like this:

```
            sage: from sage.misc.superseded import deprecated_function_alias
            sage: g = deprecated_function_alias(13109, number_of_partitions)
```



---

archive/issue_comments_171897.json:
```json
{
    "body": "I hesitate to do things like\n\n```\nfrom sage.misc.superseded import deprecated_function_alias\nfrom sage.misc.fast_methods import FastFashable_class as FH_class\nFastHashable_class = deprecated_function_alias(14054,FH_class)\n```\nin sage.categories.category_singleton:\n\n- It adds an unneeded import statement\n- `FastHashable_class` is a base class, and hence one would like to inherit from it. But doing the above, `FastHashable_class` would not be a class but a function in sage.categories.category_singleton.\n- In its now deprecated use, it was necessary to *cimport* (not just import!) the class. That will be impossible, no matter what way of deprecation warning we use, because deprecation warnings won't work at compile time.\n\nIs there a \"lazy import statement with deprecation\"? Then, one would not actually import `FastHashable_class` in category_singleton, but `from sage.categories.category_singleton import FastHashable_class` would result in a deprecation warning. And we can't cope with the compile time cimport problem anyway.",
    "created_at": "2013-02-25T14:06:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171897",
    "user": "https://github.com/simon-king-jena"
}
```

I hesitate to do things like

```
from sage.misc.superseded import deprecated_function_alias
from sage.misc.fast_methods import FastFashable_class as FH_class
FastHashable_class = deprecated_function_alias(14054,FH_class)
```
in sage.categories.category_singleton:

- It adds an unneeded import statement
- `FastHashable_class` is a base class, and hence one would like to inherit from it. But doing the above, `FastHashable_class` would not be a class but a function in sage.categories.category_singleton.
- In its now deprecated use, it was necessary to *cimport* (not just import!) the class. That will be impossible, no matter what way of deprecation warning we use, because deprecation warnings won't work at compile time.

Is there a "lazy import statement with deprecation"? Then, one would not actually import `FastHashable_class` in category_singleton, but `from sage.categories.category_singleton import FastHashable_class` would result in a deprecation warning. And we can't cope with the compile time cimport problem anyway.



---

archive/issue_comments_171898.json:
```json
{
    "body": "Replying to [comment:39 SimonKing]:\n> Perhaps like this:\n> \n> ```\n>             sage: from sage.misc.superseded import deprecated_function_alias\n>             sage: g = deprecated_function_alias(13109, number_of_partitions)\n> ```\n\n\nThat might work, but I haven't tried it (in principle, I don't see why it wouldn't). What I've done is like this:\n\n```\ndef DeprecatedClass(self, arg1, arg2, ..., *old_args, **old_kwds):\n    from sage.misc.superseded import deprecation\n    deprecation(14054, \"DepC is deprecated. Use path.to.new_mod.NewClass instead\")\n    # Do whatever needs to be done to convert to NewClass's inputs\n    from path.to.new_mod import NewClass\n    return NewClass(arg1, arg2, ..., *old_args, **old_kwds)\n```\nHowever that's a good point about the inheritance...perhaps something like\n\n```\nclass Dep(NewClass):\n    def __init__(self, arg1, arg2, ..., *args, **kwds):\n        from sage.misc.superseded import deprecation\n        deprecation(14054, \"DepC is deprecated. Use path.to.new_mod.NewClass instead\")\n        NewClass.__init__(self, arg1, arg2, ..., *args, **kwds)\n```\n?",
    "created_at": "2013-02-25T14:09:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171898",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:39 SimonKing]:
> Perhaps like this:
> 
> ```
>             sage: from sage.misc.superseded import deprecated_function_alias
>             sage: g = deprecated_function_alias(13109, number_of_partitions)
> ```


That might work, but I haven't tried it (in principle, I don't see why it wouldn't). What I've done is like this:

```
def DeprecatedClass(self, arg1, arg2, ..., *old_args, **old_kwds):
    from sage.misc.superseded import deprecation
    deprecation(14054, "DepC is deprecated. Use path.to.new_mod.NewClass instead")
    # Do whatever needs to be done to convert to NewClass's inputs
    from path.to.new_mod import NewClass
    return NewClass(arg1, arg2, ..., *old_args, **old_kwds)
```
However that's a good point about the inheritance...perhaps something like

```
class Dep(NewClass):
    def __init__(self, arg1, arg2, ..., *args, **kwds):
        from sage.misc.superseded import deprecation
        deprecation(14054, "DepC is deprecated. Use path.to.new_mod.NewClass instead")
        NewClass.__init__(self, arg1, arg2, ..., *args, **kwds)
```
?



---

archive/issue_comments_171899.json:
```json
{
    "body": "Replying to [comment:41 tscrim]:\n> However that's a good point about the inheritance...perhaps something like\n> \n> ```\n> class Dep(NewClass):\n>     def __init__(self, arg1, arg2, ..., *args, **kwds):\n>         from sage.misc.superseded import deprecation\n>         deprecation(14054, \"DepC is deprecated. Use path.to.new_mod.NewClass instead\")\n>         NewClass.__init__(self, arg1, arg2, ..., *args, **kwds)\n> ```\n> ?\n\n\nWell, that would still mean that we need to actually import it.\n\nI am tempted to ask what sage-devel has to say about this issue.",
    "created_at": "2013-02-25T14:15:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171899",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:41 tscrim]:
> However that's a good point about the inheritance...perhaps something like
> 
> ```
> class Dep(NewClass):
>     def __init__(self, arg1, arg2, ..., *args, **kwds):
>         from sage.misc.superseded import deprecation
>         deprecation(14054, "DepC is deprecated. Use path.to.new_mod.NewClass instead")
>         NewClass.__init__(self, arg1, arg2, ..., *args, **kwds)
> ```
> ?


Well, that would still mean that we need to actually import it.

I am tempted to ask what sage-devel has to say about this issue.



---

archive/issue_comments_171900.json:
```json
{
    "body": "Replying to [comment:42 SimonKing]:\n> Well, that would still mean that we need to actually import it.\n\n\nI thought if we turn it into a python class, we wouldn't need to cimport it and it would only be imported if the old class was actually used? (To me honest, part of me is still wondering if we even really need a deprecation warning since it is such a low-level base class.)\n\n> I am tempted to ask what sage-devel has to say about this issue.\n\n\nThat might be for the best.",
    "created_at": "2013-02-25T14:43:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171900",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:42 SimonKing]:
> Well, that would still mean that we need to actually import it.


I thought if we turn it into a python class, we wouldn't need to cimport it and it would only be imported if the old class was actually used? (To me honest, part of me is still wondering if we even really need a deprecation warning since it is such a low-level base class.)

> I am tempted to ask what sage-devel has to say about this issue.


That might be for the best.



---

archive/issue_comments_171901.json:
```json
{
    "body": "Replying to [comment:43 tscrim]:\n> Replying to [comment:42 SimonKing]:\n> > Well, that would still mean that we need to actually import it.\n\n> \n> I thought if we turn it into a python class, we wouldn't need to cimport it\n\n\nIts original use *requires* cimport. Namely, it had no `__init__`, and setting the hash value requires writing into the cdef attribute `_hash`, thus we need cimport. Now, I added an init method---hence, *now* an import is enough.\n\n> (To me honest, part of me is still wondering if we even really need a deprecation warning since it is \n> such a low-level base class.)\n\n\nSame here...",
    "created_at": "2013-02-25T14:48:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171901",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:43 tscrim]:
> Replying to [comment:42 SimonKing]:
> > Well, that would still mean that we need to actually import it.

> 
> I thought if we turn it into a python class, we wouldn't need to cimport it


Its original use *requires* cimport. Namely, it had no `__init__`, and setting the hash value requires writing into the cdef attribute `_hash`, thus we need cimport. Now, I added an init method---hence, *now* an import is enough.

> (To me honest, part of me is still wondering if we even really need a deprecation warning since it is 
> such a low-level base class.)


Same here...



---

archive/issue_comments_171902.json:
```json
{
    "body": "Back to the failing assertion:\n\nBy inserting information on the mismatching parents, I find that indeed we get two distinct instances of the same parent `Free module generated by {1, 2, 3, 4} over Integer Ring`.\n\nSo, how is it possible to create these distinct instances? Aha! They have indeed been created in different ways. Namely, by printing the `_reduction` attribute that is set during classcall, I found that x.parent() is created with the arguments\n\n```\n(Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'y'})\n```\nbut self.domain() is created using\n\n```\n(Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'G'})\n```",
    "created_at": "2013-02-25T15:01:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171902",
    "user": "https://github.com/simon-king-jena"
}
```

Back to the failing assertion:

By inserting information on the mismatching parents, I find that indeed we get two distinct instances of the same parent `Free module generated by {1, 2, 3, 4} over Integer Ring`.

So, how is it possible to create these distinct instances? Aha! They have indeed been created in different ways. Namely, by printing the `_reduction` attribute that is set during classcall, I found that x.parent() is created with the arguments

```
(Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'y'})
```
but self.domain() is created using

```
(Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'G'})
```



---

archive/issue_comments_171903.json:
```json
{
    "body": "Replying to [comment:45 SimonKing]:\n> {{{\n> (Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'y'})\n> }}}\n> \n> ```\n> (Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'G'})\n> ```\n\n\nThat's astounding! There is no example in modules_with_basis.py which uses prefix 'y' or prefix 'G'. So, no idea where the two distinct but equal instances comes from.",
    "created_at": "2013-02-25T15:06:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171903",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:45 SimonKing]:
> {{{
> (Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'y'})
> }}}
> 
> ```
> (Integer Ring, {1, 2, 3, 4}), {'category': Category of modules with basis over Integer Ring, 'prefix': 'G'})
> ```


That's astounding! There is no example in modules_with_basis.py which uses prefix 'y' or prefix 'G'. So, no idea where the two distinct but equal instances comes from.



---

archive/issue_comments_171904.json:
```json
{
    "body": "Argh, sorry for my preceding post. It would have been needed to look at sage/combinat/free_module.py, not at sage/categories/modules_with_basis.py, where the assertion error is raised.",
    "created_at": "2013-02-25T15:08:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171904",
    "user": "https://github.com/simon-king-jena"
}
```

Argh, sorry for my preceding post. It would have been needed to look at sage/combinat/free_module.py, not at sage/categories/modules_with_basis.py, where the assertion error is raised.



---

archive/issue_comments_171905.json:
```json
{
    "body": "We have\n\n```\n        def _repr_term(self, term):\n            \"\"\"\n            TESTS::\n\n                sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix=\"F\")\n                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix=\"G\")\n                sage: f =   F.monomial(1) + 2 * F.monomial(2)\n                sage: g = 2*G.monomial(3) +     G.monomial(4)\n                sage: tensor([f, g]) # indirect doctest\n                2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]\n            \"\"\"\n```\nand \n\n```\n        def _latex_term(self, term):\n            \"\"\"\n            TESTS::\n\n                sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix='x')\n                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')\n                sage: f =   F.monomial(1) + 2 * F.monomial(2)\n                sage: g = 2*G.monomial(3) +     G.monomial(4)\n                sage: latex(tensor([f, g])) # indirect doctest\n                2x_{1} \\otimes y_{3} + x_{1} \\otimes y_{4} + 4x_{2} \\otimes y_{3} + 2x_{2} \\otimes y_{4}\n            \"\"\"\n```\nApparently, this is where the two equal free modules generated by {1, 2, 3, 4} over Integer Ring with prefix 'G' respectively 'y' are defined.\n\nNow, I see what is happening.\n\nWe have two distinct but equal parents, and the tensor construction uses a strong cache (hence, has a side-effect across tests) using comparison by *equality*. But later, we want comparison by identity. Boom. I'll ask sage-combinat-devel for advice.",
    "created_at": "2013-02-25T15:15:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171905",
    "user": "https://github.com/simon-king-jena"
}
```

We have

```
        def _repr_term(self, term):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix="F")
                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix="G")
                sage: f =   F.monomial(1) + 2 * F.monomial(2)
                sage: g = 2*G.monomial(3) +     G.monomial(4)
                sage: tensor([f, g]) # indirect doctest
                2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]
            """
```
and 

```
        def _latex_term(self, term):
            """
            TESTS::

                sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix='x')
                sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')
                sage: f =   F.monomial(1) + 2 * F.monomial(2)
                sage: g = 2*G.monomial(3) +     G.monomial(4)
                sage: latex(tensor([f, g])) # indirect doctest
                2x_{1} \otimes y_{3} + x_{1} \otimes y_{4} + 4x_{2} \otimes y_{3} + 2x_{2} \otimes y_{4}
            """
```
Apparently, this is where the two equal free modules generated by {1, 2, 3, 4} over Integer Ring with prefix 'G' respectively 'y' are defined.

Now, I see what is happening.

We have two distinct but equal parents, and the tensor construction uses a strong cache (hence, has a side-effect across tests) using comparison by *equality*. But later, we want comparison by identity. Boom. I'll ask sage-combinat-devel for advice.



---

archive/issue_comments_171906.json:
```json
{
    "body": "Yessss! The following is *without* the patch. Hence, what we see here is an existing bug, that did not show up by mere coincidence (different ordering of the doctests)!!\n\nI can trigger it on the command line (with sage-5.6.rc0 without the patch from here):\n\n```\nsage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix=\"F\")\nsage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix=\"G\")\nsage: f =   F.monomial(1) + 2 * F.monomial(2)\nsage: g = 2*G.monomial(3) +     G.monomial(4)\nsage: tensor([f, g]) # indirect doctest\n2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]\nsage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix='x')\nsage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')\nsage: f =   F.monomial(1) + 2 * F.monomial(2)\nsage: g = 2*G.monomial(3) +     G.monomial(4)\nsage: latex(tensor([f, g])) # indirect doctest\nTraceback (most recent call last):\n...\n/home/simon/SAGE/prerelease/sage-5.6.rc0/local/lib/python2.7/site-packages/sage/categories/modules_with_basis.pyc in __call__(self, *args)\n   1385         after = args[self._position+1:len(args)]\n   1386         x = args[self._position]\n-> 1387         assert(x.parent() is self.domain())\n   1388 \n   1389         if self._is_module_with_basis_over_same_base_ring:\n\nAssertionError: \n```",
    "created_at": "2013-02-25T15:26:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171906",
    "user": "https://github.com/simon-king-jena"
}
```

Yessss! The following is *without* the patch. Hence, what we see here is an existing bug, that did not show up by mere coincidence (different ordering of the doctests)!!

I can trigger it on the command line (with sage-5.6.rc0 without the patch from here):

```
sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix="F")
sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix="G")
sage: f =   F.monomial(1) + 2 * F.monomial(2)
sage: g = 2*G.monomial(3) +     G.monomial(4)
sage: tensor([f, g]) # indirect doctest
2*F[1] # G[3] + F[1] # G[4] + 4*F[2] # G[3] + 2*F[2] # G[4]
sage: F = CombinatorialFreeModule(ZZ, [1,2,3], prefix='x')
sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')
sage: f =   F.monomial(1) + 2 * F.monomial(2)
sage: g = 2*G.monomial(3) +     G.monomial(4)
sage: latex(tensor([f, g])) # indirect doctest
Traceback (most recent call last):
...
/home/simon/SAGE/prerelease/sage-5.6.rc0/local/lib/python2.7/site-packages/sage/categories/modules_with_basis.pyc in __call__(self, *args)
   1385         after = args[self._position+1:len(args)]
   1386         x = args[self._position]
-> 1387         assert(x.parent() is self.domain())
   1388 
   1389         if self._is_module_with_basis_over_same_base_ring:

AssertionError: 
```



---

archive/issue_comments_171907.json:
```json
{
    "body": "So then this ticket does not depend on #14159, correct?",
    "created_at": "2013-02-25T15:46:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171907",
    "user": "https://github.com/tscrim"
}
```

So then this ticket does not depend on #14159, correct?



---

archive/issue_comments_171908.json:
```json
{
    "body": "Replying to [comment:50 tscrim]:\n> So then this ticket does not depend on #14159, correct?\n\n\nCorrect (and corrected).",
    "created_at": "2013-02-25T15:48:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171908",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:50 tscrim]:
> So then this ticket does not depend on #14159, correct?


Correct (and corrected).



---

archive/issue_comments_171909.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-02-25T15:48:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171909",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_171910.json:
```json
{
    "body": "Back to the deprecation: Volker Braun stated on [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/ZsszjMSynmY): \"Deprecation is for user-visible functionality. No need to deprecate hash implementation details, otherwise it'll be total and immediate development standstill.\"\n\nSo, I think no deprecation for removing `FastHashable_class` should  be needed.",
    "created_at": "2013-02-25T20:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171910",
    "user": "https://github.com/simon-king-jena"
}
```

Back to the deprecation: Volker Braun stated on [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/ZsszjMSynmY): "Deprecation is for user-visible functionality. No need to deprecate hash implementation details, otherwise it'll be total and immediate development standstill."

So, I think no deprecation for removing `FastHashable_class` should  be needed.



---

archive/issue_comments_171911.json:
```json
{
    "body": "Alright. It's good to know exactly when we don't need a deprecation.",
    "created_at": "2013-02-25T20:24:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171911",
    "user": "https://github.com/tscrim"
}
```

Alright. It's good to know exactly when we don't need a deprecation.



---

archive/issue_comments_171912.json:
```json
{
    "body": "I found:\n\n- Before this patch, `CombinatorialFreeModule` did inherit from `UniqueRepresentation`, but destroyed the uniqueness property.\n- With my changes to `UniqueRepresentation`, `CombinatorialFreeModule` behaves as follows, *if* one keeps inheriting from `UniqueRepresentation`:\n  {{{\nsage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix=\"G\")\nsage: y = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')\nsage: G is y\nFalse\nsage: G == y\nFalse\nsage: G <= y\nTrue\nsage: y <= G\nTrue\n  }}}\n  Hence, while the uniqueness of the old `UniqueRepresentation` was destroyed, it is preserved in the new version.\n- Since uniqueness is preserved, the bug exposed in comment:49 has actually been fixed!\n- However, since I wanted to preserve the old behaviour, I made `CombinatorialFreeModule` inherit from `CachedRepresentation`, not from `UniqueRepresentation`. In this way, the original bug was re-established. And since by coincidence the order of tests changed, the bug surfaced.\n\nI am now trying if anything breaks if one returns to the old layout of `CombinatorialFreeModule`.",
    "created_at": "2013-02-25T20:46:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171912",
    "user": "https://github.com/simon-king-jena"
}
```

I found:

- Before this patch, `CombinatorialFreeModule` did inherit from `UniqueRepresentation`, but destroyed the uniqueness property.
- With my changes to `UniqueRepresentation`, `CombinatorialFreeModule` behaves as follows, *if* one keeps inheriting from `UniqueRepresentation`:
  {{{
sage: G = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix="G")
sage: y = CombinatorialFreeModule(ZZ, [1,2,3,4], prefix='y')
sage: G is y
False
sage: G == y
False
sage: G <= y
True
sage: y <= G
True
  }}}
  Hence, while the uniqueness of the old `UniqueRepresentation` was destroyed, it is preserved in the new version.
- Since uniqueness is preserved, the bug exposed in comment:49 has actually been fixed!
- However, since I wanted to preserve the old behaviour, I made `CombinatorialFreeModule` inherit from `CachedRepresentation`, not from `UniqueRepresentation`. In this way, the original bug was re-established. And since by coincidence the order of tests changed, the bug surfaced.

I am now trying if anything breaks if one returns to the old layout of `CombinatorialFreeModule`.



---

archive/issue_comments_171913.json:
```json
{
    "body": "Very minor nitpick: I think providing `<=` and `>=` even for identical inputs is not quite the correct thing to do. Python has objects for which those are false or for which those raise an exception:\n\n```\nsage: a=float('NaN')\nsage: a <= a\nFalse\nsage: b=complex(1,2)\nsage: b<=b\nTypeError: no ordering relation is defined for complex numbers\n```\nIn python 3 this is even the default:\n\n```\nPython 3.2.3 (default, Jun  8 2012, 05:40:07) \n[GCC 4.6.3 20120306 (Red Hat 4.6.3-2)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> a=object()\n>>> a<=a\nTypeError: unorderable types: object() <= object()\n>>> a==a\nTrue\n>>> a is a\nTrue\n```\nI think not providing `(a <= a) == True` for `UniqueRepresentation` is less likely to cause surprises in the future.",
    "created_at": "2013-02-25T21:01:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171913",
    "user": "https://github.com/nbruin"
}
```

Very minor nitpick: I think providing `<=` and `>=` even for identical inputs is not quite the correct thing to do. Python has objects for which those are false or for which those raise an exception:

```
sage: a=float('NaN')
sage: a <= a
False
sage: b=complex(1,2)
sage: b<=b
TypeError: no ordering relation is defined for complex numbers
```
In python 3 this is even the default:

```
Python 3.2.3 (default, Jun  8 2012, 05:40:07) 
[GCC 4.6.3 20120306 (Red Hat 4.6.3-2)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> a=object()
>>> a<=a
TypeError: unorderable types: object() <= object()
>>> a==a
True
>>> a is a
True
```
I think not providing `(a <= a) == True` for `UniqueRepresentation` is less likely to cause surprises in the future.



---

archive/issue_comments_171914.json:
```json
{
    "body": "Replying to [comment:55 nbruin]:\n> I think not providing `(a <= a) == True` for `UniqueRepresentation` is less likely to cause surprises in the future.\n\n\nOK, this should be the next thing I'll test.",
    "created_at": "2013-02-25T21:06:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171914",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:55 nbruin]:
> I think not providing `(a <= a) == True` for `UniqueRepresentation` is less likely to cause surprises in the future.


OK, this should be the next thing I'll test.



---

archive/issue_comments_171915.json:
```json
{
    "body": "Using `UniqueRepresentation` on `CombinatorialFreeModule` works mostly fine. There were only some error in tests that were testing the *absence* of the unique parent condition (so, these are tests against behaviour I would like to fix!), and also there was some error in my new coercion tutorial.",
    "created_at": "2013-02-26T00:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171915",
    "user": "https://github.com/simon-king-jena"
}
```

Using `UniqueRepresentation` on `CombinatorialFreeModule` works mostly fine. There were only some error in tests that were testing the *absence* of the unique parent condition (so, these are tests against behaviour I would like to fix!), and also there was some error in my new coercion tutorial.



---

archive/issue_comments_171916.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-02-26T12:04:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171916",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_171917.json:
```json
{
    "body": "I think I fixed all the remaining issues. This includes a fix to my recently added coercion tutorial (the number of inherited methods in two examples changes).\n\nConcerning combinatorial free modules: They used to violate the unique parent condition, even though they inherited from `UniqueRepresentation`. I have demonstrated that this was a bug, when combining the failure to be unique with a cache on the tensor product construction. It is automatically fixed with the changes to `UniqueRepresentation` introduced in this patch, and gave rise to a new doctest.\n\nNeeds review!\n\nApply trac14054_fast_methods-5.8.patch",
    "created_at": "2013-02-26T12:04:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171917",
    "user": "https://github.com/simon-king-jena"
}
```

I think I fixed all the remaining issues. This includes a fix to my recently added coercion tutorial (the number of inherited methods in two examples changes).

Concerning combinatorial free modules: They used to violate the unique parent condition, even though they inherited from `UniqueRepresentation`. I have demonstrated that this was a bug, when combining the failure to be unique with a cache on the tensor product construction. It is automatically fixed with the changes to `UniqueRepresentation` introduced in this patch, and gave rise to a new doctest.

Needs review!

Apply trac14054_fast_methods-5.8.patch



---

archive/issue_comments_171918.json:
```json
{
    "body": "PS: The new dependency #14182 is because of the change to the coercion tutorial.\n\nApply trac14054_fast_methods-5.8.patch",
    "created_at": "2013-02-26T12:05:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171918",
    "user": "https://github.com/simon-king-jena"
}
```

PS: The new dependency #14182 is because of the change to the coercion tutorial.

Apply trac14054_fast_methods-5.8.patch



---

archive/issue_comments_171919.json:
```json
{
    "body": "Looks good to me now.\n\nThank you Simon,\n\nTravis",
    "created_at": "2013-02-26T17:32:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171919",
    "user": "https://github.com/tscrim"
}
```

Looks good to me now.

Thank you Simon,

Travis



---

archive/issue_comments_171920.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-02-26T17:32:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171920",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_171921.json:
```json
{
    "body": "This should be rebased to #14040.",
    "created_at": "2013-02-28T10:49:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171921",
    "user": "https://github.com/jdemeyer"
}
```

This should be rebased to #14040.



---

archive/issue_comments_171922.json:
```json
{
    "body": "Attachment [trac14054_fast_methods-5.8.patch](tarball://root/attachments/some-uuid/ticket14054/trac14054_fast_methods-5.8.patch) by @simon-king-jena created at 2013-02-28 12:13:25\n\nSeparate cache and uniqueness. Rel #6495 and #14040",
    "created_at": "2013-02-28T12:13:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171922",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac14054_fast_methods-5.8.patch](tarball://root/attachments/some-uuid/ticket14054/trac14054_fast_methods-5.8.patch) by @simon-king-jena created at 2013-02-28 12:13:25

Separate cache and uniqueness. Rel #6495 and #14040



---

archive/issue_comments_171923.json:
```json
{
    "body": "Done. I only needed to change the expected result for one example in the coercion tutorial: The number of available methods for matrix spaces changes with #14040.",
    "created_at": "2013-02-28T12:15:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171923",
    "user": "https://github.com/simon-king-jena"
}
```

Done. I only needed to change the expected result for one example in the coercion tutorial: The number of available methods for matrix spaces changes with #14040.



---

archive/issue_comments_171924.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-03-04T07:36:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171924",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_039539.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-03-04T07:36:26Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13850#event-39539"
}
```



---

archive/issue_events_039540.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-03-05T10:55:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "milestone": "sage-5.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13850#event-39540"
}
```



---

archive/issue_comments_171925.json:
```json
{
    "body": "Resolution changed from fixed to ",
    "created_at": "2013-03-05T10:55:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171925",
    "user": "https://github.com/jdemeyer"
}
```

Resolution changed from fixed to 



---

archive/issue_comments_171926.json:
```json
{
    "body": "This causes a doctest failure on Solaris SPARC 32-bit (Skynet machine `mark`):\n\n```\nsage -t  --long -force_lib devel/sage/sage/combinat/rigged_configurations/rigged_configurations.py\n**********************************************************************\nFile \"/home/buildbot/build/sage/mark-1/mark_full/build/sage-5.8.beta3/devel/sage-main/sage/combinat/rigged_configurations/rigged_configurations.py\", line 48:\n    sage: RC.list()\nExpected:\n    [\n    (/)\n    <BLANKLINE>\n    (/)\n    <BLANKLINE>\n    (/)\n    ,\n    (/)\n    <BLANKLINE>\n    -1[ ]-1\n    <BLANKLINE>\n    (/)\n    ,\n    (/)\n    <BLANKLINE>\n    0[ ]0\n    <BLANKLINE>\n    -1[ ]-1\n    ,\n    -1[ ]-1\n    <BLANKLINE>\n    0[ ]0\n    <BLANKLINE>\n    (/)\n    ,\n    -1[ ]-1\n    <BLANKLINE>\n    1[ ]1\n    <BLANKLINE>\n    -1[ ]-1\n    ,\n    0[ ]0\n    <BLANKLINE>\n    -1[ ]-1\n    -1[ ]-1\n    <BLANKLINE>\n    0[ ]0\n    ]\nGot:\n    [\n    (/)\n    <BLANKLINE>\n    (/)\n    <BLANKLINE>\n    (/)\n    , \n    (/)\n    <BLANKLINE>\n    -1[ ]-1\n    <BLANKLINE>\n    (/)\n    , \n    -1[ ]-1\n    <BLANKLINE>\n    0[ ]0\n    <BLANKLINE>\n    (/)\n    , \n    -1[ ]-1\n    <BLANKLINE>\n    1[ ]1\n    <BLANKLINE>\n    -1[ ]-1\n    , \n    (/)\n    <BLANKLINE>\n    0[ ]0\n    <BLANKLINE>\n    -1[ ]-1\n    , \n    0[ ]0\n    <BLANKLINE>\n    -1[ ]-1\n    -1[ ]-1\n    <BLANKLINE>\n    0[ ]0\n    ]\n**********************************************************************\n```",
    "created_at": "2013-03-05T10:55:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171926",
    "user": "https://github.com/jdemeyer"
}
```

This causes a doctest failure on Solaris SPARC 32-bit (Skynet machine `mark`):

```
sage -t  --long -force_lib devel/sage/sage/combinat/rigged_configurations/rigged_configurations.py
**********************************************************************
File "/home/buildbot/build/sage/mark-1/mark_full/build/sage-5.8.beta3/devel/sage-main/sage/combinat/rigged_configurations/rigged_configurations.py", line 48:
    sage: RC.list()
Expected:
    [
    (/)
    <BLANKLINE>
    (/)
    <BLANKLINE>
    (/)
    ,
    (/)
    <BLANKLINE>
    -1[ ]-1
    <BLANKLINE>
    (/)
    ,
    (/)
    <BLANKLINE>
    0[ ]0
    <BLANKLINE>
    -1[ ]-1
    ,
    -1[ ]-1
    <BLANKLINE>
    0[ ]0
    <BLANKLINE>
    (/)
    ,
    -1[ ]-1
    <BLANKLINE>
    1[ ]1
    <BLANKLINE>
    -1[ ]-1
    ,
    0[ ]0
    <BLANKLINE>
    -1[ ]-1
    -1[ ]-1
    <BLANKLINE>
    0[ ]0
    ]
Got:
    [
    (/)
    <BLANKLINE>
    (/)
    <BLANKLINE>
    (/)
    , 
    (/)
    <BLANKLINE>
    -1[ ]-1
    <BLANKLINE>
    (/)
    , 
    -1[ ]-1
    <BLANKLINE>
    0[ ]0
    <BLANKLINE>
    (/)
    , 
    -1[ ]-1
    <BLANKLINE>
    1[ ]1
    <BLANKLINE>
    -1[ ]-1
    , 
    (/)
    <BLANKLINE>
    0[ ]0
    <BLANKLINE>
    -1[ ]-1
    , 
    0[ ]0
    <BLANKLINE>
    -1[ ]-1
    -1[ ]-1
    <BLANKLINE>
    0[ ]0
    ]
**********************************************************************
```



---

archive/issue_comments_171927.json:
```json
{
    "body": "Changing status from closed to new.",
    "created_at": "2013-03-05T10:55:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171927",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from closed to new.



---

archive/issue_events_039541.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-03-05T10:55:03Z",
    "event": "reopened",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13850#event-39541"
}
```



---

archive/issue_comments_171928.json:
```json
{
    "body": "OK. Since the list is not sorted, I guess the cleanest solution is to test against `sorted(RC.list())`.",
    "created_at": "2013-03-05T11:48:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171928",
    "user": "https://github.com/simon-king-jena"
}
```

OK. Since the list is not sorted, I guess the cleanest solution is to test against `sorted(RC.list())`.



---

archive/issue_events_039542.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-03-05T11:56:33Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "milestone": "sage-5.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13850#event-39542"
}
```



---

archive/issue_events_039543.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-03-05T11:56:33Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "milestone": "sage-5.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13850#event-39543"
}
```



---

archive/issue_comments_171929.json:
```json
{
    "body": "Can this really not go into 5.8, if the tests pass with the second patch?\n\nApply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.patch",
    "created_at": "2013-03-05T11:56:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171929",
    "user": "https://github.com/simon-king-jena"
}
```

Can this really not go into 5.8, if the tests pass with the second patch?

Apply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.patch



---

archive/issue_comments_171930.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-03-05T11:56:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171930",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_171931.json:
```json
{
    "body": "Sort output of RiggedConfigurations.list(), to make it reproducible on different machines",
    "created_at": "2013-03-05T13:12:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171931",
    "user": "https://github.com/jdemeyer"
}
```

Sort output of RiggedConfigurations.list(), to make it reproducible on different machines



---

archive/issue_comments_171932.json:
```json
{
    "body": "Attachment [trac_14054-fix-rigged-list.patch](tarball://root/attachments/some-uuid/ticket14054/trac_14054-fix-rigged-list.patch) by @jdemeyer created at 2013-03-05 13:12:51\n\nTrivial rebase to #14011.",
    "created_at": "2013-03-05T13:12:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171932",
    "user": "https://github.com/jdemeyer"
}
```

Attachment [trac_14054-fix-rigged-list.patch](tarball://root/attachments/some-uuid/ticket14054/trac_14054-fix-rigged-list.patch) by @jdemeyer created at 2013-03-05 13:12:51

Trivial rebase to #14011.



---

archive/issue_comments_171933.json:
```json
{
    "body": "Now that is strange. With the sorted output, one gets another error, this time on several patchbots. \n\nIt seems that I messed up something. Try to fix it now...",
    "created_at": "2013-03-05T14:52:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171933",
    "user": "https://github.com/simon-king-jena"
}
```

Now that is strange. With the sorted output, one gets another error, this time on several patchbots. 

It seems that I messed up something. Try to fix it now...



---

archive/issue_comments_171934.json:
```json
{
    "body": "FWIW I also get the same error as the patchbot.",
    "created_at": "2013-03-05T14:53:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171934",
    "user": "https://github.com/tscrim"
}
```

FWIW I also get the same error as the patchbot.



---

archive/issue_comments_171935.json:
```json
{
    "body": "Now it should work<sup>(T)</sup>.\n\nApply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch",
    "created_at": "2013-03-05T14:59:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171935",
    "user": "https://github.com/simon-king-jena"
}
```

Now it should work<sup>(T)</sup>.

Apply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch



---

archive/issue_comments_171936.json:
```json
{
    "body": "This fails to apply for me:\n\n```\npatching file sage/combinat/rigged_configurations/rigged_configurations.py\nHunk #3 FAILED at 930\n1 out of 3 hunks FAILED -- saving rejects to file sage/combinat/rigged_configurations/rigged_configurations.py.rej\npatch failed, unable to continue (try -v)\npatch failed, rejects left in working dir\nerrors during apply, please fix and refresh trac_14054-fix-rigged-list.patch\n```",
    "created_at": "2013-03-05T15:06:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171936",
    "user": "https://github.com/tscrim"
}
```

This fails to apply for me:

```
patching file sage/combinat/rigged_configurations/rigged_configurations.py
Hunk #3 FAILED at 930
1 out of 3 hunks FAILED -- saving rejects to file sage/combinat/rigged_configurations/rigged_configurations.py.rej
patch failed, unable to continue (try -v)
patch failed, rejects left in working dir
errors during apply, please fix and refresh trac_14054-fix-rigged-list.patch
```



---

archive/issue_comments_171937.json:
```json
{
    "body": "Argh. Jeroen forgot to update the list of dependencies, it seems.",
    "created_at": "2013-03-05T15:21:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171937",
    "user": "https://github.com/simon-king-jena"
}
```

Argh. Jeroen forgot to update the list of dependencies, it seems.



---

archive/issue_comments_171938.json:
```json
{
    "body": "Rebasing really has been trivial. The error was about a missing newline at the end of the file...\n\nApply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch",
    "created_at": "2013-03-05T15:24:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171938",
    "user": "https://github.com/simon-king-jena"
}
```

Rebasing really has been trivial. The error was about a missing newline at the end of the file...

Apply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch



---

archive/issue_comments_171939.json:
```json
{
    "body": "Note that the tests in rigged_configurations do pass for me, with\n\n```\ntrac11490-coercion_tutorial.patch\n14182_whitespace.patch\ntrac_13618-rings_doc_real-ts.patch\ntrac_13618-rings_doc_complex-ts.patch\ntrac_13618-rings_doc_others-ts.patch\ntrac_14040_housekeeping.patch\ntrac_14040_repr_option.patch\ntrac_14040_doctest.patch\ntrac_14040_review.patch\ntrac14054_fast_methods-5.8.patch\ntrac_12313-mono_dict-combined-random-sk.patch\ntrac_13387-combined.patch\ntrac_13387-guard_gc.patch\ntrac_14159_weak_value_triple_dict.patch\ntrac_14159_use_cdef_get.patch\ntrac12951_cached_extension.patch\ntrac_14214-cython_homset.patch\ntrac_14214-backup_cache.patch\ntrac_14063-remove_cc_compositions-ts.patch\ntrac_13688-finite_sets_cardinality_override-ts.patch\ntrac_14138.patch\ntrac_14138-doctests.patch\ntrac_13605-partition_options-ts.patch\ntrac_14011-Sphinx_roles-fh.patch\ntrac_14054-fix-rigged-list.2.patch\n```\napplied on top of sage-5.8.beta0. But they fail if I have some more patches applied.\n\nIn other words, I get the impression that sorting of the output of `RiggedConfigurations.list()` is broken.",
    "created_at": "2013-03-05T15:28:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171939",
    "user": "https://github.com/simon-king-jena"
}
```

Note that the tests in rigged_configurations do pass for me, with

```
trac11490-coercion_tutorial.patch
14182_whitespace.patch
trac_13618-rings_doc_real-ts.patch
trac_13618-rings_doc_complex-ts.patch
trac_13618-rings_doc_others-ts.patch
trac_14040_housekeeping.patch
trac_14040_repr_option.patch
trac_14040_doctest.patch
trac_14040_review.patch
trac14054_fast_methods-5.8.patch
trac_12313-mono_dict-combined-random-sk.patch
trac_13387-combined.patch
trac_13387-guard_gc.patch
trac_14159_weak_value_triple_dict.patch
trac_14159_use_cdef_get.patch
trac12951_cached_extension.patch
trac_14214-cython_homset.patch
trac_14214-backup_cache.patch
trac_14063-remove_cc_compositions-ts.patch
trac_13688-finite_sets_cardinality_override-ts.patch
trac_14138.patch
trac_14138-doctests.patch
trac_13605-partition_options-ts.patch
trac_14011-Sphinx_roles-fh.patch
trac_14054-fix-rigged-list.2.patch
```
applied on top of sage-5.8.beta0. But they fail if I have some more patches applied.

In other words, I get the impression that sorting of the output of `RiggedConfigurations.list()` is broken.



---

archive/issue_comments_171940.json:
```json
{
    "body": "Arrgh. Can it be that `sage.combinat.rigged_configurations.rigged_configuration_element.RiggedConfigurationElement` has no sorting implemented? Travis, you are the author. How can one implement comparison of these things?\n\nJeroen, what can we do, since apparently sorting the output is not available here? I would say that it is not the fault (for a reasonable definition of \"fault\") of my patch that the test in rigged_configurations is unstable.",
    "created_at": "2013-03-05T15:33:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171940",
    "user": "https://github.com/simon-king-jena"
}
```

Arrgh. Can it be that `sage.combinat.rigged_configurations.rigged_configuration_element.RiggedConfigurationElement` has no sorting implemented? Travis, you are the author. How can one implement comparison of these things?

Jeroen, what can we do, since apparently sorting the output is not available here? I would say that it is not the fault (for a reasonable definition of "fault") of my patch that the test in rigged_configurations is unstable.



---

archive/issue_comments_171941.json:
```json
{
    "body": "Would it be better to give them an (somewhat unnatural) ordering or to change the doctest? \n\nActually...why not just make it `#random` with a note saying the output order can be random since there is no ordering?",
    "created_at": "2013-03-05T15:41:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171941",
    "user": "https://github.com/tscrim"
}
```

Would it be better to give them an (somewhat unnatural) ordering or to change the doctest? 

Actually...why not just make it `#random` with a note saying the output order can be random since there is no ordering?



---

archive/issue_comments_171942.json:
```json
{
    "body": "Replying to [comment:76 SimonKing]:\n> I would say that it is not the fault (for a reasonable definition of \"fault\") of my patch that the test in rigged_configurations is unstable.\n\nTrue, but with doctests there is no alternative but to shoot the messenger (i.e. the person adding the patch causing the doctest failure always gets the blame)",
    "created_at": "2013-03-05T15:48:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171942",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:76 SimonKing]:
> I would say that it is not the fault (for a reasonable definition of "fault") of my patch that the test in rigged_configurations is unstable.

True, but with doctests there is no alternative but to shoot the messenger (i.e. the person adding the patch causing the doctest failure always gets the blame)



---

archive/issue_comments_171943.json:
```json
{
    "body": "Replying to [comment:77 tscrim]:\n> Would it be better to give them an (somewhat unnatural) ordering or to change the doctest? \n> \n> Actually...why not just make it `#random` with a note saying the output order can be random since there is no ordering?\n\n\nI would be fine with making it random, *and* test that the length of the output (or another easy invariant) is correct.\n\nIs there a mathematically meaningful ordering? From the code, I guess that rigged configuration elements rely on list of tableaus, and if the tableaus can be ordered then one might have some kind of lexicographical ordering, perhaps. But this should be on a different ticket (and perhaps would not make sense at all), so that I would prefer to change the test.\n\nJeroen, what is your opinion on that matter?",
    "created_at": "2013-03-05T15:49:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171943",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:77 tscrim]:
> Would it be better to give them an (somewhat unnatural) ordering or to change the doctest? 
> 
> Actually...why not just make it `#random` with a note saying the output order can be random since there is no ordering?


I would be fine with making it random, *and* test that the length of the output (or another easy invariant) is correct.

Is there a mathematically meaningful ordering? From the code, I guess that rigged configuration elements rely on list of tableaus, and if the tableaus can be ordered then one might have some kind of lexicographical ordering, perhaps. But this should be on a different ticket (and perhaps would not make sense at all), so that I would prefer to change the test.

Jeroen, what is your opinion on that matter?



---

archive/issue_comments_171944.json:
```json
{
    "body": "Thankfully I'm here to take the bullet. :P\n\nI don't know of any mathematical meaning of sorting rigged configurations. I don't think there is one...\n\nThe reason why there's different (unsorted) outputs is because at the backend of the iterator in `TransitiveIdeal`, there is a (python) `set` working. If this is changed to a list, there should be no real loss of speed, but the iteration should be completely consistent across all machines (and for anything else which uses `TransitiveIdeal` for iteration and does not have a valid sorting).",
    "created_at": "2013-03-05T15:53:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171944",
    "user": "https://github.com/tscrim"
}
```

Thankfully I'm here to take the bullet. :P

I don't know of any mathematical meaning of sorting rigged configurations. I don't think there is one...

The reason why there's different (unsorted) outputs is because at the backend of the iterator in `TransitiveIdeal`, there is a (python) `set` working. If this is changed to a list, there should be no real loss of speed, but the iteration should be completely consistent across all machines (and for anything else which uses `TransitiveIdeal` for iteration and does not have a valid sorting).



---

archive/issue_comments_171945.json:
```json
{
    "body": "Mark output of `RiggedConfigurations.list()` random and test against cardinality, to make it reproducible on different machines.",
    "created_at": "2013-03-05T15:54:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171945",
    "user": "https://github.com/simon-king-jena"
}
```

Mark output of `RiggedConfigurations.list()` random and test against cardinality, to make it reproducible on different machines.



---

archive/issue_comments_171946.json:
```json
{
    "body": "Attachment [trac_14054-fix-rigged-list.2.patch](tarball://root/attachments/some-uuid/ticket14054/trac_14054-fix-rigged-list.2.patch) by @simon-king-jena created at 2013-03-05 15:55:42\n\nI have updated the patch, marking the test random and testing that the length of the list coincides with the cardinality.\n\nApply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch",
    "created_at": "2013-03-05T15:55:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171946",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_14054-fix-rigged-list.2.patch](tarball://root/attachments/some-uuid/ticket14054/trac_14054-fix-rigged-list.2.patch) by @simon-king-jena created at 2013-03-05 15:55:42

I have updated the patch, marking the test random and testing that the length of the list coincides with the cardinality.

Apply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch



---

archive/issue_comments_171947.json:
```json
{
    "body": "PS: With the new patch, the tests will also pass (for me, at least) when I apply the remaining patches in my queue...",
    "created_at": "2013-03-05T15:56:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171947",
    "user": "https://github.com/simon-king-jena"
}
```

PS: With the new patch, the tests will also pass (for me, at least) when I apply the remaining patches in my queue...



---

archive/issue_comments_171948.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-03-05T18:05:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171948",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_171949.json:
```json
{
    "body": "Everything looks good to me as well. I don't know why the patchbot just timed-out so I gave it a kick.\n\nFor patchbot:\n\nApply: trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch",
    "created_at": "2013-03-05T18:05:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171949",
    "user": "https://github.com/tscrim"
}
```

Everything looks good to me as well. I don't know why the patchbot just timed-out so I gave it a kick.

For patchbot:

Apply: trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch



---

archive/issue_comments_171950.json:
```json
{
    "body": "Hooray, and the patchbot doesn't complain either, except for the fact that a new module is loaded during start-up. But this can hardly be avoided in this case, and the patchbot does not observe the slightest increase in startup time :-)",
    "created_at": "2013-03-05T18:27:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171950",
    "user": "https://github.com/simon-king-jena"
}
```

Hooray, and the patchbot doesn't complain either, except for the fact that a new module is loaded during start-up. But this can hardly be avoided in this case, and the patchbot does not observe the slightest increase in startup time :-)



---

archive/issue_comments_171951.json:
```json
{
    "body": "Replying to [comment:81 SimonKing]:\n> I have updated the patch, marking the test random and testing that the length of the list coincides with the cardinality.\n> \n> Apply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch \n\n\nJust for the record: in similar situations, I occasionally used the following idiom:\n\n    sage: sorted(..., key=str)\n    ...\n\nWhich makes the output deterministic (well, assumming repr is ...) even if there is no natural total ordering on the objects to be sorted.",
    "created_at": "2013-03-06T04:23:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171951",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:81 SimonKing]:
> I have updated the patch, marking the test random and testing that the length of the list coincides with the cardinality.
> 
> Apply trac14054_fast_methods-5.8.patch trac_14054-fix-rigged-list.2.patch 


Just for the record: in similar situations, I occasionally used the following idiom:

    sage: sorted(..., key=str)
    ...

Which makes the output deterministic (well, assumming repr is ...) even if there is no natural total ordering on the objects to be sorted.



---

archive/issue_comments_171952.json:
```json
{
    "body": "I forgot to say: great job getting this done! Thanks!",
    "created_at": "2013-03-06T04:34:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171952",
    "user": "https://github.com/nthiery"
}
```

I forgot to say: great job getting this done! Thanks!



---

archive/issue_comments_171953.json:
```json
{
    "body": "Replying to [comment:67 SimonKing]:\n> Can this really not go into 5.8, if the tests pass with the second patch?\n\nWell, it didn't pass tests :-)\n\nBut seriously: is there any particular reason this patch should be in sage-5.8? I'd rather not take the risk and postpone it for sage-5.9.beta0.",
    "created_at": "2013-03-06T10:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171953",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:67 SimonKing]:
> Can this really not go into 5.8, if the tests pass with the second patch?

Well, it didn't pass tests :-)

But seriously: is there any particular reason this patch should be in sage-5.8? I'd rather not take the risk and postpone it for sage-5.9.beta0.



---

archive/issue_comments_171954.json:
```json
{
    "body": "Replying to [comment:87 jdemeyer]:\n> Replying to [comment:67 SimonKing]:\n> > Can this really not go into 5.8, if the tests pass with the second patch?\n\n> Well, it didn't pass tests :-)\n\nWell, it *does*, with the current version of the second patch.",
    "created_at": "2013-03-06T10:57:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171954",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:87 jdemeyer]:
> Replying to [comment:67 SimonKing]:
> > Can this really not go into 5.8, if the tests pass with the second patch?

> Well, it didn't pass tests :-)

Well, it *does*, with the current version of the second patch.



---

archive/issue_comments_171955.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-03-07T18:26:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13850#issuecomment-171955",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_039544.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-03-07T18:26:18Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13850",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13850#event-39544"
}
```
