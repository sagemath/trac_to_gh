# Issue 25154: SageMath fails to build on on Fedora 28 with gcc 8.1

Issue created by migration from https://trac.sagemath.org/ticket/25391

Original creator: Vaush

Original creation time: 2018-05-18 05:06:44

CC:  dimpase

Keywords: gcc8.1 python3 python2 linbox fedora28 compilation build

SageMath building produces 3 different errors when run on Fedora 28 64bit with  gcc 8.1, specifically when building the packages:
- python 3.6.1
- python 2.7.14
- linbox 1.5.2

The following errors are respectively reported:
- Failure to import the crypt module
- Failure to generate posix vars
- 

```
../../linbox/matrix/densematrix/blas-transposed-matrix.h:74:8: error: too many template-parameter-lists
  class TransposedBlasMatrix< TransposedBlasMatrix< Matrix > > : public Matrix{
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```


The first error is due to an unspecified issue with Fedora 28 implementation of _crypt()_ or its usage in pyhton 3.6.1.

The errors in the last two packages, instead, are due to more general issues with the new 8.1 version of gcc.
Python 2.7.14 fails to build because the way structs are aligned in C was changed in gcc 8.1, as described in https://bugs.python.org/issue33374#msg315857 .


Linbox fails to build because it uses a construct previously accepted in gcc 7 that instead produces an error in gcc 8, specifically a templated template specialization done in the following way:


```
template<>
template<typename T>
class Class1<Type1<T>>{
...
}
```


For specifics on how the errors are solved by the attached patches, see the sage-devel discussion at https://groups.google.com/forum/#!msg/sage-devel/NgzlZknrizg/o-_Exw8jCAAJ

**crypt.patch** is to be added to python3 package
**zzz_conf.patch** is to be added to python3 package

**packing.patch** is to be added to python2 package

**multiple_templates.patch** is to be added to linbox package


---

Comment by Vaush created at 2018-05-18 05:07:17

Linbox patch


---

Attachment

Python2 patch


---

Attachment

Python3 patch - 1 of 2


---

Comment by Vaush created at 2018-05-18 05:09:40

Python3 patch - 2 of 2


---

Attachment


---

Comment by Vaush created at 2018-05-18 15:06:52

I added dependencies to #25204,#25353 which respectively fix the python 2 issue and the linbox (and fflas, which is not described here) issue.
The commit to be made will be based on them, and will only modify the python 3 package


---

Comment by Vaush created at 2018-05-18 15:47:58

New commits:


---

Comment by Vaush created at 2018-05-18 15:47:58

Changing status from new to needs_review.


---

Comment by dimpase created at 2018-05-19 09:01:19

I'll be checking that this does not break on other systems.


---

Comment by dimpase created at 2018-05-19 09:44:41

Have you run tests on your branch?: `make ptest`
(or `make ptestlong` for more tests)

This is something the ticket's author should do in such cases.
(It would not be surprising if something unrelated to your changes fails, as gcc 8 is pretty much untested, but good to know anyway).


---

Comment by Vaush created at 2018-05-19 12:53:33

I haven't, but will do


---

Comment by git created at 2018-05-25 13:01:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2018-06-20 10:22:39

What is happening with this on the current 8.3.beta6?
Note that python2 has been updated.


---

Comment by dimpase created at 2018-06-20 10:31:12

For Python3, it's apparently https://github.com/python/cpython/pull/4691 which is still under review.


---

Comment by jdemeyer created at 2018-06-20 11:19:20

I am missing some context and documentation. The current branch only fixes Python 3. That is not consistent with the ticket description which mentions several packages and doesn't even mention the actual failure that the Python 3 patch is trying to fix.


---

Comment by jdemeyer created at 2018-06-20 11:19:20

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2018-06-20 11:20:33

The patch files should also contain some description, at a minimum a link to the upstream issue.

And if you add a patch to a package, you should bump the package version.


---

Comment by Vaush created at 2018-06-20 11:43:33

Ok, I'm sorry if the description or the execution aren't up to par, this is my first ticket, so I'm getting used to it.\\
The ticket was originally opened to describe the bug. After that, I succeeded in manually fixing all the bugs listed in the description, but it was brought to my attention that two of my bugs were solved in separate tickets at the same time (see the dependencies field), so I merged those tickets and added my own fix for python3, thus fixing all the issues and solving the problem stated in the ticket title, that is [SageMath](SageMath) not compiling on Fedora 28 with gcc 8.1.\\
Since the commits include the fixes for the other 2 bugs, even if by merging, I thought this counted as having a fix for all 3 of them in the branch, is this wrong?\\
There is a description for the python 3 bug, since the bug is literally "Python tries to call crypt instead of crypt_r on Fedora, and this for some reason breaks things, so let's allow it to call crypt_r", and the reason why it breaks things is, as pointed out by dimpase, apparently that fedora has a completely different crypt implementation, as can be seen here https://fedoraproject.org/wiki/Changes/Replace_glibc_libcrypt_with_libxcrypt.\\
I'll expand on the description a bit, anyway, to make this clearer, and also to reflect the fact that this ticket only directly fixes the python3 bug, since it's only reported in the comments.
I'll also quickly add a description and a link to the patch


---

Comment by git created at 2018-06-20 12:08:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2018-06-20 13:08:10

Changing status from needs_info to needs_review.


---

Comment by dimpase created at 2018-06-20 13:08:10

Changing keywords from "gcc8.1 python3 python2 linbox fedora28 compilation build" to "gcc8.1 python3 fedora28 compilation build".


---

Comment by dimpase created at 2018-06-20 13:08:10

Jeroen, how do you feel about merging Python 3 patch which is still being out for reviewing by Python people?


---

Comment by jdemeyer created at 2018-06-20 14:35:11

Replying to [comment:14 Vaush]:
> Ok, I'm sorry if the description or the execution aren't up to par, this is my first ticket, so I'm getting used to it.

As a general tip: when you fix a bug, it's always important to mention what the bug is. You're certainly not the first one to post a fix for something without even mentioning what that fix is supposed to fix.


---

Comment by jdemeyer created at 2018-06-20 14:38:43

Do you have a build log of the failed Python 3 build?


---

Comment by jdemeyer created at 2018-06-20 14:38:43

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2018-06-20 14:39:44

Replying to [comment:17 dimpase]:
> Jeroen, how do you feel about merging Python 3 patch which is still being out for reviewing by Python people?

I don't mind in principle. However, I'd very much like to know what the actual bug is that this ticket is supposed to fix.


---

Comment by Vaush created at 2018-06-20 16:16:43

I'm attaching the log file of the failed build for python 3, when the patches are not applied.


---

Comment by Vaush created at 2018-06-20 16:18:04

Log of the failed python3 build


---

Attachment

The log has a number of tries to build python3, only the one at the bottom of the log has this error, see line 32452:

```
Testing importing of various modules...
ctypes module imported OK
math module imported OK
hashlib module imported OK
./spkg-build: line 157: 21845 Segmentation fault      (core dumped) $PYTHON -c "import $module"
crypt module failed to import
readline module imported OK
socket module imported OK
Error: One or more modules failed to import.
```


and this is due to

```
sage/build/python3-3.6.1.p1/src/Modules/_cryptmodule.c: In function 'crypt_crypt_impl':
sage/build/python3-3.6.1.p1/src/Modules/_cryptmodule.c:39:31: warning: implicit declaration of function 'crypt' [-Wimplicit-function-declaration]
     return Py_BuildValue("s", crypt(word, salt));
                               ^~~~~
```


Basically, there is no `crypt` implementation available in the libraries used, one needs to use another library, and this is done in the branch of this ticket.


---

Comment by dimpase created at 2018-06-20 16:45:40

see also https://bugzilla.redhat.com/show_bug.cgi?id=1576671 (!Redhat/Fedora bug tracker)


---

Comment by dimpase created at 2018-06-20 16:46:09

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2018-06-21 05:32:44

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2018-06-21 05:32:44

Thanks for the info. It's clear to me now that the bug that we're fixing is a different one from the upstream pull request https://github.com/python/cpython/pull/4691

Can you try if Python 3.7.0 (currently in rc: https://www.python.org/downloads/release/python-370rc1/) by chance fixes it?


---

Comment by jdemeyer created at 2018-06-21 05:35:27

Something else to try is compiling Python 3 without optimization (`-O0`). Can you do that for Python 3.7.0 and post the log file?


---

Comment by dimpase created at 2018-06-21 06:53:39

To clarify: the upstream's â€‹https://github.com/python/cpython/pull/4691 does not fix a bug, it provides for using `crypt_r` if available. 

It also does a proper handling (introduces `HAVE_CRYPT_H`) of `crypt` and `crypt_r` at the configuration stage---without it there is a reliance on `glibc` providing `crypt` and a header different from `crypt.h` providing a prototype.


---

Attachment


---

Comment by jdemeyer created at 2018-06-21 08:33:13

One final thing to try: put the file [attachment:crypt_debug.patch] in `build/pkgs/python3/patches`, rebuild Python 3.6.1 with it and report back what happens.


---

Comment by jdemeyer created at 2018-06-21 08:43:46

Replying to [comment:23 dimpase]:
> and this is due to
> {{{
> sage/build/python3-3.6.1.p1/src/Modules/_cryptmodule.c: In function 'crypt_crypt_impl':
> sage/build/python3-3.6.1.p1/src/Modules/_cryptmodule.c:39:31: warning: implicit declaration of function 'crypt' [-Wimplicit-function-declaration]
>      return Py_BuildValue("s", crypt(word, salt));
>                                ^~~~~
> }}}
> 
> Basically, there is no `crypt` implementation available in the libraries used, one needs to use another library, and this is done in the branch of this ticket.

I'm not convinced by this argument. If there would no `crypt` implementation, then we would get a linking error (either at compile time or runtime). But in the log file, there is a segmentation fault. So my impression is that `crypt()` is called but that it's causing a crash somehow.


---

Comment by dimpase created at 2018-06-21 08:53:55

Replying to [comment:30 jdemeyer]:
> Replying to [comment:23 dimpase]:
> > and this is due to
> > {{{
> > sage/build/python3-3.6.1.p1/src/Modules/_cryptmodule.c: In function 'crypt_crypt_impl':
> > sage/build/python3-3.6.1.p1/src/Modules/_cryptmodule.c:39:31: warning: implicit declaration of function 'crypt' [-Wimplicit-function-declaration]
> >      return Py_BuildValue("s", crypt(word, salt));
> >                                ^~~~~
> > }}}
> > 
> > Basically, there is no `crypt` implementation available in the libraries used, one needs to use another library, and this is done in the branch of this ticket.
> 
> I'm not convinced by this argument. If there would no `crypt` implementation, then we would get a linking error (either at compile time or runtime). But in the log file, there is a segmentation fault. So my impression is that `crypt()` is called but that it's causing a crash somehow.

you are right, my bad here. Anyhow, `crypt` is called without a prototype.
One can in fact make sure that it is called with a prototype, by removing the chunk 
about using `crypt_r` from the branch on this ticket, i.e. the lines

```
+@@ -36,7 +41,13 @@
+ {
+     /* On some platforms (AtheOS) crypt returns NULL for an invalid
+        salt. Return None in that case. XXX Maybe raise an exception?  */
++#ifdef HAVE_CRYPT_R
++    struct crypt_data data;
++    data.initialized = 0;
++    return Py_BuildValue("s", crypt_r(word, salt, &data));
++#else
+     return Py_BuildValue("s", crypt(word, salt));
++#endif
+ }
+ 
+ 
```

perhaps there would be more messages from the compiler then...


---

Comment by Vaush created at 2018-06-21 09:42:20

I'm sorry for the confusion, I think I can explain what happens (not why, but at least what).\\
The _crypt()_ call goes through perfectly, without issues, and returns a seemingly correct value. This value is then passed to Py_BuildValue and retrieved through varargs, but if one checks the two char* in question, that is the return value of crypt and the one Py_BuildValue retrieves, the latter is almost identical, but with the first 3-4 digits zeroed out. As an example, if crypt returns a pointer to 0xfe5ab234 (I completely made up this address), Py_BuildValue will get a pointer to 0x000ab234, and get illegal memory access when it tries to use it.\\
The missing prototype is not really a problem, at least it wasn't when I tried, because I tried adding the needed header without success.\\
I want to try python 3.7.0, but are there any major differences one would have to account for, or can I just put the source code in the upstream folder and modify checksum.ini?


---

Comment by jdemeyer created at 2018-06-21 09:49:46

Replying to [comment:32 Vaush]:
> I'm sorry for the confusion, I think I can explain what happens (not why, but at least what).\\
> The _crypt()_ call goes through perfectly, without issues, and returns a seemingly correct value. This value is then passed to Py_BuildValue and retrieved through varargs, but if one checks the two char* in question, that is the return value of crypt and the one Py_BuildValue retrieves, the latter is almost identical, but with the first 3-4 digits zeroed out. As an example, if crypt returns a pointer to 0xfe5ab234 (I completely made up this address), Py_BuildValue will get a pointer to 0x000ab234, and get illegal memory access when it tries to use it.

If that's true, then the error has nothing to with `crypt()` at all and I would expect much more breakage. Can you post the code that you used to come to the conclusion above and the exact results (no "completely made up" address!).


---

Comment by jdemeyer created at 2018-06-21 09:50:17

Replying to [comment:32 Vaush]:
> I want to try python 3.7.0, but are there any major differences one would have to account for, or can I just put the source code in the upstream folder and modify checksum.ini?

I don't think anybody has tried. I guess what you said should just work.


---

Comment by Vaush created at 2018-06-21 09:54:56

I can't post the code because I didn't use any, I just stepped through the code with gdb. I checked the stack trace for the segfault, set a breakpoint to the line that called the function which calls crypt, and then stepped through manually to understand what was happening.\\
I can try and get some proof from gdb later in the day, but there's not much more I can do.


---

Comment by dimpase created at 2018-06-21 10:26:44

Replying to [comment:35 Vaush]:
> I can't post the code because I didn't use any, I just stepped through the code with gdb. I checked the stack trace for the segfault, set a breakpoint to the line that called the function which calls crypt, and then stepped through manually to understand what was happening.\\
> I can try and get some proof from gdb later in the day, but there's not much more I can do. 

My understanding is that `crypt` returns a pointer to a statically allocated location. Indeed, its man page says: `return value points to static data whose content is overwritten by each call`.
Whereas `crypt_r` does something else, as such design as for `crypt` is not thread-safe.

Perhaps this unusual design of `crypt` is the reason the breakage is not bigger?


---

Comment by dimpase created at 2018-06-21 10:57:24

In fact,  the call to `Py_BuildValue`  is

```
return Py_BuildValue("s", crypt(word, salt));
```

(where we see a warning in the logs).

Here `"s"` stands for [string](https://docs.python.org/3/c-api/arg.html) 
It would be very interesting to see what values of `word` and `salt` are used.
Otherwise what length it assumes by default is anyone's guess (perhaps that's why you see some bits chopped off). Indeed, it does

```
Convert a null-terminated C string to a Python str object using 'utf-8' encoding. 
```


Note that Python 2 does not do `utf-8` here, so this might be a problem.
 
How about you try modifying the patch as I suggest in comment 31 (removing `crypt_r`-related  chunk)? This would call `crypt`, but supply a correct prototype.


---

Comment by Vaush created at 2018-06-21 10:59:50

I can do that later if you want, but it's not the string that gets chopped, it's the string's address.


---

Comment by dimpase created at 2018-06-21 11:16:22

What I don't know is what is supposed to happen on the import attempt. Does `crypt` get called at all? This does not seem to be necessary, as the import is about setting up a structure to call `crypt` from Python, not about calling it with any values.

Did you see crypt actually being called? And with what values of `word` and `salt`?
This is something that is totally unclear. If they are set to bad values, or just left uninitialised, stuff can happen...


---

Comment by Vaush created at 2018-06-21 11:26:45

I remember them being set up correctly, and the call worked. Still, I am recompiling the whole of sage with debug symbols, I'll step through it again and report when I have news


---

Comment by jdemeyer created at 2018-06-21 11:33:01

Replying to [comment:35 Vaush]:
> and then stepped through manually to understand what was happening.

Posting the actual output from gdb would have been useful here...


---

Comment by jdemeyer created at 2018-06-21 11:34:49

Replying to [comment:37 dimpase]:
> Here `"s"` stands for [string](https://docs.python.org/3/c-api/arg.html) 
> It would be very interesting to see what values of `word` and `salt` are used.

That's what my debugging patch [attachment:crypt_debug.patch] does.


---

Comment by Vaush created at 2018-06-21 11:35:52

Replying to [comment:41 jdemeyer]:
> Replying to [comment:35 Vaush]:
> > and then stepped through manually to understand what was happening.
> 
> Posting the actual output from gdb would have been useful here...
Yes, the point is that I don't have it anymore, since I did that 2 or 3 weeks ago. As I said, I am now recompiling sage with debug symbols to redo it and post the output.


---

Attachment

Screenshot of gdb's output


---

Comment by Vaush created at 2018-06-21 13:45:29

Ok, for some reason I can't seem to step into crypt anymore, while earlier I could see the fact that crypt on my system was a wrap around crypt_r.\\
Anyway, I used jdemeyer's patch, and I'm attaching gdb's output.\\
What happens is that Python now segfaults on the printing attempt.
I don't have any way of confirming what I said earlier about the value being returned by crypt being fine, but causing segfaults when accessed outside of it.\\


---

Comment by dimpase created at 2018-06-21 14:13:35

Could you post the output of ldd called on the corresponding *.so file?

Did you use a custom-built crypt library at your 1st attempt?

And, finally, could you add a print to show the value of the pointer `res`
before the print that causes the crash? (E.g. it could return NULL, or some
obviously invalid value...)


---

Comment by Vaush created at 2018-06-21 14:32:53

I don't remember using any custom-built library, so the answer would be no.\\
This is the output of ldd on the built python executable and on libcrypt:


```
[vaush@jesu-c290 src]$ ldd /lib64/libcrypt.so.1
	linux-vdso.so.1 (0x00007ffe913d6000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f32ada5e000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f32ae046000)
[vaush@jesu-c290 src]$ ldd ./python
	linux-vdso.so.1 (0x00007ffd247ec000)
	libpython3.6dm.so.1.0 => not found
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fd8b8512000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007fd8b830e000)
	libutil.so.1 => /lib64/libutil.so.1 (0x00007fd8b810b000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fd8b7d77000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fd8b79b8000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd8b8731000)

```

Finally, no, I can't print anything about it, unless you mean before the return value of crypt is assigned to it, since we introduced it with jdemeyer's patch.


---

Comment by dimpase created at 2018-06-21 14:54:37

Replying to [comment:46 Vaush]:
> I don't remember using any custom-built library, so the answer would be no.\\
> This is the output of ldd on the built python executable and on libcrypt:

no, I mean the crypt.*.so or _crypt.*.so or whatever it is called; on one system I have it's here:

```
$ ldd local/lib/python3.6/lib-dynload/_crypt.cpython-36m-x86_64-linux-gnu.so
        linux-vdso.so.1 =>  (0x00007fffdff5e000)
        libcrypt.so.1 => /lib/x86_64-linux-gnu/libcrypt.so.1 (0x00007da738262000)
        libpython3.6m.so.1.0 => /home/dima/sagetrac-mirror/local/lib/libpython3.6m.so.1.0 (0x00007da737d32000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007da737b15000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007da73774b000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007da737547000)
        libutil.so.1 => /lib/x86_64-linux-gnu/libutil.so.1 (0x00007da737344000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007da73703b000)
        /lib64/ld-linux-x86-64.so.2 (0x00007da73869c000)
```



> Finally, no, I can't print anything about it, unless you mean before the return value of crypt is assigned to it, since we introduced it with jdemeyer's patch.

I meant, certainly, that you modify Jeroen's patch so that you print the **value** of the
pointer `res` (i.e. the address) after the call to crypt(), before printing the 
string it points to (the latter print crashes).


---

Comment by Vaush created at 2018-06-21 15:09:15

Ok, sorry for the misunderstandings.\\
Here is the output of ldd:


```
vaush@jesu-c290:src$ ldd build/lib.linux-x86_64-3.6-pydebug/_crypt.cpython-36dm-x86_64-linux-gnu.so
	linux-vdso.so.1 (0x00007ffeca7f6000)
	libcrypt.so.1 => /lib64/libcrypt.so.1 (0x00007fe30d625000)
	libpython3.6dm.so.1.0 => /run/media/vaush/SageMath/SageMath/local/var/tmp/sage/build/python3-3.6.1.p1/src/libpython3.6dm.so.1.0 (0x00007fe30d0c4000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fe30cea5000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fe30cae6000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007fe30c8e2000)
	libutil.so.1 => /lib64/libutil.so.1 (0x00007fe30c6df000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fe30c34b000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fe30da50000)

```

While now python outputs this during compilation:


```
[python3-3.6.1.p1] crypt('', '$6$Ukf2OXfG3jHYFFCX')
[python3-3.6.1.p1] Address = '0xc4c020'

```

As you can see, the address is compatible with the theory I presented, that in some way the value of the pointer gets chopped when coming out of crypt. Still no success in stepping into crypt, but I don't see why, it was so easy the first time around...


---

Comment by dimpase created at 2018-06-21 17:11:27

Replying to [comment:48 Vaush]:
> Still no success in stepping into crypt, but I don't see why, it was so easy the first time around...

I don't see how you'd step in a system library in a meaningful way - they usually are stripped, you won't see any symbols.

Have a look at https://fedoraproject.org/wiki/StackTraces#Installing_debuginfo_RPMs_using_DNF


---

Comment by Vaush created at 2018-06-21 19:17:44

I installed the debug infos already, to no avail.
Anyway, I know that it shouldn't be possible, but the first time around I just naively did it, and stepped into the function in some way


---

Comment by jdemeyer created at 2018-06-21 19:40:23

I have a theory. The `implicit declaration of function 'crypt'` warning causes GCC to guess the return type as `int` (which is 32 bits). Now in reality the return type is `char *` (64 bits). So that might explain the zeroed bits.

If this theory is correct, then simply adding

```
#include <crypt.h>
```

should fix the problem.

Could you try just adding that line to `_cryptmodule.c`?


---

Comment by dimpase created at 2018-06-22 00:35:54

Replying to [comment:51 jdemeyer]:
> I have a theory. The `implicit declaration of function 'crypt'` warning causes GCC to guess the return type as `int` (which is 32 bits). Now in reality the return type is `char *` (64 bits). So that might explain the zeroed bits.
> 
> If this theory is correct, then simply adding
> {{{
> #include <crypt.h>
> }}}
> should fix the problem.
> 
> Could you try just adding that line to `_cryptmodule.c`?

Or, as I have been saying already, just change the patch you are adding so that it drops `crypt_r` chunk, as it would be precisely the same thing...
Anyhow, this theory is easy to confirm:

```
/* cry.c */
#include <stdio.h>
#ifdef CRYP
#include <crypt.h>
#endif
int main()
{
char *word="blah";
char *salt="foo";
char *res;
res = crypt(word, salt);
printf("%s\n",res);
return 0;
}
```

Now trying this out, with the right include:

```
$ gcc -DCRYP cry.c -lcrypt
$ ./a.out 
fo9NXBQQtNBSA
```

and without include

```
$ gcc cry.c -lcrypt
cry.c: In function â€˜mainâ€™:
cry.c:10:7: warning: implicit declaration of function â€˜cryptâ€™ [-Wimplicit-function-declaration]
 res = crypt(word, salt);
       ^~~~~
cry.c:10:5: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
 res = crypt(word, salt);
     ^
$ ./a.out 
Segmentation fault
```


Morale: pay attention to compiler warnings :-)


---

Comment by jdemeyer created at 2018-06-22 05:18:33

Replying to [comment:52 dimpase]:
> Morale: pay attention to compiler warnings :-)

Absolutely. I was totally confused earlier because the upstream PR incorrectly states "Because crypt() only depends on primitive C types, we currently get
away with calling it without it being declared."


---

Comment by jdemeyer created at 2018-06-22 07:57:34

This should be fixed in 3.7.0, so we should just upgrade when that version comes out.


---

Comment by jdemeyer created at 2018-06-22 07:57:34

Resolution: duplicate


---

Comment by vbraun created at 2018-07-04 14:53:13

I made #25771 to update to Python 3.6.6 which contains the backported crypt fix
