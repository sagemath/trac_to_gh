# Issue 30444: Fast Pfaffian using Faddeev-LeVerrier

archive/issues_030444.json:
```json
{
    "body": "CC:  tscrim mkoeppe chapoton vdelecroix\n\nKeywords: pfaffian\n\nAt the current stage, the Pfaffian is computed using the definition by perfect matchings. This is tremendously demanding.\n\nAccording to https://arxiv.org/abs/2008.04247, there is an algorithm similar to the Faddeev-LeVerrier algorithm for the determinant running in at most O(n^4). Furthermore, it is easy to implement. This algorithm works for any torsion-free ring.\n\nI suppose there is no way to check the torsion of rings in Sage right now. Hence, I would suggest to restrict the algorithm to integral domains of characteristic zero by performing the computation in the fraction field if necessary and then converting the result back. But I am not certain whether division by integers always turns out working as intended in the fraction field.\n\nIssue created by migration from https://trac.sagemath.org/ticket/30681\n\n",
    "created_at": "2020-09-28T14:52:45Z",
    "labels": [
        "linear algebra",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.3",
    "title": "Fast Pfaffian using Faddeev-LeVerrier",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30444",
    "user": "@mjungmath"
}
```
CC:  tscrim mkoeppe chapoton vdelecroix

Keywords: pfaffian

At the current stage, the Pfaffian is computed using the definition by perfect matchings. This is tremendously demanding.

According to https://arxiv.org/abs/2008.04247, there is an algorithm similar to the Faddeev-LeVerrier algorithm for the determinant running in at most O(n^4). Furthermore, it is easy to implement. This algorithm works for any torsion-free ring.

I suppose there is no way to check the torsion of rings in Sage right now. Hence, I would suggest to restrict the algorithm to integral domains of characteristic zero by performing the computation in the fraction field if necessary and then converting the result back. But I am not certain whether division by integers always turns out working as intended in the fraction field.

Issue created by migration from https://trac.sagemath.org/ticket/30681





---

archive/issue_comments_434514.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-09-28T15:05:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434514",
    "user": "@mjungmath"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_434515.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-28T15:06:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434515",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434516.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2020-09-28T21:25:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434516",
    "user": "@mjungmath"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_434517.json:
```json
{
    "body": "What do you need info on? The determinant version? I think that would be better as a separate ticket.\n\nI don't see the point in nailing `IntegralDomains()` in memory here. This function should not be called with the kind of frequency that would mandate that.\n\nWhen the result is not a field, how does other such algorithms work in Sage? Do they convert the result back to the original ring? I feel like if I use a matrix over `ZZ`, I would expect a result in `ZZ`.\n\nI would fully Cythonize `_pf_bfl` and write it as\n\n```python\n    cdef _pf_bfl(self):\n        cdef Py_ssize_t n = self._ncols\n        cdef Py_ssize_t q = n // 2\n        cdef Py_ssize_t i, k\n\n        # apply J:\n        cdef Matrix A = <Matrix> copy(self)\n        for i in range(0, n, 2):\n            A.swap_columns_c(i, i+1)  # Avoid some checks\n            # A.set_col_to_multiple_of_col(i+1, i+1, -1)\n            for k in range(n):\n                A.set_unsafe(k, i+1, -A.get_unsage(k, i+1))\n\n        cdef Matrix M = <Matrix> copy(A)\n\n        # Baer-Faddeev-Leverrier algorithm:\n        for k in range(1, q):\n            c = -M.trace() / (2*k)\n            # M = A * (M + c*1)\n            # Add c along the diagonal\n            for i in range(n):\n                M.set_unsafe(i, i, M.get_unsafe(i, i) + c)\n            M = A * M\n        c = -M.trace() / (2*q)\n        return (-1)**q * c\n```\n\nIt would be really good if there was an in place version of `M = A * M`, but alas, I don't think there is. So we will have to have that temporary object. `:/`",
    "created_at": "2020-09-28T22:45:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434517",
    "user": "tscrim"
}
```

What do you need info on? The determinant version? I think that would be better as a separate ticket.

I don't see the point in nailing `IntegralDomains()` in memory here. This function should not be called with the kind of frequency that would mandate that.

When the result is not a field, how does other such algorithms work in Sage? Do they convert the result back to the original ring? I feel like if I use a matrix over `ZZ`, I would expect a result in `ZZ`.

I would fully Cythonize `_pf_bfl` and write it as

```python
    cdef _pf_bfl(self):
        cdef Py_ssize_t n = self._ncols
        cdef Py_ssize_t q = n // 2
        cdef Py_ssize_t i, k

        # apply J:
        cdef Matrix A = <Matrix> copy(self)
        for i in range(0, n, 2):
            A.swap_columns_c(i, i+1)  # Avoid some checks
            # A.set_col_to_multiple_of_col(i+1, i+1, -1)
            for k in range(n):
                A.set_unsafe(k, i+1, -A.get_unsage(k, i+1))

        cdef Matrix M = <Matrix> copy(A)

        # Baer-Faddeev-Leverrier algorithm:
        for k in range(1, q):
            c = -M.trace() / (2*k)
            # M = A * (M + c*1)
            # Add c along the diagonal
            for i in range(n):
                M.set_unsafe(i, i, M.get_unsafe(i, i) + c)
            M = A * M
        c = -M.trace() / (2*q)
        return (-1)**q * c
```

It would be really good if there was an in place version of `M = A * M`, but alas, I don't think there is. So we will have to have that temporary object. `:/`



---

archive/issue_comments_434518.json:
```json
{
    "body": "Thank you for the feedback. This Cython version is already much better.\n\nOne question that occurred to me is whether the division by integers always works in the (fraction) field. It should, but I am not sure whether Sage always converts the integers mathematically correct.\n\nSecondly, the algorithm should work for `QQ` algebras as well. I would guess, you can even assume an algebra over an integral domain of characteristic zero. Can you confirm that? But even if that works, it also depends on the answer of my first question.\n\nObviously, each ring constitutes an algebra over itself. But apparently, Sage doesn't recognize that. So, if the answer to all my above questions is \"yes\", how can we establish a general check for the matrix's base ring being an algebra over an integral domain with characteristic zero? And how would a conversion look like?",
    "created_at": "2020-09-29T08:15:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434518",
    "user": "@mjungmath"
}
```

Thank you for the feedback. This Cython version is already much better.

One question that occurred to me is whether the division by integers always works in the (fraction) field. It should, but I am not sure whether Sage always converts the integers mathematically correct.

Secondly, the algorithm should work for `QQ` algebras as well. I would guess, you can even assume an algebra over an integral domain of characteristic zero. Can you confirm that? But even if that works, it also depends on the answer of my first question.

Obviously, each ring constitutes an algebra over itself. But apparently, Sage doesn't recognize that. So, if the answer to all my above questions is "yes", how can we establish a general check for the matrix's base ring being an algebra over an integral domain with characteristic zero? And how would a conversion look like?



---

archive/issue_comments_434519.json:
```json
{
    "body": "Replying to [comment:8 tscrim]:\n> When the result is not a field, how does other such algorithms work in Sage? Do they convert the result back to the original ring? I feel like if I use a matrix over `ZZ`, I would expect a result in `ZZ`.\n\nYes, it should. At least for `ZZ`, the current version does the job, in particular:\n\n\n```diff\n+                if R in _Fields:\n+                    pf = self._pf_bfl()\n+                else:\n+                    F = R.fraction_field()\n+                    pf = self._coerce_element(self.change_ring(F)._pf_bfl())\n```\n\n\nBut I am not sure whether this setup always works out.",
    "created_at": "2020-09-29T08:23:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434519",
    "user": "@mjungmath"
}
```

Replying to [comment:8 tscrim]:
> When the result is not a field, how does other such algorithms work in Sage? Do they convert the result back to the original ring? I feel like if I use a matrix over `ZZ`, I would expect a result in `ZZ`.

Yes, it should. At least for `ZZ`, the current version does the job, in particular:


```diff
+                if R in _Fields:
+                    pf = self._pf_bfl()
+                else:
+                    F = R.fraction_field()
+                    pf = self._coerce_element(self.change_ring(F)._pf_bfl())
```


But I am not sure whether this setup always works out.



---

archive/issue_comments_434520.json:
```json
{
    "body": "The `_pf_bfl` method is invoked from a regular Python function. I am not a Cython expert, but shouldn't that be a `cpdef` function then?\n\nOr do you suggest to rewrite `pfaffian` as well into Cython code?",
    "created_at": "2020-09-29T10:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434520",
    "user": "@mjungmath"
}
```

The `_pf_bfl` method is invoked from a regular Python function. I am not a Cython expert, but shouldn't that be a `cpdef` function then?

Or do you suggest to rewrite `pfaffian` as well into Cython code?



---

archive/issue_comments_434521.json:
```json
{
    "body": "Replying to [comment:11 gh-mjungmath]:\n> The `_pf_bfl` method is invoked from a regular Python function. I am not a Cython expert, but shouldn't that be a `cpdef` function then?\n\nNo, because it is called within Cython code. You might need to change\n\n```diff\n-self.change_ring(F)._pf_bfl()\n+(<Matrix> self.change_ring(F))._pf_bfl()\n```\n\nin the appropriate place so Cython knows the method exists.\n\n> Or do you suggest to rewrite `pfaffian` as well into Cython code?\n\nNo, that isn't worth it I think because the heavy lifting is done in the `_pf_bfl` method, which the end user will not see. (Although that is not to say that you shouldn't put some typing on things where appropriate.)",
    "created_at": "2020-09-29T12:26:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434521",
    "user": "tscrim"
}
```

Replying to [comment:11 gh-mjungmath]:
> The `_pf_bfl` method is invoked from a regular Python function. I am not a Cython expert, but shouldn't that be a `cpdef` function then?

No, because it is called within Cython code. You might need to change

```diff
-self.change_ring(F)._pf_bfl()
+(<Matrix> self.change_ring(F))._pf_bfl()
```

in the appropriate place so Cython knows the method exists.

> Or do you suggest to rewrite `pfaffian` as well into Cython code?

No, that isn't worth it I think because the heavy lifting is done in the `_pf_bfl` method, which the end user will not see. (Although that is not to say that you shouldn't put some typing on things where appropriate.)



---

archive/issue_comments_434522.json:
```json
{
    "body": "Replying to [comment:9 gh-mjungmath]:\n> One question that occurred to me is whether the division by integers always works in the (fraction) field. It should, but I am not sure whether Sage always converts the integers mathematically correct.\n\nWhen one of them is a Sage integer/rational/etc., then yes. If they are Python `int`s then they are handled like Python `int`s IIRC (although possibly like C `int`s). However, in response to your more general question, I believe the answer is yes.\n\n> Secondly, the algorithm should work for `QQ` algebras as well. I would guess, you can even assume an algebra over an integral domain of characteristic zero. Can you confirm that? But even if that works, it also depends on the answer of my first question.\n\nI am not sure what you are asking me here. I think the answer is yes, probably, but I am not sure.\n\n> Obviously, each ring constitutes an algebra over itself. But apparently, Sage doesn't recognize that. So, if the answer to all my above questions is \"yes\", how can we establish a general check for the matrix's base ring being an algebra over an integral domain with characteristic zero? And how would a conversion look like?\n\nWell, one option is to just try and and let it fail if it does something invalid. It just needs to be documented with what it is guaranteed to work for.",
    "created_at": "2020-09-29T12:29:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434522",
    "user": "tscrim"
}
```

Replying to [comment:9 gh-mjungmath]:
> One question that occurred to me is whether the division by integers always works in the (fraction) field. It should, but I am not sure whether Sage always converts the integers mathematically correct.

When one of them is a Sage integer/rational/etc., then yes. If they are Python `int`s then they are handled like Python `int`s IIRC (although possibly like C `int`s). However, in response to your more general question, I believe the answer is yes.

> Secondly, the algorithm should work for `QQ` algebras as well. I would guess, you can even assume an algebra over an integral domain of characteristic zero. Can you confirm that? But even if that works, it also depends on the answer of my first question.

I am not sure what you are asking me here. I think the answer is yes, probably, but I am not sure.

> Obviously, each ring constitutes an algebra over itself. But apparently, Sage doesn't recognize that. So, if the answer to all my above questions is "yes", how can we establish a general check for the matrix's base ring being an algebra over an integral domain with characteristic zero? And how would a conversion look like?

Well, one option is to just try and and let it fail if it does something invalid. It just needs to be documented with what it is guaranteed to work for.



---

archive/issue_comments_434523.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-29T18:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434523",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434524.json:
```json
{
    "body": "You mean like that?",
    "created_at": "2020-09-29T18:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434524",
    "user": "@mjungmath"
}
```

You mean like that?



---

archive/issue_comments_434525.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2020-09-29T18:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434525",
    "user": "@mjungmath"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_434526.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-29T21:09:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434526",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434527.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-29T21:58:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434527",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434528.json:
```json
{
    "body": "The `/` division will almost always convert to the fraction field, so there is no point in not first converting the initial matrix (in fact, this might even cause a crash). The other option would be doing `//` division, which then might return wrong results if the conditions set in the `.. WARNING::` are not satisfied.",
    "created_at": "2020-09-29T22:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434528",
    "user": "tscrim"
}
```

The `/` division will almost always convert to the fraction field, so there is no point in not first converting the initial matrix (in fact, this might even cause a crash). The other option would be doing `//` division, which then might return wrong results if the conditions set in the `.. WARNING::` are not satisfied.



---

archive/issue_comments_434529.json:
```json
{
    "body": "Replying to [comment:18 tscrim]:\n> The `/` division will almost always convert to the fraction field, so there is no point in not first converting the initial matrix (in fact, this might even cause a crash).\n\nThat was more or less my first thought, too. But think about examples like polynomial rings over `ZZ` where the element can be coerced into an element of `QQ[x]`. In that case, the fraction field setup is not necessary. In fact, if you already start with an `QQ` algebra that even has no fraction field implemented, the conversion to a fraction field will fail even though the algorithm would work. Thus, I would avoid going into the fraction field prior because it is not always the suitable choice.\n\nDo you have an example where no conversion would cause a crash?",
    "created_at": "2020-09-30T01:03:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434529",
    "user": "@mjungmath"
}
```

Replying to [comment:18 tscrim]:
> The `/` division will almost always convert to the fraction field, so there is no point in not first converting the initial matrix (in fact, this might even cause a crash).

That was more or less my first thought, too. But think about examples like polynomial rings over `ZZ` where the element can be coerced into an element of `QQ[x]`. In that case, the fraction field setup is not necessary. In fact, if you already start with an `QQ` algebra that even has no fraction field implemented, the conversion to a fraction field will fail even though the algorithm would work. Thus, I would avoid going into the fraction field prior because it is not always the suitable choice.

Do you have an example where no conversion would cause a crash?



---

archive/issue_comments_434530.json:
```json
{
    "body": "Replying to [comment:19 gh-mjungmath]:\n> Replying to [comment:18 tscrim]:\n> > The `/` division will almost always convert to the fraction field, so there is no point in not first converting the initial matrix (in fact, this might even cause a crash).\n> \n> That was more or less my first thought, too. But think about examples like polynomial rings over `ZZ` where the element can be coerced into an element of `QQ[x]`. In that case, the fraction field setup is not necessary. In fact, if you already start with an `QQ` algebra that even has no fraction field implemented, the conversion to a fraction field will fail even though the algorithm would work. Thus, I would avoid going into the fraction field prior because it is not always the suitable choice.\n\nDivision could be a subtle thing in Sage whether it computes the pushout first or the fraction field first. This might warrant some testing.\n\n> Do you have an example where no conversion would cause a crash? \n\nSince it doesn't change the type of the matrix, the entries might be expected to be `Integer` but instead be set to `Rational`. The type mismatch would then lead to a crash.",
    "created_at": "2020-09-30T04:43:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434530",
    "user": "tscrim"
}
```

Replying to [comment:19 gh-mjungmath]:
> Replying to [comment:18 tscrim]:
> > The `/` division will almost always convert to the fraction field, so there is no point in not first converting the initial matrix (in fact, this might even cause a crash).
> 
> That was more or less my first thought, too. But think about examples like polynomial rings over `ZZ` where the element can be coerced into an element of `QQ[x]`. In that case, the fraction field setup is not necessary. In fact, if you already start with an `QQ` algebra that even has no fraction field implemented, the conversion to a fraction field will fail even though the algorithm would work. Thus, I would avoid going into the fraction field prior because it is not always the suitable choice.

Division could be a subtle thing in Sage whether it computes the pushout first or the fraction field first. This might warrant some testing.

> Do you have an example where no conversion would cause a crash? 

Since it doesn't change the type of the matrix, the entries might be expected to be `Integer` but instead be set to `Rational`. The type mismatch would then lead to a crash.



---

archive/issue_comments_434531.json:
```json
{
    "body": "Okay, what do you suggest? Something like that perhaps? \n\n\n```python\ntry:\n    elt = R.zero() / 1 # try division by integers\n    F = elt.parent() # get parent\n    R(elt) # try conversion back\n    temp = <Matrix> self.change_ring(F)\n    ... \n```\n\n\nIf that succeeds, the matrix should be applicable for the BFL algorithm.",
    "created_at": "2020-09-30T07:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434531",
    "user": "@mjungmath"
}
```

Okay, what do you suggest? Something like that perhaps? 


```python
try:
    elt = R.zero() / 1 # try division by integers
    F = elt.parent() # get parent
    R(elt) # try conversion back
    temp = <Matrix> self.change_ring(F)
    ... 
```


If that succeeds, the matrix should be applicable for the BFL algorithm.



---

archive/issue_comments_434532.json:
```json
{
    "body": "Different approach: the paper explains that you can simply go into the rationalization. Is Sage capable of that? I didn't find anything useful so far, but maybe I haven't looked closely enough.",
    "created_at": "2020-09-30T10:57:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434532",
    "user": "@mjungmath"
}
```

Different approach: the paper explains that you can simply go into the rationalization. Is Sage capable of that? I didn't find anything useful so far, but maybe I haven't looked closely enough.



---

archive/issue_comments_434533.json:
```json
{
    "body": "I am not quite sure what you mean by the rationalization. I am guessing you don't mean the fraction field.\n\nActually, one thing you could do is\n\n```python\n        # Baer-Faddeev-Leverrier algorithm:\n        R = self._parent._base\n        for k in range(1, q):\n            c = R(-M.trace() / (2*k))\n            # add c along the diagonal\n            for i in range(n):\n                M.set_unsafe(i ,i, M.get_unsafe(i, i) + c)\n            M = A * M\n        c = R(-M.trace() / (2*q))\n        return (-1)**q * c\n```\n\nIt will be slightly slower for matrices over fields, but my guess is it wouldn't even be significant except in some possibly some really small examples. For non-fields, it would guarantee every element belongs to `R` after every division. However, this would then fail for Pfaffians over, e.g., `ZZ` because an intermediate computation needed to be in `QQ`.\n\nI think the best approach is probably converting the matrix to the fraction field, then coercing the result back to `R`.",
    "created_at": "2020-09-30T22:56:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434533",
    "user": "tscrim"
}
```

I am not quite sure what you mean by the rationalization. I am guessing you don't mean the fraction field.

Actually, one thing you could do is

```python
        # Baer-Faddeev-Leverrier algorithm:
        R = self._parent._base
        for k in range(1, q):
            c = R(-M.trace() / (2*k))
            # add c along the diagonal
            for i in range(n):
                M.set_unsafe(i ,i, M.get_unsafe(i, i) + c)
            M = A * M
        c = R(-M.trace() / (2*q))
        return (-1)**q * c
```

It will be slightly slower for matrices over fields, but my guess is it wouldn't even be significant except in some possibly some really small examples. For non-fields, it would guarantee every element belongs to `R` after every division. However, this would then fail for Pfaffians over, e.g., `ZZ` because an intermediate computation needed to be in `QQ`.

I think the best approach is probably converting the matrix to the fraction field, then coercing the result back to `R`.



---

archive/issue_comments_434534.json:
```json
{
    "body": "Replying to [comment:23 tscrim]:\n> I am not quite sure what you mean by the rationalization. I am guessing you don't mean the fraction field.\n\nAh, perhaps you mean extension of scalars to be a `QQ`-algebra. If this is the case, then Sage doesn't have this feature yet. You can change rings to be over `QQ`, but that won't work for algebras over, e.g., `ZZ['t']`. Well, I guess perhaps you could keep doing this until the base ring is itself:\n\n```\nsage: ZZ.base_ring()                                                                                                  \nInteger Ring\n```\n\nand then build new rings back. Although that feels a bit overkill right now as we can just go to the fraction field for this time with perhaps a `TODO` note.",
    "created_at": "2020-09-30T23:13:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434534",
    "user": "tscrim"
}
```

Replying to [comment:23 tscrim]:
> I am not quite sure what you mean by the rationalization. I am guessing you don't mean the fraction field.

Ah, perhaps you mean extension of scalars to be a `QQ`-algebra. If this is the case, then Sage doesn't have this feature yet. You can change rings to be over `QQ`, but that won't work for algebras over, e.g., `ZZ['t']`. Well, I guess perhaps you could keep doing this until the base ring is itself:

```
sage: ZZ.base_ring()                                                                                                  
Integer Ring
```

and then build new rings back. Although that feels a bit overkill right now as we can just go to the fraction field for this time with perhaps a `TODO` note.



---

archive/issue_comments_434535.json:
```json
{
    "body": "Fraction fields and TODO, check. But what about `QQ` algebras in particular? This would be very beneficial for e.g. mixed forms.\n\nBesides, what do you think about my proposal in comment 21?",
    "created_at": "2020-10-01T07:01:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434535",
    "user": "@mjungmath"
}
```

Fraction fields and TODO, check. But what about `QQ` algebras in particular? This would be very beneficial for e.g. mixed forms.

Besides, what do you think about my proposal in comment 21?



---

archive/issue_comments_434536.json:
```json
{
    "body": "My first thought for `QQ` algebras would be to test the category, but then I am not so convinced this is a good approach. Your idea in comment:21 should work unless an implementation does something very special for zero. I think you are better off doing\n\n```python\ntry:\n    F = parent(R.one() / 2)\n    R(F.one())  # trivial check that we can go back\n    temp = <Matrix> self.change_ring(F)\n    ...\n```\n\nsince that way it checks something non-trivial and that division is something that will actually be performed (so it will more quickly fail if you are working over `GF(2)`).",
    "created_at": "2020-10-01T07:49:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434536",
    "user": "tscrim"
}
```

My first thought for `QQ` algebras would be to test the category, but then I am not so convinced this is a good approach. Your idea in comment:21 should work unless an implementation does something very special for zero. I think you are better off doing

```python
try:
    F = parent(R.one() / 2)
    R(F.one())  # trivial check that we can go back
    temp = <Matrix> self.change_ring(F)
    ...
```

since that way it checks something non-trivial and that division is something that will actually be performed (so it will more quickly fail if you are working over `GF(2)`).



---

archive/issue_comments_434537.json:
```json
{
    "body": "Replying to [comment:26 tscrim]:\n> My first thought for `QQ` algebras would be to test the category, but then I am not so convinced this is a good approach.\n\nWhy do you think this is not a good approach?\n\nWhat about:\n\n\n```python\nF = R.base_ring()\nif QQ.is_subring(F):\n    pf = self._pf_bfl()\n```\n\n\nThis should work always.\n\n> Your idea in comment:21 should work unless an implementation does something very special for zero. I think you are better off doing\n> {{{#!python\n> try:\n>     F = parent(R.one() / 2)\n>     R(F.one())  # trivial check that we can go back\n>     temp = <Matrix> self.change_ring(F)\n>     ...\n> }}}\n> since that way it checks something non-trivial and that division is something that will actually be performed (so it will more quickly fail if you are working over `GF(2)`).\n\nI have a bad feeling about this approach. There is still plenty of room what can go wrong here, isn't it? I peeked a bit into the matrix code; take a closer look at `with_added_multiple_of_row` in `matrix0.pyx`, there you want to multiply a row by an integer. Perhaps this is something we can adapt:\n\n\n```python\nF = Sequence([R.one()] + [1/(2*j) for j in range(1, k//2 + 1)]).universe()\nif F in Rings():\n    temp = <Matrix> self.change_ring(F)\n    pf = R(temp._pf_bfl())\n```\n\n\nI am not completely sure how and whether this works.",
    "created_at": "2020-10-01T08:32:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434537",
    "user": "@mjungmath"
}
```

Replying to [comment:26 tscrim]:
> My first thought for `QQ` algebras would be to test the category, but then I am not so convinced this is a good approach.

Why do you think this is not a good approach?

What about:


```python
F = R.base_ring()
if QQ.is_subring(F):
    pf = self._pf_bfl()
```


This should work always.

> Your idea in comment:21 should work unless an implementation does something very special for zero. I think you are better off doing
> {{{#!python
> try:
>     F = parent(R.one() / 2)
>     R(F.one())  # trivial check that we can go back
>     temp = <Matrix> self.change_ring(F)
>     ...
> }}}
> since that way it checks something non-trivial and that division is something that will actually be performed (so it will more quickly fail if you are working over `GF(2)`).

I have a bad feeling about this approach. There is still plenty of room what can go wrong here, isn't it? I peeked a bit into the matrix code; take a closer look at `with_added_multiple_of_row` in `matrix0.pyx`, there you want to multiply a row by an integer. Perhaps this is something we can adapt:


```python
F = Sequence([R.one()] + [1/(2*j) for j in range(1, k//2 + 1)]).universe()
if F in Rings():
    temp = <Matrix> self.change_ring(F)
    pf = R(temp._pf_bfl())
```


I am not completely sure how and whether this works.



---

archive/issue_comments_434538.json:
```json
{
    "body": "Replying to [comment:27 gh-mjungmath]:\n> Replying to [comment:26 tscrim]:\n> > My first thought for `QQ` algebras would be to test the category, but then I am not so convinced this is a good approach.\n> \n> Why do you think this is not a good approach?\n\nBecause you could have something over `ZZ['q'].fraction_field()`, or worse over `QQ.category()` (this was done to minimize the number of categories constructed when varying over prime fields).\n\n> What about:\n> \n> {{{\n> #!python\n> F = R.base_ring()\n> if QQ.is_subring(F):\n>     pf = self._pf_bfl()\n> }}}\n> \n> This should work always.\n\nI am not entirely sure how much I trust that. It is more robust than I expected (I actually expected `QQ.is_subring(ZZ['t'].fraction_field())` to fail). From this check, I am comfortable enough to use this.\n\n> > Your idea in comment:21 should work unless an implementation does something very special for zero. I think you are better off doing\n> > {{{#!python\n> > try:\n> >     F = parent(R.one() / 2)\n> >     R(F.one())  # trivial check that we can go back\n> >     temp = <Matrix> self.change_ring(F)\n> >     ...\n> > }}}\n> > since that way it checks something non-trivial and that division is something that will actually be performed (so it will more quickly fail if you are working over `GF(2)`).\n> \n> I have a bad feeling about this approach. There is still plenty of room what can go wrong here, isn't it?\n\nIt would fail later on, but that is okay.\n\n> I peeked a bit into the matrix code; take a closer look at `with_added_multiple_of_row` in `matrix0.pyx`, there you want to multiply a row by an integer. Perhaps this is something we can adapt:\n> \n> {{{\n> #!python\n> F = Sequence([R.one()] + [1/(2*j) for j in range(1, k//2 + 1)]).universe()\n> temp = <Matrix> self.change_ring(F)\n> pf = R(temp._pf_bfl())\n> }}}\n\nThere shouldn't be any difference between dividing by 2 or 4 or 6 (unless working over `GF(3)`, but like I said above, this would fail later on, which is okay with me). Perhaps the `QQ.is_subring()` approach is best. At a certain point, we might be putting too much thought into this.",
    "created_at": "2020-10-01T08:51:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434538",
    "user": "tscrim"
}
```

Replying to [comment:27 gh-mjungmath]:
> Replying to [comment:26 tscrim]:
> > My first thought for `QQ` algebras would be to test the category, but then I am not so convinced this is a good approach.
> 
> Why do you think this is not a good approach?

Because you could have something over `ZZ['q'].fraction_field()`, or worse over `QQ.category()` (this was done to minimize the number of categories constructed when varying over prime fields).

> What about:
> 
> {{{
> #!python
> F = R.base_ring()
> if QQ.is_subring(F):
>     pf = self._pf_bfl()
> }}}
> 
> This should work always.

I am not entirely sure how much I trust that. It is more robust than I expected (I actually expected `QQ.is_subring(ZZ['t'].fraction_field())` to fail). From this check, I am comfortable enough to use this.

> > Your idea in comment:21 should work unless an implementation does something very special for zero. I think you are better off doing
> > {{{#!python
> > try:
> >     F = parent(R.one() / 2)
> >     R(F.one())  # trivial check that we can go back
> >     temp = <Matrix> self.change_ring(F)
> >     ...
> > }}}
> > since that way it checks something non-trivial and that division is something that will actually be performed (so it will more quickly fail if you are working over `GF(2)`).
> 
> I have a bad feeling about this approach. There is still plenty of room what can go wrong here, isn't it?

It would fail later on, but that is okay.

> I peeked a bit into the matrix code; take a closer look at `with_added_multiple_of_row` in `matrix0.pyx`, there you want to multiply a row by an integer. Perhaps this is something we can adapt:
> 
> {{{
> #!python
> F = Sequence([R.one()] + [1/(2*j) for j in range(1, k//2 + 1)]).universe()
> temp = <Matrix> self.change_ring(F)
> pf = R(temp._pf_bfl())
> }}}

There shouldn't be any difference between dividing by 2 or 4 or 6 (unless working over `GF(3)`, but like I said above, this would fail later on, which is okay with me). Perhaps the `QQ.is_subring()` approach is best. At a certain point, we might be putting too much thought into this.



---

archive/issue_comments_434539.json:
```json
{
    "body": "Replying to [comment:28 tscrim]:\n> There shouldn't be any difference between dividing by 2 or 4 or 6 (unless working over `GF(3)`, but like I said above, this would fail later on, which is okay with me). Perhaps the `QQ.is_subring()` approach is best. At a certain point, we might be putting too much thought into this.\n\nExactly. The algorithm should also work if the ring's characteristic is bigger than the matrix dimension. This is also guaranteed by this approach. But perhaps you are right, we are putting too much thought into this.\n\nI think, this might be good:\n\n\n```python\nif R in IntegralDomains():\n    F = R.fraction_field()\n    temp = <Matrix> self.change_ring(F)\nelse:\n    F = R.base_ring()\n    temp = <Matrix> copy(self)\nif QQ.is_subring(F):\n    pf = R(temp._pf_bfl())\n```\n\n\nThis checks already make sure that the characteristic is zero even without using `characteristic` (which is good because the mixed form algebra for example does not have this method). Moreover, this guarantees the integer division to work.",
    "created_at": "2020-10-01T09:04:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434539",
    "user": "@mjungmath"
}
```

Replying to [comment:28 tscrim]:
> There shouldn't be any difference between dividing by 2 or 4 or 6 (unless working over `GF(3)`, but like I said above, this would fail later on, which is okay with me). Perhaps the `QQ.is_subring()` approach is best. At a certain point, we might be putting too much thought into this.

Exactly. The algorithm should also work if the ring's characteristic is bigger than the matrix dimension. This is also guaranteed by this approach. But perhaps you are right, we are putting too much thought into this.

I think, this might be good:


```python
if R in IntegralDomains():
    F = R.fraction_field()
    temp = <Matrix> self.change_ring(F)
else:
    F = R.base_ring()
    temp = <Matrix> copy(self)
if QQ.is_subring(F):
    pf = R(temp._pf_bfl())
```


This checks already make sure that the characteristic is zero even without using `characteristic` (which is good because the mixed form algebra for example does not have this method). Moreover, this guarantees the integer division to work.



---

archive/issue_comments_434540.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-10-01T12:22:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434540",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_434541.json:
```json
{
    "body": "Check this out. This should be fine. The `QQ` sub-ring check is good enough to guarantee a working algorithm. And the number of applicable rings is reasonable. Ready for (final) review.",
    "created_at": "2020-10-01T12:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434541",
    "user": "@mjungmath"
}
```

Check this out. This should be fine. The `QQ` sub-ring check is good enough to guarantee a working algorithm. And the number of applicable rings is reasonable. Ready for (final) review.



---

archive/issue_comments_434542.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-10-01T12:30:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434542",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434543.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-10-01T17:34:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434543",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_434544.json:
```json
{
    "body": "Squashed to one commit. The changes were negligible.",
    "created_at": "2020-10-01T17:38:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434544",
    "user": "@mjungmath"
}
```

Squashed to one commit. The changes were negligible.



---

archive/issue_comments_434545.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-10-01T21:58:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434545",
    "user": "@mjungmath"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_434546.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-10-01T22:10:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434546",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434547.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-10-01T22:11:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434547",
    "user": "@mjungmath"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_434548.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-10-01T22:22:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434548",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_434549.json:
```json
{
    "body": "Turns out that `is_subring` is indeed **very** robust. Works for algebras such as mixed forms and scalar fields, too. Using `base_ring` was not a good idea, fails for e.g. fraction fields.\n\nSorry for the mess. I hope that should be it. If I should add any more tests/examples, let me know.",
    "created_at": "2020-10-01T22:28:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434549",
    "user": "@mjungmath"
}
```

Turns out that `is_subring` is indeed **very** robust. Works for algebras such as mixed forms and scalar fields, too. Using `base_ring` was not a good idea, fails for e.g. fraction fields.

Sorry for the mess. I hope that should be it. If I should add any more tests/examples, let me know.



---

archive/issue_comments_434550.json:
```json
{
    "body": "Minor details:\n\n```diff\n-        Computes the Pfaffian of ``self`` using the Baer-Faddeev-LeVerrier\n-        algorithm. This method assumes that the base ring is an `\\QQ`-algebra.\n+        Computes the Pfaffian of ``self`` using the Baer-Faddeev-LeVerrier\n+        algorithm.\n+\n+        .. WARNING::\n+\n+            This method assumes that the base ring is an `\\QQ`-algebra.\n```\n\nAlso `Computes` -> `Compute` for `_pf_perfect_matchings` and bad comma spacing:\n\n```diff\n-M.set_unsafe(i ,i, M.get_unsafe(i, i) + c)\n+M.set_unsafe(i, i, M.get_unsafe(i, i) + c)\n```\n\n\nI would also put the `bfl` method as the first choice in the doc since it is the \"default\" choice.",
    "created_at": "2020-10-01T23:32:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434550",
    "user": "tscrim"
}
```

Minor details:

```diff
-        Computes the Pfaffian of ``self`` using the Baer-Faddeev-LeVerrier
-        algorithm. This method assumes that the base ring is an `\QQ`-algebra.
+        Computes the Pfaffian of ``self`` using the Baer-Faddeev-LeVerrier
+        algorithm.
+
+        .. WARNING::
+
+            This method assumes that the base ring is an `\QQ`-algebra.
```

Also `Computes` -> `Compute` for `_pf_perfect_matchings` and bad comma spacing:

```diff
-M.set_unsafe(i ,i, M.get_unsafe(i, i) + c)
+M.set_unsafe(i, i, M.get_unsafe(i, i) + c)
```


I would also put the `bfl` method as the first choice in the doc since it is the "default" choice.



---

archive/issue_comments_434551.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-10-02T07:25:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434551",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434552.json:
```json
{
    "body": "Done. Thank you. :)",
    "created_at": "2020-10-02T07:25:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434552",
    "user": "@mjungmath"
}
```

Done. Thank you. :)



---

archive/issue_comments_434553.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-10-02T07:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434553",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_434554.json:
```json
{
    "body": "Thank you.",
    "created_at": "2020-10-02T07:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434554",
    "user": "tscrim"
}
```

Thank you.



---

archive/issue_comments_434555.json:
```json
{
    "body": "Thank *you* for the review. :)",
    "created_at": "2020-10-02T11:23:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434555",
    "user": "@mjungmath"
}
```

Thank *you* for the review. :)



---

archive/issue_comments_434556.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2020-10-02T11:31:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434556",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_434557.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2020-10-02T11:31:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434557",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_434558.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-10-02T11:38:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434558",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_434559.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-10-02T11:41:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434559",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_434560.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-10-02T11:43:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434560",
    "user": "@mjungmath"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_434561.json:
```json
{
    "body": "Added authorship and date and screwed up the merge.",
    "created_at": "2020-10-02T11:43:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434561",
    "user": "@mjungmath"
}
```

Added authorship and date and screwed up the merge.



---

archive/issue_comments_434562.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2020-10-03T21:16:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434562",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_434563.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2020-10-03T21:16:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434563",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_434564.json:
```json
{
    "body": "I just noticed that I forgot to fetch the cached result. Commit is pushed.",
    "created_at": "2020-10-03T21:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434564",
    "user": "@mjungmath"
}
```

I just noticed that I forgot to fetch the cached result. Commit is pushed.



---

archive/issue_comments_434565.json:
```json
{
    "body": "Yes, that is good to use, although I think the cache check should be first. Once that is moved, you can set a positive review on my behalf.",
    "created_at": "2020-10-04T02:22:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434565",
    "user": "tscrim"
}
```

Yes, that is good to use, although I think the cache check should be first. Once that is moved, you can set a positive review on my behalf.



---

archive/issue_comments_434566.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-10-04T08:35:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434566",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434567.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-10-04T08:49:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434567",
    "user": "@mjungmath"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_434568.json:
```json
{
    "body": "Thanks.",
    "created_at": "2020-10-04T08:49:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434568",
    "user": "@mjungmath"
}
```

Thanks.



---

archive/issue_comments_434569.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2020-10-04T12:01:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434569",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_434570.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2020-10-04T12:01:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434570",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_434571.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-10-04T12:03:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434571",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_434572.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-10-04T12:08:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434572",
    "user": "@mjungmath"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_434573.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-10-31T18:07:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30444#issuecomment-434573",
    "user": "vbraun"
}
```

Resolution: fixed
