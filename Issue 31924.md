# Issue 31924: Derivative of the symbolic sum of function of two variables

archive/issues_031924.json:
```json
{
    "body": "CC:  @nbruin @slel @mkoeppe @EmmanuelCharpentier\n\nLet's try to differentiate the symbolic sum of function of two variables.\n\n\n```\nsage: x,y = var(\"x,y\")\nsage: a,b = var(\"a,b\")\nsage: F = function(\"F\")(x, y)\nsage: from sage.calculus.calculus import symbolic_sum\nsage: s = symbolic_sum(F(x, y), x, a, b)\nsage: s.diff(y)\ndiff(F(x, y), y)*D[0](sum)(F(x, y), x, a, b)\n```\n\n\n\nBut expected something like\n\n\n\n```\nsum((diff(F(x, y), y), x, a, b)\n```\n\n\n\nor\n\n\n```\n\nsum(D[1](F(x, y)), x, a, b)\n```\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/32161\n\n",
    "created_at": "2021-07-08T03:41:06Z",
    "labels": [
        "symbolics",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Derivative of the symbolic sum of function of two variables",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31924",
    "user": "@daju1"
}
```
CC:  @nbruin @slel @mkoeppe @EmmanuelCharpentier

Let's try to differentiate the symbolic sum of function of two variables.


```
sage: x,y = var("x,y")
sage: a,b = var("a,b")
sage: F = function("F")(x, y)
sage: from sage.calculus.calculus import symbolic_sum
sage: s = symbolic_sum(F(x, y), x, a, b)
sage: s.diff(y)
diff(F(x, y), y)*D[0](sum)(F(x, y), x, a, b)
```



But expected something like



```
sum((diff(F(x, y), y), x, a, b)
```



or


```

sum(D[1](F(x, y)), x, a, b)
```



Issue created by migration from https://trac.sagemath.org/ticket/32161





---

archive/issue_comments_456100.json:
```json
{
    "body": "Attachment [bug Derivative of the symbolic sum of function of two variables.ipynb](tarball://root/attachments/some-uuid/ticket32161/bug Derivative of the symbolic sum of function of two variables.ipynb) by @daju1 created at 2021-07-21 15:16:19",
    "created_at": "2021-07-21T15:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456100",
    "user": "@daju1"
}
```

Attachment [bug Derivative of the symbolic sum of function of two variables.ipynb](tarball://root/attachments/some-uuid/ticket32161/bug Derivative of the symbolic sum of function of two variables.ipynb) by @daju1 created at 2021-07-21 15:16:19



---

archive/issue_comments_456101.json:
```json
{
    "body": "Set assignee to @daju1.",
    "created_at": "2021-07-21T15:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456101",
    "user": "@daju1"
}
```

Set assignee to @daju1.



---

archive/issue_comments_456102.json:
```json
{
    "body": "Attachment [bug Derivative of the symbolic sum of function of two variables.2.ipynb](tarball://root/attachments/some-uuid/ticket32161/bug Derivative of the symbolic sum of function of two variables.2.ipynb) by @nbruin created at 2021-07-21 16:07:36\n\nConfirming the bug reported here:\n\n```\nsage: var(\"x,a,b\")\n(x, a, b)\nsage: S=sum(f(x),x,a,b)\nsage: S\nsum(f(x), x, a, b)\nsage: S.diff(x)\ndiff(f(x), x)*D[0](sum)(f(x), x, a, b) + D[1](sum)(f(x), x, a, b)\n```\n\nClearly, sage has no knowledge on how to differentiate sums (it just considers the sum as an unknown function in four variables). The first step would be to throw an error, because things like 'sum(f(x+y),x,a,b+y).diff(y)' can probably not be handled.\n\nIn most cases, the most useful answer would probably be to differentiate term-wise (provided the differentiating variable does not occur in the bounds), which would be the correct answer for formal sums and absolutely convergent ones.",
    "created_at": "2021-07-21T16:07:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456102",
    "user": "@nbruin"
}
```

Attachment [bug Derivative of the symbolic sum of function of two variables.2.ipynb](tarball://root/attachments/some-uuid/ticket32161/bug Derivative of the symbolic sum of function of two variables.2.ipynb) by @nbruin created at 2021-07-21 16:07:36

Confirming the bug reported here:

```
sage: var("x,a,b")
(x, a, b)
sage: S=sum(f(x),x,a,b)
sage: S
sum(f(x), x, a, b)
sage: S.diff(x)
diff(f(x), x)*D[0](sum)(f(x), x, a, b) + D[1](sum)(f(x), x, a, b)
```

Clearly, sage has no knowledge on how to differentiate sums (it just considers the sum as an unknown function in four variables). The first step would be to throw an error, because things like 'sum(f(x+y),x,a,b+y).diff(y)' can probably not be handled.

In most cases, the most useful answer would probably be to differentiate term-wise (provided the differentiating variable does not occur in the bounds), which would be the correct answer for formal sums and absolutely convergent ones.



---

archive/issue_comments_456103.json:
```json
{
    "body": "My investigation of this issue shown that giac, maxima and sympy solve this example in true way.\n\nLet's try giac:\n\n```\nsage: sum_str = \"sum(F(sageVARx,sageVARy), sageVARx, sageVARa, sageVARb)\"                                                                                                        \nsage: from sage.interfaces.giac import giac                                                                                                                                      \nsage: result_giac = giac(sum_str)                                                                                                                                                \nsage: result_giac                                                                                                                                                                \nsum(F(sageVARx,sageVARy),sageVARx,sageVARa,sageVARb)\nsage: y = var('y')                                                                                                                                                               \nsage: result_giac.diff(y)                                                                                                                                                        \nsum((diff(F,1))(sageVARx,sageVARy),sageVARx,sageVARa,sageVARb)\n```\n\n\nLet's try sympy:\n\n\n```\nsage: x,y = var(\"x,y\")                                                                                                                                                           \nsage: a,b = var(\"a,b\")                                                                                                                                                           \nsage: F = function(\"F\")(x, y)                                                                                                                                                    \nsage: expression,v,a,b = [expr._sympy_() for expr in (F, x, a, b)]                                                                                                               \nsage: from sympy import summation                                                                                                                                                \nsage: from sage.interfaces.sympy import sympy_init                                                                                                                               \nsage: sympy_init()                                                                                                                                                               \nsage: result_sympy = summation(expression, (v, a, b)).diff(y)                                                                                                                    \nsage: result_sympy                                                                                                                                                               \nSum(Derivative(F(x, y), y), (x, a, b))\n```\n\n\nand an least maxima:\n\n\n\n```\nsage: s = maxima('sum(F(x,y),x,a,b)')                                                                                                                                            \nsage: s                                                                                                                                                                          \n'sum(F(x,y),x,a,b)\nsage: s.diff('y')                                                                                                                                                                \n'sum('diff(F(x,y),y,1),x,a,b)\nsage: s.diff('y').sage()                                                                                                                                                         \nsum(diff(F(x, y), y), x, a, b)\n```\n\n\nAll OK, but just\n\n\n```\ns.sage().diff(var('y'))                                                                                                                                                    \ndiff(F(x, y), y)*D[0](sum)(F(x, y), x, a, b)\n```\n\n\ngives wrong answer.\n\nI have understood what part of sage code gives this wrong result. This is function `def dummy_diff(*args): ` from `src/sage/calculus/calculus.py` which is called from\n\n```\ndef symbolic_expression_from_maxima_string(x, equals_sub=False, maxima=maxima):\n```\n\nConsidering that \n\n```\ndef symbolic_sum(expression, v, a, b, algorithm='maxima', hold=False):\n    if algorithm == 'maxima':\n        return maxima.sr_sum(expression,v,a,b)\n```\n\n\n\nI have provided example which reproduces the issue:\n\n\n```\nsage: from sage.misc.parser import Parser, LookupNameMaker \n....: from sage.calculus.calculus import _find_var, _find_func \n....: from sage.libs.pynac.pynac import symbol_table \n....: from sage.calculus.calculus import _is_function \n....:  \n....: parser_make_Mvar = LookupNameMaker({}, fallback=lambda x: _find_var(x, interface='maxima')) \n....: parser_make_function = LookupNameMaker({}, fallback=_find_func) \n....: SRM_parser = Parser(make_int      = lambda x: SR(Integer(x)), \n....:                     make_float    = lambda x: SR(RealDoubleElement(x)), \n....:                     make_var      = parser_make_Mvar, \n....:                     make_function = parser_make_function) \n....:  \n....: var_syms = {k: v for k, v in symbol_table.get('maxima', {}).items() \n....:             if not _is_function(v)} \n....: function_syms = {k: v for k, v in symbol_table.get('maxima', {}).items() \n....:                  if _is_function(v)} \n....:  \n....: #from sage.calculus.calculus import dummy_diff \n....: def dummy_diff(*args): \n....:     \"\"\" \n....:     This function is called when 'diff' appears in a Maxima string. \n....:  \n....:     EXAMPLES:: \n....:  \n....:         sage: from sage.calculus.calculus import dummy_diff \n....:         sage: x,y = var('x,y') \n....:         sage: dummy_diff(sin(x*y), x, SR(2), y, SR(1)) \n....:         -x*y^2*cos(x*y) - 2*y*sin(x*y) \n....:  \n....:     Here the function is used implicitly:: \n....:  \n....:         sage: a = var('a') \n....:         sage: f = function('cr')(a) \n....:         sage: g = f.diff(a); g \n....:         diff(cr(a), a) \n....:     \"\"\" \n....:     f = args[0] \n....:     from sage.cpython.debug import type_debug, shortrepr \n....:     args = list(args[1:]) \n....:     for i in range(1, len(args), 2): \n....:         args[i] = Integer(args[i]) \n....:     print (\"f\", f) \n....:     print (\"*args\", *args) \n....:     res = f.diff(*args) \n....:     print(\"res\", res) \n....:  \n....:     return res \n....:  \n....: function_syms['diff'] = dummy_diff                                                                                                                                         \nsage:                                                                                                                                                                            \nsage: s = \"diff(sr_sum(F(_SAGE_VAR_x,_SAGE_VAR_y),_SAGE_VAR_x,a,b),_SAGE_VAR_y,1)\" \n....:  \n....: SRM_parser._variable_constructor().set_names(var_syms) \n....: SRM_parser._callable_constructor().set_names(function_syms) \n....: parser_output = SRM_parser.parse_sequence(s) \n....: print(\"parser_output\", parser_output)                                                                                                                                      \nf sr_sum(F(x, y), x, a, b)\n*args y 1\nres diff(F(x, y), y)*D[0](sr_sum)(F(x, y), x, a, b)\nparser_output diff(F(x, y), y)*D[0](sr_sum)(F(x, y), x, a, b)\n\n```\n\n\nInside `dummy_diff(*args)` type of `f` is just `type(f) = <class 'sage.symbolic.expression.Expression'>` and may be you are right that sage thinks that 'sr_sum' an unknown function in four variables.",
    "created_at": "2021-07-26T00:49:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456103",
    "user": "@daju1"
}
```

My investigation of this issue shown that giac, maxima and sympy solve this example in true way.

Let's try giac:

```
sage: sum_str = "sum(F(sageVARx,sageVARy), sageVARx, sageVARa, sageVARb)"                                                                                                        
sage: from sage.interfaces.giac import giac                                                                                                                                      
sage: result_giac = giac(sum_str)                                                                                                                                                
sage: result_giac                                                                                                                                                                
sum(F(sageVARx,sageVARy),sageVARx,sageVARa,sageVARb)
sage: y = var('y')                                                                                                                                                               
sage: result_giac.diff(y)                                                                                                                                                        
sum((diff(F,1))(sageVARx,sageVARy),sageVARx,sageVARa,sageVARb)
```


Let's try sympy:


```
sage: x,y = var("x,y")                                                                                                                                                           
sage: a,b = var("a,b")                                                                                                                                                           
sage: F = function("F")(x, y)                                                                                                                                                    
sage: expression,v,a,b = [expr._sympy_() for expr in (F, x, a, b)]                                                                                                               
sage: from sympy import summation                                                                                                                                                
sage: from sage.interfaces.sympy import sympy_init                                                                                                                               
sage: sympy_init()                                                                                                                                                               
sage: result_sympy = summation(expression, (v, a, b)).diff(y)                                                                                                                    
sage: result_sympy                                                                                                                                                               
Sum(Derivative(F(x, y), y), (x, a, b))
```


and an least maxima:



```
sage: s = maxima('sum(F(x,y),x,a,b)')                                                                                                                                            
sage: s                                                                                                                                                                          
'sum(F(x,y),x,a,b)
sage: s.diff('y')                                                                                                                                                                
'sum('diff(F(x,y),y,1),x,a,b)
sage: s.diff('y').sage()                                                                                                                                                         
sum(diff(F(x, y), y), x, a, b)
```


All OK, but just


```
s.sage().diff(var('y'))                                                                                                                                                    
diff(F(x, y), y)*D[0](sum)(F(x, y), x, a, b)
```


gives wrong answer.

I have understood what part of sage code gives this wrong result. This is function `def dummy_diff(*args): ` from `src/sage/calculus/calculus.py` which is called from

```
def symbolic_expression_from_maxima_string(x, equals_sub=False, maxima=maxima):
```

Considering that 

```
def symbolic_sum(expression, v, a, b, algorithm='maxima', hold=False):
    if algorithm == 'maxima':
        return maxima.sr_sum(expression,v,a,b)
```



I have provided example which reproduces the issue:


```
sage: from sage.misc.parser import Parser, LookupNameMaker 
....: from sage.calculus.calculus import _find_var, _find_func 
....: from sage.libs.pynac.pynac import symbol_table 
....: from sage.calculus.calculus import _is_function 
....:  
....: parser_make_Mvar = LookupNameMaker({}, fallback=lambda x: _find_var(x, interface='maxima')) 
....: parser_make_function = LookupNameMaker({}, fallback=_find_func) 
....: SRM_parser = Parser(make_int      = lambda x: SR(Integer(x)), 
....:                     make_float    = lambda x: SR(RealDoubleElement(x)), 
....:                     make_var      = parser_make_Mvar, 
....:                     make_function = parser_make_function) 
....:  
....: var_syms = {k: v for k, v in symbol_table.get('maxima', {}).items() 
....:             if not _is_function(v)} 
....: function_syms = {k: v for k, v in symbol_table.get('maxima', {}).items() 
....:                  if _is_function(v)} 
....:  
....: #from sage.calculus.calculus import dummy_diff 
....: def dummy_diff(*args): 
....:     """ 
....:     This function is called when 'diff' appears in a Maxima string. 
....:  
....:     EXAMPLES:: 
....:  
....:         sage: from sage.calculus.calculus import dummy_diff 
....:         sage: x,y = var('x,y') 
....:         sage: dummy_diff(sin(x*y), x, SR(2), y, SR(1)) 
....:         -x*y^2*cos(x*y) - 2*y*sin(x*y) 
....:  
....:     Here the function is used implicitly:: 
....:  
....:         sage: a = var('a') 
....:         sage: f = function('cr')(a) 
....:         sage: g = f.diff(a); g 
....:         diff(cr(a), a) 
....:     """ 
....:     f = args[0] 
....:     from sage.cpython.debug import type_debug, shortrepr 
....:     args = list(args[1:]) 
....:     for i in range(1, len(args), 2): 
....:         args[i] = Integer(args[i]) 
....:     print ("f", f) 
....:     print ("*args", *args) 
....:     res = f.diff(*args) 
....:     print("res", res) 
....:  
....:     return res 
....:  
....: function_syms['diff'] = dummy_diff                                                                                                                                         
sage:                                                                                                                                                                            
sage: s = "diff(sr_sum(F(_SAGE_VAR_x,_SAGE_VAR_y),_SAGE_VAR_x,a,b),_SAGE_VAR_y,1)" 
....:  
....: SRM_parser._variable_constructor().set_names(var_syms) 
....: SRM_parser._callable_constructor().set_names(function_syms) 
....: parser_output = SRM_parser.parse_sequence(s) 
....: print("parser_output", parser_output)                                                                                                                                      
f sr_sum(F(x, y), x, a, b)
*args y 1
res diff(F(x, y), y)*D[0](sr_sum)(F(x, y), x, a, b)
parser_output diff(F(x, y), y)*D[0](sr_sum)(F(x, y), x, a, b)

```


Inside `dummy_diff(*args)` type of `f` is just `type(f) = <class 'sage.symbolic.expression.Expression'>` and may be you are right that sage thinks that 'sr_sum' an unknown function in four variables.



---

archive/issue_comments_456104.json:
```json
{
    "body": "You may have found which code in sage is involved in producing the wrong answer, but that code is not \"at fault\". It's just that it doesn't know how to differentiate sums, because it hasn't been told how to.\n\nIf one defines:\n\n```\ndef sum_deriv(self,*args,**kwds):\n    return self(*[[args[0].diff(kwds['diff_param'])]+list(args[1:])])\nmysum=function('mysum',nargs=4,tderivative_func=sum_deriv)\n```\n\none can just do:\n\n```\nsage: var('x,y,a,b')\n(x, y, a, b)\nsage: function('f')\nf\nsage: mysum(f(x,y),x,a,b).diff(y)\nmysum(diff(f(x, y), y), x, a, b)\n```\n\nThis approach is a little simple minded, of course (apart from the mathematical problem that term-wise differentiation is not always justified): it would need to check that the differentiation variable is indeed independent of the summation. With the current code, we get nonsense such as:\n\n```\nsage: mysum(f(x,y),x,a,b).diff(x)\nmysum(diff(f(x, y), x), x, a, b)\nsage: mysum(f(x,y),x,a,b).diff(a)\nmysum(0, x, a, b)\n```\n\nHowever, it does show which hook on `sage.functions.other.Function_sum'` would need to be populated.",
    "created_at": "2021-07-26T02:15:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456104",
    "user": "@nbruin"
}
```

You may have found which code in sage is involved in producing the wrong answer, but that code is not "at fault". It's just that it doesn't know how to differentiate sums, because it hasn't been told how to.

If one defines:

```
def sum_deriv(self,*args,**kwds):
    return self(*[[args[0].diff(kwds['diff_param'])]+list(args[1:])])
mysum=function('mysum',nargs=4,tderivative_func=sum_deriv)
```

one can just do:

```
sage: var('x,y,a,b')
(x, y, a, b)
sage: function('f')
f
sage: mysum(f(x,y),x,a,b).diff(y)
mysum(diff(f(x, y), y), x, a, b)
```

This approach is a little simple minded, of course (apart from the mathematical problem that term-wise differentiation is not always justified): it would need to check that the differentiation variable is indeed independent of the summation. With the current code, we get nonsense such as:

```
sage: mysum(f(x,y),x,a,b).diff(x)
mysum(diff(f(x, y), x), x, a, b)
sage: mysum(f(x,y),x,a,b).diff(a)
mysum(0, x, a, b)
```

However, it does show which hook on `sage.functions.other.Function_sum'` would need to be populated.



---

archive/issue_comments_456105.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-07-26T04:04:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456105",
    "user": "@daju1"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_456106.json:
```json
{
    "body": "Please see my commit which fixes the issue\n----\nNew commits:",
    "created_at": "2021-07-26T04:04:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456106",
    "user": "@daju1"
}
```

Please see my commit which fixes the issue
----
New commits:



---

archive/issue_comments_456107.json:
```json
{
    "body": "What does your code presently do with `sum(f(x,b),x,a,b).diff(b)`? It should probably check that the differentiation variable is independent from the bounds as well and perhaps throw an error if it's not.\n\nI'm also not so sure that 0 is the best answer if a derivative with respect to the summation variable is requested. Sure, it's not a free variable, so an external reference to it can be interpreted as a \"different\" variable, but it' more likely a typo.",
    "created_at": "2021-07-26T16:03:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456107",
    "user": "@nbruin"
}
```

What does your code presently do with `sum(f(x,b),x,a,b).diff(b)`? It should probably check that the differentiation variable is independent from the bounds as well and perhaps throw an error if it's not.

I'm also not so sure that 0 is the best answer if a derivative with respect to the summation variable is requested. Sure, it's not a free variable, so an external reference to it can be interpreted as a "different" variable, but it' more likely a typo.



---

archive/issue_comments_456108.json:
```json
{
    "body": "I have confirmed with sympy output\n\n\n```\nsage: x,y = var(\"x,y\") \n....: a,b = var(\"a,b\")                                                                                       \nsage: F = function(\"F\")(x, y)                                                                                \nsage: expression,v,a,b = [expr._sympy_() for expr in (F, x, a, b)] \n....: from sympy import summation \n....: from sage.interfaces.sympy import sympy_init \n....: sympy_init()                                                                                           \nsage: summation(expression, (v, a, b)).diff(y)                                                               \nSum(Derivative(F(x, y), y), (x, a, b))\nsage: summation(expression, (v, a, b)).diff(v)                                                               \n0\nsage: summation(expression, (v, a, b)).diff(a)                                                               \nDerivative(Sum(F(x, y), (x, a, b)), a)\nsage: summation(expression, (v, a, b)).diff(b)                                                               \nDerivative(Sum(F(x, y), (x, a, b)), b)\n\n```\n\n\nand tried the following \n\n\n```\n        from sage.calculus.functional import derivative\n        if diff_param == a:\n            ans = derivative(symbolic_sum(f, x, a, b, hold=True), a)\n        if diff_param == b:\n            ans = derivative(symbolic_sum(f, x, a, b, hold=True), b)\n```\n\n\nThe problem is that with this test\n\n\n```\n            sage: s.diff(a)\n            diff(sum(f, x, a, b), a)\n            sage: s.diff(b)\n            diff(sum(f, x, a, b), b)\n```\n\n\nI have received exception caused by infinitly recursive call-stack.",
    "created_at": "2021-07-26T18:49:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456108",
    "user": "@daju1"
}
```

I have confirmed with sympy output


```
sage: x,y = var("x,y") 
....: a,b = var("a,b")                                                                                       
sage: F = function("F")(x, y)                                                                                
sage: expression,v,a,b = [expr._sympy_() for expr in (F, x, a, b)] 
....: from sympy import summation 
....: from sage.interfaces.sympy import sympy_init 
....: sympy_init()                                                                                           
sage: summation(expression, (v, a, b)).diff(y)                                                               
Sum(Derivative(F(x, y), y), (x, a, b))
sage: summation(expression, (v, a, b)).diff(v)                                                               
0
sage: summation(expression, (v, a, b)).diff(a)                                                               
Derivative(Sum(F(x, y), (x, a, b)), a)
sage: summation(expression, (v, a, b)).diff(b)                                                               
Derivative(Sum(F(x, y), (x, a, b)), b)

```


and tried the following 


```
        from sage.calculus.functional import derivative
        if diff_param == a:
            ans = derivative(symbolic_sum(f, x, a, b, hold=True), a)
        if diff_param == b:
            ans = derivative(symbolic_sum(f, x, a, b, hold=True), b)
```


The problem is that with this test


```
            sage: s.diff(a)
            diff(sum(f, x, a, b), a)
            sage: s.diff(b)
            diff(sum(f, x, a, b), b)
```


I have received exception caused by infinitly recursive call-stack.



---

archive/issue_comments_456109.json:
```json
{
    "body": "Replying to [comment:9 gh-daju1]:\n> The problem is that with this test\n> \n> {{{\n>             sage: s.diff(a)\n>             diff(sum(f, x, a, b), a)\n>             sage: s.diff(b)\n>             diff(sum(f, x, a, b), b)\n> }}}\n> \n> I have received exception caused by infinitly recursive call-stack.\nYes, I guess the hold isn't strong enough here. You'll probably have to construct the derivative from lower-level primitives (basically, have a hold on the \"derivative\")\n\nThe problem is that in the current lingo, `diff(sum(f, x, a, b), a)` should basically return `(D[2]sum)(f,x,a,b)`. The operator in question is easily constructed by\n`sage.symbolic.operators.FDerivativeOperator(sage.functions.other.symbolic_sum,[2])`, but I think as soon as it's evaluated at `(f,x,a,b)` it will try to expand the operator again, leading to an infinite recursion. I don't know if we have precedent of this: functions that do have some rules for expanding their derivatives, but still need inert forms to linger too. It would be worth asking sage symbolic computation experts (particularly the pynac crowd?) what means we have to support this.\n\nFor now I'd say raising an error would be fine; I don't think anything useful would be possible with a derivative with respect to a summation bound.",
    "created_at": "2021-07-26T22:38:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456109",
    "user": "@nbruin"
}
```

Replying to [comment:9 gh-daju1]:
> The problem is that with this test
> 
> {{{
>             sage: s.diff(a)
>             diff(sum(f, x, a, b), a)
>             sage: s.diff(b)
>             diff(sum(f, x, a, b), b)
> }}}
> 
> I have received exception caused by infinitly recursive call-stack.
Yes, I guess the hold isn't strong enough here. You'll probably have to construct the derivative from lower-level primitives (basically, have a hold on the "derivative")

The problem is that in the current lingo, `diff(sum(f, x, a, b), a)` should basically return `(D[2]sum)(f,x,a,b)`. The operator in question is easily constructed by
`sage.symbolic.operators.FDerivativeOperator(sage.functions.other.symbolic_sum,[2])`, but I think as soon as it's evaluated at `(f,x,a,b)` it will try to expand the operator again, leading to an infinite recursion. I don't know if we have precedent of this: functions that do have some rules for expanding their derivatives, but still need inert forms to linger too. It would be worth asking sage symbolic computation experts (particularly the pynac crowd?) what means we have to support this.

For now I'd say raising an error would be fine; I don't think anything useful would be possible with a derivative with respect to a summation bound.



---

archive/issue_comments_456110.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-08-06T18:27:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456110",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_456111.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-08-17T10:51:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456111",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_456112.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-08-19T10:55:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456112",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_456113.json:
```json
{
    "body": "I think we should also be a bit careful if one of the summation limits is `oo`.\n\n```\nsage: n,x = var('n,x')\nsage: F = function('F')(x)\nsage: sum(F(x=x), x, 1, oo)\nsum(F(x), x, 1, +Infinity)\nsage: sum(x^(n*x), x, 1, oo)\nsum(x^(n*x), x, 1, +Infinity)\n```\n\nLimits may not commute. While I think such a useful case for this is unlikely, we might want to be a little more on the cautious side here.",
    "created_at": "2021-08-23T00:21:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456113",
    "user": "@tscrim"
}
```

I think we should also be a bit careful if one of the summation limits is `oo`.

```
sage: n,x = var('n,x')
sage: F = function('F')(x)
sage: sum(F(x=x), x, 1, oo)
sum(F(x), x, 1, +Infinity)
sage: sum(x^(n*x), x, 1, oo)
sum(x^(n*x), x, 1, +Infinity)
```

Limits may not commute. While I think such a useful case for this is unlikely, we might want to be a little more on the cautious side here.



---

archive/issue_comments_456114.json:
```json
{
    "body": "Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.",
    "created_at": "2021-12-18T19:53:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456114",
    "user": "@mkoeppe"
}
```

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.



---

archive/issue_comments_456115.json:
```json
{
    "body": "This issue came up again in:\n\nhttps://groups.google.com/g/sage-devel/c/Ksil-Qg9SlM/m/ZWUwKxdVAAAJ\n\nperhaps merging a more modest solution first that just addresses the simple cases is worthwhile?",
    "created_at": "2022-05-28T08:06:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456115",
    "user": "@nbruin"
}
```

This issue came up again in:

https://groups.google.com/g/sage-devel/c/Ksil-Qg9SlM/m/ZWUwKxdVAAAJ

perhaps merging a more modest solution first that just addresses the simple cases is worthwhile?



---

archive/issue_comments_456116.json:
```json
{
    "body": "Ahem...\n\nI'm not sure that \"derive a sum with respect to (one of) is bounds\" has any meaning... `set` is a //dscrete// operation  ; the summation variable takes **integer** values only. Forgetting this for a moment, try plotting `points([(u, sum(x, x, 0, u)) for u in (0, 1/3..4)])` to convince yourselves. You can even `plot(lambda u:sum(x, x, 0, u), (0, 4))`...\n\nIn other words, `sum(x, x, a, b) == -1/2*a^2 + 1/2*b^2 + 1/2*a + 1/2*b` holds **if and only if** `a` and `b` are **integers**. Differentiating the right-hand side of this equality wrt `a` and `b` has a meaning ; differentiating the left hand has **not**.\n\nThe fact that the closed expression `-1/2*a^2 + 1/2*b^2 + 1/2*a + 1/2*b`does not convey this condition is a design insufficiency of Sage (and Giac, Sympy and Mathematica ; Fricas (Axiom) may be a horse of an entirely different color...)\n\nIn consequence, we can check if the differentiation variable occurs in the expression of bounds, and safely raise some \"Nonsense exception\" (to be carefully choosen...) if so.\n\nHTH,",
    "created_at": "2022-05-29T06:28:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456116",
    "user": "@EmmanuelCharpentier"
}
```

Ahem...

I'm not sure that "derive a sum with respect to (one of) is bounds" has any meaning... `set` is a //dscrete// operation  ; the summation variable takes **integer** values only. Forgetting this for a moment, try plotting `points([(u, sum(x, x, 0, u)) for u in (0, 1/3..4)])` to convince yourselves. You can even `plot(lambda u:sum(x, x, 0, u), (0, 4))`...

In other words, `sum(x, x, a, b) == -1/2*a^2 + 1/2*b^2 + 1/2*a + 1/2*b` holds **if and only if** `a` and `b` are **integers**. Differentiating the right-hand side of this equality wrt `a` and `b` has a meaning ; differentiating the left hand has **not**.

The fact that the closed expression `-1/2*a^2 + 1/2*b^2 + 1/2*a + 1/2*b`does not convey this condition is a design insufficiency of Sage (and Giac, Sympy and Mathematica ; Fricas (Axiom) may be a horse of an entirely different color...)

In consequence, we can check if the differentiation variable occurs in the expression of bounds, and safely raise some "Nonsense exception" (to be carefully choosen...) if so.

HTH,



---

archive/issue_comments_456117.json:
```json
{
    "body": "Replying to [comment:20 charpent]:\n> I'm not sure that \"derive a sum with respect to (one of) is bounds\" has any meaning... `set` is a //dscrete// operation  ; the summation variable takes **integer** values only. Forgetting this for a moment, try plotting `points([(u, sum(x, x, 0, u)) for u in (0, 1/3..4)])` to convince yourselves. You can even `plot(lambda u:sum(x, x, 0, u), (0, 4))`...\n\nI don't think many interesting things will be done with it but something like\n`F(x)=sum((x+k)^2,k,0,floor(sqrt(x))`\nmakes perfect sense, and `F(x)` is a piecewise differentiable function. So I think the restraint the people considering the implementation here have shown discarding differentiation with respect to variables that occur in the bounds is somewhat warranted.\n\nI also think we've seen it gets pretty hairy quickly, so for the sake of at least being able to deal with more straightforward cases (and avoiding the outright wrong results we're getting now!) we SHOULD probably just cast an error if the summation variable or any of the bounds contain the differentiation variable.",
    "created_at": "2022-05-29T15:34:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31924",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31924#issuecomment-456117",
    "user": "@nbruin"
}
```

Replying to [comment:20 charpent]:
> I'm not sure that "derive a sum with respect to (one of) is bounds" has any meaning... `set` is a //dscrete// operation  ; the summation variable takes **integer** values only. Forgetting this for a moment, try plotting `points([(u, sum(x, x, 0, u)) for u in (0, 1/3..4)])` to convince yourselves. You can even `plot(lambda u:sum(x, x, 0, u), (0, 4))`...

I don't think many interesting things will be done with it but something like
`F(x)=sum((x+k)^2,k,0,floor(sqrt(x))`
makes perfect sense, and `F(x)` is a piecewise differentiable function. So I think the restraint the people considering the implementation here have shown discarding differentiation with respect to variables that occur in the bounds is somewhat warranted.

I also think we've seen it gets pretty hairy quickly, so for the sake of at least being able to deal with more straightforward cases (and avoiding the outright wrong results we're getting now!) we SHOULD probably just cast an error if the summation variable or any of the bounds contain the differentiation variable.
