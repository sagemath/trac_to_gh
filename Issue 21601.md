# Issue 21601: Better representation of exact reals in QQbar

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2016-11-08 10:04:44

CC:  tdumont tscrim

The following example is confusing because of the apparition of the imaginary part

```
sage: y = QQbar(cos(pi/18))
sage: y.imag() == 0
True
sage: y
0.9848077530122081? + 0.?e-36*I
```

This ticket proposes to change the representation of known exact reals to be without imaginary part, that is

```
sage: y
0.9848077530122081?
```



---

Comment by jdemeyer created at 2016-11-08 11:02:43

Possibly related: #20288.


---

Comment by vdelecroix created at 2017-05-03 17:41:02

The problem is directly related to the not careful enough conversion

```
sage: CIF(QQbar(cos(pi/18))).imag().is_zero()
False
```



---

Comment by chapoton created at 2020-08-17 19:36:36

VoilÃ  une tentative. Ca va probablement changer pas mal de doctests.
----
New commits:


---

Comment by chapoton created at 2020-08-17 19:40:50

Changing status from new to needs_review.


---

Comment by chapoton created at 2020-08-18 06:01:31

Looks rather good, not so many doctest failures. And they seem to be improvements

```
sage -t --long --random-seed=0 src/sage/matrix/matrix2.pyx  # 8 doctests failed
sage -t --long --random-seed=0 src/sage/dynamics/arithmetic_dynamics/projective_ds.py  # 1 doctest failed
sage -t --long --random-seed=0 src/sage/geometry/polyhedron/base.py  # 2 doctests failed
sage -t --long --random-seed=0 src/sage/schemes/generic/algebraic_scheme.py  # 2 doctests failed
sage -t --long --random-seed=0 src/sage/matrix/matrix0.pyx  # 1 doctest failed
sage -t --long --random-seed=0 src/sage/schemes/elliptic_curves/period_lattice.py  # 2 doctests failed
sage -t --long --random-seed=0 src/sage/symbolic/expression_conversions.py  # 1 doctest failed
sage -t --long --random-seed=0 src/sage/geometry/polyhedron/backend_field.py  # 2 doctests failed
```


Opinions ? Is this the way to go ?


---

Comment by tscrim created at 2020-08-18 06:06:54

I agree with your assessment and change. It does seem like an improvement.


---

Comment by git created at 2020-08-18 06:50:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-18 10:45:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-08-18 11:13:06

Green patchbot => positive review.


---

Comment by tscrim created at 2020-08-18 11:13:06

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2020-08-18 11:27:48

I was wondering (for no special reason) about possible slowing effects of the changes ?


---

Comment by tscrim created at 2020-08-18 11:32:53

I guess in principle there could be 2 extra `is_zero` tests that could be done, but I doubt that would cause any significant slowdown. Since the results are usually more accurate types (well, better reflect the element), I think the result should be either net 0 or a speedup due to subsequent computations. However, without any data, I couldn't say.

In short, I doubt there would be any.


---

Comment by chapoton created at 2020-08-18 12:08:02

I was more worried about the change

```diff
-            return repr(CIF(self._value))
+            return repr(self.interval(CIF))
         else:
-            return repr(RIF(self._value))
+            return repr(self.interval(RIF))
```

because I am not sure of the exact status of `_value`


---

Comment by @mwageringel created at 2020-08-18 21:52:48

Changing status from positive_review to needs_work.


---

Comment by @mwageringel created at 2020-08-18 21:52:48

I was also wondering whether this change means that now exactifications are computed that were not needed before?

```diff
             sage: Q*R - A
-            [            0.?e-17 0.?e-17 + 0.?e-17*I 0.?e-16 + 0.?e-16*I 0.?e-16 + 0.?e-16*I]
-            [            0.?e-18 0.?e-17 + 0.?e-17*I 0.?e-16 + 0.?e-16*I 0.?e-16 + 0.?e-16*I]
-            [0.?e-17 + 0.?e-18*I 0.?e-17 + 0.?e-17*I 0.?e-16 + 0.?e-16*I 0.?e-16 + 0.?e-16*I]
-            [0.?e-18 + 0.?e-18*I 0.?e-18 + 0.?e-18*I 0.?e-16 + 0.?e-16*I 0.?e-16 + 0.?e-16*I]
+            [0 0 0 0]
+            [0 0 0 0]
+            [0 0 0 0]
+            [0 0 0 0]
```


Also, there is one more test failure. Therefore I am setting this back to _needs work_.

```
File "src/sage/matrix/matrix2.pyx", line 11149, in sage.matrix.matrix2.Matrix.is_similar
Failed example:
    T
Expected:
    [ 1.00000000000000? + 0.?e-14*I            0.?e-14 + 0.?e-14*I            0.?e-14 + 0.?e-14*I]
    [-0.66666666666667? + 0.?e-15*I 0.166666666666667? + 0.?e-15*I -0.83333333333334? + 0.?e-14*I]
    [ 0.66666666666667? + 0.?e-14*I            0.?e-14 + 0.?e-14*I -0.33333333333333? + 0.?e-14*I]
Got:
    [                   1                    0                    0]
    [-0.6666666666666667?  0.1666666666666667? -0.8333333333333333?]
    [ 0.6666666666666667?                    0 -0.3333333333333334?]
```



---

Comment by git created at 2020-08-19 08:14:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-19 08:28:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2020-08-19 08:48:22

Well, one could argue that we now do in every case what we were only doing (these `.is_zero` tests) for real fields before. Moreover, the changes only touch either the "repr", which is not time critical, or the method "interval", which is used only for inexact conversion to real numbers or complex numbers.

I would therefore advocate that this is ok. Maybe benchmarks would be welcome ?


---

Comment by mmezzarobba created at 2020-08-19 09:37:23

Are you saying that with these changes, converting an element of QQbar to a complex interval can trigger an exactification to test if the element is real? Then I think that's a very bad idea. Testing if an element is real can be extremely costly, while converting to intervals (without caring if the result is real or not) is something you do all the time in some types of computations.

(I'm all in favor of printing elements of QQbar that are _already known_ to be real without an imaginary part if we're not already doing it. And I don't really like the idea of testing if the real part is zero in `_repr_`, though I can live with it.)


---

Comment by chapoton created at 2020-08-19 09:46:21

not in the conversion to RIF or CIF, but in conversion to RR or CC, I would say


---

Comment by mmezzarobba created at 2020-08-19 10:06:44

Regarding RR, I expect the conversion to fail if the imaginary part is not exactly zero.

However, conversion to CC shouldn't ever call `exactify()` IMO.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.
