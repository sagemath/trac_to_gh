# Issue 17171: Faster transitive_reduction (=> faster Poset creation)

archive/issues_017171.json:
```json
{
    "body": "CC:  @fchapoton @jm58660\n\nAs reported on #17361, the call to `transitive_reduction` represents a non-negligible part of Poset creation.\n\nThis branch re-implements it for acyclic graphs.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17408\n\n",
    "created_at": "2014-11-27T14:14:09Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.5",
    "title": "Faster transitive_reduction (=> faster Poset creation)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17171",
    "user": "https://github.com/nathanncohen"
}
```
CC:  @fchapoton @jm58660

As reported on #17361, the call to `transitive_reduction` represents a non-negligible part of Poset creation.

This branch re-implements it for acyclic graphs.

Issue created by migration from https://trac.sagemath.org/ticket/17408





---

archive/issue_comments_227989.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-11-27T14:19:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227989",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_227990.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-27T14:19:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227990",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_227991.json:
```json
{
    "body": "Changing keywords from \"\" to \"poset\".",
    "created_at": "2014-11-27T21:17:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227991",
    "user": "https://github.com/fchapoton"
}
```

Changing keywords from "" to "poset".



---

archive/issue_comments_227992.json:
```json
{
    "body": "\"That is actually pre-computing the equality relationships between all existing posets even if you never asked for it, and I personally see it as wasted time (especially since I cannot disable it).\"\n\nWhat happens with key= -parameter? If you put a different one in every poset, I think it should not try to compare to posets with different key.",
    "created_at": "2014-11-28T06:52:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227992",
    "user": "https://github.com/jm58660"
}
```

"That is actually pre-computing the equality relationships between all existing posets even if you never asked for it, and I personally see it as wasted time (especially since I cannot disable it)."

What happens with key= -parameter? If you put a different one in every poset, I think it should not try to compare to posets with different key.



---

archive/issue_comments_227993.json:
```json
{
    "body": "Indeed, but then the poset equality is broken. And I have no control the posets built by subfunctions like the poset constructors, the products, etc ...",
    "created_at": "2014-11-28T06:56:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227993",
    "user": "https://github.com/nathanncohen"
}
```

Indeed, but then the poset equality is broken. And I have no control the posets built by subfunctions like the poset constructors, the products, etc ...



---

archive/issue_comments_227994.json:
```json
{
    "body": "Replying to [comment:7 ncohen]:\n> Indeed, but then the poset equality is broken. And I have no control the posets built by subfunctions like the poset constructors, the products, etc ...\n\nTrue. Should there be a global setting for it? Or an option in every poset function for this?",
    "created_at": "2014-11-28T07:03:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227994",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:7 ncohen]:
> Indeed, but then the poset equality is broken. And I have no control the posets built by subfunctions like the poset constructors, the products, etc ...

True. Should there be a global setting for it? Or an option in every poset function for this?



---

archive/issue_comments_227995.json:
```json
{
    "body": "> True. Should there be a global setting for it? Or an option in every poset function for this?\n\nTruth is that I do not know. This feature is a class inheritance from `UniqueRepresentation`, so you cannot really \"flag\" that.\n\nYep. Complicated. Don't know how to make both work easily `-_-`\n\nNathann",
    "created_at": "2014-11-28T07:13:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227995",
    "user": "https://github.com/nathanncohen"
}
```

> True. Should there be a global setting for it? Or an option in every poset function for this?

Truth is that I do not know. This feature is a class inheritance from `UniqueRepresentation`, so you cannot really "flag" that.

Yep. Complicated. Don't know how to make both work easily `-_-`

Nathann



---

archive/issue_comments_227996.json:
```json
{
    "body": "Objects produced in an inner loop should not be `UniqueRepresentation`. Parent are *designed* to be heavy objects. You should be creating them at least one or two orders less frequently than your most frequently created objects (unless your computations aren't bound by creation of objects). If you're finding that you're creating posets frequently, then you should make a \"lightweight\" version of poset that's not carrying around all the parent baggage.\n\nIf you're finding that those \"lightweight\" posets need to be turned into full-fledged parents every now and again, then consider making it possible to create a full-scale poset from a lightweight one.\n\nSee [http://trac.sagemath.org/ticket/14356#comment:6](http://trac.sagemath.org/ticket/14356#comment:6)",
    "created_at": "2014-11-28T08:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227996",
    "user": "https://github.com/nbruin"
}
```

Objects produced in an inner loop should not be `UniqueRepresentation`. Parent are *designed* to be heavy objects. You should be creating them at least one or two orders less frequently than your most frequently created objects (unless your computations aren't bound by creation of objects). If you're finding that you're creating posets frequently, then you should make a "lightweight" version of poset that's not carrying around all the parent baggage.

If you're finding that those "lightweight" posets need to be turned into full-fledged parents every now and again, then consider making it possible to create a full-scale poset from a lightweight one.

See [http://trac.sagemath.org/ticket/14356#comment:6](http://trac.sagemath.org/ticket/14356#comment:6)



---

archive/issue_comments_227997.json:
```json
{
    "body": "Replying to [comment:10 nbruin]:\n\n> If you're finding that you're creating posets frequently, then you should make a \"lightweight\" version of poset that's not carrying around all the parent baggage.\n\nMaybe we already have this: it is called Hasse diagram?\n\nI mean, can we have a code generating only hasse diagrams and using functions from `hasse_diagram.py`? I have been computing quite many calculations of format \"Generate posets of size `n`. Remove those that have property `p`. For remaining compute `f(P)` and then find smallest/biggest value among results.\"",
    "created_at": "2014-11-28T08:53:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227997",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:10 nbruin]:

> If you're finding that you're creating posets frequently, then you should make a "lightweight" version of poset that's not carrying around all the parent baggage.

Maybe we already have this: it is called Hasse diagram?

I mean, can we have a code generating only hasse diagrams and using functions from `hasse_diagram.py`? I have been computing quite many calculations of format "Generate posets of size `n`. Remove those that have property `p`. For remaining compute `f(P)` and then find smallest/biggest value among results."



---

archive/issue_comments_227998.json:
```json
{
    "body": "> If you're finding that you're creating posets frequently, then you should make a \"lightweight\" version of poset that's not carrying around all the parent baggage.\n\nWell, Jori wants to implement a way to enumerate all posets of a given size, so in this case we will have to pay a high tribute to parents. But how do you think that it should be implemented ? Jori is right that Hasse Diagrams have a lot of features already, but that is only... Well, a Hasse Diagram. No comparisons of elements, none of the products defined in the posets directly, well.\n\nWhat we would need as you say is a class exactly like Poset without the parent infrastructure, but how could we implement that with the smallest amount of copy/paste ?\n\nNathann",
    "created_at": "2014-11-28T09:10:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227998",
    "user": "https://github.com/nathanncohen"
}
```

> If you're finding that you're creating posets frequently, then you should make a "lightweight" version of poset that's not carrying around all the parent baggage.

Well, Jori wants to implement a way to enumerate all posets of a given size, so in this case we will have to pay a high tribute to parents. But how do you think that it should be implemented ? Jori is right that Hasse Diagrams have a lot of features already, but that is only... Well, a Hasse Diagram. No comparisons of elements, none of the products defined in the posets directly, well.

What we would need as you say is a class exactly like Poset without the parent infrastructure, but how could we implement that with the smallest amount of copy/paste ?

Nathann



---

archive/issue_comments_227999.json:
```json
{
    "body": "\n```\nsage: g = posets.BooleanLattice(5).hasse_diagram().transitive_closure(); g = g.cartesian_product(g)\nsage: %time Poset(g)\nCPU times: user 284 ms, sys: 32 ms, total: 316 ms\nWall time: 278 ms\nFinite poset containing 1024 elements\nsage: %time Poset(g)\nCPU times: user 1.63 s, sys: 44 ms, total: 1.68 s\nWall time: 1.61 s\nFinite poset containing 1024 elements\n```\n",
    "created_at": "2014-11-28T09:16:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-227999",
    "user": "https://github.com/nathanncohen"
}
```


```
sage: g = posets.BooleanLattice(5).hasse_diagram().transitive_closure(); g = g.cartesian_product(g)
sage: %time Poset(g)
CPU times: user 284 ms, sys: 32 ms, total: 316 ms
Wall time: 278 ms
Finite poset containing 1024 elements
sage: %time Poset(g)
CPU times: user 1.63 s, sys: 44 ms, total: 1.68 s
Wall time: 1.61 s
Finite poset containing 1024 elements
```




---

archive/issue_comments_228000.json:
```json
{
    "body": "Replying to [comment:12 ncohen]:\n\n> What we would need as you say is a class exactly like Poset without the parent infrastructure, but how could we implement that with the smallest amount of copy/paste ?\n\nIt would require some thought and some major refactoring. The natural structure to me would seem to have a base class that does not inherit from UniqueRepresentation that implements all the basic stuff and then (hopefully) use multiple inheritance to equip this with the requisite parent stuff for the \"full Parent POSet\". If there are things that are incompatible between a usable \"fast POSet\" and a \"full parent POSet\" then the useful thing should probably inherit separately from the common base class.\n\nThe \"full parent poset\" __init__ would probably require some trickery to allow instantiation of a full parent from a fast poset (if that's required). Quite possibly, you'd be better off with a UniqueFactory there, so that you have better control over what the construction is keyed under.",
    "created_at": "2014-11-28T17:50:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228000",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:12 ncohen]:

> What we would need as you say is a class exactly like Poset without the parent infrastructure, but how could we implement that with the smallest amount of copy/paste ?

It would require some thought and some major refactoring. The natural structure to me would seem to have a base class that does not inherit from UniqueRepresentation that implements all the basic stuff and then (hopefully) use multiple inheritance to equip this with the requisite parent stuff for the "full Parent POSet". If there are things that are incompatible between a usable "fast POSet" and a "full parent POSet" then the useful thing should probably inherit separately from the common base class.

The "full parent poset" __init__ would probably require some trickery to allow instantiation of a full parent from a fast poset (if that's required). Quite possibly, you'd be better off with a UniqueFactory there, so that you have better control over what the construction is keyed under.



---

archive/issue_comments_228001.json:
```json
{
    "body": "What is the rationale behind current implementation? I mean, there must be some example where `UniqueRepresentation` makes things faster.\n\nI understand the logic for, say, finite ring, but not for posets.",
    "created_at": "2014-12-01T07:24:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228001",
    "user": "https://github.com/jm58660"
}
```

What is the rationale behind current implementation? I mean, there must be some example where `UniqueRepresentation` makes things faster.

I understand the logic for, say, finite ring, but not for posets.



---

archive/issue_comments_228002.json:
```json
{
    "body": "Replying to [comment:15 jmantysalo]:\n> What is the rationale behind current implementation? I mean, there must be some example where `UniqueRepresentation` makes things faster.\n\nI suspect it was done out of dogma: \"Parents are supposed to be unique\" in sage. That statement by itself is not correct: not all parents need to be unique. However, equal-but-non-identical parents can cause some minor problems in the coercion framework.\n\nThe real catch is if you're building a parent that can serve as base for other parents that ARE unique representation. Because cache keys there are looked up by equality and not identity, you can really confuse the coercion framework to the point of getting buggy behaviour. See [http://trac.sagemath.org/ticket/15248#comment:2](http://trac.sagemath.org/ticket/15248#comment:2) for an explanation of a classic example.\n\nThere is always a solution to this: do not inherit from UniqueRepresentation or UniqueFactory but do inherit from WithEqualityById (or implement that by yourself). It gives you a very cheap but mathematically not terribly useful equality test. However, there's something to say for it: The two posets `A={1,2,3}` and `B={1,2,3}` with trivial relation (ie. x<=y iff x==y) are isomorphic, but not uniquely so. So unless we're explicitly saying by what isomorphism `A,B` are to be identified, perhaps we should treat them as not equal. After all, `C={a,b,c}` (with empty relation) is also isomorphic to `A` and `B` and there no-one would be tempted to say C is equal to A and B.\n\nHowever, such strict equality might be too hard to swallow for people who want their computer algebra system to cater a little more to intuitive, human reasoning. In that case you can just make your parent non-unique, but still define equality to be by some looser equivalence relation. You should just document that your class is not appropriate for use as a base for another `UniqueRepesentation` parent.",
    "created_at": "2014-12-01T17:26:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228002",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:15 jmantysalo]:
> What is the rationale behind current implementation? I mean, there must be some example where `UniqueRepresentation` makes things faster.

I suspect it was done out of dogma: "Parents are supposed to be unique" in sage. That statement by itself is not correct: not all parents need to be unique. However, equal-but-non-identical parents can cause some minor problems in the coercion framework.

The real catch is if you're building a parent that can serve as base for other parents that ARE unique representation. Because cache keys there are looked up by equality and not identity, you can really confuse the coercion framework to the point of getting buggy behaviour. See [http://trac.sagemath.org/ticket/15248#comment:2](http://trac.sagemath.org/ticket/15248#comment:2) for an explanation of a classic example.

There is always a solution to this: do not inherit from UniqueRepresentation or UniqueFactory but do inherit from WithEqualityById (or implement that by yourself). It gives you a very cheap but mathematically not terribly useful equality test. However, there's something to say for it: The two posets `A={1,2,3}` and `B={1,2,3}` with trivial relation (ie. x<=y iff x==y) are isomorphic, but not uniquely so. So unless we're explicitly saying by what isomorphism `A,B` are to be identified, perhaps we should treat them as not equal. After all, `C={a,b,c}` (with empty relation) is also isomorphic to `A` and `B` and there no-one would be tempted to say C is equal to A and B.

However, such strict equality might be too hard to swallow for people who want their computer algebra system to cater a little more to intuitive, human reasoning. In that case you can just make your parent non-unique, but still define equality to be by some looser equivalence relation. You should just document that your class is not appropriate for use as a base for another `UniqueRepesentation` parent.



---

archive/issue_comments_228003.json:
```json
{
    "body": "Yooooo !\n\n> I suspect it was done out of dogma: \"Parents are supposed to be unique\" in sage.\n\nHMmmm... I am afraid that if I follow the mains lines of what you say, I have no clue how it is to be implemented in practice. I believe that the combinat guys use posets as exponents of polynomials, and that this is why they need a fast equality test. It would be cool if we could remove this `UniqueRepresentation` dependency from Posets, while letting them have a way to add it afterwards if they need it in their computations.\n\nWe just can't give up enumerating posets up to isomorphism because of this cached equality test. And lose seconds like in the ticket's description.\n\nNathann\n\nP.S. : What this ticket does is totally orthogonal to that, though, and still in `needs_review`  `:-P`",
    "created_at": "2014-12-01T17:37:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228003",
    "user": "https://github.com/nathanncohen"
}
```

Yooooo !

> I suspect it was done out of dogma: "Parents are supposed to be unique" in sage.

HMmmm... I am afraid that if I follow the mains lines of what you say, I have no clue how it is to be implemented in practice. I believe that the combinat guys use posets as exponents of polynomials, and that this is why they need a fast equality test. It would be cool if we could remove this `UniqueRepresentation` dependency from Posets, while letting them have a way to add it afterwards if they need it in their computations.

We just can't give up enumerating posets up to isomorphism because of this cached equality test. And lose seconds like in the ticket's description.

Nathann

P.S. : What this ticket does is totally orthogonal to that, though, and still in `needs_review`  `:-P`



---

archive/issue_comments_228004.json:
```json
{
    "body": "By the way I wonder if I should add a \"if self.is_directed_acyclic()\" in th function. I am not sure that those who use this `transitive_reduction` thing will think of looking at the doc, and `is_directed_acyclic` is rather cheap. What would you think of running it when `acyclic=False`, just in case ?\n\nNathann",
    "created_at": "2014-12-01T17:44:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228004",
    "user": "https://github.com/nathanncohen"
}
```

By the way I wonder if I should add a "if self.is_directed_acyclic()" in th function. I am not sure that those who use this `transitive_reduction` thing will think of looking at the doc, and `is_directed_acyclic` is rather cheap. What would you think of running it when `acyclic=False`, just in case ?

Nathann



---

archive/issue_comments_228005.json:
```json
{
    "body": "Replying to [comment:17 ncohen]:\n\n> HMmmm... I am afraid that if I follow the mains lines of what you say, I have no clue how it is to be implemented in practice. I believe that the combinat guys use posets as exponents of polynomials, and that this is why they need a fast equality test. It would be cool if we could remove this `UniqueRepresentation` dependency from Posets, while letting them have a way to add it afterwards if they need it in their computations.\n\nFor one thing, that use wouldn't require posets to be *parents* then.\n\n[possibly off-topic example]\nThis happens in number theory too: fractional ideals are Z-submodules of a number field, so they have elements. That would qualify them to be \"parents\", but nobody in their right mind would implement them like that if you're going to do ideal arithmetic: then they're just represented as matrices or tuples of generating elements. Equality is taken care of by putting generators in normal form, which can be fairly expensive the first time around, but equality testing afterwards is pretty quick.\n\nIf you want to make POsets faster you should seriously consider splitting POsets-as-parents and POsets-as-objects. Both usage scenarios you describe seem to fall in the latter scenario, by the way, so perhaps POsets-as-parents aren't really needed beyond checking a box for which parents are available in sage.",
    "created_at": "2014-12-01T17:52:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228005",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:17 ncohen]:

> HMmmm... I am afraid that if I follow the mains lines of what you say, I have no clue how it is to be implemented in practice. I believe that the combinat guys use posets as exponents of polynomials, and that this is why they need a fast equality test. It would be cool if we could remove this `UniqueRepresentation` dependency from Posets, while letting them have a way to add it afterwards if they need it in their computations.

For one thing, that use wouldn't require posets to be *parents* then.

[possibly off-topic example]
This happens in number theory too: fractional ideals are Z-submodules of a number field, so they have elements. That would qualify them to be "parents", but nobody in their right mind would implement them like that if you're going to do ideal arithmetic: then they're just represented as matrices or tuples of generating elements. Equality is taken care of by putting generators in normal form, which can be fairly expensive the first time around, but equality testing afterwards is pretty quick.

If you want to make POsets faster you should seriously consider splitting POsets-as-parents and POsets-as-objects. Both usage scenarios you describe seem to fall in the latter scenario, by the way, so perhaps POsets-as-parents aren't really needed beyond checking a box for which parents are available in sage.



---

archive/issue_comments_228006.json:
```json
{
    "body": "> If you want to make POsets faster you should seriously consider splitting POsets-as-parents and POsets-as-objects. Both usage scenarios you describe seem to fall in the latter scenario, by the way, so perhaps POsets-as-parents aren't really needed beyond checking a box for which parents are available in sage.\n\nWell, perhaps we could return \"Poset-as-parents\" when the user asks for a non-facade poset, and non-parent posets otherwise.\n\nSigh. I'll write to the sage-devel and the combinat guys...\n\nNathann",
    "created_at": "2014-12-01T17:55:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228006",
    "user": "https://github.com/nathanncohen"
}
```

> If you want to make POsets faster you should seriously consider splitting POsets-as-parents and POsets-as-objects. Both usage scenarios you describe seem to fall in the latter scenario, by the way, so perhaps POsets-as-parents aren't really needed beyond checking a box for which parents are available in sage.

Well, perhaps we could return "Poset-as-parents" when the user asks for a non-facade poset, and non-parent posets otherwise.

Sigh. I'll write to the sage-devel and the combinat guys...

Nathann



---

archive/issue_comments_228007.json:
```json
{
    "body": "Replying to [comment:16 nbruin]:\n\n> > What is the rationale behind current implementation? I mean, there must be some example where `UniqueRepresentation` makes things faster.\n\n> However, there's something to say for it: The two posets `A={1,2,3}` and `B={1,2,3}` with trivial relation (ie. x<=y iff x==y) are isomorphic, but not uniquely so. So unless we're explicitly saying by what isomorphism `A,B` are to be identified, perhaps we should treat them as not equal. After all, `C={a,b,c}` (with empty relation) is also isomorphic to `A` and `B` and there no-one would be tempted to say C is equal to A and B.\n\nThank you for very good explanation!\n\nGenerating all posets of size 7 up to isomorphism takes 18,5 second --- this is not a bottle neck then. But with #14110 the time drops to 2,5 seconds. And when generating just Hasse diagrams instead of posets it took 0,3 second. In the code I was asked to write this is the turning point: now slowest part is doing something with posets, not generating them.\n\nMaybe this is so specialized case that we should let posets to be like they are now. A user might then optimize by directly playing with Hasse diagrams.\n\nThis optimization does not mean that you can do things with posets of size `2n` --- it means that that you can use posets of size `n+2`.",
    "created_at": "2014-12-02T07:49:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228007",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:16 nbruin]:

> > What is the rationale behind current implementation? I mean, there must be some example where `UniqueRepresentation` makes things faster.

> However, there's something to say for it: The two posets `A={1,2,3}` and `B={1,2,3}` with trivial relation (ie. x<=y iff x==y) are isomorphic, but not uniquely so. So unless we're explicitly saying by what isomorphism `A,B` are to be identified, perhaps we should treat them as not equal. After all, `C={a,b,c}` (with empty relation) is also isomorphic to `A` and `B` and there no-one would be tempted to say C is equal to A and B.

Thank you for very good explanation!

Generating all posets of size 7 up to isomorphism takes 18,5 second --- this is not a bottle neck then. But with #14110 the time drops to 2,5 seconds. And when generating just Hasse diagrams instead of posets it took 0,3 second. In the code I was asked to write this is the turning point: now slowest part is doing something with posets, not generating them.

Maybe this is so specialized case that we should let posets to be like they are now. A user might then optimize by directly playing with Hasse diagrams.

This optimization does not mean that you can do things with posets of size `2n` --- it means that that you can use posets of size `n+2`.



---

archive/issue_comments_228008.json:
```json
{
    "body": "(beyond the poset discussion, this ticket is still needing a review) `:-P`",
    "created_at": "2014-12-05T06:54:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228008",
    "user": "https://github.com/nathanncohen"
}
```

(beyond the poset discussion, this ticket is still needing a review) `:-P`



---

archive/issue_comments_228009.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2014-12-05T07:37:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228009",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_228010.json:
```json
{
    "body": "I removed the \"acyclic\" flag that nobody would have seen and added an automatic detection of acyclic graphs. This has a small cost, but as I believe that nobody ever calls this function except on acyclic graphs I would say that it is a win (really, nobody would have seen the optional flag).\n\nNathann",
    "created_at": "2014-12-05T13:44:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228010",
    "user": "https://github.com/nathanncohen"
}
```

I removed the "acyclic" flag that nobody would have seen and added an automatic detection of acyclic graphs. This has a small cost, but as I believe that nobody ever calls this function except on acyclic graphs I would say that it is a win (really, nobody would have seen the optional flag).

Nathann



---

archive/issue_comments_228011.json:
```json
{
    "body": "There was a failing doctest, because undirected graphs do not have a is_directed_acyclic method.\n\nI have also made a few pep8 changes.\n\nLooks good to me. You can set a positive review if you agree with my changes.\n----\nNew commits:",
    "created_at": "2014-12-06T20:47:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228011",
    "user": "https://github.com/fchapoton"
}
```

There was a failing doctest, because undirected graphs do not have a is_directed_acyclic method.

I have also made a few pep8 changes.

Looks good to me. You can set a positive review if you agree with my changes.
----
New commits:



---

archive/issue_comments_228012.json:
```json
{
    "body": "Helloooooo !\n\n> There was a failing doctest, because undirected graphs do not have a is_directed_acyclic method.\n\nOh, I see. Thanks ! `;-)`\n\n> I have also made a few pep8 changes.\n\nYou should see a doctor about that `:-P`\n\n> Looks good to me. You can set a positive review if you agree with my changes.\n\nThanks again ! `:-)`\n\nNathann",
    "created_at": "2014-12-08T06:53:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228012",
    "user": "https://github.com/nathanncohen"
}
```

Helloooooo !

> There was a failing doctest, because undirected graphs do not have a is_directed_acyclic method.

Oh, I see. Thanks ! `;-)`

> I have also made a few pep8 changes.

You should see a doctor about that `:-P`

> Looks good to me. You can set a positive review if you agree with my changes.

Thanks again ! `:-)`

Nathann



---

archive/issue_comments_228013.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-12-08T06:53:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228013",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_228014.json:
```json
{
    "body": "doctests fail",
    "created_at": "2014-12-12T13:34:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228014",
    "user": "https://github.com/vbraun"
}
```

doctests fail



---

archive/issue_comments_228015.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-12-12T13:34:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228015",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_228016.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-12T18:42:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228016",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_228017.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2014-12-13T03:43:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228017",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_228018.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-12-16T13:57:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17171#issuecomment-228018",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_016588.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2014-12-16T13:57:13Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/17171",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17171#event-16588"
}
```
