# Issue 18698: Finite field linear function to polynomial

Issue created by migration from https://trac.sagemath.org/ticket/18935

Original creator: tgagne

Original creation time: 2015-07-21 22:06:28

CC:  rbeezer malb simonking

Keywords: finite field, polynomial

Adding a method which converts a linear function over a finite field in the form of a matrix into a polynomial over that finite field.
This method uses dual bases to perform this calculation in milliseconds over fields such as `GF(3^8)`, whereas a naive Lagrange interpolation calculation can take several minutes to get the same result. 


---

Comment by tgagne created at 2015-07-21 22:14:30

Changing status from new to needs_review.


---

Comment by tgagne created at 2015-07-21 22:14:30

Changing type from PLEASE CHANGE to enhancement.


---

Comment by tgagne created at 2015-07-21 22:14:30

Changing component from PLEASE CHANGE to finite rings.


---

Comment by tgagne created at 2015-07-21 22:14:30

Changing priority from major to minor.


---

Comment by jdemeyer created at 2015-07-23 08:09:28

The dependency should be a trac ticket, not a commit. Do you have a ticket for your dependency? If yes, write the ticket number there. If no, just remove the dependency.


---

Comment by tgagne created at 2015-07-23 19:54:53

Replying to [comment:2 jdemeyer]:
> The dependency should be a trac ticket, not a commit. Do you have a ticket for your dependency? If yes, write the ticket number there. If no, just remove the dependency.
Whoops! Thanks for pointing that out!


---

Comment by vdelecroix created at 2015-11-28 15:18:29

Why `base_matrix_to_polynomial` and not simply `matrix_to_polynomial`?

`poly(el)` is simpler than `poly.subs(x=el)`

This test is really bad

```
not all([matrix[i,j] in self.base_ring() for i in range(n) for j in range(n)])
```

You have several better options
- `matrix.base_ring() == self`
- `matrix = matrix.change_ring(self)` (this might make an unneeded copy)

If `var` is already an element of a polynomial ring then you should not recreate another one. In particular, I might want to work over QQ[x,y] and obtain a polynomial in the variable x in this specific ring. I would simply do

```
if isinstance(var, str):
    from sage.rings.polynomial.polynomial_ring import polygen
    var = polygen(self)
```


If the matrix is sparse you are doing a lot of unwanted computations. I would actually separate

```
if matrix.is_sparse():
    entries = matrix.nonzero_positions()
else:
    entries = ((i,j) for i in range(n) for j in range(n))

for i,j in entries:
    # do the looping
```

And add a test with a huge matrix with very few coefficients like

```
sage: M = matrix(GF(3,4), 1000, sparse=True)
sage: M[0,3] = 1
```


The operation `gen**i` is actually very fast. So I would avoid computing the list `basis` and replace `basis[i]` with `gen**i`

You should not compute a list and then make a sum of elements. Do everything at once

```
s = 0
for i in range(10):
    s += 1
```

is much better than

```
l = []
for i in range(10):
    l.append(i)
s = sum(l)
```



---

Comment by vdelecroix created at 2015-11-28 15:18:29

Changing status from needs_review to needs_work.
