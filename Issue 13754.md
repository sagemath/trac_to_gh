# Issue 13754: number of generators of number field ideal blows up under multiplication

Issue created by migration from https://trac.sagemath.org/ticket/13958

Original creator: mstreng

Original creation time: 2013-01-15 13:09:49

Assignee: davidloeffler

CC:  mderickx

Keywords: number field ideal multiplication power

With

```
K = QQ[sqrt(2)]
I = K.ideal(2).factor()[0][0]
I = I*I; I.ngens()
4
I = I*I; I.ngens()
16
I = I*I; I.ngens()
256
I = I*I; I.ngens()
65536
```

the first three squarings are fast, the fourth starts to be a bit slower, and if you try a fifth, it will take up all your memory.
The reason is that that the number of generators is multiplied with every multiplication and never reduced back to 1 or 2 with gens_reduced or gens_two, as you can see from the output.

Addition suffers from the same problem, but the result is less dramatic

```
sage: I = K.ideal(2).factor()[0][0]
sage: I = I+I; I.ngens()
4
sage: I = I+I; I.ngens()
8
sage: I = I+I; I.ngens()
16
sage: I = I+I; I.ngens()
32
sage: I = I+I; I.ngens()
64
sage: I = I+I; I.ngens()
128
sage: I = I+I; I.ngens()
256
```


Solution: implement `__mul__` for `NumberFieldFractionalIdeal` (instead of inheriting the function from Ideal) and use gens_two or gens_reduced before giving the output. Or wrap functions from pari.


---

Comment by nbruin created at 2013-01-15 21:16:01

I don't know how it is exactly in pari, but representing an ideal with 2 generators is not always cheaply done. Some ideal operations more naturally produce a basis of the ideal as a ZZ-basis (or a pseudobasis for relative ideals), which of course are also generators in the ideal sense. So I expect that internally, you should have the possiblity of either (or both) representations and lazily compute one representation from the other. In fact, internally it would probably be good to store them as power products too (being a far more compact representation when doing factor-basis based computations)


---

Comment by mderickx created at 2013-01-16 11:28:46

I did some profiling and from this it seems that gens_two is faster then pari_hnf. 

See: http://pastebin.com/aejaKMds for timings with principal ideals and http://pastebin.com/HU2DExLH for timings with ideals generated by multiple random elements (where the amount or random elements changes).

The documentation says that gens_two runs in randomized polynomial time (but does not say anything about the degree of the polynomial).
I think that at least in __mul__ it would make a lot of sense to call gens_two on both ideals before multiplication (at least if I.ngens()>2). Not doing this causes I.ngens() to explode as mentioned above. And my timing suggest that calling gens_two before multiplication and then multiplying is cheaper then first multiplying and then doing something like pari_hnf or gens_two . The reason is that as soon as your ideal is given by n!^2 generators (where n is the degree of the function field) then any operation to reduce the ammount of generators is going to be very costly, simply because the ammount of input generators is so big.


---

Comment by mderickx created at 2013-01-17 16:28:36

i just wrote a patch and will upload it shortly. Just a message to avoid duplication of effort.


---

Comment by mderickx created at 2013-01-18 10:56:46

Ok, here is the patch. I did not do anything with the !__add!__ method. The reason being that I think that the memory usage doesn't blow up to bad (the memory needed to store the sum(list_of_ideals) is linear in len(list_of_ideals) while the memory needed for prod(list_of_ideals) was exponential in len(list_of_ideals). And reducing the amount of generators after each addition is probably slower then reducing the amount of generators only when you need to do something more fancy with the Ideal.


---

Comment by mderickx created at 2013-01-18 10:57:40

Changing status from new to needs_review.


---

Comment by mstreng created at 2013-01-21 15:48:22

Changing status from needs_review to needs_work.


---

Comment by mstreng created at 2013-01-21 15:48:22

off-trac comments sent to mderickx


---

Comment by mderickx created at 2013-01-23 11:21:08

There is one reaction to the off-trac comments of which I think it deserves to be on trac. Namely why the implementation in the attachement is different from what turned out to be fastest one in the timings in the previous one.

The reason that it is different is that I tried some other strategy (namely just let pari figure everything out), and I found one that this one was even faster. See: http://pastebin.com/xRhq3mrX

So that is why I changed the code to do it this way. This has an extra bonus, namely if the pari ideal mul gets improved, then we automatically benefit from this.


---

Comment by mderickx created at 2013-01-23 14:34:28

Changing status from needs_work to needs_review.


---

Comment by mstreng created at 2013-01-25 12:06:13

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2013-01-25 12:22:48

Replying to [comment:1 nbruin]:
> representing an ideal with 2 generators is not always cheaply done.
[citation needed]


---

Comment by jdemeyer created at 2013-01-25 12:25:32

This patch needs a proper commit message.


---

Attachment


---

Comment by mderickx created at 2013-01-26 21:53:50

Sorry for the inconvenience. I added a commit message.


---

Comment by jdemeyer created at 2013-01-30 07:35:51

Resolution: fixed
