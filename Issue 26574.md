# Issue 26574: New MultiWeakref object

archive/issues_026574.json:
```json
{
    "body": "CC:  simonking\n\n...intended to solve some weak/strong reference problems in the coercion model. Details to follow.\n\nIssue created by migration from https://trac.sagemath.org/ticket/26811\n\n",
    "created_at": "2018-12-04T13:06:25Z",
    "labels": [
        "coercion",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.5",
    "title": "New MultiWeakref object",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26574",
    "user": "@jdemeyer"
}
```
CC:  simonking

...intended to solve some weak/strong reference problems in the coercion model. Details to follow.

Issue created by migration from https://trac.sagemath.org/ticket/26811





---

archive/issue_comments_373604.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-04T16:41:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373604",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373605.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-04T22:38:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373605",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373606.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-05T16:40:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373606",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373607.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-06T12:36:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373607",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373608.json:
```json
{
    "body": "Can you give a reference to (I guess) CPython documentation, that explains why your code works as it is supposed to?",
    "created_at": "2018-12-06T13:22:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373608",
    "user": "@simon-king-jena"
}
```

Can you give a reference to (I guess) CPython documentation, that explains why your code works as it is supposed to?



---

archive/issue_comments_373609.json:
```json
{
    "body": "Replying to [comment:9 SimonKing]:\n> Can you give a reference to (I guess) CPython documentation, that explains why your code works as it is supposed to?\n\nNo. The only reference is the CPython *source code*.",
    "created_at": "2018-12-06T13:32:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373609",
    "user": "@jdemeyer"
}
```

Replying to [comment:9 SimonKing]:
> Can you give a reference to (I guess) CPython documentation, that explains why your code works as it is supposed to?

No. The only reference is the CPython *source code*.



---

archive/issue_comments_373610.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-06T16:04:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373610",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373611.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-06T16:24:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373611",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373612.json:
```json
{
    "body": "I think the implementation is more or less done now. I added plenty of documentation, I hope it is clear.",
    "created_at": "2018-12-06T16:25:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373612",
    "user": "@jdemeyer"
}
```

I think the implementation is more or less done now. I added plenty of documentation, I hope it is clear.



---

archive/issue_comments_373613.json:
```json
{
    "body": "It looks like a neat idea and it may be worth experimenting with it to see if we can get some benefits out of it, but before we commit to accepting its use in sage, I think we need to establish a clearer picture of what the assumptions on CPython are and to what extent these are justified.\n\nThe main thing that worries me is the dependence on visiting order whether links are considered strong or not. As we've seen, the order of visiting can influence whether a certain cycle will be found reachable or not, so in addition to lifetime of objects being ill-defined due to when gc happens, we'll also have that it's ill-defined due to how gc proceeds.\n\nWhat are exactly the assumptions we are making about visiting order that would allow us, given a reference graph, to decide which objects will be found reachable and which won't?",
    "created_at": "2018-12-06T21:47:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373613",
    "user": "@nbruin"
}
```

It looks like a neat idea and it may be worth experimenting with it to see if we can get some benefits out of it, but before we commit to accepting its use in sage, I think we need to establish a clearer picture of what the assumptions on CPython are and to what extent these are justified.

The main thing that worries me is the dependence on visiting order whether links are considered strong or not. As we've seen, the order of visiting can influence whether a certain cycle will be found reachable or not, so in addition to lifetime of objects being ill-defined due to when gc happens, we'll also have that it's ill-defined due to how gc proceeds.

What are exactly the assumptions we are making about visiting order that would allow us, given a reference graph, to decide which objects will be found reachable and which won't?



---

archive/issue_comments_373614.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-07T09:55:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373614",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373615.json:
```json
{
    "body": "We define a *traverse loop* as a loop of the form:\n\n```\n        for obj in set_of_objects:\n            type(obj)->tp_traverse(obj, visit, arg)\n```\n\nwhere `visit` is constant during the loop (`arg` does not\nmatter). More precisely, a traverse loop is a sequence of\nconsecutive `tp_traverse` calls with the same `visit`.\nTraverse loops can be detected by comparing the `visit` argument\nto the last `visit`.\n\nThese are the main assumptions:\n\n1. Any garbage collection involves at least two traverse loops.\n   Thefore, a traverse loop cannot span multiple garbage\n   collections. In CPython, a garbage collection needs two\n   traverse loops: one in `subtract_refs` and one in\n   `move_unreachable`.\n\n2. The precise reference graph is allowed to change between traverse\n   loops, as long as refcounts do not change and the reference graph\n   is consistent within each individual traverse loop.\n\n3. Considering the first-visited references in a traverse loop as\n   weak references maximizes the amount of garbage that can be\n   collected.",
    "created_at": "2018-12-07T09:57:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373615",
    "user": "@jdemeyer"
}
```

We define a *traverse loop* as a loop of the form:

```
        for obj in set_of_objects:
            type(obj)->tp_traverse(obj, visit, arg)
```

where `visit` is constant during the loop (`arg` does not
matter). More precisely, a traverse loop is a sequence of
consecutive `tp_traverse` calls with the same `visit`.
Traverse loops can be detected by comparing the `visit` argument
to the last `visit`.

These are the main assumptions:

1. Any garbage collection involves at least two traverse loops.
   Thefore, a traverse loop cannot span multiple garbage
   collections. In CPython, a garbage collection needs two
   traverse loops: one in `subtract_refs` and one in
   `move_unreachable`.

2. The precise reference graph is allowed to change between traverse
   loops, as long as refcounts do not change and the reference graph
   is consistent within each individual traverse loop.

3. Considering the first-visited references in a traverse loop as
   weak references maximizes the amount of garbage that can be
   collected.



---

archive/issue_comments_373616.json:
```json
{
    "body": "Replying to [comment:15 nbruin]:\n> As we've seen, the order of visiting can influence whether a certain cycle will be found reachable or not\n\nCan you elaborate on this or give an example?",
    "created_at": "2018-12-07T09:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373616",
    "user": "@jdemeyer"
}
```

Replying to [comment:15 nbruin]:
> As we've seen, the order of visiting can influence whether a certain cycle will be found reachable or not

Can you elaborate on this or give an example?



---

archive/issue_comments_373617.json:
```json
{
    "body": "Replying to [comment:15 nbruin]:\n> we'll also have that it's ill-defined due to how gc proceeds.\n\nThe order-dependence here should not be a problem because the GC does not really keep track of references `A -> B` but only the number of times that `B` is referenced. You can see this in the signature of `visit`: only the visited object (`B`) is passed, not the object holding the reference (`A`).\n\nSo we really want to minimize the number of times that `B` is seen as reference, it doesn't matter which objects have `B` as strong reference.",
    "created_at": "2018-12-07T10:02:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373617",
    "user": "@jdemeyer"
}
```

Replying to [comment:15 nbruin]:
> we'll also have that it's ill-defined due to how gc proceeds.

The order-dependence here should not be a problem because the GC does not really keep track of references `A -> B` but only the number of times that `B` is referenced. You can see this in the signature of `visit`: only the visited object (`B`) is passed, not the object holding the reference (`A`).

So we really want to minimize the number of times that `B` is seen as reference, it doesn't matter which objects have `B` as strong reference.



---

archive/issue_comments_373618.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-07T10:49:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373618",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373619.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-12-07T15:30:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373619",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_373620.json:
```json
{
    "body": "Replying to [comment:18 jdemeyer]:\n> Replying to [comment:15 nbruin]:\n> > As we've seen, the order of visiting can influence whether a certain cycle will be found reachable or not\n> \n> Can you elaborate on this or give an example?\n\nIf we have a multiref object M to an object C that needs two references to stay alive and has two references\n\n```\n<ROOT> -> A -> M -> C and B -> M -> C -> B\n```\n \nthen it depends in what order these are checked: If the connection via <ROOT> is checked first, then the \"strong\" reference to C falls in an unreachable cycle, so C is collectible. In the other order, the \"strong\" reference comes from <ROOT>, so C lives on.\n\nThat's why order matters. Apparently you are assuming that all \"reachable\" trees are visited before other links are examined. In a full mark-and-sweep collector, this would be a fair assumption, because the unreachable nodes will not be visited. Because python uses a hybrid system with reference counting, it is not clear to me that this is a valid assumption, or that it will remain valid if it is now. In principle, you could decide that a cycle is unreachable by checking that all the reference counts can be accounted for by internal links.\n\nI think you are also assuming is that the \"VISIT\" callback will be identical within an entire GC operation.\n\nThese assumptions should all be made explicit and corroborated if possible. They are definite drawbacks to this approach, because it ties the *design* of sage more closely to a particular implementation: You are introducing a primitive that is not easy to implement on memory models without detailed knowledge.\n\nI think definite advantages need to be exhibited before we'd commit to using a primitive like this.\n\nFor instance, I'm not so sure that the penalty above is worth paying just to ditch the weak ref to the domain. Another, more transparent way to do this, is to clearly distinguish the lifetime implications for structures with coercions (with a coercion A -> B, should B keep A alive or the other way around? -- I think it is acceptable to have one or the other) and then cache the map on the shorter-lived one.",
    "created_at": "2018-12-07T18:34:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373620",
    "user": "@nbruin"
}
```

Replying to [comment:18 jdemeyer]:
> Replying to [comment:15 nbruin]:
> > As we've seen, the order of visiting can influence whether a certain cycle will be found reachable or not
> 
> Can you elaborate on this or give an example?

If we have a multiref object M to an object C that needs two references to stay alive and has two references

```
<ROOT> -> A -> M -> C and B -> M -> C -> B
```
 
then it depends in what order these are checked: If the connection via <ROOT> is checked first, then the "strong" reference to C falls in an unreachable cycle, so C is collectible. In the other order, the "strong" reference comes from <ROOT>, so C lives on.

That's why order matters. Apparently you are assuming that all "reachable" trees are visited before other links are examined. In a full mark-and-sweep collector, this would be a fair assumption, because the unreachable nodes will not be visited. Because python uses a hybrid system with reference counting, it is not clear to me that this is a valid assumption, or that it will remain valid if it is now. In principle, you could decide that a cycle is unreachable by checking that all the reference counts can be accounted for by internal links.

I think you are also assuming is that the "VISIT" callback will be identical within an entire GC operation.

These assumptions should all be made explicit and corroborated if possible. They are definite drawbacks to this approach, because it ties the *design* of sage more closely to a particular implementation: You are introducing a primitive that is not easy to implement on memory models without detailed knowledge.

I think definite advantages need to be exhibited before we'd commit to using a primitive like this.

For instance, I'm not so sure that the penalty above is worth paying just to ditch the weak ref to the domain. Another, more transparent way to do this, is to clearly distinguish the lifetime implications for structures with coercions (with a coercion A -> B, should B keep A alive or the other way around? -- I think it is acceptable to have one or the other) and then cache the map on the shorter-lived one.



---

archive/issue_comments_373621.json:
```json
{
    "body": "Replying to [comment:22 nbruin]:\n> That's why order matters. Apparently you are assuming that all \"reachable\" trees are visited before other links are examined.\n\nYes, and this is how the Python GC works. Admittedly, it's an assumption, but it's an assumption which is currently valid.\n\n> In principle, you could decide that a cycle is unreachable by checking that all the reference counts can be accounted for by internal links.\n\nYes, and this is part of what Python's GC does: it uses refcounts to determine which objects are certainly reachable and which are potentially unreachable. It then recursively checks all links from reachable objects to determine which potentially unreachable objects are reachable anyway.\n\nSo in your example (assuming that `ROOT` is not tracked by GC), `A` will be certainly reachable and all other objects will start out potentially unreachable.\n\n> I think you are also assuming is that the \"VISIT\" callback will be identical within an entire GC operation.\n\nNo, a single GC operation involves two traverse loops with two distinct VISIT values (one to count references and one to check potentially unreachable objects).\n\n> These assumptions should all be made explicit and corroborated if possible.\n\nI think I'm doing that in the documentation, in the section starting with `ASSUMPTIONS`.",
    "created_at": "2018-12-11T10:08:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373621",
    "user": "@jdemeyer"
}
```

Replying to [comment:22 nbruin]:
> That's why order matters. Apparently you are assuming that all "reachable" trees are visited before other links are examined.

Yes, and this is how the Python GC works. Admittedly, it's an assumption, but it's an assumption which is currently valid.

> In principle, you could decide that a cycle is unreachable by checking that all the reference counts can be accounted for by internal links.

Yes, and this is part of what Python's GC does: it uses refcounts to determine which objects are certainly reachable and which are potentially unreachable. It then recursively checks all links from reachable objects to determine which potentially unreachable objects are reachable anyway.

So in your example (assuming that `ROOT` is not tracked by GC), `A` will be certainly reachable and all other objects will start out potentially unreachable.

> I think you are also assuming is that the "VISIT" callback will be identical within an entire GC operation.

No, a single GC operation involves two traverse loops with two distinct VISIT values (one to count references and one to check potentially unreachable objects).

> These assumptions should all be made explicit and corroborated if possible.

I think I'm doing that in the documentation, in the section starting with `ASSUMPTIONS`.



---

archive/issue_comments_373622.json:
```json
{
    "body": "Replying to [comment:23 jdemeyer]:\n> Replying to [comment:22 nbruin]:\n> > That's why order matters. Apparently you are assuming that all \"reachable\" trees are visited before other links are examined.\n> \n> Yes, and this is how the Python GC works. Admittedly, it's an assumption, but it's an assumption which is currently valid.\n> \n> > In principle, you could decide that a cycle is unreachable by checking that all the reference counts can be accounted for by internal links.\n> \n> Yes, and this is part of what Python's GC does: it uses refcounts to determine which objects are certainly reachable and which are potentially unreachable. It then recursively checks all links from reachable objects to determine which potentially unreachable objects are reachable anyway.\n> \n> So in your example (assuming that `ROOT` is not tracked by GC), `A` will be certainly reachable and all other objects will start out potentially unreachable.\n> \n> > I think you are also assuming is that the \"VISIT\" callback will be identical within an entire GC operation.\n> \n> No, a single GC operation involves two traverse loops with two distinct VISIT values (one to count references and one to check potentially unreachable objects).\n> \n> > These assumptions should all be made explicit and corroborated if possible.\n> \n> I think I'm doing that in the documentation, in the section starting with `ASSUMPTIONS`.\n\nYes, although here already you are giving more information. Since these things are so sensitive, I think it would be good to include explicit references to the python source and udate your comments with the details about VISIT.\n\nOne of my main concerns is really the cost of fundamentally changing the rules of how references prevent garbage collection. For instance, at the moment gc.get_referrers and/or objgraph allow us to see if an object is prevented from being garbage collected. I think with the change here, this would fundamentally change. That's why I would urge you to only consider including this construct if you have established it gives significant benefits that are otherwise impossible or very difficult to effect. With MultiRef, the sage architecture would be even less like standard python.",
    "created_at": "2018-12-11T21:01:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26574",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26574#issuecomment-373622",
    "user": "@nbruin"
}
```

Replying to [comment:23 jdemeyer]:
> Replying to [comment:22 nbruin]:
> > That's why order matters. Apparently you are assuming that all "reachable" trees are visited before other links are examined.
> 
> Yes, and this is how the Python GC works. Admittedly, it's an assumption, but it's an assumption which is currently valid.
> 
> > In principle, you could decide that a cycle is unreachable by checking that all the reference counts can be accounted for by internal links.
> 
> Yes, and this is part of what Python's GC does: it uses refcounts to determine which objects are certainly reachable and which are potentially unreachable. It then recursively checks all links from reachable objects to determine which potentially unreachable objects are reachable anyway.
> 
> So in your example (assuming that `ROOT` is not tracked by GC), `A` will be certainly reachable and all other objects will start out potentially unreachable.
> 
> > I think you are also assuming is that the "VISIT" callback will be identical within an entire GC operation.
> 
> No, a single GC operation involves two traverse loops with two distinct VISIT values (one to count references and one to check potentially unreachable objects).
> 
> > These assumptions should all be made explicit and corroborated if possible.
> 
> I think I'm doing that in the documentation, in the section starting with `ASSUMPTIONS`.

Yes, although here already you are giving more information. Since these things are so sensitive, I think it would be good to include explicit references to the python source and udate your comments with the details about VISIT.

One of my main concerns is really the cost of fundamentally changing the rules of how references prevent garbage collection. For instance, at the moment gc.get_referrers and/or objgraph allow us to see if an object is prevented from being garbage collected. I think with the change here, this would fundamentally change. That's why I would urge you to only consider including this construct if you have established it gives significant benefits that are otherwise impossible or very difficult to effect. With MultiRef, the sage architecture would be even less like standard python.
