# Issue 17294: allow algorithm keyword when _call_()ing BuiltinFunction

Issue created by migration from https://trac.sagemath.org/ticket/17531

Original creator: rws

Original creation time: 2014-12-20 14:31:03

CC:  jdemeyer

Keywords: symbolic functions

As per http://trac.sagemath.org/ticket/17489#comment:17 and http://trac.sagemath.org/ticket/17489#comment:23, the ticket should improve the `BuiltinFunction` class, such that subclassed function classes that have an `algorithm=...` keyword given via function call will automatically have this keyword inserted into any `__evalf__` member function call.

This means the following should be possible without changes to `Function.__call__`:

```
sage: from sage.symbolic.function import BuiltinFunction                               
sage: class MyFunction(BuiltinFunction):                               
    def evalf(self, *args, **kwds):                                                    
        algorithm = kwds.get('algorithm', 'algoA')
        if algorithm == 'algoA':
            return 1
        else:
            return 0
....:         
sage: f = MyFunction
sage: f(x)
1
sage: f(x, algorithm='algoB')
0
```

At the moment, as with all(?) symbolic functions we get

```
sage: f(x, algorithm='algoB')
TypeError: __init__() got an unexpected keyword argument 'algorithm'
sage: sin(x, algorithm='algoB')
TypeError: __call__() got an unexpected keyword argument 'algorithm'
```

So the ticket should also give a better error message for existing functions.


---

Comment by rws created at 2014-12-20 14:39:14

Is there something missing in the example?

```
sage: f(x)
Traceback (most recent call last):
  File "<ipython-input-10-963bfc488912>", line 1, in <module>
    f(x)
  File "sage/symbolic/function.pyx", line 942, in sage.symbolic.function.BuiltinFunction.__init__ (build/cythonized/sage/symbolic/function.cpp:9902)
    Function.__init__(self, name, nargs, latex_name, conversions,
  File "sage/symbolic/function.pyx", line 110, in sage.symbolic.function.Function.__init__ (build/cythonized/sage/symbolic/function.cpp:3655)
    if not self._is_registered():
  File "sage/symbolic/function.pyx", line 1042, in sage.symbolic.function.BuiltinFunction._is_registered (build/cythonized/sage/symbolic/function.cpp:10966)
    try:
TypeError: expected string or Unicode object, sage.symbolic.expression.Expression found
```



---

Comment by jdemeyer created at 2014-12-20 15:10:52


```
f = MyFunction()
```

instead of

```
f = MyFunction
```


Also, `__evalf__` should be `_evalf_`.


---

Comment by rws created at 2014-12-21 14:24:41

Isn't this a bug? Hold as no effect:

```
sage: from sage.symbolic.function import BuiltinFunction
sage: class MyFunction(BuiltinFunction):
....:    def __init__(self, name):
....:        BuiltinFunction.__init__(self, name, nargs=1)
....:    def _evalf_(self, x, parent=None, algorithm=None):
....:        print algorithm
....:        return x
sage: f = MyFunction('f')
sage: ex = f(0.0, algorithm='algoA', hold=True); ex
algoA
0.000000000000000

sage: sin(0.0, hold=True)
sin(0.000000000000000)
```



---

Comment by rws created at 2014-12-22 09:19:11

New commits:


---

Comment by rws created at 2014-12-22 09:25:29

Changing status from new to needs_review.


---

Comment by rws created at 2014-12-22 09:25:29

This means that any function now accepts the `algorithm` keyword which is better than any error message IMHO.

```
sage: sin(x, algorithm='algoB')
sin(x)
```



---

Comment by rws created at 2014-12-22 17:05:25

Replying to [comment:5 rws]:
> Isn't this a bug? Hold as no effect:
I'll include a fix for this in #17489.


---

Comment by kcrisman created at 2014-12-22 20:55:34


```
sage: sin(x, algorithm='algoB')
sin(x)
```

General Sage behavior is to raise some sort of not implemented error or something "unknown algorithm" - we do this in a number of contexts.


---

Comment by rws created at 2014-12-23 07:26:11

Replying to [comment:11 kcrisman]:
> {{{
> sage: sin(x, algorithm='algoB')
> sin(x)
> }}}
> General Sage behavior is to raise some sort of not implemented error or something "unknown algorithm" - we do this in a number of contexts.
Actually, the `sin` function has no behaviour specified for the `algorithm` keyword and so, the outcome is undefined, meaning it could be either way. Certainly no such convention exists in the documentation. Pragmatically, it would be overkill to implement an algorithm registry for this reason.


---

Comment by kcrisman created at 2014-12-24 02:01:50

Well, right, in this case it should just say "undefined keyword" or something!


---

Comment by rws created at 2014-12-25 07:51:07

Replying to [comment:13 kcrisman]:
> Well, right, in this case it should just say "undefined keyword" or something!
If you so insist, please help with the following design decision. We could
 * A) add a dictionary to the base class (`Function`) containing names of algorithms. The user (who writes subclasses of `Function`) may register names through subclass initialization. Unregistered names given in a `__call__` argument result in error.
 * B) make available the algorithm keyword only in a specific subclass of `Function`. The user would inherit from this subclass. Other existing classes retain their previous behaviour. The user is responsible to give an error in his class for unknown algorithms.
 * C) disallow the algorithm keyword completely from any `__call__` method of `Function` or its subclasses. This means that the end user cannot say `factorial(10^6, algorithm=...)` but should be able to say `f(10^6, hold=True).n(algorithm=...)`. The function creator is responsible to give an error in his class for unknown algorithms.

Granted, C does make some sense in that all numeric issues are moved into `_evalf_`, and it works around shortfalls of A or B. But the end user will hate it. With A, there is additional code (clutter) in `Function` and the subclass must register its algorithm names. With B, it's not a general `Function`-wide solution.

EDIT: C does not make sense with functions returning int or polynomials and having different algorithms, unless the meaning of `f` in `evalf` or 'numerical approximation' is stretched beyond repair.

See also #15200 where Jeroen argues for hardcoding a few backend choices.

#17489 depends on this.


---

Comment by rws created at 2015-02-02 17:23:14

> EDIT: C does not make sense with functions returning int or polynomials and having different algorithms, unless the meaning of `f` in `evalf` or 'numerical approximation' is stretched beyond repair.
Nevertheless, C seems best.


---

Comment by kcrisman created at 2015-02-03 03:37:49

> If you so insist, please help with the following design decision.

Hmm.  I do kind of like A), actually.  We already have the dictionary of conversions to other systems (Maxima, Mma, etc.), right?  This seems very analogous.  But it sounds like you have some concrete examples of some shortcomings.  I do agree that the end user might not like C).


---

Comment by kcrisman created at 2015-02-03 03:46:10

Though maybe if all our other functions have C), as a little browsing suggests, maybe it is okay.  For instance, in #17489 I'm not sure Jeroen is suggesting we _must_ do this, just that it should be consistent.


---

Comment by jdemeyer created at 2015-02-04 16:28:31

I would propose D:

D) accept any `algorithm` in `__call__`, pass `algorithm` to `_evalf_` (and possibly other methods) and do error handling "downstream". For example, the end of `Function.__call__` uses Ginac, so there you could add

```
if algorithm is not None and algorithm != "ginac":
    raise ValueError("unknown algorithm %r for %s"%(algorithm,self))
```



---

Comment by rws created at 2015-02-05 09:34:45

Ah OK. This can go into `GinacFunction.__call__`. Maybe I did not consider this solution because `factorial`, which needs to inherit from `GinacFunction` (because of #17547), needs the `algorithm` keyword. But this can be easily and naturally resolved by providing `IntegerGinacFunction` in #17489 with its own `__call__`.


---

Comment by git created at 2015-02-05 09:36:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-02-05 09:50:25

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2015-02-05 09:50:25

I really don't like this:

```
self._algorithm = algorithm
```



---

Comment by jdemeyer created at 2015-02-05 09:52:20

I would put this

```
algorithm = kwds.get('algorithm')
if algorithm is not None and algorithm != "ginac":
    raise ValueError("unknown algorithm %r for %s"%(algorithm,self))
```

right before calling Ginac (towards the end of `Function.__call__`).


---

Comment by rws created at 2015-02-05 10:10:39

Replying to [comment:22 jdemeyer]:
> I would put this
> {{{
> algorithm = kwds.get('algorithm')
> if algorithm is not None and algorithm != "ginac":
>     raise ValueError("unknown algorithm %r for %s"%(algorithm,self))
> }}}
> right before calling Ginac (towards the end of `Function.__call__`).
But when you do `sin(x,algorithm='foo')` the `Function.__call__` doesn't even get called (EDIT: because `BuiltinFunction.__call__` doesn't call super) so no error is thrown.


---

Comment by git created at 2015-02-05 14:07:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-02-05 14:09:19

Replying to [comment:21 jdemeyer]:
> I really don't like this:
> {{{
> self._algorithm = algorithm
> }}}
Indeed, I don't need a class field for this, thanks for the hint. I don't see a better solution for the other issue mentioned, however.


---

Comment by rws created at 2015-02-09 06:33:31

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2015-02-13 09:49:13

Replying to [comment:23 rws]:
> But when you do `sin(x,algorithm='foo')` the `Function.__call__` doesn't even get called (EDIT: because `BuiltinFunction.__call__` doesn't call super) so no error is thrown.

In any case, the place where the exception is raised now isn't correct.


---

Comment by jdemeyer created at 2015-02-13 09:49:13

Changing status from needs_review to needs_work.


---

Comment by rws created at 2015-02-14 08:13:27

Replying to [comment:27 jdemeyer]:
> In any case, the place where the exception is raised now isn't correct.
Please be more verbose. It concerns `GinacFunction`s so I think it's placed right, and it obviously works. So I'm probably missing something that you know, and I don't want to fiddle with your `BuiltinFunction` code.


---

Comment by rws created at 2015-04-12 14:54:46

Changing status from needs_work to needs_info.


---

Comment by rws created at 2015-04-12 15:08:16

#16812 depends on this.


---

Comment by git created at 2015-06-18 08:40:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-06-18 08:41:32

Let's recap. What I missed is that while `sin(x)` and `sin(1.1)` do not call `Function.__call__` `sin(0)` does. Regarding `sin(1.1)` `BuiltinFunction::__call__` calls `sage.rings.real_mpfr.RealLiteral.sin` directly so any check for 'ginac' would be nonsense. Should we check for any other algorithm keyword there?


---

Comment by rws created at 2015-06-18 08:41:32

Changing status from needs_info to needs_review.


---

Comment by rws created at 2015-10-20 12:54:34

Ping?


---

Comment by rws created at 2016-08-05 07:51:01

Seems the recent `gamma_inc` changes trigger test failures.
----
New commits:


---

Comment by rws created at 2016-08-05 07:51:01

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-09-22 08:08:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-09-22 08:09:10


```
**********************************************************************
File "src/sage/functions/other.py", line 1020, in sage.functions.other.Function_gamma_inc.__init__
Failed example:
    gamma_inc(CDF(0,1), 3)
Expected:
    0.0032085749933691158 + 0.012406185811871568*I
Got:
    0.003208574993369116 + 0.012406185811871567*I
**********************************************************************
File "src/sage/functions/other.py", line 1117, in sage.functions.other.Function_gamma_inc._evalf_
Failed example:
    gamma_inc(float(-1), float(-1))
Expected:
    (-0.8231640121031085+3.141592653589793j)
Got:
    (-0.8231640121031085-3.141592653589793j)
**********************************************************************
File "src/sage/functions/other.py", line 1119, in sage.functions.other.Function_gamma_inc._evalf_
Failed example:
    gamma_inc(RR(-1), RR(-1))
Expected:
    -0.823164012103109 + 3.14159265358979*I
Got:
    -0.823164012103109 - 3.14159265358979*I
**********************************************************************
File "src/sage/functions/other.py", line 1126, in sage.functions.other.Function_gamma_inc._evalf_
Failed example:
    r = gamma_inc(float(0), float(1)); r
Expected:
    0.21938393439552029
Got:
    0.21938393439552026
```



---

Comment by git created at 2016-09-22 08:24:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-09-22 08:25:41

Changing status from needs_work to needs_review.


---

Comment by rws created at 2018-03-03 16:15:43

I'll close this as wontfix, my argument is in #17489#comment:48


---

Comment by rws created at 2018-03-03 16:15:43

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2018-05-18 17:16:26

closing positively reviewed duplicates


---

Comment by vdelecroix created at 2018-05-18 17:16:26

Resolution: wontfix
