# Issue 24962: Dictionary substitutions don't work over Frac(QQbar[x,y])

Issue created by migration from https://trac.sagemath.org/ticket/25199

Original creator: @BrentBaccala

Original creation time: 2018-04-17 22:17:14

CC:  vdelecroix cheuberg behackl dkrenn

Keywords: QQbar, subs


```
sage: R.<x,y> = QQbar[]
sage: (1/y).subs({y: 2})
1/y
```


The problem is that the hashes don't match up between the polynomial ring and its fraction field:


```
sage: hash(y) == hash(Frac(R)(y))
False
```


From [src/sage/rings/fraction_field_element.pyx`@`8.1:316-318](../tree/master/src/sage/rings/fraction_field_element.pyx`@`8.1:316-318)

 This function hashes in a special way to ensure that generators of
 a ring `R` and generators of a fraction field of `R` have the same
 hash. This enables them to be used as keys interchangeably in a
 dictionary (since ``==`` will claim them equal). This is particularly
 useful for methods like ``subs`` on ``ParentWithGens`` if you are
 passing a dictionary of substitutions.

The reason that it's not working right is that the hashing code in fraction_field_element.pyx assumes that hash(1) == 1, and that's not true in QQbar:


```
sage: hash(QQbar(1))
-3730706066237751940
```




---

Comment by @BrentBaccala created at 2018-04-17 22:28:31

New commits:


---

Comment by @BrentBaccala created at 2018-04-17 22:28:31

Changing status from new to needs_review.


---

Comment by @BrentBaccala created at 2018-04-17 22:31:51

The patch changes QQbar's hash function so that rational numbers always hash the same way.


---

Comment by dkrenn created at 2018-04-18 07:17:45

Replying to [ticket:25199 gh-BrentBaccala]:
> The reason that it's not working right is that the hashing code in fraction_field_element.pyx assumes that hash(1) == 1

This sounds strange; why should any code assume that `hash(1) == 1`?


---

Comment by tscrim created at 2018-04-18 07:20:24

I think what is being referred to is substitution does something like a comparison by dicts:

```sage
sage: d1 = {ZZ(1): 1}
sage: d2 = {QQbar(1): 1}
sage: d1 == d2
False
sage: d3 = {QQ(1): 1}
sage: d1 == d3
True
```

The `d1 == d2` uses a hash comparison before an equality comparison:

```sage
sage: hash(QQbar(1)) == hash(ZZ(1))
False
sage: QQbar(1) == ZZ(1)
True
```



---

Comment by @BrentBaccala created at 2018-04-18 17:25:38

Didn't think that patch would break so many tests...

> This sounds strange; why should any code assume that hash(1) == 1?

Yet the fraction field hashing code does make that assumption.  If we're going to keep it that way, perhaps this assumption needs to be more clearly documented.  QQbar might not be the only place that has problems with this.


---

Comment by @BrentBaccala created at 2018-04-18 17:25:38

Changing status from needs_review to needs_work.


---

Comment by @BrentBaccala created at 2018-04-18 19:45:45

The problem with the patch that I submitted yesterday is that it can cause the hash value to change when an element is exactified, and there seems to be another assumption that an element's hash value never changes.  Fixing this so that hash(one) == hash(1), no matter how 'one' was constructed, would require exactifying 'one' whenever we hash it.  The most consistent action would be to exactify anything whenever we hash it, to see if it's rational.  The current QQbar hash code goes out of its way to avoid this, though the comments state:

  All of this effort to avoid exact computation is probably wasted, anyway... in almost all uses of hash codes, if the hash codes
  match, the next step is to compare for equality; and comparing
  for equality often requires exact computation

So we could drop this logic, and exactify every time we hash.

I'm also thinking of another way to fix this - patch the fraction field code to check the denominator with is_one, rather than just checking to see if the denominator hashes to 1.  Then we no longer assume that hash(1) == 1, but is_one() might be slower than hash().

Comments?


---

Comment by git created at 2018-04-20 03:54:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-04-20 19:48:28

Changing status from needs_work to needs_review.


---

Comment by @BrentBaccala created at 2018-12-10 04:51:03

Fixed by #16268


---

Comment by dkrenn created at 2018-12-10 09:14:36

Replying to [comment:10 gh-BrentBaccala]:
> Fixed by #16268

Ok. Is there a doctest covering the issue of this ticket?


---

Comment by dkrenn created at 2018-12-10 09:15:04

Changing status from needs_review to needs_info.


---

Comment by @BrentBaccala created at 2018-12-14 01:02:18

Replying to [comment:11 dkrenn]:
> Ok. Is there a doctest covering the issue of this ticket?

There's an existing doctest in `FractionFieldElement`'s `__hash__` method (lines 360-364 in Sage 8.4) that checks similar behavior:



```
sage: R.<x,y,z>=QQ[]
sage: hash(R.0)==hash(FractionField(R).0)
True
sage: ((x+1)/(x^2+1)).subs({x:1})
1
```


However, this test is over `QQ`, not `QQbar`, and I've verified that it passed on Sage 7.5.1, while the test in the description of this ticket did not.

So, I suggest adding an additional test over `QQbar` below the existing one in `FractionFieldElement` `__hash__`.

I switched this ticket to a new branch with just that doctest on it.


---

Comment by @BrentBaccala created at 2018-12-14 01:02:18

Changing priority from major to trivial.


---

Comment by @BrentBaccala created at 2018-12-14 01:02:18

Changing status from needs_info to needs_review.


---

Comment by dkrenn created at 2018-12-14 08:20:56

Changing status from needs_review to positive_review.


---

Comment by dkrenn created at 2018-12-14 08:20:56

LGTM, thanks.


---

Comment by vbraun created at 2018-12-23 23:39:08

Resolution: fixed


---

Comment by embray created at 2018-12-28 14:06:38

This tickets were closed as fixed after the Sage 8.5 release.
