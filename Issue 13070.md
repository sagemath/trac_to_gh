# Issue 13070: Determine if an edge in a graph is a cut-edge (bridge)

Issue created by migration from https://trac.sagemath.org/ticket/13242

Original creator: lkeough

Original creation time: 2012-07-12 19:36:00

Assignee: jason, ncohen, rlm

CC:  jeremy.l.martin ncohen dcoudert

Keywords: days40

is_cut_edge is needed to compute the Tutte polynomial (#1314)


---

Comment by lkeough created at 2012-07-12 19:37:23

I looked for cut-edge/bridge/isthmus in Sage and in trac tickets, but didn't find anything.  Let me know if you see anything though!


---

Comment by lkeough created at 2012-07-12 20:44:08

Apply only trac_13242.patch


---

Comment by lkeough created at 2012-07-12 20:56:15

Changing status from new to needs_review.


---

Comment by dcoudert created at 2012-07-13 10:42:27

Since this function is working for undirected graphs only, it should not be in generic_graph.py.

The following function should be way faster and avoids a copy of the graph.

```
def is_edge_cut(self,e):
    if not self.has_edge(e):
        raise ValueError, 'edge not in graph' 

    eu = e[0]
    ev = e[1]

    visited = dict([(u,False) for u in self.vertex_iterator()])
    visited[eu] = True
    s = set(self.neighbors(eu))
    s.remove(ev)
    while (len(s) > 0) and not visited[ev]:
        w = s.pop()
        visited[w] = True
        for x in self.neighbor_iterator(w):
            if not visited[x]:
                s.add(x)

    return (not visited[ev]) and (self.degree(ev)>1)
```



---

Comment by dcoudert created at 2012-07-13 10:42:27

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2012-07-13 10:44:16

Above code should be improved to cope with multiple edges.


---

Comment by lkeough created at 2012-07-13 12:09:01

Thanks, I will move this to graph.py if that is the correct place?

I tried this code for K_3 with a leaf (G = Graph([[0,1],[0,2],[1,2],[0,3]]) ) and if I ask if the leaf is a cut-edge it returns False, but it should be True.  I haven't been able to figure out why this isn't working - any ideas?  It seems to work with the slower code.


---

Comment by dcoudert created at 2012-07-13 12:40:55

Replying to [comment:7 lkeough]:
> Thanks, I will move this to graph.py if that is the correct place?

Well, you can let it in generic_graph since it has also some interest for connectivity in digraphs. 

> I tried this code for K_3 with a leaf (G = Graph([[0,1],[0,2],[1,2],[0,3]]) ) and if I ask if the leaf is a cut-edge it returns False, but it should be True.  I haven't been able to figure out why this isn't working - any ideas?  It seems to work with the slower code.

My fault (last test in the return). 
This new version is much better. It allows multiple formats of input, solves the pending edge problem, cope with multi-edges. It remains to add examples and tests.

```
def is_edge_cut(self, u, v=None, label=None):
    """
    Returns True if (u,v) is a cut edge, False otherwise.

    INPUT: The following forms are accepted

    - G.is_edge_cut( 1, 2 )

    - G.is_edge_cut( (1, 2) )

    - G.is_edge_cut( 1, 2, 'label' )

    - G.is_edge_cut( (1, 2, 'label') )

 
    """
    if label is None:
        if v is None:
            try:
                u, v, label = u
            except:
                u, v = u
                label = None

    if not self.has_edge(u,v):
        raise ValueError, 'edge not in graph' 

    # If edge (u,v) is a pending edge, it is also a cut edge
    if self.degree(u) == 1 or self.degree(v) == 1:
        return True
    elif self.allows_multiple_edges():
        # If we have two or more edges between u and v, it is not a cut edge
        if len([(uu,vv) for uu,vv,ll in self.edges_incident(u) if uu == v or vv == v]) > 1:
            return False

    # We search for a path from u to v not using edge (u,v). If no such path is
    # found, edge (u,v) is a cut edge
    visited = dict([(uu,False) for uu in self.vertex_iterator()])
    visited[u] = True
    s = set(self.neighbors(u))
    s.remove(v)
    while (len(s) > 0) and not visited[v]:
        w = s.pop()
        visited[w] = True
        for x in self.neighbor_iterator(w):
            if not visited[x]:
                s.add(x)

    return not visited[v]
```


Last, I don't know if the function should be named is_edge_cut or is_cut_edge


---

Comment by lkeough created at 2012-07-13 13:42:43

Replying to [comment:8 dcoudert]:
> Replying to [comment:7 lkeough]:
> > Thanks, I will move this to graph.py if that is the correct place?
> 
> Well, you can let it in generic_graph since it has also some interest for connectivity in digraphs. 
Sounds good, I do believe your code works on digraphs as well.
> 
> > I tried this code for K_3 with a leaf (G = Graph([[0,1],[0,2],[1,2],[0,3]]) ) and if I ask if the leaf is a cut-edge it returns False, but it should be True.  I haven't been able to figure out why this isn't working - any ideas?  It seems to work with the slower code.
> 
> My fault (last test in the return). 
> This new version is much better. It allows multiple formats of input, solves the pending edge problem, cope with multi-edges. It remains to add examples and tests.

Thanks!  I'm new to Sage developing so this might take me a bit, but I'll work on it today.

> {{{
> def is_edge_cut(self, u, v=None, label=None):
>     """
>     Returns True if (u,v) is a cut edge, False otherwise.
> 
>     INPUT: The following forms are accepted
> 
>     - G.is_edge_cut( 1, 2 )
> 
>     - G.is_edge_cut( (1, 2) )
> 
>     - G.is_edge_cut( 1, 2, 'label' )
> 
>     - G.is_edge_cut( (1, 2, 'label') )
> 
>  
>     """
>     if label is None:
>         if v is None:
>             try:
>                 u, v, label = u
>             except:
>                 u, v = u
>                 label = None
> 
>     if not self.has_edge(u,v):
>         raise ValueError, 'edge not in graph' 
> 
>     # If edge (u,v) is a pending edge, it is also a cut edge
>     if self.degree(u) == 1 or self.degree(v) == 1:
>         return True
>     elif self.allows_multiple_edges():
>         # If we have two or more edges between u and v, it is not a cut edge
>         if len([(uu,vv) for uu,vv,ll in self.edges_incident(u) if uu == v or vv == v]) > 1:
>             return False
> 
>     # We search for a path from u to v not using edge (u,v). If no such path is
>     # found, edge (u,v) is a cut edge
>     visited = dict([(uu,False) for uu in self.vertex_iterator()])
>     visited[u] = True
>     s = set(self.neighbors(u))
>     s.remove(v)
>     while (len(s) > 0) and not visited[v]:
>         w = s.pop()
>         visited[w] = True
>         for x in self.neighbor_iterator(w):
>             if not visited[x]:
>                 s.add(x)
> 
>     return not visited[v]
> }}}
> 
> Last, I don't know if the function should be named is_edge_cut or is_cut_edge

I've always referred to this as either cut-edge or bridge (and it seems Wikipedia does too, for what that is worth).


---

Comment by lkeough created at 2012-07-13 14:42:56

Changing status from needs_work to needs_review.


---

Comment by jeremy.l.martin created at 2012-07-13 14:45:06

I believe it should be called is_cut_edge, as "edge cut" means a *set* of edges whose deletion disconnects the graph.


---

Comment by dcoudert created at 2012-07-13 15:19:52

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2012-07-13 15:19:52

Install OK, long tests OK, functionality OK.

However I'm unable to test docbuild (working remote today), and I saw a small alignment problem line 4024.

Also, I'm not sure of the behavior of 'EXAMPLES' versus 'TESTS'. Are examples also considered as tests for 'sage -t'? Is anyone able to answer?


---

Comment by lkeough created at 2012-07-13 16:15:03

Replying to [comment:12 dcoudert]:
> Install OK, long tests OK, functionality OK.
> 
> However I'm unable to test docbuild (working remote today), and I saw a small alignment problem line 4024.
I tested docbuild and it looks fine.  Is your issue at 4024 that """ should be 4 spaces back.  I fixed that and uploaded again.
> 
> Also, I'm not sure of the behavior of 'EXAMPLES' versus 'TESTS'. Are examples also considered as tests for 'sage -t'? Is anyone able to answer?
I'm at Sage Days 40 and was told that examples are tested, but are different from tests in that they show up if the user asks for documentation.


---

Comment by dcoudert created at 2012-07-13 16:23:56

For me the patch is now OK so I give positive review.

Enjoy the Sage Days.


---

Comment by dcoudert created at 2012-07-13 16:23:56

Changing status from needs_work to positive_review.


---

Comment by dcoudert created at 2012-07-14 11:55:51

Hello,

I had some discussions with Nathann, and he said that the following should be faster:

```
    self.delete_edge(u,v,label)
    ans = self.distance(u,v) < self.order()
    self.add_edge(u,v,label)
    return ans
```


I tried it on large graphs and it is definitively faster (10x to 100x). It is in fact the same algorithm behind, but the distance function is in cython, so it's fast.

Sorry for the extra work, but it would be better to replace the lines from *# We search for a path from* till the end with above code.


---

Comment by dcoudert created at 2012-07-14 11:55:51

Changing status from positive_review to needs_work.


---

Comment by lkeough created at 2012-07-14 14:59:24

Faster is certainly better so I don't mind.  When I replace this and run the tests it fails the very first example - if an edge in K_4 is a cut edge.  I messed around in the Sage notebook and it also seems to be a problem there.  The algorithm is correct so I'm probably just implementing this wrong.  All I did was replace the lines  after #We search for a path..


---

Comment by lkeough created at 2012-07-14 15:22:23

Replying to [comment:16 lkeough]:
> Faster is certainly better so I don't mind.  When I replace this and run the tests it fails the very first example - if an edge in K_4 is a cut edge.  I messed around in the Sage notebook and it also seems to be a problem there.  The algorithm is correct so I'm probably just implementing this wrong.  All I did was replace the lines  after #We search for a path..

I see now..we want return not ans.  Because if self.distance(u,v) < self.order()  then (u,v) is not a cut-edge.


---

Comment by lkeough created at 2012-07-14 15:46:24

This no longer works for digraphs.  It returns that an edge in a directed cycle is a cut edge because if we remove that edge there is no _directed_ path between those two vertices.  There is a connected_components_number function for digraphs, but comparing connected_components_number(G) and connected_components_number(G-e) is probably not the fastest way to make it work for digraphs.


---

Comment by dcoudert created at 2012-07-14 18:31:06

Another option is:

```
    self.delete_edge(u,v,label)
    if self.is_directed():
        ans = self.is_connected()
    else:
        ans = self.distance(u,v) < self.order()
    self.add_edge(u,v,label)
    return not ans
```


the self.is_connected() function would be sufficient, but the distance function is faster for undirected graphs.

Don't forget to explain the behavior for directed graphs in the description of the function.


---

Comment by lkeough created at 2012-07-15 00:58:03

I need connected_components_number since an edge is a cut-edge if it increases the number of connected components. So you may be trying to figure out if an edge in an already disconnected graph is a cut edge.  I used this:

```  
if self.is_directed():
            H = self.copy()
            H.delete_edge(u,v,label)
            sol = self.connected_components_number() == H.connected_components_number()
            return not sol
```


I ran tests and built the documentation and it looks fine.  I'm going to upload a new patch, but I'm willing to change it if this is a terrible algorithm.


---

Comment by dcoudert created at 2012-07-15 09:48:48

Apparently you did something wrong when updating the patch. It contains only parts of the function (last modifications).

Your proposition for directed graphs can be improved because you don't need to copy the graph. It is sufficient to remove edge (u,v), and to later restore it. For instance, you can do:

```
self.delete_edge(u,v,label)
if self.is_directed():
    # (u,v) is a cut edge if u is not in the connected component 
    # containing v of self-(u,v), 
    sol = not u in self.connected_component_containing_vertex(v)
else:
    # (u,v) is a cut edge if there is no path from u to v in self-(u,v) 
    sol = not self.distance(u,v) < self.order()

self.add_edge(u,v,label)
return sol
```

In fact, the connected_components_number function uses the connected_component_containing_vertex function. So it is easier that way.


---

Comment by lkeough created at 2012-07-15 16:38:30

Use this one.


---

Attachment

I think I fixed the patch updating problem and used your code for the directed graph.


---

Attachment


---

Comment by dcoudert created at 2012-07-15 18:02:23

I did some minor edit (removal of useless spaces, alignments, etc.) in the complementary patch trac_13242-rev.patch (you have to apply both files).

If it is OK for you, I will give a positive review to this patch. For me everything is fine (install, tests, docbuild, functionality, etc.).


---

Comment by dcoudert created at 2012-07-15 18:03:03

Changing status from needs_work to needs_review.


---

Comment by lkeough created at 2012-07-15 19:03:10

All these things worked for me as well.

Thanks for all of your help!


---

Comment by dcoudert created at 2012-07-16 06:12:50

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2012-07-27 20:47:22

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2012-07-27 20:47:22

[attachment:trac_13242.patch] needs a proper commit message.


---

Comment by jdemeyer created at 2012-08-01 12:16:52

Changing status from needs_work to positive_review.


---

Attachment

Fixed myself (and put both patches together).


---

Comment by lkeough created at 2012-08-01 16:37:57

Sorry, had been away from a computer for a few days.  Thank you for fixing this!


---

Comment by jdemeyer created at 2012-08-12 19:01:15

Resolution: fixed
