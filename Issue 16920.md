# Issue 16920: Cleanup formula for Bell numbers

Issue created by migration from https://trac.sagemath.org/ticket/17157

Original creator: jdemeyer

Original creation time: 2014-10-15 08:35:38

In the function `bell_number`, we have the line

```
return ZZ(ceil(N((b - n) / n2 * exp2(Integer(-1)) - 1 / 4, log(b, 2) + 3)))
```


This can be improved by
1. Removing the `1 / 4` which is actually `0` in Python 2.
2. Not using global functions like `ceil()` and `exp()`.
3. Using a `RealField` instead of the `N()` function.


---

Comment by jdemeyer created at 2014-10-15 21:56:27

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2014-10-15 22:03:45

New commits:


---

Comment by fredrik.johansson created at 2014-10-16 13:30:12

You might also consider wrapping flint's arith_bell_number. On this computer it seems to be about twice as fast as Sage's current bell_number(n, algorithm='dobinski') for n = 1000, 2000, 4000, 10000, 20000, 40000.


---

Comment by jdemeyer created at 2014-10-16 13:37:35

Replying to [comment:6 fredrik.johansson]:
> Sage's current bell_number(n, algorithm='dobinski')
With or without this patch?


---

Comment by jdemeyer created at 2014-10-16 13:43:52

Replying to [comment:6 fredrik.johansson]:
> You might also consider wrapping flint's arith_bell_number.
If I do so, will you review this ticket?


---

Comment by fredrik.johansson created at 2014-10-16 13:47:17

Replying to [comment:7 jdemeyer]:
> Replying to [comment:6 fredrik.johansson]:
> > Sage's current bell_number(n, algorithm='dobinski')
> With or without this patch?

Without. The difference is bigger for smaller n of course. Here is a more accurate comparison:

flint:

100  cpu/wall(s): 2.6e-05 2.68e-05
200  cpu/wall(s): 8.2e-05 8.57e-05
400  cpu/wall(s): 0.00039 0.000403
1000  cpu/wall(s): 0.004 0.00441
2000  cpu/wall(s): 0.023 0.026
4000  cpu/wall(s): 0.16 0.172
10000  cpu/wall(s): 0.91 0.949
20000  cpu/wall(s): 4.02 4.173
40000  cpu/wall(s): 18.12 21.109

sage (without patch):

100 5 loops, best of 3: 1.05 ms per loop
200 625 loops, best of 3: 1.52 ms per loop
400 125 loops, best of 3: 1.96 ms per loop
1000 125 loops, best of 3: 7.39 ms per loop
2000 5 loops, best of 3: 38 ms per loop
4000 5 loops, best of 3: 216 ms per loop
10000 5 loops, best of 3: 2.17 s per loop
20000 1 loops, best of 3: 13 s per loop
40000 1 loops, best of 3: 68 s per loop


---

Comment by fredrik.johansson created at 2014-10-16 14:09:15

You can just compute the sum in Dobinski's formula as an exact fraction (keeping the numerator and denominator separate, not actually dividing rational numbers by successive factorials). Indeed this is what flint does for n < 5000 (for larger n it uses a multimodular algorithm). This simplifies the error analysis.


---

Comment by fredrik.johansson created at 2014-10-16 14:28:32

Which reminds me that flint is missing two tricks: firstly, batch computing all the powers `1^n, 3^n, 5^n, ..., N^n` using sieving (one multiplication for every odd index, then one shift for every even index), and secondly, only working with approximate values of the powers near the end of that list.

The first trick would use much more memory, of course, but that's fine as one can fall back to the multimodular algorithm for very large n anyway.


---

Comment by git created at 2014-10-20 19:36:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-23 14:23:30

Replying to [comment:8 jdemeyer]:
> Replying to [comment:6 fredrik.johansson]:
> > You might also consider wrapping flint's arith_bell_number.
> If I do so, will you review this ticket?

I will review it if you do so. I'm for including access to multiple implementations.


---

Comment by git created at 2014-10-23 14:51:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-23 15:43:38

Waiting now for all my cython files to recompile.


---

Comment by tscrim created at 2014-10-23 16:32:46

Some timings:

```
sage: %timeit bell_number(200)
1000 loops, best of 3: 612 Âµs per loop
sage: %timeit bell_number(200, algorithm='dobinski')
100 loops, best of 3: 2.2 ms per loop
sage: %timeit bell_number(200, algorithm='gap')
1 loops, best of 3: 21 ms per loop
sage: %timeit bell_number(200, algorithm='mpmath')
10 loops, best of 3: 21.2 ms per loop

sage: %timeit bell_number(1000)
10 loops, best of 3: 40.1 ms per loop
sage: %timeit bell_number(1000, algorithm='dobinski')
10 loops, best of 3: 49.5 ms per loop
sage: %timeit bell_number(1000, algorithm='gap')
1 loops, best of 3: 1.58 s per loop
sage: %timeit bell_number(1000, algorithm='mpmath')
1 loops, best of 3: 737 ms per loop

sage: %timeit bell_number(10000, algorithm='flint')
1 loops, best of 3: 3.57 s per loop
sage: %timeit bell_number(10000, algorithm='dobinski')
1 loops, best of 3: 20 s per loop
```


So LGTM.


---

Comment by tscrim created at 2014-10-23 16:32:46

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-10-23 19:19:33

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2014-10-23 19:19:33

Conflicts with #15300 most likely


---

Comment by git created at 2014-10-23 19:27:06

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by jdemeyer created at 2014-10-23 19:27:54

Changing status from needs_work to positive_review.


---

Comment by jdemeyer created at 2014-10-23 19:27:54

Last 10 new commits:


---

Comment by vbraun created at 2014-10-24 18:05:57

Resolution: fixed
