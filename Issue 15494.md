# Issue 15494: Too early coercion causes weird behavior of comparison

archive/issues_015494.json:
```json
{
    "body": "CC:  nbruin jakobkroeker\n\nLet's say I want to create my own number objects and I want be able to compare my objects with regular number types.\n\n\n```python\nclass SpecialNumber():\n    def __init__(self, number):\n        self.number = number\n    def __lt__(self, other):\n        return self.number < other\n    def __gt__(self, other):\n        return self.number > other\n```\n\nWhen comparing an int and a SpecialNumber, and SpecialNumber is on the left, everything works well, because SpecialNumber's comparison operators are called. However, when the SpecialNumber is on the right, it fail, i.e.:\n\n\n```python\nsage: a = SpecialNumber(3)\nsage: a > 2\nTrue\nsage: 2 < a\nFalse\n```\n\n\nThe exact same code in pure python would return True, because there is no `__lt__` method to call on an int that works, so instead `a > 2` is tried which returns True.\n\nWhereas Sage, after not being able to call the `__lt__` method of the Integer object, tries coercion right away without trying to evaluate `a > 2`. Since there is no coercion, it checks if the types of the two objects are the same or something like that, and since not, it returns false. I think the right behavior would be check first if `a > 2` can be evaluated, and try to coerce only after that.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15731\n\n",
    "created_at": "2014-01-25T01:57:24Z",
    "labels": [
        "coercion",
        "minor",
        "bug"
    ],
    "title": "Too early coercion causes weird behavior of comparison",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15494",
    "user": "strenner"
}
```
CC:  nbruin jakobkroeker

Let's say I want to create my own number objects and I want be able to compare my objects with regular number types.


```python
class SpecialNumber():
    def __init__(self, number):
        self.number = number
    def __lt__(self, other):
        return self.number < other
    def __gt__(self, other):
        return self.number > other
```

When comparing an int and a SpecialNumber, and SpecialNumber is on the left, everything works well, because SpecialNumber's comparison operators are called. However, when the SpecialNumber is on the right, it fail, i.e.:


```python
sage: a = SpecialNumber(3)
sage: a > 2
True
sage: 2 < a
False
```


The exact same code in pure python would return True, because there is no `__lt__` method to call on an int that works, so instead `a > 2` is tried which returns True.

Whereas Sage, after not being able to call the `__lt__` method of the Integer object, tries coercion right away without trying to evaluate `a > 2`. Since there is no coercion, it checks if the types of the two objects are the same or something like that, and since not, it returns false. I think the right behavior would be check first if `a > 2` can be evaluated, and try to coerce only after that.

Issue created by migration from https://trac.sagemath.org/ticket/15731





---

archive/issue_comments_200200.json:
```json
{
    "body": "Changing priority from minor to major.",
    "created_at": "2014-01-25T01:59:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200200",
    "user": "strenner"
}
```

Changing priority from minor to major.



---

archive/issue_comments_200201.json:
```json
{
    "body": "How about `a<2`, `2<a` then? Do you want the same there? That would give an infinite recursion.\n\nIn python, the meaning of comparison is in the hands of the left hand side. In general, you shouldn't expect any consistency when applying comparisons between unrelated objects. If you want to cooperate with sage objects, you'll probably have to support coercion.",
    "created_at": "2014-01-25T05:59:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200201",
    "user": "nbruin"
}
```

How about `a<2`, `2<a` then? Do you want the same there? That would give an infinite recursion.

In python, the meaning of comparison is in the hands of the left hand side. In general, you shouldn't expect any consistency when applying comparisons between unrelated objects. If you want to cooperate with sage objects, you'll probably have to support coercion.



---

archive/issue_comments_200202.json:
```json
{
    "body": "Replying to [comment:2 nbruin]:\n> How about `a<2`, `2<a` then? Do you want the same there? That would give an infinite recursion.\n\nI am hoping that there exists an implementation that avoids infinite recursion.\n \n> In python, the meaning of comparison is in the hands of the left hand side. \n\nThis is not entirely true. From http://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror (the same thing works for other comparison operators):\n\n \"`NotImplemented` signals to the runtime that it should ask someone else to satisfy the operation. In the expression `a == b`, if `a.__eq__(b)` returns `NotImplemented`, then Python tries `b.__eq__(a)`. If b knows enough to return True or False, then the expression can succeed. If it doesn't, then the runtime will fall back to the built-in behavior (which is based on identity for == and !=).\"\n\nFor instance, if Sage could override this built-in behavior and try coercion instead, that would save us from infinite recursion.",
    "created_at": "2014-01-25T18:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200202",
    "user": "strenner"
}
```

Replying to [comment:2 nbruin]:
> How about `a<2`, `2<a` then? Do you want the same there? That would give an infinite recursion.

I am hoping that there exists an implementation that avoids infinite recursion.
 
> In python, the meaning of comparison is in the hands of the left hand side. 

This is not entirely true. From http://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror (the same thing works for other comparison operators):

 "`NotImplemented` signals to the runtime that it should ask someone else to satisfy the operation. In the expression `a == b`, if `a.__eq__(b)` returns `NotImplemented`, then Python tries `b.__eq__(a)`. If b knows enough to return True or False, then the expression can succeed. If it doesn't, then the runtime will fall back to the built-in behavior (which is based on identity for == and !=)."

For instance, if Sage could override this built-in behavior and try coercion instead, that would save us from infinite recursion.



---

archive/issue_comments_200203.json:
```json
{
    "body": "Replying to [comment:3 strenner]:\n\n> This is not entirely true. From http://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror (the same thing works for other comparison operators):\n\nI'm not sure it's entirely true; see [http://docs.python.org/2/reference/datamodel.html#object.__lt__](http://docs.python.org/2/reference/datamodel.html#object.__lt__) (the official documentation tends to be a little more authoritative than stackoverflow, and in the case of python, usually very clear too). Indeed, these methods can return to `NotImplemented`, but I think that leads python to try different variants, and never \"swapped\" (rather, it will try `__ge__` after `__lt__` has failed). The final showstopper is probably the older `__cmp__` protocol that predates python's \"rich\" comparisons and is actually what is used most throughout sage. I don't see a \"notImplemented\" escape documented for that. Normal python semantics seem to never swap LHS and RHS for comparison operators, contrasting what python specifies for `+` with `__add__` and `__radd__`\n\n> For instance, if Sage could override this built-in behavior and try coercion instead, that would save us from infinite recursion.",
    "created_at": "2014-01-25T18:34:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200203",
    "user": "nbruin"
}
```

Replying to [comment:3 strenner]:

> This is not entirely true. From http://stackoverflow.com/questions/878943/why-return-notimplemented-instead-of-raising-notimplementederror (the same thing works for other comparison operators):

I'm not sure it's entirely true; see [http://docs.python.org/2/reference/datamodel.html#object.__lt__](http://docs.python.org/2/reference/datamodel.html#object.__lt__) (the official documentation tends to be a little more authoritative than stackoverflow, and in the case of python, usually very clear too). Indeed, these methods can return to `NotImplemented`, but I think that leads python to try different variants, and never "swapped" (rather, it will try `__ge__` after `__lt__` has failed). The final showstopper is probably the older `__cmp__` protocol that predates python's "rich" comparisons and is actually what is used most throughout sage. I don't see a "notImplemented" escape documented for that. Normal python semantics seem to never swap LHS and RHS for comparison operators, contrasting what python specifies for `+` with `__add__` and `__radd__`

> For instance, if Sage could override this built-in behavior and try coercion instead, that would save us from infinite recursion.



---

archive/issue_comments_200204.json:
```json
{
    "body": "Well, I am not sure how it works either, but I did experiments in a python interpreter (with the `SpecialNumber` being defined as the original description), and I got this:\n\n\n```python: \n>>> a = SpecialNumber(3)\n>>> 4 < a\nFalse\n>>> 2 < a\nTrue\n```\n\n\nThe only way I can explain this behavior is the `SpecialNumber.__gt__` is called at some point.",
    "created_at": "2014-01-25T21:42:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200204",
    "user": "strenner"
}
```

Well, I am not sure how it works either, but I did experiments in a python interpreter (with the `SpecialNumber` being defined as the original description), and I got this:


```python: 
>>> a = SpecialNumber(3)
>>> 4 < a
False
>>> 2 < a
True
```


The only way I can explain this behavior is the `SpecialNumber.__gt__` is called at some point.



---

archive/issue_comments_200205.json:
```json
{
    "body": "Replying to [comment:5 strenner]:\n> The only way I can explain this behavior is the `SpecialNumber.__gt__` is called at some point.\nWhich you can confirm by inserting a print message in the relevant `__gt__`. It indeed seems that if, in evaluation of `a<b`, it happens that `a.__lt__(b)` returns `NotImplemented`, then the next thing tried is `b.__gt__(a)`. On second reading (or perhaps just correct reading) this *is* as documented:\n\n\"\"\"\nThere are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does); rather, __lt__() and __gt__() are each other\u2019s reflection, __le__() and __ge__() are each other\u2019s reflection, and __eq__() and __ne__() are their own reflection.\n\"\"\"\n\nSo indeed, if sage were a little more liberal in returning `NotImplemented` your approach could work.\n\nThe problem is that parts of sage are quite intent on having all objects comparable, meaning that the sage implementations try quite hard to return `True` or `False` rather than `NotImplemented`. So changing this will be pretty hard.",
    "created_at": "2014-01-26T04:25:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200205",
    "user": "nbruin"
}
```

Replying to [comment:5 strenner]:
> The only way I can explain this behavior is the `SpecialNumber.__gt__` is called at some point.
Which you can confirm by inserting a print message in the relevant `__gt__`. It indeed seems that if, in evaluation of `a<b`, it happens that `a.__lt__(b)` returns `NotImplemented`, then the next thing tried is `b.__gt__(a)`. On second reading (or perhaps just correct reading) this *is* as documented:

"""
There are no swapped-argument versions of these methods (to be used when the left argument does not support the operation but the right argument does); rather, __lt__() and __gt__() are each other’s reflection, __le__() and __ge__() are each other’s reflection, and __eq__() and __ne__() are their own reflection.
"""

So indeed, if sage were a little more liberal in returning `NotImplemented` your approach could work.

The problem is that parts of sage are quite intent on having all objects comparable, meaning that the sage implementations try quite hard to return `True` or `False` rather than `NotImplemented`. So changing this will be pretty hard.



---

archive/issue_comments_200206.json:
```json
{
    "body": "> the sage implementations try quite hard to return True or False\n\nIMHO this behaviour will pretty easy break most of the math... \nThus for me it is worth to open a blocker ticket for  that issue",
    "created_at": "2017-03-03T23:24:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200206",
    "user": "jakobkroeker"
}
```

> the sage implementations try quite hard to return True or False

IMHO this behaviour will pretty easy break most of the math... 
Thus for me it is worth to open a blocker ticket for  that issue



---

archive/issue_comments_200207.json:
```json
{
    "body": "Duplicate of #21163.",
    "created_at": "2017-03-08T12:41:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200207",
    "user": "jdemeyer"
}
```

Duplicate of #21163.



---

archive/issue_comments_200208.json:
```json
{
    "body": "Resolution: duplicate",
    "created_at": "2017-03-08T12:41:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15494",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15494#issuecomment-200208",
    "user": "jdemeyer"
}
```

Resolution: duplicate
