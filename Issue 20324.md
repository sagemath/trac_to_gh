# Issue 20324: Return cycle type of a permutation

Issue created by migration from https://trac.sagemath.org/ticket/20561

Original creator: andrew.mathas

Original creation time: 2016-05-05 00:26:00




---

Comment by andrew.mathas created at 2016-05-05 01:04:32

Changing keywords from "" to "permutation, cycle type".


---

Comment by andrew.mathas created at 2016-05-05 01:04:32

Changing component from PLEASE CHANGE to group theory.


---

Comment by andrew.mathas created at 2016-05-05 01:04:32

Changing status from new to needs_review.


---

Comment by andrew.mathas created at 2016-05-05 01:04:32

Changing type from PLEASE CHANGE to enhancement.


---

Comment by git created at 2016-05-05 01:06:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-05-08 02:32:53

Hello,

You would better use the option `reverse` of `sort` rather than sorting and inversing.

On the other hand, constructing the actual cycle tuples to count their length is not optimal... I would rather implement it from scratch.

Sided remark: returning a Partition is very costly. Most of the time will be spent in the actual construction of the Partition from the given list.


---

Comment by vdelecroix created at 2016-05-08 02:32:53

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-05-08 13:27:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2016-05-08 13:34:15

Changing status from needs_work to needs_review.


---

Comment by andrew.mathas created at 2016-05-08 13:34:15

Replying to [comment:5 vdelecroix]:
> Hello,
> 
> You would better use the option `reverse` of `sort` rather than sorting and inversing.
> 
> Sided remark: returning a Partition is very costly. Most of the time will be spent in the actual construction of the Partition from the given list.

I have addressed both of these points: the `reverse=True` is now used and a list is returned.

> On the other hand, constructing the actual cycle tuples to count their length is not optimal... I would rather implement it from scratch.

I have not changed this as this seems to be unnecessary code duplication. I have not delved into the cycle code deeply but it seems to me that to extract this information you would essentially rewrite much of the cython code in `cycle_tuples`.


---

Comment by tscrim created at 2016-05-08 14:49:40

Considering that Sage's permutations return a `Partition`, I think this should also return a `Partition` for consistency. If that extra overhead of constructing a `Partition` is that great, then the act of sorting should be a significant burden as well (which is `O(n log n)` as opposed to `O(n)`).

You can also get ~10% speedup by using `_Partitions(data)` instead of `Partition(data)`.


---

Comment by vdelecroix created at 2016-05-08 18:11:57

On a random example *all* the time is taken by actually constructing the partition.

```
sage: S = SymmetricGroup(20)
sage: p = S.random_element()
sage: %timeit c = p.cycle_tuples()
1000000 loops, best of 3: 1.04 µs per loop
sage: c = p.cycle_tuples()
sage: %timeit l = map(len, c)
1000000 loops, best of 3: 382 ns per loop
sage: l = map(len, c)
sage: %timeit ls = sorted(l, reverse=True)
1000000 loops, best of 3: 889 ns per loop
sage: ls = sorted(l, reverse=True)
sage: %timeit p = Partition(ls)
10000 loops, best of 3: 14.5 µs per loop
```



---

Comment by vdelecroix created at 2016-05-08 18:31:04

You should fix the `OUTPUT` section.

In the doctest and the code, there would better be a space on each side of the equality sign `a = b` instead of `a=b`. This is just code convention. But it helps reading if this is uniform.
 
It costs nothing to add an option `singletons` to your `cycle_type` method. It is sometimes useful to ignore the fixed points.


---

Comment by tscrim created at 2016-05-08 18:40:43

I get much less percentage of time to construct a partition:

```
sage: S = SymmetricGroup(100)
sage: p = S.random_element()
sage: p
(1,60,19,34,68,36,55,29,54,89,23,87,99,95,31,24,83,98,6,82,2,10,76,5,80,52,32,77,22,37,93)(3,91,8,90,67,59,33,58,64,66,63,12,78,75,70,51,86,96,56,25,69,81,27,28,13,94,17,62,88,47,49,4,16,65,74,14,85,20,39,9,92,72,71,40,30,50,11,35,44,43)(7,84,45,73,38,21,61,97,53,18,41,79,26,100,42,48,57)(15,46)
sage: %timeit c = p.cycle_tuples()
100000 loops, best of 3: 3.63 µs per loop
sage: c = p.cycle_tuples(singletons=True)
sage: %timeit l = [len(x) for x in c]
1000000 loops, best of 3: 286 ns per loop
sage: l = [len(x) for x in c]
sage: %timeit ls = sorted(l, reverse=True)
1000000 loops, best of 3: 995 ns per loop
sage: ls = sorted(l, reverse=True)
sage: P = Partitions()
sage: %timeit p = P(ls)
100000 loops, best of 3: 8.92 µs per loop
```

Besides, not everything has to be ultra-super-optimized (plus these operations are not being compared fairly since the `Partition` call is Python). In this case, the consistency is much more desirable. (Technically to be fair, you need to include the singletons, but I believe these are "rare".) Averaging over all partitions and using `%lprun`, I get that it takes ~80% of the time.

I would say what would need to be done is improve the creation time of partitions if this is an issue for you Vincent.

Also, I don't know how it would make sense to disregard singletons. They are needed because the cycle types (with cycle types) determine the conjugacy classes of the symmetric group.

Side note: if you really care about speed, you should use `list.sort(reverse=True)` because it does it in place and does not create a second list.


---

Comment by vdelecroix created at 2016-05-08 18:52:17

Replying to [comment:11 tscrim]:

> I get much less percentage of time to construct a partition:

Your code is not the same as mine since you ignore the creation of the parent. In Andrew's code the call is precisely `Partition(ls)`. You should time the call `P = Partitions(); p = P(ls)`.

> Besides, not everything has to be ultra-super-optimized (plus these operations are not being compared fairly since the `Partition` call is Python). In this case, the consistency is much more desirable. (Technically to be fair, you need to include the singletons, but I believe these are "rare".) Averaging over all partitions and using `%lprun`, I get that it takes ~80% of the time.

A 80% gain is not what I would call super-optimization.

> I would say what would need to be done is improve the creation time of partitions if this is an issue for you Vincent.

Creating a partition from a tuple is trivial at no extra cost: just do `Partition(l)`. On the other hand, creating a list from a partition is: `list(p)` and this costs a >80% slow down.

> Also, I don't know how it would make sense to disregard singletons. They are needed because the cycle types (with cycle types) determine the conjugacy classes of the symmetric group.

It makes sense in a lot of situations. Especially when you count solutions of equations in the symmetric group. Getting the conjugacy is not the only important thing.

> Side note: if you really care about speed, you should use `list.sort(reverse=True)` because it does it in place and does not create a second list.

This is precisely what is done in Andrew's code and that I asked for in [comment:5].


---

Comment by tscrim created at 2016-05-08 19:09:53

Replying to [comment:12 vdelecroix]:
> Replying to [comment:11 tscrim]:
> 
> > I get much less percentage of time to construct a partition:
> 
> Your code is not the same as mine since you ignore the creation of the parent. In Andrew's code the call is precisely `Partition(ls)`. You should time the call `P = Partitions(); p = P(ls)`.

See the last part of comment:8.

> > Besides, not everything has to be ultra-super-optimized (plus these operations are not being compared fairly since the `Partition` call is Python). In this case, the consistency is much more desirable. (Technically to be fair, you need to include the singletons, but I believe these are "rare".) Averaging over all partitions and using `%lprun`, I get that it takes ~80% of the time.
> 
> A 80% gain is not what I would call super-optimization.

I forgot that sarcasm can be lost. Let me be more precise, we don't have to optimize everything, and it is not like it causes a significant slowdown. This is on the order of microseconds.

> > I would say what would need to be done is improve the creation time of partitions if this is an issue for you Vincent.
> 
> Creating a partition from a tuple is trivial at no extra cost: just do `Partition(l)`. On the other hand, creating a list from a partition is: `list(p)` and this costs a >80% slow down.

Despite how loaded your phrasing is, you should not be doing `list(p)` because partitions behave like lists (well, more like tuples). We also want to make things accessible to the user, and in particular, the conjugacy classes of permutations are always considered as partitions in the areas I know. So this makes things nice for the non-programmer-users who would expect this to be a partition.

Again, having this not return a partition would introduce an inconsistency with `cycle_type` of `Permutation`.

> > Also, I don't know how it would make sense to disregard singletons. They are needed because the cycle types (with cycle types) determine the conjugacy classes of the symmetric group.
> 
> It makes sense in a lot of situations. Especially when you count solutions of equations in the symmetric group. Getting the conjugacy is not the only important thing.

Then just use the cycle tuples; it doesn't sound like you care about the ordering.

> > Side note: if you really care about speed, you should use `list.sort(reverse=True)` because it does it in place and does not create a second list.

> This is precisely what is done in Andrew's code and that I asked for in [comment:5].

Ah, sorry; I misread that comment (I thought you said `sorted`).


---

Comment by git created at 2016-05-09 07:56:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-05-09 07:59:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2016-05-09 08:00:17

I am amused how much bandwidth such a trivial ticket can generate:)

I agree with Vincent that allowing singletons to be ignored will probably be useful, is more consistent with the other `cycle_*` methods and that it is trivial to implement. For all of these reasons, it should be implemented so I have added an optional `singletons` argument for this.

I also agree with Travis that the casual user will expect that `cycle_type` will return a partition so I have made this the default, using `_Partitions` as Travis recommends. The non-casual user may well not want a partition so I have added a second optional argument `as_list` that , when `True`, will cause a list to be returned.

Here are some new timings with these changes:


```python
sage: S = SymmetricGroup(100)
sage: p = S.random_element()
sage:  %timeit c = p.cycle_type()
10000 loops, best of 3: 47.5 µs per loop
sage: %timeit c = p.cycle_type(singletons=True)
10000 loops, best of 3: 50.2 µs per loop
sage: %timeit c = p.cycle_type(as_list=True)
100000 loops, best of 3: 11.9 µs per loop
sage: %timeit c = p.cycle_type(singletons=True, as_list=True)
100000 loops, best of 3: 11.6 µs per loop
sage: %timeit c = p.cycle_tuples()
100000 loops, best of 3: 9.83 µs per loop
```


So it seems that returning a partition is relatively costly but I think that it is more user friendly so should be the default. I have added a remark in the documentation that `as_list=True` should be used when speed is an issue.
----
New commits:


---

Comment by tscrim created at 2016-05-09 14:43:14

I am okay with it. Vincent (to whom, thank you for your input)?

From this, I figure it is about time that we rework `Partition` a bit so that has faster initialization.


---

Comment by vdelecroix created at 2016-05-09 21:51:22

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-05-19 22:38:42

Resolution: fixed
