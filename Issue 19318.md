# Issue 19318: Implement a containment for cartesian_product

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-11-08 22:12:47

Assignee: sage-combinat

CC:  sage-combinat vdelecroix

We currently have this:

```
sage: C = cartesian_product([range(5), range(5)])
sage: (1, 1) in C
False
```



---

Comment by tscrim created at 2015-11-08 22:17:56

New commits:


---

Comment by tscrim created at 2015-11-08 22:17:56

Changing status from new to needs_review.


---

Comment by ncohen created at 2015-11-09 20:04:26

I admittedly do not know much about such matters, but isn't the problemm here that the object is not a 'facade' object, while you expect it to be in your bug report?

Nathann


---

Comment by vdelecroix created at 2015-11-09 20:32:54

Replying to [comment:2 ncohen]:
> I admittedly do not know much about such matters, but isn't the problemm here that the object is not a 'facade' object, while you expect it to be in your bug report?

More or less. The current generic code (from `sage.structure.parent`) tries to compare the tuple with the corresponding object of the cartesian product. And they of course compare as different:

```
sage: C = cartesian_product([srange(5), srange(5)])
sage: c = C((1,1))
sage: c
(1, 1)
sage: c == (1,1)
False
sage: (1,1) == c
False
```


Warning: your example is completely broken

```
sage: C = cartesian_product([range(5), range(5)])
sage: C((1r,1r))
(1, 1)
sage: C((1,1))
Traceback (most recent call last):
...
TypeError: Cannot convert int to sage.structure.element.Element
```


Warning++: you can not use `range` and `srange` in the same Sage session since `FiniteEnumeratedSet` uses `UniqueRepresentation`... I guess a safer way to implement this unique representation, would be to force a common universe for the elements... (see #19562)


---

Comment by tscrim created at 2015-11-09 20:48:34

The issue of the element constructor is worked around on #19554 (see #19553 for the general issue).


---

Comment by vdelecroix created at 2015-12-04 01:34:31

Changing status from needs_review to needs_info.


---

Comment by vdelecroix created at 2015-12-04 01:34:31

1. What is the rationale for having tuple being considered as elements of the cartesian product?

2. With this version `__contains__` and `Element.__eq__` are not compatible

```
sage: (1,1) in C
True
sage: any(x == (1,1) for x in C)
False
```



---

Comment by git created at 2015-12-06 17:46:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-12-06 17:47:59

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2015-12-06 17:47:59

Replying to [comment:6 vdelecroix]:
> 1. What is the rationale for having tuple being considered as elements of the cartesian product?

They are just wrappers around tuples, and at times, it is beneficial to not wrap/unwrap such objects, such as if the Cartesian product is the set of keys of a dict/Family.

> 2. With this version `__contains__` and `Element.__eq__` are not compatible
> {{{
> sage: (1,1) in C
> True
> sage: any(x == (1,1) for x in C)
> False
> }}}

Good point. I added equality of tuples.


---

Comment by vdelecroix created at 2015-12-06 17:50:05

Replying to [comment:8 tscrim]:
> Replying to [comment:6 vdelecroix]:
> > 1. What is the rationale for having tuple being considered as elements of the cartesian product?
> 
> They are just wrappers around tuples, and at times, it is beneficial to not wrap/unwrap such objects, such as if the Cartesian product is the set of keys of a dict/Family.

Then in that case I would actually implement an option in `CartesianProduct` to actually *use* tuples directly.


---

Comment by ncohen created at 2015-12-06 17:52:56

Err.. Just wondering aloud: is it safe to enable equality with tuples? It means that the hash has to be the same, doesn't it?

Nathann


---

Comment by tscrim created at 2015-12-06 17:53:55


```
sage: A = cartesian_product([ZZ, ZZ])
sage: elt = A((1,1))
sage: hash(elt)
3713081631935493181
sage: hash((1,1))
3713081631935493181
```



---

Comment by ncohen created at 2015-12-06 17:54:54

Oh, okay okay then. I didn't see a hash function in the file, and so I wondered if we were sure that the parent was not involved.


---

Comment by tscrim created at 2015-12-06 17:57:17

The default hash of `ElementWrapper` is the hash of the wrapper value.


---

Comment by vdelecroix created at 2015-12-06 23:43:27

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-12-06 23:43:27

Equality does not work (see patchbot report). And what about [comment:9 comment:9]?


---

Comment by git created at 2015-12-07 01:01:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-12-07 01:07:10

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2015-12-07 01:07:10

With regards to comment:9, we don't want them to be tuples because we want all of the category information to be inherited, e.g.

```
sage: C = cartesian_product([ZZ, ZZ])
sage: x = C.an_element()
sage: x
(1, 1)
sage: x.is_one()
True
```



---

Comment by vdelecroix created at 2015-12-07 02:12:48

I fully agree on the above example and there are many others. As you said, wrapping has a cost. Having an option looks reasonable

```
sage: C = cartesian_product([range(5), range(5)], with_elements_as_tuple=True)
sage: C.element_class
<type 'tuple'>
```

Though, I am just asking for your opinion. I am not considering it good for inclusion in this ticket.

On the other hand, with your laxism with respect to tuples the equality test is about 3x slower. We had

```
sage: C = cartesian_product([srange(5), srange(5)])
sage: c = C((1,1))
sage: d = C((1,1))
sage: e = C((1,2))
sage: %timeit c == d and c == e
1000000 loops, best of 3: 327 ns per loop
```

And with your branch

```
sage: %timeit c == d and c == e
100000 loops, best of 3: 1.93 Âµs per loop
```

If the comparison has to be touched, it has to be at the level of `ElementWrapper`. Probably a new class.


---

Comment by git created at 2015-12-10 04:44:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-12-10 04:50:20

Ahh...the speed of Cython. I created a new class in between `ElementWrapper` and `CartesianProduct.Element` that has specialized equality comparisons against the wrapped class.

Current:

```
sage: C = cartesian_product([ZZ, ZZ])
sage: c = C((1, 1))
sage: d = C((1, 1))
sage: e = C((1, 2))
sage: %timeit c == d
1000000 loops, best of 3: 183 ns per loop
sage: %timeit c == e
10000000 loops, best of 3: 183 ns per loop
```

vs old:

```
sage: %timeit c == d
1000000 loops, best of 3: 175 ns per loop
sage: %timeit c == e
10000000 loops, best of 3: 179 ns per loop
```

So we might loose up to ~2%, but I think this will get lost in noise if someone is doing Cartesian products of things with any harder comparison operators. (Although IMO the previous slowdown would likely have been negligible in computations (at least I would recommend using `itertools` and `tuple`s if this was an issue)).

As suggested in the parenthetical, if you wanted this to be a facade parent for tuples, which is I think what you would end up with, then you likely could just use `itertools`.


---

Comment by vdelecroix created at 2015-12-24 15:59:48

Replying to [comment:19 tscrim]:
> As suggested in the parenthetical, if you wanted this to be a facade parent for tuples, which is I think what you would end up with, then you likely could just use `itertools`.

But itertools does not care about `rank`, `unrank`, `__contains__`. Python iterators might not be rich enough.

Vincent


---

Comment by vdelecroix created at 2015-12-24 15:59:48

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2015-12-24 22:15:28

Well, we'll see if such a situation arises. Thanks for the review.


---

Comment by vbraun created at 2015-12-25 16:16:48

Resolution: fixed
