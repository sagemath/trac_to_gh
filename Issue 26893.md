# Issue 26893: posets.RandomLattice() cannot generate some lattices

archive/issues_026893.json:
```json
{
    "body": "CC:  @kevindilks @jm58660\n\nFor example, the lattice\n\n\n```\nL = LatticePoset((range(9), [(0,1),(1,2),(1,3),(1,4),(2,5),(2,6),(3,5),(3,7),(4,6),(4,7),(5,8),(6,8),(7,8)]))\n```\n\n\n(a 3-cube with an extra point added at the bottom) will never be generated by `posets.RandomLattice()`.\n\nThe algorithm used to generate random lattices is to construct a join-semilattice, successively adding new minimum elements by choosing an admissible upper cover for them at random; and finally making a lattice by adding a bottom element. (Note that the code looks like it is doing the dual of this, but the thing gets turned upside-down when passed to the Poset constructor.) The problem is in the method used to search for an admissible upper cover for the new element: it adds random elements to the antichain one by one, checking at each stage whether the antichain is admissible (i.e. whether adding the new element will preserve unique joins). But not all admissible antichains can be obtained in this way, as the example above demonstrates: in order to construct it, the point 1 has to be added below the antichain {2,3,4}; but no 2-element subset of {2,3,4} is admissible. Furthermore, the lattice cannot be constructed in any way that avoids this step.\n\nA possible fix would be at each step to select the antichain at random from the set of all antichains (repeatedly until an admissible antichain is selected), rather than build it up incrementally. It would, I think, be reasonably efficient to maintain the set of antichains as the random lattice is constructed, since after adding a new element the new antichains are just the old ones with the new element possibly added provided they don't contain any elements from the upper cover just selected. On the other hand, the set of antichains probably grows quite fast as the lattice grows. A method that avoids this cost while still being able to generate all possible lattices would be interesting, but I can't think of one.\n\n(This method would remove the need for the parameter p; alternatively p could be used to bias the selection of antichains in favour of larger or smaller ones.)\n\nIssue created by migration from https://trac.sagemath.org/ticket/27130\n\n",
    "created_at": "2019-01-25T19:51:46Z",
    "labels": [
        "combinatorics",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.7",
    "title": "posets.RandomLattice() cannot generate some lattices",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26893",
    "user": "@obtext"
}
```
CC:  @kevindilks @jm58660

For example, the lattice


```
L = LatticePoset((range(9), [(0,1),(1,2),(1,3),(1,4),(2,5),(2,6),(3,5),(3,7),(4,6),(4,7),(5,8),(6,8),(7,8)]))
```


(a 3-cube with an extra point added at the bottom) will never be generated by `posets.RandomLattice()`.

The algorithm used to generate random lattices is to construct a join-semilattice, successively adding new minimum elements by choosing an admissible upper cover for them at random; and finally making a lattice by adding a bottom element. (Note that the code looks like it is doing the dual of this, but the thing gets turned upside-down when passed to the Poset constructor.) The problem is in the method used to search for an admissible upper cover for the new element: it adds random elements to the antichain one by one, checking at each stage whether the antichain is admissible (i.e. whether adding the new element will preserve unique joins). But not all admissible antichains can be obtained in this way, as the example above demonstrates: in order to construct it, the point 1 has to be added below the antichain {2,3,4}; but no 2-element subset of {2,3,4} is admissible. Furthermore, the lattice cannot be constructed in any way that avoids this step.

A possible fix would be at each step to select the antichain at random from the set of all antichains (repeatedly until an admissible antichain is selected), rather than build it up incrementally. It would, I think, be reasonably efficient to maintain the set of antichains as the random lattice is constructed, since after adding a new element the new antichains are just the old ones with the new element possibly added provided they don't contain any elements from the upper cover just selected. On the other hand, the set of antichains probably grows quite fast as the lattice grows. A method that avoids this cost while still being able to generate all possible lattices would be interesting, but I can't think of one.

(This method would remove the need for the parameter p; alternatively p could be used to bias the selection of antichains in favour of larger or smaller ones.)

Issue created by migration from https://trac.sagemath.org/ticket/27130





---

archive/issue_comments_378373.json:
```json
{
    "body": "Attachment [impossible-random-lattice.png](tarball://root/attachments/some-uuid/ticket27130/impossible-random-lattice.png) by @obtext created at 2019-01-25 19:52:39\n\nDiagram of lattice that cannot be generated by posets.RandomLattice()",
    "created_at": "2019-01-25T19:52:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378373",
    "user": "@obtext"
}
```

Attachment [impossible-random-lattice.png](tarball://root/attachments/some-uuid/ticket27130/impossible-random-lattice.png) by @obtext created at 2019-01-25 19:52:39

Diagram of lattice that cannot be generated by posets.RandomLattice()



---

archive/issue_comments_378374.json:
```json
{
    "body": "How does what Sage currently does compare with the algorithm given here ( https://www.emis.de/journals/MB/125.2/mb125_2_1.pdf ) ?",
    "created_at": "2019-01-25T20:23:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378374",
    "user": "@kevindilks"
}
```

How does what Sage currently does compare with the algorithm given here ( https://www.emis.de/journals/MB/125.2/mb125_2_1.pdf ) ?



---

archive/issue_comments_378375.json:
```json
{
    "body": "I'm afraid I don't understand the algorithm described there. The description in section 2 sounds as if you build a meet semilattice by successively adding new elements whose lower covers consist only of maximal elements. But that can't generate anything except a chain. I'm trying to understand the code...\n\nEdit: I have compiled and run the code from section 2 of that paper, with a few small modifications:\n- Initialize `u` to 0 in `Work()` (otherwise it's used uninitialized).\n- Change `if(!rnd(q))` to `if(i && !rnd(q))` (otherwise we may call `rnd()` with a zero argument in `FindMax()`, which makes no sense).\n- Finally add a bottom element. (The code only generates a join semilattice.)\n\nIt does then generate non-trivial lattices. But not all of them. It only generates 2 out of the 5 possible 5-point lattices.",
    "created_at": "2019-01-25T22:11:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378375",
    "user": "@obtext"
}
```

I'm afraid I don't understand the algorithm described there. The description in section 2 sounds as if you build a meet semilattice by successively adding new elements whose lower covers consist only of maximal elements. But that can't generate anything except a chain. I'm trying to understand the code...

Edit: I have compiled and run the code from section 2 of that paper, with a few small modifications:
- Initialize `u` to 0 in `Work()` (otherwise it's used uninitialized).
- Change `if(!rnd(q))` to `if(i && !rnd(q))` (otherwise we may call `rnd()` with a zero argument in `FindMax()`, which makes no sense).
- Finally add a bottom element. (The code only generates a join semilattice.)

It does then generate non-trivial lattices. But not all of them. It only generates 2 out of the 5 possible 5-point lattices.



---

archive/issue_comments_378376.json:
```json
{
    "body": "I was overthinking the problem. we don't need to maintain a list of antichains. We can just generate random antichains on the fly at each step, repeating until we find an admissible one.\n\nWorking on a patch...",
    "created_at": "2019-01-27T08:30:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378376",
    "user": "@obtext"
}
```

I was overthinking the problem. we don't need to maintain a list of antichains. We can just generate random antichains on the fly at each step, repeating until we find an admissible one.

Working on a patch...



---

archive/issue_comments_378377.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-01-27T09:15:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378377",
    "user": "@obtext"
}
```

New commits:



---

archive/issue_comments_378378.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-01-27T09:15:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378378",
    "user": "@obtext"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_378379.json:
```json
{
    "body": "Hi kdilks, would you be able to review this -- or suggest someone else? Thanks!",
    "created_at": "2019-01-28T11:21:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378379",
    "user": "@obtext"
}
```

Hi kdilks, would you be able to review this -- or suggest someone else? Thanks!



---

archive/issue_comments_378380.json:
```json
{
    "body": "I can look at this in a few days.",
    "created_at": "2019-01-28T21:04:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378380",
    "user": "@kevindilks"
}
```

I can look at this in a few days.



---

archive/issue_comments_378381.json:
```json
{
    "body": "True, my fault. Also I did not enough random testing for random lattices: I tested that all 8-element lattices are generated, not for 9-element lattices.\n\nNumber of possible antichains is of course `O(n!)`, just take an antichain with upper cover added.\n\nAs a quick fix at least one can create a random poset and run `completion_by_cuts()` to it, but that is also slow.\n\nWhen doing this I remember thinking about speed and possible algorithms. One possibility could be making a random antichain, and if it not admissible, removing elements from it.",
    "created_at": "2019-01-29T07:35:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378381",
    "user": "@jm58660"
}
```

True, my fault. Also I did not enough random testing for random lattices: I tested that all 8-element lattices are generated, not for 9-element lattices.

Number of possible antichains is of course `O(n!)`, just take an antichain with upper cover added.

As a quick fix at least one can create a random poset and run `completion_by_cuts()` to it, but that is also slow.

When doing this I remember thinking about speed and possible algorithms. One possibility could be making a random antichain, and if it not admissible, removing elements from it.



---

archive/issue_comments_378382.json:
```json
{
    "body": "To get some numbers I counted all antichains in 9-, 10- and 11-element lattices. On average they have 27, 37 and 51 antichains. But the corner cases might still freeze computation in practise.",
    "created_at": "2019-01-29T07:42:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378382",
    "user": "@jm58660"
}
```

To get some numbers I counted all antichains in 9-, 10- and 11-element lattices. On average they have 27, 37 and 51 antichains. But the corner cases might still freeze computation in practise.



---

archive/issue_comments_378383.json:
```json
{
    "body": "Yes, I found by experiment that keeping track of all antichains was too expensive for sizes greater than about 25.\n\nActually I've submitted for review [a simpler fix](https://git.sagemath.org/sage.git/diff?id2=0cb494282d7b4cea50aba7f4d100e7932a4c00b1&id=4480bf21e491969ff832b37ea6d009f25ad08c94), which modifies your algorithm so that it generates a random antichain without checking for admissibility at each step, and then if it is inadmissible retries with a new antichain. Performance seems OK.\n\nIf this is accepted, I am not sure if the comment advising on the value of p should be modified. Did you have some heuristic to arrive at that recommendation?",
    "created_at": "2019-01-29T08:32:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378383",
    "user": "@obtext"
}
```

Yes, I found by experiment that keeping track of all antichains was too expensive for sizes greater than about 25.

Actually I've submitted for review [a simpler fix](https://git.sagemath.org/sage.git/diff?id2=0cb494282d7b4cea50aba7f4d100e7932a4c00b1&id=4480bf21e491969ff832b37ea6d009f25ad08c94), which modifies your algorithm so that it generates a random antichain without checking for admissibility at each step, and then if it is inadmissible retries with a new antichain. Performance seems OK.

If this is accepted, I am not sure if the comment advising on the value of p should be modified. Did you have some heuristic to arrive at that recommendation?



---

archive/issue_comments_378384.json:
```json
{
    "body": "The code seems to be OK. I am currently compiling it.\n\nThere is already `random_order_ideal` on posets, with docstring \"Return a random order ideal with uniform probability.\" Might be useful. For values of `p` I have no suggestion. Might be hard to have a good heuristics.\n\nOne idea I had when thinking about more uniform distribution: Create all lattices of (say) *three* more elements using for example canonical augmentation. Now use the number of them as weight to randomly select *one* new element to add. Repeat. I haven't tested that.\n\n(Btw, I also tested 12-element lattices. They have 71 antichains on average.)",
    "created_at": "2019-01-29T08:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378384",
    "user": "@jm58660"
}
```

The code seems to be OK. I am currently compiling it.

There is already `random_order_ideal` on posets, with docstring "Return a random order ideal with uniform probability." Might be useful. For values of `p` I have no suggestion. Might be hard to have a good heuristics.

One idea I had when thinking about more uniform distribution: Create all lattices of (say) *three* more elements using for example canonical augmentation. Now use the number of them as weight to randomly select *one* new element to add. Repeat. I haven't tested that.

(Btw, I also tested 12-element lattices. They have 71 antichains on average.)



---

archive/issue_comments_378385.json:
```json
{
    "body": "I tested with\n\n\n```\nL = LatticePoset((range(9), [(0,1),(1,2),(1,3),(1,4),(2,5),(2,6),(3,5),(3,7),(4,6),(4,7),(5,8),(6,8),(7,8)]))\nfor i in xrange(100000):\n    if i%1000 == 0:\n        print(i/1000)\n    set_random_seed(i)\n    L1 = posets.RandomLattice(9, 0.995)\n    if L.is_isomorphic(L1):\n        print(\"Found\", i)\n        break\nelse:\n    print(\"Not found\")\n```\n\n\nand it found nothing. However with `p=0.9` it was fast and the lattice was found.",
    "created_at": "2019-01-29T09:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378385",
    "user": "@jm58660"
}
```

I tested with


```
L = LatticePoset((range(9), [(0,1),(1,2),(1,3),(1,4),(2,5),(2,6),(3,5),(3,7),(4,6),(4,7),(5,8),(6,8),(7,8)]))
for i in xrange(100000):
    if i%1000 == 0:
        print(i/1000)
    set_random_seed(i)
    L1 = posets.RandomLattice(9, 0.995)
    if L.is_isomorphic(L1):
        print("Found", i)
        break
else:
    print("Not found")
```


and it found nothing. However with `p=0.9` it was fast and the lattice was found.



---

archive/issue_comments_378386.json:
```json
{
    "body": "Yes, it seems that values of p very close to 1 do inhibit some configurations. Perhaps the advice for p should be modified, but I don't have a clear sense of how.",
    "created_at": "2019-01-29T10:55:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378386",
    "user": "@obtext"
}
```

Yes, it seems that values of p very close to 1 do inhibit some configurations. Perhaps the advice for p should be modified, but I don't have a clear sense of how.



---

archive/issue_comments_378387.json:
```json
{
    "body": "I wrote some quick (well, not that quick) test code to get a sense of how varying p changed the 'spread' of isomorphism classes of lattices produced:\n\n```python\ndef iso_invariant(L):\n    \"\"\" Quick and dirty isomorphism-invariant, hopefully enough to distinguish\n        most non-isomorphic pairs.\n    \"\"\"\n    return (L.height(), L.width(), L.relations_number(), len(L.coatoms()), len(L.atoms()), len(L.meet_irreducibles()), len(L.join_irreducibles()))\ndef variation(n, p, k):\n    S = set(iso_invariant(posets.RandomLattice(n, p)) for _ in xrange(k))\n    return len(S)\ndef variations(n, k):\n    ps = [0.4, 0.6, 0.8, 0.85, 0.9, 0.95, 0.99, 0.995]\n    return [(p, variation(n,p,k)) for p in ps]\n```\n\n\nI ran it with n=9 and n=20, each time with k=1000. This leads me to think that p=0.9 may be a good choice:\n\n```\nsage: a = variations(9, 1000); a\n[(0.400000000000000, 153),\n (0.600000000000000, 190),\n (0.800000000000000, 206),\n (0.850000000000000, 215),\n (0.900000000000000, 218),\n (0.950000000000000, 197),\n (0.990000000000000, 143),\n (0.995000000000000, 128)]\nsage: a = variations(20, 1000); a\n[(0.400000000000000, 939),\n (0.600000000000000, 970),\n (0.800000000000000, 982),\n (0.850000000000000, 989),\n (0.900000000000000, 988),\n (0.950000000000000, 981),\n (0.990000000000000, 891),\n (0.995000000000000, 796)]\n```\n",
    "created_at": "2019-01-29T17:27:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378387",
    "user": "@obtext"
}
```

I wrote some quick (well, not that quick) test code to get a sense of how varying p changed the 'spread' of isomorphism classes of lattices produced:

```python
def iso_invariant(L):
    """ Quick and dirty isomorphism-invariant, hopefully enough to distinguish
        most non-isomorphic pairs.
    """
    return (L.height(), L.width(), L.relations_number(), len(L.coatoms()), len(L.atoms()), len(L.meet_irreducibles()), len(L.join_irreducibles()))
def variation(n, p, k):
    S = set(iso_invariant(posets.RandomLattice(n, p)) for _ in xrange(k))
    return len(S)
def variations(n, k):
    ps = [0.4, 0.6, 0.8, 0.85, 0.9, 0.95, 0.99, 0.995]
    return [(p, variation(n,p,k)) for p in ps]
```


I ran it with n=9 and n=20, each time with k=1000. This leads me to think that p=0.9 may be a good choice:

```
sage: a = variations(9, 1000); a
[(0.400000000000000, 153),
 (0.600000000000000, 190),
 (0.800000000000000, 206),
 (0.850000000000000, 215),
 (0.900000000000000, 218),
 (0.950000000000000, 197),
 (0.990000000000000, 143),
 (0.995000000000000, 128)]
sage: a = variations(20, 1000); a
[(0.400000000000000, 939),
 (0.600000000000000, 970),
 (0.800000000000000, 982),
 (0.850000000000000, 989),
 (0.900000000000000, 988),
 (0.950000000000000, 981),
 (0.990000000000000, 891),
 (0.995000000000000, 796)]
```




---

archive/issue_comments_378388.json:
```json
{
    "body": "For comparison, this is what I get running with the unpatched `RandomLattice` code:\n\n```\nsage: a = variations(9, 1000); a\n[(0.400000000000000, 145),\n (0.600000000000000, 184),\n (0.800000000000000, 229),\n (0.850000000000000, 219),\n (0.900000000000000, 214),\n (0.950000000000000, 224),\n (0.990000000000000, 202),\n (0.995000000000000, 211)]\nsage: a = variations(20, 1000); a\n[(0.400000000000000, 953),\n (0.600000000000000, 966),\n (0.800000000000000, 974),\n (0.850000000000000, 970),\n (0.900000000000000, 985),\n (0.950000000000000, 988),\n (0.990000000000000, 992),\n (0.995000000000000, 986)]\n```\n",
    "created_at": "2019-01-29T17:37:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378388",
    "user": "@obtext"
}
```

For comparison, this is what I get running with the unpatched `RandomLattice` code:

```
sage: a = variations(9, 1000); a
[(0.400000000000000, 145),
 (0.600000000000000, 184),
 (0.800000000000000, 229),
 (0.850000000000000, 219),
 (0.900000000000000, 214),
 (0.950000000000000, 224),
 (0.990000000000000, 202),
 (0.995000000000000, 211)]
sage: a = variations(20, 1000); a
[(0.400000000000000, 953),
 (0.600000000000000, 966),
 (0.800000000000000, 974),
 (0.850000000000000, 970),
 (0.900000000000000, 985),
 (0.950000000000000, 988),
 (0.990000000000000, 992),
 (0.995000000000000, 986)]
```




---

archive/issue_comments_378389.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-01-29T20:40:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378389",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378390.json:
```json
{
    "body": "Ping ... is this OK to be merged?",
    "created_at": "2019-02-09T17:43:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378390",
    "user": "@obtext"
}
```

Ping ... is this OK to be merged?



---

archive/issue_comments_378391.json:
```json
{
    "body": "Yes, I think this is ready to go.",
    "created_at": "2019-02-10T06:11:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378391",
    "user": "@jm58660"
}
```

Yes, I think this is ready to go.



---

archive/issue_comments_378392.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-02-10T06:11:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378392",
    "user": "@jm58660"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_378393.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-02-11T23:06:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26893",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26893#issuecomment-378393",
    "user": "@vbraun"
}
```

Resolution: fixed
