# Issue 26000: SystemError with LinearMatroid with an IntegerMatrix

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2018-09-11 05:26:13

CC:  stefan rudi yomcat msaaltink

I am trying to compute things with some linear matroids whose representation matrices have integer values. Because the generic code is too slow, I wanted to use the more specialized code directly:

```
sage: from sage.matroids.linear_matroid import LinearMatroid
sage: from sage.matroids.lean_matrix import IntegerMatrix
sage: M = LinearMatroid(matrix=IntegerMatrix(4,3,matrix([[0,0,0],[0,0,0],[0,1,1],[1,0,1]])))
sage: M.circuits()
---------------------------------------------------------------------------
SystemError                               Traceback (most recent call last)
<ipython-input-42-8adfde621a57> in <module>()
----> 1 M.circuits()

SystemError: error return without exception set
```

However, this works if I use `GenericMatrix`.

This also occurs by doing things directly in the global namespace:

```
sage: M = Matroid(matrix=matrix([[0,0,0],[0,0,0],[0,1,1],[1,0,1]]), regular=True)
sage: M.circuits()
---------------------------------------------------------------------------
SystemError                               Traceback (most recent call last)
<ipython-input-47-8adfde621a57> in <module>()
----> 1 M.circuits()

SystemError: error return without exception set
```

There is definitely a bug at least somewhere.


---

Comment by jdemeyer created at 2018-09-11 05:41:55

Works for me:

```
sage: from sage.matroids.linear_matroid import LinearMatroid
sage: from sage.matroids.lean_matrix import IntegerMatrix
sage: M = LinearMatroid(matrix=IntegerMatrix(4,3,matrix([[0,0,0],[0,0,0],[0,1,1],[1,0,1]])))
sage: M.circuits()
Iterator over a system of subsets
```



---

Comment by tscrim created at 2018-09-11 05:45:53

Hmm...strange. Let me try from a fresh session to see if I somehow unintentionally corrupted things.


---

Comment by tscrim created at 2018-09-11 05:54:06

Okay, I had one little seemingly innocuous change: I added an explicit return type `int` on the corresponding `get` method of `IntegerMatrix`. Once I removed that, it worked.


---

Comment by tscrim created at 2018-09-11 05:57:07

So what was going wrong is that there is a `bint is_nonzero` method which simply was `return self.get(r, c)`, and Cython could somehow not automatically convert that to a boolean check. Would that count as a Cython bug?

If it is not, I might also recycle this ticket with some Cython tweaks to `IntegerMatrix` to try and squeeze a bit more speed out of it.


---

Comment by tscrim created at 2018-09-11 06:09:04

Well, there is a bug somewhere (on vanilla 8.4.beta4):

```
sage: M = LinearMatroid(matrix=IntegerMatrix(4,4,matrix([[0,0,0,0],[1,1,1,1],[0,1,1,2],[0,0,1,0]])))
sage: list(M.bases())
[frozenset({0, 1, 2}), frozenset({0, 2, 3})]

sage: Mp = LinearMatroid(matrix=GenericMatrix(4,4,matrix([[0,0,0,0],[1,1,1,1],[0,1,1,2],[0,0,1,0]])))
sage: list(Mp.bases())
[frozenset({0, 1, 2}), frozenset({0, 2, 3}), frozenset({1, 2, 3})]
```



---

Comment by jdemeyer created at 2018-09-11 07:33:29

Replying to [comment:4 tscrim]:
> So what was going wrong is that there is a `bint is_nonzero` method which simply was `return self.get(r, c)`, and Cython could somehow not automatically convert that to a boolean check.

I'm not following here... what do you mean with "Cython could somehow not automatically convert that to a boolean check"?


---

Comment by tscrim created at 2018-09-11 07:46:42

Yes, that is correct (well, an `int` to a `bint` to be specific).


---

Comment by tscrim created at 2018-09-11 07:47:17

At least, once I changed that to an explicit check != 0, it fixed the problem.


---

Comment by Stefan created at 2018-09-11 07:49:08

Replying to [comment:5 tscrim]:
> Well, there is a bug somewhere (on vanilla 8.4.beta4):
> {{{
> sage: M = LinearMatroid(matrix=IntegerMatrix(4,4,matrix([[0,0,0,0],[1,1,1,1],[0,1,1,2],[0,0,1,0]])))
> sage: list(M.bases())
> [frozenset({0, 1, 2}), frozenset({0, 2, 3})]
> 
> sage: Mp = LinearMatroid(matrix=GenericMatrix(4,4,matrix([[0,0,0,0],[1,1,1,1],[0,1,1,2],[0,0,1,0]])))
> sage: list(Mp.bases())
> [frozenset({0, 1, 2}), frozenset({0, 2, 3}), frozenset({1, 2, 3})]
> }}}

Most (all?) LinearMatroid methods assume that we are allowed to pivot in the matrix, and do so without leaving the ring. Maybe that's what went wrong?


---

Comment by jdemeyer created at 2018-09-11 09:02:56

Replying to [comment:8 tscrim]:
> At least, once I changed that to an explicit check != 0, it fixed the problem.

It's still not clear which check you mean and what the problem really is...


---

Comment by Rudi created at 2018-09-11 09:31:06

The method GenericMatrix.is_nonzero seems to be called only by LeanMatrix.gauss_jordan_reduce() and LeanMatrix.nonzero_positions_in row().

LeanMatrix.pivot() does not even use is_nonzero(), but ‘s=self.get_unsafe(i,y)’ followed by ‘if s and ..’ (line 303 of lean_matrix.pyx). Apparently the conversion to a bool implicit in ‘if s’ does work in that context. It may be more effcient too, since depending on the base ring evaluating s!=0 may involve casting 0 as a ring element. I’m quite sure that for finite fields ‘if s’ is about 5 times faster than ‘if (s!=0)’.

So it may also be a solution to rewrite LeanMatrix.gauss_jordan_reduce() and LeanMatrix.nonzero_positions_in row() in the more efficient way used in pivot(), completely avoiding the use of is_nonzero().


---

Comment by tscrim created at 2018-09-11 22:42:31

Replying to [comment:10 jdemeyer]:
> Replying to [comment:8 tscrim]:
> > At least, once I changed that to an explicit check != 0, it fixed the problem.
> 
> It's still not clear which check you mean and what the problem really is...

Sorry, I was trying to answer quickly while I was out.

So when I explicitly tell Cython that `get` should return an `int`, then I have to do this change

```diff
     cdef bint is_nonzero(self, long r, long c) except -2:   # Not a Sage matrix operation
-        return self.get(r, c)
+        return self.get(r, c) != 0
```

otherwise I get the original error message in the ticket description.


---

Comment by tscrim created at 2018-09-11 22:43:53

Replying to [comment:9 Stefan]:
> Replying to [comment:5 tscrim]:
> > Well, there is a bug somewhere (on vanilla 8.4.beta4):
> > {{{
> > sage: M = LinearMatroid(matrix=IntegerMatrix(4,4,matrix([[0,0,0,0],[1,1,1,1],[0,1,1,2],[0,0,1,0]])))
> > sage: list(M.bases())
> > [frozenset({0, 1, 2}), frozenset({0, 2, 3})]
> > 
> > sage: Mp = LinearMatroid(matrix=GenericMatrix(4,4,matrix([[0,0,0,0],[1,1,1,1],[0,1,1,2],[0,0,1,0]])))
> > sage: list(Mp.bases())
> > [frozenset({0, 1, 2}), frozenset({0, 2, 3}), frozenset({1, 2, 3})]
> > }}}
> 
> Most (all?) LinearMatroid methods assume that we are allowed to pivot in the matrix, and do so without leaving the ring. Maybe that's what went wrong?

But in the latter case, the matrix is over `ZZ`, so I would not think that is the problem.


---

Comment by tscrim created at 2018-09-11 22:53:49

Replying to [comment:11 Rudi]:
> The method GenericMatrix.is_nonzero seems to be called only by LeanMatrix.gauss_jordan_reduce() and LeanMatrix.nonzero_positions_in row().
> 
> LeanMatrix.pivot() does not even use is_nonzero(), but ‘s=self.get_unsafe(i,y)’ followed by ‘if s and ..’ (line 303 of lean_matrix.pyx). Apparently the conversion to a bool implicit in ‘if s’ does work in that context. It may be more effcient too, since depending on the base ring evaluating s!=0 may involve casting 0 as a ring element. I’m quite sure that for finite fields ‘if s’ is about 5 times faster than ‘if (s!=0)’.

Yes, as you surmised, the `s != 0` is slower because invokes the coercion framework. So `if s` is the best thing to do for speed in general. It is just in this case that Cython does not seem to be converting an `int` (from an `inline` function) into a `bint`.

> So it may also be a solution to rewrite LeanMatrix.gauss_jordan_reduce() and LeanMatrix.nonzero_positions_in row() in the more efficient way used in pivot(), completely avoiding the use of is_nonzero().

What I was hoping to do was take advantage of the known return types in the integer matrix to improve the Cython code. With the explicit casting, my computation goes from 13.6s to 3s.

```diff
diff --git a/src/sage/matroids/lean_matrix.pxd b/src/sage/matroids/lean_matrix.pxd
index c284f6a..122dab1 100644
--- a/src/sage/matroids/lean_matrix.pxd
+++ b/src/sage/matroids/lean_matrix.pxd
`@``@` -102,7 +102,7 `@``@` cdef class QuaternaryMatrix(LeanMatrix):
 cdef class IntegerMatrix(LeanMatrix):
     cdef int* _entries
 
-    cdef inline get(self, long r, long c)   # Not a Sage matrix operation
+    cdef inline int get(self, long r, long c)   # Not a Sage matrix operation
     cdef inline void set(self, long r, long c, int x)   # Not a Sage matrix operation
 
     cdef inline long row_len(self, long i) except -1   # Not a Sage matrix operation
diff --git a/src/sage/matroids/lean_matrix.pyx b/src/sage/matroids/lean_matrix.pyx
index 93a32bc..d6022c2 100644
--- a/src/sage/matroids/lean_matrix.pyx
+++ b/src/sage/matroids/lean_matrix.pyx
`@``@` -2844,7 +2844,7 `@``@` cdef class IntegerMatrix(LeanMatrix):
         """
         return "IntegerMatrix instance with " + str(self._nrows) + " rows and " + str(self._ncols) + " columns"
 
-    cdef inline get(self, long r, long c):   # Not a Sage matrix operation
+    cdef inline int get(self, long r, long c):   # Not a Sage matrix operation
         return self._entries[r * self._ncols + c]
 
     cdef inline void set(self, long r, long c, int x):   # Not a Sage matrix operation
`@``@` -2877,7 +2877,7 `@``@` cdef class IntegerMatrix(LeanMatrix):
         return 0
 
     cdef bint is_nonzero(self, long r, long c) except -2:   # Not a Sage matrix operation
-        return self.get(r, c)
+        return self.get(r, c) != 0
 
     cdef LeanMatrix copy(self):   # Deprecated Sage matrix operation
         cdef IntegerMatrix M = IntegerMatrix(self._nrows, self._ncols)
`@``@` -2982,12 +2982,14 `@``@` cdef class IntegerMatrix(LeanMatrix):
         ignored.
         """
         cdef long i
+        cdef int sval
         if s is None:
             for i from 0 <= i < self._ncols:
                 self.set(x, i, self.get(x, i) + self.get(y, i))
         else:
+            sval = int(s)
             for i from 0 <= i < self._ncols:
-                self.set(x, i, self.get(x, i) + s * self.get(y, i))
+                self.set(x, i, self.get(x, i) + sval * self.get(y, i))
         return 0
 
     cdef int swap_rows_c(self, long x, long y) except -1:
`@``@` -3010,8 +3012,9 `@``@` cdef class IntegerMatrix(LeanMatrix):
         compatibility, and is ignored.
         """
         cdef long i
+        cdef int sval = int(s)
         for i from 0 <= i < self._ncols:
-            self.set(x, i, s * self.get(x, i))
+            self.set(x, i, sval * self.get(x, i))
         return 0
 
     cdef int rescale_column_c(self, long y, s, bint start_row) except -1:
`@``@` -3020,8 +3023,9 `@``@` cdef class IntegerMatrix(LeanMatrix):
         compatibility, and is ignored.
         """
         cdef long j
+        cdef int sval = int(s)
         for j from 0 <= j < self._nrows:
-            self.set(j, y, self.get(j, y) * s)
+            self.set(j, y, self.get(j, y) * sval)
         return 0
 
     cdef int pivot(self, long x, long y) except -1:   # Not a Sage matrix operation
```



---

Comment by Rudi created at 2018-09-12 07:55:35

Replying to [comment:14 tscrim]:
> Replying to [comment:11 Rudi]:
> What I was hoping to do was take advantage of the known return types in the integer matrix to improve the Cython code. With the explicit casting, my computation goes from 13.6s to 3s.

That looks like a good solution. Great! 

Could `GenericMatrix` perhaps also benefit from such explicit casting?  Anything that improves the efficiency of row operations should have an immediate effect on overall efficiency of linear matroid code.


---

Comment by tscrim created at 2018-09-12 08:01:35

Replying to [comment:15 Rudi]:
> Replying to [comment:14 tscrim]:
> > Replying to [comment:11 Rudi]:
> > What I was hoping to do was take advantage of the known return types in the integer matrix to improve the Cython code. With the explicit casting, my computation goes from 13.6s to 3s.
> 
> That looks like a good solution. Great! 
> 
> Could `GenericMatrix` perhaps also benefit from such explicit casting?  Anything that improves the efficiency of row operations should have an immediate effect on overall efficiency of linear matroid code. 

You cannot explicitly cast to something you don't know. Plus the arithmetic operations being done for `IntegerMatrix` are explicitly as C integers and not going through Python (much less Sage) at all. So I don't see how.


---

Comment by tscrim created at 2018-09-12 08:07:28

I guess something you could do is also special case `QQ` and go directly with the C data using the `mpq` commands. It looks like the `GF(2)` and `GF(3)` matrices are already quite specialized. At least I would think that is the next most common field to work over (other than maybe `GF(4)`).


---

Comment by jdemeyer created at 2018-09-12 08:15:02

Replying to [comment:12 tscrim]:
> So when I explicitly tell Cython that `get` should return an `int`

First of all, that's a bad idea: a C int has limited range (typically 32 bits) and you cannot guarantee that all entries fit in that.

> then I have to do this change
> {{{#!diff
>      cdef bint is_nonzero(self, long r, long c) except -2:   # Not a Sage matrix operation
> -        return self.get(r, c)
> +        return self.get(r, c) != 0
> }}}
> otherwise I get the original error message in the ticket description.

I don't consider that a bug. The reason is that the conversion of a Python object to a `bint` essentially translates to `int(bool(obj))` while the conversion to an `int` translates to `int(obj)`. These are obviously different. But once on the C level, the types `int` and `bint` are exactly the same, so no conversion is done when casting `int` to `bint`.


---

Comment by jdemeyer created at 2018-09-12 08:19:52

So the solution for really converting an `int` to a `bint` in Cython is indeed adding an explicit `!= 0`.


---

Comment by jdemeyer created at 2018-09-12 08:23:29

Should I close this ticket or do you want to recycle it?


---

Comment by tscrim created at 2018-09-12 13:05:37

I will recycle this, at least for the speedups to `IntegerMatrix`, but maybe with some more tweaks or improvements or an implementation of a `RationalMatrix`.

However, the fact that `bint` and `int` are the same, then why do I get the error I am getting when I do not explicitly make it a `bint` with the `!= 0`? From what you're saying, it should not result in an error. Unless there is some code elsewhere secretly expecting the result to be 0 or 1, which seems unlikely (or is `bint` allowed to take on different values)?

I am guessing instead of `int`, you would say we should have them all be `Py_ssize_t`?


---

Comment by jdemeyer created at 2018-09-12 13:38:08

Replying to [comment:21 tscrim]:
> However, the fact that `bint` and `int` are the same, then why do I get the error I am getting when I do not explicitly make it a `bint` with the `!= 0`? From what you're saying, it should not result in an error. Unless there is some code elsewhere secretly expecting the result to be 0 or 1, which seems unlikely (or is `bint` allowed to take on different values)?

Suppose that an entry in the matrix equals the Python integer -2. Currently (without applying any changes): when calling `is_nonzero()` on that -2, the return value is `int(bool(-2)) = 1`. With your changes, the return value for the same `is_nonzero()` call is just `-2`. The Cython wrapper interprets this `-2` as an exception return value (that is what `except -2` does). But there hasn't been an exception raised, which gives the `SystemError`.


---

Comment by jdemeyer created at 2018-09-12 13:50:04

Replying to [comment:21 tscrim]:
> I am guessing instead of `int`, you would say we should have them all be `Py_ssize_t`?

I just looked at the Cython sources for `lean_matrix.pyx` and `IntegerMatrix` does indeed use `int` internally. Therefore, returning `int` in `get()` is correct in that sense.

However... this just shows that using `IntegerMatrix` in general looks dangerous: operations can overflow. This is actually documented in the docstring of `IntegerMatrix`:

```
        This class is mainly intended for use with the RegularMatroid class,
        so entries are assumed to be small integers. No
        overflow checking takes place!
```



---

Comment by Stefan created at 2018-09-12 21:40:44

Thing is, the LeanMatrix classes are internal datatypes. Regular matroids have matrices with entries equal to -1, 0, 1, and are such that pivoting preserves that property. For a potentially regular matroid on which you want to run is_valid(), we check this condition through pivoting, which means we get to a "bad subdeterminant" of size at most 2x2, hardly enough to cause overflows if the entries are 0,1, or -1.

We took some effort to keep the LeanMatrix away from the end user (LinearMatroid.Representation returns a Sage matrix, for instance, and the datatypes don't get imported into the Sage namespace). Speed is of the essence here, since we create and destroy tons of these (Sage matrices have a lot of overhead at creation time), and we do tons of row operations on them. If you dig deep enough to use IntegerMatrix at this spot in the code, you'll have some idea of what you're getting yourself into.

Again, since you want to use IntegerMatrix in the LinearMatroid subclasses, and since you need a matrix where pivoting is safe, really the only use case is Regular Matroids where overflows are never an issue.


---

Comment by tscrim created at 2018-09-13 01:15:36

Replying to [comment:23 jdemeyer]:
> Replying to [comment:21 tscrim]:
> > However, the fact that `bint` and `int` are the same, then why do I get the error I am getting when I do not explicitly make it a `bint` with the `!= 0`? From what you're saying, it should not result in an error. Unless there is some code elsewhere secretly expecting the result to be 0 or 1, which seems unlikely (or is `bint` allowed to take on different values)?
> 
> Suppose that an entry in the matrix equals the Python integer -2. Currently (without applying any changes): when calling `is_nonzero()` on that -2, the return value is `int(bool(-2)) = 1`. With your changes, the return value for the same `is_nonzero()` call is just `-2`. The Cython wrapper interprets this `-2` as an exception return value (that is what `except -2` does). But there hasn't been an exception raised, which gives the `SystemError`.

Ah, I see. Thank you for the explanation. I fully agree that it is not a bug.


---

Comment by tscrim created at 2018-09-13 01:33:02

Replying to [comment:25 Stefan]:
> Thing is, the LeanMatrix classes are internal datatypes. Regular matroids have matrices with entries equal to -1, 0, 1, and are such that pivoting preserves that property. For a potentially regular matroid on which you want to run is_valid(), we check this condition through pivoting, which means we get to a "bad subdeterminant" of size at most 2x2, hardly enough to cause overflows if the entries are 0,1, or -1.

I see. `IntegerMatrix` is a misnomer because it requires entries to be `+-1` or `0`, which is also undocumented. In fact, in the `.. NOTE::`, it says this works for `LinearMatroid`, but that is not quite the case. Thank you for the explanation.

Now I understand why it is working for the generic matrix over `ZZ`: it is secretly converting things to `QQ` when doing the matrix operations. My computation was not working using `IntegerMatrix` because of the assumption of `+-1` for the nonzero entries.

I think this needs to be documented at the very least (which I will do here). I might also like to change the name of `IntegerMatrix` to perhaps `UnitIntegerMatrix` or `PlusMinusOneMatrix`. Thoughts?

> Again, since you want to use IntegerMatrix in the LinearMatroid subclasses, and since you need a matrix where pivoting is safe, really the only use case is Regular Matroids where overflows are never an issue.

So it seems like I should write a version of `LeanMatrix` that directly uses `mpq`. I will start to work on that.


---

Comment by jdemeyer created at 2018-09-13 05:41:06

Also: if the entries are really only 0, 1 or -1 then using an `int` to store the entries wastes memory. You could use `int8_t` (8 bits) instead of `int` (typically 32 bits). I'll leave it to you to decide whether it would be worth to change that.


---

Comment by tscrim created at 2018-09-13 05:46:04

I will leave it to Rudi or Stefan to decide for that.

So I have gotten a somewhat working `RationalMatrix` version working, but I am having a bit of an issue with getting things to work like I expected. In Cython, are things pass-by-reference or pass-by-copy (like C)? In particular, I wanted to have an inlined `get` that returned the correct `mpq_t` entry, and I want to pass some of those around (and sometimes assign them to local variables). However, this does not seem to work. Does that mean I have to handle them always as pointers when I want to pass them around?
----
New commits:


---

Comment by jdemeyer created at 2018-09-13 05:53:44

Replace

```
cdef int sval = int(s)
```

by

```
cdef int sval = s
```


The `int()` is superfluous and will only slow things down. Cython already implicitly converts when you assign to a C `int`.


---

Comment by git created at 2018-09-13 05:55:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-09-13 05:55:33

Done. I didn't know that. Thanks.


---

Comment by jdemeyer created at 2018-09-13 05:56:12

You will see that no function ever returns an `mpq_t` (or `mpz_t` or whatever). The typical calling convention is passing a return argument, for example the declaration of `mpq_add`:

```
void mpq_add(mpq_t sum, mpq_t addend1, mpq_t addend2)
```



---

Comment by tscrim created at 2018-09-13 06:00:13

Yea, I noticed that and so I scrapped the `get` in place of the `index` for better maintainability should the internal ordering change. However, I do have some functions where I am passing an `mpq_t`, e.g., in `pivot`, and this is not working as I would expect. Also, I had tried to do something like

```
cdef mpq_t s = self._entries[self.index(i,j)]
mpq_add(s, s, t)
```

where `t` is some other `mpq_t`, but that wasn't working like I expected either.


---

Comment by jdemeyer created at 2018-09-13 07:54:01

Can you move "Implement `RationalMatrix`" to a new ticket instead?

The commits that you added here to improve `IntegerMatrix` make sense independently.


---

Comment by jdemeyer created at 2018-09-13 07:55:41

Replying to [comment:27 tscrim]:
> I think this needs to be documented at the very least (which I will do here). I might also like to change the name of `IntegerMatrix` to perhaps `UnitIntegerMatrix` or `PlusMinusOneMatrix`. Thoughts?

+1 to `PlusMinusOneMatrix`.


---

Comment by tscrim created at 2018-09-13 07:57:44

Replying to [comment:36 jdemeyer]:
> Can you move "Implement `RationalMatrix`" to a new ticket instead?
> 
> The commits that you added here to improve `IntegerMatrix` make sense independently.

Yep, I can do that. I will do that when I get into my office tomorrow.


---

Comment by tscrim created at 2018-09-13 10:39:33

#26269 for the `RationalMatrix` implementation.


---

Comment by git created at 2018-09-14 01:07:27

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2018-09-14 01:10:51

Changing status from new to needs_review.


---

Comment by tscrim created at 2018-09-14 01:10:51

I've split the ticket into the two parts. This part is now ready for review.


---

Comment by tscrim created at 2018-09-14 05:02:32

(Essentially) Green patchbot.


---

Comment by jdemeyer created at 2018-09-14 07:49:20

So how about renaming to `PlusMinusOneMatrix`? I'd like the opinion of Stefan on that.


---

Comment by git created at 2018-09-16 22:47:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-09-16 22:48:21

I did the refactoring. Stefan, Rudi, any objections?


---

Comment by Stefan created at 2018-09-17 05:28:34

I am happy with the new name. Don’t have time for a long review.


---

Comment by dkrenn created at 2019-03-27 14:03:46

I've looked through the code and I am happy with it, so LGTM.

However contributed to this ticket (mainly review), please insert your name in the reviewer field.


---

Comment by dkrenn created at 2019-03-27 14:03:46

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2019-03-27 22:08:16

Stefan, Rudi I added you as reviewers based on our conversions above. Jeroen is obviously a reviewer for looking at the Cython code (as well as his additional useful insights).


---

Comment by vbraun created at 2019-03-29 12:36:45

Resolution: fixed
