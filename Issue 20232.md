# Issue 20232: Implement Ariki-Koike algebras

Issue created by migration from https://trac.sagemath.org/ticket/20469

Original creator: tscrim

Original creation time: 2016-04-19 19:07:57

Assignee: sage-combinat

CC:  sage-combinat stumpc5 andrew.mathas tscrim

Keywords: hecke algebra, complex reflection group, ariki-koike

An Ariki-Koike algebra is the Hecke algebra of the complex reflection group G(r,1,n).


---

Comment by tscrim created at 2016-05-06 03:45:01

Here is the first version. I still have to convert from Ariki-Koike's version to the Hu-Mathas definition, but this version seems to work (in particular, it passed a few of my associativity tests and the relations I tested). There is also more documentation that needs to be added. I'm also not completely satisfied with the default base ring. However, I wanted to get feedback.

Note that the multiplication is highly recursive. In particular, once there is an l<sub>i</sub><sup>r</sup> occurring, it can easily run into Python's recursion limit. It might be possible to work this out with handling the manipulations within the code here or doing parts of the multiplication in bigger chunks. However, this would take a lot of work I think to improve and the code works.

I am also planning on implementing the isomorphism with type A<sub>n</sub>/B<sub>n</sub> Hecke algebras shortly too.
----
New commits:


---

Comment by andrew.mathas created at 2016-05-06 04:44:18

Thanks Travis. This looks interesting. I will have a play with it and see if I can improve the multiplication with the tricks that I know about these algebras -- I am not promising that this will be possible, only to look!

Some initial comments: 
- It would be better to use `L1`,`...`,`Ln` for the Jucys-Murphy elements as this is what is commonly used in the literature and it's also consistent with using `T1`,`T2`,`...` for the Hecke generators. Using `l1`,`...`,`ln` looks strange to me.
- I am not sure that it is worth the effort to define the Hu-Mathas as the algebras that we defined are different to these when `q=1` and, more importantly, the conversion between the two is easy in principle but messy in practice. 
- The default base ring should be the smallest ring that contains `q`, `u0`,...,`ur`.
- At some stage I will polish the code that I have which implements the Specht modules for these algebras. Given this it would probably be a good idea to put this code in its own subdirectory so that the module code. Similarly, my graded Specht module could go in here to.


---

Comment by git created at 2016-05-06 16:41:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-05-06 16:56:27

Replying to [comment:3 andrew.mathas]:
> Thanks Travis. This looks interesting. I will have a play with it and see if I can improve the multiplication with the tricks that I know about these algebras -- I am not promising that this will be possible, only to look!

Great, thanks. It is currently so recursive that it fails for `L2 * L1 * L2` in `H(2,2)` (although `L1 * (L2)^2` works).

> - It would be better to use `L1`,`...`,`Ln` for the Jucys-Murphy elements as this is what is commonly used in the literature and it's also consistent with using `T1`,`T2`,`...` for the Hecke generators. Using `l1`,`...`,`ln` looks strange to me.

Done.

> - I am not sure that it is worth the effort to define the Hu-Mathas as the algebras that we defined are different to these when `q=1` and, more importantly, the conversion between the two is easy in principle but messy in practice.

This also leads to a question of what do we want to call the Hu-Mathas variant? In the future, we can also add another basis to this for `q \neq 1`. We also should probably add the basis indexed by the colored permutations (i.e., monomials in `T_0, ..., T_{n-1}`).

> - The default base ring should be the smallest ring that contains `q`, `u0`,...,`ur`.

With `q` invertible, that is what it currently does (just in a slightly funky way that groups the `u`'s together then the `q`'s).

> - At some stage I will polish the code that I have which implements the Specht modules for these algebras. Given this it would probably be a good idea to put this code in its own subdirectory so that the module code. Similarly, my graded Specht module could go in here to.

I have moved this into a `hecke_algebras` folder to start. We can move the rest of the Hecke algebras (e.g., Iwahori and Yokonuma) to this folder on a followup ticket.

While adding the documentation, I also found some errors with the multiplication that I have fixed.


---

Comment by git created at 2016-05-07 02:15:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-07-12 22:47:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2016-07-12 23:12:34

Hi Travis,

I have been through your code and fixed the recursion issue. It was actually an infinite recursion loop. The problem was that as the terms in the products `....T_i L_k...` were being put into standard form "letter-by-letter" (so changing the previous expression to `\sum ... L_m T_j...`) you sometimes ended up going around in circles by pushing a `T_i` past an `L_k` that then created a large power of some `L_m` that, when reduced, got you back to the previous situation. I have rewritten the `product_on_basis` code to avoid this, so I'm afraid that I've replaced this section of your code. The product code is now less recursive with terms largely being rewritten into standard form "in place". 

On top of this I proved a formula for the expansion of `L_k^m` that, embarrassingly, I later found in one of my papers. This was my first guess for improving the multiplication issues but once I'd made this change I discovered the recursion loop. The other main change is that I rescaled `L_k` to `q**{1-k}*L_k`, in [AK] notation, because this renormalisation is what is normally used in the literature as it works better with the combinatorics.

I have made a start at adding the documentation.  As a result of the rescaling of the `L_k`'s quite a lot of doc-tests are currently failing, being off by the corresponding power of `q`. I am happy to fix these. I left them in only so that you can compare if you wish. I am also happy to fill out the documentation as I know this area quite well.

Other issues that we could think about are:
- whether to allow the two parameter version: `(T_i-q1)(T_i+q2)=0`. Probably quite painful as all of the product formulas will change
- whether to implement the degenerate algebras. This might be easy as it could be done as a derived class with slightly different `_product_LTwTv`, `_product_Tw_L`, and `_Li_power` methods
- I think having a slightly shorter `_repr_` string would be a good idea: `Ariki-Koike algebra of rank 5 with parameters q,u0,u2,u3` is enough I think
- implementing other bases? This is probably best left for another ticket...especially as I think that the realisations code currently requires that the same indexing sets be used(?)

Any way, I think that the code now works. Please have a look and let me know what you think. Happy to be a reviewer or coauthor on the ticket as you think best.

Andrew


---

Comment by andrew.mathas created at 2016-07-12 23:17:22

ps. With the degenerate algebras, the other option would be to use the Hu-Mathas presentation for the "main" algebra (this combines the Ariki-Koike algebras with `q\ne1` and the degenerate AK algebras (when `q=1`) and then implement the `q=1` version of the Ariki-Koike algebras as the "extra" case. I am biased, but personally I think that makes more sense because the Hu-M. presentation fits with the KLR categorifiction of integrable highest weight modules perfectly whereas the Ariki-Koike presentation does not.


---

Comment by tscrim created at 2016-07-13 02:19:05

Replying to [comment:8 andrew.mathas]:
> I have been through your code and fixed the recursion issue. It was actually an infinite recursion loop. The problem was that as the terms in the products `....T_i L_k...` were being put into standard form "letter-by-letter" (so changing the previous expression to `\sum ... L_m T_j...`) you sometimes ended up going around in circles by pushing a `T_i` past an `L_k` that then created a large power of some `L_m` that, when reduced, got you back to the previous situation. I have rewritten the `product_on_basis` code to avoid this, so I'm afraid that I've replaced this section of your code. The product code is now less recursive with terms largely being rewritten into standard form "in place". 

Thank you very much for looking through this code and fixing the problem(s). Sorry it ended up being a bit of a mess. I'm very happy you were able to improve it.

> On top of this I proved a formula for the expansion of `L_k^m` that, embarrassingly, I later found in one of my papers. This was my first guess for improving the multiplication issues but once I'd made this change I discovered the recursion loop. The other main change is that I rescaled `L_k` to `q**{1-k}*L_k`, in [AK] notation, because this renormalisation is what is normally used in the literature as it works better with the combinatorics.

I probably could have looked harder in the literature. I'm okay with the renormalization (especially since I have more of an interest in the combinatorics too). I just kept the [AK] normalization since I was using that as my reference and didn't trust myself to correctly handle the renormalization.

> I have made a start at adding the documentation.  As a result of the rescaling of the `L_k`'s quite a lot of doc-tests are currently failing, being off by the corresponding power of `q`. I am happy to fix these. I left them in only so that you can compare if you wish. I am also happy to fill out the documentation as I know this area quite well.

I would appreciate all of your expertise in writing the documentation. I can go over it and do any necessary formatting. I can also fix the doctests afterwards.

> Other issues that we could think about are:
> - whether to allow the two parameter version: `(T_i-q1)(T_i+q2)=0`. Probably quite painful as all of the product formulas will change

I think it is good to try and be as general as possible when it is not much work. I agree, I think it would be very annoying to switch because we would have to redo all of the product formulas (at least, I would have to put some thought on how to do this to make everything consistent). So, I think this is plenty good for now.

> - whether to implement the degenerate algebras. This might be easy as it could be done as a derived class with slightly different `_product_LTwTv`, `_product_Tw_L`, and `_Li_power` methods

> - I think having a slightly shorter `_repr_` string would be a good idea: `Ariki-Koike algebra of rank 5 with parameters q,u0,u2,u3` is enough I think

I think we should give the base ring to better differentiate the instances. Plus this is consistent with what we do elsewhere in Sage. One slight issue is the default ring is a polynomial ring over a polynomial ring, and it is this that makes the repr very long. I decided to do this for the default ring so the q's would be grouped together.

> - implementing other bases? This is probably best left for another ticket...especially as I think that the realisations code currently requires that the same indexing sets be used(?)

I agree; this should be another ticket unless you have code ready. The realizations code itself does not require the same indexing set, but you have to do a bit more with the morphisms. For an example, see the descent algebra (`combinat/descent_algebra.py`).

> Any way, I think that the code now works. Please have a look and let me know what you think. Happy to be a reviewer or coauthor on the ticket as you think best.

I will play around with in shortly. We will both be both coauthors and reviewers (yet again :P).

Replying to [comment:9 andrew.mathas]:
> ps. With the degenerate algebras, the other option would be to use the Hu-Mathas presentation for the "main" algebra (this combines the Ariki-Koike algebras with `q\ne1` and the degenerate AK algebras (when `q=1`) and then implement the `q=1` version of the Ariki-Koike algebras as the "extra" case. I am biased, but personally I think that makes more sense because the Hu-M. presentation fits with the KLR categorifiction of integrable highest weight modules perfectly whereas the Ariki-Koike presentation does not. 

I'm +1 for getting things closer to the KLR algebra (something that I hope to eventually get into Sage at some point). Otherwise I don't have an opinion on which presentation we use. How much would have to be changed in order to move to the Hu-Mathas presentation?


---

Comment by andrew.mathas created at 2016-07-13 14:50:36

Replying to [comment:10 tscrim]:
> Replying to [comment:8 andrew.mathas]:

> I'm +1 for getting things closer to the KLR algebra (something that I hope to eventually get into Sage at some point). Otherwise I don't have an opinion on which presentation we use. How much would have to be changed in order to move to the Hu-Mathas presentation?

With all of these things it is mainly a matter of implementing appropriate analogues of the three methods `_product_LTwTv`, `_product_Tw_L`, and `_Li_power` that underpin the multiplication. Replacing `q` with a two variable version may be the hardest option as we'd have to think what the appropriate normalisation of the Jucys-Murphy elements is. This said, I would prefer to have the more symmetric relations `(T_i-q)(T_i+q^{-1})=0`, so I will have a think about this.

Regarding KLR algebras, implementing the "affine" KLR algebras is reasonably straightforward. I know now of a way to do the cyclotomic quotients in a few cases and I will implement them at some point, although the isomorphism to the ungraded algebras is much harder to do.


---

Comment by tscrim created at 2016-07-15 03:54:30

Replying to [comment:11 andrew.mathas]:
> Replying to [comment:10 tscrim]:
> > Replying to [comment:8 andrew.mathas]:
> 
> > I'm +1 for getting things closer to the KLR algebra (something that I hope to eventually get into Sage at some point). Otherwise I don't have an opinion on which presentation we use. How much would have to be changed in order to move to the Hu-Mathas presentation?
> 
> With all of these things it is mainly a matter of implementing appropriate analogues of the three methods `_product_LTwTv`, `_product_Tw_L`, and `_Li_power` that underpin the multiplication. Replacing `q` with a two variable version may be the hardest option as we'd have to think what the appropriate normalisation of the Jucys-Murphy elements is. This said, I would prefer to have the more symmetric relations `(T_i-q)(T_i+q^{-1})=0`, so I will have a think about this.

I believe I've said this above, but to be pedantic, I have no preference as to what quadratic relation is. How much could be obtained by looking at the affine Hecke algebra and passing to the quotient?

> Regarding KLR algebras, implementing the "affine" KLR algebras is reasonably straightforward. I know now of a way to do the cyclotomic quotients in a few cases and I will implement them at some point, although the isomorphism to the ungraded algebras is much harder to do.

Please cc me on that ticket when you create it. I would be happy to review it.


---

Comment by git created at 2017-08-09 05:42:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-09 14:18:14

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-05-02 04:38:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-05-02 04:40:39

I've found and fixed 2 bugs with the multiplication:

1. In `_product_LTwTv`, the coefficient `c` was not being multiplied in the second term.
2. In `_Li_power`, the formula was suppose to be q<sup>-1</sup> (q - 1) = 1 - q<sup>-1</sup>, but instead it was q - q<sup>-1</sup>. This fixes the associativity test.

Now all doctests are currently passing.


---

Comment by git created at 2018-05-02 05:41:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-05-30 11:02:59

Changing status from new to needs_review.


---

Comment by tscrim created at 2018-05-30 11:02:59

Here is a version with 2 bases: the `T` basis given by BM and `LT` basis given by AK.

From some testing, the `T` basis implementation is (currently) clearly the better basis:

```
sage: def test(B):
....:     for b in B:
....:         for bp in B:
....:             b * bp
....:             
sage: H = algebras.ArikiKoike(3, 3)
sage: LT = H.LT()
sage: T = H.T()
sage: %time test(LT.basis())
CPU times: user 4min 30s, sys: 1.64 s, total: 4min 31s
Wall time: 4min 31s
sage: %time test(T.basis())
CPU times: user 1min 40s, sys: 739 ms, total: 1min 41s
Wall time: 1min 40s
```

In particular, this `LT` basis computation took over 5GB of RAM, whereas the `T` basis computation took less than 2GB. (The computation above involves all 26244 possible products.) The speed difference also holds for smaller dimensional spaces.


---

Comment by tscrim created at 2018-05-30 11:03:33

Changing keywords from "hecke algebra, complex reflection group, ariki-koike" to "hecke algebra, complex reflection group, ariki-koike, days93.51".


---

Comment by tscrim created at 2018-05-31 07:09:31

Last 10 new commits:


---

Comment by git created at 2018-05-31 15:14:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-01 10:04:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-01 10:20:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2018-08-03 19:20:18

update milestone 8.3 -> 8.4


---

Comment by chapoton created at 2018-08-11 18:57:55

some typos:

```
OUPTUT
```


```
These element different by a power of `q` from the corresponding
```


```
an tuple
```

missing `\` in 

```
+.. [BM1997] K. Bremke and G. Malle,
```



---

Comment by chapoton created at 2018-09-29 12:52:31

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2018-09-29 12:52:31

branch is red


---

Comment by git created at 2018-12-07 19:46:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-12-07 19:47:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2018-12-07 19:48:03

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2019-01-16 07:39:52

one failing doctest, see patchbot


---

Comment by chapoton created at 2019-01-16 07:39:52

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-03-13 11:08:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-03-13 11:12:02

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2020-03-13 11:12:02

Thanks to Sebastian doing some very thorough testing in looking at changing the index set, I came across a subtle bug in the T multiplication. When performing the reduction of the T<sub>0</sub><sup>r</sup> in T<sub>k,a</sub>, we can have a T<sub>0</sub><sup>0</sup>, which we want to "represent" as T<sub>k,0</sub>, but this is defined as `1`. So we have lost track of the s<sub>k-1</sub> ... s<sub>1</sub> permutation. This has now been fixed.


---

Comment by chapoton created at 2020-03-14 19:23:04

There seems to be some missing `r"""` that cause 3 "invalid escape sequences", see patchbot report.


---

Comment by git created at 2020-03-15 22:28:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-03-15 22:31:29

Thanks. Fixed.


---

Comment by soehms created at 2020-03-17 15:46:43

It seems that you missed to fix this:


```
sage: H = algebras.ArikiKoike(3, 4)
sage: LT = H.LT()
sage: LT.inject_variables()
Defining L1, L2, L3, L4, T1, T2, T3
sage: LT._Li_power(2,4) == L2 * LT._Li_power(2,3)
False
```



---

Comment by tscrim created at 2020-03-17 22:46:37

Replying to [comment:37 soehms]:
> It seems that you missed to fix this:
> 
> {{{
> sage: H = algebras.ArikiKoike(3, 4)
> sage: LT = H.LT()
> sage: LT.inject_variables()
> Defining L1, L2, L3, L4, T1, T2, T3
> sage: LT._Li_power(2,4) == L2 * LT._Li_power(2,3)
> False
> }}}

I do not think there is need to fix that because `_Li_power` is only used in the internal multiplication, which ultimately cancels or resolves out the issues with not doing proper reduction of the the L<sub>i</sub><sup>k</sup>. By not doing as many resolutions (which can generate large number of terms), it should be faster. Should I add something to the `_Li_power` docstring about this or run some timings to confirm?


---

Comment by soehms created at 2020-03-18 11:06:19

Replying to [comment:38 tscrim]:
> Replying to [comment:37 soehms]:
> > It seems that you missed to fix this:
> > 
> > {{{
> > sage: H = algebras.ArikiKoike(3, 4)
> > sage: LT = H.LT()
> > sage: LT.inject_variables()
> > Defining L1, L2, L3, L4, T1, T2, T3
> > sage: LT._Li_power(2,4) == L2 * LT._Li_power(2,3)
> > False
> > }}}
> 
> I do not think there is need to fix that because `_Li_power` is only used in the internal multiplication, which ultimately cancels or resolves out the issues with not doing proper reduction of the the L<sub>i</sub><sup>k</sup>. By not doing as many resolutions (which can generate large number of terms), it should be faster.

Ah, I forgot about that explanation!

> Should I add something to the `_Li_power` docstring about this or run some timings to confirm?

I think a comment on that would make sense, since `LT._Li_power(2,4) == L2**4` giving `False` is quite irritating.


---

Comment by git created at 2020-03-19 00:07:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-03-19 00:09:48

I ran some timings to confirm my suspicions, and here is what I found:

```
sage: def test(LT):
....:     B = LT.basis()
....:     for b in B:
....:         for bp in B:
....:             dummy = b * bp
sage: H = algebras.ArikiKoike(4, 2)
sage: LT = H.LT()
sage: %time test(LT)
CPU times: user 3.49 s, sys: 6.16 ms, total: 3.5 s
Wall time: 3.5 s
sage: H = algebras.ArikiKoike(5, 2)
sage: LT = H.LT()
sage: %time test(LT)
CPU times: user 2min 50s, sys: 446 ms, total: 2min 51s
Wall time: 2min 51s
```

versus always resolving it out:

```
sage: H = algebras.ArikiKoike(4, 2)
sage: LT = H.LT()
sage: %time test(LT)
CPU times: user 3.16 s, sys: 23.5 ms, total: 3.18 s
Wall time: 3.18 s
sage: H = algebras.ArikiKoike(5, 2)
sage: LT = H.LT()
sage: %time test(LT)
CPU times: user 3min 14s, sys: 463 ms, total: 3min 14s
Wall time: 3min 14s
```

So it seems to be inconsistent with which one is better strangely enough. Memory-wise they seem to be similar. The latter is ~11% slower. So I implemented a hybrid approach and here is the timings for that:

```
sage: H = algebras.ArikiKoike(4, 2)
sage: LT = H.LT()
sage: %time test(LT)
CPU times: user 3.27 s, sys: 25.4 ms, total: 3.29 s
Wall time: 3.33 s
sage: H = algebras.ArikiKoike(5, 2)
sage: LT = H.LT()
sage: %time test(LT)
CPU times: user 3min 17s, sys: 389 ms, total: 3min 17s
Wall time: 3min 17s
```

So I think I will go with the hybrid, trying keep some of the benefits of both (less multiplication and strict correctness at intermediate steps). I suspect the last timing is a little skewed because I was doing a few other things on my computer at the time.


---

Comment by soehms created at 2020-03-20 20:47:28

Replying to [comment:41 tscrim]:

> So I think I will go with the hybrid, trying keep some of the benefits of both (less multiplication and strict correctness at intermediate steps). I suspect the last timing is a little skewed because I was doing a few other things on my computer at the time.

Are you sure you want to keep the hybrid version? I repeated your test and the timing comparison was even worse.

What about the following suggestion: Rename `_Li_power` as something like `_prepare_Li_power` to avoid such irritation. In addition, leave your new test in the docstring returning `False` as an example that this method does not give the final result (but for this purpose you have to run it for `algebras.ArikiKoike(3, 4)`).

Furthermore, the local function `L` in `_Li_power` seems not to be used any more. Can't we delete it?


---

Comment by tscrim created at 2020-03-20 21:46:00

Replying to [comment:42 soehms]:
> Replying to [comment:41 tscrim]:
> 
> > So I think I will go with the hybrid, trying keep some of the benefits of both (less multiplication and strict correctness at intermediate steps). I suspect the last timing is a little skewed because I was doing a few other things on my computer at the time.
> 
> Are you sure you want to keep the hybrid version? I repeated your test and the timing comparison was even worse.

Which timings? I agree this will probably be worse than the previous version, but it cannot be worse than the fully-reduced-to-basis version.

> What about the following suggestion: Rename `_Li_power` as something like `_prepare_Li_power` to avoid such irritation. In addition, leave your new test in the docstring returning `False` as an example that this method does not give the final result (but for this purpose you have to run it for `algebras.ArikiKoike(3, 4)`).

I think that name is less descriptive. Plus it gives the correct result, just not necessarily in the basis elements, which is okay for an internal function not visible to the standard user. So if we decide revert the change, then I think just a warning would be sufficient.

> Furthermore, the local function `L` in `_Li_power` seems not to be used any more. Can't we delete it?

Yes, we can delete it.


---

Comment by soehms created at 2020-03-21 15:14:42

Replying to [comment:43 tscrim]:
> Which timings? I agree this will probably be worse than the previous version, but it cannot be worse than the fully-reduced-to-basis version.

Of course, I meant in the comparison with the previous version!

> So if we decide revert the change, then I think just a warning would be sufficient.

Agreed! 

Once this is done from my point of view we can let the ticket pass.


---

Comment by git created at 2020-03-22 22:43:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-03-22 22:44:40

Replying to [comment:44 soehms]:
> Replying to [comment:43 tscrim]:
> > So if we decide revert the change, then I think just a warning would be sufficient.
> 
> Agreed! 
> 
> Once this is done from my point of view we can let the ticket pass.

Done. Thank you! Please set to a final positive review if you are happy with my changes.


---

Comment by git created at 2020-03-23 06:57:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by soehms created at 2020-03-23 07:00:44

Changing status from needs_review to positive_review.


---

Comment by soehms created at 2020-03-23 07:00:44

Replying to [comment:46 tscrim]:
> Done. Thank you! Please set to a final positive review if you are happy with my changes.

Yes, I am (just fixed a patchbot hint)! Thanks, as well.


---

Comment by git created at 2020-03-23 07:08:35

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2020-03-23 07:08:35

Changing status from positive_review to needs_review.


---

Comment by tscrim created at 2020-03-23 08:19:29

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2020-03-23 08:19:29

Thank you.


---

Comment by vbraun created at 2020-03-29 00:24:23

Resolution: fixed
