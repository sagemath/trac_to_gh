# Issue 18803: defuse bool(x!=0) performance bomb

Issue created by migration from Trac.

Original creator: rws

Original creation time: 2015-08-16 06:07:21

CC:  leif behackl kcrisman eviatarbach

Symbolics may be part of type-neutral computations, e.g. matrices, rings. Developers do not expect proof machinery to crank up when writing `if x!=0`, so `bool(x1!=x2)` should mean `not (x1-x2).is_trivial_zero()` for symbolic `x`. Instead of `Expression.__nonzero__` this ticket should provide a different interface for cases requiring simplification/proof.


---

Comment by vdelecroix created at 2015-08-16 09:20:29

Be careful that in a lot of Sage place there are

```
def my_generic_function(x):
    if not x:
        ...
    else:
        ...
```

or with `not x` replaced by `x.is_zero()`.

So this change would also implies to change all of these in a uniform way.


---

Comment by rws created at 2015-08-17 05:30:14

Replying to [comment:1 vdelecroix]:
> `    if not x:`
`bool(not x)` calls `PyObject_IsTrue` which calls `Expression.__nonzero__` which atm tries to prove that `x` is nonzero
> or with `not x` replaced by `x.is_zero()`.
This calls `PyObject_IsTrue` as well.
> So this change would also implies to change all of these in a uniform way.
Right, `Expression.__nonzero__` will then call `x.is_trivial_zero()` and everyone who wants a proof needs a dfferent method.


---

Comment by rws created at 2015-08-17 08:45:56

It's not too bad. Catching `!=` and `==` in `__nonzero__` and comparing trivially yields only a few dozen doctest fails in `symbolic` and `calculus`, mainly from `bool(...)`. No fail in `src/doc`.


---

Comment by vdelecroix created at 2015-08-17 09:03:52

I agree that the change would be actually good (for the reason why you created this ticket). 

Thoug, for symbolic expression we want to create equations and check their validity

```
sage: cos(x)**2 + sin(x)**2 == 1
cos(x) == sin(x)
sage: bool(_)
True
```

The above will not be enough anymore. What would be the new way of checking? This needs to be emphasized a lot in the documentation as it is backward incompatible. And I guess it is worth a thread on sage-devel. Not necessarily right now, it is always good to have concrete propositions.

You should also have a look to `sage/tests/*` where I am sure some of the things are broken.


---

Comment by rws created at 2015-08-17 13:40:33

Replying to [comment:4 vdelecroix]:
> Thoug, for symbolic expression we want to create equations and check their validity
> {{{
> sage: cos(x)**2 + sin(x)**2 == 1
> cos(x) == sin(x)
> sage: bool(_)
> True
> }}}
> The above will not be enough anymore. What would be the new way of checking?

```
sage: satisfiable(_)
True
```

This is a long-standing omission, and it would resolve conceptual problems of #17700. It would use #19000 and, if that finds no solution, Maxima as before. SMT solvers can also give a satisfying `x` in case of satisfiability, but no full solution which is the task of `solve`.

> This needs to be emphasized a lot in the documentation as it is backward incompatible. And I guess it is worth a thread on sage-devel. Not necessarily right now, it is always good to have concrete propositions.
> 
> You should also have a look to `sage/tests/*` where I am sure some of the things are broken.
Three fails.


---

Comment by rws created at 2015-08-17 15:18:15

Replying to [comment:5 rws]:
> It would use #19000
Could. #19000 is not a necessity.


---

Comment by rws created at 2015-08-17 15:43:51

Actually, proving equality would need quantifiers like:

```
sage: satisfiable(_, for_all(x))
True
```



---

Comment by rws created at 2015-09-08 15:10:40

New commits:


---

Comment by git created at 2015-09-09 08:05:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-09-16 08:01:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-09-21 13:56:51

It may not be possible to get the desired behaviour in the `structure/parent.pyx` doctests, so we oblige `Parent.__contains__` by throwing an exception if `lhs-rhs` contains inexact ring elements. This way inclusion in those rings (i.e., `pi in CC == True`) is always guaranteed as before.
----
New commits:


---

Comment by vdelecroix created at 2015-09-21 14:12:18

A small remark: From the documentation of the method `holds`

```
If Sage knows exactly that the relation is
undecidable it will throw an ``AttributeError``.
```

For *one* relation there *always* is an algorithm which is either `return True` or `return False`. What is not possible is to design an algorithm whose input is an equation and answers the validity of the input. Your sentence makes no sense. A right formulation would be

```
If Sage does not know if the equation is valid it will
throw a ``NotImplementedError``. Note that the validity
of equations is an undecidable problem. Hence there will
always be instances for which such error is raised.
```

(`AttributeError` makes no sense here).


---

Comment by rws created at 2015-09-23 16:19:00

Changing status from new to needs_review.


---

Comment by rws created at 2015-09-23 16:19:00

This should be it. Please review.
----
New commits:


---

Comment by rws created at 2015-09-26 07:09:14

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-09-27 06:46:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-09-27 06:47:26

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-09-27 06:51:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-10-15 05:52:48

Changing status from needs_review to needs_work.


---

Comment by rws created at 2015-10-15 05:52:48

Patchbot failures in hyperbolic space.


---

Comment by rws created at 2015-10-16 15:50:36

This code cannot be separated from #19312 so I included it there. I'll let this ticket stay here for the description unless someone objects.


---

Comment by rws created at 2015-10-16 15:50:36

Changing status from needs_work to needs_info.


---

Comment by jdemeyer created at 2015-10-16 17:10:24

Replying to [comment:34 rws]:
> This code cannot be separated from #19312

Please explain why.


---

Comment by rws created at 2015-10-17 07:47:59

Replying to [comment:35 jdemeyer]:
> Replying to [comment:34 rws]:
> > This code cannot be separated from #19312
> 
> Please explain why.

Correction: an advanced version of this code cannot be separated from #19312. So, this is already obsolete. If, however, #19312 merge is not in the forseeable future I'll consider presenting this branch for review again.


---

Comment by jdemeyer created at 2015-10-17 09:35:16

I would much prefer to separate #19040 from #19312, mainly to make the review easier (reviewing a package upgrade plus a huge number of Sage library changes is difficult).


---

Comment by rws created at 2015-10-17 15:37:47

This will make it necessary to implement some (fast) functions from Pynac-0.5 in Python to achieve the same result. The two remaining fails are quite demanding.


---

Comment by rws created at 2015-10-19 15:16:29

I succeeded to separate #19040 from #19312, so this branch needs rewrite after #19312 is merged.


---

Comment by vdelecroix created at 2015-11-27 20:03:58

What would be the difference between the output `NotImplemented` and `Undecidable`!?

As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.

In an ideal world, the function `satisfiable(expr)` would return one of:
 - `(True, example)`
 - `(False, proof)`
 - `NotImplemented`


---

Comment by vdelecroix created at 2015-11-27 20:06:09

other remark: If I understand correctly `satisfiable` would corresponds to a *exists* quantifier for *all* the variables in the formula. While the `holds` would correspond to *for all*. What about something more elaborate such as

```
  for all x, exists y, for all z  expr(x,y,z)
```



---

Comment by rws created at 2015-11-28 07:18:01

Replying to [comment:41 vdelecroix]:
> What would be the difference between the output `NotImplemented` and `Undecidable`!?
> 
> As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.
Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.
>`for all x, exists y, for all z  expr(x,y,z)`
Such will not be in the first versions.


---

Comment by vdelecroix created at 2015-11-28 12:17:25

Replying to [comment:43 rws]:
> Replying to [comment:41 vdelecroix]:
> > What would be the difference between the output `NotImplemented` and `Undecidable`!?
> > 
> > As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.
> Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.

What do you mean? Do you have an example of such inequality?

> >`for all x, exists y, for all z  expr(x,y,z)`
> Such will not be in the first versions.

But do you have a syntax in mind for it. It would be cool to not multiply ad libitum the `satisfiable`, `holds`, etc which are exactly the same thing with a choice of quantifiers.


---

Comment by rws created at 2015-11-28 13:47:15

Replying to [comment:44 vdelecroix]:
> Replying to [comment:43 rws]:
> > Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.
> 
> What do you mean? Do you have an example of such inequality?
Comparison of real/infinity with complex.

> > >`for all x, exists y, for all z  expr(x,y,z)`
> > Such will not be in the first versions.
> 
> But do you have a syntax in mind for it. It would be cool to not multiply ad libitum the `satisfiable`, `holds`, etc which are exactly the same thing with a choice of quantifiers.
No syntax in my mind. There could be precedents in SMT-solvers which could be copied.


---

Comment by vdelecroix created at 2015-11-28 13:53:30

Replying to [comment:45 rws]:
> Replying to [comment:44 vdelecroix]:
> > Replying to [comment:43 rws]:
> > > Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.
> > 
> > What do you mean? Do you have an example of such inequality?
> Comparison of real/infinity with complex.

Then I would qualify this as undefined and not undecidable. The latter introduces confusion with the standard notion related to proofs and computability.


---

Comment by rws created at 2016-02-24 13:57:40

I will upload a fresh branch with this.


---

Comment by cheuberg created at 2016-02-26 06:32:04

Replying to [comment:5 rws]:
> > You should also have a look to `sage/tests/*` where I am sure some of the things are broken.
> Three fails.

Which probably means lots of user code being broken, see my experience on [sage-devel](https://groups.google.com/d/topic/sage-devel/ojHqBy7oUVU/discussion).

In my opinion, for any change in this area, be it fixing a perceived bug or not, we definitely need a deprecation. We do not need on what user's code relies and `sage/tests/*` is in no ways a representative sample (but even some code fails there).

The existing deprecation framework may not be enough: for some time, old and new code should be compared and a warning should be raised if the outcome is different. Users should be able to silence this warning once they have converted their code to the new behaviour; and the sage library should also silence the warning for its own use only. No idea how to implement this nicely, but I see no other option.


---

Comment by rws created at 2016-02-27 07:47:26

The easiest way for the user to see if behaviour has changed is to give the command `git diff original-version /path/to/file` and check if doctests were changed. Since the system is huge and users have different needs you either need to do this yourself or Sage automates this by providing some sort of subscription service. Since Sage cannot know which of your changes should be monitored for different behaviour (because there is no distinction between a user adding code and a developer adding code), you would need to initiate this subscription yourself. Anyway, a deprecation message every time `bool(relation)` is called is out of the question, much more so for all possible changes to Sage. Also, performance would suffer because of all the checks.

You seem to be of the opinion that there exists a representative sample of tests that covers all eventualities. Needless to say there isn't---however, Sage development tries to come close with the code coverage tools. I think a good dose of realism can be gathered from, for example https://www.youtube.com/watch?v=VfRVz1iqgKU


---

Comment by cheuberg created at 2016-02-28 05:41:35

The discussion is perhaps theoretical at this moment because there is no branch attached, so I do not know what will actually change.

Replying to [comment:51 rws]:
> The easiest way for the user to see if behaviour has changed is to give the command `git diff original-version /path/to/file` and check if doctests were changed. Since the system is huge and users have different needs you either need to do this yourself or Sage automates this by providing some sort of subscription service.

We are speaking about users, not developers.

The most we could perhaps expect from users is to read well-written release notes giving a hint what changed. We do not currently have those.

> Since Sage cannot know which of your changes should be monitored for different behaviour (because there is no distinction between a user adding code and a developer adding code), you would need to initiate this subscription yourself. Anyway, a deprecation message every time `bool(relation)` is called is out of the question, much more so for all possible changes to Sage. Also, performance would suffer because of all the checks.

Library code could call a _new_ method or something like that. But it is certainly ugly.

We do have a deprecation policy for much less serious cases: if a method is renamed, we have a one-year deprecation period; the only harm done is that a user gets a message that a method does no longer exist.

Changing the behaviour of `bool(...)` *silently* leads to different results which might be wrong.

I see the following options:
1. Not changing fundamental behaviour.
2. Changing fundamental behaviour at some really *major* release where we support old user code for much longer than usual (compare Python 2/Python 3)
3. Some kind of deprecation system

Simply making a fundamental change in a random version (say 7.2) and letting users alone with their old code is not an option for me.

> You seem to be of the opinion that there exists a representative sample of tests that covers all eventualities.

Certainly not, I think the contrary.

I was surprised that at some point on this ticket, changed behaviour was caught by tests in `src/sage/tests`, given that those tests there seem to be quite random.


---

Comment by rws created at 2016-02-28 08:29:24

Replying to [comment:52 cheuberg]:
> 
> The discussion is perhaps theoretical at this moment because there is no branch attached, so I do not know what will actually change.
The branch is not listed in the ticket field but the recent commits are visible in the comments. The branch can be checked out via `git trac checkout 19040 --branch=u/rws/19040-2`.


---

Comment by rws created at 2016-03-09 03:37:43

A good way to contribute to this is to review #16397. Mixed order comparison is part of the branch mentioned above.
