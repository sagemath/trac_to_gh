# Issue 18803: defuse bool(x!=0) performance bomb

archive/issues_018803.json:
```json
{
    "body": "CC:  leif behackl kcrisman eviatarbach\n\nSymbolics may be part of type-neutral computations, e.g. matrices, rings. Developers do not expect proof machinery to crank up when writing `if x!=0`, so `bool(x1!=x2)` should mean `not (x1-x2).is_trivial_zero()` for symbolic `x`. Instead of `Expression.__nonzero__` this ticket should provide a different interface for cases requiring simplification/proof.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19040\n\n",
    "created_at": "2015-08-16T06:07:21Z",
    "labels": [
        "symbolics",
        "major",
        "enhancement"
    ],
    "title": "defuse bool(x!=0) performance bomb",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18803",
    "user": "rws"
}
```
CC:  leif behackl kcrisman eviatarbach

Symbolics may be part of type-neutral computations, e.g. matrices, rings. Developers do not expect proof machinery to crank up when writing `if x!=0`, so `bool(x1!=x2)` should mean `not (x1-x2).is_trivial_zero()` for symbolic `x`. Instead of `Expression.__nonzero__` this ticket should provide a different interface for cases requiring simplification/proof.

Issue created by migration from https://trac.sagemath.org/ticket/19040





---

archive/issue_comments_257084.json:
```json
{
    "body": "Be careful that in a lot of Sage place there are\n\n```\ndef my_generic_function(x):\n    if not x:\n        ...\n    else:\n        ...\n```\n\nor with `not x` replaced by `x.is_zero()`.\n\nSo this change would also implies to change all of these in a uniform way.",
    "created_at": "2015-08-16T09:20:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257084",
    "user": "vdelecroix"
}
```

Be careful that in a lot of Sage place there are

```
def my_generic_function(x):
    if not x:
        ...
    else:
        ...
```

or with `not x` replaced by `x.is_zero()`.

So this change would also implies to change all of these in a uniform way.



---

archive/issue_comments_257085.json:
```json
{
    "body": "Replying to [comment:1 vdelecroix]:\n> `    if not x:`\n`bool(not x)` calls `PyObject_IsTrue` which calls `Expression.__nonzero__` which atm tries to prove that `x` is nonzero\n> or with `not x` replaced by `x.is_zero()`.\nThis calls `PyObject_IsTrue` as well.\n> So this change would also implies to change all of these in a uniform way.\nRight, `Expression.__nonzero__` will then call `x.is_trivial_zero()` and everyone who wants a proof needs a dfferent method.",
    "created_at": "2015-08-17T05:30:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257085",
    "user": "rws"
}
```

Replying to [comment:1 vdelecroix]:
> `    if not x:`
`bool(not x)` calls `PyObject_IsTrue` which calls `Expression.__nonzero__` which atm tries to prove that `x` is nonzero
> or with `not x` replaced by `x.is_zero()`.
This calls `PyObject_IsTrue` as well.
> So this change would also implies to change all of these in a uniform way.
Right, `Expression.__nonzero__` will then call `x.is_trivial_zero()` and everyone who wants a proof needs a dfferent method.



---

archive/issue_comments_257086.json:
```json
{
    "body": "It's not too bad. Catching `!=` and `==` in `__nonzero__` and comparing trivially yields only a few dozen doctest fails in `symbolic` and `calculus`, mainly from `bool(...)`. No fail in `src/doc`.",
    "created_at": "2015-08-17T08:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257086",
    "user": "rws"
}
```

It's not too bad. Catching `!=` and `==` in `__nonzero__` and comparing trivially yields only a few dozen doctest fails in `symbolic` and `calculus`, mainly from `bool(...)`. No fail in `src/doc`.



---

archive/issue_comments_257087.json:
```json
{
    "body": "I agree that the change would be actually good (for the reason why you created this ticket). \n\nThoug, for symbolic expression we want to create equations and check their validity\n\n```\nsage: cos(x)**2 + sin(x)**2 == 1\ncos(x) == sin(x)\nsage: bool(_)\nTrue\n```\n\nThe above will not be enough anymore. What would be the new way of checking? This needs to be emphasized a lot in the documentation as it is backward incompatible. And I guess it is worth a thread on sage-devel. Not necessarily right now, it is always good to have concrete propositions.\n\nYou should also have a look to `sage/tests/*` where I am sure some of the things are broken.",
    "created_at": "2015-08-17T09:03:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257087",
    "user": "vdelecroix"
}
```

I agree that the change would be actually good (for the reason why you created this ticket). 

Thoug, for symbolic expression we want to create equations and check their validity

```
sage: cos(x)**2 + sin(x)**2 == 1
cos(x) == sin(x)
sage: bool(_)
True
```

The above will not be enough anymore. What would be the new way of checking? This needs to be emphasized a lot in the documentation as it is backward incompatible. And I guess it is worth a thread on sage-devel. Not necessarily right now, it is always good to have concrete propositions.

You should also have a look to `sage/tests/*` where I am sure some of the things are broken.



---

archive/issue_comments_257088.json:
```json
{
    "body": "Replying to [comment:4 vdelecroix]:\n> Thoug, for symbolic expression we want to create equations and check their validity\n> {{{\n> sage: cos(x)**2 + sin(x)**2 == 1\n> cos(x) == sin(x)\n> sage: bool(_)\n> True\n> }}}\n> The above will not be enough anymore. What would be the new way of checking?\n\n```\nsage: satisfiable(_)\nTrue\n```\n\nThis is a long-standing omission, and it would resolve conceptual problems of #17700. It would use #19000 and, if that finds no solution, Maxima as before. SMT solvers can also give a satisfying `x` in case of satisfiability, but no full solution which is the task of `solve`.\n\n> This needs to be emphasized a lot in the documentation as it is backward incompatible. And I guess it is worth a thread on sage-devel. Not necessarily right now, it is always good to have concrete propositions.\n> \n> You should also have a look to `sage/tests/*` where I am sure some of the things are broken.\nThree fails.",
    "created_at": "2015-08-17T13:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257088",
    "user": "rws"
}
```

Replying to [comment:4 vdelecroix]:
> Thoug, for symbolic expression we want to create equations and check their validity
> {{{
> sage: cos(x)**2 + sin(x)**2 == 1
> cos(x) == sin(x)
> sage: bool(_)
> True
> }}}
> The above will not be enough anymore. What would be the new way of checking?

```
sage: satisfiable(_)
True
```

This is a long-standing omission, and it would resolve conceptual problems of #17700. It would use #19000 and, if that finds no solution, Maxima as before. SMT solvers can also give a satisfying `x` in case of satisfiability, but no full solution which is the task of `solve`.

> This needs to be emphasized a lot in the documentation as it is backward incompatible. And I guess it is worth a thread on sage-devel. Not necessarily right now, it is always good to have concrete propositions.
> 
> You should also have a look to `sage/tests/*` where I am sure some of the things are broken.
Three fails.



---

archive/issue_comments_257089.json:
```json
{
    "body": "Replying to [comment:5 rws]:\n> It would use #19000\nCould. #19000 is not a necessity.",
    "created_at": "2015-08-17T15:18:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257089",
    "user": "rws"
}
```

Replying to [comment:5 rws]:
> It would use #19000
Could. #19000 is not a necessity.



---

archive/issue_comments_257090.json:
```json
{
    "body": "Actually, proving equality would need quantifiers like:\n\n```\nsage: satisfiable(_, for_all(x))\nTrue\n```\n",
    "created_at": "2015-08-17T15:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257090",
    "user": "rws"
}
```

Actually, proving equality would need quantifiers like:

```
sage: satisfiable(_, for_all(x))
True
```




---

archive/issue_comments_257091.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-09-08T15:10:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257091",
    "user": "rws"
}
```

New commits:



---

archive/issue_comments_257092.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-09T08:05:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257092",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257093.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-16T08:01:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257093",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257094.json:
```json
{
    "body": "It may not be possible to get the desired behaviour in the `structure/parent.pyx` doctests, so we oblige `Parent.__contains__` by throwing an exception if `lhs-rhs` contains inexact ring elements. This way inclusion in those rings (i.e., `pi in CC == True`) is always guaranteed as before.\n----\nNew commits:",
    "created_at": "2015-09-21T13:56:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257094",
    "user": "rws"
}
```

It may not be possible to get the desired behaviour in the `structure/parent.pyx` doctests, so we oblige `Parent.__contains__` by throwing an exception if `lhs-rhs` contains inexact ring elements. This way inclusion in those rings (i.e., `pi in CC == True`) is always guaranteed as before.
----
New commits:



---

archive/issue_comments_257095.json:
```json
{
    "body": "A small remark: From the documentation of the method `holds`\n\n```\nIf Sage knows exactly that the relation is\nundecidable it will throw an ``AttributeError``.\n```\n\nFor **one** relation there **always** is an algorithm which is either `return True` or `return False`. What is not possible is to design an algorithm whose input is an equation and answers the validity of the input. Your sentence makes no sense. A right formulation would be\n\n```\nIf Sage does not know if the equation is valid it will\nthrow a ``NotImplementedError``. Note that the validity\nof equations is an undecidable problem. Hence there will\nalways be instances for which such error is raised.\n```\n\n(`AttributeError` makes no sense here).",
    "created_at": "2015-09-21T14:12:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257095",
    "user": "vdelecroix"
}
```

A small remark: From the documentation of the method `holds`

```
If Sage knows exactly that the relation is
undecidable it will throw an ``AttributeError``.
```

For **one** relation there **always** is an algorithm which is either `return True` or `return False`. What is not possible is to design an algorithm whose input is an equation and answers the validity of the input. Your sentence makes no sense. A right formulation would be

```
If Sage does not know if the equation is valid it will
throw a ``NotImplementedError``. Note that the validity
of equations is an undecidable problem. Hence there will
always be instances for which such error is raised.
```

(`AttributeError` makes no sense here).



---

archive/issue_comments_257096.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-09-23T16:19:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257096",
    "user": "rws"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_257097.json:
```json
{
    "body": "This should be it. Please review.\n----\nNew commits:",
    "created_at": "2015-09-23T16:19:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257097",
    "user": "rws"
}
```

This should be it. Please review.
----
New commits:



---

archive/issue_comments_257098.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-26T07:09:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257098",
    "user": "rws"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_257099.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-27T06:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257099",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257100.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-27T06:47:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257100",
    "user": "rws"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_257101.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-27T06:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257101",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257102.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-10-15T05:52:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257102",
    "user": "rws"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_257103.json:
```json
{
    "body": "Patchbot failures in hyperbolic space.",
    "created_at": "2015-10-15T05:52:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257103",
    "user": "rws"
}
```

Patchbot failures in hyperbolic space.



---

archive/issue_comments_257104.json:
```json
{
    "body": "This code cannot be separated from #19312 so I included it there. I'll let this ticket stay here for the description unless someone objects.",
    "created_at": "2015-10-16T15:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257104",
    "user": "rws"
}
```

This code cannot be separated from #19312 so I included it there. I'll let this ticket stay here for the description unless someone objects.



---

archive/issue_comments_257105.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2015-10-16T15:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257105",
    "user": "rws"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_257106.json:
```json
{
    "body": "Replying to [comment:34 rws]:\n> This code cannot be separated from #19312\n\nPlease explain why.",
    "created_at": "2015-10-16T17:10:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257106",
    "user": "jdemeyer"
}
```

Replying to [comment:34 rws]:
> This code cannot be separated from #19312

Please explain why.



---

archive/issue_comments_257107.json:
```json
{
    "body": "Replying to [comment:35 jdemeyer]:\n> Replying to [comment:34 rws]:\n> > This code cannot be separated from #19312\n> \n> Please explain why.\n\nCorrection: an advanced version of this code cannot be separated from #19312. So, this is already obsolete. If, however, #19312 merge is not in the forseeable future I'll consider presenting this branch for review again.",
    "created_at": "2015-10-17T07:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257107",
    "user": "rws"
}
```

Replying to [comment:35 jdemeyer]:
> Replying to [comment:34 rws]:
> > This code cannot be separated from #19312
> 
> Please explain why.

Correction: an advanced version of this code cannot be separated from #19312. So, this is already obsolete. If, however, #19312 merge is not in the forseeable future I'll consider presenting this branch for review again.



---

archive/issue_comments_257108.json:
```json
{
    "body": "I would much prefer to separate #19040 from #19312, mainly to make the review easier (reviewing a package upgrade plus a huge number of Sage library changes is difficult).",
    "created_at": "2015-10-17T09:35:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257108",
    "user": "jdemeyer"
}
```

I would much prefer to separate #19040 from #19312, mainly to make the review easier (reviewing a package upgrade plus a huge number of Sage library changes is difficult).



---

archive/issue_comments_257109.json:
```json
{
    "body": "This will make it necessary to implement some (fast) functions from Pynac-0.5 in Python to achieve the same result. The two remaining fails are quite demanding.",
    "created_at": "2015-10-17T15:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257109",
    "user": "rws"
}
```

This will make it necessary to implement some (fast) functions from Pynac-0.5 in Python to achieve the same result. The two remaining fails are quite demanding.



---

archive/issue_comments_257110.json:
```json
{
    "body": "I succeeded to separate #19040 from #19312, so this branch needs rewrite after #19312 is merged.",
    "created_at": "2015-10-19T15:16:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257110",
    "user": "rws"
}
```

I succeeded to separate #19040 from #19312, so this branch needs rewrite after #19312 is merged.



---

archive/issue_comments_257111.json:
```json
{
    "body": "What would be the difference between the output `NotImplemented` and `Undecidable`!?\n\nAs I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.\n\nIn an ideal world, the function `satisfiable(expr)` would return one of:\n- `(True, example)`\n- `(False, proof)`\n- `NotImplemented`",
    "created_at": "2015-11-27T20:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257111",
    "user": "vdelecroix"
}
```

What would be the difference between the output `NotImplemented` and `Undecidable`!?

As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.

In an ideal world, the function `satisfiable(expr)` would return one of:
- `(True, example)`
- `(False, proof)`
- `NotImplemented`



---

archive/issue_comments_257112.json:
```json
{
    "body": "other remark: If I understand correctly `satisfiable` would corresponds to a **exists** quantifier for **all** the variables in the formula. While the `holds` would correspond to **for all**. What about something more elaborate such as\n\n```\n  for all x, exists y, for all z  expr(x,y,z)\n```\n",
    "created_at": "2015-11-27T20:06:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257112",
    "user": "vdelecroix"
}
```

other remark: If I understand correctly `satisfiable` would corresponds to a **exists** quantifier for **all** the variables in the formula. While the `holds` would correspond to **for all**. What about something more elaborate such as

```
  for all x, exists y, for all z  expr(x,y,z)
```




---

archive/issue_comments_257113.json:
```json
{
    "body": "Replying to [comment:41 vdelecroix]:\n> What would be the difference between the output `NotImplemented` and `Undecidable`!?\n> \n> As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.\nAgreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.\n>`for all x, exists y, for all z  expr(x,y,z)`\nSuch will not be in the first versions.",
    "created_at": "2015-11-28T07:18:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257113",
    "user": "rws"
}
```

Replying to [comment:41 vdelecroix]:
> What would be the difference between the output `NotImplemented` and `Undecidable`!?
> 
> As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.
Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.
>`for all x, exists y, for all z  expr(x,y,z)`
Such will not be in the first versions.



---

archive/issue_comments_257114.json:
```json
{
    "body": "Replying to [comment:43 rws]:\n> Replying to [comment:41 vdelecroix]:\n> > What would be the difference between the output `NotImplemented` and `Undecidable`!?\n> > \n> > As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.\n> Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.\n\nWhat do you mean? Do you have an example of such inequality?\n\n> >`for all x, exists y, for all z  expr(x,y,z)`\n> Such will not be in the first versions.\n\nBut do you have a syntax in mind for it. It would be cool to not multiply ad libitum the `satisfiable`, `holds`, etc which are exactly the same thing with a choice of quantifiers.",
    "created_at": "2015-11-28T12:17:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257114",
    "user": "vdelecroix"
}
```

Replying to [comment:43 rws]:
> Replying to [comment:41 vdelecroix]:
> > What would be the difference between the output `NotImplemented` and `Undecidable`!?
> > 
> > As I already mentioned in [comment:24 comment 24], it makes few sense that `satisfiable(expr)` returns `Undecidable`. Each formula is either `True` or `False`. I am here only assuming that mathematics are consistent. Of course `satisfiable` can not work for all input and when it can not it should return `NotImplemented`. That being said, some formula `expr` have no proof of their truthness (from Godel), but then I doubt any computer would actually be able to prove it.
> Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.

What do you mean? Do you have an example of such inequality?

> >`for all x, exists y, for all z  expr(x,y,z)`
> Such will not be in the first versions.

But do you have a syntax in mind for it. It would be cool to not multiply ad libitum the `satisfiable`, `holds`, etc which are exactly the same thing with a choice of quantifiers.



---

archive/issue_comments_257115.json:
```json
{
    "body": "Replying to [comment:44 vdelecroix]:\n> Replying to [comment:43 rws]:\n> > Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.\n> \n> What do you mean? Do you have an example of such inequality?\nComparison of real/infinity with complex.\n\n> > >`for all x, exists y, for all z  expr(x,y,z)`\n> > Such will not be in the first versions.\n> \n> But do you have a syntax in mind for it. It would be cool to not multiply ad libitum the `satisfiable`, `holds`, etc which are exactly the same thing with a choice of quantifiers.\nNo syntax in my mind. There could be precedents in SMT-solvers which could be copied.",
    "created_at": "2015-11-28T13:47:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257115",
    "user": "rws"
}
```

Replying to [comment:44 vdelecroix]:
> Replying to [comment:43 rws]:
> > Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.
> 
> What do you mean? Do you have an example of such inequality?
Comparison of real/infinity with complex.

> > >`for all x, exists y, for all z  expr(x,y,z)`
> > Such will not be in the first versions.
> 
> But do you have a syntax in mind for it. It would be cool to not multiply ad libitum the `satisfiable`, `holds`, etc which are exactly the same thing with a choice of quantifiers.
No syntax in my mind. There could be precedents in SMT-solvers which could be copied.



---

archive/issue_comments_257116.json:
```json
{
    "body": "Replying to [comment:45 rws]:\n> Replying to [comment:44 vdelecroix]:\n> > Replying to [comment:43 rws]:\n> > > Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.\n> > \n> > What do you mean? Do you have an example of such inequality?\n> Comparison of real/infinity with complex.\n\nThen I would qualify this as undefined and not undecidable. The latter introduces confusion with the standard notion related to proofs and computability.",
    "created_at": "2015-11-28T13:53:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257116",
    "user": "vdelecroix"
}
```

Replying to [comment:45 rws]:
> Replying to [comment:44 vdelecroix]:
> > Replying to [comment:43 rws]:
> > > Agreed if we look at equalities. Inequalities can be undecidable if we know one side has no order relation. I don't know if there could be other reasons. I haven't decided yet if `__nonzero__` should throw an exception for this.
> > 
> > What do you mean? Do you have an example of such inequality?
> Comparison of real/infinity with complex.

Then I would qualify this as undefined and not undecidable. The latter introduces confusion with the standard notion related to proofs and computability.



---

archive/issue_comments_257117.json:
```json
{
    "body": "I will upload a fresh branch with this.",
    "created_at": "2016-02-24T13:57:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257117",
    "user": "rws"
}
```

I will upload a fresh branch with this.



---

archive/issue_comments_257118.json:
```json
{
    "body": "Replying to [comment:5 rws]:\n> > You should also have a look to `sage/tests/*` where I am sure some of the things are broken.\n> Three fails.\n\nWhich probably means lots of user code being broken, see my experience on [sage-devel](https://groups.google.com/d/topic/sage-devel/ojHqBy7oUVU/discussion).\n\nIn my opinion, for any change in this area, be it fixing a perceived bug or not, we definitely need a deprecation. We do not need on what user's code relies and `sage/tests/*` is in no ways a representative sample (but even some code fails there).\n\nThe existing deprecation framework may not be enough: for some time, old and new code should be compared and a warning should be raised if the outcome is different. Users should be able to silence this warning once they have converted their code to the new behaviour; and the sage library should also silence the warning for its own use only. No idea how to implement this nicely, but I see no other option.",
    "created_at": "2016-02-26T06:32:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257118",
    "user": "cheuberg"
}
```

Replying to [comment:5 rws]:
> > You should also have a look to `sage/tests/*` where I am sure some of the things are broken.
> Three fails.

Which probably means lots of user code being broken, see my experience on [sage-devel](https://groups.google.com/d/topic/sage-devel/ojHqBy7oUVU/discussion).

In my opinion, for any change in this area, be it fixing a perceived bug or not, we definitely need a deprecation. We do not need on what user's code relies and `sage/tests/*` is in no ways a representative sample (but even some code fails there).

The existing deprecation framework may not be enough: for some time, old and new code should be compared and a warning should be raised if the outcome is different. Users should be able to silence this warning once they have converted their code to the new behaviour; and the sage library should also silence the warning for its own use only. No idea how to implement this nicely, but I see no other option.



---

archive/issue_comments_257119.json:
```json
{
    "body": "The easiest way for the user to see if behaviour has changed is to give the command `git diff original-version /path/to/file` and check if doctests were changed. Since the system is huge and users have different needs you either need to do this yourself or Sage automates this by providing some sort of subscription service. Since Sage cannot know which of your changes should be monitored for different behaviour (because there is no distinction between a user adding code and a developer adding code), you would need to initiate this subscription yourself. Anyway, a deprecation message every time `bool(relation)` is called is out of the question, much more so for all possible changes to Sage. Also, performance would suffer because of all the checks.\n\nYou seem to be of the opinion that there exists a representative sample of tests that covers all eventualities. Needless to say there isn't---however, Sage development tries to come close with the code coverage tools. I think a good dose of realism can be gathered from, for example https://www.youtube.com/watch?v=VfRVz1iqgKU",
    "created_at": "2016-02-27T07:47:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257119",
    "user": "rws"
}
```

The easiest way for the user to see if behaviour has changed is to give the command `git diff original-version /path/to/file` and check if doctests were changed. Since the system is huge and users have different needs you either need to do this yourself or Sage automates this by providing some sort of subscription service. Since Sage cannot know which of your changes should be monitored for different behaviour (because there is no distinction between a user adding code and a developer adding code), you would need to initiate this subscription yourself. Anyway, a deprecation message every time `bool(relation)` is called is out of the question, much more so for all possible changes to Sage. Also, performance would suffer because of all the checks.

You seem to be of the opinion that there exists a representative sample of tests that covers all eventualities. Needless to say there isn't---however, Sage development tries to come close with the code coverage tools. I think a good dose of realism can be gathered from, for example https://www.youtube.com/watch?v=VfRVz1iqgKU



---

archive/issue_comments_257120.json:
```json
{
    "body": "The discussion is perhaps theoretical at this moment because there is no branch attached, so I do not know what will actually change.\n\nReplying to [comment:51 rws]:\n> The easiest way for the user to see if behaviour has changed is to give the command `git diff original-version /path/to/file` and check if doctests were changed. Since the system is huge and users have different needs you either need to do this yourself or Sage automates this by providing some sort of subscription service.\n\nWe are speaking about users, not developers.\n\nThe most we could perhaps expect from users is to read well-written release notes giving a hint what changed. We do not currently have those.\n\n> Since Sage cannot know which of your changes should be monitored for different behaviour (because there is no distinction between a user adding code and a developer adding code), you would need to initiate this subscription yourself. Anyway, a deprecation message every time `bool(relation)` is called is out of the question, much more so for all possible changes to Sage. Also, performance would suffer because of all the checks.\n\nLibrary code could call a *new* method or something like that. But it is certainly ugly.\n\nWe do have a deprecation policy for much less serious cases: if a method is renamed, we have a one-year deprecation period; the only harm done is that a user gets a message that a method does no longer exist.\n\nChanging the behaviour of `bool(...)` **silently** leads to different results which might be wrong.\n\nI see the following options:\n1. Not changing fundamental behaviour.\n2. Changing fundamental behaviour at some really **major** release where we support old user code for much longer than usual (compare Python 2/Python 3)\n3. Some kind of deprecation system\n\nSimply making a fundamental change in a random version (say 7.2) and letting users alone with their old code is not an option for me.\n\n> You seem to be of the opinion that there exists a representative sample of tests that covers all eventualities.\n\nCertainly not, I think the contrary.\n\nI was surprised that at some point on this ticket, changed behaviour was caught by tests in `src/sage/tests`, given that those tests there seem to be quite random.",
    "created_at": "2016-02-28T05:41:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257120",
    "user": "cheuberg"
}
```

The discussion is perhaps theoretical at this moment because there is no branch attached, so I do not know what will actually change.

Replying to [comment:51 rws]:
> The easiest way for the user to see if behaviour has changed is to give the command `git diff original-version /path/to/file` and check if doctests were changed. Since the system is huge and users have different needs you either need to do this yourself or Sage automates this by providing some sort of subscription service.

We are speaking about users, not developers.

The most we could perhaps expect from users is to read well-written release notes giving a hint what changed. We do not currently have those.

> Since Sage cannot know which of your changes should be monitored for different behaviour (because there is no distinction between a user adding code and a developer adding code), you would need to initiate this subscription yourself. Anyway, a deprecation message every time `bool(relation)` is called is out of the question, much more so for all possible changes to Sage. Also, performance would suffer because of all the checks.

Library code could call a *new* method or something like that. But it is certainly ugly.

We do have a deprecation policy for much less serious cases: if a method is renamed, we have a one-year deprecation period; the only harm done is that a user gets a message that a method does no longer exist.

Changing the behaviour of `bool(...)` **silently** leads to different results which might be wrong.

I see the following options:
1. Not changing fundamental behaviour.
2. Changing fundamental behaviour at some really **major** release where we support old user code for much longer than usual (compare Python 2/Python 3)
3. Some kind of deprecation system

Simply making a fundamental change in a random version (say 7.2) and letting users alone with their old code is not an option for me.

> You seem to be of the opinion that there exists a representative sample of tests that covers all eventualities.

Certainly not, I think the contrary.

I was surprised that at some point on this ticket, changed behaviour was caught by tests in `src/sage/tests`, given that those tests there seem to be quite random.



---

archive/issue_comments_257121.json:
```json
{
    "body": "Replying to [comment:52 cheuberg]:\n> \n> The discussion is perhaps theoretical at this moment because there is no branch attached, so I do not know what will actually change.\nThe branch is not listed in the ticket field but the recent commits are visible in the comments. The branch can be checked out via `git trac checkout 19040 --branch=u/rws/19040-2`.",
    "created_at": "2016-02-28T08:29:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257121",
    "user": "rws"
}
```

Replying to [comment:52 cheuberg]:
> 
> The discussion is perhaps theoretical at this moment because there is no branch attached, so I do not know what will actually change.
The branch is not listed in the ticket field but the recent commits are visible in the comments. The branch can be checked out via `git trac checkout 19040 --branch=u/rws/19040-2`.



---

archive/issue_comments_257122.json:
```json
{
    "body": "A good way to contribute to this is to review #16397. Mixed order comparison is part of the branch mentioned above.",
    "created_at": "2016-03-09T03:37:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18803",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18803#issuecomment-257122",
    "user": "rws"
}
```

A good way to contribute to this is to review #16397. Mixed order comparison is part of the branch mentioned above.
