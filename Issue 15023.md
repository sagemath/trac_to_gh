# Issue 15023: Integer division of rationals

Issue created by migration from https://trac.sagemath.org/ticket/15260

Original creator: ncohen

Original creation time: 2013-10-07 11:59:20

CC:  was tmonteil zimmerma

As reported there [1]


```
sage: x = 1/2 
sage: x 
1/2 
sage: x//2 
1/4
}}} 

Though I have no idea how this kind of things is to be fixed `^^;`

Nathann

[1] https://groups.google.com/d/topic/sage-support/xE_S3WbFHzA/discussion


---

Comment by tmonteil created at 2013-10-07 12:24:41

The reason is that for rationals (and apparently more generally for `FieldElement`), we have


```
    def __floordiv__(self, other):
        return self / other
```


where it should be


```
    def __floordiv__(self, other):
        return floor(self / other)
```


I will do a patch once i have compiled a more recent version of Sage

What is fun is that


```
sage: RDF(0.5)//2
0.25

sage: RR(0.5)//2
TypeError: unsupported operand type(s) for //: 'sage.rings.real_mpfr.RealLiteral' and 'sage.rings.real_mpfr.RealNumber'
```



---

Comment by jkeitel created at 2014-08-03 06:52:49

Here's a branch that does this and implements a simple `floordiv` method for RR.
----
New commits:


---

Comment by jkeitel created at 2014-08-03 06:53:03

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2014-08-05 12:28:22

New commits:


---

Comment by jdemeyer created at 2014-08-05 12:44:48

Using the `floor()` function for every field is a bad idea, for many fields taking `floor()` does not make sense.


---

Comment by git created at 2014-08-05 13:10:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2014-08-05 13:11:22

I suggest just making the fixes for reals and rationals and deferring the discussion about a generic `__floordiv__` to #2034.


---

Comment by jdemeyer created at 2014-08-05 13:12:54

Running doctests now...


---

Comment by jdemeyer created at 2014-08-05 14:43:16

Tests passed, needs review.


---

Comment by tmonteil created at 2014-08-12 21:34:32

Could the fix work at least for RDF and RIF ? The current situation is:



```
sage: RDF(5) // 2
2.5

sage: RIF(5) // 2
TypeError: unsupported operand type(s) for //: 'sage.rings.real_mpfi.RealIntervalFieldElement' and 'sage.rings.real_mpfi.RealIntervalFieldElement'
```



---

Comment by tmonteil created at 2014-08-12 21:34:32

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2014-08-13 07:10:24

Changing component from numerical to basic arithmetic.


---

Comment by jdemeyer created at 2014-08-13 07:10:24

Changing status from needs_info to needs_work.


---

Comment by git created at 2014-08-13 07:48:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2014-08-13 09:52:01

Changing status from needs_work to needs_review.


---

Comment by tmonteil created at 2014-08-24 21:32:56

Changing status from needs_review to needs_info.


---

Comment by tmonteil created at 2014-08-24 21:32:56

The condition `if not other != 0:` looks weird. For real interval fields, why not using `other.contains_zero()` which is both easier to understand and faster ?

I do not understand the ad-hoc coercion that is made for `RealNumber` where the precision of `self` takes predecence over the one of `other`.

Concerning `FieldElement` it is very dangerous to return the usual division, since it will silently fail when the field in a subset of the reals for which we did not define a `__floordiv__` method:


```
sage: RLF(5) // 2
2.5000000000000000?
sage: AA(5) // 2
5/2
```


What about trying `(self/other).floor()` and raising a `NotImplementedError` if the method does not exist ?


---

Comment by jdemeyer created at 2014-08-25 10:00:46

Replying to [comment:18 tmonteil]:
> The condition `if not other != 0:` looks weird. For real interval fields, why not using `other.contains_zero()` which is both easier to understand and faster ?
Because I wanted something which behaves like `contains_zero()` but still works for any kind of element (unfortunately, `__floordiv__` doesn't use the coercion system).

> Concerning `FieldElement` it is very dangerous to return the usual division, since it will silently fail when the field in a subset of the reals for which we did not define a `__floordiv__` method:
> 
> What about trying `(self/other).floor()` and raising a `NotImplementedError` if the method does not exist ?
That's outside the scope of this ticket, but something like that could be done in a new ticket or as part of #2034.


---

Comment by jdemeyer created at 2014-08-25 10:00:46

Changing status from needs_info to needs_work.


---

Comment by jdemeyer created at 2014-08-25 13:43:12

Replying to [comment:18 tmonteil]:
> I do not understand the ad-hoc coercion that is made for `RealNumber` where the precision of `self` takes predecence over the one of `other`.
Yes, that was problematic, that is fixed now.


---

Comment by jdemeyer created at 2014-08-25 13:43:12

Changing status from needs_work to needs_review.


---

Comment by git created at 2014-08-25 13:43:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-10-04 11:58:19

Is there a reason for why we don't fix #2034 first? It seems its a really simple fix in `src/sage/structure/element.pyx`, just following what is done for `__div__`. Otherwise whoever wants to tackle that also has to undo the handcrafted type promotion from this ticket.


---

Comment by jdemeyer created at 2014-10-04 21:22:07

Replying to [comment:23 vbraun]:
> Is there a reason for why we don't fix #2034 first?
Not really. Mostly, I don't know how to do it.


---

Comment by vdelecroix created at 2015-04-30 10:19:56

I do not agree with your semantic of `__floordiv__`. Within Sage `//` is meant for _internal division_ (i.e. quotient of the euclidean division):

```
sage: x = polygen(ZZ)
sage: p1 = (x+1)*(x+2)
sage: p1 // (x+1)
x + 2
sage: _.parent()
Univariate Polynomial Ring in x over Integer Ring
sage: sage: p1 / (x+1)
x + 2
sage: sage: _.parent()
Fraction Field of Univariate Polynomial Ring in x over Integer Ring
```


Inside `RR` or `RDF` I am not sure what would be the point of `//`. This is a prefectly valid euclidean division `5 = 2 x 2.5 + 0`.


---

Comment by vdelecroix created at 2015-04-30 10:19:56

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2016-01-19 17:41:51

Changing status from needs_info to needs_work.


---

Comment by git created at 2016-01-20 13:57:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2016-01-20 14:03:25

Replying to [comment:25 vdelecroix]:
> I do not agree with your semantic of `__floordiv__`.

It's consistent with Python's `__floordiv__` for `float`, so this what we should do according to the "principle of least surprise".


---

Comment by jdemeyer created at 2016-01-20 14:03:25

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-01-20 15:52:10

Is that what we want

```
sage: QQ(7) // QQ(3)
2
sage: parent(_)
Integer Ring
sage: RR(7) // RR(3)
2
sage: parent(_)
Integer Ring
```

Floordiv of two Python floats is a float (in both Python 2 and 3).


---

Comment by vdelecroix created at 2016-01-20 15:52:10

Changing status from needs_review to needs_info.


---

Comment by vbraun created at 2016-01-20 20:57:45

The sage-devel thread is in favor of throwing an exception. Really code shouldn't rely on `QQ.__floordiv__` as it is ambiguous and likely to cause difficult-to-see errors.


---

Comment by bruno created at 2016-03-16 17:31:33

By the principle of least surprise, I would be in favor of `QQ.__floordiv__` behaving the same way as `float.__floordiv__` behaves in Python. Another reason for `__floordiv__` to be internal is that it gives a generic "exact division" method (division while you know in advance that the result is exact), which has several use cases. For instance if you want to take the primitive part of a polynomial: You can write a generic method which works over fields as well as over rings, as soon as you have a method `content` which returns 1 for fields and a more interesting content for rings.ยน In a situation where `__floordiv__` raises an Exception, you must use a `__truediv__` and then convert to the original ring to obtain an exact division.

ยน This example may seem anecdotal though I constantly encounter the need for an exact division. Of course, this is only useful for generic implementation, which could be used with rings or fields.


---

Comment by jdemeyer created at 2016-03-16 21:07:30

Replying to [comment:32 bruno]:
> By the principle of least surprise, I would be in favor of `QQ.__floordiv__` behaving the same way as `float.__floordiv__` behaves in Python.

In my opinion, `QQ` and `float` are very different things so I see no reason why their `__floordiv__` methods should be similar.


---

Comment by jdemeyer created at 2016-03-16 21:11:31

That being said, I could certainly agree with `QQ.__floordiv__` returning a rational which is always an exact integer. That would be:

```
sage: QQ(7)//QQ(3)
2
sage: parent(QQ(7)//QQ(3))
Rational Field
```

which looks useful indeed. But I don't know if there is enough consensus for this.


---

Comment by bruno created at 2016-03-17 09:04:22

I used `QQ` as an example, but the same holds for other fields. In the current branch, `__floordiv__` always returns an integer, while it should to my mind always be internal. Note that I am strongly against raising an exception since it would be a useless regression. (By this I mean that it would break some existing code, and bring nothing interesting.) I guess that my viewpoint is the same as (close to?) the one expressed by Vincent in comment:28 and comment:30.

Replying to [comment:31 vbraun]:
> The sage-devel thread is in favor of throwing an exception. 

I do not see any such consensus in the sage-devel thread! You are the only one proposing to raise an exception... William says that it is a reasonable option, as is Jeroen's proposal.


---

Comment by vdelecroix created at 2016-10-23 13:52:02

See #21745 for modifying only QQ.

Actually I think that a good (partial) specification would be:
 - `//` and `%` should always be consistent when implemented
 - in non-trivial euclidean rings `a // b` and `a % b` should stand for the remainder and quotient of euclidean division (eg `ZZ`, `QQ[x]`). In these cases, it would just be aliases of `a.quo_rem(b)[0]` and `a.quo_rem(b)[1]`.
 - for subset of the reals it should be the natural extension of integer euclidean division as proposed in [this thread](https://groups.google.com/forum/#!topic/sage-devel/PfMop0nyiL0) (see also #21745 and #21747 for a concrete proposal)


---

Comment by vdelecroix created at 2016-10-23 15:30:42

Replying to [comment:34 jdemeyer]:
> That being said, I could certainly agree with `QQ.__floordiv__` returning a rational which is always an exact integer. That would be:
> {{{
> sage: QQ(7)//QQ(3)
> 2
> sage: parent(QQ(7)//QQ(3))
> Rational Field
> }}}
> which looks useful indeed. But I don't know if there is enough consensus for this.

Would make sense to me and would also be better from the coercion point of view. However in Sage we use to convert exact integer results to integer as in

```
sage: type((2.5).floor())
<type 'sage.rings.integer.Integer'>
```


Note that Python is sloppy about the output type

```
>>> type(2.0 // 1.0)
float
>>> type(fractions.Fraction(2,1) // fractions.Fraction(1,1))
int
```

(but `fractions` is not so much a standard)
