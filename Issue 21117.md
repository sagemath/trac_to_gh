# Issue 21117: LatticePoset: certificates to non-modularity and non-distributivity

Issue created by migration from Trac.

Original creator: jmantysalo

Original creation time: 2016-08-27 05:09:52

CC:  tscrim chapoton kdilks

Now when #21002 has got positive review we can continue to `is_distributive` and `is_modular`.

Lattice Theory: Foundation by George Grätzer, p. 111: "If the lattice is finite, modular and and nondistributive, then it contains a cover-preserving diamond."

Hence it is easy to search a certificate for non-distributive lattice: check for non-lower semimodular, check for non-upper semimodular, check for diamond subgraph.


---

Comment by git created at 2016-08-27 14:20:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2016-08-30 07:24:14

patchbot says

```
sage -t --long src/sage/combinat/posets/lattices.py
**********************************************************************
File "src/sage/combinat/posets/lattices.py", line 736, in sage.combinat.posets.lattices.FiniteLatticePoset.is_distributive
Failed example:
    Posets.PentagonPoset().is_distributive(certificate=True)
Expected:
    (False, (3, 2, 1))
Got:
    (False, (3, 1, 2))
```



---

Comment by git created at 2016-08-30 10:19:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-09-18 19:21:27

Todo: To see if a lattice is join-distributive (i.e. every interval from an element to the join of upper covers of the element is distributive) we propably should check if the lattice is upper semimodular and has no M3 as a convex sublattice. Hence the M3-search shall go to `hasse_diagram.py`, where it can be used for several functions.


---

Comment by jmantysalo created at 2016-11-15 10:08:09

Changing status from new to needs_info.


---

Comment by jmantysalo created at 2016-11-15 10:08:09

Travis or Frédéric, I want an opinion.

Currenlty finite lattices have `is_modular` with two different uses: it can check if a lattice is modular, or if all elements in a given subset are modular. Then there is `is_modular_element` that checks only one element.

This feels somewhat unnatural. Compare to `is_compelemted` vs. `complements`; but then `complements` can give dictionary for complements of every element, whereas `pseudocomplement` does not. And there is no function to check if given subset has a complement or pseudocomplement.

An element of a lattice can be tuple, and tuple can also be an argument to `is_modular`.

So what should we do for this? I can of course just add `certificate` to `is_modular` such that it raises an exception when used in combination with current `L`-parameter. But what you think?


---

Comment by tscrim created at 2016-11-15 15:06:54

Replying to [comment:6 jmantysalo]:
> Travis or Frédéric, I want an opinion.
> 
> Currenlty finite lattices have `is_modular` with two different uses: it can check if a lattice is modular, or if all elements in a given subset are modular. Then there is `is_modular_element` that checks only one element.
> 
> This feels somewhat unnatural. Compare to `is_compelemted` vs. `complements`; but then `complements` can give dictionary for complements of every element, whereas `pseudocomplement` does not. And there is no function to check if given subset has a complement or pseudocomplement.

It would be easy to extend `complements` to have this functionality. However, `P.is_modular(elts)` is really just (slightly faster) shorthand for `all(P.is_modular_element(x) for x in elts)`, and since that is not doing anything complicated code-wise, I would not remove this feature.

> An element of a lattice can be tuple, and tuple can also be an argument to `is_modular`.
> 
> So what should we do for this? I can of course just add `certificate` to `is_modular` such that it raises an exception when used in combination with current `L`-parameter. But what you think?

I don't see any problem. You should pass in a list/tuple with the element to `is_modular` in that case. In particular, `is_modular` is assuming the input is a list of elements, not a single element.


---

Comment by jmantysalo created at 2016-11-15 18:26:13

Replying to [comment:7 tscrim]:

> - - I don't see any problem. - -

OK then. I will make a certificate for non-modularity in this ticket.


---

Comment by jmantysalo created at 2016-11-15 18:26:13

Changing status from needs_info to needs_work.


---

Comment by jmantysalo created at 2016-11-16 09:20:52

New commits:


---

Comment by jmantysalo created at 2016-11-16 09:20:52

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2016-11-16 09:27:21

Btw, the time needed to check that `BooleanLattice(10)` is modular drops from 4,31 to 0.16 seconds with this patch. And the time to select modular lattices from all 10-element lattices drops from 0.72 to 0.18 seconds.


---

Comment by tscrim created at 2016-11-16 15:49:54

This is not a sentence:

```
        some subset of elements are all modular. An element `x` in a
        lattice `L` is *modular* if `x \leq b` implies
        for every `a, b \in L`.
```

Replace `\not=` with `\neq`. I also disagree with raising an error here:

```
        if certificate and L is not None:
            raise ValueError("parameters L and certificate can not be combined")
```

There still is a meaningful certificate, it is now just a pair of entries that do not satisfy:

```
H._rank[a] + H._rank[b] == H._rank[H._meet[a, b]] + H._rank[H._join[a, b]]
```

There is a small problem because the definition given did not match what the code is actually checking. Yet, it still should be possible to make everything consistent.
I also disagree with putting the condition inline instead of in an equation environment.


---

Comment by jmantysalo created at 2016-11-19 20:55:09

Replying to [comment:13 tscrim]:

> There is a small problem because the definition given did not match what the code is actually checking. Yet, it still should be possible to make everything consistent.

True. Then this is a defect.

> I also disagree with raising an error here:
> {{{
>         if certificate and L is not None:
>             raise ValueError("parameters L and certificate can not be combined")
> }}}
> There still is a meaningful certificate, it is now just a pair of entries that do not satisfy:
> {{{
> H._rank[a] + H._rank[b] == H._rank[H._meet[a, b]] + H._rank[H._join[a, b]]
> }}}

Only if the poset is ranked. But yes, I think I can make a certificate.

> I also disagree with putting the condition inline instead of in an equation environment.

As you wish. But for example `is_join_semidistributive()` then looks a little different.

I'll look at this a day or few days later.


---

Comment by jmantysalo created at 2016-11-19 20:55:09

Changing type from enhancement to defect.


---

Comment by tscrim created at 2016-11-19 21:55:04

Replying to [comment:14 jmantysalo]:
> Replying to [comment:13 tscrim]:
> 
> > There is a small problem because the definition given did not match what the code is actually checking. Yet, it still should be possible to make everything consistent.
> 
> True. Then this is a defect.

It's only a problem for the certificate, not the code itself because it is using an equivalent definition. (Admittedly this is walking us right past the bikeshed...) 

> > I also disagree with raising an error here:
> > {{{
> >         if certificate and L is not None:
> >             raise ValueError("parameters L and certificate can not be combined")
> > }}}
> > There still is a meaningful certificate, it is now just a pair of entries that do not satisfy:
> > {{{
> > H._rank[a] + H._rank[b] == H._rank[H._meet[a, b]] + H._rank[H._join[a, b]]
> > }}}
> 
> Only if the poset is ranked. But yes, I think I can make a certificate.

Good point about the rankedness, but we should be try to be consistent with our certificate.

> > I also disagree with putting the condition inline instead of in an equation environment.
> 
> As you wish. But for example `is_join_semidistributive()` then looks a little different.

IMO, it's easier to read with it being on its own line in the html docs. Thanks.

> I'll look at this a day or few days later.

I will be at a SageDays this upcoming week so I should get to review it quickly.


---

Comment by tscrim created at 2016-11-19 21:55:04

Changing type from defect to enhancement.


---

Comment by kdilks created at 2016-11-28 01:13:39

Changing keywords from "" to "kdilks".


---

Comment by jmantysalo created at 2016-11-28 04:32:40

Kevin, I suppose you didn't want you to be a keyword. `:=)`


---

Comment by jmantysalo created at 2016-11-28 04:32:40

Changing keywords from "kdilks" to "".


---

Comment by tscrim created at 2016-12-01 22:18:29

Any thoughts on the certificate given an `L`?


---

Comment by jmantysalo created at 2016-12-02 07:36:33

Replying to [comment:18 tscrim]:
> Any thoughts on the certificate given an `L`?

I think I'll just implement the `L` parameter for non-ranked lattices as you suggested, also with `certificate`. That may take some time. (Please notify if you plan to do it yourself, so we won't do the same job twise.)

This may relate to #21903: what is the fastest way to compute neutral elements? It is easy to find a non-distributivity certificate, and can the lattice be "shrinked" so that only neutral elements remain? Gonna think that for a while too...


---

Comment by tscrim created at 2016-12-02 15:10:24

Replying to [comment:19 jmantysalo]:
> Replying to [comment:18 tscrim]:
> > Any thoughts on the certificate given an `L`?
> 
> I think I'll just implement the `L` parameter for non-ranked lattices as you suggested, also with `certificate`. That may take some time. (Please notify if you plan to do it yourself, so we won't do the same job twise.)

I will not be doing any work on posets/lattice code in the near future, so don't worry about conflicting with me.

> This may relate to #21903: what is the fastest way to compute neutral elements? It is easy to find a non-distributivity certificate, and can the lattice be "shrinked" so that only neutral elements remain? Gonna think that for a while too...

I have no idea as this is a little too far outside my knowledge area for me to be helpful.


---

Comment by git created at 2016-12-05 20:23:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-12-05 20:23:36

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-12-07 07:06:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-12-07 07:08:04

Continuing this a little. But after #21903 it seems inconsistent to have this kind of `L`-parameter.


---

Comment by tscrim created at 2016-12-07 15:07:29

I'm not so sure about that. However, if you really don't want to deal with a certificate with `L`, then it should raise a `NotImplementedError` because there should be a certificate in principle.


---

Comment by git created at 2016-12-11 07:14:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-12-14 09:31:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-12-14 09:35:27

Changing type from enhancement to defect.


---

Comment by jmantysalo created at 2016-12-14 09:35:27

OK, here it is.

I also mark this as a bug correction. Current version will return `False` from `Posets.PentagonPoset().is_modular(L=[0])` which is an error. Also the docstring seems to be incorrect: It says "An element **x** in a lattice L is modular", but it should be "An element **b** in a lattice L is modular"; compare to the Wikipedia article it refers.


---

Comment by jmantysalo created at 2016-12-14 09:35:27

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2016-12-14 15:43:55

Thank you.

However, looking at the previous documentation, I like the flow better (1 element modular and then the definition for the entire poset). You can also use `\neq` instead of `\not=`.

Another possible optimization, which would mean more work, would be to push the actual comparison tests to `HasseDiagram` and just convert back the elements in the certificate. However, we don't have to do this on this ticket.


---

Comment by git created at 2016-12-16 12:47:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-12-16 12:51:47

Replying to [comment:29 tscrim]:

> However, looking at the previous documentation, I like the flow better (1 element modular and then the definition for the entire poset).

Well, yes and no. This is more logical if we think the function as a whole. OTOH if we see `is_modular()` without `L`-parameter a "main function" for this, then it should be said first. Anyways, I changed that.

> Another possible optimization, which would mean more work, would be to push the actual comparison tests to `HasseDiagram` and just convert back the elements in the certificate. However, we don't have to do this on this ticket.

True, but even more than that I should think about the algorithm itself. No time for that for now.


---

Comment by jmantysalo created at 2016-12-27 16:39:32

More modifications needed for the docstring?


---

Comment by tscrim created at 2017-01-02 00:50:59

I would change it to:

```
        .. MATH::

            x \vee (a \wedge b) = (x \vee a) \wedge b

        for every element `x \leq b` and `a`.
```

Otherwise LGTM and you can set a positive review on my behalf.


---

Comment by git created at 2017-01-02 07:12:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2017-01-02 07:14:20

Replying to [comment:33 tscrim]:
> I would change it to - -

True, better now. Thanks!

rc1 is out, also changed milestone.


---

Comment by jmantysalo created at 2017-01-02 07:14:20

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-01-18 20:39:43

Resolution: fixed
