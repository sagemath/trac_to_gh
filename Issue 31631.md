# Issue 31631: Interruption of JuPyMake kills sage the hard way

Issue created by migration from https://trac.sagemath.org/ticket/31868

Original creator: @kliem

Original creation time: 2021-05-27 20:04:19

CC:  mkoeppe tscrim tmonteil

Keyboard interrupt of `JuPyMake` kills an ipython session, but not a python session.

This is in `sage -sh` and then in `ipython`, so in sage's ipython:


```
In [1]: import JuPyMake                                                                                                                                                             

In [2]: JuPyMake.InitializePolymake()                                                                                                                                               
Out[2]: True

In [4]: JuPyMake.ExecuteCommand("$p=cube(15);")                                                                                                                                     
Out[4]: (True, '', '', '')

In [5]: JuPyMake.ExecuteCommand("$q=$p->VERTICES;")  
```


Interrupting the last command kills ipython, whereas in python it just gets ignored as intended (not nice, but a lot better).


---

Comment by mkoeppe created at 2021-05-27 20:11:23

on macOS I am getting:

```
sage: import JuPyMake
sage: JuPyMake.InitializePolymake()
True
sage: JuPyMake.ExecuteCommand("$p=cube(15);")
(True, '', '', '')
sage: JuPyMake.ExecuteCommand("$q=$p->VERTICES;")
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
KeyboardInterrupt: polymake interrupted

The above exception was the direct cause of the following exception:

SystemError                               Traceback (most recent call last)
<ipython-input-4-14391b0da80c> in <module>
----> 1 JuPyMake.ExecuteCommand("$q=$p->VERTICES;")

SystemError: <cyfunction python_check_interrupt at 0x1120cbad0> returned a result with an error set
```



---

Comment by mkoeppe created at 2021-05-27 20:12:44

and with ipython:

```
$ ./sage -ipython
Python 3.9.4 (default, Apr  5 2021, 01:49:30) 
Type 'copyright', 'credits' or 'license' for more information
IPython 7.16.1 -- An enhanced Interactive Python. Type '?' for help.

In [1]: import JuPyMake

In [2]: JuPyMake.InitializePolymake()
Out[2]: True

In [3]: JuPyMake.ExecuteCommand("$p=cube(15);")
Out[3]: (True, '', '', '')

In [4]: JuPyMake.ExecuteCommand("$q=$p->VERTICES;")
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-4-14391b0da80c> in <module>
----> 1 JuPyMake.ExecuteCommand("$q=$p->VERTICES;")

KeyboardInterrupt: 
```



---

Comment by @kliem created at 2021-05-27 20:12:51

So it interrupts as desired?


---

Comment by mkoeppe created at 2021-05-27 20:13:50

and with python:

```
$ ./sage -python
Python 3.9.4 (default, Apr  5 2021, 01:49:30) 
[Clang 12.0.0 (clang-1200.0.32.29)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import JuPyMake
>>> JuPyMake.InitializePolymake()
True
>>> JuPyMake.ExecuteCommand("$p=cube(15);")
(True, '', '', '')
>>> JuPyMake.ExecuteCommand("$q=$p->VERTICES;")
^CTraceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyboardInterrupt
```



---

Comment by mkoeppe created at 2021-05-27 20:16:49

https://github.com/sebasguts/JuPyMake/commits/master has some changes that we don't have in our package yet. I don't remember the details at this point


---

Comment by mkoeppe created at 2021-05-27 21:00:55

We may also want to take a look at what the Julia integration of polymake (in OSCAR) does regarding interrupts.


---

Comment by @kliem created at 2021-05-28 09:18:01

Replying to [comment:5 mkoeppe]:
> https://github.com/sebasguts/JuPyMake/commits/master has some changes that we don't have in our package yet. I don't remember the details at this point

One thing that is fixed upstream is that `InitializePolymake` is called implicitly instead of a segmentation fault, by accessing a NULL-pointer to a non-existent session. That would be nice to have.



Regarding the signals nothing changed upstream as far as I can see. Apparently the signal handling is just not working that way for me.  It is even worse as it completely breaks my `SIGINT` handling. After calling `polymake` once any keyboard in the same sage session leads to immediate hard crash.

With the following patch it works for me (similar to what normaliz does):


```diff
+volatile sig_atomic_t JuPyMake_interrupted = 0;
+void interrupt_signal_handler(int signal) {
+        JuPyMake_interrupted = 1;
+}
+
+#define SET_SIGNAL_HANDLERS                                                             \
+    PyOS_sighandler_t prev_action = PyOS_setsig(SIGINT, interrupt_signal_handler);     \
+    PyOS_sighandler_t prev_action2 = PyOS_setsig(SIGALRM, interrupt_signal_handler);     \
+
+#define RESET_SIGNAL_HANDLERS                                                \
+    PyOS_setsig(SIGINT, prev_action);                                        \
+    PyOS_setsig(SIGALRM, prev_action2);                                      \
+    if (JuPyMake_interrupted) {                                              \
+        JuPyMake_interrupted = 0;                                            \
+        PyErr_SetString(PyExc_KeyboardInterrupt, "polymake interrupted");    \
+        PyErr_SetInterrupt();                                                \
+        PyErr_CheckSignals();                                                \
+        return NULL;                                                         \
+    }
-#define SET_SIGNAL_HANDLERS                                                  \
-    sigset_t signal_block_set, signal_pending_set;                           \
-    sigemptyset(&signal_block_set);                                          \
-    sigaddset(&signal_block_set, SIGINT);                                    \
-    sigaddset(&signal_block_set, SIGALRM);                                   \
-    sigprocmask(SIG_BLOCK, &signal_block_set, NULL);
-
-#define RESET_SIGNAL_HANDLERS                                                \
-    sigpending(&signal_pending_set);                                         \
-    if (sigismember(&signal_pending_set, SIGINT)) {                          \
-        PyOS_sighandler_t current_handler = PyOS_setsig(SIGINT, SIG_IGN);    \
-        sigprocmask(SIG_UNBLOCK, &signal_block_set, NULL);                   \
-        PyOS_setsig(SIGINT, current_handler);                                \
-        PyErr_SetString(PyExc_KeyboardInterrupt, "polymake interrupted");    \
-        PyErr_SetInterrupt();                                                \
-        PyErr_CheckSignals();                                                \
-        return NULL;                                                         \
-    }                                                                        \
-    sigprocmask(SIG_UNBLOCK, &signal_block_set, NULL);
```


In this case the signal is ignored as desired and then a keyboard interrupt is raised after the polymake command finishes.

There is definitely a problem with JuPyMake, as it assumes that `SIGINT` and `SIGALARM` are not not blocked. It should record the old signals and then reset the mask to the old values. However, it does not fix my issue and I don't understand why.
