# Issue 24672: Boruvka algorithm for MST

Issue created by migration from Trac.

Original creator: meghanamreddy

Original creation time: 2018-03-06 11:27:03

CC:  dcoudert




---

Comment by meghanamreddy created at 2018-03-06 12:04:49

Changing type from PLEASE CHANGE to enhancement.


---

Comment by meghanamreddy created at 2018-03-06 12:04:49

Changing keywords from "" to "Boruvka, minimum spanning tree".


---

Comment by meghanamreddy created at 2018-03-06 12:06:25

Changing component from PLEASE CHANGE to graph theory.


---

Comment by dcoudert created at 2018-03-06 17:27:37

Welcome to Sage.

There is a problem with the branch name and so I cannot access the code. 
You could use either `public/24909_boruvka_algorithm_for_mst` in which case the branch is public and can be modified by others, or `u/meghanamreddy/24909_boruvka_algorithm_for_mst` where `u/meghanamreddy/` is for user meghanamreddy.

I don't know where to find documentation on possible branch names, but both forms are commonly used.


---

Comment by meghanamreddy created at 2018-03-06 17:47:33

New commits:


---

Comment by meghanamreddy created at 2018-03-06 17:57:33

I had done some mistake with git push. I have added the correct branch now. Please review it.
And as of the algorithm itself, I have tested my code on the test cases of Kruskal's algorithm and a few of my own test cases. But since the test cases used for Kruskal's algorithm cover most of the cases for MST, I have added the same ones for Boruvka's algorithm as well. 

I was also looking at Prim's algorithm. Though the file spanning_tree.pyx mentions Prim's as a To-Do, the generic_graph.py uses Boost's Prim's implementation. Is prim's algorithm still required to be implemented?


---

Comment by dcoudert created at 2018-03-07 08:49:31

Hello,

there are multiple possible improvements of your code. Let's start with a first round.

- You implement your own Union-Find data structure, but we already have `DisjointSet` in `src/sage/sets/disjoint_set.pyx`. So you should use it

- Loops / multiple edges: I'm not sure it is interesting to simplify the graph and so to make a copy. But we can let this part for later.

- for loop over edges: we can reduce the cost of this loop. Indeed, if the as soon as the end vertices of an edge are in the same component, we don't want to see this edge anymore. To do so, you first make a copy of the list of edges (before while loop). So `E = g.edges()`. Then let `E_tmp` be a list, initially empty, and during the for loop, you add to `E_tmp` the edges that are still active. After the for loop, you do `E,E_tmp = E_tmp,[]`. This way, at next iteration, you consider only active edges.

- for loop over vertices: here you want to consider only one vertex per component. To do so, a simple way is to use the dictionary `cheapest`. At the beginning of the while loop, you set `cheapest = dict()`. Then, during the for loop over edges, you use tests like `if component1 not in cheapest or ...`, and you add the edges to `cheapest` as you do (with some care). Now, the for loop over vertices can be turned to a for loop over active vertices which are the keys of `cheapest`.

Let's start with this. It should already help improving the algorithm. We will then try to speed up the code further.

Prim: no, we don't need Prim's algorithm. You can remove it from the todo list. It might be hard to provide a faster implementation than boost.


---

Comment by meghanamreddy created at 2018-03-07 13:59:06

Dear Mr David,

Thank you for your quick response. The changes you mentioned will definitely help to speed up the code. I will work on making the changes and upload ASAP.


---

Comment by git created at 2018-03-10 09:57:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-10 10:18:01

I have made the changes you suggested. 
Using the DisjointSet class has simplified the algorithm and gives more flexibility.
The second for loop, which loops over the vertices has been improved by looping over each component once. 
The first for loop has also been improved, I have kept track of active edges in each loop. However there is still room for improvement in this loop since, the list of active edges, i.e, edge_temp contains the active edges along with the edges that were added to MST in the previous iteration. This is because I'm adding an edge to edge_temp if the endpoints belong to different components. If the components are merged later, the edge still remains in the edge_temp list for the next iteration.

Another approach that could be followed is to replace the first for loop over the edges to a for loop over the components, find the cheapest edge for each component by iterating over its outgoing edges using edge_boundary() function.

And regarding your comment on removing the loops and multiple edges: If there are multiple edges between two vertices, only the minimum weight edge can be in the MST. Hence, when we use


```
G.to_simple(to_undirected=False, keep_label='min')
```


we keep the edges with minimum weight. The algorithm anyway works with loops and multiple edges as well.


---

Comment by dcoudert created at 2018-03-10 13:12:29

> The second for loop, which loops over the vertices has been improved by looping over each component once.

Could you move the description of what the loop is about before the loop.
Do the same for the first for loop. It's what is done elsewhere (at least in many places)

Also, make sure that each time you have a comment, you have a space after `#`. For instance `#reset` -> `# reset`. It's easier to read. 

> The first for loop has also been improved, I have kept track of active edges in each loop. However there is still room for improvement in this loop since, the list of active edges, i.e, edge_temp contains the active edges along with the edges that were added to MST in the previous iteration. This is because I'm adding an edge to edge_temp if the endpoints belong to different components. If the components are merged later, the edge still remains in the edge_temp list for the next iteration.

The list of active edges is `edge_list` and it contains the edges that were added to MST in previous iteration. However, the edges added to MST at previous iteration will not be added to `edge_temp`.
This is a good way to remove edges that are no longer active. 

The drawback of this approach is that you may keep a large number of edges between between 2 components for as long that these components are not merged.

One possible improvement is to use a dictionary keyed by pairs `c1,c2`, with `c1 < c2`, recording the cheapest edge between component `c1` and component `c2`. So as you loop over active edges, you store the cheapest edge between `c1` and `c2`.
Then, at the end of the first for loop, you can rebuild the set of active edges (the values stored in the dictionary), and reset the dictionary for next iteration.

This can be tested, but I don't know if it will be faster in practice than the current code.
 
> Another approach that could be followed is to replace the first for loop over the edges to a for loop over the components, find the cheapest edge for each component by iterating over its outgoing edges using edge_boundary() function.

No. The `edge_boundary` method will go over all vertices of the component, visit all edges incident to at least one vertex in the component and return the edges with only one vertex in the component. So it will visit many edges, including edges that where removed long time ago. Bad idea.


> And regarding your comment on removing the loops and multiple edges: If there are multiple edges between two vertices, only the minimum weight edge can be in the MST. Hence, when we use
> 
> {{{
> G.to_simple(to_undirected=False, keep_label='min')
> }}}
> 
> we keep the edges with minimum weight. The algorithm anyway works with loops and multiple edges as well.

The way you do it forces to make a copy of the graph, even if the graph is simple. Please avoid that.

Also, if the method I propose above for keeping a unique active edge between each pair of components is used, there will be no need anymore for removing multiple edges/loops.


Why are you sorting the edges at the end ? There is no need for it.


---

Comment by chapoton created at 2018-03-11 07:31:00

The branch wrongly adds a "test.py" file...


---

Comment by git created at 2018-03-14 17:58:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-14 18:00:17

Replying to [comment:12 chapoton]:
> The branch wrongly adds a "test.py" file...

Thank you, I have deleted it.


---

Comment by meghanamreddy created at 2018-03-14 18:16:21

I have added two versions of the algorithm now. Once I test both methods thoroughly, I will update to the better version. The first approach is using an `edge_list` and `edge_temp` as previously discussed. `edge_list` now contains only active edges. However, if two components contain 3 edges incident to them, `edge_list` would contain all the edges. As mentioned by you, one way to improve this is by using a dictionary.

> One possible improvement is to use a dictionary keyed by pairs `c1,c2`, with `c1 < c2`, recording the cheapest edge between component `c1` and component `c2`. So as you loop over active edges, you store the cheapest edge between `c1` and `c2`.
> Then, at the end of the first for loop, you can rebuild the set of active edges (the values stored in the dictionary), and reset the dictionary for next iteration.
> 
> This can be tested, but I don't know if it will be faster in practice than the current code.
>  

The method named `boruvka_v2` is an implementation using this approach. The list of active edges, i.e., `edge_list` now will contain only the least weight edge between any pair of components. On small test cases, this approach seems to work better as the number of edges in `edge_list` decrease more as compared to the first approach. I am yet to test on bigger inputs and compare the overall performance. However, the second approach seems promising and mostly will perform better than the older approach. 

> Why are you sorting the edges at the end ? There is no need for it.
The kruskal's algorithm seemed to return sorted edges. Hence, I was sorting here also. I have changed it, now I'm not sorting the edges.


---

Comment by dcoudert created at 2018-03-14 18:24:36

In your tests, make sure that the result is correct (i.e., it is a tree and it is spanning all vertices).


---

Comment by meghanamreddy created at 2018-03-19 06:31:03

After running the some tests on the two functions, the second version (the one where we used a dictionary approach and stored (c1,c2) pairs with the shortest edge between then as dictionary values) is faster than the previous version.
| No of vertices| Edge density | Kruskal | Boruvka |Boruvka v2|
|:---------------:|:--------------:|:---------:|:---------:|:----------:|
| 100           |  0.4  |0.0079	seconds |  0.0115	|  0.0058   |
| 100           |  0.8  |  0.024  |  0.0253	|  0.014  |
| 500           |  0.4  |  0.216	|  0.227	|  0.176   |
| 500           |  0.8  |  0.453	|  0.478	|  0.365   |
| 1000           |  0.4  |  1.05	|  1.09	|  0.88  |
| 1000           |  0.8  |  2.18	|  1.87	|  1.75   |
| 5000           |  0.3  |  22.59	|  29.59	|  21.85  |
| 5000           |  0.7  |  62.11	|  62.45	|  54.4  |
For testing, I used the RandomGNP(n,p) function with the value of p as the edge density, and I used random edge weights. The second version of Boruvka seems to be faster than Kruskal's in some cases. Hence, I have updated to the latest version of Boruvka algorithm.


---

Comment by git created at 2018-03-19 06:36:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-19 06:55:16

Replying to [comment:16 dcoudert]:
> In your tests, make sure that the result is correct (i.e., it is a tree and it is spanning all vertices).

Did you mean the examples in the tests, which are also used for doctests? There is a test which gives a tree as an input and the output is the tree itself.


---

Comment by dcoudert created at 2018-03-19 12:14:54

Thank you for the performance report.

Some possible improvements:
- Could try not using `edge_temp`, and so not updating the list of edges. It's an expensive operation, so I'm wondering if it is really better to do it or not.

- `if G.order() == 0:` you can do `if G.order() <= 1:`. Furthermore, this test should be outside the `check` test. It is always useful.

- We should now work on the weight function. In other methods, we use

```
if wfunction is None:
    wfunction = lambda e:e[2]
```

  You may also use an extra parameter `by_weight` such that

```
if by_weight:
   if wfunction is None:
       wfunction = lambda e:e[2]
else:
   wfunction = lambda e:1
```

  and then reduce the size of the code.
  Look at the code of other methods using weights, like shortest path methods, etc.

  You could also test if the weights are in RR when check is True.

- what happen if G is not connected and check is False ?


---

Comment by meghanamreddy created at 2018-03-19 17:37:34

Replying to [comment:20 dcoudert]:
> - Could try not using `edge_temp`, and so not updating the list of edges. It's an expensive operation, so I'm wondering if it is really better to do it or not.
I will do a performance check with and without the `edge_temp` and proceed accordingly.   

>   You could also test if the weights are in RR when check is True.
I am sorry, but I am a bit confused on what RR means? 
> - what happen if G is not connected and check is False ?
Currently, the code runs into an infinite loop. Which is bad. However, as mentioned in the comments (which is similar to that of Kruskals), if check is False, the code assumes the input graph is connected. We could change the default value of check to True so that the users will set check to False only if they are sure that the input graph need not go through the checks. Currently, Kruskal's gives a runtime error if G is not connected and check is False. Hence, I thought it was an acceptable assumption. What do you think should be done? If the checks do not take a long time (which I verified and take about 4% of the total running time), we could perform the checks for all inputs and remove the check parameter.


---

Comment by dcoudert created at 2018-03-19 17:52:41

Replying to [comment:21 meghanamreddy]:
> Replying to [comment:20 dcoudert]:
> > - Could try not using `edge_temp`, and so not updating the list of edges. It's an expensive operation, so I'm wondering if it is really better to do it or not.
> I will do a performance check with and without the `edge_temp` and proceed accordingly.   
> 
> >   You could also test if the weights are in RR when check is True.
> I am sorry, but I am a bit confused on what RR means? 


```
sage: RR
Real Field with 53 bits of precisions
sage: 3 in RR
True
sage: 3.5 in RR
True
sage: 'a' in RR
False
sage: [1] in RR
False
```

but forget about it. It's not tested in kruskal. We could (latter) add a test in method `min_spanning_tree`. We will have to modify `min_spanning_tree`. Note also that the Prim algorithm is in `min_spanning_tree`.

> > - what happen if G is not connected and check is False ?
> Currently, the code runs into an infinite loop. Which is bad. However, as mentioned in the comments (which is similar to that of Kruskals), if check is False, the code assumes the input graph is connected. We could change the default value of check to True so that the users will set check to False only if they are sure that the input graph need not go through the checks. Currently, Kruskal's gives a runtime error if G is not connected and check is False. Hence, I thought it was an acceptable assumption. What do you think should be done? If the checks do not take a long time (which I verified and take about 4% of the total running time), we could perform the checks for all inputs and remove the check parameter. 

We can avoid testing if the graph is connected by testing after each iteration of the while loop if the number of components has been reduced. if not, for sure the graph is not connected and we can raise an error.


---

Comment by dcoudert created at 2018-03-19 17:55:28

Also, you could do as in `min_spanning_tree`:

```
        if weight_function is None:
            if self.weighted():
                weight_function = lambda e:e[2]
            else:
                weight_function = lambda e:1
```

thus allowing to have a unique case in the for loop over edges.


---

Comment by meghanamreddy created at 2018-03-20 09:06:42

Replying to [comment:23 dcoudert]:
> Also, you could do as in `min_spanning_tree`:
> {{{
>         if weight_function is None:
>             if self.weighted():
>                 weight_function = lambda e:e[2]
>             else:
>                 weight_function = lambda e:1
> }}}
> thus allowing to have a unique case in the for loop over edges.

I tried this and got an error stating "closures inside cpdef functions not yet supported". Closures are not yet supported in Cython? The `min_spanning_tree` is entirely in Python.


---

Comment by dcoudert created at 2018-03-20 12:27:08

it's in Python but in a Cython file.

An alternative could be:

```
if by_weight:
    if wfunction is None:
        edge_list = G.edges()
    else:
        edge_list = [(e[0], e[1], wfunction(e)) for e in G.edge_iterator()]
else:
    edge_list = [(u, v, 1) for u,v in G.edge_iterator(labels=None)]
```

The first case assumes that e[2] is the weight of the edge, the second applies the wfunction on the edge (useful if the label is more than just a value), and the third case set the weight of each edge to 1.

Then you don't have to take care of weight function anymore, e[2] is always the weight ;)
The only drawback is that the tree edges might be different than graph edges... can you check what is done in other methods like kruskal ?


---

Comment by git created at 2018-03-21 05:40:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-21 05:57:57

Replying to [comment:25 dcoudert]:

> Then you don't have to take care of weight function anymore, e[2] is always the weight ;)
> The only drawback is that the tree edges might be different than graph edges... can you check what is done in other methods like kruskal ?

Currently, Kruskal needs to sort the edges once in the beginning. It is being done by using the sort function with wfunction for the comparator. Hence, the final final tree edges are the same as graph edges. 

I could do as you suggested. But the tree edges being different from graph edges can be a problem if the user wants to use the tree edges further in their algorithm? However, only the weight of the edges would be different, so can be used with some care. Do you suggest I go ahead with changing e[2]? In the meantime, I will try for a workaround without changing e[2].


In the latest commit, I have removed `edge_temp` as it did speed up the computation. And I have also added an additional check in the while loop to identify if the graph is disconnected, in which case, an empty list is returned. I will also work on adding a test in `min_spanning_tree` to check if weights are in RR.


---

Comment by dcoudert created at 2018-03-21 10:10:01

- could you use a shorter name for `numConnectedComponentsPrevIter`. I'm not sure such a long name is really helpful here.
- `numConnectedComponentsPrevIter = numConnectedComponents + 1`

- be aware that all comments must be formatted on 80 columns mode. Some code editors help you to do that.

The main issue I see with weights is when `wfunction is None` and the graph is unweighted. Can you try the following idea: instead of working with `edge_list = G.edges()`, use a list of tuples `(e, e_weight)`. So you compute once for all the weight of edge e when you create the list `edge_list` using `wfunction`, and then you can safely compare weights in the `for e in ` loop (which becomes `for e,e_weight in edge_list`). Of course you have to store the cheapest tuple in `cheapest`. This will simplify the code. It might also be faster.


---

Comment by git created at 2018-03-22 12:06:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-22 12:18:36

Replying to [comment:28 dcoudert]:
> 
> - could you use a shorter name for `numConnectedComponentsPrevIter`. I'm not sure such a long name is really helpful here.
> - `numConnectedComponentsPrevIter = numConnectedComponents + 1`
> 
I have made the name shorter. I cannot do `numConnectedComponentsPrevIter = numConnectedComponents + 1` since I'm using a slightly different logic of updating `numConnectedComponents` at the end of the loop.
> - be aware that all comments must be formatted on 80 columns mode. Some code editors help you to do that.
> 
I have ensured comments are on 80 columns mode. Does the TESTS and EXAMPLES section also have this restriction? I am unable to make it 80 columns as it contains Sage code.
> The main issue I see with weights is when `wfunction is None` and the graph is unweighted. Can you try the following idea: instead of working with `edge_list = G.edges()`, use a list of tuples `(e, e_weight)`. So you compute once for all the weight of edge e when you create the list `edge_list` using `wfunction`, and then you can safely compare weights in the `for e in ` loop (which becomes `for e,e_weight in edge_list`). Of course you have to store the cheapest tuple in `cheapest`. This will simplify the code. It might also be faster.

I have made this change. It did not speed up the computations, but the code is simplified.


---

Comment by dcoudert created at 2018-03-22 12:40:49

Replying to [comment:30 meghanamreddy]:
> Replying to [comment:28 dcoudert]:
> > 
> > - could you use a shorter name for `numConnectedComponentsPrevIter`. I'm not sure such a long name is really helpful here.
> > - `numConnectedComponentsPrevIter = numConnectedComponents + 1`
> > 
> I have made the name shorter. I cannot do `numConnectedComponentsPrevIter = numConnectedComponents + 1` since I'm using a slightly different logic of updating `numConnectedComponents` at the end of the loop.

I mean before the while loop. Instead of computing twice the length of the list of vertices.
Actually, you can get the number of vertices as `G.order()` and the number of edges as `G.size()`. So use these methods.

Also, you have loops like `for e in G.edges()`. Please use instead `for e in G.edge_iterator()`. The reason for that is that `G.edges()` will actually build the list of edges, and then the for loop will iterate on this list, while using `G.edge_iterator()` we save the construction of the list. It's minor optimization, but it's good to know.

> > - be aware that all comments must be formatted on 80 columns mode. Some code editors help you to do that.
> > 
> I have ensured comments are on 80 columns mode. Does the TESTS and EXAMPLES section also have this restriction? I am unable to make it 80 columns as it contains Sage code.
> > The main issue I see with weights is when `wfunction is None` and the graph is unweighted. Can you try the following idea: instead of working with `edge_list = G.edges()`, use a list of tuples `(e, e_weight)`. So you compute once for all the weight of edge e when you create the list `edge_list` using `wfunction`, and then you can safely compare weights in the `for e in ` loop (which becomes `for e,e_weight in edge_list`). Of course you have to store the cheapest tuple in `cheapest`. This will simplify the code. It might also be faster.

the 80 colimns is only for comments. Sage code can be longer. If you check at the code of the graph module, you will see from time to time that the code is sometimes split on several lines. This is mostly to improve readability (it's also important for the maintainability of the code).

> I have made this change. It did not speed up the computations, but the code is simplified.

That's the objective: simpler code, easier to read, similar performance.


I'll send you later my comments on the examples / tests. Previous sections are fine.


---

Comment by dcoudert created at 2018-03-22 15:15:34

- `:meth:`sage.graphs.generic_graph.GenericGraph.min_spanning_tree`` add `~` before `sage`. I'm not completely sure of the syntax here, but I know it's working with `~`.

  You can rebuild the html references using: `sage -docbuild reference/graphs html`
  Add see if the documentation displays well.

- In the examples, you could start with 

```
sage: from sage.graphs.spanning_tree import boruvka
        sage: G = Graph({1:{2:28, 6:10}, 2:{3:16, 7:14}, 3:{4:12}, 4:{5:22, 7:18}, 5:{6:25, 7:24}}, weighted=True)
sage: G.weighted(True)
sage: boruvka(G, check=True)
[(1, 6, 10), (2, 7, 14), (3, 4, 12), (4, 5, 22), (5, 6, 25), (2, 3, 16)]
sage: boruvka(G, by_weight=True)
[(1, 6, 10), (2, 7, 14), (3, 4, 12), (4, 5, 22), (5, 6, 25), (2, 3, 16)]
sage: boruvka(G, by_weight=False)
[......] # I have not run the code so I don't know the correct answer
```


- then add an example of weight function like :

```
sage: boruvka(G, by_weight=True, wfunction=lambda e:e[2])
[(1, 6, 10), (2, 7, 14), (3, 4, 12), (4, 5, 22), (5, 6, 25), (2, 3, 16)]
sage: boruvka(G, by_weight=True, wfunction=lambda e:float(1/e[2]))
[......] #  I have not run the code so I don't know the correct answer
```


- and an example of non connected graph like:

```
sage: G = Graph([(0,1,1), (2,3,1)], weighted=True)
sage: boruvka(G)
[]
```

- and your example with the tree, but you can fix the size of the random tree to 10. It's enough.

- In the tests, you can keep the `If the input is not a Graph::` case.

All this should already be enough, right ? or do you think it is important to show other examples ? The most important is to cover combinations of parameters with small and simple examples. your method `my_disconnected_graph` is too complex. 

To let you know, these tests / examples are tested many many times, for instance each time a new patch is proposed, even if the new patch has nothing to do with this code. So the faster the examples are the better.


---

Comment by git created at 2018-03-23 18:13:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-23 18:15:06

Replying to [comment:31 dcoudert]:
> Replying to [comment:30 meghanamreddy]:
> > Replying to [comment:28 dcoudert]:
> > > 
> > > - could you use a shorter name for `numConnectedComponentsPrevIter`. I'm not sure such a long name is really helpful here.
> > > - `numConnectedComponentsPrevIter = numConnectedComponents + 1`
> > > 
> > I have made the name shorter. I cannot do `numConnectedComponentsPrevIter = numConnectedComponents + 1` since I'm using a slightly different logic of updating `numConnectedComponents` at the end of the loop.
> 
> I mean before the while loop. Instead of computing twice the length of the list of vertices.
> Actually, you can get the number of vertices as `G.order()` and the number of edges as `G.size()`. So use these methods.
> 

My bad, I have updated it.
> Also, you have loops like `for e in G.edges()`. Please use instead `for e in G.edge_iterator()`. The reason for that is that `G.edges()` will actually build the list of edges, and then the for loop will iterate on this list, while using `G.edge_iterator()` we save the construction of the list. It's minor optimization, but it's good to know.
> 
I have made this change.


---

Comment by meghanamreddy created at 2018-03-23 18:23:50

Replying to [comment:32 dcoudert]:
> 
> - `:meth:`sage.graphs.generic_graph.GenericGraph.min_spanning_tree`` add `~` before `sage`. I'm not completely sure of the syntax here, but I know it's working with `~`.
> 
>   You can rebuild the html references using: `sage -docbuild reference/graphs html`
>   Add see if the documentation displays well.
> 

I checked the documentation and ensured everything displayed well.
> - In the examples, you could start with 

> All this should already be enough, right ? or do you think it is important to show other examples ? The most important is to cover combinations of parameters with small and simple examples. your method `my_disconnected_graph` is too complex. 
> 
> To let you know, these tests / examples are tested many many times, for instance each time a new patch is proposed, even if the new patch has nothing to do with this code. So the faster the examples are the better.
> 
Yes, the examples you mentioned covered all the cases required, so they are definitely enough. I was actually following the examples in the Kruskal's method and used the `my_disconnected_graph` method from there. I have removed the extra examples and kept only the necessary examples.


---

Comment by git created at 2018-03-23 18:33:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-03-23 19:50:29

Now, can you expose this method in the method `min_spanning_tree` in file `generic_graph.py` .

We are almost done !


---

Comment by git created at 2018-03-24 18:45:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-24 19:07:32

Replying to [comment:37 dcoudert]:
> Now, can you expose this method in the method `min_spanning_tree` in file `generic_graph.py` .
> 
> We are almost done !

Thank you. I have added Boruvka to `min_spanning_tree` in file `generic_graph.py`.

Regarding checking if the weights are in RR, `min_spanning_tree` currently converts the weights to float and raises an exception otherwise.

```
wfunction_float = lambda e:float(weight_function(e))
```

We could instead convert the weights to RR using -

```
wfunction_float = lambda e:RR(weight_function(e))
```

Should I go ahead and make this change? Or checking if they are floating point numbers is enough?


---

Comment by dcoudert created at 2018-03-25 10:05:41

weights: the current behavior is fine. So let it as is.

in `generic_graph.py`:
- ```"Boruka"``` -> ```"Boruvka"```

could you add in method boruvka a test like:

```
sage: G = Graph([(u,v,randint(1,5)) for u,v in graphs.CompleteGraph(4).edges(labels=0)], weighted=True)
sage: G.weighted()
True
sage: E1 = G.min_spanning_tree(algorithm='Boruvka')
sage: E2 = G.min_spanning_tree(algorithm='Prim_Boost')
sage: sum(e[2] for e in E1) == sum(e[2] for e in E2)
True
```



---

Comment by dcoudert created at 2018-03-25 10:05:41

Changing status from new to needs_review.


---

Comment by git created at 2018-03-27 18:55:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-03-27 18:57:12

Replying to [comment:40 dcoudert]:
> weights: the current behavior is fine. So let it as is.
> 
> in `generic_graph.py`:
> - ```"Boruka"``` -> ```"Boruvka"```
> 
Changed it, thank you for pointing it out.
> could you add in method boruvka a test like:
> {{{
> sage: G = Graph([(u,v,randint(1,5)) for u,v in graphs.CompleteGraph(4).edges(labels=0)], weighted=True)
> sage: G.weighted()
> True
> sage: E1 = G.min_spanning_tree(algorithm='Boruvka')
> sage: E2 = G.min_spanning_tree(algorithm='Prim_Boost')
> sage: sum(e[2] for e in E1) == sum(e[2] for e in E2)
> True
> }}}
I have added this test to the Boruvka method in `spanning_tree.pyx`.


---

Comment by dcoudert created at 2018-03-27 19:19:15

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2018-03-27 19:19:15

For me the patch is now good to go. Congratulation !


---

Comment by meghanamreddy created at 2018-03-28 07:32:48

Replying to [comment:43 dcoudert]:
> For me the patch is now good to go. Congratulation !
Thank you for guiding me through this patch. I now understand the process better and I'm familiar with the kind of errors and improvements to look out for while coding a patch/algorithm. I'm sure this experience will help me contribute more actively and efficiently from now on. I look forward to contributing more to Sage codebase.


---

Comment by vbraun created at 2018-05-09 09:49:37

Resolution: fixed
