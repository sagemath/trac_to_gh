# Issue 20443: Some optimizations for addition in combinatorial free modules and dict_* methods

Issue created by migration from https://trac.sagemath.org/ticket/20680

Original creator: tscrim

Original creation time: 2016-05-25 15:35:23

Assignee: sage-combinat

CC:  sage-combinat nthiery

Keywords: combinatorial free module, addition

We improve the speed of methods like `dict_addition` in order to improve the speed of addition in `CombinatorialFreeModule`.


---

Comment by tscrim created at 2016-05-25 15:36:07

Changing status from new to needs_review.


---

Comment by git created at 2016-05-25 15:37:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-05-25 16:00:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-05-26 06:06:35

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2016-05-26 06:06:35

Hmmm...slightly worrisome that there is an ordering change to elements in that failing `categories/finite_dimensional_algebras_with_basis.py` test, to which this ticket should not have caused AFAICS. Will investigate.


---

Comment by tscrim created at 2016-05-26 06:13:58

So what the issue is is that the example finite monoid does not have an ordering of its elements. What I am thinking of doing is implementing a `_cmp_` by using the `_cmp_by_value` of `ElementWrapper`. This will make this doctest far less fragile in the future (it's somewhat surprising it is not machine dependent as is), but it then becomes less of a minimal implementation.


---

Comment by tscrim created at 2016-05-26 06:13:58

Changing status from needs_work to needs_info.


---

Comment by git created at 2016-05-26 09:30:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-05-26 09:53:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2016-05-26 12:46:19

Is there anything combinatorics-specific to `dict_addition.pyx`? If not, it should not be in the `combinat` directory. Perhaps move to `data_structures`?


---

Comment by nthiery created at 2016-11-21 14:07:38

Here are some benchmarks, first with plain Sage 5.3, then with
Travis's optimizations, and then after the code refactorization of
commit ee10e70daec5704b4f2c8f63c2cf2e3c525e9311. Sorry that's a bit
long; the timings fluctuate quite some which makes it painful to do.

Rough interpretation: with Travis optimization the speed gain
fluctuates between 1 and 3, and the refactorization does no harm, and
could even improve slightly the situation.

# Protocol

For each n=0,1000,2000,4000, we time the addition of two dictionaries
of length n. Three times for overlapping dictionaries, three times for
half overlapping dictionaries, three times for non overlapping
dictionaries.


```
    def Xn(n): return { i:i for i in range(n) }
    def Yn(n): return { i:i for i in range(n,2*n) }
    def Zn(n): return { i:i for i in range(2*n,3*n) }
```


# Sage 5.3

Setup:

```
    sage: blasadd = sage.combinat.dict_addition.dict_addition
```

Running the tests for a given n:

```
    X = Xn(n); Y = Yn(n); Z = Zn(n)
    %timeit blasadd([X,X])
    %timeit blasadd([X,X])
    %timeit blasadd([X,X])
    %timeit blasadd([X,Y])
    %timeit blasadd([X,Y])
    %timeit blasadd([X,Y])
    %timeit blasadd([X,Z])
    %timeit blasadd([X,Z])
    %timeit blasadd([X,Z])
```


Timings:

```
    n = 0
    1000000 loops, best of 3: 1.12 µs per loop
    1000000 loops, best of 3: 662 ns per loop
    1000000 loops, best of 3: 684 ns per loop

    1000000 loops, best of 3: 646 ns per loop
    1000000 loops, best of 3: 1.04 µs per loop
    1000000 loops, best of 3: 941 ns per loop

    1000000 loops, best of 3: 918 ns per loop
    1000000 loops, best of 3: 705 ns per loop
    1000000 loops, best of 3: 670 ns per loop

    n = 1000
    1000 loops, best of 3: 365 µs per loop
    1000 loops, best of 3: 405 µs per loop
    1000 loops, best of 3: 402 µs per loop

    1000 loops, best of 3: 462 µs per loop
    1000 loops, best of 3: 212 µs per loop
    1000 loops, best of 3: 376 µs per loop

    1000 loops, best of 3: 465 µs per loop
    1000 loops, best of 3: 481 µs per loop
    1000 loops, best of 3: 467 µs per loop

    n=2000
    1000 loops, best of 3: 835 µs per loop
    1000 loops, best of 3: 369 µs per loop
    1000 loops, best of 3: 785 µs per loop

    1000 loops, best of 3: 504 µs per loop
    1000 loops, best of 3: 968 µs per loop
    1000 loops, best of 3: 561 µs per loop

    1000 loops, best of 3: 618 µs per loop
    1000 loops, best of 3: 675 µs per loop
    1000 loops, best of 3: 1.02 ms per loop

    n=4000
    1000 loops, best of 3: 1.11 ms per loop
    1000 loops, best of 3: 1.19 ms per loop
    1000 loops, best of 3: 1.17 ms per loop

    1000 loops, best of 3: 1.82 ms per loop
    1000 loops, best of 3: 1.67 ms per loop
    1000 loops, best of 3: 1.5 ms per loop

    100 loops, best of 3: 2.02 ms per loop
    100 loops, best of 3: 1.1 ms per loop
    1000 loops, best of 3: 1.53 ms per loop
```


# Travis's optimization

Setup:

```
    blasadd = sage.combinat.dict_addition.dict_add
```

Running the tests for a given n:

```
    X = Xn(n); Y = Yn(n); Z = Zn(n)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
```



Timings:

```
    n = 0:
    1000000 loops, best of 3: 677 ns per loop
    1000000 loops, best of 3: 574 ns per loop
    1000000 loops, best of 3: 1.01 µs per loop

    1000000 loops, best of 3: 985 ns per loop
    1000000 loops, best of 3: 640 ns per loop
    1000000 loops, best of 3: 635 ns per loop

    1000000 loops, best of 3: 664 ns per loop
    1000000 loops, best of 3: 489 ns per loop
    1000000 loops, best of 3: 600 ns per loop

    n = 1000: ~.3ms
    1000 loops, best of 3: 357 µs per loop
    1000 loops, best of 3: 353 µs per loop
    1000 loops, best of 3: 373 µs per loop

    1000 loops, best of 3: 282 µs per loop
    1000 loops, best of 3: 283 µs per loop
    1000 loops, best of 3: 259 µs per loop

    1000 loops, best of 3: 302 µs per loop
    1000 loops, best of 3: 315 µs per loop
    1000 loops, best of 3: 313 µs per loop

    n = 2000: .7ms
    1000 loops, best of 3: 787 µs per loop
    1000 loops, best of 3: 778 µs per loop
    1000 loops, best of 3: 747 µs per loop

    1000 loops, best of 3: 175 µs per loop
    1000 loops, best of 3: 343 µs per loop
    1000 loops, best of 3: 256 µs per loop

    1000 loops, best of 3: 682 µs per loop
    1000 loops, best of 3: 330 µs per loop
    1000 loops, best of 3: 662 µs per loop

    n = 4000: 1.2ms
    1000 loops, best of 3: 1.15 ms per loop
    1000 loops, best of 3: 1.46 ms per loop
    1000 loops, best of 3: 1.2 ms per loop

    1000 loops, best of 3: 1.11 ms per loop
    1000 loops, best of 3: 1.09 ms per loop
    1000 loops, best of 3: 800 µs per loop

    1000 loops, best of 3: 985 µs per loop
    1000 loops, best of 3: 915 µs per loop
    1000 loops, best of 3: 1.08 ms per loop
```


# After blas-style refactorization

Setup:

```
    blasadd = sage.data_structures.blas_dict.add
```

Running the tests for a given n:

```
    X = Xn(n); Y = Yn(n); Z = Zn(n)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
```


Timings::

```
    n=0: ~.2ms
    1000000 loops, best of 3: 578 ns per loop
    1000000 loops, best of 3: 603 ns per loop
    1000000 loops, best of 3: 227 ns per loop

    1000000 loops, best of 3: 226 ns per loop
    1000000 loops, best of 3: 391 ns per loop
    1000000 loops, best of 3: 572 ns per loop

    1000000 loops, best of 3: 566 ns per loop
    10000000 loops, best of 3: 515 ns per loop
    1000000 loops, best of 3: 217 ns per loop

    n=1000: ~.3ms
    10000 loops, best of 3: 299 µs per loop
    1000 loops, best of 3: 351 µs per loop
    1000 loops, best of 3: 334 µs per loop

    1000 loops, best of 3: 256 µs per loop
    1000 loops, best of 3: 255 µs per loop
    1000 loops, best of 3: 258 µs per loop

    1000 loops, best of 3: 78.1 µs per loop
    1000 loops, best of 3: 279 µs per loop
    1000 loops, best of 3: 283 µs per loop

    n = 2000: ~.6s
    1000 loops, best of 3: 704 µs per loop
    1000 loops, best of 3: 709 µs per loop
    1000 loops, best of 3: 697 µs per loop

    1000 loops, best of 3: 174 µs per loop
    1000 loops, best of 3: 334 µs per loop
    10000 loops, best of 3: 502 µs per loop

    1000 loops, best of 3: 204 µs per loop
    1000 loops, best of 3: 612 µs per loop
    1000 loops, best of 3: 591 µs per loop

    n = 4000: ~1 ms
    1000 loops, best of 3: 1 ms per loop
    1000 loops, best of 3: 960 µs per loop
    1000 loops, best of 3: 903 µs per loop

    1000 loops, best of 3: 658 µs per loop
    1000 loops, best of 3: 1.04 ms per loop
    1000 loops, best of 3: 723 µs per loop

    1000 loops, best of 3: 1.15 ms per loop
    1000 loops, best of 3: 1.16 ms per loop
    1000 loops, best of 3: 984 µs per loop
```



---

Comment by git created at 2016-11-21 14:07:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nthiery created at 2016-11-21 14:10:08

Replying to [comment:8 jdemeyer]:
> Is there anything combinatorics-specific to `dict_addition.pyx`? If not, it should not be in the `combinat` directory. Perhaps move to `data_structures`?

I agree. I'll chat with Travis here for whether we do it now or in a later ticket.


---

Comment by nthiery created at 2016-11-21 19:47:24

After discussion with Travis:
- We will move it now
- A bit of hesitation between `sage.modules` and `sage.data_structures`; Travis is more in favor of the latter.

Any opinion?

I'll fix some remaining doctest failures in the mean time.


---

Comment by jdemeyer created at 2016-11-22 07:36:29

I also mentioned earlier that `data_structures` seems like a better choice.


---

Comment by git created at 2016-11-22 07:45:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nthiery created at 2016-11-22 08:46:40

Replying to [comment:14 jdemeyer]:
> I also mentioned earlier that `data_structures` seems like a better choice.

Your comment was about `data_structures` versus `combinat`, when we are hesitating between `modules` and `data_structures` :-)

I'll do the move this afternoon.


---

Comment by git created at 2016-11-23 13:56:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-11-23 14:06:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-11-23 14:16:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-11-23 14:24:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nthiery created at 2016-11-23 14:24:42

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2016-11-23 14:33:06

Obvious design question: why don't you implement this as a subclass of `dict` such that you could actually write `a * D` instead of `scal(a, D)`?

I understand that it might be more work this way. It does seem the most natural thing to do and it would result in more readable and more efficient code.


---

Comment by jdemeyer created at 2016-11-23 14:34:56

This should be avoided

```
__cmp__ = ElementWrapper._cmp_by_value
```

as it will not be supported in Python 3.


---

Comment by jdemeyer created at 2016-11-23 14:38:25

Cython knows how to copy dicts efficiently, so you can replace `PyDict_Copy(D)` by `D.copy()` (assuming that `D` is declared as `dict`).


---

Comment by jdemeyer created at 2016-11-23 14:43:00

I think you should also specify exactly what mathematical assumptions you make on `K`. For example, you assume that `bool(x)` implies `bool(-x)` and you assume that `-1 * x = -x`.


---

Comment by jdemeyer created at 2016-11-23 14:48:58

This is false:

```
.. TODO::

    Upon migrating to Python 3, change .iteritems below to .items. We
    don't want to do it now as this is a speed-critical location.
```

Cython supports `.iteritems()` for objects typed as `dict`, so you can just keep `.iteritems()` regardless of Python version.


---

Comment by jdemeyer created at 2016-11-23 14:53:55

I think the `remove_zeros` flag of `iaxpy` is too confusing. You don't really define what happens if `removes_zeros=False` (which keys would appear with a zero value?). I guess that every key which appears in `X` or `Y` should appear in the result, but that is not currently the case.


---

Comment by jdemeyer created at 2016-11-23 14:57:21

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-11-23 22:30:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-11-23 22:34:00

comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`. Furthermore, we couldn't do `a*D + E` in one single operation.

comment:23 - I think this was needed at the time due to the absence of coercion for comparisons for 
`ElementWrapper`.

comment:24 - Done.

comment:25 - I took a crack at it. Let me know if you still think it is unclear.


---

Comment by tscrim created at 2016-11-23 22:34:00

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2016-11-24 07:46:06

Replying to [comment:30 tscrim]:
> comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`.

More precisely, `_mul_` would not be involved since `D` would not be an `Element`. But the coercion model would be involved. If the coercion model is too slow for these purposes, we _really_ should fix that. It makes no sense to make code more complicated just to avoid the coercion model.

> Furthermore, we couldn't do `a*D + E` in one single operation.

True, but then you make a method to do that in a single operation.


---

Comment by jdemeyer created at 2016-11-24 07:50:20

Regarding [comment:27], I think the phrase "values are zero after the addition has
been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?


---

Comment by jdemeyer created at 2016-11-24 08:01:10

Replying to [comment:30 tscrim]:
> comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`. Furthermore, we couldn't do `a*D + E` in one single operation.

OK, new try: how about subclassing `dict` and making all operations methods of that class? That would avoid the inefficiency issues with the coercion model.


---

Comment by jdemeyer created at 2016-11-24 08:01:42

(Edit: wrong ticket)


---

Comment by tscrim created at 2016-11-24 08:22:48

Replying to [comment:31 jdemeyer]:
> Replying to [comment:30 tscrim]:
> > comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`.
> 
> More precisely, `_mul_` would not be involved since `D` would not be an `Element`. But the coercion model would be involved. If the coercion model is too slow for these purposes, we _really_ should fix that. It makes no sense to make code more complicated just to avoid the coercion model.

Sorry, that should have been `__mul__`, but you still need to take some cycles differentiating between `a * D` and `D * a` in Cython. At least, I could not get `__radd__` on a Cython class (different ticket), and I'm assuming that extends to `__rmul__`.

Replying to [comment:33 jdemeyer]:
> OK, new try: how about subclassing dict and making all operations methods of that class? That would avoid the inefficiency issues with the coercion model. 

If we make all operations to be methods of that class, then all I see is unneeded complexity added because we'd still be making (essentially) function calls everywhere, but we have to differentiate between `dict` and `BLASdict`.


---

Comment by tscrim created at 2016-11-24 08:25:01

Replying to [comment:32 jdemeyer]:
> Regarding [comment:27], I think the phrase "values are zero after the addition has
> been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?

I think you're misparsing something. The word `value` is as in key-value pair of a dictionary (because everything we are doing is dictionaries). In some cases, someone might want a basis element that has a coefficient of 0. For instance, it takes longer to remove these coefficients, and if you're doing a lot of additions with full support, you may only want to remove the basis elements with a 0 coefficient after you're all done.


---

Comment by tscrim created at 2016-11-24 08:25:41

Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?


---

Comment by jdemeyer created at 2016-11-24 08:26:42

Replying to [comment:37 tscrim]:
> Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?

Even if you do that, you could still develop it within Sage and then split it off.


---

Comment by jdemeyer created at 2016-11-24 08:28:47

Replying to [comment:36 tscrim]:
> Replying to [comment:32 jdemeyer]:
> > Regarding [comment:27], I think the phrase "values are zero after the addition has
> > been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?
> 
> I think you're misparsing something.

If I am misparsing something, it probably means that the documentation wasn't clear. My question remains: if `remove_zeros=False`, exactly which keys will appear with a zero value?


---

Comment by jdemeyer created at 2016-11-24 08:32:56

Replying to [comment:35 tscrim]:
> At least, I could not get `__radd__` on a Cython class

http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-methods


---

Comment by tscrim created at 2016-11-24 08:33:52

Replying to [comment:39 jdemeyer]:
> Replying to [comment:36 tscrim]:
> > Replying to [comment:32 jdemeyer]:
> > > Regarding [comment:27], I think the phrase "values are zero after the addition has
> > > been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?
> > 
> > I think you're misparsing something.
> 
> If I am misparsing something, it probably means that the documentation wasn't clear. My question remains: if `remove_zeros=False`, exactly which keys will appear with a zero value?

All of them. The point is that if it is true, then remove them.

Edit: That claim might be somewhat vague. If there is a key with a value of 0, then it stays.


---

Comment by tscrim created at 2016-11-24 08:40:34

Replying to [comment:40 jdemeyer]:
> Replying to [comment:35 tscrim]:
> > At least, I could not get `__radd__` on a Cython class
> 
> http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-methods

So I was trying to add an element and a list. I implemented an add that looked like this:

```sage
def __add__(self, other):
    if isinstance(other, list):
        return self + self.parent()(list[0])
    return super(self, Foo).__add__(other)
```

What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`. If it got to `__radd__`, then it would have been after this call, but I was getting an error trying to make the `super` call that wasn't getting caught.


---

Comment by tscrim created at 2016-11-24 08:41:35

Replying to [comment:38 jdemeyer]:
> Replying to [comment:37 tscrim]:
> > Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?
> 
> Even if you do that, you could still develop it within Sage and then split it off.

Nicolas wasn't in favor of doing this as it is just one file.


---

Comment by jdemeyer created at 2016-11-24 09:27:50

Replying to [comment:42 tscrim]:
> So I was trying to add an element and a list. I implemented an add that looked like this:
> {{{#!sage
> def __add__(self, other):
>     if isinstance(other, list):
>         return self + self.parent()(list[0])
>     return super(self, Foo).__add__(other)
> }}}
> What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`.

Right, that is how `__add__` works in a `cdef class`. For this reason, I recommend against using the name `self` in this case. I prefer

```
def __add__(left, right):
```

which shows the more symmetric nature of the arguments.

> If it got to `__radd__`

What do you mean? There is no `__radd__` for a `cdef class`.

> I was getting an error trying to make the `super` call that wasn't getting caught.

Logically, if `self` is not an instance of `Foo`, then `super(self, Foo)` would be an error.


---

Comment by jdemeyer created at 2016-11-24 09:37:15

Replying to [comment:43 tscrim]:
> Nicolas wasn't in favor of doing this as it is just one file.

Makes sense.


---

Comment by tscrim created at 2016-11-24 11:03:22

Replying to [comment:44 jdemeyer]:
> Replying to [comment:42 tscrim]:
> > So I was trying to add an element and a list. I implemented an add that looked like this:
> > {{{#!sage
> > def __add__(self, other):
> >     if isinstance(other, list):
> >         return self + self.parent()(list[0])
> >     return super(self, Foo).__add__(other)
> > }}}
> > What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`.
> 
> Right, that is how `__add__` works in a `cdef class`. For this reason, I recommend against using the name `self` in this case. I prefer
> ...

Ah, sorry, I didn't read the link you sent and misunderstood what you were trying to say. However, that is my point, we would have to check for this in `__mul__`, which takes a few extra cycles. If instead we use a function that has a fixed signature (or at least, semantically), then we don't loose those cycles.

Does comment:41 help with the `remove_zeros`?


---

Comment by tscrim created at 2016-11-24 11:03:22

Changing keywords from "combinatorial free module, addition" to "combinatorial free module, addition, days79".


---

Comment by nthiery created at 2016-11-24 13:07:36

If remove_zeros=True (and the input have no zero values themselves),
then the output is guaranteed to have no zero values. Otherwise the
some zero value may be left in the output. Which ones is voluntarily
left undefined.

The point is that clearing zero values has a cost and there are cases
where the user want to postpone the clearing until the end of a long
series of operations.

Jeroen: does the above clarify the remove_zeros option? If yes, I'll
add it to the documentation.


---

Comment by nthiery created at 2016-11-24 13:16:17

Hi Jeroen,

Thanks for the feedback!

The current design (compared to a class with methods) has two advantages for such a low level use case:

- following a widely used pattern for basic linear algebra operations (used even in OO languages)
- not requiring to coerce / cast inputs when they are provided as plain dictionaries;
  the same holds for output

(and you know that I am a fan of OO :-) )


---

Comment by nthiery created at 2016-11-24 13:17:28

Travis: for some reason, 9570c65ca4bb27fe8ee3dbee82b6ee42c4acb108 includes unrelated changes in `finite_monoids`; could you revert those?


---

Comment by jdemeyer created at 2016-11-24 13:40:14

Replying to [comment:46 tscrim]:
> Ah, sorry, I didn't read the link you sent and misunderstood what you were trying to say. However, that is my point, we would have to check for this in `__mul__`, which takes a few extra cycles. If instead we use a function that has a fixed signature (or at least, semantically), then we don't loose those cycles.

This is an interesting (but wrong) argument. It shows that there are a lot of misconceptions about efficiency in !Python/Cython code.

What is correct:

(1) Arithmetic operators (like `+` implemented as `__add__`) are fast.

(2) `isinstance()` in Cython is fast.

(3) Python function calls are slow.

In turns out that (1) + (2) is actually faster than (3).


---

Comment by jdemeyer created at 2016-11-24 13:46:43

Replying to [comment:47 nthiery]:
> If remove_zeros=True (and the input have no zero values themselves),
> then the output is guaranteed to have no zero values. Otherwise the
> some zero value may be left in the output. Which ones is voluntarily
> left undefined.
> 
> The point is that clearing zero values has a cost and there are cases
> where the user want to postpone the clearing until the end of a long
> series of operations.

> Jeroen: does the above clarify the remove_zeros option? If yes, I'll
> add it to the documentation.

Absolutely (much better than Travis's explanation; sorry Travis).


---

Comment by jdemeyer created at 2016-11-24 13:48:41

Regarding efficiency, let met add this: the module `blas_dict` seems to be used only from Python (not Cython) code, so these efficiency considerations are probably irrelevant anyway.


---

Comment by tscrim created at 2016-11-24 13:55:16

Replying to [comment:52 jdemeyer]:
> Regarding efficiency, let met add this: the module `blas_dict` seems to be used only from Python (not Cython) code, so these efficiency considerations are probably irrelevant anyway.

Nicolas and I are planning to move `CombinatorialFreeModuleElement` to a Cython class, so I would think it would be C function calls in that case?


---

Comment by jdemeyer created at 2016-11-24 13:58:41

First of all, I am not going to insist on implementing this as a subclass. You know better than me how this code is actually used.

Still, some comments:

Replying to [comment:48 nthiery]:
> The current design (compared to a class with methods) has two advantages for such a low level use case:
> 
> - following a widely used pattern for basic linear algebra operations (used even in OO languages)

I believe the standard implementation languages of BLAS are Fortran and C and those are not OO languages.

> - not requiring to coerce / cast inputs when they are provided as plain dictionaries;

Sure, this is indeed a potential disadvantage (but also the only one). Wouldn't it work to just keep the attributes `__monomials` or `_monomial_coefficients` an instance of that type?

>   the same holds for output
Not really for output since it would be a `dict` subclass. So anything expecting a `dict` would still work.


---

Comment by jdemeyer created at 2016-11-24 14:00:25

Replying to [comment:53 tscrim]:
> Nicolas and I are planning to move `CombinatorialFreeModuleElement` to a Cython class, so I would think it would be C function calls in that case?

Yes, provided that you `cimport` (not `import`) the functions. This requires you to add a `.pxd` file. I guess you should do that on this ticket.


---

Comment by git created at 2016-11-24 14:08:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-11-24 14:13:04

I forgot to add the `.pxd` file; thanks for the reminder. I also added Nicolas' explanation of `remove_zeros` to the documentation.


---

Comment by jdemeyer created at 2016-11-24 14:56:11

If you care about efficiency, then `iaxpy` should have the prototype

```
cpdef int iaxpy(....) except -1
```

Returning an `int` is faster than returning the Python `None`.


---

Comment by git created at 2016-11-24 15:36:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-11-24 15:36:34

Replying to [comment:58 jdemeyer]:
> If you care about efficiency, then `iaxpy` should have the prototype
> {{{
> cpdef int iaxpy(....) except -1
> }}}
> Returning an `int` is faster than returning the Python `None`.

Done. This resulted in a 2 microsecond speedup for the `n=1000` benchmark for me.


---

Comment by git created at 2016-12-01 00:29:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-12-01 00:30:26

So there are two doctest failures:

The failure in `categories/finite_dimensional_algebras_with_basis.py` is reordering, and I've fixed it.

The one in `misc/dev_tools.py` is essentially trivial, but it requires some thought as to what the correct change should be. I'm thinking we should find something else that has a unique object name (perhaps `'QQ'`?). However, I want your opinions.

Once that is fixed, perhaps we can get this into Sage?


---

Comment by tscrim created at 2016-12-01 00:30:26

Changing status from needs_review to needs_info.


---

Comment by nthiery created at 2016-12-01 08:57:11

Hi Travis,

Thanks for checking this out. +1 on the first change. For the second, I agree that it's good enough to replace sum by something else with a unique name. The only thing is that this test is about exercising `import_statement` for objects that are defined as aliases. So we need to find some object like this (haven't found one yet).

Then, yes, let's get this in Sage!


---

Comment by tscrim created at 2016-12-01 19:40:25

Replying to [comment:63 nthiery]:
> For the second, I agree that it's good enough to replace sum by something else with a unique name. The only thing is that this test is about exercising `import_statement` for objects that are defined as aliases. So we need to find some object like this (haven't found one yet).

I haven't been able to find one either. We can do something slightly artificial like importing something in the doctest as an alias and checking against that. Should we go that route?


---

Comment by nthiery created at 2016-12-01 22:25:54

Or maybe just remove the test: the feature already has test which seem equivalent, and if we can't find another example, it's not a critical feature anyway.


---

Comment by git created at 2016-12-02 15:20:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-12-02 15:22:25

Okay, I've removed it. So if there are no other objections, then I believe we can set this to a positive review. Next up will be to cythonize `CFMElement`...


---

Comment by tscrim created at 2016-12-02 15:22:25

Changing status from needs_info to needs_review.


---

Comment by git created at 2016-12-03 11:22:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nthiery created at 2016-12-03 11:28:45

Hi,

I checked the patchbot reports. I fixed the non-ascii issue. The startup-module report is normal. There are two python3 issue: one in a speed-critical section which we had discussed and decided to be a necessary evil. The other is a false positive (existing cmp in a line of code that was respaced).

Hence positive review!


---

Comment by nthiery created at 2016-12-03 11:29:40

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2016-12-03 12:24:31

Replying to [comment:69 nthiery]:
> There are two python3 issue: one in a speed-critical section which we had discussed and decided to be a necessary evil.

That's a non-issue. Cython != Python and Cython does support `.iteritems()` for dicts.


---

Comment by vbraun created at 2016-12-05 00:44:31

Resolution: fixed
