# Issue 20443: Some optimizations for addition in combinatorial free modules and dict_* methods

archive/issues_020443.json:
```json
{
    "body": "Assignee: sage-combinat\n\nCC:  sage-combinat @nthiery\n\nKeywords: combinatorial free module, addition, days79\n\nWe improve the speed of methods like `dict_addition` in order to improve the speed of addition in `CombinatorialFreeModule`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20680\n\n",
    "closed_at": "2016-12-05T00:44:31Z",
    "created_at": "2016-05-25T15:35:23Z",
    "labels": [
        "component: performance"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.5",
    "title": "Some optimizations for addition in combinatorial free modules and dict_* methods",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20443",
    "user": "https://github.com/tscrim"
}
```
Assignee: sage-combinat

CC:  sage-combinat @nthiery

Keywords: combinatorial free module, addition, days79

We improve the speed of methods like `dict_addition` in order to improve the speed of addition in `CombinatorialFreeModule`.

Issue created by migration from https://trac.sagemath.org/ticket/20680





---

archive/issue_comments_281368.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-05-25T15:36:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281368",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_281369.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-25T15:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281369",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281370.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-25T16:00:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281370",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281371.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-05-26T06:06:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281371",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_281372.json:
```json
{
    "body": "Hmmm...slightly worrisome that there is an ordering change to elements in that failing `categories/finite_dimensional_algebras_with_basis.py` test, to which this ticket should not have caused AFAICS. Will investigate.",
    "created_at": "2016-05-26T06:06:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281372",
    "user": "https://github.com/tscrim"
}
```

Hmmm...slightly worrisome that there is an ordering change to elements in that failing `categories/finite_dimensional_algebras_with_basis.py` test, to which this ticket should not have caused AFAICS. Will investigate.



---

archive/issue_comments_281373.json:
```json
{
    "body": "So what the issue is is that the example finite monoid does not have an ordering of its elements. What I am thinking of doing is implementing a `_cmp_` by using the `_cmp_by_value` of `ElementWrapper`. This will make this doctest far less fragile in the future (it's somewhat surprising it is not machine dependent as is), but it then becomes less of a minimal implementation.",
    "created_at": "2016-05-26T06:13:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281373",
    "user": "https://github.com/tscrim"
}
```

So what the issue is is that the example finite monoid does not have an ordering of its elements. What I am thinking of doing is implementing a `_cmp_` by using the `_cmp_by_value` of `ElementWrapper`. This will make this doctest far less fragile in the future (it's somewhat surprising it is not machine dependent as is), but it then becomes less of a minimal implementation.



---

archive/issue_comments_281374.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2016-05-26T06:13:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281374",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_281375.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-26T09:30:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281375",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281376.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-26T09:53:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281376",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281377.json:
```json
{
    "body": "Is there anything combinatorics-specific to `dict_addition.pyx`? If not, it should not be in the `combinat` directory. Perhaps move to `data_structures`?",
    "created_at": "2016-05-26T12:46:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281377",
    "user": "https://github.com/jdemeyer"
}
```

Is there anything combinatorics-specific to `dict_addition.pyx`? If not, it should not be in the `combinat` directory. Perhaps move to `data_structures`?



---

archive/issue_comments_281378.json:
```json
{
    "body": "Here are some benchmarks, first with plain Sage 5.3, then with\nTravis's optimizations, and then after the code refactorization of\ncommit ee10e70daec5704b4f2c8f63c2cf2e3c525e9311. Sorry that's a bit\nlong; the timings fluctuate quite some which makes it painful to do.\n\nRough interpretation: with Travis optimization the speed gain\nfluctuates between 1 and 3, and the refactorization does no harm, and\ncould even improve slightly the situation.\n\n# Protocol\n\nFor each n=0,1000,2000,4000, we time the addition of two dictionaries\nof length n. Three times for overlapping dictionaries, three times for\nhalf overlapping dictionaries, three times for non overlapping\ndictionaries.\n\n```\n    def Xn(n): return { i:i for i in range(n) }\n    def Yn(n): return { i:i for i in range(n,2*n) }\n    def Zn(n): return { i:i for i in range(2*n,3*n) }\n```\n\n# Sage 5.3\n\nSetup:\n\n```\n    sage: blasadd = sage.combinat.dict_addition.dict_addition\n```\nRunning the tests for a given n:\n\n```\n    X = Xn(n); Y = Yn(n); Z = Zn(n)\n    %timeit blasadd([X,X])\n    %timeit blasadd([X,X])\n    %timeit blasadd([X,X])\n    %timeit blasadd([X,Y])\n    %timeit blasadd([X,Y])\n    %timeit blasadd([X,Y])\n    %timeit blasadd([X,Z])\n    %timeit blasadd([X,Z])\n    %timeit blasadd([X,Z])\n```\n\nTimings:\n\n```\n    n = 0\n    1000000 loops, best of 3: 1.12 \u00b5s per loop\n    1000000 loops, best of 3: 662 ns per loop\n    1000000 loops, best of 3: 684 ns per loop\n\n    1000000 loops, best of 3: 646 ns per loop\n    1000000 loops, best of 3: 1.04 \u00b5s per loop\n    1000000 loops, best of 3: 941 ns per loop\n\n    1000000 loops, best of 3: 918 ns per loop\n    1000000 loops, best of 3: 705 ns per loop\n    1000000 loops, best of 3: 670 ns per loop\n\n    n = 1000\n    1000 loops, best of 3: 365 \u00b5s per loop\n    1000 loops, best of 3: 405 \u00b5s per loop\n    1000 loops, best of 3: 402 \u00b5s per loop\n\n    1000 loops, best of 3: 462 \u00b5s per loop\n    1000 loops, best of 3: 212 \u00b5s per loop\n    1000 loops, best of 3: 376 \u00b5s per loop\n\n    1000 loops, best of 3: 465 \u00b5s per loop\n    1000 loops, best of 3: 481 \u00b5s per loop\n    1000 loops, best of 3: 467 \u00b5s per loop\n\n    n=2000\n    1000 loops, best of 3: 835 \u00b5s per loop\n    1000 loops, best of 3: 369 \u00b5s per loop\n    1000 loops, best of 3: 785 \u00b5s per loop\n\n    1000 loops, best of 3: 504 \u00b5s per loop\n    1000 loops, best of 3: 968 \u00b5s per loop\n    1000 loops, best of 3: 561 \u00b5s per loop\n\n    1000 loops, best of 3: 618 \u00b5s per loop\n    1000 loops, best of 3: 675 \u00b5s per loop\n    1000 loops, best of 3: 1.02 ms per loop\n\n    n=4000\n    1000 loops, best of 3: 1.11 ms per loop\n    1000 loops, best of 3: 1.19 ms per loop\n    1000 loops, best of 3: 1.17 ms per loop\n\n    1000 loops, best of 3: 1.82 ms per loop\n    1000 loops, best of 3: 1.67 ms per loop\n    1000 loops, best of 3: 1.5 ms per loop\n\n    100 loops, best of 3: 2.02 ms per loop\n    100 loops, best of 3: 1.1 ms per loop\n    1000 loops, best of 3: 1.53 ms per loop\n```\n\n# Travis's optimization\n\nSetup:\n\n```\n    blasadd = sage.combinat.dict_addition.dict_add\n```\nRunning the tests for a given n:\n\n```\n    X = Xn(n); Y = Yn(n); Z = Zn(n)\n    %timeit blasadd(X,X)\n    %timeit blasadd(X,X)\n    %timeit blasadd(X,X)\n    %timeit blasadd(X,Y)\n    %timeit blasadd(X,Y)\n    %timeit blasadd(X,Y)\n    %timeit blasadd(X,Z)\n    %timeit blasadd(X,Z)\n    %timeit blasadd(X,Z)\n```\n\n\nTimings:\n\n```\n    n = 0:\n    1000000 loops, best of 3: 677 ns per loop\n    1000000 loops, best of 3: 574 ns per loop\n    1000000 loops, best of 3: 1.01 \u00b5s per loop\n\n    1000000 loops, best of 3: 985 ns per loop\n    1000000 loops, best of 3: 640 ns per loop\n    1000000 loops, best of 3: 635 ns per loop\n\n    1000000 loops, best of 3: 664 ns per loop\n    1000000 loops, best of 3: 489 ns per loop\n    1000000 loops, best of 3: 600 ns per loop\n\n    n = 1000: ~.3ms\n    1000 loops, best of 3: 357 \u00b5s per loop\n    1000 loops, best of 3: 353 \u00b5s per loop\n    1000 loops, best of 3: 373 \u00b5s per loop\n\n    1000 loops, best of 3: 282 \u00b5s per loop\n    1000 loops, best of 3: 283 \u00b5s per loop\n    1000 loops, best of 3: 259 \u00b5s per loop\n\n    1000 loops, best of 3: 302 \u00b5s per loop\n    1000 loops, best of 3: 315 \u00b5s per loop\n    1000 loops, best of 3: 313 \u00b5s per loop\n\n    n = 2000: .7ms\n    1000 loops, best of 3: 787 \u00b5s per loop\n    1000 loops, best of 3: 778 \u00b5s per loop\n    1000 loops, best of 3: 747 \u00b5s per loop\n\n    1000 loops, best of 3: 175 \u00b5s per loop\n    1000 loops, best of 3: 343 \u00b5s per loop\n    1000 loops, best of 3: 256 \u00b5s per loop\n\n    1000 loops, best of 3: 682 \u00b5s per loop\n    1000 loops, best of 3: 330 \u00b5s per loop\n    1000 loops, best of 3: 662 \u00b5s per loop\n\n    n = 4000: 1.2ms\n    1000 loops, best of 3: 1.15 ms per loop\n    1000 loops, best of 3: 1.46 ms per loop\n    1000 loops, best of 3: 1.2 ms per loop\n\n    1000 loops, best of 3: 1.11 ms per loop\n    1000 loops, best of 3: 1.09 ms per loop\n    1000 loops, best of 3: 800 \u00b5s per loop\n\n    1000 loops, best of 3: 985 \u00b5s per loop\n    1000 loops, best of 3: 915 \u00b5s per loop\n    1000 loops, best of 3: 1.08 ms per loop\n```\n\n# After blas-style refactorization\n\nSetup:\n\n```\n    blasadd = sage.data_structures.blas_dict.add\n```\nRunning the tests for a given n:\n\n```\n    X = Xn(n); Y = Yn(n); Z = Zn(n)\n    %timeit blasadd(X,X)\n    %timeit blasadd(X,X)\n    %timeit blasadd(X,X)\n    %timeit blasadd(X,Y)\n    %timeit blasadd(X,Y)\n    %timeit blasadd(X,Y)\n    %timeit blasadd(X,Z)\n    %timeit blasadd(X,Z)\n    %timeit blasadd(X,Z)\n```\n\nTimings::\n\n```\n    n=0: ~.2ms\n    1000000 loops, best of 3: 578 ns per loop\n    1000000 loops, best of 3: 603 ns per loop\n    1000000 loops, best of 3: 227 ns per loop\n\n    1000000 loops, best of 3: 226 ns per loop\n    1000000 loops, best of 3: 391 ns per loop\n    1000000 loops, best of 3: 572 ns per loop\n\n    1000000 loops, best of 3: 566 ns per loop\n    10000000 loops, best of 3: 515 ns per loop\n    1000000 loops, best of 3: 217 ns per loop\n\n    n=1000: ~.3ms\n    10000 loops, best of 3: 299 \u00b5s per loop\n    1000 loops, best of 3: 351 \u00b5s per loop\n    1000 loops, best of 3: 334 \u00b5s per loop\n\n    1000 loops, best of 3: 256 \u00b5s per loop\n    1000 loops, best of 3: 255 \u00b5s per loop\n    1000 loops, best of 3: 258 \u00b5s per loop\n\n    1000 loops, best of 3: 78.1 \u00b5s per loop\n    1000 loops, best of 3: 279 \u00b5s per loop\n    1000 loops, best of 3: 283 \u00b5s per loop\n\n    n = 2000: ~.6s\n    1000 loops, best of 3: 704 \u00b5s per loop\n    1000 loops, best of 3: 709 \u00b5s per loop\n    1000 loops, best of 3: 697 \u00b5s per loop\n\n    1000 loops, best of 3: 174 \u00b5s per loop\n    1000 loops, best of 3: 334 \u00b5s per loop\n    10000 loops, best of 3: 502 \u00b5s per loop\n\n    1000 loops, best of 3: 204 \u00b5s per loop\n    1000 loops, best of 3: 612 \u00b5s per loop\n    1000 loops, best of 3: 591 \u00b5s per loop\n\n    n = 4000: ~1 ms\n    1000 loops, best of 3: 1 ms per loop\n    1000 loops, best of 3: 960 \u00b5s per loop\n    1000 loops, best of 3: 903 \u00b5s per loop\n\n    1000 loops, best of 3: 658 \u00b5s per loop\n    1000 loops, best of 3: 1.04 ms per loop\n    1000 loops, best of 3: 723 \u00b5s per loop\n\n    1000 loops, best of 3: 1.15 ms per loop\n    1000 loops, best of 3: 1.16 ms per loop\n    1000 loops, best of 3: 984 \u00b5s per loop\n```",
    "created_at": "2016-11-21T14:07:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281378",
    "user": "https://github.com/nthiery"
}
```

Here are some benchmarks, first with plain Sage 5.3, then with
Travis's optimizations, and then after the code refactorization of
commit ee10e70daec5704b4f2c8f63c2cf2e3c525e9311. Sorry that's a bit
long; the timings fluctuate quite some which makes it painful to do.

Rough interpretation: with Travis optimization the speed gain
fluctuates between 1 and 3, and the refactorization does no harm, and
could even improve slightly the situation.

# Protocol

For each n=0,1000,2000,4000, we time the addition of two dictionaries
of length n. Three times for overlapping dictionaries, three times for
half overlapping dictionaries, three times for non overlapping
dictionaries.

```
    def Xn(n): return { i:i for i in range(n) }
    def Yn(n): return { i:i for i in range(n,2*n) }
    def Zn(n): return { i:i for i in range(2*n,3*n) }
```

# Sage 5.3

Setup:

```
    sage: blasadd = sage.combinat.dict_addition.dict_addition
```
Running the tests for a given n:

```
    X = Xn(n); Y = Yn(n); Z = Zn(n)
    %timeit blasadd([X,X])
    %timeit blasadd([X,X])
    %timeit blasadd([X,X])
    %timeit blasadd([X,Y])
    %timeit blasadd([X,Y])
    %timeit blasadd([X,Y])
    %timeit blasadd([X,Z])
    %timeit blasadd([X,Z])
    %timeit blasadd([X,Z])
```

Timings:

```
    n = 0
    1000000 loops, best of 3: 1.12 µs per loop
    1000000 loops, best of 3: 662 ns per loop
    1000000 loops, best of 3: 684 ns per loop

    1000000 loops, best of 3: 646 ns per loop
    1000000 loops, best of 3: 1.04 µs per loop
    1000000 loops, best of 3: 941 ns per loop

    1000000 loops, best of 3: 918 ns per loop
    1000000 loops, best of 3: 705 ns per loop
    1000000 loops, best of 3: 670 ns per loop

    n = 1000
    1000 loops, best of 3: 365 µs per loop
    1000 loops, best of 3: 405 µs per loop
    1000 loops, best of 3: 402 µs per loop

    1000 loops, best of 3: 462 µs per loop
    1000 loops, best of 3: 212 µs per loop
    1000 loops, best of 3: 376 µs per loop

    1000 loops, best of 3: 465 µs per loop
    1000 loops, best of 3: 481 µs per loop
    1000 loops, best of 3: 467 µs per loop

    n=2000
    1000 loops, best of 3: 835 µs per loop
    1000 loops, best of 3: 369 µs per loop
    1000 loops, best of 3: 785 µs per loop

    1000 loops, best of 3: 504 µs per loop
    1000 loops, best of 3: 968 µs per loop
    1000 loops, best of 3: 561 µs per loop

    1000 loops, best of 3: 618 µs per loop
    1000 loops, best of 3: 675 µs per loop
    1000 loops, best of 3: 1.02 ms per loop

    n=4000
    1000 loops, best of 3: 1.11 ms per loop
    1000 loops, best of 3: 1.19 ms per loop
    1000 loops, best of 3: 1.17 ms per loop

    1000 loops, best of 3: 1.82 ms per loop
    1000 loops, best of 3: 1.67 ms per loop
    1000 loops, best of 3: 1.5 ms per loop

    100 loops, best of 3: 2.02 ms per loop
    100 loops, best of 3: 1.1 ms per loop
    1000 loops, best of 3: 1.53 ms per loop
```

# Travis's optimization

Setup:

```
    blasadd = sage.combinat.dict_addition.dict_add
```
Running the tests for a given n:

```
    X = Xn(n); Y = Yn(n); Z = Zn(n)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
```


Timings:

```
    n = 0:
    1000000 loops, best of 3: 677 ns per loop
    1000000 loops, best of 3: 574 ns per loop
    1000000 loops, best of 3: 1.01 µs per loop

    1000000 loops, best of 3: 985 ns per loop
    1000000 loops, best of 3: 640 ns per loop
    1000000 loops, best of 3: 635 ns per loop

    1000000 loops, best of 3: 664 ns per loop
    1000000 loops, best of 3: 489 ns per loop
    1000000 loops, best of 3: 600 ns per loop

    n = 1000: ~.3ms
    1000 loops, best of 3: 357 µs per loop
    1000 loops, best of 3: 353 µs per loop
    1000 loops, best of 3: 373 µs per loop

    1000 loops, best of 3: 282 µs per loop
    1000 loops, best of 3: 283 µs per loop
    1000 loops, best of 3: 259 µs per loop

    1000 loops, best of 3: 302 µs per loop
    1000 loops, best of 3: 315 µs per loop
    1000 loops, best of 3: 313 µs per loop

    n = 2000: .7ms
    1000 loops, best of 3: 787 µs per loop
    1000 loops, best of 3: 778 µs per loop
    1000 loops, best of 3: 747 µs per loop

    1000 loops, best of 3: 175 µs per loop
    1000 loops, best of 3: 343 µs per loop
    1000 loops, best of 3: 256 µs per loop

    1000 loops, best of 3: 682 µs per loop
    1000 loops, best of 3: 330 µs per loop
    1000 loops, best of 3: 662 µs per loop

    n = 4000: 1.2ms
    1000 loops, best of 3: 1.15 ms per loop
    1000 loops, best of 3: 1.46 ms per loop
    1000 loops, best of 3: 1.2 ms per loop

    1000 loops, best of 3: 1.11 ms per loop
    1000 loops, best of 3: 1.09 ms per loop
    1000 loops, best of 3: 800 µs per loop

    1000 loops, best of 3: 985 µs per loop
    1000 loops, best of 3: 915 µs per loop
    1000 loops, best of 3: 1.08 ms per loop
```

# After blas-style refactorization

Setup:

```
    blasadd = sage.data_structures.blas_dict.add
```
Running the tests for a given n:

```
    X = Xn(n); Y = Yn(n); Z = Zn(n)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,X)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Y)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
    %timeit blasadd(X,Z)
```

Timings::

```
    n=0: ~.2ms
    1000000 loops, best of 3: 578 ns per loop
    1000000 loops, best of 3: 603 ns per loop
    1000000 loops, best of 3: 227 ns per loop

    1000000 loops, best of 3: 226 ns per loop
    1000000 loops, best of 3: 391 ns per loop
    1000000 loops, best of 3: 572 ns per loop

    1000000 loops, best of 3: 566 ns per loop
    10000000 loops, best of 3: 515 ns per loop
    1000000 loops, best of 3: 217 ns per loop

    n=1000: ~.3ms
    10000 loops, best of 3: 299 µs per loop
    1000 loops, best of 3: 351 µs per loop
    1000 loops, best of 3: 334 µs per loop

    1000 loops, best of 3: 256 µs per loop
    1000 loops, best of 3: 255 µs per loop
    1000 loops, best of 3: 258 µs per loop

    1000 loops, best of 3: 78.1 µs per loop
    1000 loops, best of 3: 279 µs per loop
    1000 loops, best of 3: 283 µs per loop

    n = 2000: ~.6s
    1000 loops, best of 3: 704 µs per loop
    1000 loops, best of 3: 709 µs per loop
    1000 loops, best of 3: 697 µs per loop

    1000 loops, best of 3: 174 µs per loop
    1000 loops, best of 3: 334 µs per loop
    10000 loops, best of 3: 502 µs per loop

    1000 loops, best of 3: 204 µs per loop
    1000 loops, best of 3: 612 µs per loop
    1000 loops, best of 3: 591 µs per loop

    n = 4000: ~1 ms
    1000 loops, best of 3: 1 ms per loop
    1000 loops, best of 3: 960 µs per loop
    1000 loops, best of 3: 903 µs per loop

    1000 loops, best of 3: 658 µs per loop
    1000 loops, best of 3: 1.04 ms per loop
    1000 loops, best of 3: 723 µs per loop

    1000 loops, best of 3: 1.15 ms per loop
    1000 loops, best of 3: 1.16 ms per loop
    1000 loops, best of 3: 984 µs per loop
```



---

archive/issue_comments_281379.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-21T14:07:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281379",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281380.json:
```json
{
    "body": "Replying to [comment:8 jdemeyer]:\n> Is there anything combinatorics-specific to `dict_addition.pyx`? If not, it should not be in the `combinat` directory. Perhaps move to `data_structures`?\n\n\nI agree. I'll chat with Travis here for whether we do it now or in a later ticket.",
    "created_at": "2016-11-21T14:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281380",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:8 jdemeyer]:
> Is there anything combinatorics-specific to `dict_addition.pyx`? If not, it should not be in the `combinat` directory. Perhaps move to `data_structures`?


I agree. I'll chat with Travis here for whether we do it now or in a later ticket.



---

archive/issue_comments_281381.json:
```json
{
    "body": "After discussion with Travis:\n- We will move it now\n- A bit of hesitation between `sage.modules` and `sage.data_structures`; Travis is more in favor of the latter.\n\nAny opinion?\n\nI'll fix some remaining doctest failures in the mean time.",
    "created_at": "2016-11-21T19:47:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281381",
    "user": "https://github.com/nthiery"
}
```

After discussion with Travis:
- We will move it now
- A bit of hesitation between `sage.modules` and `sage.data_structures`; Travis is more in favor of the latter.

Any opinion?

I'll fix some remaining doctest failures in the mean time.



---

archive/issue_comments_281382.json:
```json
{
    "body": "I also mentioned earlier that `data_structures` seems like a better choice.",
    "created_at": "2016-11-22T07:36:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281382",
    "user": "https://github.com/jdemeyer"
}
```

I also mentioned earlier that `data_structures` seems like a better choice.



---

archive/issue_comments_281383.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-22T07:45:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281383",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281384.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> I also mentioned earlier that `data_structures` seems like a better choice.\n\n\nYour comment was about `data_structures` versus `combinat`, when we are hesitating between `modules` and `data_structures` :-)\n\nI'll do the move this afternoon.",
    "created_at": "2016-11-22T08:46:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281384",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:14 jdemeyer]:
> I also mentioned earlier that `data_structures` seems like a better choice.


Your comment was about `data_structures` versus `combinat`, when we are hesitating between `modules` and `data_structures` :-)

I'll do the move this afternoon.



---

archive/issue_comments_281385.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-23T13:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281385",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281386.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-23T14:06:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281386",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281387.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-23T14:16:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281387",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281388.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-23T14:24:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281388",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281389.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-11-23T14:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281389",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_281390.json:
```json
{
    "body": "Obvious design question: why don't you implement this as a subclass of `dict` such that you could actually write `a * D` instead of `scal(a, D)`?\n\nI understand that it might be more work this way. It does seem the most natural thing to do and it would result in more readable and more efficient code.",
    "created_at": "2016-11-23T14:33:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281390",
    "user": "https://github.com/jdemeyer"
}
```

Obvious design question: why don't you implement this as a subclass of `dict` such that you could actually write `a * D` instead of `scal(a, D)`?

I understand that it might be more work this way. It does seem the most natural thing to do and it would result in more readable and more efficient code.



---

archive/issue_comments_281391.json:
```json
{
    "body": "This should be avoided\n\n```\n__cmp__ = ElementWrapper._cmp_by_value\n```\nas it will not be supported in Python 3.",
    "created_at": "2016-11-23T14:34:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281391",
    "user": "https://github.com/jdemeyer"
}
```

This should be avoided

```
__cmp__ = ElementWrapper._cmp_by_value
```
as it will not be supported in Python 3.



---

archive/issue_comments_281392.json:
```json
{
    "body": "Cython knows how to copy dicts efficiently, so you can replace `PyDict_Copy(D)` by `D.copy()` (assuming that `D` is declared as `dict`).",
    "created_at": "2016-11-23T14:38:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281392",
    "user": "https://github.com/jdemeyer"
}
```

Cython knows how to copy dicts efficiently, so you can replace `PyDict_Copy(D)` by `D.copy()` (assuming that `D` is declared as `dict`).



---

archive/issue_comments_281393.json:
```json
{
    "body": "I think you should also specify exactly what mathematical assumptions you make on `K`. For example, you assume that `bool(x)` implies `bool(-x)` and you assume that `-1 * x = -x`.",
    "created_at": "2016-11-23T14:43:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281393",
    "user": "https://github.com/jdemeyer"
}
```

I think you should also specify exactly what mathematical assumptions you make on `K`. For example, you assume that `bool(x)` implies `bool(-x)` and you assume that `-1 * x = -x`.



---

archive/issue_comments_281394.json:
```json
{
    "body": "This is false:\n\n```\n.. TODO::\n\n    Upon migrating to Python 3, change .iteritems below to .items. We\n    don't want to do it now as this is a speed-critical location.\n```\nCython supports `.iteritems()` for objects typed as `dict`, so you can just keep `.iteritems()` regardless of Python version.",
    "created_at": "2016-11-23T14:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281394",
    "user": "https://github.com/jdemeyer"
}
```

This is false:

```
.. TODO::

    Upon migrating to Python 3, change .iteritems below to .items. We
    don't want to do it now as this is a speed-critical location.
```
Cython supports `.iteritems()` for objects typed as `dict`, so you can just keep `.iteritems()` regardless of Python version.



---

archive/issue_comments_281395.json:
```json
{
    "body": "I think the `remove_zeros` flag of `iaxpy` is too confusing. You don't really define what happens if `removes_zeros=False` (which keys would appear with a zero value?). I guess that every key which appears in `X` or `Y` should appear in the result, but that is not currently the case.",
    "created_at": "2016-11-23T14:53:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281395",
    "user": "https://github.com/jdemeyer"
}
```

I think the `remove_zeros` flag of `iaxpy` is too confusing. You don't really define what happens if `removes_zeros=False` (which keys would appear with a zero value?). I guess that every key which appears in `X` or `Y` should appear in the result, but that is not currently the case.



---

archive/issue_comments_281396.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-11-23T14:57:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281396",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_281397.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-23T22:30:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281397",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281398.json:
```json
{
    "body": "comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`. Furthermore, we couldn't do `a*D + E` in one single operation.\n\ncomment:23 - I think this was needed at the time due to the absence of coercion for comparisons for \n`ElementWrapper`.\n\ncomment:24 - Done.\n\ncomment:25 - I took a crack at it. Let me know if you still think it is unclear.",
    "created_at": "2016-11-23T22:34:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281398",
    "user": "https://github.com/tscrim"
}
```

comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`. Furthermore, we couldn't do `a*D + E` in one single operation.

comment:23 - I think this was needed at the time due to the absence of coercion for comparisons for 
`ElementWrapper`.

comment:24 - Done.

comment:25 - I took a crack at it. Let me know if you still think it is unclear.



---

archive/issue_comments_281399.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-11-23T22:34:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281399",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_events_055655.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2016-11-23T22:34:00Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "milestone": "sage-7.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/20443#event-55655"
}
```



---

archive/issue_comments_281400.json:
```json
{
    "body": "Replying to [comment:30 tscrim]:\n> comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`.\n\n\nMore precisely, `_mul_` would not be involved since `D` would not be an `Element`. But the coercion model would be involved. If the coercion model is too slow for these purposes, we *really* should fix that. It makes no sense to make code more complicated just to avoid the coercion model.\n\n> Furthermore, we couldn't do `a*D + E` in one single operation.\n\n\nTrue, but then you make a method to do that in a single operation.",
    "created_at": "2016-11-24T07:46:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281400",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:30 tscrim]:
> comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`.


More precisely, `_mul_` would not be involved since `D` would not be an `Element`. But the coercion model would be involved. If the coercion model is too slow for these purposes, we *really* should fix that. It makes no sense to make code more complicated just to avoid the coercion model.

> Furthermore, we couldn't do `a*D + E` in one single operation.


True, but then you make a method to do that in a single operation.



---

archive/issue_comments_281401.json:
```json
{
    "body": "Regarding [comment:27], I think the phrase \"values are zero after the addition has\nbeen performed\" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?",
    "created_at": "2016-11-24T07:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281401",
    "user": "https://github.com/jdemeyer"
}
```

Regarding [comment:27], I think the phrase "values are zero after the addition has
been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?



---

archive/issue_comments_281402.json:
```json
{
    "body": "Replying to [comment:30 tscrim]:\n> comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`. Furthermore, we couldn't do `a*D + E` in one single operation.\n\n\nOK, new try: how about subclassing `dict` and making all operations methods of that class? That would avoid the inefficiency issues with the coercion model.",
    "created_at": "2016-11-24T08:01:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281402",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:30 tscrim]:
> comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`. Furthermore, we couldn't do `a*D + E` in one single operation.


OK, new try: how about subclassing `dict` and making all operations methods of that class? That would avoid the inefficiency issues with the coercion model.



---

archive/issue_comments_281403.json:
```json
{
    "body": "(Edit: wrong ticket)",
    "created_at": "2016-11-24T08:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281403",
    "user": "https://github.com/jdemeyer"
}
```

(Edit: wrong ticket)



---

archive/issue_comments_281404.json:
```json
{
    "body": "Replying to [comment:31 jdemeyer]:\n> Replying to [comment:30 tscrim]:\n> > comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`.\n\n> \n> More precisely, `_mul_` would not be involved since `D` would not be an `Element`. But the coercion model would be involved. If the coercion model is too slow for these purposes, we *really* should fix that. It makes no sense to make code more complicated just to avoid the coercion model.\n\n\nSorry, that should have been `__mul__`, but you still need to take some cycles differentiating between `a * D` and `D * a` in Cython. At least, I could not get `__radd__` on a Cython class (different ticket), and I'm assuming that extends to `__rmul__`.\n\nReplying to [comment:33 jdemeyer]:\n> OK, new try: how about subclassing dict and making all operations methods of that class? That would avoid the inefficiency issues with the coercion model. \n\n\nIf we make all operations to be methods of that class, then all I see is unneeded complexity added because we'd still be making (essentially) function calls everywhere, but we have to differentiate between `dict` and `BLASdict`.",
    "created_at": "2016-11-24T08:22:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281404",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:31 jdemeyer]:
> Replying to [comment:30 tscrim]:
> > comment:22 - This would be quite difficult to do because we would have to handle `a * D` and `D * a`, which would take more time because they would both pass through `_mul_`.

> 
> More precisely, `_mul_` would not be involved since `D` would not be an `Element`. But the coercion model would be involved. If the coercion model is too slow for these purposes, we *really* should fix that. It makes no sense to make code more complicated just to avoid the coercion model.


Sorry, that should have been `__mul__`, but you still need to take some cycles differentiating between `a * D` and `D * a` in Cython. At least, I could not get `__radd__` on a Cython class (different ticket), and I'm assuming that extends to `__rmul__`.

Replying to [comment:33 jdemeyer]:
> OK, new try: how about subclassing dict and making all operations methods of that class? That would avoid the inefficiency issues with the coercion model. 


If we make all operations to be methods of that class, then all I see is unneeded complexity added because we'd still be making (essentially) function calls everywhere, but we have to differentiate between `dict` and `BLASdict`.



---

archive/issue_comments_281405.json:
```json
{
    "body": "Replying to [comment:32 jdemeyer]:\n> Regarding [comment:27], I think the phrase \"values are zero after the addition has\n> been performed\" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?\n\n\nI think you're misparsing something. The word `value` is as in key-value pair of a dictionary (because everything we are doing is dictionaries). In some cases, someone might want a basis element that has a coefficient of 0. For instance, it takes longer to remove these coefficients, and if you're doing a lot of additions with full support, you may only want to remove the basis elements with a 0 coefficient after you're all done.",
    "created_at": "2016-11-24T08:25:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281405",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:32 jdemeyer]:
> Regarding [comment:27], I think the phrase "values are zero after the addition has
> been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?


I think you're misparsing something. The word `value` is as in key-value pair of a dictionary (because everything we are doing is dictionaries). In some cases, someone might want a basis element that has a coefficient of 0. For instance, it takes longer to remove these coefficients, and if you're doing a lot of additions with full support, you may only want to remove the basis elements with a 0 coefficient after you're all done.



---

archive/issue_comments_281406.json:
```json
{
    "body": "Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?",
    "created_at": "2016-11-24T08:25:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281406",
    "user": "https://github.com/tscrim"
}
```

Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?



---

archive/issue_comments_281407.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?\n\n\nEven if you do that, you could still develop it within Sage and then split it off.",
    "created_at": "2016-11-24T08:26:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281407",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:37 tscrim]:
> Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?


Even if you do that, you could still develop it within Sage and then split it off.



---

archive/issue_comments_281408.json:
```json
{
    "body": "Replying to [comment:36 tscrim]:\n> Replying to [comment:32 jdemeyer]:\n> > Regarding [comment:27], I think the phrase \"values are zero after the addition has\n> > been performed\" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?\n\n> \n> I think you're misparsing something.\n\n\nIf I am misparsing something, it probably means that the documentation wasn't clear. My question remains: if `remove_zeros=False`, exactly which keys will appear with a zero value?",
    "created_at": "2016-11-24T08:28:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281408",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:36 tscrim]:
> Replying to [comment:32 jdemeyer]:
> > Regarding [comment:27], I think the phrase "values are zero after the addition has
> > been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?

> 
> I think you're misparsing something.


If I am misparsing something, it probably means that the documentation wasn't clear. My question remains: if `remove_zeros=False`, exactly which keys will appear with a zero value?



---

archive/issue_comments_281409.json:
```json
{
    "body": "Replying to [comment:35 tscrim]:\n> At least, I could not get `__radd__` on a Cython class\n\n\nhttp://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-methods",
    "created_at": "2016-11-24T08:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281409",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:35 tscrim]:
> At least, I could not get `__radd__` on a Cython class


http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-methods



---

archive/issue_comments_281410.json:
```json
{
    "body": "Replying to [comment:39 jdemeyer]:\n> Replying to [comment:36 tscrim]:\n> > Replying to [comment:32 jdemeyer]:\n> > > Regarding [comment:27], I think the phrase \"values are zero after the addition has\n> > > been performed\" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?\n\n> > \n> > I think you're misparsing something.\n\n> \n> If I am misparsing something, it probably means that the documentation wasn't clear. My question remains: if `remove_zeros=False`, exactly which keys will appear with a zero value?\n\n\nAll of them. The point is that if it is true, then remove them.\n\nEdit: That claim might be somewhat vague. If there is a key with a value of 0, then it stays.",
    "created_at": "2016-11-24T08:33:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281410",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:39 jdemeyer]:
> Replying to [comment:36 tscrim]:
> > Replying to [comment:32 jdemeyer]:
> > > Regarding [comment:27], I think the phrase "values are zero after the addition has
> > > been performed" is still not clear. Do you mean values such that `a * x` is non-zero and `y` is non-zero but `a * x + y` is zero? If so, what is the rationale for keeping those zeros but not the cases where `y` is zero and `a * x` is zero?

> > 
> > I think you're misparsing something.

> 
> If I am misparsing something, it probably means that the documentation wasn't clear. My question remains: if `remove_zeros=False`, exactly which keys will appear with a zero value?


All of them. The point is that if it is true, then remove them.

Edit: That claim might be somewhat vague. If there is a key with a value of 0, then it stays.



---

archive/issue_comments_281411.json:
```json
{
    "body": "Replying to [comment:40 jdemeyer]:\n> Replying to [comment:35 tscrim]:\n> > At least, I could not get `__radd__` on a Cython class\n\n> \n> http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-methods\n\n\nSo I was trying to add an element and a list. I implemented an add that looked like this:\n\n```sage\ndef __add__(self, other):\n    if isinstance(other, list):\n        return self + self.parent()(list[0])\n    return super(self, Foo).__add__(other)\n```\nWhat I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`. If it got to `__radd__`, then it would have been after this call, but I was getting an error trying to make the `super` call that wasn't getting caught.",
    "created_at": "2016-11-24T08:40:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281411",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:40 jdemeyer]:
> Replying to [comment:35 tscrim]:
> > At least, I could not get `__radd__` on a Cython class

> 
> http://cython.readthedocs.io/en/latest/src/userguide/special_methods.html#arithmetic-methods


So I was trying to add an element and a list. I implemented an add that looked like this:

```sage
def __add__(self, other):
    if isinstance(other, list):
        return self + self.parent()(list[0])
    return super(self, Foo).__add__(other)
```
What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`. If it got to `__radd__`, then it would have been after this call, but I was getting an error trying to make the `super` call that wasn't getting caught.



---

archive/issue_comments_281412.json:
```json
{
    "body": "Replying to [comment:38 jdemeyer]:\n> Replying to [comment:37 tscrim]:\n> > Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?\n\n> \n> Even if you do that, you could still develop it within Sage and then split it off.\n\n\nNicolas wasn't in favor of doing this as it is just one file.",
    "created_at": "2016-11-24T08:41:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281412",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:38 jdemeyer]:
> Replying to [comment:37 tscrim]:
> > Actually, slightly radical proposal: How about removing this altogether as a separate spkg since it is independent of Sage?

> 
> Even if you do that, you could still develop it within Sage and then split it off.


Nicolas wasn't in favor of doing this as it is just one file.



---

archive/issue_comments_281413.json:
```json
{
    "body": "Replying to [comment:42 tscrim]:\n> So I was trying to add an element and a list. I implemented an add that looked like this:\n> \n> ```sage\n> def __add__(self, other):\n>     if isinstance(other, list):\n>         return self + self.parent()(list[0])\n>     return super(self, Foo).__add__(other)\n> ```\n> What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`.\n\n\nRight, that is how `__add__` works in a `cdef class`. For this reason, I recommend against using the name `self` in this case. I prefer\n\n```\ndef __add__(left, right):\n```\nwhich shows the more symmetric nature of the arguments.\n\n> If it got to `__radd__`\n\n\nWhat do you mean? There is no `__radd__` for a `cdef class`.\n\n> I was getting an error trying to make the `super` call that wasn't getting caught.\n\n\nLogically, if `self` is not an instance of `Foo`, then `super(self, Foo)` would be an error.",
    "created_at": "2016-11-24T09:27:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281413",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:42 tscrim]:
> So I was trying to add an element and a list. I implemented an add that looked like this:
> 
> ```sage
> def __add__(self, other):
>     if isinstance(other, list):
>         return self + self.parent()(list[0])
>     return super(self, Foo).__add__(other)
> ```
> What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`.


Right, that is how `__add__` works in a `cdef class`. For this reason, I recommend against using the name `self` in this case. I prefer

```
def __add__(left, right):
```
which shows the more symmetric nature of the arguments.

> If it got to `__radd__`


What do you mean? There is no `__radd__` for a `cdef class`.

> I was getting an error trying to make the `super` call that wasn't getting caught.


Logically, if `self` is not an instance of `Foo`, then `super(self, Foo)` would be an error.



---

archive/issue_comments_281414.json:
```json
{
    "body": "Replying to [comment:43 tscrim]:\n> Nicolas wasn't in favor of doing this as it is just one file.\n\n\nMakes sense.",
    "created_at": "2016-11-24T09:37:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281414",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:43 tscrim]:
> Nicolas wasn't in favor of doing this as it is just one file.


Makes sense.



---

archive/issue_comments_281415.json:
```json
{
    "body": "Replying to [comment:44 jdemeyer]:\n> Replying to [comment:42 tscrim]:\n> > So I was trying to add an element and a list. I implemented an add that looked like this:\n> > \n> > ```sage\n> > def __add__(self, other):\n> >     if isinstance(other, list):\n> >         return self + self.parent()(list[0])\n> >     return super(self, Foo).__add__(other)\n> > ```\n> > What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`.\n\n> \n> Right, that is how `__add__` works in a `cdef class`. For this reason, I recommend against using the name `self` in this case. I prefer\n> ...\n\n\nAh, sorry, I didn't read the link you sent and misunderstood what you were trying to say. However, that is my point, we would have to check for this in `__mul__`, which takes a few extra cycles. If instead we use a function that has a fixed signature (or at least, semantically), then we don't loose those cycles.\n\nDoes comment:41 help with the `remove_zeros`?",
    "created_at": "2016-11-24T11:03:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281415",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:44 jdemeyer]:
> Replying to [comment:42 tscrim]:
> > So I was trying to add an element and a list. I implemented an add that looked like this:
> > 
> > ```sage
> > def __add__(self, other):
> >     if isinstance(other, list):
> >         return self + self.parent()(list[0])
> >     return super(self, Foo).__add__(other)
> > ```
> > What I saw happen when it was `list + Foo` was `__add__` was being called with `self` being `list`.

> 
> Right, that is how `__add__` works in a `cdef class`. For this reason, I recommend against using the name `self` in this case. I prefer
> ...


Ah, sorry, I didn't read the link you sent and misunderstood what you were trying to say. However, that is my point, we would have to check for this in `__mul__`, which takes a few extra cycles. If instead we use a function that has a fixed signature (or at least, semantically), then we don't loose those cycles.

Does comment:41 help with the `remove_zeros`?



---

archive/issue_comments_281416.json:
```json
{
    "body": "Changing keywords from \"combinatorial free module, addition\" to \"combinatorial free module, addition, days79\".",
    "created_at": "2016-11-24T11:03:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281416",
    "user": "https://github.com/tscrim"
}
```

Changing keywords from "combinatorial free module, addition" to "combinatorial free module, addition, days79".



---

archive/issue_comments_281417.json:
```json
{
    "body": "If remove_zeros=True (and the input have no zero values themselves),\nthen the output is guaranteed to have no zero values. Otherwise the\nsome zero value may be left in the output. Which ones is voluntarily\nleft undefined.\n\nThe point is that clearing zero values has a cost and there are cases\nwhere the user want to postpone the clearing until the end of a long\nseries of operations.\n\nJeroen: does the above clarify the remove_zeros option? If yes, I'll\nadd it to the documentation.",
    "created_at": "2016-11-24T13:07:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281417",
    "user": "https://github.com/nthiery"
}
```

If remove_zeros=True (and the input have no zero values themselves),
then the output is guaranteed to have no zero values. Otherwise the
some zero value may be left in the output. Which ones is voluntarily
left undefined.

The point is that clearing zero values has a cost and there are cases
where the user want to postpone the clearing until the end of a long
series of operations.

Jeroen: does the above clarify the remove_zeros option? If yes, I'll
add it to the documentation.



---

archive/issue_comments_281418.json:
```json
{
    "body": "Hi Jeroen,\n\nThanks for the feedback!\n\nThe current design (compared to a class with methods) has two advantages for such a low level use case:\n\n- following a widely used pattern for basic linear algebra operations (used even in OO languages)\n- not requiring to coerce / cast inputs when they are provided as plain dictionaries;\n  the same holds for output\n\n(and you know that I am a fan of OO :-) )",
    "created_at": "2016-11-24T13:16:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281418",
    "user": "https://github.com/nthiery"
}
```

Hi Jeroen,

Thanks for the feedback!

The current design (compared to a class with methods) has two advantages for such a low level use case:

- following a widely used pattern for basic linear algebra operations (used even in OO languages)
- not requiring to coerce / cast inputs when they are provided as plain dictionaries;
  the same holds for output

(and you know that I am a fan of OO :-) )



---

archive/issue_comments_281419.json:
```json
{
    "body": "Travis: for some reason, 9570c65ca4bb27fe8ee3dbee82b6ee42c4acb108 includes unrelated changes in `finite_monoids`; could you revert those?",
    "created_at": "2016-11-24T13:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281419",
    "user": "https://github.com/nthiery"
}
```

Travis: for some reason, 9570c65ca4bb27fe8ee3dbee82b6ee42c4acb108 includes unrelated changes in `finite_monoids`; could you revert those?



---

archive/issue_comments_281420.json:
```json
{
    "body": "Replying to [comment:46 tscrim]:\n> Ah, sorry, I didn't read the link you sent and misunderstood what you were trying to say. However, that is my point, we would have to check for this in `__mul__`, which takes a few extra cycles. If instead we use a function that has a fixed signature (or at least, semantically), then we don't loose those cycles.\n\n\nThis is an interesting (but wrong) argument. It shows that there are a lot of misconceptions about efficiency in !Python/Cython code.\n\nWhat is correct:\n\n(1) Arithmetic operators (like `+` implemented as `__add__`) are fast.\n\n(2) `isinstance()` in Cython is fast.\n\n(3) Python function calls are slow.\n\nIn turns out that (1) + (2) is actually faster than (3).",
    "created_at": "2016-11-24T13:40:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281420",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:46 tscrim]:
> Ah, sorry, I didn't read the link you sent and misunderstood what you were trying to say. However, that is my point, we would have to check for this in `__mul__`, which takes a few extra cycles. If instead we use a function that has a fixed signature (or at least, semantically), then we don't loose those cycles.


This is an interesting (but wrong) argument. It shows that there are a lot of misconceptions about efficiency in !Python/Cython code.

What is correct:

(1) Arithmetic operators (like `+` implemented as `__add__`) are fast.

(2) `isinstance()` in Cython is fast.

(3) Python function calls are slow.

In turns out that (1) + (2) is actually faster than (3).



---

archive/issue_comments_281421.json:
```json
{
    "body": "Replying to [comment:47 nthiery]:\n> If remove_zeros=True (and the input have no zero values themselves),\n> then the output is guaranteed to have no zero values. Otherwise the\n> some zero value may be left in the output. Which ones is voluntarily\n> left undefined.\n> \n> The point is that clearing zero values has a cost and there are cases\n> where the user want to postpone the clearing until the end of a long\n> series of operations.\n\n\n> Jeroen: does the above clarify the remove_zeros option? If yes, I'll\n> add it to the documentation.\n\n\nAbsolutely (much better than Travis's explanation; sorry Travis).",
    "created_at": "2016-11-24T13:46:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281421",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:47 nthiery]:
> If remove_zeros=True (and the input have no zero values themselves),
> then the output is guaranteed to have no zero values. Otherwise the
> some zero value may be left in the output. Which ones is voluntarily
> left undefined.
> 
> The point is that clearing zero values has a cost and there are cases
> where the user want to postpone the clearing until the end of a long
> series of operations.


> Jeroen: does the above clarify the remove_zeros option? If yes, I'll
> add it to the documentation.


Absolutely (much better than Travis's explanation; sorry Travis).



---

archive/issue_comments_281422.json:
```json
{
    "body": "Regarding efficiency, let met add this: the module `blas_dict` seems to be used only from Python (not Cython) code, so these efficiency considerations are probably irrelevant anyway.",
    "created_at": "2016-11-24T13:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281422",
    "user": "https://github.com/jdemeyer"
}
```

Regarding efficiency, let met add this: the module `blas_dict` seems to be used only from Python (not Cython) code, so these efficiency considerations are probably irrelevant anyway.



---

archive/issue_comments_281423.json:
```json
{
    "body": "Replying to [comment:52 jdemeyer]:\n> Regarding efficiency, let met add this: the module `blas_dict` seems to be used only from Python (not Cython) code, so these efficiency considerations are probably irrelevant anyway.\n\n\nNicolas and I are planning to move `CombinatorialFreeModuleElement` to a Cython class, so I would think it would be C function calls in that case?",
    "created_at": "2016-11-24T13:55:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281423",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:52 jdemeyer]:
> Regarding efficiency, let met add this: the module `blas_dict` seems to be used only from Python (not Cython) code, so these efficiency considerations are probably irrelevant anyway.


Nicolas and I are planning to move `CombinatorialFreeModuleElement` to a Cython class, so I would think it would be C function calls in that case?



---

archive/issue_comments_281424.json:
```json
{
    "body": "First of all, I am not going to insist on implementing this as a subclass. You know better than me how this code is actually used.\n\nStill, some comments:\n\nReplying to [comment:48 nthiery]:\n> The current design (compared to a class with methods) has two advantages for such a low level use case:\n> \n> - following a widely used pattern for basic linear algebra operations (used even in OO languages)\n\n\nI believe the standard implementation languages of BLAS are Fortran and C and those are not OO languages.\n\n> - not requiring to coerce / cast inputs when they are provided as plain dictionaries;\n\n\nSure, this is indeed a potential disadvantage (but also the only one). Wouldn't it work to just keep the attributes `__monomials` or `_monomial_coefficients` an instance of that type?\n\n>   the same holds for output\n\nNot really for output since it would be a `dict` subclass. So anything expecting a `dict` would still work.",
    "created_at": "2016-11-24T13:58:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281424",
    "user": "https://github.com/jdemeyer"
}
```

First of all, I am not going to insist on implementing this as a subclass. You know better than me how this code is actually used.

Still, some comments:

Replying to [comment:48 nthiery]:
> The current design (compared to a class with methods) has two advantages for such a low level use case:
> 
> - following a widely used pattern for basic linear algebra operations (used even in OO languages)


I believe the standard implementation languages of BLAS are Fortran and C and those are not OO languages.

> - not requiring to coerce / cast inputs when they are provided as plain dictionaries;


Sure, this is indeed a potential disadvantage (but also the only one). Wouldn't it work to just keep the attributes `__monomials` or `_monomial_coefficients` an instance of that type?

>   the same holds for output

Not really for output since it would be a `dict` subclass. So anything expecting a `dict` would still work.



---

archive/issue_comments_281425.json:
```json
{
    "body": "Replying to [comment:53 tscrim]:\n> Nicolas and I are planning to move `CombinatorialFreeModuleElement` to a Cython class, so I would think it would be C function calls in that case?\n\n\nYes, provided that you `cimport` (not `import`) the functions. This requires you to add a `.pxd` file. I guess you should do that on this ticket.",
    "created_at": "2016-11-24T14:00:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281425",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:53 tscrim]:
> Nicolas and I are planning to move `CombinatorialFreeModuleElement` to a Cython class, so I would think it would be C function calls in that case?


Yes, provided that you `cimport` (not `import`) the functions. This requires you to add a `.pxd` file. I guess you should do that on this ticket.



---

archive/issue_comments_281426.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-24T14:08:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281426",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281427.json:
```json
{
    "body": "I forgot to add the `.pxd` file; thanks for the reminder. I also added Nicolas' explanation of `remove_zeros` to the documentation.",
    "created_at": "2016-11-24T14:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281427",
    "user": "https://github.com/tscrim"
}
```

I forgot to add the `.pxd` file; thanks for the reminder. I also added Nicolas' explanation of `remove_zeros` to the documentation.



---

archive/issue_comments_281428.json:
```json
{
    "body": "If you care about efficiency, then `iaxpy` should have the prototype\n\n```\ncpdef int iaxpy(....) except -1\n```\nReturning an `int` is faster than returning the Python `None`.",
    "created_at": "2016-11-24T14:56:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281428",
    "user": "https://github.com/jdemeyer"
}
```

If you care about efficiency, then `iaxpy` should have the prototype

```
cpdef int iaxpy(....) except -1
```
Returning an `int` is faster than returning the Python `None`.



---

archive/issue_comments_281429.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-24T15:36:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281429",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281430.json:
```json
{
    "body": "Replying to [comment:58 jdemeyer]:\n> If you care about efficiency, then `iaxpy` should have the prototype\n> \n> ```\n> cpdef int iaxpy(....) except -1\n> ```\n> Returning an `int` is faster than returning the Python `None`.\n\n\nDone. This resulted in a 2 microsecond speedup for the `n=1000` benchmark for me.",
    "created_at": "2016-11-24T15:36:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281430",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:58 jdemeyer]:
> If you care about efficiency, then `iaxpy` should have the prototype
> 
> ```
> cpdef int iaxpy(....) except -1
> ```
> Returning an `int` is faster than returning the Python `None`.


Done. This resulted in a 2 microsecond speedup for the `n=1000` benchmark for me.



---

archive/issue_comments_281431.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-12-01T00:29:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281431",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281432.json:
```json
{
    "body": "So there are two doctest failures:\n\nThe failure in `categories/finite_dimensional_algebras_with_basis.py` is reordering, and I've fixed it.\n\nThe one in `misc/dev_tools.py` is essentially trivial, but it requires some thought as to what the correct change should be. I'm thinking we should find something else that has a unique object name (perhaps `'QQ'`?). However, I want your opinions.\n\nOnce that is fixed, perhaps we can get this into Sage?",
    "created_at": "2016-12-01T00:30:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281432",
    "user": "https://github.com/tscrim"
}
```

So there are two doctest failures:

The failure in `categories/finite_dimensional_algebras_with_basis.py` is reordering, and I've fixed it.

The one in `misc/dev_tools.py` is essentially trivial, but it requires some thought as to what the correct change should be. I'm thinking we should find something else that has a unique object name (perhaps `'QQ'`?). However, I want your opinions.

Once that is fixed, perhaps we can get this into Sage?



---

archive/issue_comments_281433.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2016-12-01T00:30:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281433",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_281434.json:
```json
{
    "body": "Hi Travis,\n\nThanks for checking this out. +1 on the first change. For the second, I agree that it's good enough to replace sum by something else with a unique name. The only thing is that this test is about exercising `import_statement` for objects that are defined as aliases. So we need to find some object like this (haven't found one yet).\n\nThen, yes, let's get this in Sage!",
    "created_at": "2016-12-01T08:57:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281434",
    "user": "https://github.com/nthiery"
}
```

Hi Travis,

Thanks for checking this out. +1 on the first change. For the second, I agree that it's good enough to replace sum by something else with a unique name. The only thing is that this test is about exercising `import_statement` for objects that are defined as aliases. So we need to find some object like this (haven't found one yet).

Then, yes, let's get this in Sage!



---

archive/issue_comments_281435.json:
```json
{
    "body": "Replying to [comment:63 nthiery]:\n> For the second, I agree that it's good enough to replace sum by something else with a unique name. The only thing is that this test is about exercising `import_statement` for objects that are defined as aliases. So we need to find some object like this (haven't found one yet).\n\n\nI haven't been able to find one either. We can do something slightly artificial like importing something in the doctest as an alias and checking against that. Should we go that route?",
    "created_at": "2016-12-01T19:40:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281435",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:63 nthiery]:
> For the second, I agree that it's good enough to replace sum by something else with a unique name. The only thing is that this test is about exercising `import_statement` for objects that are defined as aliases. So we need to find some object like this (haven't found one yet).


I haven't been able to find one either. We can do something slightly artificial like importing something in the doctest as an alias and checking against that. Should we go that route?



---

archive/issue_comments_281436.json:
```json
{
    "body": "Or maybe just remove the test: the feature already has test which seem equivalent, and if we can't find another example, it's not a critical feature anyway.",
    "created_at": "2016-12-01T22:25:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281436",
    "user": "https://github.com/nthiery"
}
```

Or maybe just remove the test: the feature already has test which seem equivalent, and if we can't find another example, it's not a critical feature anyway.



---

archive/issue_comments_281437.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-12-02T15:20:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281437",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281438.json:
```json
{
    "body": "Okay, I've removed it. So if there are no other objections, then I believe we can set this to a positive review. Next up will be to cythonize `CFMElement`...",
    "created_at": "2016-12-02T15:22:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281438",
    "user": "https://github.com/tscrim"
}
```

Okay, I've removed it. So if there are no other objections, then I believe we can set this to a positive review. Next up will be to cythonize `CFMElement`...



---

archive/issue_comments_281439.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-12-02T15:22:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281439",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_281440.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-12-03T11:22:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281440",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_281441.json:
```json
{
    "body": "Hi,\n\nI checked the patchbot reports. I fixed the non-ascii issue. The startup-module report is normal. There are two python3 issue: one in a speed-critical section which we had discussed and decided to be a necessary evil. The other is a false positive (existing cmp in a line of code that was respaced).\n\nHence positive review!",
    "created_at": "2016-12-03T11:28:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281441",
    "user": "https://github.com/nthiery"
}
```

Hi,

I checked the patchbot reports. I fixed the non-ascii issue. The startup-module report is normal. There are two python3 issue: one in a speed-critical section which we had discussed and decided to be a necessary evil. The other is a false positive (existing cmp in a line of code that was respaced).

Hence positive review!



---

archive/issue_comments_281442.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-12-03T11:29:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281442",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_281443.json:
```json
{
    "body": "Replying to [comment:69 nthiery]:\n> There are two python3 issue: one in a speed-critical section which we had discussed and decided to be a necessary evil.\n\n\nThat's a non-issue. Cython != Python and Cython does support `.iteritems()` for dicts.",
    "created_at": "2016-12-03T12:24:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281443",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:69 nthiery]:
> There are two python3 issue: one in a speed-critical section which we had discussed and decided to be a necessary evil.


That's a non-issue. Cython != Python and Cython does support `.iteritems()` for dicts.



---

archive/issue_events_055656.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-12-05T00:44:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/20443#event-55656"
}
```



---

archive/issue_comments_281444.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-12-05T00:44:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20443",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20443#issuecomment-281444",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
