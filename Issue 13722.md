# Issue 13722: Undo #13014

Issue created by migration from Trac.

Original creator: jdemeyer

Original creation time: 2013-01-08 08:15:13

Assignee: burcin

CC:  dsm was ddrake

The patch at #13014 caused an unacceptable slow-down for

```
sage: time p = polar_plot(lambda t: (100/(100+(t-pi/2)^8))*(2-sin(7*t)-cos(30*t)/2), -pi/4, 3*pi/2, color="red",plot_points=1000)
```



---

Attachment


---

Comment by jdemeyer created at 2013-01-08 08:29:05

Changing status from new to needs_review.


---

Comment by ppurka created at 2013-01-08 11:06:44

Do you have any idea why gcd is even called in this case? There is no instance of this function in the plot commands

```
...eta0/devel/sage/sage/plot» grep -w gcd -r *
...devel/sage/sage/plot [1] » 
```

By default, it takes this time on my machine:

```
sage: sage: time p = polar_plot(lambda t: (100/(100+(t-pi/2)^8))*(2-sin(7*t)-cos(30*t)/2), -pi/4, 3*pi/2, color="red",plot_points=1000)
Time: CPU 39.02 s, Wall: 39.04 s
```

I tried changing all the fractions to floats. And then there is a noticeable improvement.

```
sage: time p = polar_plot(lambda t: (100./(100.+(t-pi/2.)^8))*(2.-sin(7.*t)-cos(30.*t)/2.), -pi/4., 3*pi/2., color="red", plot_points=1000)
Time: CPU 6.40 s, Wall: 6.40 s
```

I think the correct solution is to not eliminate QQ from gcd, but to determine which command in plot is introducing this slowdown. Obviously, some computations are being done in rational space, instead of converting them to floats. I don't think we need that much precision while doing plots. Moreover, the functions are always converted to `fast_float` functions before generating the plot points (or at least it is tried to do the conversion).


---

Comment by burcin created at 2013-01-08 12:20:29

Replying to [comment:2 ppurka]:
> Do you have any idea why gcd is even called in this case? There is no instance of this function in the plot commands

The expression is instantiated for each value of t, thanks to the lambda function. For each of these instantiations, Pynac tries to normalize the expression, in the process calculating many gcd's and lcm's of coefficients. Adding a print statement in `py_{gcd,lcm}()` in `sage/symbolic/pynac.pyx`, I get


```
sage: var('t')
t
sage: ex = (100/(100+(t-pi/2)^8))*(2-sin(7*t)-cos(30*t)/2)
in py_gcd, n: -1, k: 0
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_lcm, n: 2, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_gcd, n: 1, k: 1
type(n): <type 'int'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 2
type(n): <type 'int'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 0, k: 1
type(n): <type 'int'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 2
type(n): <type 'int'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 1, k: 0
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_gcd, n: -2, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 0, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 1, k: 0
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_gcd, n: -2, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 0, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 1, k: 0
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_lcm, n: 256, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_gcd, n: 100, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 256
type(n): <type 'int'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 1, k: 0
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_gcd, n: 25600, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: -1, k: 0
type(n): <type 'int'>, type(k): <type 'int'>
in py_lcm, n: 1, k: 1
type(n): <type 'int'>, type(k): <type 'int'>
in py_gcd, n: -1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 2, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 2, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 2
type(n): <type 'int'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: 2, k: 0
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'int'>
in py_gcd, n: 1, k: 2
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_gcd, n: -4, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
in py_lcm, n: 1, k: 1
type(n): <type 'sage.rings.integer.Integer'>, type(k): <type 'sage.rings.integer.Integer'>
```


Not all of these are passed on to `sage.rings.arith.{gcd,lcm}`, `py_gcd()` contains a couple of special cases before calling those. This function is very speed critical indeed.

I am tempted to switch to a positive review especially since no doctests need to be changed. Any objections?


---

Comment by ppurka created at 2013-01-08 13:13:15

Thanks a lot for investigating this! So, what I gather from your explanation is that
1. the gcd has nothing to do with the plot itself.
2. the slowdown is more generic and potentially affects many different areas of Sage
3. the slowdown is rectified by this patch, which incidentally doesn't affect the functionality introduced by #13014.
I have no objection to a positive review in this case.


---

Comment by jdemeyer created at 2013-01-09 10:30:59

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2013-01-12 08:53:21

Resolution: fixed
