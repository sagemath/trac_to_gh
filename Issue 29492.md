# Issue 29492: improve solve_right for some inexact rings

archive/issues_029492.json:
```json
{
    "body": "CC:  alexghitza nbruin\n\nSince #12406, the `check` keyword to `solve_right` is ignored over all inexact rings. As discussed on [sage-devel](https://groups.google.com/forum/#!topic/sage-devel/1Ew9s16IhsE), this is a bit too drastic, as the solution can be checked for correctness in some cases.\n\nOver `SR`, we can check if all entries are exact and then check whether the solution is correct.\n\n```\nsage: matrix(SR, [[0]]).solve_right(vector(SR, [1]))  # should raise an error\n(0)\n```\n\n\nOver ball and intervall fields, we can check the error bounds to determine whether the result is valid.\n\n\n```\nsage: matrix(RIF, [[2/3, 1], [2/5, 3/5]]).solve_right(vector(RIF, [1, 1]))  # this solution is acceptable\n([-infinity .. +infinity], [-infinity .. +infinity])\nsage: matrix(RIF, [[0]]).solve_right(vector(RIF, [1]))  # this is not\n(0)\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/29729\n\n",
    "created_at": "2020-05-23T18:24:44Z",
    "labels": [
        "linear algebra",
        "major",
        "enhancement"
    ],
    "title": "improve solve_right for some inexact rings",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29492",
    "user": "@mwageringel"
}
```
CC:  alexghitza nbruin

Since #12406, the `check` keyword to `solve_right` is ignored over all inexact rings. As discussed on [sage-devel](https://groups.google.com/forum/#!topic/sage-devel/1Ew9s16IhsE), this is a bit too drastic, as the solution can be checked for correctness in some cases.

Over `SR`, we can check if all entries are exact and then check whether the solution is correct.

```
sage: matrix(SR, [[0]]).solve_right(vector(SR, [1]))  # should raise an error
(0)
```


Over ball and intervall fields, we can check the error bounds to determine whether the result is valid.


```
sage: matrix(RIF, [[2/3, 1], [2/5, 3/5]]).solve_right(vector(RIF, [1, 1]))  # this solution is acceptable
([-infinity .. +infinity], [-infinity .. +infinity])
sage: matrix(RIF, [[0]]).solve_right(vector(RIF, [1]))  # this is not
(0)
```


Issue created by migration from https://trac.sagemath.org/ticket/29729





---

archive/issue_comments_418765.json:
```json
{
    "body": "Here's a proof-of-concept (not well tested) for SR.\n----\nNew commits:",
    "created_at": "2020-05-27T03:38:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418765",
    "user": "mjo"
}
```

Here's a proof-of-concept (not well tested) for SR.
----
New commits:



---

archive/issue_comments_418766.json:
```json
{
    "body": "The SR proof-of-concept passes a ptestlong, at least.\n\nAs for the ball/interval fields: half of the problem with RBF is that we have a dedicated implementation of `_solve_right_nonsingular_square` for complex ball matrices, but not for RBF ones. Thus we miss out on the work that the arb library has already done for these systems. Compare:\n\n\n```\nsage: A = matrix(RBF, [[2/3, 1], [2/5, 3/5]])\nsage: b = vector(RBF, [1, 1])\nsage: A.solve_right(b)\n(nan, nan)\n\nsage: A = A.change_ring(CBF)\nsage: b = b.change_ring(CBF)\nsage: A.solve_right(b)\n...\nValueError: unable to invert this matrix\n```\n\n\n(Note: we should catch that exception and turn it into a `NotFullRankError`).\n\nFor the generic interval solve/check, as a first approximation, maybe we could multiply `A*x` and check that each component thereof intersects the corresponding component (interval) of `b`. That's as opposed to the default \"check\" implementation using literal equality that would fail. This needs an expert opinion as my understanding of interval systems is only wikipedia-deep.",
    "created_at": "2020-05-28T01:36:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418766",
    "user": "mjo"
}
```

The SR proof-of-concept passes a ptestlong, at least.

As for the ball/interval fields: half of the problem with RBF is that we have a dedicated implementation of `_solve_right_nonsingular_square` for complex ball matrices, but not for RBF ones. Thus we miss out on the work that the arb library has already done for these systems. Compare:


```
sage: A = matrix(RBF, [[2/3, 1], [2/5, 3/5]])
sage: b = vector(RBF, [1, 1])
sage: A.solve_right(b)
(nan, nan)

sage: A = A.change_ring(CBF)
sage: b = b.change_ring(CBF)
sage: A.solve_right(b)
...
ValueError: unable to invert this matrix
```


(Note: we should catch that exception and turn it into a `NotFullRankError`).

For the generic interval solve/check, as a first approximation, maybe we could multiply `A*x` and check that each component thereof intersects the corresponding component (interval) of `b`. That's as opposed to the default "check" implementation using literal equality that would fail. This needs an expert opinion as my understanding of interval systems is only wikipedia-deep.



---

archive/issue_comments_418767.json:
```json
{
    "body": "It might also be a good idea to factor out the solution check into a separate method, that way we don't have to override all of `_solve_right_general` for interval matrices just to replace the strict-equality check.",
    "created_at": "2020-05-28T01:43:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418767",
    "user": "mjo"
}
```

It might also be a good idea to factor out the solution check into a separate method, that way we don't have to override all of `_solve_right_general` for interval matrices just to replace the strict-equality check.



---

archive/issue_comments_418768.json:
```json
{
    "body": "Replying to [comment:2 mjo]:\n> (Note: we should catch that exception and turn it into a `NotFullRankError`).\n\nThe `NotFullRankError` is currently only used internally for control flow, so we should only raise it if we want `_solve_right_general` to be tried when `_solve_right_nonsingular_square` fails, in the case of `CBF`.\n\n> For the generic interval solve/check, as a first approximation, maybe we could multiply `A*x` and check that each component thereof intersects the corresponding component (interval) of `b`. That's as opposed to the default \"check\" implementation using literal equality that would fail. This needs an expert opinion as my understanding of interval systems is only wikipedia-deep.\n\nThe literal equality check seemingly works with ball/interval arithmetics. Though, this is probably just a coincidence. If vector equality is implemented by checking whether not any entries are different (as opposed to all entries being equal), for ball fields this means it is checked that no entries are disjoint balls, hence they must intersect.\n\n```\nsage: A = matrix(RBF, [[2/3, 1], [2/5, 3/5]])\nsage: b = vector(RBF, [1, 1])\nsage: x = A.solve_right(b)\nsage: A * x == b\nTrue\n```\n\nHowever, it would be more correct to check that every entry of `b`, as a ball/interval, is fully contained in the corresponding entry of `A * x`:\n\n```\nsage: all(u in v for u, v in zip(b, A*x))\nTrue\n```\n\nI am not very familiar with interval arithmetics either, though.",
    "created_at": "2020-05-28T07:48:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418768",
    "user": "@mwageringel"
}
```

Replying to [comment:2 mjo]:
> (Note: we should catch that exception and turn it into a `NotFullRankError`).

The `NotFullRankError` is currently only used internally for control flow, so we should only raise it if we want `_solve_right_general` to be tried when `_solve_right_nonsingular_square` fails, in the case of `CBF`.

> For the generic interval solve/check, as a first approximation, maybe we could multiply `A*x` and check that each component thereof intersects the corresponding component (interval) of `b`. That's as opposed to the default "check" implementation using literal equality that would fail. This needs an expert opinion as my understanding of interval systems is only wikipedia-deep.

The literal equality check seemingly works with ball/interval arithmetics. Though, this is probably just a coincidence. If vector equality is implemented by checking whether not any entries are different (as opposed to all entries being equal), for ball fields this means it is checked that no entries are disjoint balls, hence they must intersect.

```
sage: A = matrix(RBF, [[2/3, 1], [2/5, 3/5]])
sage: b = vector(RBF, [1, 1])
sage: x = A.solve_right(b)
sage: A * x == b
True
```

However, it would be more correct to check that every entry of `b`, as a ball/interval, is fully contained in the corresponding entry of `A * x`:

```
sage: all(u in v for u, v in zip(b, A*x))
True
```

I am not very familiar with interval arithmetics either, though.



---

archive/issue_comments_418769.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-05-30T01:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418769",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_418770.json:
```json
{
    "body": "That last commit should fix the square/nonsingular issue but probably needs some polish.",
    "created_at": "2020-05-30T01:48:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418770",
    "user": "mjo"
}
```

That last commit should fix the square/nonsingular issue but probably needs some polish.



---

archive/issue_comments_418771.json:
```json
{
    "body": "Replying to [comment:4 gh-mwageringel]:\n> \n> The `NotFullRankError` is currently only used internally for control flow, so we should only raise it if we want `_solve_right_general` to be tried when `_solve_right_nonsingular_square` fails, in the case of `CBF`.\n\nIf we can make `check=True` work, I think that's what we want. I'm imagining a square system with exact real entries (like powers of two) and then some extra redundant rows tacked onto the end. If the generic solver can eliminate those junk rows and if `check=True` can make sure we don't wind up with a wrong answer... well first we need to make `check=True` work, and then I can just try it.\n\n\n> The literal equality check seemingly works with ball/interval arithmetics. Though, this is probably just a coincidence...\n> However, it would be more correct to check that every entry of `b`, as a ball/interval, is fully contained in the corresponding entry of `A * x`:\n\nFrom what I gather, a solution to an interval system **Ax** = **b** should be an interval vector **x** such that for all *x* in **x**, there exists some *A* in **A** and *b* in **b** with *Ax = b*. So I don't think either suggestion is quite right; mine because **Ax** can wind up being larger than necessary, and thus too lenient if we intersect it with **b**. Yours I would imagine is too strict: if everything is nonnegative, we should be able to pair up the left endpoints of **x** with the left endpoints of **A** and **b** and not insist that the right endpoints of **A** and **b** work (for the left endpoints of **x**) as well.",
    "created_at": "2020-05-30T02:08:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418771",
    "user": "mjo"
}
```

Replying to [comment:4 gh-mwageringel]:
> 
> The `NotFullRankError` is currently only used internally for control flow, so we should only raise it if we want `_solve_right_general` to be tried when `_solve_right_nonsingular_square` fails, in the case of `CBF`.

If we can make `check=True` work, I think that's what we want. I'm imagining a square system with exact real entries (like powers of two) and then some extra redundant rows tacked onto the end. If the generic solver can eliminate those junk rows and if `check=True` can make sure we don't wind up with a wrong answer... well first we need to make `check=True` work, and then I can just try it.


> The literal equality check seemingly works with ball/interval arithmetics. Though, this is probably just a coincidence...
> However, it would be more correct to check that every entry of `b`, as a ball/interval, is fully contained in the corresponding entry of `A * x`:

From what I gather, a solution to an interval system **Ax** = **b** should be an interval vector **x** such that for all *x* in **x**, there exists some *A* in **A** and *b* in **b** with *Ax = b*. So I don't think either suggestion is quite right; mine because **Ax** can wind up being larger than necessary, and thus too lenient if we intersect it with **b**. Yours I would imagine is too strict: if everything is nonnegative, we should be able to pair up the left endpoints of **x** with the left endpoints of **A** and **b** and not insist that the right endpoints of **A** and **b** work (for the left endpoints of **x**) as well.



---

archive/issue_comments_418772.json:
```json
{
    "body": "Replying to [comment:7 mjo]:\n> From what I gather, a solution to an interval system **Ax** = **b** should be an interval vector **x** such that for all *x* in **x**, there exists some *A* in **A** and *b* in **b** with *Ax = b*.\n\nThis does not seem quite right to me, as then **x** could always be shrinkened to just a single point, thus reducing the error to 0.\n\nIn my naive understanding, as we do not know the exact values of *A* and *b*, the solution **x** of the system **Ax** = **b** should satisfy:\n\n    \u2200 *A*\u2208**A** \u2200 *b*\u2208**b** \u2203 *x*\u2208**x** such that *Ax* = *b*.\n\nGiven **x** and **A**, let me denote the product by **y** = **Ax**. Then **y** should contain the set\n\n    { *y*\u2208\u211d<sup>n</sup> | \u2203 *A*\u2208**A** \u2203 *x*\u2208**x** : *Ax* = *y* }.\n\n(In particular, this means that \u2200 *A*\u2208**A** \u2200 *x*\u2208**x** \u2203 *y*\u2208**y** such that *Ax* = *y*.)\n\nSince **A** is non-empty, we can fix an arbitrary *A*\u2208**A**. Now, given any *b*\u2208**b**, we find an *x*\u2208**x** satisfying *Ax*=*b*, and so *b*\u2208**y**.\n\nTherefore, under the above assumptions, it would be a necessary condition that **b** is contained in **y**.",
    "created_at": "2020-05-30T19:55:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418772",
    "user": "@mwageringel"
}
```

Replying to [comment:7 mjo]:
> From what I gather, a solution to an interval system **Ax** = **b** should be an interval vector **x** such that for all *x* in **x**, there exists some *A* in **A** and *b* in **b** with *Ax = b*.

This does not seem quite right to me, as then **x** could always be shrinkened to just a single point, thus reducing the error to 0.

In my naive understanding, as we do not know the exact values of *A* and *b*, the solution **x** of the system **Ax** = **b** should satisfy:

    ∀ *A*∈**A** ∀ *b*∈**b** ∃ *x*∈**x** such that *Ax* = *b*.

Given **x** and **A**, let me denote the product by **y** = **Ax**. Then **y** should contain the set

    { *y*∈ℝ<sup>n</sup> | ∃ *A*∈**A** ∃ *x*∈**x** : *Ax* = *y* }.

(In particular, this means that ∀ *A*∈**A** ∀ *x*∈**x** ∃ *y*∈**y** such that *Ax* = *y*.)

Since **A** is non-empty, we can fix an arbitrary *A*∈**A**. Now, given any *b*∈**b**, we find an *x*∈**x** satisfying *Ax*=*b*, and so *b*∈**y**.

Therefore, under the above assumptions, it would be a necessary condition that **b** is contained in **y**.



---

archive/issue_comments_418773.json:
```json
{
    "body": "Replying to [comment:8 gh-mwageringel]:\n> In my naive understanding, as we do not know the exact values of *A* and *b*, the solution **x** of the system **Ax** = **b** should satisfy:\n> \n>     \u2200 *A*\u2208**A** \u2200 *b*\u2208**b** \u2203 *x*\u2208**x** such that *Ax* = *b*.\n\nCome to think of it, this will never hold if **A** has more rows than columns (and not everything is exact), as then *A* and *b* can easily be chosen such that no solution exists.",
    "created_at": "2020-05-30T20:53:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418773",
    "user": "@mwageringel"
}
```

Replying to [comment:8 gh-mwageringel]:
> In my naive understanding, as we do not know the exact values of *A* and *b*, the solution **x** of the system **Ax** = **b** should satisfy:
> 
>     ∀ *A*∈**A** ∀ *b*∈**b** ∃ *x*∈**x** such that *Ax* = *b*.

Come to think of it, this will never hold if **A** has more rows than columns (and not everything is exact), as then *A* and *b* can easily be chosen such that no solution exists.



---

archive/issue_comments_418774.json:
```json
{
    "body": "It looks like all of these definitions of a solution that we've been making up are valid in different contexts (see e.g. *Interval linear systems as a necessary step in fuzzy linear systems* by Lodwick and Dubois). However, since RBF is documented to be implemented with Arb and since square systems will be solved by Arb, we should probably use the same interpretation of \"solution\" that Arb uses. So far I've been unable to figure out what that is. I may have to ask on the mailing list.",
    "created_at": "2020-06-02T01:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418774",
    "user": "mjo"
}
```

It looks like all of these definitions of a solution that we've been making up are valid in different contexts (see e.g. *Interval linear systems as a necessary step in fuzzy linear systems* by Lodwick and Dubois). However, since RBF is documented to be implemented with Arb and since square systems will be solved by Arb, we should probably use the same interpretation of "solution" that Arb uses. So far I've been unable to figure out what that is. I may have to ask on the mailing list.



---

archive/issue_comments_418775.json:
```json
{
    "body": "Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-04-07T19:29:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29492",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29492#issuecomment-418775",
    "user": "mkoeppe"
}
```

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review.
