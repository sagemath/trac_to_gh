# Issue 27098: Segmentation fault in Gen.isprime on Cygwin

Issue created by migration from https://trac.sagemath.org/ticket/27335

Original creator: embray

Original creation time: 2019-02-21 11:37:30

CC:  jdemeyer

This was originally reported in #27267, but determined to be a distinct issue from another crash reported on that ticket.


```
sage: (2^127 - 1).is_prime()

*** SIG 11 *** inside sig_on
do_raise_exception(sig=11)
PyErr_Occurred() = 0x0
Raising Python exception 0 ms after signal...
---------------------------------------------------------------------------
SignalError                               Traceback (most recent call last)
<ipython-input-1-714806c14b73> in <module>()
----> 1 (Integer(2)**Integer(127) - Integer(1)).is_prime()

/home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/sage/rings/integer.pyx in sage.rings.integer.Integer.is_prime (build/cythonized/sage/rings/integer.c:32034)()
   5141             proof = get_flag(proof, "arithmetic")
   5142         if proof:
-> 5143             return self.__pari__().isprime()
   5144         else:
   5145             return self.__pari__().ispseudoprime()

cypari2/gen.pyx in cypari2.gen.Gen.isprime()

SignalError: Segmentation fault
```


The C stack trace in the case of these crashes looks like:


```
Program received signal SIGSEGV, Segmentation fault.
0x00000003b598daf4 in red_montgomery ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
(gdb) where
#0  0x00000003b598daf4 in red_montgomery ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#1  0x00000003b5bd482f in gen_pow_i ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#2  0x00000003b5b58d1e in Fp_pow ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#3  0x00000003b5e77644 in pl831 ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#4  0x00000003b5e7a8f4 in BPSW_isprime.part.15 ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#5  0x00000003b5e7acb2 in isprime ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#6  0x00000003b5d0d4cf in map_proto_lG ()
   from /home/embray/src/sagemath/sage/local/lib/libpari-gmp.dll
#7  0x00000003b269a455 in __pyx_pf_7cypari2_3gen_3Gen_118isprime.isra.124 ()
   from /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/cypari2/gen.dll
#8  0x00000003b277765f in __pyx_pw_7cypari2_3gen_3Gen_119isprime ()
   from /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/cypari2/gen.dll
#9  0x000000039881394c in __Pyx_CyFunction_CallAsMethod ()
   from /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/sage/misc/persist.dll
#10 0x0000000393e55486 in __Pyx__PyObject_CallOneArg ()
   from /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/sage/rings/integer.dll
#11 0x0000000393e645c5 in __Pyx_PyObject_CallOneArg ()
   from /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/sage/rings/integer.dll
#12 0x0000000393e6bccc in __pyx_pw_4sage_5rings_7integer_7Integer_203is_prime
    ()
   from /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/sage/rings/integer.dll
#13 0x00000003c1548bfa in PyEval_EvalFrameEx ()
   from /home/embray/src/sagemath/sage/local/bin/libpython2.7.dll
```


(I need to apply some debugging fixups in order to see what the function arguments look like).

This can be reproduced with any one of:


```
sage: (2^127 - 1).is_prime()
```



```
sage: pari(2^127 - 1).isprime()
```



```
sage: pari("2^127 - 1").isprime()
```


But _not_ as a pure gp expression like:


```
sage: pari("isprime(2^127 - 1)")
1
```


In other words, it occurs explicitly when one goes through `Gen.isprime`.  Incidentally, after calling `pari("isprime(2^127 - 1)")`, all the other examples begin to work.  Presumably this is because the result is cached somewhere in PARI resulting in going down a different code path that does not crash.


---

Comment by jdemeyer created at 2019-02-21 11:40:56

Please also check `pari.isprime(2^127 - 1)`.


---

Comment by jdemeyer created at 2019-02-21 12:07:31

What happens in pure Python (the Python in Sage):

```
>>> from cypari2 import Pari; pari = Pari(); pari("2^127 - 1").isprime()
True
```



---

Comment by embray created at 2019-02-21 13:12:18

I meant to add: It's the same problem.  The bug is somewhere in pari or cypari2, not Sage itself.  So you meant want to open an issue over there too.


---

Comment by embray created at 2019-02-21 13:13:34

When I do that I also see a `RuntimeWarning` that for some reason is being squelched in the normal sage repl?


```
>>> from cypari2 import Pari; pari = Pari(); pari("2^127 - 1").isprime()

*** SIG 11 *** inside sig_on
do_raise_exception(sig=11)
PyErr_Occurred() = 0x0
Raising Python exception 0 ms after signal...
sys:1: RuntimeWarning: cypari2 leaked 5704 bytes on the PARI stack
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "cypari2/gen.pyx", line 2078, in cypari2.gen.Gen.isprime
cysignals.signals.SignalError: Segmentation fault
```



---

Comment by jdemeyer created at 2019-02-21 13:28:14

I wouldn't worry too much about that `RuntimeWarning` (which clearly happens after the segmentation fault, so it can't be the cause).


---

Comment by jdemeyer created at 2019-02-21 13:33:25

Don't forget to check `pari.isprime(2^127 - 1)`.


---

Comment by embray created at 2019-02-21 13:42:59

I think it should be fairly obvious at this point that it's the same (though `s/^/**/` in plain Python).


---

Comment by jdemeyer created at 2019-02-21 13:46:35

Replying to [comment:7 embray]:
> I think it should be fairly obvious at this point that it's the same (though `s/^/**/` in plain Python).

It's not obvious at all to me... but it's good to know that this also crashes.


---

Comment by jdemeyer created at 2019-02-21 13:58:35

I really have no clue what could be the problem here. There shouldn't be anything special about wrapping the `isprime()` function.


---

Comment by embray created at 2019-02-21 14:02:16

I think either way it's creating a `GEN` from the integer (whether it's a Sage Integer or a Python int) and passing it to `gisprime`.

I suspect the bug is somewhere in Pari, but is only invoked as a result of whatever weird manipulations the wrapper is doing to Pari's stack.  Some assumption that is made somewhere that does not hold up in that context.  I'm not sure what though.  I'll be able to investigate more once I'm done testing against #27267


---

Comment by embray created at 2019-02-21 14:03:33

Since the fault is in libpari-gmp.dll, it's possible GMP/MPIR is also suspect.  I'll see if I can invoke the same bug without GMP support.


---

Comment by jdemeyer created at 2019-02-21 14:10:53

Maybe it's accessing memory beyond the PARI stack. You mention that after things work correctly after `pari("isprime(2^127 - 1)")`. But maybe things work correctly after any PARI computation?

So please try:

```
a = pari(3)
b = pari(2^127 - 1).isprime()
```



---

Comment by embray created at 2019-02-21 14:19:34

Good call--that seems to work.  I had guessed (and it was just a guess) that it was caching some results related to the isprime computation, but that probably isn't it.


---

Comment by jdemeyer created at 2019-02-21 14:22:37

Is there any chance to get from GDB the precise point where the segfault is raised?


---

Comment by embray created at 2019-02-21 14:28:44

The `red_montgomery` function does do some suspicious looking manipulations with `avma` that I'll be able to debug more carefully soon.  To summarize some relevant bits:


```
red_montgomery(GEN T, GEN N, ulong inv)
{
  pari_sp av;
  ...
  av = avma; scratch = new_chunk(k<<1); /* >= k + 2: result fits */
  ...
  /// The next line that uses av looks like: ///
  Td = (GEN)av - 1; /* *Td = high word of final result */
  /// segfault here, maybe??? ///
  while (*Td == 0 && Te < Td) Td--; /* strip leading 0s */
  ...
}
```



---

Comment by embray created at 2019-02-21 14:30:00

Replying to [comment:17 jdemeyer]:
> Is there any chance to get from GDB the precise point where the segfault is raised?

Yes, obviously that would be better than just speculating.  I'm waiting for this test run to finish so I can do a debug build of PARI for easier debugging.  Though I suppose I could go ahead and try it now and see how easily I can decipher the assembly.


---

Comment by jdemeyer created at 2019-02-21 14:34:45

Replying to [comment:19 embray]:
> decipher the assembly.

Always fun!


---

Comment by jdemeyer created at 2019-02-21 14:35:42

On Linux, I'm trying to add some assertions inside the `red_montgomery` function to check for potential problems but everything is OK so far.


---

Comment by embray created at 2019-02-21 14:48:02

I noticed that it gets called many times in a loop, and each time `avma` goes down a little bit, as though there's (maybe?) a memory leak on the PARI stack.  So you might be right that I'm just hitting the bottom of the stack.  Wouldn't this normally be protected against?

I have no idea what this algorithm is either so I can't speak too intelligently about what it should or shouldn't be doing.


---

Comment by jdemeyer created at 2019-02-21 14:51:20

Replying to [comment:22 embray]:
> I noticed that it gets called many times in a loop, and each time `avma` goes down a little bit, as though there's (maybe?) a memory leak on the PARI stack.

What you describe is completely normal and just normal usage of the stack by `cypari2`. If you run it even more times in a loop, you should see that the stack is actually cleared completely at regular times.


---

Comment by jdemeyer created at 2019-02-21 14:58:20

Replying to [comment:22 embray]:
> So you might be right that I'm just hitting the bottom of the stack.

I actually meant hitting the _top_ of the stack. With cypari2, when doing `pari.isprime(2^127 - 1)` right after startup, the number `2^127 - 1` is literally the very first thing on the stack. When evaluating the GP expression `isprime(2^127 - 1)`, this is not true since computing `2^127 - 1` also needs a bit of stack. Also when first computing `pari(3)` (or whatever), the number `2^127 - 1` is no longer the first thing on the stack. So we have a 100% correlation between the number being the first thing on the stack and the crash.

But we don't know yet why things are different on Cygwin. This is crashing in pure C code, where the OS shouldn't matter.


---

Comment by embray created at 2019-02-21 15:02:28

I see, thank you for your analysis.  That does make sense given the overall behavior we're seeing (where it doesn't crash if I do something else first).

As for why things are different, it may very well be that the bug exists on Linux too, but just happens to be accessing memory that is allocated to the process for some other purpose, or perhaps that's within some page alignment?  I'm not sure.  It will help once I can find the exact line it's crashing on.


---

Comment by embray created at 2019-02-21 15:34:30

FWIW I built a PARI/gp and cypari2 outside of sage and was able to reproduce the problem with that as well, with my normal system Python.  I have to go home for now so I probably can't look at it any more today, but I think I'll be able to have a closer look in gdb tomorrow.


---

Comment by embray created at 2019-02-21 18:44:41

Changing status from new to needs_review.


---

Comment by embray created at 2019-02-21 18:44:41

Replying to [comment:25 embray]:
> or perhaps that's within some page alignment?

I think I was on to something with this conjecture.


```
On Cygwin sysconf(_SC_PAGE_SIZE) cannot be relied on to accurately
page-align the top of the PARI stack, because it does not actually give
the correct physical page size (this is intentional, as a compromise
with POSIX requirements that are incompatible with most Windows
versions; see
https://www.cygwin.com/ml/cygwin-patches/2016-q4/msg00002.html)

Normally, the value returned by sysconf(_SC_PAGE_SIZE) is actually
larger than the physical page size, which can result in placing the
top of the pari_mainstack a little past the real end of the allocated
memory region.

As it happens, the mem_unit member returned by sysinfo() does, however,
give the correct page size on Cygwin.
```


I want to run a full build/test of Sage with this patch, but at least in isolation it appears to do the trick.

What I still don't fully understand is why I never saw this bug before cypari2.  Is it possible that it just plays closer to the top of the stack when doing operations in a freshly initialized `Pari`?
----
New commits:


---

Comment by jdemeyer created at 2019-02-22 09:18:43

I don't think that this patch is related to the bug we're seeing here. In particular, I don't believe this:

```
which can result in placing the
top of the pari_mainstack a little past the real end of the allocated
memory region.
```

If this were true, then we would be hitting segmentation faults all the time, not just in this particular `isprime()` function.

The patch might just accidentally work around the bug by changing memory locations or something, but I don't see how it would fix anything.


---

Comment by jdemeyer created at 2019-02-22 09:49:12

Now that I knew better what to look for, I can reliably reproduce this on Linux too (see ticket description). The missing bit was forcing a `PROT_NONE` mmap region right after the PARI stack.


---

Comment by jdemeyer created at 2019-02-22 09:53:25

Have to go now. After lunch, I'll try to get a good GDB trace of this.


---

Comment by jdemeyer created at 2019-02-22 11:16:50

Reported upstream: https://pari.math.u-bordeaux.fr/cgi-bin/bugreport.cgi?bug=2117


---

Comment by jdemeyer created at 2019-02-22 11:16:50

Changing component from interfaces to packages: standard.


---

Comment by embray created at 2019-02-22 11:25:25

Yep. FWIW the line it crashes on in `red_montgomery` is the last line of this block:


```
1008   if (carry)
1009   { /* Td > N overflows (k+1 words), set Td := Td - N */
1010     GEN NE = N + k+2;
1011     Td = Te;
1012     Nd = Ne;
1013     t = subll(*++Td, *++Nd); *Td = t;
1014     while (Nd < NE) { t = subllx(*++Td, *++Nd); *Td = t; }
1015   }
```


It crashes here after a few hundred calls to the function.  On the last call where it crashes `N` is top-most GEN on the stack, the value `(2^127 - 1)` itself, in this case, and it so happens then that `NE = N + k + 2` is the top of the stack.  So in the `while` loop the last `*++Nd` attempts to dereference the address at the top of the stack and this is where it segfaults.

Now, this _should_ work, and my patch fixes that.  I'm less certain exactly why though, and am beginning to suspect some bug/subtlety in Cygwin with page boundaries and mmap.  This is the test program that led me to my fix:


```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <stdio.h>
#include <sys/errno.h>
#include <string.h>
#include <stdlib.h>


size_t PARI_STACK_ALIGN = 4096;
#define SIZE 1000000


static void mainstack_mreset(void*, void*);


static size_t fix_size(size_t a)
{
    size_t ps = PARI_STACK_ALIGN;
    size_t b = a & ~(ps - 1);
    if (b < a && b < ~(ps - 1)) b += ps;
    return b;
}


int main(int argc, char** argv) {
    void *b;
    size_t align;
    size_t size;
    if (argc == 2 && atoi(argv[1]) == 1) {
        PARI_STACK_ALIGN = sysconf(_SC_PAGESIZE);
    }

    size = fix_size(SIZE);

    b = mmap(NULL, size, PROT_READ|PROT_WRITE,
             MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);

    printf("PARI_STACK_ALIGN = 0x%lx\n", PARI_STACK_ALIGN);
    printf("size = 0x%lx\n", size);
    printf("bot = 0x%lx\n", b);
    printf("top = 0x%lx\n", b + size);
    printf("*(char*)bot = 0x%lx\n", *(char*)(b));
    printf("*(char*)(top - 1) = 0x%lx\n", *(char*)((b + size) - 1));
    printf("*(char*)top = 0x%lx\n", *(char*)(b + size));
    printf("*(int*)top = 0x%lx\n", *(int*)(b + size));
    return 0;
}
```


When run like `./test 0` it uses 4096 as the page size (which the actual value on Windows):


```
$ ./test.exe 0
PARI_STACK_ALIGN = 0x1000
size = 0xf5000
bot = 0x6fffff00000
top = 0x6ffffff5000
*(char*)bot = 0x0
*(char*)(top - 1) = 0x0
*(char*)top = 0x0
*(int*)top = 0x0
```


When run like `./test 1` it uses `sysconf(_SC_PAGE_SIZE)` (which is 64k):


```
$ ./test.exe 1
PARI_STACK_ALIGN = 0x10000
size = 0x100000
bot = 0x6fffff00000
top = 0x70000000000
*(char*)bot = 0x0
*(char*)(top - 1) = 0x0
Segmentation fault (core dumped)
```


Somewhat to my surprise this also holds with or without `MAP_NORESERVE` so I don't think that's related, though it could have been.


---

Comment by embray created at 2019-02-22 11:25:25

Changing component from packages: standard to interfaces.


---

Comment by embray created at 2019-02-22 11:28:13

Okay, I see you found the same issue in `red_montgomery`.  Actually I'm not sure if normally I _should_ be able to dereference `(b + size)` or if I'm mentally making an off-by-one.  Need more coffee.


---

Comment by embray created at 2019-02-22 11:51:24

Yes, that's it. Internally, Cygwin's `mmap` uses the larger "allocation granularity" (64k) as the "page size" for mmap'd regions, since each `VirtualAlloc` has to be aligned to multiple of 64k anyways, so there's no point in making a mmap that is less than a multiple of 64k. So the behavior I was originally getting was actually correct, but when I used a 4k `PARI_STACK_ALIGN` it was putting the stack top below the end of a larger 64k range of memory, so that "fixed" the problem, sort of by chance, as you surmised. Similarly on Linux I guess it just happened that you had readable memory at that location unless you forcibly do a `MAP_FIXED` mmap there with `PROT_NONE` or something.


---

Comment by jdemeyer created at 2019-02-22 12:58:37

This is actually already fixed in PARI master. I'll create a branch.


---

Comment by jdemeyer created at 2019-02-22 13:03:09

Replying to [comment:34 embray]:
> Yes, that's it. Internally, Cygwin's `mmap` uses the larger "allocation granularity" (64k) as the "page size" for mmap'd regions, since each `VirtualAlloc` has to be aligned to multiple of 64k anyways, so there's no point in making a mmap that is less than a multiple of 64k. So the behavior I was originally getting was actually correct, but when I used a 4k `PARI_STACK_ALIGN` it was putting the stack top below the end of a larger 64k range of memory, so that "fixed" the problem, sort of by chance, as you surmised.

So it seems to me that the "allocation granularity" is the right measure to use after all.

> Similarly on Linux I guess it just happened that you had readable memory at that location

Indeed.

> unless you forcibly do a `MAP_FIXED` mmap there with `PROT_NONE` or something. 

Well, doing an `mmap` of `/dev/zero` with `PROT_NONE` was sufficient (this used to be in the ticket description before you accidentally reverted it)
----
New commits:


---

Comment by embray created at 2019-02-22 13:08:25

Replying to [comment:37 jdemeyer]:
> So it seems to me that the "allocation granularity" is the right measure to use after all.

Yes, apparently so.  Last time I was bitten by this it was because I wanted to make memory usage calculations given a page count, and in that case using it for the page size was actually wrong, but not in this case.

In this case it gave me behavior I _wanted_ (accessing that memory address did not cause an access violation) but what I wanted was also wrong in the first place.

> Well, doing an `mmap` of `/dev/zero` with `PROT_NONE` was sufficient (this used to be in the ticket description before you accidentally reverted it)

Oops, sorry.


---

Comment by embray created at 2019-02-26 12:36:26

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-02-28 17:54:09

Resolution: fixed
