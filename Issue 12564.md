# Issue 12564: More solver options for GLPK

Issue created by migration from Trac.

Original creator: john_perry

Original creation time: 2012-03-23 15:38:13

Assignee: ncohen

CC:  ncohen r.gaia.cs

Keywords: solver parameters

Several requests for solver options to use as parameters for GLPK prompt us to allow the user to set quite a few parameters.

In addition, the name for the solver paramter in ticket #12309 (`preprocessing`) isn't very accurate (we didn't think it through carefully enough at the time) so that option will change, too.

I propose to change/enable the following solver options. See the GLPK documentation for details on each option, and note that most have two names: one to correspond to GLPK, one for legibility.

* glpk's solver
  * default is `glp_intopt`, as at present
  * `simplex_first`: setting this to `True` makes the solver invoke `glp_simplex` before `glp_intopt`
    * useful to avoid problems in glpk
    * *replaces* current `preprocessing` parameter
  * `simplex_only`: setting this to `True makes the solver invoke `glp_simplex` *instead* of `glp_intopt`

* glpk's `intopt` solver
  * `msg_level` or `verbosity`
  * `br_tech` or `branching`
  * `bt_tech` or `backtracking`
  * `pp_tech` or `preprocessing`
  * `fp_heur` or `feasibility_pump`
  * `gmi_cuts` or `gomory_cuts`
  * `mir_cuts` or `mixed_int_rounding_cuts`
  * `cov_cuts` or `mixed_cover_cuts`
  * `clq_cuts` or `clique_cuts`
  * `tol_int` or `absolute_tolerance`
  * `tol_obj` or `relative_tolerance`
  * `mip_gap` or `mip_gap_tolerance`
  * `tm_lim` or `time_limit`
  * `out_freq` or `output_frequency`
  * `presolve` or `mip_presolver`
  * `binarize`

* glpk's `simplex` solver
  * `msg_level` or `verbosity`
  * `meth` or `primal_v_dual`
  * `pricing`
  * `r_test` or `ratio_test`
  * `tol_bnd` or `tolerance_primal`
  * `tol_dj` or `tolerance_dual`
  * `tol_piv` or `tolerance_pivot`
  * `obj_ll` or `obj_lower_limit`
  * `obj_ul` or `obj_upper_limit`
  * `it_lim` or `iteration_limit`
  * `tm_lim` or `time_limit`
  * `out_frq` or `output_frequency`
  * `out_dly` or `output_delay`
  * `presolve`

Feel free to suggest better names, or that we stick with only the GLPK names, etc.


---

Attachment


---

Comment by john_perry created at 2012-03-26 14:39:25

Raniere,

I don't like the idea of using strings for the solver parameter name. This is primarily for efficiency reasons; you have to remember that in my projects, I create a lot of small LPs, & don't want to deal with the string comparisons when an integer comparison will do much better.

I will upload another patch in a little bit (I finally figured out how to do it) and you can tell me what you think of this approach.


---

Comment by john_perry created at 2012-03-26 14:45:55

Replying to [comment:2 john_perry]:
> I don't like the idea of using strings for the solver parameter name.

Argh. Expressed myself badly: I meant,

> ...for the solver parameter *value*.

Although, given that the name is passed as a string, that may be a dumb objection.


---

Comment by ncohen created at 2012-03-26 15:03:46

Helloooooo John !!!

Did you try whether it really makes a difference in practice ? I mean, if you replace the arguments by integers and feed it with the right integer, is it really faster ? I am afraid of Python's own efficiency, and I wonder if this may not be the real bottleneck :-)

Nathann


---

Comment by john_perry created at 2012-03-26 15:10:08

Replying to [comment:4 ncohen]:
> Did you try whether it really makes a difference in practice ? I mean, if you replace the arguments by integers and feed it with the right integer, is it really faster ? I am afraid of Python's own efficiency, and I wonder if this may not be the real bottleneck :-)

I create & modify these lp's all in Cython.


---

Comment by ncohen created at 2012-03-26 15:12:02

Oh. And does it make a difference, even in Cython ? I thought you were using the MixedIntegerLinearProgram.solver_parameter function, but it looks like you directly use the backend `;-)`

Perhaps the best for you would be to create an empty LP with the right parameters and clone it afterwards !

Nathann


---

Comment by r.gaia.cs created at 2012-03-26 15:55:28

Replying to [comment:3 john_perry]:
John,
using strings for name and value was my first and only ideia of how to do GLPKBackend.solver_parameter work with MixedIntegerLinearProgram.solver_parameter with not import GLPKBackend module.
For some parameter that only two values are avaliable it's possible to use True and False as values.

Raniere


---

Comment by john_perry created at 2012-03-26 18:11:59

The declaration of the `solve()` method of the `MixedIntegerLinearProgram` class is


```
    def solve(self, solver=None, log=0, objective_only=False):
```

Within the function we have


```
        self._backend.set_verbosity(log)
```

Makes sense, you say, right? Well, no, for three reasons:

 1. It renders moot the `msg_lev` solver paramter.
 1. It's a bit weird to initialize `log`  to 0, since the solvers are already initialized to shut up in `__cinit__` .
 1. Someone might want to see whether the solver is making any progress, by setting the verbosity through the solver parameter, rather than through `solve()` .

IMHO, the user ought to have that option; otherwise, there's no point to allowing a `msg_level` option at all. This is easily fixed, too: change the default value of `log` to `None`, and then the code to,


```
        if log != None:
          self._backend.set_verbosity(log)
```

This should retain compatibility with the previous setup.

What do you guys think?


---

Comment by john_perry created at 2012-03-26 18:12:49

Replying to [comment:7 r.gaia.cs]:
> using strings for name and value was my first and only ideia of how to do GLPKBackend.solver_parameter work with MixedIntegerLinearProgram.solver_parameter with not import GLPKBackend module.

That's fine, and it even makes sense. The patch I'm preparing now will allow both approaches.


---

Comment by john_perry created at 2012-03-26 20:27:52

Changing status from new to needs_review.


---

Comment by john_perry created at 2012-03-26 20:27:52

I've added my version of a patch that should take care of the same thing. Although the coverage is more or less what we discussed, you may not like the approach I used to expose the GLPK constants: basically, I define them as module-level constants. I use this for both the names and the values. That way, the hard parts get done by integers, which should mitigate questions of efficiency. Well, sort of. `:-/`

The patch probably needs more doctests. Suggestions?


---

Comment by john_perry created at 2012-03-26 23:04:21

Sorry -- the last patch was prepared in a hurry, right before teaching a class. I came back & discovered doctests, which are now fixed. This version passes all doctests in sage/numerical, so it should now be a question of adding new ones, & deciding if this captures the interface we really want.


---

Comment by r.gaia.cs created at 2012-03-26 23:24:01

Replying to [comment:11 john_perry]:
I look very quickly your patch and I like it.
IMHO, is better pass the number values in miliseconds as in GLPK.


---

Comment by john_perry created at 2012-03-26 23:26:22

Replying to [comment:12 r.gaia.cs]:
> IMHO, is better pass the number values in miliseconds as in GLPK.

Thanks. I remember that I wanted to check that, but forgot. I'll fix that once I have more input.


---

Comment by john_perry created at 2012-04-04 03:31:42

Replying to [comment:12 r.gaia.cs]:
> IMHO, is better pass the number values in miliseconds as in GLPK.

While working on this tonight, I realized that mip.pyx expects the `timelimit` parameter for both CPLEX and GLPK to be in seconds. To get around this, I added a new parameter, `timelimit_intopt` and `timelimit_simplex`; these accept milliseconds.

I also added a couple of new doctests, one to test this difference.

I would like to doctest output when we set `msg_level` to something other than `...off`, but apparently the doctest facility doesn't recognize output produced by linked C code, only output produced by Python or Cython. If anyone has an idea on how to make that work, let me know.

Otherwise, I guess this is ready. (I've tested it with some of my own code, too.)

NEEDS REVIEW.


---

Comment by ncohen created at 2012-04-05 14:08:33

Helloooooooo John !!

> While working on this tonight, I realized that mip.pyx expects the `timelimit` parameter for both CPLEX and GLPK to be in seconds. To get around this, I added a new parameter, `timelimit_intopt` and `timelimit_simplex`; these accept milliseconds.

Hmmm... Why do you name this parameter timelimit_intopt or timelimit_simplex and not timelimit_seconds, or something like that ? What does it specifically have to do with simplex or intopt ? I think it would be better to have only one parameter for timelimit, and if you think that milliseconds are better what about having only one parameter which accepts milliseconds ? By the way, it is already possible to define the timelimit up to milisecond with this argument. The code actually multiplies the input by 1000 before updating GLPK's value `:-)`

Nathann


---

Comment by ncohen created at 2012-04-05 14:09:58

Hmmmmmm `O_o`

I quickly looked at the code again and you apparently also thought of a timelimit_seconds parameter, though it appears in the code and not in the documentation `^^;`

Nathann


---

Comment by john_perry created at 2012-04-09 23:21:51

Replying to [comment:15 ncohen]:
> Hmmm... Why do you name this parameter timelimit_intopt or timelimit_simplex and not timelimit_seconds, or something like that ?

I guess, just to be as specific as possible... in case someone needed it. I can't foresee all uses. But, for example, if someone wants to run `simplex_then_intopt`, she might want to set `timelimit_intopt` much higher than `timelimit_simplex`, because she knows that, in general, integer optimization takes much longer. Whereas if `simplex` doesn't end relatively quickly, there could be a bigger problem altogether.


---

Comment by ncohen created at 2012-04-10 14:23:26

Oh, you mean that timelimit_intopt limits the time it takes for the whole ILP to be solved while timelimit_simplex just bounds the time it takes to run the simplex algorithm for a *relaxed* instance.. Okok, I just didn't get that part `:-)`

The list of parameters is so long that I begin to look for a way to do it with dichotomy instead of trying all the different parameters, but that would really be messy `:-D`

By the way, about the string and integer values for the parameters.. Does it really make a meaningful difference in runtimes ? Just being curious `^^;`

Nathann


---

Comment by john_perry created at 2012-04-10 15:15:36

Replying to [comment:18 ncohen]:
> The list of parameters is so long that I begin to look for a way to do it with dichotomy instead of trying all the different parameters, but that would really be messy `:-D`

Yeah. The long list of parameters can be a drag, but that's the price of enabling everything in GLPK. Alternately, we could decide to take a bunch of things off (would people actually use them?) but I'll bet that if we remove Gomory cuts, say, then we'll hear something in six weeks. `;-)`

> By the way, about the string and integer values for the parameters.. Does it really make a meaningful difference in runtimes ? Just being curious `^^;`

If your focus is a handful of large linear programs, the penalty of Python strings v. machine integers might not matter. If your focus is a few thousand small linear programs, it could be an issue -- especially if you start mucking around w/options quite a bit.

Admittedly, in my own work I don't seem to need the options after all, and I've managed to revise, revise, revise my approach until I'm now creating only a few tens of programs, instead of a few thousand. So it's not that big an issue for me as it used to be. But it could become an issue again in the future.


---

Comment by ncohen created at 2012-04-10 16:30:23

Hellooooooooo !!!

> Yeah. The long list of parameters can be a drag, but that's the price of enabling everything in GLPK. Alternately, we could decide to take a bunch of things off (would people actually use them?) but I'll bet that if we remove Gomory cuts, say, then we'll hear something in six weeks. `;-)`

Oh, I really do not mind, I was just looking at the code and thinking that if the user wanted to set the LAST parameter the code would test all others first. That's why I would have wanted some dichotomy ! `:-D`
But that is just a natural reflex. Of course it is muuuuch better implemented like that.

> If your focus is a handful of large linear programs, the penalty of Python strings v. machine integers might not matter. If your focus is a few thousand small linear programs, it could be an issue -- especially if you start mucking around w/options quite a bit.
> 
> Admittedly, in my own work I don't seem to need the options after all, and I've managed to revise, revise, revise my approach until I'm now creating only a few tens of programs, instead of a few thousand. So it's not that big an issue for me as it used to be. But it could become an issue again in the future.

Well, I was just surprised that comparing integers was *that much shorter* than comparing strings. And that it could become the bottleneck in LP codes `:-)`

Ok, I should give this code a proper review now !

Nathann


---

Comment by john_perry created at 2012-04-10 16:37:43

Replying to [comment:20 ncohen]:
> I was just looking at the code and thinking that if the user wanted to set the LAST parameter the code would test all others first. That's why I would have wanted some dichotomy ! `:-D`

That bothers me, too. I guess it should be organized so that the options most likely to come first would be tested first -- OR -- organize an if tree so that we have O(log(n)) comparisons instead of O(n). I'm completely open to suggestions on that.

> Well, I was just surprised that comparing integers was *that much shorter* than comparing strings.

I don't have hard tests, but it seems pretty obvious; string comparison is quite a bit more expensive.

> And that it could become the bottleneck in LP codes `:-)`

Unlikely, of course, but every bit helps `:-)`


---

Comment by ncohen created at 2012-04-10 19:01:58

Hellooooooooo John !!

Since #12816 I am really into Sphinx tables, so perhaps it was a bad idea in this case... But what do you think of the following patch ? It applies on top of yours `:-)`

There is nothing else that seems wrong at this level... Only some details in the documentation. Give me your advice on that ! `:-)`

Nathann


---

Attachment


---

Comment by john_perry created at 2012-04-10 19:18:01

Replying to [comment:22 ncohen]:
> Since #12816 I am really into Sphinx tables...

I hadn't heard of them. Okay, the update is merely to the documentation. What's a good way of viewing it? Should it work even in text mode?


---

Comment by ncohen created at 2012-04-10 19:19:12

> I hadn't heard of them. Okay, the update is merely to the documentation. What's a good way of viewing it? Should it work even in text mode?

No, it should change nothing to the text mode, but the html doc should be much better !!

To compile it :

sage -b <your_branch> && sage -docbuild reference html

Nathann


---

Comment by john_perry created at 2012-04-10 19:25:16

Replying to [comment:25 ncohen]:
> To compile it :
> 
> sage -b <your_branch> && sage -docbuild reference html

Building the reference will take a while, won't it? If so, I'll wait until later to do this.


---

Comment by ncohen created at 2012-04-10 19:27:05

It depends on your luck. Usually it just compiles "the difference", but with some Sage install it may mean building them from the beginning `:-)`

You can add a "nice" before, if that is too heavy :
sage -b <your_branch> && nice sage -docbuild reference html

Nathann


---

Comment by john_perry created at 2012-04-12 20:06:35

I am now getting, on two different machines, doctest failures in `mip.pyx` when #12736 is applied. They report different lines (different betas, different patches applied, I guess) but the basic idea is this:

```
Expected:
    Traceback (most recent call last):
    ...
    MIPSolverException: 'GLPK : Solution is undefined'
...
Got:
    Traceback (most recent call last):
    ...
    MIPSolverException: 'GLPK: An error occurred in the solver'
```

I
At first, I thought it was just a matter of the space, but then I realized the errors were different, too. I'm going to look into this real quick.

Also, I added a dependency to the ticket description.


---

Comment by john_perry created at 2012-04-12 20:06:35

Changing status from needs_review to needs_work.


---

Comment by john_perry created at 2012-04-12 20:28:00

Okay, it looks as if * _I_ * had forgotten to test `mip.pyx` this time! Basically, I had added to `glpk_backend`'s `solve()` method a test for correctness when the timer runs out. I did this because otherwise `mip.pyx` thought there was a solution. (I don't remember exactly why.)

For now, I've changed the expected string in the doctest to reflect what the backend currently has, but another (better?) mofidication would be to change the backend to test for the precise signal (`GLP_ETMLIM`) and raise an exception telling the user that time ran out, so the solution will be invalid.

Which do youprefer?


---

Comment by ncohen created at 2012-04-12 20:53:37

Helloooooooo John !!

I see no new method in your patch, but it is a bit hard to see what you *changed* inside of this large patch. By the way, if you modify your patch while mine already applies on top of it, there's a chance that it will break afterwards `^^;`

I do not use this timelimit option myself, but it would surely be nice to be able to know whether the value of the variables when GLPK stops has any meaning.... Would it be possible to return a MIPSolverException or something similar when the computations stopped because of time ? It could probably detected along with the other ones (unbounded/impossible/no integer solution/...).

Nathann


---

Comment by john_perry created at 2012-04-12 22:07:45

Replying to [comment:30 ncohen]:
> I see no new method in your patch...

Correct. There wasn't one. I only changed a doctest.

> ...but it is a bit hard to see what you *changed* inside of this large patch. By the way, if you modify your patch while mine already applies on top of it, there's a chance that it will break afterwards `^^;`

I've tried it with your patch on top, too. `:-)`

> Would it be possible to return a MIPSolverException or something similar when the computations stopped because of time ?

Of course. I'll do that.


---

Comment by john_perry created at 2012-04-12 22:37:18

Changing status from needs_work to needs_review.


---

Attachment

I've uploaded a new patch that restores things as they were.

Also, perhaps you wrote the wrong thing earlier: it occurred to me later that I might have uploaded the wrong patch... This one is definitely different, as you can find the GLP_ETMLIM and GLP_EITLIM signals used.

I looked at the generated html documentation, and it looked great! So, if you're okay with the current patch, I think we can award it a positive review?


---

Comment by ncohen created at 2012-04-13 08:12:08

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2012-04-13 08:12:08

Helloooooooo John !!

Well, if you also agree with my changes then I guess this patch can go ! I regret that it is hard to test these timelimit exceptions, though I did a test myself by modifying a hard LP and solving it with a time limit. The exception is indeed thrown, and besides the last message printed by GLPK is 

```
TIME LIMIT EXCEEDED; SEARCH TERMINATED
```

So well... It will show anyway `:-)`

On the practical side, all doctests pass with GLPK as the default solver, the documentation is nice, well. Good addition `:-)`

Nathann


---

Comment by jdemeyer created at 2012-04-16 12:31:10

Please fill in the Author/Reviewer fields with your real names.


---

Comment by jdemeyer created at 2012-05-06 12:15:58

Resolution: fixed
