# Issue 14056: Casting a standard tableau as a tableau

Issue created by migration from https://trac.sagemath.org/ticket/14260

Original creator: chrisjamesberg

Original creation time: 2013-03-12 13:44:32

Assignee: sage-combinat

Keywords: tableau

Right now, if I have a standard tableau, I can't cast it as a tableau. For instance:


```
sage: t = StandardTableau([[1]])
sage: type(Tableau(t))
sage.combinat.tableau.StandardTableaux_all_with_category.element_class
```



---

Comment by stumpc5 created at 2013-03-12 13:49:45

This just comes from 

```
sage: t = StandardTableau([[1]])
sage: isinstance(t,Tableau)
True
```

and before trying to construct a tableau from some input this is tested... I wouldn't consider this a bug but more a feature: a standard tableau has all features of a tableau, plus extra. So for Sage users, I think this is the desired behaviour...


---

Comment by tscrim created at 2013-03-18 20:17:06

Changing status from new to needs_review.


---

Comment by tscrim created at 2013-03-18 20:17:06

This is the desired and correct behavior. Elements (such as [`Standard`]`Tableau`) are typically meant to be immutable, so something which is a standard tableau should always remain a standard tableau. Also because `Tableau` is only suppose to put a non-tableau object into a tableau, it shouldn't do anything for any class which is a subclass of `Tableau`.

Also I can't think of a good reason why you'd want to explicitly cast an object into a subclass (the concept of type casing technically doesn't exist in python). (I don't quite know what context this came up in, but the first one that comes to mind is you're trying to get an overriden method `foo(*args)` in the base class, to which you can do `Tableau.foo(t, *args)`.) Could you explain more why you want this explicit casting?


---

Comment by tscrim created at 2013-03-18 20:17:06

Changing type from PLEASE CHANGE to defect.


---

Comment by chrisjamesberg created at 2013-03-19 02:08:14

This casting is used all over the place. Immutability has nothing to do with it, a tuple is immutable and yet I can cast it as a list.

One can cast a Partition as a Composition:


```
sage: Composition(Partition([3,2,1]))
[3, 2, 1]
sage: isinstance(c, Composition)
True
sage: isinstance(c, Partition)
False
```


Which is the correct behavior?


---

Comment by tscrim created at 2013-03-19 14:12:31

You're not casting when you do that, you're creating a new object altogether, including tuples/lists:

```
sage: T = tuple(1, 2, 3)
sage: L = list(T)
sage: L
[1, 2, 3]
sage: L.append(4); L
[1, 2, 3, 4]
sage: T
(1, 2, 3)
```

In python, I believe the copy is done lazily, so if it's an immutable type, it is safe to just return the original object. Sage follows this paradigm. With your example above, `Composition` and `Partition` are different classes (with methods for `Composition` not in `Partition`), and the above behavior is a reflection of this. Why isn't `Partition` a subclass of `Composition`? I think that's more of a question for Nicolas. (A guess might be because of some overhead, but I don't really know. The explicit conversion has been sufficient for me.)

Casting is something which tells the program that the _same_ object is a different _type_. For example in C++

```c++
class Foo {
};
class Bar : public Foo {
   public:
   B() { }
};

Foo *f = new Bar();
Bar *b = (Bar) f;
```

The last line is casting because a priori, the computer doesn't know `f` is pointing to a type `Bar`, so it wouldn't know what to do. Also note that both `f` and `b` point to the same object in memory.


---

Comment by ncohen created at 2013-06-27 17:00:46

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2013-06-27 17:00:46

(if you want this ticket to be closed ...)

Nathann


---

Comment by jdemeyer created at 2013-08-13 08:33:58

Resolution: invalid
