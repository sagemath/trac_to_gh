# Issue 22485: R is not in Ideals(R)

Issue created by migration from https://trac.sagemath.org/ticket/22722

Original creator: tscrim

Original creation time: 2017-03-30 16:58:29

This was surprising to me:

```
sage: ZZ in Ideals(ZZ)
False
```

Should be easy enough to fix as it is just a missed case in the custom `__contains__` method.


---

Comment by msaaltink created at 2017-03-31 17:07:05

This is consistent with many other functions that do not treat a ring R as an ideal, for example

```
sage: ZZ.quotient_ring(ZZ)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: I must be an ideal of ZZ or an integer
sage: ZZ.quotient_ring(1*ZZ)
Ring of integers modulo 1
```


So ZZ is not treated as an ideal, but 1*ZZ is.  And this is correctly implemented:

```
sage: (1*ZZ) in Ideals(ZZ)
True
```



---

Comment by tscrim created at 2017-04-01 03:27:33

However, that doesn't absolve the problem. I would say it is evidence that it is more systematic. I think I will start digging into this on the code side.

I guess another question is should `1*ZZ == ZZ` and/or be `ZZ`?


---

Comment by msaaltink created at 2017-04-01 18:42:18

It is indeed systematic and this sort of thing afflicts other categories, like monoids

```
sage: ZZ in Monoids()
True
sage: 1*ZZ in Monoids()
False
```

semigroups,

```
sage: ZZ in Semigroups()
True
sage: 2*ZZ in Semigroups()
False
```

and rings:

```
sage: (1*ZZ) in Rings()
False
sage: (1*ZZ) in Rngs()
False
```


On the plus side, Sage knows that ideals are additive groups:

```
ZZ.categories()[24]
Category of additive groups
sage: AG = _
sage: AG.axioms()
frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})
sage: ZZ in AG
True
sage: (2*ZZ) in AG
True
```


To weigh in on your question, if you make ZZ known as an ideal of itself, then 1*ZZ == ZZ would make sense, and indeed they could be identical.
