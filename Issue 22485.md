# Issue 22485: R is not in Ideals(R)

archive/issues_022485.json:
```json
{
    "body": "This was surprising to me:\n\n```\nsage: ZZ in Ideals(ZZ)\nFalse\n```\n\nShould be easy enough to fix as it is just a missed case in the custom `__contains__` method.\n\nIssue created by migration from https://trac.sagemath.org/ticket/22722\n\n",
    "created_at": "2017-03-30T16:58:29Z",
    "labels": [
        "categories",
        "major",
        "enhancement"
    ],
    "title": "R is not in Ideals(R)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22485",
    "user": "tscrim"
}
```
This was surprising to me:

```
sage: ZZ in Ideals(ZZ)
False
```

Should be easy enough to fix as it is just a missed case in the custom `__contains__` method.

Issue created by migration from https://trac.sagemath.org/ticket/22722





---

archive/issue_comments_313316.json:
```json
{
    "body": "This is consistent with many other functions that do not treat a ring R as an ideal, for example\n\n```\nsage: ZZ.quotient_ring(ZZ)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n...\nTypeError: I must be an ideal of ZZ or an integer\nsage: ZZ.quotient_ring(1*ZZ)\nRing of integers modulo 1\n```\n\n\nSo ZZ is not treated as an ideal, but 1*ZZ is.  And this is correctly implemented:\n\n```\nsage: (1*ZZ) in Ideals(ZZ)\nTrue\n```\n",
    "created_at": "2017-03-31T17:07:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22485#issuecomment-313316",
    "user": "msaaltink"
}
```

This is consistent with many other functions that do not treat a ring R as an ideal, for example

```
sage: ZZ.quotient_ring(ZZ)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: I must be an ideal of ZZ or an integer
sage: ZZ.quotient_ring(1*ZZ)
Ring of integers modulo 1
```


So ZZ is not treated as an ideal, but 1*ZZ is.  And this is correctly implemented:

```
sage: (1*ZZ) in Ideals(ZZ)
True
```




---

archive/issue_comments_313317.json:
```json
{
    "body": "However, that doesn't absolve the problem. I would say it is evidence that it is more systematic. I think I will start digging into this on the code side.\n\nI guess another question is should `1*ZZ == ZZ` and/or be `ZZ`?",
    "created_at": "2017-04-01T03:27:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22485#issuecomment-313317",
    "user": "tscrim"
}
```

However, that doesn't absolve the problem. I would say it is evidence that it is more systematic. I think I will start digging into this on the code side.

I guess another question is should `1*ZZ == ZZ` and/or be `ZZ`?



---

archive/issue_comments_313318.json:
```json
{
    "body": "It is indeed systematic and this sort of thing afflicts other categories, like monoids\n\n```\nsage: ZZ in Monoids()\nTrue\nsage: 1*ZZ in Monoids()\nFalse\n```\n\nsemigroups,\n\n```\nsage: ZZ in Semigroups()\nTrue\nsage: 2*ZZ in Semigroups()\nFalse\n```\n\nand rings:\n\n```\nsage: (1*ZZ) in Rings()\nFalse\nsage: (1*ZZ) in Rngs()\nFalse\n```\n\n\nOn the plus side, Sage knows that ideals are additive groups:\n\n```\nZZ.categories()[24]\nCategory of additive groups\nsage: AG = _\nsage: AG.axioms()\nfrozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\nsage: ZZ in AG\nTrue\nsage: (2*ZZ) in AG\nTrue\n```\n\n\nTo weigh in on your question, if you make ZZ known as an ideal of itself, then 1*ZZ == ZZ would make sense, and indeed they could be identical.",
    "created_at": "2017-04-01T18:42:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22485#issuecomment-313318",
    "user": "msaaltink"
}
```

It is indeed systematic and this sort of thing afflicts other categories, like monoids

```
sage: ZZ in Monoids()
True
sage: 1*ZZ in Monoids()
False
```

semigroups,

```
sage: ZZ in Semigroups()
True
sage: 2*ZZ in Semigroups()
False
```

and rings:

```
sage: (1*ZZ) in Rings()
False
sage: (1*ZZ) in Rngs()
False
```


On the plus side, Sage knows that ideals are additive groups:

```
ZZ.categories()[24]
Category of additive groups
sage: AG = _
sage: AG.axioms()
frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})
sage: ZZ in AG
True
sage: (2*ZZ) in AG
True
```


To weigh in on your question, if you make ZZ known as an ideal of itself, then 1*ZZ == ZZ would make sense, and indeed they could be identical.
