# Issue 11832: copying a linear program using Coin solver consumes enormous amounts of memory

Issue created by migration from https://trac.sagemath.org/ticket/12004

Original creator: john_perry

Original creation time: 2011-11-08 20:22:26

Assignee: ncohen

Keywords: linear programming, Coin, copy, memory

The following Sage program quickly explodes memory usage:

```
P = MixedIntegerLinearProgram(solver="Coin")
P.add_constraint(P[0]+P[1]==1)
while True:
  P = copy(P)
  w = solve(P)
```



---

Comment by john_perry created at 2011-11-08 20:30:05

One problem may lie in line 259 of mip.pyx:

```
cdef MixedIntegerLinearProgram p = MixedIntegerLinearProgram(solver="GLPK")
```

but changing this does not resolve the problem. In any case, I'm not sure what's the best way to fix this; `p` has to be initialized to *something*. When I first did it, I initialized `p` by checking `isinstance(self._backend,...)`, but that leads to import problems if CPLEX or Coin are not installed. That didn't fix the memory leak, so I didn't see the point in submitting even a preliminary patch. I could add an attribute that would indicate what the backend is, but there's probably a better way.


---

Comment by ncohen created at 2011-11-09 09:57:17

Ohhhhhh !! Now I remember why there is this solver="GLPK" where it shouldn't be, inside of the code ! It's because three lines later the ``_backend`` variable is overwritten anyway :


```
p._backend = (<GenericBackend> self._backend).copy()
```


So the solver used by the copy of the MILP will indeed be the same as the current solver, and all is well under the sun. Now, for some reason the bug could come from the fact that even though the p._backend is overwritten, the former object is not freed. Would a del p._backend just before the assigning a new value to p._backend solve the problem ? `:-)`

Nathann


---

Comment by john_perry created at 2011-11-09 16:52:19

Replying to [comment:2 ncohen]:
> Would a del p._backend just before the assigning a new value to p._backend solve the problem ? `:-)`

I had tried something like this, but Cython complains:

```
sage/numerical/mip.pyx:281:13: Cannot delete C attribute of extension type
```

Is there a command that lets me delete the backend? I can see that there is a command that is commented out, `void del_OsiCbcSolverInterface...`, but I haven't yet figured out whether I should uncomment or use that.


---

Comment by john_perry created at 2011-11-09 19:33:23

FWIW, I'm fairly convinced that initializing with the GLPK backend is not the problem. I tried the following modifications:

  * change `__init__` in MixedIntegerLinearProgram so that `solver==None` actually gives _no_ backend, not the GLPK backend;
  * in `__copy__`, initialize with `solver==None`.

I know it is a bad, bad idea to change the behavior of an initializer this way, but I thought it would give unequivocal evidence. I've changed my version back.

Indeed, *even in this case*, copying a Coin solver consumes enormous memory. It seems easier to break out of the loop, though. In fact, within 15 loops it consumes 1.6GB RAM. That's not a typo: only 15!!! `8-0`

So the problem really does lie elsewhere.


---

Comment by ncohen created at 2011-11-10 08:48:25

> So the problem really does lie elsewhere.

Did you add a "print 'Hey'" in the __dealloc__ method of the COIN backend, just to see whether the backends are really removed each time you overwrite the value of P ?

Nathann


---

Comment by john_perry created at 2011-11-10 11:54:13

Replying to [comment:5 ncohen]:
> Did you add a "print 'Hey'" in the __dealloc__ method of the COIN backend, just to see whether the backends are really removed each time you overwrite the value of P ?

No, but I tried it now, and the backends really are removed: I get a "hey" with every `copy`.

In addition, the explosion in memory occurs regardless of whether we add constraints or not. You could simply run `P = copy(P)` several times, and memory usage jumps up.


---

Comment by john_perry created at 2011-11-10 12:14:08

Maybe I'm wrong (probably) but the exponential growth suggests to me that, during the copy, some sort of nesting is going on. If the problem were merely a failure to deallocate, the growth should be merely linear, shouldn't it?

Python has a garbage collector -- is there any way to peek inside the structure of `P`, and see what constitutes it?


---

Comment by ncohen created at 2011-11-10 12:37:24

> Maybe I'm wrong (probably) but the exponential growth suggests to me that, during the copy, some sort of nesting is going on. If the problem were merely a failure to deallocate, the growth should be merely linear, shouldn't it?

Yep, right `O_o`

> Python has a garbage collector -- is there any way to peek inside the structure of `P`, and see what constitutes it?

I've got no idea how to do that. And if that were the case, it would have to deal with Cython too !

Nathann


---

Comment by john_perry created at 2011-11-10 13:06:53

Replying to [comment:8 ncohen]:
> > Maybe I'm wrong (probably) but the exponential growth suggests to me that, during the copy, some sort of nesting is going on. If the problem were merely a failure to deallocate, the growth should be merely linear, shouldn't it?
> 
> Yep, right `O_o`

I was afraid of that.

> > Python has a garbage collector -- is there any way to peek inside the structure of `P`, and see what constitutes it?
> 
> I've got no idea how to do that. And if that were the case, it would have to deal with Cython too !

I tried it (`import gc; gc.get_referents(P)`). It isn't really helpful.

I also tried the following: instead of calling the copy constructor, I called the clone method. I'm referring to this function in `OsiCbcSolverInterface.hpp`:

```
virtual OsiSolverInterface * clone(bool copyData = true) const;
```

That required modifying the `.pxd` file, of course. I got it to compile & run, but the memory problems persist. Still chugging away at this...


---

Comment by john_perry created at 2011-11-10 13:11:22

I tried the following code:

```
from sage.numerical.backends.coin_backend import CoinBackend

p = CoinBackend()
while True: p = copy(p)
```

We do *not* see an explosion of memory on this. The problem lies elsewhere.

Geez... I should have tried this a long time ago.


---

Comment by john_perry created at 2011-11-10 13:26:20

Ahh... spoke too soon. If I change the above to,

```
from sage.numerical.backends.coin_backend import CoinBackend

p = CoinBackend()
while True: p = p.copy()
```

then the memory problems persist.


---

Comment by john_perry created at 2011-11-10 16:39:33

I figured out how to implement the copy constructor: in the .pxd file, declare under `cdef cppclass c_OsiCbcSolverInterface "OsiCbcSolverInterface"`

```
  c_OsiCbcSolverInterface(c_OsiCbcSolverInterface &si)
```

In the .pyx file, I then call

```
        p.si = new c_OsiCbcSolverInterface(<c_OsiCbcSolverInterface>self.si)
```

It runs, but we still get exponential growth of memory.

I'm running out of ideas here. Do you have a copy of the Coin source, and can you see if there is exponential growth if we do the same thing there?


---

Comment by ncohen created at 2011-11-10 17:01:30

Hello again !

Did you try copying several times the line p.si = new [...] ? This way, each time you do a copy() in Sage the COIN interface actually does several of them, if the memory explodes faster you will be sure it comes from their code !

On my computer I am having some trouble installing CBC right now `^^;`

Nathann


---

Comment by john_perry created at 2011-11-10 17:51:33

Here's what I tried. In `coin_backend.copy` I changed line 990,

```
p.si = new c_OsiCbcSolverInterface(<OsiSolverInterface *> self.si)
```

to

```
for each in xrange(20): p.si = new c_OsiCbcSolverInterface(<OsiSolverInterface *> self.si)
```

That gave me no problems.

Then I changed it to two lines:

```
p.si = new c_OsiCbcSolverInterface(<OsiSolverInterface *> self.si)
for each in xrange(20): p.si = new c_OsiCbcSolverInterface(<OsiSolverInterface *> p.si)
```

and quickly regretted it!

So, it looks as if that's the problem.


---

Comment by john_perry created at 2011-12-08 20:12:45

I have successfully replicated the problem in C++ directly, using the following short program:

```
#include "include/coin/OsiCbcSolverInterface.hpp"
#include <stdio.h>

int main() {
  OsiCbcSolverInterface * si = new OsiCbcSolverInterface(NULL);
  
  for (int i = 0; i < 13; i++) {
    printf("%d ", i);
    si = new OsiCbcSolverInterface(si);
  }
  printf("\n");
  
  while (true) {}
  
  delete si;
}
```

An enormous amount of memory is consumed thereby. Since it's possible that this has already been resolved upstream, I will test with the latest version of Coin (2.7.5) in a moment.


---

Comment by john_perry created at 2011-12-08 22:00:37

Same problem in 2.7.5.


---

Comment by ncohen created at 2011-12-09 10:35:27

Hmmm.... So the issue is to "report upstream" ?

Nathann


---

Comment by john_perry created at 2011-12-09 14:42:43

I want to look carefully at the documentation first, and see if there's another way to do what we're trying to do. Maybe this approach is not what they actually want (but I doubt it). I'd also like to see if I can identify the precise location of the error.


---

Comment by john_perry created at 2011-12-09 15:16:14

The source code (`Cbc/src/OsiCbc/OsiCbcSolverInterface.cpp`) suggests we're doing the right thing: when supplied a solver, the constructor tries to clone it. I can see that they carry out several further steps, cloning the solver again, but that's for a different class member (`referenceSolver_`). Nothing strikes me as obviously wrong.

I will report it upstream and try to find out what's going on.


---

Comment by john_perry created at 2011-12-09 15:16:14

Changing assignee from ncohen to john_perry.


---

Comment by john_perry created at 2011-12-13 04:50:58

Changing status from new to needs_info.


---

Comment by john_perry created at 2011-12-13 04:50:58

Upstream replies pretty quickly, once you get the right mailing list. `:-)`

  > I may be wrong but in my experience OsiCbcSolverInterface has several problems and should not be used. If your problem is a linear program, you should use OsiClpSolverInterface instead. Once you load the problem in an object of class OsiClpSolverInterface, you can use the clone() method to obtain copies.

I can verify that modifying the test program above in this way means we can clone without an exponential memory leak:

```
#include "include/coin/OsiClpSolverInterface.hpp"
#include <stdio.h>

int main() {
  OsiClpSolverInterface * si = new OsiClpSolverInterface();
  OsiClpSolverInterface * newsi;
  
  for (int i = 0; i < 13; i++) {
    printf("%d ", i);
    newsi = dynamic_cast <OsiClpSolverInterface *>((*si).clone());
    delete si;
    si = newsi;
  }
  printf("\n");
  
  while (true) {}
  
}
```

(FWIW putting `newsi = ...; delete si; si = newsi;` didn't affect the previous version of the code, either.)

So, now I have a question. Is there a reason we're using the `OsiCbcSolverInterface` instead of the `OsiClpSolverInterface`? or is it okay to switch interfaces?


---

Comment by john_perry created at 2011-12-13 04:52:32

Changing assignee from john_perry to ncohen.


---

Comment by john_perry created at 2011-12-13 04:52:32

And how did I end up the owner of this ticket, anyway?


---

Comment by ncohen created at 2011-12-13 09:37:58

Well.... The main reason is that if I make no mistake Clp is their *linear* solver and Cbc their *integer* solver. So if we switch to OsiClpSolverInterface I guess we immediately loose the ability to solve integer programs `O_o`

Nathann


---

Comment by john_perry created at 2011-12-13 14:01:30

Replying to [comment:22 ncohen]:

> Well.... The main reason is that if I make no mistake Clp is their *linear* solver and Cbc their *integer* solver. So if we switch to OsiClpSolverInterface I guess we immediately loose the ability to solve integer programs `O_o` Nathann

This was a question I had in mind, by the way. Doesn't MILP return float() answers? In fact, I've often found it to return non-integer answers, so that in some of my code, I've had to hack a way to create approximate rational answers (which will suffice for my purposes).

I understand your problem, and I'll ask with them. One option that would work for me would be to create a separate Clp interface, and work with that. I guess that in this case, we couldn't package it with Coin.


---

Comment by john_perry created at 2011-12-13 14:11:17

> ...we couldn't package it with Coin.

Sorry, I meant "we couldn't package it with *_MI*_LP".


---

Comment by ncohen created at 2012-01-05 13:26:31

John reported the bug upstream, they acknowledge it is a bug and do not intend to fix it `:-D`

The reason is that the C++ class that is currently use to deal with Coin is "a mistake" according to the developpers. Anyway the package will eventually be upgraded by #12220, and the rewriting that it will require should solve this bug along.

Nathann


---

Comment by ncohen created at 2012-01-05 13:26:31

Changing status from needs_info to needs_review.


---

Comment by ncohen created at 2012-01-05 13:26:43

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2012-04-04 19:48:08

Resolution: duplicate
