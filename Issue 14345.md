# Issue 14345: Memory leak in algebraic_immunity of BooleanFunction class

Issue created by migration from Trac.

Original creator: okazymyrov

Original creation time: 2013-05-07 22:44:13

Assignee: mvngu

Keywords: algebraic_immunity, BooleanFunction

On my Mac OS X 10.8.3 the code


```
from sage.crypto.boolean_function import BooleanFunction
s=[BooleanFunction(random_vector(GF(2),16).list()).algebraic_immunity() for g in xrange(100)]
s=[BooleanFunction(random_vector(GF(2),16).list()).algebraic_immunity() for g in xrange(100)]
```

takes around 5GB of RAM on each "s=..." part. You can repeat the procedure for new 5GB.

Without algebraic_immunity function, the problem disappears.


---

Comment by asante created at 2017-05-16 16:17:43

I took a look at this issue, it is still present in sage-8.0. But it seems as this is not a problem in the algebraic_immunity function, but, inherited from the call to annihilator, a problem with pbori's BooleanPolynomialRing objects. The memory leak can be reproduced by


```
from sage.rings.polynomial.pbori import BooleanPolynomialRing
s=[BooleanPolynomialRing(8, 'x') for _ in xrange(100)]
```


and repeating the last line.

I skimmed over the PolyBoRi wrapper code, but I have no idea about cython and how this wrapping works in sage, so I'm a bit lost here :) Maybe someone else has a idea, what to do here.

Should this ticket be somehow changed? Closed as the problem is somewhere else, or how to proceed?


---

Comment by nbruin created at 2017-05-16 19:02:58

The leak actually already exists on python level:

```

import gc
from collections import Counter
gc.collect()
pre={id(c) for c in gc.get_objects()}
from sage.rings.polynomial.pbori import BooleanPolynomialRing
for i in range(100):
    P=BooleanPolynomialRing(8, 'x')
    del P
gc.collect()
post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
sorted(post.iteritems(),key=lambda t: t[1])
```

shows that the sage python-level polynomial rings remain in memory.
Looking at the backreferences graph:

```
objgraph.show_backrefs((a for a in gc.get_objects() if type(a) is sage.rings.polynomial.pbori.BooleanPolynomialRing).next(),filename="g.png",max_depth=6)
```


You can see there is a circular reference between 
`sage.rings.polynomial.pbori.BooleanMonomialMonoid` and
`sage.rings.polynomial.pbori.BooleanPolynomialRing`. Furthermore, the polynomial ring is a construction parameter for the monoid. This puts a strong reference to the polynomial ring in the `CachedRepresentation` cache, so the cycle is kept alive.

The simple solution is to not make `BooleanMonomialMonoid` to be UniqueRepresentation. It probably doesn't need to be. If that's not an option, then `BooleanPolynomialRing` isn't allowed to store any references to the `BooleanMonomialMonoid` (after all, it can look it up in the `CachedRepresentation` cache ...)

This is a classic memory leak that keeps happening over and over.

(it could still be that pbori leaks underneath as well, but the construction above can already explain exploding memory use)


---

Comment by asante created at 2017-05-16 19:37:08

I tried to simple remove the inheritance of UniqueRepresentation:

```
diff --git a/src/sage/rings/polynomial/pbori.pyx b/src/sage/rings/polynomial/pbori.pyx
index 812f3b9..b6b761a 100644
--- a/src/sage/rings/polynomial/pbori.pyx
+++ b/src/sage/rings/polynomial/pbori.pyx
`@``@` -1835,7 +1835,7 `@``@` def get_var_mapping(ring, other):
     return var_mapping
 
 
-class BooleanMonomialMonoid(UniqueRepresentation,Monoid_class):
+class BooleanMonomialMonoid(Monoid_class):
     """
     Construct a boolean monomial monoid given a boolean polynomial
     ring.
```

but this does not seem to solve the problem for me (ie. it still leaks).

Interestingly, there seems to be no leak, when not importing BooleanPolynomialRing from pbori before. I guess it then calls the constructor from `sage/rings/polynomial/polynomial_ring_constructor.py`

Calling this constructor in annihilator also seems to solve the memory leak in the boolean_functions module.


---

Comment by nbruin created at 2017-05-16 20:55:59

That sounds like a reasonable hack for the immediate problem. It looks like `pbori.BooleanPolynomialRing` isn't UniqueRepresentation by itself, so calling the factory function is definitely the way to go.

Your tests suggest there needs to be more work if we actually want to solve the underlying leak (there are more polynomial rings that leak: anything that has to do with libsingular has eternal life too). With using the appropriate factory function, you will see that

```
for i in range(10000):
    R=BooleanPolynomialRing(8,"x%s"%i)
```

still leaks.


---

Comment by asante created at 2017-05-16 21:03:37

Changing assignee from mvngu to asante.


---

Comment by git created at 2017-05-16 21:05:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by asante created at 2017-05-16 21:09:39

Changing status from new to needs_review.


---

Comment by asante created at 2017-05-16 21:11:33

Changing keywords from "algebraic_immunity, BooleanFunction" to "algebraic_immunity, BooleanFunction, memory leak".


---

Comment by nbruin created at 2017-05-17 13:23:17

There is some related discussion on #21892. Apparently `UniqueRepresentation` is there because of a pickling problem and possibly we can do away with BooleanPolynomialRing.

One solution is to close this ticket by merging the branch here and leave #21892 open for resolving the underlying problem.


---

Comment by malb created at 2017-07-28 16:13:09

Looks good to me.


---

Comment by malb created at 2017-07-28 16:13:09

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-07-31 20:18:05

Resolution: fixed
