# Issue 14345: Memory leak in algebraic_immunity of BooleanFunction class

archive/issues_014345.json:
```json
{
    "body": "Assignee: mvngu\n\nKeywords: algebraic_immunity, BooleanFunction\n\nOn my Mac OS X 10.8.3 the code\n\n\n```\nfrom sage.crypto.boolean_function import BooleanFunction\ns=[BooleanFunction(random_vector(GF(2),16).list()).algebraic_immunity() for g in xrange(100)]\ns=[BooleanFunction(random_vector(GF(2),16).list()).algebraic_immunity() for g in xrange(100)]\n```\n\ntakes around 5GB of RAM on each \"s=...\" part. You can repeat the procedure for new 5GB.\n\nWithout algebraic_immunity function, the problem disappears.\n\nIssue created by migration from https://trac.sagemath.org/ticket/14549\n\n",
    "created_at": "2013-05-07T22:44:13Z",
    "labels": [
        "cryptography",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Memory leak in algebraic_immunity of BooleanFunction class",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14345",
    "user": "okazymyrov"
}
```
Assignee: mvngu

Keywords: algebraic_immunity, BooleanFunction

On my Mac OS X 10.8.3 the code


```
from sage.crypto.boolean_function import BooleanFunction
s=[BooleanFunction(random_vector(GF(2),16).list()).algebraic_immunity() for g in xrange(100)]
s=[BooleanFunction(random_vector(GF(2),16).list()).algebraic_immunity() for g in xrange(100)]
```

takes around 5GB of RAM on each "s=..." part. You can repeat the procedure for new 5GB.

Without algebraic_immunity function, the problem disappears.

Issue created by migration from https://trac.sagemath.org/ticket/14549





---

archive/issue_comments_181203.json:
```json
{
    "body": "I took a look at this issue, it is still present in sage-8.0. But it seems as this is not a problem in the algebraic_immunity function, but, inherited from the call to annihilator, a problem with pbori's BooleanPolynomialRing objects. The memory leak can be reproduced by\n\n\n```\nfrom sage.rings.polynomial.pbori import BooleanPolynomialRing\ns=[BooleanPolynomialRing(8, 'x') for _ in xrange(100)]\n```\n\n\nand repeating the last line.\n\nI skimmed over the PolyBoRi wrapper code, but I have no idea about cython and how this wrapping works in sage, so I'm a bit lost here :) Maybe someone else has a idea, what to do here.\n\nShould this ticket be somehow changed? Closed as the problem is somewhere else, or how to proceed?",
    "created_at": "2017-05-16T16:17:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181203",
    "user": "@pfasante"
}
```

I took a look at this issue, it is still present in sage-8.0. But it seems as this is not a problem in the algebraic_immunity function, but, inherited from the call to annihilator, a problem with pbori's BooleanPolynomialRing objects. The memory leak can be reproduced by


```
from sage.rings.polynomial.pbori import BooleanPolynomialRing
s=[BooleanPolynomialRing(8, 'x') for _ in xrange(100)]
```


and repeating the last line.

I skimmed over the PolyBoRi wrapper code, but I have no idea about cython and how this wrapping works in sage, so I'm a bit lost here :) Maybe someone else has a idea, what to do here.

Should this ticket be somehow changed? Closed as the problem is somewhere else, or how to proceed?



---

archive/issue_comments_181204.json:
```json
{
    "body": "The leak actually already exists on python level:\n\n```\n\nimport gc\nfrom collections import Counter\ngc.collect()\npre={id(c) for c in gc.get_objects()}\nfrom sage.rings.polynomial.pbori import BooleanPolynomialRing\nfor i in range(100):\n    P=BooleanPolynomialRing(8, 'x')\n    del P\ngc.collect()\npost=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\nsorted(post.iteritems(),key=lambda t: t[1])\n```\n\nshows that the sage python-level polynomial rings remain in memory.\nLooking at the backreferences graph:\n\n```\nobjgraph.show_backrefs((a for a in gc.get_objects() if type(a) is sage.rings.polynomial.pbori.BooleanPolynomialRing).next(),filename=\"g.png\",max_depth=6)\n```\n\n\nYou can see there is a circular reference between \n`sage.rings.polynomial.pbori.BooleanMonomialMonoid` and\n`sage.rings.polynomial.pbori.BooleanPolynomialRing`. Furthermore, the polynomial ring is a construction parameter for the monoid. This puts a strong reference to the polynomial ring in the `CachedRepresentation` cache, so the cycle is kept alive.\n\nThe simple solution is to not make `BooleanMonomialMonoid` to be UniqueRepresentation. It probably doesn't need to be. If that's not an option, then `BooleanPolynomialRing` isn't allowed to store any references to the `BooleanMonomialMonoid` (after all, it can look it up in the `CachedRepresentation` cache ...)\n\nThis is a classic memory leak that keeps happening over and over.\n\n(it could still be that pbori leaks underneath as well, but the construction above can already explain exploding memory use)",
    "created_at": "2017-05-16T19:02:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181204",
    "user": "@nbruin"
}
```

The leak actually already exists on python level:

```

import gc
from collections import Counter
gc.collect()
pre={id(c) for c in gc.get_objects()}
from sage.rings.polynomial.pbori import BooleanPolynomialRing
for i in range(100):
    P=BooleanPolynomialRing(8, 'x')
    del P
gc.collect()
post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
sorted(post.iteritems(),key=lambda t: t[1])
```

shows that the sage python-level polynomial rings remain in memory.
Looking at the backreferences graph:

```
objgraph.show_backrefs((a for a in gc.get_objects() if type(a) is sage.rings.polynomial.pbori.BooleanPolynomialRing).next(),filename="g.png",max_depth=6)
```


You can see there is a circular reference between 
`sage.rings.polynomial.pbori.BooleanMonomialMonoid` and
`sage.rings.polynomial.pbori.BooleanPolynomialRing`. Furthermore, the polynomial ring is a construction parameter for the monoid. This puts a strong reference to the polynomial ring in the `CachedRepresentation` cache, so the cycle is kept alive.

The simple solution is to not make `BooleanMonomialMonoid` to be UniqueRepresentation. It probably doesn't need to be. If that's not an option, then `BooleanPolynomialRing` isn't allowed to store any references to the `BooleanMonomialMonoid` (after all, it can look it up in the `CachedRepresentation` cache ...)

This is a classic memory leak that keeps happening over and over.

(it could still be that pbori leaks underneath as well, but the construction above can already explain exploding memory use)



---

archive/issue_comments_181205.json:
```json
{
    "body": "I tried to simple remove the inheritance of UniqueRepresentation:\n\n```\ndiff --git a/src/sage/rings/polynomial/pbori.pyx b/src/sage/rings/polynomial/pbori.pyx\nindex 812f3b9..b6b761a 100644\n--- a/src/sage/rings/polynomial/pbori.pyx\n+++ b/src/sage/rings/polynomial/pbori.pyx\n@@ -1835,7 +1835,7 @@ def get_var_mapping(ring, other):\n     return var_mapping\n \n \n-class BooleanMonomialMonoid(UniqueRepresentation,Monoid_class):\n+class BooleanMonomialMonoid(Monoid_class):\n     \"\"\"\n     Construct a boolean monomial monoid given a boolean polynomial\n     ring.\n```\n\nbut this does not seem to solve the problem for me (ie. it still leaks).\n\nInterestingly, there seems to be no leak, when not importing BooleanPolynomialRing from pbori before. I guess it then calls the constructor from `sage/rings/polynomial/polynomial_ring_constructor.py`\n\nCalling this constructor in annihilator also seems to solve the memory leak in the boolean_functions module.",
    "created_at": "2017-05-16T19:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181205",
    "user": "@pfasante"
}
```

I tried to simple remove the inheritance of UniqueRepresentation:

```
diff --git a/src/sage/rings/polynomial/pbori.pyx b/src/sage/rings/polynomial/pbori.pyx
index 812f3b9..b6b761a 100644
--- a/src/sage/rings/polynomial/pbori.pyx
+++ b/src/sage/rings/polynomial/pbori.pyx
@@ -1835,7 +1835,7 @@ def get_var_mapping(ring, other):
     return var_mapping
 
 
-class BooleanMonomialMonoid(UniqueRepresentation,Monoid_class):
+class BooleanMonomialMonoid(Monoid_class):
     """
     Construct a boolean monomial monoid given a boolean polynomial
     ring.
```

but this does not seem to solve the problem for me (ie. it still leaks).

Interestingly, there seems to be no leak, when not importing BooleanPolynomialRing from pbori before. I guess it then calls the constructor from `sage/rings/polynomial/polynomial_ring_constructor.py`

Calling this constructor in annihilator also seems to solve the memory leak in the boolean_functions module.



---

archive/issue_comments_181206.json:
```json
{
    "body": "That sounds like a reasonable hack for the immediate problem. It looks like `pbori.BooleanPolynomialRing` isn't UniqueRepresentation by itself, so calling the factory function is definitely the way to go.\n\nYour tests suggest there needs to be more work if we actually want to solve the underlying leak (there are more polynomial rings that leak: anything that has to do with libsingular has eternal life too). With using the appropriate factory function, you will see that\n\n```\nfor i in range(10000):\n    R=BooleanPolynomialRing(8,\"x%s\"%i)\n```\n\nstill leaks.",
    "created_at": "2017-05-16T20:55:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181206",
    "user": "@nbruin"
}
```

That sounds like a reasonable hack for the immediate problem. It looks like `pbori.BooleanPolynomialRing` isn't UniqueRepresentation by itself, so calling the factory function is definitely the way to go.

Your tests suggest there needs to be more work if we actually want to solve the underlying leak (there are more polynomial rings that leak: anything that has to do with libsingular has eternal life too). With using the appropriate factory function, you will see that

```
for i in range(10000):
    R=BooleanPolynomialRing(8,"x%s"%i)
```

still leaks.



---

archive/issue_comments_181207.json:
```json
{
    "body": "Changing assignee from mvngu to @pfasante.",
    "created_at": "2017-05-16T21:03:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181207",
    "user": "@pfasante"
}
```

Changing assignee from mvngu to @pfasante.



---

archive/issue_comments_181208.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-05-16T21:05:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181208",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_181209.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-05-16T21:09:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181209",
    "user": "@pfasante"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_181210.json:
```json
{
    "body": "Changing keywords from \"algebraic_immunity, BooleanFunction\" to \"algebraic_immunity, BooleanFunction, memory leak\".",
    "created_at": "2017-05-16T21:11:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181210",
    "user": "@pfasante"
}
```

Changing keywords from "algebraic_immunity, BooleanFunction" to "algebraic_immunity, BooleanFunction, memory leak".



---

archive/issue_comments_181211.json:
```json
{
    "body": "There is some related discussion on #21892. Apparently `UniqueRepresentation` is there because of a pickling problem and possibly we can do away with BooleanPolynomialRing.\n\nOne solution is to close this ticket by merging the branch here and leave #21892 open for resolving the underlying problem.",
    "created_at": "2017-05-17T13:23:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181211",
    "user": "@nbruin"
}
```

There is some related discussion on #21892. Apparently `UniqueRepresentation` is there because of a pickling problem and possibly we can do away with BooleanPolynomialRing.

One solution is to close this ticket by merging the branch here and leave #21892 open for resolving the underlying problem.



---

archive/issue_comments_181212.json:
```json
{
    "body": "Looks good to me.",
    "created_at": "2017-07-28T16:13:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181212",
    "user": "@malb"
}
```

Looks good to me.



---

archive/issue_comments_181213.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-07-28T16:13:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181213",
    "user": "@malb"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_181214.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-07-31T20:18:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14345",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14345#issuecomment-181214",
    "user": "@vbraun"
}
```

Resolution: fixed
