# Issue 20327: KleshchevPartitions

Issue created by migration from https://trac.sagemath.org/ticket/20564

Original creator: andrew.mathas

Original creation time: 2016-05-06 01:36:13

CC:  tscrim




---

Comment by andrew.mathas created at 2016-05-06 05:10:29

Set assignee to andrew.mathas.


---

Comment by andrew.mathas created at 2016-05-06 05:10:29

Changing keywords from "" to "Kleshchev partition tuples".


---

Comment by andrew.mathas created at 2016-05-06 05:10:29

New commits:


---

Comment by andrew.mathas created at 2016-05-06 05:10:29

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by andrew.mathas created at 2016-05-06 05:10:29

Changing type from PLEASE CHANGE to enhancement.


---

Comment by git created at 2016-05-16 07:26:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-05-16 08:08:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2016-05-16 08:10:10

[ This is a dud comment that appeared when I pushed to trac while I editting the ticket description. ]


---

Comment by tscrim created at 2016-05-16 14:27:20

There are also duplicates in the `"down"` iteration. For this, I think we should just use the crystal iteration from #15584, which seems to match. Do you agree?


---

Comment by tscrim created at 2016-05-16 14:35:44

Also, I don't understand the comment in the `KleshchevPartitions_size.__init__`. I think the case for `e=0` is handled by `IntegerModRing` correctly:

```
sage: IntegerModRing(0)
Integer Ring
```

and the multicharge would be correct. Or am I missing something elsewhere?


---

Comment by git created at 2016-05-16 23:16:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2016-05-16 23:24:42

Replying to [comment:9 tscrim]:
> There are also duplicates in the `"down"` iteration. For this, I think we should just use the crystal iteration from #15584, which seems to match. Do you agree?

Great. I noticed that I had too many tuples yesterday but didn't have time to investigate. I thought that I just needed to add the direction to the calls to the good nodes routines in order to get the labelling that you are using but, in addition, I should have changed `cell<=c` to `cell>=c`. With this fix to the code our labellings agree. I also separated the four different iterations (for up/down and level 1/higher levels) into their own methods.

With these changes in place the timing for my code are:

```
sage: %timeit KleshchevPartitions(5,[3,2,1],3)[:]
100 loops, best of 3: 6.44 ms per loop
sage: %timeit KleshchevPartitions(5,[3,2,1],3, direction="down")[:]
100 loops, best of 3: 6.62 ms per loop
```

Mind you I am not sure how meaningful this is as there is probably some caching going on with `UniqueRepresentation`. Not sure how to compare with your code as I couldn't produce any timings for it (sage complained with a `TypeError`...).


---

Comment by andrew.mathas created at 2016-05-16 23:25:55

Replying to [comment:10 tscrim]:
> Also, I don't understand the comment in the `KleshchevPartitions_size.__init__`. I think the case for `e=0` is handled by `IntegerModRing` correctly:
> {{{
> sage: IntegerModRing(0)
> Integer Ring
> }}}
> and the multicharge would be correct. Or am I missing something elsewhere?

I agree. I think that this was an old and redundant comment: initially I was using lists to keep track of residues and then I changed to using a dictionary. I have deleted it.


---

Comment by tscrim created at 2016-05-27 13:16:55

I've done the first round of fusing the two implementations, and with your version of (co)normal/good cells, I was not getting a crystal structure. I changed things around so that they matched Kleshchev's article for the definition of (co)normal/good. Please check that you agree with them. I haven't updated the doctests yet so tests do not pass (and there's still more documentation to add/fix).

I still need to define a similar crystal structure for the level 1 partition tuples. I'm debating whether to use the current setup or to have it delegate to `e`-regular partitions (and implement a parent for `e`-restricted partitions). Any preferences?
----
New commits:


---

Comment by andrew.mathas created at 2016-05-28 01:37:36

Thanks for this Travis!

Replying to [comment:16 tscrim]:
> I've done the first round of fusing the two implementations, and with your version of (co)normal/good cells, I was not getting a crystal structure. I changed things around so that they matched Kleshchev's article for the definition of (co)normal/good. Please check that you agree with them. I haven't updated the doctests yet so tests do not pass (and there's still more documentation to add/fix).
> 
Was the crystal structure wrong for both the good and cogood methods? I would not be surprised if the cogood structure was wrong but I would have thought that the good nodes were right as this is what I are about more...anyway, thanks for fixing it.

> I still need to define a similar crystal structure for the level 1 partition tuples. I'm debating whether to use the current setup or to have it delegate to `e`-regular partitions (and implement a parent for `e`-restricted partitions). Any preferences?

Of course the way that I had it there was a single parent that had partitions in level one and partition tuples in higher levels. I can accept if you ant to move away from this. The good nodes methods etc also exist in level one but there is of course a much more efficient way to generate these partitions. As there is a more efficient way to generate the restricted/regular partitions it makes sense to have a separate parent for them. On the other hand, in the code that I pushed I had one parent for all levels and instead made `__iter__` depend on the level. Mathematically, it makes more sense, I think, to have one parent but the implementation differences between partitions and 1-tulpes of partitions needs to be taken into account somewhere. Given my bias I am happy for some one more objective to make this decision.

The second issue, which is probably already addressed in your changes is whether we should implement both the the "restricted" and "regular" versions. This is partly a question of taste and conveniences: the restricted variants are more commonly used in the literature for the cyclotomic Hecke algebras but the regular versions seem more common in the crystal world.


---

Comment by tscrim created at 2016-05-28 08:01:59

Replying to [comment:17 andrew.mathas]:
> Thanks for this Travis!

Thank you for your work.

> Replying to [comment:16 tscrim]:
> > I've done the first round of fusing the two implementations, and with your version of (co)normal/good cells, I was not getting a crystal structure. I changed things around so that they matched Kleshchev's article for the definition of (co)normal/good. Please check that you agree with them. I haven't updated the doctests yet so tests do not pass (and there's still more documentation to add/fix).
> > 
> Was the crystal structure wrong for both the good and cogood methods? I would not be surprised if the cogood structure was wrong but I would have thought that the good nodes were right as this is what I are about more...anyway, thanks for fixing it.

Yes, they were, at least according to Kleshchev and how things were ordered, but the normal cells were computed correctly (although I had to flip one of the directions, and I did so to match Kleshchev).

> > I still need to define a similar crystal structure for the level 1 partition tuples. I'm debating whether to use the current setup or to have it delegate to `e`-regular partitions (and implement a parent for `e`-restricted partitions). Any preferences?
> 
> Of course the way that I had it there was a single parent that had partitions in level one and partition tuples in higher levels. I can accept if you ant to move away from this. The good nodes methods etc also exist in level one but there is of course a much more efficient way to generate these partitions. As there is a more efficient way to generate the restricted/regular partitions it makes sense to have a separate parent for them.

We already have a class for regular partitions, and essentially we have a class for restricted partitions (which is easy enough to "resurrect").

> On the other hand, in the code that I pushed I had one parent for all levels and instead made `__iter__` depend on the level. Mathematically, it makes more sense, I think, to have one parent but the implementation differences between partitions and 1-tulpes of partitions needs to be taken into account somewhere. Given my bias I am happy for some one more objective to make this decision.

I liked the fact that everything was tied to one parent called `KleshchevPartitions`, but I think it is better to utilize the separate classes for the essentially distinct behaviors and to take advantage of their specializations. However, `KleshchevPartitions` would remain the global entry point, and we can use that as an indicator class by tweaking the class inheritance. I.e., any class that implements Kleshchev partitions will be a subclass of `KleshchevPartitions` (this is a common idiom in various languages (e.g.., Java) by using what are known as interfaces).

> The second issue, which is probably already addressed in your changes is whether we should implement both the the "restricted" and "regular" versions. This is partly a question of taste and conveniences: the restricted variants are more commonly used in the literature for the cyclotomic Hecke algebras but the regular versions seem more common in the crystal world.

We have both given by passing the `direction`. Although we will need to specify in the doc which direction corresponds to which type (I believe `up` is restricted and `down` is regular, but I'd need to double-check). There is also which way we order the partition tuples, which I believe corresponds to which tensor product convention we use. Do we also want to deal with that as well?


---

Comment by git created at 2016-07-15 23:44:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-07-16 04:12:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-07-16 04:24:02

I've added a basic implementation of `\ell`-restricted partitions. I've also gone through and fixed a number of other issues with the additional methods (e.g., `good_residue_sequence`). I just wanted to make sure everything looked good to you before I fixed the failing doctests. Also, do you have a good example for the Mullineux conjugate?

Additionally, I discovered that my implementation of Kleshchev partitions had the partitions ordered in reverse order (but not the rows), reflecting my usual preference to use the opposite convention of Kashiwara for tensor products. To add this, all we would need to do is basically add another input option for Kleshchev partitions, but what would we call this option? `(tensor_)convention`? Refine the `direction` to be of the form `UR`, `UL`, `DR`, `DL`?


---

Comment by andrew.mathas created at 2016-07-29 00:39:19

Hi Travis,

This is just to let you know that I am playing with this at the moment. I had fixed up/checked most of the failing doc-tests but then I decided that it would be better to make `direction` part of `Partitions.options` and I have not got the code working full yet. I am calling the option `simple_labelling` with values of `regular` and `restricted`. Let me know if you think that this is not a good idea. One complication is whether `KleshchevPartitions` should just use the current value of the option or whether it should be able to override it. I am favour of it just using the option because conjugation and friends give trivial maps between the different labellings so if someone needs both then there is an easy  way to do this.

Andrew


---

Comment by tscrim created at 2016-07-29 01:48:23

This is a not good idea because they are completely different sets. However, since you think there is a use-case and it is easy, we should probably implement coercion (or just conversion because of the crystal structure?) maps between them.

Edit - Missing an important word: 'not' :P


---

Comment by andrew.mathas created at 2016-07-29 05:22:46

Replying to [tscrim] (form email correspondence, but it should be on the ticket...):
>The biggest problem I see is this:
>
> sage: P = KleshchevPartitions(3)  # direction = 'up' is the default IIRC
> sage: regular_partition = P([4,4])   # I might be backwards on which is the correct direction for this, I forget offhand
> sage: regular_partition in P
> True
> sage: P.options.order = 'down'  # This cannot change regular_partition...
> sage: regular_partition in P   #  so this now fails
> False
>
> Granted, I agree that I don't think anyone will really do this except by accidentally forgetting to set it beforehand, but it can cause subtle bugs (e.g., the multiplication convention for permutations option).
This possibility had occurred to me but I thought to ignore it. What do you think of having simple_labelling as an option but making it possible to over ride this when calling KleshchevPartitions and then hard-wiring the choice into the class. So I am thinking:

    sage: KleshchevPartitions(3)
    regular Kleshchev partitions with e=3
    sage: KleshchevPartitions(3, labelling='restricted')
    restricted Kleshchev partitions with e=3

My main aim was to get rid of the need to specify the convention in all of the (co)good, (co)normal, mullineux_map, ... methods You are likely to object to my removing the direction from these as well as with my current of the code the only way to get the previous functionality is with a kludge like:

    simple_labelling = Partitions.options.simple_labelling
    Partitions.options.simple_labelling='restricted'
    mu.good_nodes(3)
    Partitions.options.simple_labelling = simple_labelling

I thought about giving GlobalOptions a context manager to make it possible to instead write

    with Partitions.options.simple_labelling:

        Partitions.options.simple_labelling='restricted'
        mu.good_nodes(3)

but I am not sure if this is a good idea...

Btw, with the default "direction" (simple_labelling is more meaningful I think), it used to be "down" but during the code revisions it seems to have changed to "up" in some places but not others (in particular the documentation). My preference for "restricted Kleshchev's" but I am not really fussed. What would you like to me to make it?


---

Comment by tscrim created at 2016-07-30 15:11:43

I feel it is too easy to break things (likely in subtle ways) with a global option. I certainly can understand the reason why you want to get rid of the convention. Well, perhaps a middle ground solution would be to add it as a global option as a default for the convention, where if the convention is not specified, it would go to the global option. For example:

```sage
def foo(self, direction=None):
    if direction is None:
        direction = self.parent().global_option.direction
    return direction
```

The other option would be to explicitly tie it to the parent. Oh, here's an much better idea:

```sage
def foo(self):
    try:
        direction = self.parent()._direction
    except AttributeError:
        direction = self.parent().global_option.direction
    return direction
```

That way we wouldn't have to move the methods away from the general partition (tuples) class. We get a global option for general parents, but for parents which depend on the direction (i.e., `KleshchevPartitions`), it avoids the global option altogether and becomes an implementation detail.

IMO, a context manager seems like complete overkill and likely would require extra boilerplate code.


---

Comment by git created at 2017-02-04 20:36:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-30 05:14:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-30 08:30:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2018-04-30 09:52:33

`EXAMPLE::` should be `EXAMPLES::`


---

Comment by git created at 2018-04-30 13:28:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 01:14:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 04:09:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 04:29:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 04:33:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 06:56:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 07:27:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 07:35:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 08:30:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-01 09:45:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-02 00:43:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-03 00:47:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2018-05-03 00:49:21

Changing status from new to needs_review.


---

Comment by andrew.mathas created at 2018-05-03 00:49:21

This is pretty much ready to go.


---

Comment by git created at 2018-05-03 01:16:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-03 01:18:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2018-05-03 01:18:52

If my changes LGTY, then positive review.


---

Comment by git created at 2018-05-03 01:22:44

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by tscrim created at 2018-05-03 01:23:12

Trivial reference conflicts with #15508.


---

Comment by git created at 2018-05-03 23:47:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2018-05-03 23:53:10

I just added a few mathscinet links to `index.rst` and corrected one reference. If you are happy with this please set to positive review.


---

Comment by tscrim created at 2018-05-03 23:53:42

LGTM. Thank you.


---

Comment by tscrim created at 2018-05-03 23:53:42

Changing status from needs_review to positive_review.


---

Comment by git created at 2018-05-11 05:09:02

Changing status from positive_review to needs_review.


---

Comment by git created at 2018-05-11 05:09:02

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by andrew.mathas created at 2018-05-11 05:10:44

The patchbot was complaining about startup timings so I have made `KleshchevPartitions` (and skew partitions and partition tuples) lazy imports -- which they should have been from the start.


---

Comment by andrew.mathas created at 2018-05-11 05:10:44

Changing status from needs_review to positive_review.


---

Comment by git created at 2018-05-11 05:28:59

Changing status from positive_review to needs_review.


---

Comment by git created at 2018-05-11 05:28:59

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by tscrim created at 2018-05-11 05:31:03

Yes, indeed they should have. Thank you for catching. I fixed a small issue with the lazy import (you forgot `.combinat`). I made the entire crystal catalog a lazy import so the import of Kleshchev partitions was not resolved that way, but this should be done anyways. Please review/check.


---

Comment by andrew.mathas created at 2018-05-11 05:44:32

Oops, thanks! Looks good.


---

Comment by andrew.mathas created at 2018-05-11 05:44:32

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-05-12 12:00:27

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2018-05-12 12:00:27

Merge conflict


---

Comment by andrew.mathas created at 2018-05-12 23:44:00

I don't see a merge conflict with 8.3.beta0-develop? I guess that we need to wait for 8.3.beta1.


---

Comment by tscrim created at 2018-05-13 00:06:21

It will be with the forthcoming 8.3.beta1, almost certainly a trivial conflict in the master reference file.


---

Comment by git created at 2018-05-14 21:35:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-05-14 23:10:10

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2018-05-18 17:04:27

Resolution: fixed
