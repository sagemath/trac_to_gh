# Issue 23485: Pool for padics

archive/issues_023485.json:
```json
{
    "body": "CC:  @roed314 @saraedum @jdemeyer\n\nKeywords: pool\n\nAs discussed on [zulip](https://zulip.sagemath.org/#narrow/stream/padics/topic/pool), we propose to implement a pool for p-adic numbers.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/23722\n\n",
    "created_at": "2017-08-25T23:24:04Z",
    "labels": [
        "component: padics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "Pool for padics",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23485",
    "user": "https://github.com/xcaruso"
}
```
CC:  @roed314 @saraedum @jdemeyer

Keywords: pool

As discussed on [zulip](https://zulip.sagemath.org/#narrow/stream/padics/topic/pool), we propose to implement a pool for p-adic numbers.


Issue created by migration from https://trac.sagemath.org/ticket/23722





---

archive/issue_comments_328745.json:
```json
{
    "body": "I attach a first rough implementation that works only for CR elements.\n\nThe speed up is about 50% (= 2 times faster) for `Zp(p)` when p is small.\n----\nNew commits:",
    "created_at": "2017-08-25T23:27:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328745",
    "user": "https://github.com/xcaruso"
}
```

I attach a first rough implementation that works only for CR elements.

The speed up is about 50% (= 2 times faster) for `Zp(p)` when p is small.
----
New commits:



---

archive/issue_comments_328746.json:
```json
{
    "body": "1. If you intend to have such an option then the code would better be shared with `Integer`.\n\n2. The most convenient by far would be to extend [`@`freelib Cython decorator](http://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#fast-instantiation). Typically we might want to use it for most basic rings.",
    "created_at": "2017-08-26T03:08:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328746",
    "user": "https://github.com/videlec"
}
```

1. If you intend to have such an option then the code would better be shared with `Integer`.

2. The most convenient by far would be to extend [`@`freelib Cython decorator](http://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#fast-instantiation). Typically we might want to use it for most basic rings.



---

archive/issue_comments_328747.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-26T05:05:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328747",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_328748.json:
```json
{
    "body": "Replying to [comment:3 vdelecroix]:\n> 1. If you intend to have such an option then the code would better be shared with `Integer`.\nProbably. But the pool for `Integer` has additional optimizations.\nMoreover, it uses global variables (instead of classes) and is then faster.\n\n> 2. The most convenient by far would be to extend [`@`freelib Cython decorator](http://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#fast-instantiation). \nWell, in my implementation, the parent plays some role (we have access to the pool through the parent and may enable/disable the pool for different parents using the same element class). It seems to be difficult to introduce these features in the ``@`freelib` decorator since parents are typical to sage.\n\n> Typically we might want to use it for most basic rings.\nIndeed. For now, I'm just testing this for padics but it works well.",
    "created_at": "2017-08-26T05:13:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328748",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:3 vdelecroix]:
> 1. If you intend to have such an option then the code would better be shared with `Integer`.
Probably. But the pool for `Integer` has additional optimizations.
Moreover, it uses global variables (instead of classes) and is then faster.

> 2. The most convenient by far would be to extend [`@`freelib Cython decorator](http://cython.readthedocs.io/en/latest/src/userguide/extension_types.html#fast-instantiation). 
Well, in my implementation, the parent plays some role (we have access to the pool through the parent and may enable/disable the pool for different parents using the same element class). It seems to be difficult to introduce these features in the ``@`freelib` decorator since parents are typical to sage.

> Typically we might want to use it for most basic rings.
Indeed. For now, I'm just testing this for padics but it works well.



---

archive/issue_comments_328749.json:
```json
{
    "body": "I justed posted a message on Cython mailing list https://groups.google.com/forum/#!topic/cython-users/Uh4JCzDdIsQ",
    "created_at": "2017-08-27T15:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328749",
    "user": "https://github.com/videlec"
}
```

I justed posted a message on Cython mailing list https://groups.google.com/forum/#!topic/cython-users/Uh4JCzDdIsQ



---

archive/issue_comments_328750.json:
```json
{
    "body": "Very nice!\n\nSome thoughts:\n\n* We should probably wait a bit to see if anyone responds on the Cython list.  If they are going to implement such a pool, great; otherwise I definitely think this is a feature worth having in Sage.\n* As you pointed out on Zulip, `self.prime_pow` isn't set during `__cinit__`.  Since it's not used in any of the current linkage files, I think it's fine removing it from the call.  If we implement a linkage where it's needed, we can rethink the process with that example in mind.\n* I like your mechanism for allowing the enabling and disabling of pools at the level of individual parents.  Presumably we'll eventually have heuristics for when pools should be enabled (depending on `p` and `prec_cap`).\n* I'm not completely sure about the reference counting code you've used (though I don't have any particular flaws in mind). We should make sure to test for memory leaks somehow.\n* At what level should we add a Pool?  I'm hesitant to add it to Parent (because there is a memory cost), but there isn't another obvious place. Perhaps we should raise this on sage-devel once the code on this ticket has progressed a bit?\n\nGreat work Xavier!",
    "created_at": "2017-08-28T07:39:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328750",
    "user": "https://github.com/roed314"
}
```

Very nice!

Some thoughts:

* We should probably wait a bit to see if anyone responds on the Cython list.  If they are going to implement such a pool, great; otherwise I definitely think this is a feature worth having in Sage.
* As you pointed out on Zulip, `self.prime_pow` isn't set during `__cinit__`.  Since it's not used in any of the current linkage files, I think it's fine removing it from the call.  If we implement a linkage where it's needed, we can rethink the process with that example in mind.
* I like your mechanism for allowing the enabling and disabling of pools at the level of individual parents.  Presumably we'll eventually have heuristics for when pools should be enabled (depending on `p` and `prec_cap`).
* I'm not completely sure about the reference counting code you've used (though I don't have any particular flaws in mind). We should make sure to test for memory leaks somehow.
* At what level should we add a Pool?  I'm hesitant to add it to Parent (because there is a memory cost), but there isn't another obvious place. Perhaps we should raise this on sage-devel once the code on this ticket has progressed a bit?

Great work Xavier!



---

archive/issue_comments_328751.json:
```json
{
    "body": "Replying to [comment:3 vdelecroix]:\n> 1. If you intend to have such an option then the code would better be shared with `Integer`.\n\nAbsolutely! This should **not** be specific to p-adics.",
    "created_at": "2017-08-28T10:35:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328751",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:3 vdelecroix]:
> 1. If you intend to have such an option then the code would better be shared with `Integer`.

Absolutely! This should **not** be specific to p-adics.



---

archive/issue_comments_328752.json:
```json
{
    "body": "Also, it would be good to have a short write-up of what exactly this does (the current branch doesn't have much documentation) before continuing the discussion.",
    "created_at": "2017-08-28T10:39:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328752",
    "user": "https://github.com/jdemeyer"
}
```

Also, it would be good to have a short write-up of what exactly this does (the current branch doesn't have much documentation) before continuing the discussion.



---

archive/issue_comments_328753.json:
```json
{
    "body": "See also #17670 which I created a long time ago but never did anything with.",
    "created_at": "2017-08-28T10:42:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328753",
    "user": "https://github.com/jdemeyer"
}
```

See also #17670 which I created a long time ago but never did anything with.



---

archive/issue_comments_328754.json:
```json
{
    "body": "Replying to [comment:7 roed]:\n> Very nice!\n\nThanks :-)\n\n> * We should probably wait a bit to see if anyone responds on the Cython list.  If they are going to implement such a pool, great; otherwise I definitely think this is a feature worth having in Sage.\n\nSure.\nBut as I mentioned above, my implementation is based on the parent (which is typical to Sage).\n\n> * As you pointed out on Zulip, `self.prime_pow` isn't set during `__cinit__`.  Since it's not used in any of the current linkage files, I think it's fine removing it from the call.  If we implement a linkage where it's needed, we can rethink the process with that example in mind.\n\nIf `self.prime_pow` is needed in this initialization, I think that we should seriously consider the option to have a pool for each parent.\n\nI actually think that this could be an option in any case. Concretely `pool_enable` could take an attribute `global`; if it set to true, then the pool is shared with all other parents using the same type; otherwise, it is local to the parent. And the default could be `True`.\n\n> * I like your mechanism for allowing the enabling and disabling of pools at the level of individual parents.  Presumably we'll eventually have heuristics for when pools should be enabled (depending on `p` and `prec_cap`).\n\nYes.\n\n> * I'm not completely sure about the reference counting code you've used (though I don't have any particular flaws in mind). We should make sure to test for memory leaks somehow.\n\nReference counting should be fine (hopefully).\nThe line `o.ob_refcnt = 1` in the de-allocation prevents the object to be collected again and again.\nThe line `o.ob_refcnt = 0` in the allocation is needed because the reference counting is incremented just after.\n\n> * At what level should we add a Pool?  I'm hesitant to add it to Parent (because there is a memory cost), but there isn't another obvious place. Perhaps we should raise this on sage-devel once the code on this ticket has progressed a bit?\n\nOne possible solution: we create a new class `ParentWithPool` (inheriting from `Parent`) and let the parents that wants to implement a pool derive from this class. This won't affect other parents (and then will limit the number of bugs).",
    "created_at": "2017-08-28T14:21:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328754",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:7 roed]:
> Very nice!

Thanks :-)

> * We should probably wait a bit to see if anyone responds on the Cython list.  If they are going to implement such a pool, great; otherwise I definitely think this is a feature worth having in Sage.

Sure.
But as I mentioned above, my implementation is based on the parent (which is typical to Sage).

> * As you pointed out on Zulip, `self.prime_pow` isn't set during `__cinit__`.  Since it's not used in any of the current linkage files, I think it's fine removing it from the call.  If we implement a linkage where it's needed, we can rethink the process with that example in mind.

If `self.prime_pow` is needed in this initialization, I think that we should seriously consider the option to have a pool for each parent.

I actually think that this could be an option in any case. Concretely `pool_enable` could take an attribute `global`; if it set to true, then the pool is shared with all other parents using the same type; otherwise, it is local to the parent. And the default could be `True`.

> * I like your mechanism for allowing the enabling and disabling of pools at the level of individual parents.  Presumably we'll eventually have heuristics for when pools should be enabled (depending on `p` and `prec_cap`).

Yes.

> * I'm not completely sure about the reference counting code you've used (though I don't have any particular flaws in mind). We should make sure to test for memory leaks somehow.

Reference counting should be fine (hopefully).
The line `o.ob_refcnt = 1` in the de-allocation prevents the object to be collected again and again.
The line `o.ob_refcnt = 0` in the allocation is needed because the reference counting is incremented just after.

> * At what level should we add a Pool?  I'm hesitant to add it to Parent (because there is a memory cost), but there isn't another obvious place. Perhaps we should raise this on sage-devel once the code on this ticket has progressed a bit?

One possible solution: we create a new class `ParentWithPool` (inheriting from `Parent`) and let the parents that wants to implement a pool derive from this class. This won't affect other parents (and then will limit the number of bugs).



---

archive/issue_comments_328755.json:
```json
{
    "body": "Replying to [comment:10 jdemeyer]:\n> See also #17670 which I created a long time ago but never did anything with.\nOh, I've always thought that overriding `__dealloc__` doesn't prevent the actual deallocation of memory but just allows the user to free properly extra allocated memory (just like a C destructor). Am I mistaken?",
    "created_at": "2017-08-28T14:23:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328755",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:10 jdemeyer]:
> See also #17670 which I created a long time ago but never did anything with.
Oh, I've always thought that overriding `__dealloc__` doesn't prevent the actual deallocation of memory but just allows the user to free properly extra allocated memory (just like a C destructor). Am I mistaken?



---

archive/issue_comments_328756.json:
```json
{
    "body": "Replying to [comment:5 caruso]:\n> Well, in my implementation, the parent plays some role\n\nI'm not convinced that it should. Ideally, the implementation should be as generic as possible, so the parent should not be involved.",
    "created_at": "2017-08-28T14:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328756",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:5 caruso]:
> Well, in my implementation, the parent plays some role

I'm not convinced that it should. Ideally, the implementation should be as generic as possible, so the parent should not be involved.



---

archive/issue_comments_328757.json:
```json
{
    "body": "Replying to [comment:12 caruso]:\n> Oh, I've always thought that overriding `__dealloc__` doesn't prevent the actual deallocation of memory but just allow the user to free properly extra allocated memory (just like a C destructor). Am I mistaken?\n\nI think you are right. Like I said, I wrote #17670 a long time ago and I'm not claiming that the ticket description of #17670 is correct.",
    "created_at": "2017-08-28T14:28:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328757",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:12 caruso]:
> Oh, I've always thought that overriding `__dealloc__` doesn't prevent the actual deallocation of memory but just allow the user to free properly extra allocated memory (just like a C destructor). Am I mistaken?

I think you are right. Like I said, I wrote #17670 a long time ago and I'm not claiming that the ticket description of #17670 is correct.



---

archive/issue_comments_328758.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-28T18:45:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328758",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_328759.json:
```json
{
    "body": "The documentation and changes help.  Here are some comments.\n\n* I think that in Cython `<long?>` is not necessary, since long isn't a pointer.  The problem occurs when you ask Cython to interpret a pointer to one extension type as a pointer to another, and then get invalid memory references.\n* You added a `_pool` attribute to `LocalGenericElement`.  Was this accidental?  Aren't pools supposed to be stored on the parent?\n* There are various typos in the documentation; I'll fix the ones I notice.",
    "created_at": "2017-08-28T19:12:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328759",
    "user": "https://github.com/roed314"
}
```

The documentation and changes help.  Here are some comments.

* I think that in Cython `<long?>` is not necessary, since long isn't a pointer.  The problem occurs when you ask Cython to interpret a pointer to one extension type as a pointer to another, and then get invalid memory references.
* You added a `_pool` attribute to `LocalGenericElement`.  Was this accidental?  Aren't pools supposed to be stored on the parent?
* There are various typos in the documentation; I'll fix the ones I notice.



---

archive/issue_comments_328760.json:
```json
{
    "body": "Replying to [comment:13 jdemeyer]:\n> Replying to [comment:5 caruso]:\n> > Well, in my implementation, the parent plays some role\n> \n> I'm not convinced that it should. Ideally, the implementation should be as generic as possible, so the parent should not be involved.\n\nThe benefit of having the parent involved is that you can turn on the pool for `p=5` when it's useful, and off for `p=next_prime(10^400)` when it's not.\n\nIf we can make pools available upstream in Cython, I think it's worth giving up this feature.  But if we're just implementing it in Sage, I like Xavier's choice to attach it to the parent, since I don't see anything in Sage other than elements using a pool, and we do get the flexibility of varying the behavior by parent.",
    "created_at": "2017-08-28T19:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328760",
    "user": "https://github.com/roed314"
}
```

Replying to [comment:13 jdemeyer]:
> Replying to [comment:5 caruso]:
> > Well, in my implementation, the parent plays some role
> 
> I'm not convinced that it should. Ideally, the implementation should be as generic as possible, so the parent should not be involved.

The benefit of having the parent involved is that you can turn on the pool for `p=5` when it's useful, and off for `p=next_prime(10^400)` when it's not.

If we can make pools available upstream in Cython, I think it's worth giving up this feature.  But if we're just implementing it in Sage, I like Xavier's choice to attach it to the parent, since I don't see anything in Sage other than elements using a pool, and we do get the flexibility of varying the behavior by parent.



---

archive/issue_comments_328761.json:
```json
{
    "body": "Replying to [comment:17 roed]:\n> The benefit of having the parent involved is that you can turn on the pool for `p=5` when it's useful, and off for `p=next_prime(10^400)` when it's not.\n\nObvious question: why do you assume that `p` is fixed? I.e. why couldn't an element with `p=5` be stored in the pool and recycled with `p=7`?",
    "created_at": "2017-08-28T20:41:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328761",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:17 roed]:
> The benefit of having the parent involved is that you can turn on the pool for `p=5` when it's useful, and off for `p=next_prime(10^400)` when it's not.

Obvious question: why do you assume that `p` is fixed? I.e. why couldn't an element with `p=5` be stored in the pool and recycled with `p=7`?



---

archive/issue_comments_328762.json:
```json
{
    "body": "Replying to [comment:18 jdemeyer]:\n> Replying to [comment:17 roed]:\n> > The benefit of having the parent involved is that you can turn on the pool for `p=5` when it's useful, and off for `p=next_prime(10^400)` when it's not.\n> \n> Obvious question: why do you assume that `p` is fixed? I.e. why couldn't an element with `p=5` be stored in the pool and recycled with `p=7`?\n\nIt certainly can.  But for larger `p` the object creation time is not as relevant compared to arithmetic time, so the pool is less useful (and possibly not worth the memory cost).\n\nI'm not strongly attached to the ability to enable and disable the pool at the level of individual parents, but I think it does provide some benefit.",
    "created_at": "2017-08-28T21:19:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328762",
    "user": "https://github.com/roed314"
}
```

Replying to [comment:18 jdemeyer]:
> Replying to [comment:17 roed]:
> > The benefit of having the parent involved is that you can turn on the pool for `p=5` when it's useful, and off for `p=next_prime(10^400)` when it's not.
> 
> Obvious question: why do you assume that `p` is fixed? I.e. why couldn't an element with `p=5` be stored in the pool and recycled with `p=7`?

It certainly can.  But for larger `p` the object creation time is not as relevant compared to arithmetic time, so the pool is less useful (and possibly not worth the memory cost).

I'm not strongly attached to the ability to enable and disable the pool at the level of individual parents, but I think it does provide some benefit.



---

archive/issue_comments_328763.json:
```json
{
    "body": "Replying to [comment:19 roed]:\n> It certainly can.\n\nSo then, there is again no reason to get the parent involved...",
    "created_at": "2017-08-28T21:21:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328763",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:19 roed]:
> It certainly can.

So then, there is again no reason to get the parent involved...



---

archive/issue_comments_328764.json:
```json
{
    "body": "Replying to [comment:19 roed]:\n> Replying to [comment:18 jdemeyer]:\n> > Obvious question: why do you assume that `p` is fixed? I.e. why couldn't an element with `p=5` be stored in the pool and recycled with `p=7`?\n> \n> It certainly can.\n\nAnd actually it is (in my implementation): a given pool may be shared between different parents, and it's for now the default for p-adics.",
    "created_at": "2017-08-28T21:29:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328764",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:19 roed]:
> Replying to [comment:18 jdemeyer]:
> > Obvious question: why do you assume that `p` is fixed? I.e. why couldn't an element with `p=5` be stored in the pool and recycled with `p=7`?
> 
> It certainly can.

And actually it is (in my implementation): a given pool may be shared between different parents, and it's for now the default for p-adics.



---

archive/issue_comments_328765.json:
```json
{
    "body": "Replying to [comment:20 jdemeyer]:\n> Replying to [comment:19 roed]:\n> > It certainly can.\n> \n> So then, there is again no reason to get the parent involved...\n\nYes, there is because you may want, in some specific cases, to have separated pools.\n\nI agree that sharing the pool for `Zp(5)` and `Zp(7)` is certainly the right thing to do. But, on the other hand, disabling the pool for `Zp(nextprime(10^400))` makes sense as well.\n\nAlso, one can imagine other classes where the data structure corresponding to some parameters are not compatible with the data structure to other parameters (for instance, if we want to implement a p-adic number as a flint p-adic, then I guess that a 5-adic number cannot be easily recycled to a 7-adic number). For these classes, it's useful to have separated pools according to the parent.",
    "created_at": "2017-08-28T21:34:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328765",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:20 jdemeyer]:
> Replying to [comment:19 roed]:
> > It certainly can.
> 
> So then, there is again no reason to get the parent involved...

Yes, there is because you may want, in some specific cases, to have separated pools.

I agree that sharing the pool for `Zp(5)` and `Zp(7)` is certainly the right thing to do. But, on the other hand, disabling the pool for `Zp(nextprime(10^400))` makes sense as well.

Also, one can imagine other classes where the data structure corresponding to some parameters are not compatible with the data structure to other parameters (for instance, if we want to implement a p-adic number as a flint p-adic, then I guess that a 5-adic number cannot be easily recycled to a 7-adic number). For these classes, it's useful to have separated pools according to the parent.



---

archive/issue_comments_328766.json:
```json
{
    "body": "Replying to [comment:22 caruso]:\n> Also, one can imagine other classes where the data structure corresponding to some parameters are not compatible with the data structure to other parameters\n\nYes, I can \"imagine\" that. However, I feel that we should go for an implementation which is as generic as possible and which therefore would not involve something Sage-specific like a parent.",
    "created_at": "2017-08-28T21:38:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328766",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:22 caruso]:
> Also, one can imagine other classes where the data structure corresponding to some parameters are not compatible with the data structure to other parameters

Yes, I can "imagine" that. However, I feel that we should go for an implementation which is as generic as possible and which therefore would not involve something Sage-specific like a parent.



---

archive/issue_comments_328767.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-29T12:36:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328767",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_328768.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-30T07:42:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328768",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_328769.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-31T06:27:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328769",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_328770.json:
```json
{
    "body": "In case it is not clear, let me mention that I disagree with several design choices made here (storing the pool in the parent is one of them).\n\nI think that the `Integer` pool is a much better idea and I suggest to expand on that instead of reinventing a new (worse) pool implementation.",
    "created_at": "2017-08-31T07:36:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328770",
    "user": "https://github.com/jdemeyer"
}
```

In case it is not clear, let me mention that I disagree with several design choices made here (storing the pool in the parent is one of them).

I think that the `Integer` pool is a much better idea and I suggest to expand on that instead of reinventing a new (worse) pool implementation.



---

archive/issue_comments_328771.json:
```json
{
    "body": "Don't worry, I think I understood that you disagree :-).\n\nI wanted to be sure that my approach will eventually work and it's the reason why I continued working on it (and then pushed it to the ticket).\nI'm however happy to discuss design choices.\n\nBut, I'm afraid that I didn't understand well your point. \nCould you explain for instance more why you don't like storing the pool in the parent? Is it \"just\" because it's not enough cythonic? Is there something more?\n\nCould you detail more please what should be the features of a good pool (according to you)? I understand, I think, that it should be attached to a python type, it that right? Are you proposing to modify Cython and embed it in the `PyTypeObject` structure?\nBesides, do you think that the pool should be resizable or not? Should we let to the user the possibility to enable/disable it? More generally, should the pool be accessible through special methods/commands?",
    "created_at": "2017-08-31T07:55:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328771",
    "user": "https://github.com/xcaruso"
}
```

Don't worry, I think I understood that you disagree :-).

I wanted to be sure that my approach will eventually work and it's the reason why I continued working on it (and then pushed it to the ticket).
I'm however happy to discuss design choices.

But, I'm afraid that I didn't understand well your point. 
Could you explain for instance more why you don't like storing the pool in the parent? Is it "just" because it's not enough cythonic? Is there something more?

Could you detail more please what should be the features of a good pool (according to you)? I understand, I think, that it should be attached to a python type, it that right? Are you proposing to modify Cython and embed it in the `PyTypeObject` structure?
Besides, do you think that the pool should be resizable or not? Should we let to the user the possibility to enable/disable it? More generally, should the pool be accessible through special methods/commands?



---

archive/issue_comments_328772.json:
```json
{
    "body": "Replying to [comment:28 caruso]:\n> Could you detail more please what should be the features of a good pool (according to you)?\n\nThat's actually an excellent question. In decreasing order of importance, a pool should:\n\n1. Be robust (all code which currently works with the type should continue to work the same way if the type is implemented with a pool).\n\n2. Be fast.\n\n3. Be as generic as possible, i.e. work for any type.\n\n4. Not require any special code to use the pool (i.e. no `PY_NEW` or `PY_NEW_WITH_POOL`).\n\n5. Make it easy for developers to add a pool to their types.\n\n> Besides, do you think that the pool should be resizable or not? Should we let to the user the possibility to enable/disable it? More generally, should the pool be accessible through special methods/commands?\n\nFirst of all, these are details: we should first get a good design and then think about this.\n\nTo answer the question: I don't think that such features would ever be used. So, you could add them, but why? Perhaps more interesting would be to get access to some statictics, like how full is the pool, how often does it overflow/underflow...",
    "created_at": "2017-08-31T08:10:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328772",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:28 caruso]:
> Could you detail more please what should be the features of a good pool (according to you)?

That's actually an excellent question. In decreasing order of importance, a pool should:

1. Be robust (all code which currently works with the type should continue to work the same way if the type is implemented with a pool).

2. Be fast.

3. Be as generic as possible, i.e. work for any type.

4. Not require any special code to use the pool (i.e. no `PY_NEW` or `PY_NEW_WITH_POOL`).

5. Make it easy for developers to add a pool to their types.

> Besides, do you think that the pool should be resizable or not? Should we let to the user the possibility to enable/disable it? More generally, should the pool be accessible through special methods/commands?

First of all, these are details: we should first get a good design and then think about this.

To answer the question: I don't think that such features would ever be used. So, you could add them, but why? Perhaps more interesting would be to get access to some statictics, like how full is the pool, how often does it overflow/underflow...



---

archive/issue_comments_328773.json:
```json
{
    "body": "Ok.\n\nAt some point, I've also tried to conceal all these requirements but I then had to give up because I couldn't see how to achieve in pure Cython (i.e. without modifying the Cython compiler). \nIndeed, following the implementation of ``@`freelist` (i.e. custom the C code of the standard `tp_new` and `tp_dealloc` functions for each type for which a pool is enabled) clearly required to modify the Cython compiler. Another related but maybe less aggressive solution is the following: we write generic functions `tp_new_with_pool` and `tp_dealloc_with_pool` functions (and attach them to each relevant type). The issue is that this requires to store the address of the pool in some data structure attached to the type (typically the `PyTypeObject` structure) but there is no space left on this struct. So, we need to add a variable. (Another option would be to lookup in a global dictionary but I didn't consider this option because of efficiency.)\n\nMoreover, as already discussed, these brute solutions are not that fine because they do not prevent the creation/deletion of extra allocated objects (as mpz integers in the case of padics). So there would eventually require extra work. Maybe splitting `__cinit__` and `__dealloc__` into\ntwo parts as discussed here: https://groups.google.com/forum/#!topic/cython-users/Uh4JCzDdIsQ\nThen, in any case, having an efficient pool will require to adapt the implementation of the underlying elements.\n\nI'm not part of the community of Cython developers (I mean people who are developing Cython). It's the reason why I had preferred mode \"cythonic\" solutions. But if you (or someone else) think that you can come up with a working code following the previous lines in a reasonable time, it's of course fine with me.\n\nBesides, I think that the implementation I proposed (where the pool is attached to the parent) has interesting features. For padics, it's really efficient (2 times faster for `ZpCR`, 3 times faster for `ZpFM`) and cheap to have a pool when p is small. But it is not when p is large: the gain of speed is not significant (less than 1%) and the pool is greedy in memory. Thus having the possibility to enable/disable the pool according to the parent seems nice to me. Of course, the user will not do it manually but this can be done automatically at the creation of the parent based on some heuristics.\nIn the same spirit, small pools are enough when manipulating a small amounts of variables (i.e. iterating a recursive sequence) but large pools are better otherwise (e.g. manipulating large matrices for instance). So the good size of the pool depends on applications and I think it's a good idea to let to the user the possibility to play with it.",
    "created_at": "2017-09-01T07:11:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328773",
    "user": "https://github.com/xcaruso"
}
```

Ok.

At some point, I've also tried to conceal all these requirements but I then had to give up because I couldn't see how to achieve in pure Cython (i.e. without modifying the Cython compiler). 
Indeed, following the implementation of ``@`freelist` (i.e. custom the C code of the standard `tp_new` and `tp_dealloc` functions for each type for which a pool is enabled) clearly required to modify the Cython compiler. Another related but maybe less aggressive solution is the following: we write generic functions `tp_new_with_pool` and `tp_dealloc_with_pool` functions (and attach them to each relevant type). The issue is that this requires to store the address of the pool in some data structure attached to the type (typically the `PyTypeObject` structure) but there is no space left on this struct. So, we need to add a variable. (Another option would be to lookup in a global dictionary but I didn't consider this option because of efficiency.)

Moreover, as already discussed, these brute solutions are not that fine because they do not prevent the creation/deletion of extra allocated objects (as mpz integers in the case of padics). So there would eventually require extra work. Maybe splitting `__cinit__` and `__dealloc__` into
two parts as discussed here: https://groups.google.com/forum/#!topic/cython-users/Uh4JCzDdIsQ
Then, in any case, having an efficient pool will require to adapt the implementation of the underlying elements.

I'm not part of the community of Cython developers (I mean people who are developing Cython). It's the reason why I had preferred mode "cythonic" solutions. But if you (or someone else) think that you can come up with a working code following the previous lines in a reasonable time, it's of course fine with me.

Besides, I think that the implementation I proposed (where the pool is attached to the parent) has interesting features. For padics, it's really efficient (2 times faster for `ZpCR`, 3 times faster for `ZpFM`) and cheap to have a pool when p is small. But it is not when p is large: the gain of speed is not significant (less than 1%) and the pool is greedy in memory. Thus having the possibility to enable/disable the pool according to the parent seems nice to me. Of course, the user will not do it manually but this can be done automatically at the creation of the parent based on some heuristics.
In the same spirit, small pools are enough when manipulating a small amounts of variables (i.e. iterating a recursive sequence) but large pools are better otherwise (e.g. manipulating large matrices for instance). So the good size of the pool depends on applications and I think it's a good idea to let to the user the possibility to play with it.



---

archive/issue_comments_328774.json:
```json
{
    "body": "You make some good points which I need to think about...\n\nI never said it was easy, but I like challenges :-)",
    "created_at": "2017-09-01T12:15:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328774",
    "user": "https://github.com/jdemeyer"
}
```

You make some good points which I need to think about...

I never said it was easy, but I like challenges :-)



---

archive/issue_comments_328775.json:
```json
{
    "body": "Jeroen, are you planning on working on this soon?  If not, I think it's worth trying to get an implementation based on Xavier's prototype into Sage.  It has a huge performance impact, and I don't want to see it languish because we move on to other things.",
    "created_at": "2017-09-06T16:26:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328775",
    "user": "https://github.com/roed314"
}
```

Jeroen, are you planning on working on this soon?  If not, I think it's worth trying to get an implementation based on Xavier's prototype into Sage.  It has a huge performance impact, and I don't want to see it languish because we move on to other things.



---

archive/issue_comments_328776.json:
```json
{
    "body": "Replying to [comment:32 roed]:\n> If not, I think it's worth trying to get an implementation based on Xavier's prototype into Sage.\n\nYou are basically proposing to have two different semi-working pool implementations (the one from `Integer` and this one) in Sage?",
    "created_at": "2017-09-06T21:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328776",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:32 roed]:
> If not, I think it's worth trying to get an implementation based on Xavier's prototype into Sage.

You are basically proposing to have two different semi-working pool implementations (the one from `Integer` and this one) in Sage?



---

archive/issue_comments_328777.json:
```json
{
    "body": "Replying to [comment:33 jdemeyer]:\n> Replying to [comment:32 roed]:\n> > If not, I think it's worth trying to get an implementation based on Xavier's prototype into Sage.\n> \n> You are basically proposing to have two different semi-working pool implementations (the one from `Integer` and this one) in Sage?\n\nI didn't say this ticket was ready for positive review yet.  But what makes these implementations \"semi-working?\"  The integer one has been in Sage for a long time and seems to be useful.\n\nAs for having two implementations, I'd be curious to see how the speed of the current integer pool compares with Xavier's implementation.  If nothing else, it would give us an idea of how costly performance-wise the decision to use the parent to store the pool is.",
    "created_at": "2017-09-06T21:42:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328777",
    "user": "https://github.com/roed314"
}
```

Replying to [comment:33 jdemeyer]:
> Replying to [comment:32 roed]:
> > If not, I think it's worth trying to get an implementation based on Xavier's prototype into Sage.
> 
> You are basically proposing to have two different semi-working pool implementations (the one from `Integer` and this one) in Sage?

I didn't say this ticket was ready for positive review yet.  But what makes these implementations "semi-working?"  The integer one has been in Sage for a long time and seems to be useful.

As for having two implementations, I'd be curious to see how the speed of the current integer pool compares with Xavier's implementation.  If nothing else, it would give us an idea of how costly performance-wise the decision to use the parent to store the pool is.



---

archive/issue_comments_328778.json:
```json
{
    "body": "Replying to [comment:34 roed]:\n> As for having two implementations, I'd be curious to see how the speed of the current integer pool compares with Xavier's implementation.  If nothing else, it would give us an idea of how costly performance-wise the decision to use the parent to store the pool is.\n\nThe pool for integers is faster (a simple addition takes ~70ns compared to ~110ns for `ZpFM` on my laptop). I suppose that the difference is the time needed to look for the address of the pool (it is hardcoded in the new/dealloc functions for the integers).",
    "created_at": "2017-09-06T21:58:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328778",
    "user": "https://github.com/xcaruso"
}
```

Replying to [comment:34 roed]:
> As for having two implementations, I'd be curious to see how the speed of the current integer pool compares with Xavier's implementation.  If nothing else, it would give us an idea of how costly performance-wise the decision to use the parent to store the pool is.

The pool for integers is faster (a simple addition takes ~70ns compared to ~110ns for `ZpFM` on my laptop). I suppose that the difference is the time needed to look for the address of the pool (it is hardcoded in the new/dealloc functions for the integers).



---

archive/issue_comments_328779.json:
```json
{
    "body": "I have an idea for this. Instead of storing the pool in the parent, store the pool as a static C variable inside the Cython module. This is fast, general but ugly. Since one cannot dynamically create functions in C, this would mean that a single Cython module could only use a fixed number of pools.",
    "created_at": "2017-09-26T13:12:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328779",
    "user": "https://github.com/jdemeyer"
}
```

I have an idea for this. Instead of storing the pool in the parent, store the pool as a static C variable inside the Cython module. This is fast, general but ugly. Since one cannot dynamically create functions in C, this would mean that a single Cython module could only use a fixed number of pools.



---

archive/issue_comments_328780.json:
```json
{
    "body": "I have (finally) finished my pool implementation in #17670. It is meant to be quite generally applicable.",
    "created_at": "2017-11-10T11:05:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328780",
    "user": "https://github.com/jdemeyer"
}
```

I have (finally) finished my pool implementation in #17670. It is meant to be quite generally applicable.



---

archive/issue_comments_328781.json:
```json
{
    "body": "Changing keywords from \"pool\" to \"pool, padicIMA\".",
    "created_at": "2018-07-22T20:45:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23485#issuecomment-328781",
    "user": "https://github.com/roed314"
}
```

Changing keywords from "pool" to "pool, padicIMA".
