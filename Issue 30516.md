# Issue 30516: Further improvements in method subgraph

Issue created by migration from https://trac.sagemath.org/ticket/30753

Original creator: dcoudert

Original creation time: 2020-10-11 12:25:56

CC:  @kliem

Extra speedup improvements in `subgraph` with a case forgotten in #30510. We also improve the logic in the selection of the default algorithm.


---

Comment by dcoudert created at 2020-10-11 12:29:44

I'm not sure if the threshold for selecting default algorithm is still best possible. At least, we have improved both algorithms.
----
New commits:


---

Comment by dcoudert created at 2020-10-11 12:29:53

Changing status from new to needs_review.


---

Comment by dcoudert created at 2020-10-11 12:57:37

Currently, the default algorithm is `'delete'` if the number of vertices of the subgraph is at least 5% of the number of vertices of the graph. But following tests suggest that `'add'` is faster when the number of vertices of the subgraph is up to 90%... so we should change the threshold to e.g. 90%. Do you agree ?

```
sage: G = graphs.Grid2dGraph(100, 100)
sage: V = list(G)
sage: %timeit H = G.subgraph(V[:50], algorithm=None)   # use add
219 µs ± 7.56 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit H = G.subgraph(V[:50], algorithm='add')
213 µs ± 10.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit H = G.subgraph(V[:50], algorithm='delete')
62.3 ms ± 1.64 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

sage: %timeit H = G.subgraph(V[:500], algorithm=None)  # use add
1.85 ms ± 35.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit H = G.subgraph(V[:500], algorithm='add')
1.99 ms ± 70.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit H = G.subgraph(V[:500], algorithm='delete')
64 ms ± 1.14 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

sage: %timeit H = G.subgraph(V[:5000], algorithm=None)  # use delete but add is faster here
53 ms ± 1.1 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
sage: %timeit H = G.subgraph(V[:5000], algorithm='add')
23.7 ms ± 229 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
sage: %timeit H = G.subgraph(V[:5000], algorithm='delete')
52.3 ms ± 636 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
```



```
sage: G = graphs.CompleteGraph(1000)                                                                                                
sage: V = list(G)                                                                                                                   
sage: %timeit H = G.subgraph(V[:50], algorithm=None)  # use 'add'
17.9 ms ± 408 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit H = G.subgraph(V[:50], algorithm='add')
19.5 ms ± 441 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit H = G.subgraph(V[:50], algorithm='delete')
962 ms ± 14.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

sage: %timeit H = G.subgraph(V[:100], algorithm=None)  # use 'delete' but 'add' is faster
962 ms ± 20.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit H = G.subgraph(V[:100], algorithm='add')
38 ms ± 828 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
sage: %timeit H = G.subgraph(V[:100], algorithm='delete')
959 ms ± 18.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

sage: %timeit H = G.subgraph(V[:500], algorithm=None)  # use 'delete' but 'add' is faster
949 ms ± 18.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit H = G.subgraph(V[:500], algorithm='add')
283 ms ± 15.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit H = G.subgraph(V[:100], algorithm='delete')
982 ms ± 32.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

sage: %timeit H = G.subgraph(V[:800], algorithm=None)  # use 'delete' but 'add' is faster
918 ms ± 35.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit H = G.subgraph(V[:800], algorithm='add')
643 ms ± 19.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit H = G.subgraph(V[:800], algorithm='delete')
909 ms ± 35.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

sage: %timeit H = G.subgraph(V[:900], algorithm=None)  # use 'delete' but 'add' is faster
862 ms ± 19.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit H = G.subgraph(V[:900], algorithm='add')
735 ms ± 16.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```



---

Comment by git created at 2020-10-11 16:45:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-10-11 16:48:15

I change the threshold for default algorithm to use use `'delete'` when the subgraph has at least 90% of the vertices and `'add'` otherwise. It seems faster this way. I updated some doctests (mostly changes in orderings).


---

Comment by @kliem created at 2020-10-12 06:41:19

The example in this ticket might imply, that #30665 should be put back onto needs work.

I see a huge slowdown.


---

Comment by dcoudert created at 2020-10-12 07:07:19

OK, so may be we should wait for the finalization of #30665 before changing the threshold.


---

Comment by @kliem created at 2020-10-12 07:50:19

I think I'm done with #30665.

However, I could open another ticket and implement a subgraph iterator in the backend:
Given a list of vertices, iterate over all edges in the induced subgraph. This should be much faster.


---

Comment by dcoudert created at 2020-10-12 08:57:09

We can give it a try, at least for simple cases.
You can either do it here (the branch is public) or in a separate ticket but it might be harder to ensure that all changes are consistent (i.e., improve the situation).


---

Comment by @kliem created at 2020-10-12 15:06:04

I would say, it is definitely worth it. But I have only a draft now with some todos.

In particular, this should speedup the copy method:


```
sage: G = graphs.Grid2dGraph(100, 100)                                                                                                                                                                                                                                                                                                                                     
sage: V = list(G)                                                                                                                                                                                                                                                                                                                                                          
sage: %timeit H = G.copy()                                                                                                                                                                                                                                                                                                                                                 
31.1 ms ± 183 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
sage: %timeit H = G.subgraph(V[:10000], algorithm='add')                                                                                                                                                                                                                                                                                                                   
16.6 ms ± 15.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```



---

Comment by @kliem created at 2020-10-12 15:11:56

Btw, `subgraph_by_deleting` should only be used in place or if the backend has an optimized copy method (which appears to be not the case yet).

Not sure about the special subgraphs yet, which are not obtained by just reducing the number of vertices.


---

Comment by git created at 2020-10-12 15:13:32

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2020-10-12 15:15:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-10-12 15:24:59

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2020-10-12 22:11:43

I'm not sure about this last commit as it has a different number than in #30665. Is it normal ?


---

Comment by @kliem created at 2020-10-13 05:58:30

This usually happens to me when cherry picking. I can rebase at some point on #30665.


---

Comment by git created at 2020-10-13 06:54:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by dcoudert created at 2020-10-13 11:29:37

- may be the method `obtain_subgraph` could be renamed like `subgraph_given_vertices` or something more explicit with respect what it actually do.
- there is a line `cdef CGraph` to remove
- instead of `max(b_vertices_2)`, why not using the size or capacity of bitset `active_vertices` ? or may be the size of `b_vertices` ?
- Somehow, before starting to add vertices to `other`, we should call `realloc` with appropriate size, thus avoiding multiple calls.
- I have no clue how to deal with multiple edges here.

- Concerning methods `add` and `delete`, I fully agree that now `delete` should be used only when `inplace is True or algorithm == 'delete'`. The  `add` method is now way faster and should be the default one, without threshold.


---

Comment by @kliem created at 2020-10-13 11:52:52

I'll keep that in mind.

Concerning the multiedges, unfortunately I shbould clean up dense and sparse graphs backend a bit first. Otherwise, I think it is not a problem.

If ``self`` is mutliedge, it will simply try to make ``other`` multiedge. If other is dense, this will raise an error.

If I do things right, optimizing `is_subgraph` afterwards should be easy. In particual this can be used to check equality fast.


---

Comment by dcoudert created at 2020-10-13 12:15:43

So may be for the moment, we can use the new method for graphs without multiple edges only and let other cases in the todo list (i.e., raise `NotImplementedError` if called on a graph with multiple edges).

It's cool if we can also optimize other methods. The work you have already done for iterating edges plus these optimizations of the subgraph method makes significant speed ups for the entire graph module :))


---

Comment by @kliem created at 2020-10-13 13:53:48

The current method does not even work for labeled graphs.

Give me a day or so and I'll see if I can figure things out.


---

Comment by @kliem created at 2020-10-14 14:45:31

This is basically working.

What is missing:

- Documentation.
- Cleanup.
- Exposure in `__init__` of `DiGraph` and `Graph` to speed up e.g. copy.
- (Maybe) Heuristics when to delete instead of add:
  As long as there are no improved copying methods, I changed the deletion subgraph to first obtain the subgraph induced by the given vertices instead of making a copy. Depending on the input of `edges` and `edge_property`, this might be better than adding, but maybe in not so many cases. And in those cases it might be more natural to obtain a subgraph first and then delete edges.
----
Last 10 new commits:


---

Comment by dcoudert created at 2020-10-14 16:39:35

This is really nice and I observe some speed up at least when doctesting the graph module :))


---

Comment by git created at 2020-10-14 19:27:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-10-14 19:44:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2020-10-15 09:09:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-10-15 09:10:21

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2020-10-15 09:38:28

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2020-10-15 09:38:28

It's not easy to review the changes done in this ticket as it depends on two other big tickets.
Nonetheless, so far all my tests are successful and show serious speed up with respect previous design. Method subgraph was a bottleneck in several of my own code.


---

Comment by vbraun created at 2020-11-07 16:23:58

Resolution: fixed
