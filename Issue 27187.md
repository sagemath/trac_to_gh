# Issue 27187: enumeration of minimal dominating sets

Issue created by migration from https://trac.sagemath.org/ticket/27424

Original creator: @jfraymond

Original creation time: 2019-03-04 20:36:28

Keywords: enumeration, dominating set

Goal: implement an algorithm enumerating the minimal dominating sets of a graph as described in https://arxiv.org/abs/1810.00789 .


---

Comment by @jfraymond created at 2019-03-04 21:18:12

(work in progress)


---

Comment by chapoton created at 2019-03-05 07:46:12

just some comments

* Please avoid that : `+from sage.all import *`

* use the arxiv role for arxiv links `:arxiv:`2022.01243``

* one blank line after INPUT:


---

Comment by dcoudert created at 2019-03-05 09:44:23

I don't think it's a good idea to define new neighbor iterators in this file.
It might be better to properly extend the functionalities of `neighbors` and `neighbor_iterator`.

Also, your method `neighbors_of_a_set` do the same as `.vertex_boundary()`, except that it returns a set instead of a list.


---

Comment by embray created at 2019-03-25 10:56:15

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)


---

Comment by git created at 2019-04-03 14:42:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @jfraymond created at 2019-04-03 14:59:28

Thanks for the comments.

Currently I assume that the vertices of the input graph are sortable, in order for some procedure to have deterministic output, which is required for the correctness of the algorithm. The procedure removes vertices one by one in increasing order until a property is met.

Is there a fast and easy way to sort the vertices in any case, for instance using some integer used internally to represent a vertex? Otherwise I could define an arbitrary order at the beginning, but that looks cumbersome.
Or can I assume that `.vertices()` always returns the vertices in the same order? (I guess not.)


---

Comment by dcoudert created at 2019-04-03 15:35:33

method `_peel`
- as you mix sets and lists in the output. Use sets only
- instead of `set(G.vertices())`, use `set(G)`. No need to sort here
- `peeling = [(None, G.vertices())]` should be `(None, set(G))]`, right ?
- `while H.order() > 0:` -> `while H:`

Some parts can be simplified like:

```diff
-            for L in tree_search(H, plng, dom, i + 1):
-                yield L
+            yield from tree_search(H, plng, dom, i + 1)
```


I'm really not in favor of adding new vertex iterators methods. Instead, you could add parameter `closed=True/False` to `neighbor_iterator` and `vertex_boundary`.

Now, concerning the sorting, and in view of your code, you could relabel your graph and use the mapping before returning the result. Then, you can sort integers safely if needed.

```
int_to_vertex = list(G)
vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}
G = G.relabel(perm=vertex_to_int)
...
for dom in tree_search(G, peeling, set(), 0):
    # we generate the leaves of the search tree that are descendant of (empty set, 0)
    yield dom[0], {int_to_vertex[i] for i in dom[1]}
```



---

Comment by mantepse created at 2019-04-03 18:58:35

If you want to, you could add the following sanity check:

```
sage: findstat([(G, sum(1 for _ in minimal_dominating_sets(G))) for n in range(6) for G in graphs(n)], depth=0) # optional - internet
0: (St001302: The number of minimally dominating sets of vertices of a graph., [], 52)
```

or, taking a bit longer, 

```
sage: findstat("Graphs", lambda G: sum(1 for _ in minimal_dominating_sets(G)), depth=0) # optional - internet
0: (St001302: The number of minimally dominating sets of vertices of a graph., [], 1000)
```



---

Comment by @jfraymond created at 2019-04-04 10:01:37

Thanks!
`@`dcoudert: as far as I know using `yield from` would make the code non compatible with python 2. Can we assume that everybody uses python 3 now?


---

Comment by dcoudert created at 2019-04-04 10:06:04

Right, it's working in Cython, but not in Python 2, a pity :(


---

Comment by git created at 2019-04-05 14:16:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-04-07 18:08:15

May be we should make a specific ticket for the neighbor iterators. If you agree, I can do it.


---

Comment by @jfraymond created at 2019-04-08 07:59:35

Indeed, I did not think of that. Thanks for offering! Feel free to do it.


---

Comment by git created at 2019-04-10 18:31:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-04-11 10:26:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-04-11 11:22:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @jfraymond created at 2019-04-11 16:00:38

I created the ticket #27647 for the changes in neighbor_iterator.


---

Comment by @jfraymond created at 2019-04-12 15:52:57

Is the correct procedure now to merge #27647 in this branch?


---

Comment by dcoudert created at 2019-04-14 15:56:03

yes, you should rebase your branch on top of #27647, and add it to the dependencies field


---

Comment by git created at 2019-04-15 12:42:14

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by @jfraymond created at 2019-04-15 12:47:24

Not sure what happened with the rebase (some commit messages have be re-displayed by trac), but it seems fine.


---

Comment by dcoudert created at 2019-04-15 14:06:46

should be ok.

are methods `private_neighbors`, `is_dominating`, `is_redundant` valid for graphs and digraphs ? if not, then these methods should be in `graph.py` or in `domination.py`.


---

Comment by git created at 2019-04-17 15:59:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @jfraymond created at 2019-04-17 16:08:48

The methods could easily be extended to digraphs but it would require to define closed neighborhoods for the `_backend.iterator_out_nbrs` method (and also update my previous changes to `neighbor_iterator`) or to define an `out_neighbors_iterator` method in `generic_graph.py` with a `closed` parameter. As I do not have much time now, I just moved the functions to `graph.py`.
I will now make a last pass on the code before I ask for a review.


---

Comment by git created at 2019-05-08 11:42:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-05-08 13:13:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @jfraymond created at 2019-05-08 13:14:07

Changing status from new to needs_review.


---

Comment by chapoton created at 2019-05-26 16:19:21

doc does not build


---

Comment by dcoudert created at 2019-05-30 09:45:29

- why adding `lazy_import("sage.graphs.domination", "minimal_dominating_sets")` in `src/sage/graphs/all.py` ? I think that `minimal_dominating_sets` should be a method of `Graph`.

- a possible error that prevent to build the doc

```diff
-    r'''
+    r"""
```

and of course the block ends with `"""` and not `'''`.

- In `minimal_dominating_sets`, please document more precisely the input parameters. What's the goal of `to_dominate` ? `work_on_copy` ?

- please revert modifications in `src/sage/graphs/generic_graph.py`. These modifications introduce trailing white spaces...

- in `is_dominating` input parameters and documented parameters are not the same. Futhermore, you should be more explicit that by default we want to dominate the vertices of `self`.
  For instance

```
Check whether ``p_dominating`` is a dominating set of ``self``.

When ``p_dominates`` is specified, check instead if ``p_dominating``
 dominates the vertices in ``p_dominates``.
```


  I'm not convince by the choice of the names `p_dominating` and `p_dominates`.

- in `is_redundant`, you should define `has_private` as a set, and add it `dominator[v][1]` in the `for v in focus` loop. Then, you just have to check if `has_private != dom`.


---

Comment by git created at 2019-06-04 22:25:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-05 11:24:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-05 11:29:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @jfraymond created at 2019-06-05 11:34:45

Thanks for the comments!
I addressed them all.


---

Comment by git created at 2019-06-05 11:52:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-05 13:47:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-06-12 16:22:19

The code has been greatly improved but I still have some comments. Sorry for that.

- We can improve the readability

```diff
-    def _aux_with_rep(H, to_dom, u_next):
-        # Auxilliary routine.
-        # Return the minimal dominating sets of to_dom, with the
-        # assumption that u_next dominates to_som.
-        # WARNING: the same output may be output several times
-        # (up to |H| times).
-        #
-        # In order to later remove duplicates, we here output pairs
-        # (ext,i) where ext is the output candidate extension and i
-        # counts how many elements have already been output.
+    def _aux_with_rep(H, to_dom, u_next):
+        """
+        Return the minimal dominating sets of to_dom, with the
+        assumption that u_next dominates to_som.
+
+        WARNING: the same output may be output several times
+        (up to |H| times).
+
+        In order to later remove duplicates, we here output pairs
+        (ext,i) where ext is the output candidate extension and i
+        counts how many elements have already been output.
+        """
```




- in `is_dominating`:

```diff
-        Check if a set is a dominating set.
+        Check whether ``dom`` is a dominating set of ``self``.
```

and you can remove that sentence from the output block. Actually, the output block is not necessary, and you could just say in the description of the method that this method can be used to check whether `dom` dominates a subset of vertices of the graph.

- you can simply do

```diff
-        return to_dom == set()
+        return not to_dom
```


- since you assume that `focus` has no repeated verices, you should better use a `set`. The test `v in focus` will be faster`.

- a simpler version

```diff
-        dominator = dict()
-        for v in focus:
-            dominator[v] = (0, None)  # Initialization
+        # Initialization
+        dominator = {v: (0, None) for v in focus}
```



- I suggest the following simplification (the text can be improved)

```diff
-        # Now we can compute with_private, the set of vertices of dom
-        # that have a private neighbor in focus
-        with_private = set()
-        for v in focus:
-            # Here we do care neither about vertices dominated by more
-            # than one vertex of dom (they are not private neighbor of
-            # anybody) nor about vertices not dominated by dom (idem).
-            if dominator[v][0] == 1:
-                # If v is dominated only by one vertex x,
-                # then v is a private neighbor of x
-                with_private.add(dominator[v][1])
+        # We now compute the subset of vertices of dom that have a
+        # private neighbor in focus. A vertex v in dom has a private
+        # neighbor in focus if it is dominated by a unique vertex,
+        # that is if dominator[v][0] == 1
+        with_private = {dominator[v][1] for v in focus is dominator[v][0] == 1}
```


- why not doing this:

```diff
-        return (neighbor
-                for neighbor in self.neighbor_iterator(vertex, closed=True)
-                if neighbor not in closed_neighborhood_vs)
+        return set(self.neighbors(vertex, closed=True)).difference(closed_neighborhood_vs)
```



---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by dcoudert created at 2019-07-13 23:14:53

There is a merge conflict with last beta.


---

Comment by chapoton created at 2019-07-14 09:48:55

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2019-10-07 10:19:54

I can help solving the merge conflicts if needed


---

Comment by dcoudert created at 2019-10-20 15:20:37

I fixed the merge conflicts, applied the modifications proposed in #comment:39, and move all methods related to domination to the file `domination.py`. I pushed everything to a new branch in public so that you can modify it if needed.

Do you agree with these changes ?
----
New commits:


---

Comment by dcoudert created at 2019-10-20 15:20:37

Changing status from needs_work to needs_review.


---

Comment by git created at 2019-12-28 16:34:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-12-28 17:04:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @jfraymond created at 2019-12-28 17:07:55

Thanks for the changes! (And sorry for the late relpy!)
I agree with all of them.
I made some minor changes in the docstrings.


---

Comment by dcoudert created at 2019-12-29 13:54:18

LGTM.


---

Comment by dcoudert created at 2019-12-29 13:54:18

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2020-01-01 21:01:32

9.0 is out


---

Comment by vbraun created at 2020-01-05 15:47:46

Resolution: fixed
