# Issue 30443: Finitely presented modules over the Steenrod algebra

Issue created by migration from https://trac.sagemath.org/ticket/30680

Original creator: @catanzaromj

Original creation time: 2020-09-28 12:53:40

CC:  @sverre320 kvanwoerden jhpalmieri tscrim @rrbruner cnassau




---

Comment by @catanzaromj created at 2020-09-28 14:00:34

Changing type from PLEASE CHANGE to enhancement.


---

Comment by @catanzaromj created at 2020-09-28 14:00:34

Changing component from PLEASE CHANGE to algebra.


---

Comment by @catanzaromj created at 2020-09-28 14:00:34

Changing keywords from "" to "Steenrod algebra, modules, homological algebra".


---

Comment by @catanzaromj created at 2020-09-28 14:07:14

Changing status from new to needs_review.


---

Comment by git created at 2020-09-29 20:06:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-30 20:08:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-10-02 08:47:38

This is quite a project and looks good on a first lookover. Thank you for the contribution. I have some immediate questions/comments before delving too much into the code:

1. Could this be split up into smaller tickets? This would make the review much easier.
2. I think you could rename `finitely_presented_over_the_steenrod_algebra` to `fp_over_steenrod_algebra` in order to make the file paths shorter to type.
3. I think the module elements should be Cythonized as this is generally where the majority of the computations happen and it is good to be faster here.
4. Use the Sage default latex commands of `\ZZ`, `\GF{p}`, etc. so the documentation is standardized.
5. Check your use of `::` and `:`. If there is going to be a docstring after, then it should be `::`, otherwise it should be `:` (with exceptions for, e.g., `.. NOTE::`).
6. Errors should be of the form `raise TypeError("a message without a capital letter or period")` to follow Python's conventions. Also, you should not raise a `RuntimeError` unless you have a very good reason to; `NotImplementedError`, `TypeError`, and `ValueError` are usually much better.
7. I think it is better to have class level documentation explaining stuff about input, descriptive information, and use-case doctests. The `__init__` can then have a simple docstring with a test that basically does `TestSuite(foo).run()`. This is also a common pattern in Sage.


---

Comment by @sverre320 created at 2020-10-08 15:59:12

tscrim,

Thanks for the quick follow-up.  Here are some preliminary answers:

1. There are (essentially) three new classes introduced in this ticket: 
   a) free graded modules over F_p-algebras
   b) f.p. graded modules over F_p-algebras, and
   c) f.p. graded modules over the Steenrod algebra.

   The class structure is so that f.p. modules (b) have a morphism of free modules (a) as internal data to represent the finite presentation of itself, while a f.p. module over the Steenrod algebra (c) is derived from the class b).

   It would be possible to split the ticket into perhaps two or three tickets: either a), b) and c), or a)+b) and c).  The classes in (b) contain all the functionality which does not depend on features special for the Steenrod algebra.  Thus, they might be of more general interest.

   However, as they are written, classes a)+b) are privately used by c) and was not intended for public use (yet).  As a consequence, the examples and tests in a) + b) only consider modules over the Steenrod algebra.

3. Indeed there are performance bottlenecks here.  In particular, a lot of time is spent just creating instances of the free modules (class a mentioned above).  The current implementation was motivated by readability, and a performance optimization was planned as a second step.  Preliminary measurements indicate that even a Python version using tighter data structures would increase performance by x10 already.

   However -- we have not considered Cython because neither of us have used it before.  This may be the best option though, and I am looking into it now.  One concern I have is that we use derived classes (fpa modules are e.g. derived from fp modules).  Would this complicate using Cython, in your opinion?


Thanks for your input so far.  These are certainly valid points.  There should be an update addressing 2. 4. 5. 6. and 7. coming soon.


---

Comment by tscrim created at 2020-10-09 21:53:30

1. It actually would be better to run the tests on the classes themselves rather than through an intermediary because it makes errors easier to find. You will just have to import the relevant classes in each of the doctests.

3. I would look more to optimization before accepting this. This first version is good for setting up the testing and code framework, but 10x is a huge gain and worth doing before merging it into Sage IMO. Using Cython shouldn't complicate things too much if you only have single inheritance. However, the main things you should use Cython on are the element classes (not the parents, which usually have multiple inheritance because you want them to also inherit from `UniqueRepresentation`) and time-critical computations. I am happy to help in translating things into Cython too.


---

Comment by git created at 2021-01-11 18:08:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Attachment

Performance of the original Python code.


---

Comment by @sverre320 created at 2021-01-12 20:23:07

Performance of the cythonized code.


---

Attachment

visualization of the performance data combined


---

Attachment

visualization of total time (green colors) and accounted time (red colors) for both python and cythonized code.


---

Attachment

Visualization of performance data where only time spent in external modules are shown


---

Comment by @sverre320 created at 2021-01-12 20:26:33

Visualization of performance data for cython code only.


---

Attachment

Visualization of performance data for python code only.


---

Attachment

We have pushed updates to this package which addresses tscrim's above comments 2, 4, 5, 6, and 7.

With regards to comment 3, we have tried to use Cython to optimize certain parts of the package but without experiencing any significant speedups.  I commented earlier that
"Preliminary measurements indicate that even a Python version using tighter data structures would increase performance by x10 already."  Unfortunately, this comment was based on a too simple example (constructing a free module on one generator).  The performance tests we now have conducted are based on a real world use case which is much more relevant for the typical user.

We have therefore come to the conclusion that we want to keep the code as it is, all in Python.

We have conducted performance measurements of both the original Python code as well as a version of it using Cython.  Our analysis points to two facts:

1. There is virtually no difference in computing time when comparing our original all-Python code to a version where fp_element.py and free_element.py have been turned into .pyx-files and "cythonized".

2. Approximately 70% of the time used computing the resolution is spent in either the SteenrodAlgebra module or doing linear algebra (subspace spanning, vector space quotients, etc.)  These are modules that are external to our package, so Cythonizing our code will not have an effect on this chunk of time.  We stopped looking when we could account for 70%-80% of the time consumed, and we are certain that we are not spending the remaining time in a loop somewhere which can benefit from Cythonizing.  We imagine various memory allocations and overhead due to the dynamic nature of Python accounts for at  least some of the remaining 30%.

The code to reproduce these performance measurements is available in the
two experimental branches:

origin/u/gh-sverre320/fp_over_steenrod_algebra_cython_test

origin/u/gh-sverre320/fp_over_steenrod_algebra_performance_test

The first branch contains a version of our package where the two modules fp_element.py and free_element.py have been turned into .pyx-files and "cythonized".

Both branches contain a sage script called 'performance_test.sage' which run the same performance test.  It can be used like this:


```
> ./sage performance_test.sage
```



The test produces a CSV formatted output, and we have included the results from running it on our system to this comment.

Here's a quick explanation of their contents:

The output is CSV-formatted and measures how much time various parts of the code spends during the computation of one (homological) step of a certain free resolution.  This computation is done one (internal) degree at a time, and each line in the CSV file corresponds to a single degree.

Each row contains the following measurements:

"total time": This is the number of seconds it takes to complete one step of the free resolution in one homogeneous degree.

"accounted time": The number of seconds which are accounted for (We only measured the time spent in certain parts which we suspected were most time consuming).

"SteenrodAlgebra": The number of seconds spent calling the SteenrodAlgebra module.

"linear algebra": The number of seconds spent running external linear algebra code.

For each line, the two last values should add up to "accounted time" (or close to it.  We left out some more measurements which were tiny in comparison to the two already mentioned.)

The attached images visualize these data.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by tscrim created at 2021-04-22 00:05:19

Sorry for the massive delay in getting back to this.

Thank you for looking into Cythonization. I would have thought there would be more of an advantage going to/from the linear algebra in Sage than dealing with the Steenrod algebra from a quick look through the code.

I have some quick comments before going into a deeper review:

It should be `INPUT:` and `OUTPUT:` with single quotes. If there is code afterwards (such as Sage doctests, which are indented one level), then it should be `EXAMPLES::` and `TESTS::`.

*Every* method needs a doctest. Good ones for `__init__` are to create an instance `foo` and run `TestSuite(foo).run()`.

The author bullet points should not be indented.

Input items should not end is a period/full-stop.

For `_richcmp_`, it is already guaranteed the elements have the same parent.

I would not do an import at the class level (see `from .fp_element import FP_Element`), but instead at the module level.

I would set `ModuleClass` and `HomSpaceClass` at the class level rather than during the `__init__`.

Do you want `j` to be a public attribute of `FP_Module`? If so (which I don't think is a good idea though), it needs a better name.

The name `FP_Module` doesn't follow Python naming conventions. Also, it is a bit too generic IMO.

You should add a method for creating the modules to the Steenrod algebra so it is both more discoverable and natural for the user.

I will likely have more comments later as I go deeper into the code.


---

Comment by dimpase created at 2021-04-24 10:00:58

Perhaps needless to mention, but Cython gets you big speedups only with some care, i.e. you'd need to avoid using Python types (anything untyped in Cython code would be Python, and may render the effort of cythonising useless).


---

Comment by @sverre320 created at 2021-04-24 10:54:09

tscrim: Great, you're back!

>The name FP_Module doesn't follow Python naming conventions. Also, it is a bit too generic IMO. 
About the naming, we have struggled a bit in the past getting names for these classes.  They tend to grow rather long when we put in too many descriptive words.

But could this work?

FP_Module -> FinitelyPresentedModule

FPA_Module -> FinitelyPresentedSteenrodAlgebraModule

Personally, if we are to make the class names more descriptive, I would prefer to go all the way, like so:

FP_Module -> FinitelyPresentedModule

FPA_Module -> FinitelyPresentedModuleOverTheSteenrodAlgebra

Also, what about directory path names, does this mean that they have to grow too?


---

Comment by @sverre320 created at 2021-04-24 10:56:54

dimpase: Yes, that makes sense.  Also, since the performance analysis points to the fact that most of the heavy lifting is performed by other libraries, I saw no point in optimizing our internal data structures.


---

Comment by tscrim created at 2021-04-25 03:45:56

I have some more consecutitive free time now to devote to a larger patch review. Sorry again for taking so long to get to it.

I would suggest the folder being `fp_steenrod_repr` the files being `fp_graded_*` and `gp_steenrod_*` and the classes being `FinitelyPresentedGradedAlgebraModule` and `FinitelyPresentedSteenrodRepresentation`. Shortening `FinitelyPresented` to `FP` is also good, but no underscore `_` after it.

If the `FP_Module` is really more general, then the elements should be Cythonized and put in a different folder. I think it would be good if the corresponding documentation stated a bit about what assumptions you have on the algebra's implementation.

In the morphism implementation, you should instead implement the single underscore version of the algebraic operations, e.g. `_add_`. Then you can assume compatible maps (in terms of domain and codomain) as the coercion framework will take care of the rest.

Do you need the implementation of free modules? In particular, I am wondering if you could use what is currently in Sage (with perhaps some renaming of methods and/or adding stuff to an appropriate category)?


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by jhpalmieri created at 2021-08-27 21:43:26

Here is a small patch. It fixes some documentation syntax, and it also moves the documentation from "algebras" to "modules". It fixes two doctest failures, probably due to a change in another component of Sage.
----
Last 10 new commits:


---

Comment by jhpalmieri created at 2021-08-27 22:01:52

I also echo tscrim's comments. For example, the module `sage.combinat.free_module` is may be a good replacement for your free module implementation, or a good class to use for inheritance (where you might add `generator_degrees`, etc.).

Using long names (like `FinitelyPresentedGradedAlgebraModule` or `FPGradedAlgebraModule`) is pretty typical in Sage, and it's typically not a burden because you either don't need to type the name much or when you do, then at least in an interactive session, you can use tab completion. So the preference is to use more descriptive names.


---

Comment by jhpalmieri created at 2021-08-27 22:04:02

The function `mod_p_log` can be replaced by the method `exact_log` (defined for Sage Integers).


---

Comment by jhpalmieri created at 2021-08-27 22:56:51

Actually, `mod_p_log(a, p)` is `1+a.exact_log(p)`. Here is a potential patch:

```diff
diff --git a/src/sage/modules/fp_over_steenrod_algebra/profile.py b/src/sage/modules/fp_over_steenrod_algebra/profile.py
index 95f8277e1c..a12b454c40 100755
--- a/src/sage/modules/fp_over_steenrod_algebra/profile.py
+++ b/src/sage/modules/fp_over_steenrod_algebra/profile.py
@@ -37,32 +37,7 @@ from sage.algebras.steenrod.steenrod_algebra import SteenrodAlgebra
 from copy import copy
 
 
-#import sage.modules.fp_over_steenrod_algebra.utility as Utility
-def mod_p_log(n,p):
-    r"""
-    Input an integer $n$ and a prime $p$
-    Output the $k$ so that $p^{k-1} < n <= p^k$
-
-    EXAMPLES::
-
-        sage: from sage.modules.fp_over_steenrod_algebra.profile import *
-        sage: mod_p_log(1,4)
-        1
-        sage: mod_p_log(8,3)
-        2
-        sage: mod_p_log(9,3)
-        3
-
-    """
-    k=0
-    pow=1
-    while n >= pow:
-        k += 1
-        pow *= p
-    return k
-
-
-def profile_ele(alist,char=2):
+def profile_ele(alist, char=2):
     """
     Finds the smallest sub-Hopf algebra containing the element passed.
     `alist' is assumed to be an element of the Steenrod Algebra, (the only other
@@ -91,32 +66,33 @@ def profile_ele(alist,char=2):
         alist2 = [e[0] for e in alist]
         maxlength = max([0]+[len(e) for e in alist2])
         alist2 = [list(e) + (maxlength-len(e))*[0] for e in alist2]
-        minprofile = [max([alist2[i][j] for i in range(len(alist2))]) \
+        minprofile = [max([alist2[i][j] for i in range(len(alist2))])
                                                 for j in range(maxlength)]
-        minprofile = tuple(map(lambda xx: mod_p_log(xx,char),minprofile))
+        minprofile = tuple(map(lambda xx: xx.exact_log(char)+1, minprofile))
         return find_min_profile(minprofile,char)
-    if char != 2:
-        alistQ = [e[0][0] for e in alist]
-        alistP = [e[0][1] for e in alist]
-        maxlengthQ = max([0]+[len(e) for e in alistQ])
-        maxlengthP = max([0]+[len(e) for e in alistP])
-        alistQ = [list(e) + (maxlengthQ-len(e))*[0] for e in alistQ]
-        alistP = [list(e) + (maxlengthP-len(e))*[0] for e in alistP]
-        minprofileQ = [max([alistQ[i][j] for i in range(len(alistQ))]) \
-                                            for j in range(maxlengthQ)]
-        minprofileP = [max([alistP[i][j] for i in range(len(alistP))]) \
-                                            for j in range(maxlengthP)]
-        minprofileP = tuple(map(lambda xx: mod_p_log(xx,char),minprofileP))
-        if not minprofileQ:
-            minpQ=[]
-        else:
-            minpQ = [1]*(max(minprofileQ)+1)
-            for j in minprofileQ:
-                minpQ[j] = 2
-        return find_min_profile((minprofileP,minpQ),char=char)
+
+    # odd primes
+    alistQ = [e[0][0] for e in alist]
+    alistP = [e[0][1] for e in alist]
+    maxlengthQ = max([0]+[len(e) for e in alistQ])
+    maxlengthP = max([0]+[len(e) for e in alistP])
+    alistQ = [list(e) + (maxlengthQ-len(e))*[0] for e in alistQ]
+    alistP = [list(e) + (maxlengthP-len(e))*[0] for e in alistP]
+    minprofileQ = [max([alistQ[i][j] for i in range(len(alistQ))])
+                                        for j in range(maxlengthQ)]
+    minprofileP = [max([alistP[i][j] for i in range(len(alistP))])
+                                        for j in range(maxlengthP)]
+    minprofileP = tuple(map(lambda xx: xx.exact_log(char)+1, minprofileP))
+    if not minprofileQ:
+        minpQ=[]
+    else:
+        minpQ = [1]*(max(minprofileQ)+1)
+        for j in minprofileQ:
+            minpQ[j] = 2
+    return find_min_profile((minprofileP,minpQ),char=char)
 
 
-def enveloping_profile_elements(alist,char=2):
+def enveloping_profile_elements(alist, char=2):
     """
     Finds the profile function for the smallest sub-Hopf algebra containing
     the list of elements passed. Entries of `alist' are elements of the Steenrod
@@ -145,26 +121,27 @@ def enveloping_profile_elements(alist,char=2):
              return (0,)
         maxlength = max([len(e) for e in alist2])
         alist2 = [list(e) + (maxlength-len(e))*[0] for e in alist2]
-        minprofile = tuple(max([alist2[i][j] for i in range(len(alist2))]) \
+        minprofile = tuple(max([alist2[i][j] for i in range(len(alist2))])
                                                 for j in range(maxlength))
         return find_min_profile(minprofile)
-    else:
-        masterlist = [profile_ele(x,char) for x in alist if x != 0]
-        alistP = [x[0] for x in masterlist]
-        alistQ = [x[1] for x in masterlist]
-        if not alistP and not alistQ:
-            return ((0,),(0,))
-        maxlengthQ = max([len(e) for e in alistQ])
-        maxlengthP = max([len(e) for e in alistP])
-        alistQ = [list(e) + (maxlengthQ-len(e))*[0] for e in alistQ]
-        alistP = [list(e) + (maxlengthP-len(e))*[0] for e in alistP]
-        minprofileQ = tuple(max([alistQ[i][j] for i in range(len(alistQ))]) \
-                                                for j in range(maxlengthQ))
-        minprofileP = tuple(max([alistP[i][j] for i in range(len(alistP))])\
-                                                for j in range(maxlengthP))
-        return find_min_profile((minprofileP,minprofileQ),char=char)
-
-def enveloping_profile_profiles(alist,char=2):
+
+    # odd primes
+    masterlist = [profile_ele(x,char) for x in alist if x != 0]
+    alistP = [x[0] for x in masterlist]
+    alistQ = [x[1] for x in masterlist]
+    if not alistP and not alistQ:
+        return ((0,),(0,))
+    maxlengthQ = max([len(e) for e in alistQ])
+    maxlengthP = max([len(e) for e in alistP])
+    alistQ = [list(e) + (maxlengthQ-len(e))*[0] for e in alistQ]
+    alistP = [list(e) + (maxlengthP-len(e))*[0] for e in alistP]
+    minprofileQ = tuple(max([alistQ[i][j] for i in range(len(alistQ))])
+                                            for j in range(maxlengthQ))
+    minprofileP = tuple(max([alistP[i][j] for i in range(len(alistP))])
+                                            for j in range(maxlengthP))
+    return find_min_profile((minprofileP,minprofileQ),char=char)
+
+def enveloping_profile_profiles(alist, char=2):
     """
     Finds the profile function for the smallest sub-Hopf algebra containing
     the sub-algebras corresponding the list of profile functions passed. Accepts
@@ -190,24 +167,25 @@ def enveloping_profile_profiles(alist,char=2):
         alist2 = list(copy(alist))
         maxlength = max([len(e) for e in alist2])
         alist2 = [list(e) + (maxlength-len(e))*[0] for e in alist2]
-        minprofile = tuple(max([alist2[i][j] for i in range(len(alist2))]) \
+        minprofile = tuple(max([alist2[i][j] for i in range(len(alist2))])
                                                 for j in range(maxlength))
         return find_min_profile(minprofile)
-    else:
-        alistP = [copy(alist[i][0]) for i in range(len(alist))]
-        alistQ = [copy(alist[i][1]) for i in range(len(alist))]
-        maxlengthQ = max([len(e) for e in alistQ])
-        maxlengthP = max([len(e) for e in alistP])
-        alistQ = [list(e) + (maxlengthQ-len(e))*[0] for e in alistQ]
-        alistP = [list(e) + (maxlengthP-len(e))*[0] for e in alistP]
-        minprofileQ = tuple(max([alistQ[i][j] for i in range(len(alistQ))]) \
-                                                for j in range(maxlengthQ))
-        minprofileP = tuple(max([alistP[i][j] for i in range(len(alistP))]) \
-                                                for j in range(maxlengthP))
-        return find_min_profile((minprofileP,minprofileQ),char=char)
-
-
-def valid(LL,char=2):
+
+    # odd primes
+    alistP = [copy(alist[i][0]) for i in range(len(alist))]
+    alistQ = [copy(alist[i][1]) for i in range(len(alist))]
+    maxlengthQ = max([len(e) for e in alistQ])
+    maxlengthP = max([len(e) for e in alistP])
+    alistQ = [list(e) + (maxlengthQ-len(e))*[0] for e in alistQ]
+    alistP = [list(e) + (maxlengthP-len(e))*[0] for e in alistP]
+    minprofileQ = tuple(max([alistQ[i][j] for i in range(len(alistQ))])
+                                            for j in range(maxlengthQ))
+    minprofileP = tuple(max([alistP[i][j] for i in range(len(alistP))])
+                                            for j in range(maxlengthP))
+    return find_min_profile((minprofileP,minprofileQ),char=char)
+
+
+def valid(LL, char=2):
     """
     Determines if the list passed is a valid profile.
     ## When checking at odd primes, the `P`-part must be the 0th entry in LL,
@@ -235,20 +213,21 @@ def valid(LL,char=2):
             for i in range(1,r):
                 value = value and ((L[r] >= L[r-i] - i) or (L[r] >= L[i]))
         return value
-    else:
-        (alistP,alistQ) = (LL[0],LL[1])
-        M = [0] + list(alistP) + [0]*len(alistP)
-        L = list(alistQ) + [1]*(len(alistQ)+1)
-        M = M + [0]*abs(len(M)-len(L))  # Pad so they're the same length
-        L = L + [1]*abs(len(M)-len(L))
-        value = valid(alistP,char=2)  # P part must satisfy same conditions, regardless of prime.
-        for r in range(len(L)): # \tau's indexed at 0, unlike \xi 's
-            if (L[r] == 1) and value:
-                for i in range(r+1):
-                    value = value and ((M[i] <= r -i) or (L[r-i] == 1))
-        return value
 
-def nextprof(p,n,char=2):
+    # odd primes
+    (alistP,alistQ) = (LL[0],LL[1])
+    M = [0] + list(alistP) + [0]*len(alistP)
+    L = list(alistQ) + [1]*(len(alistQ)+1)
+    M = M + [0]*abs(len(M)-len(L))  # Pad so they're the same length
+    L = L + [1]*abs(len(M)-len(L))
+    value = valid(alistP,char=2)  # P part must satisfy same conditions, regardless of prime.
+    for r in range(len(L)): # \tau's indexed at 0, unlike \xi 's
+        if (L[r] == 1) and value:
+            for i in range(r+1):
+                value = value and ((M[i] <= r -i) or (L[r-i] == 1))
+    return value
+
+def nextprof(p, n, char=2):
     """
     Takes a possible profile `p' and a base profile `n'. Returns the next
     profile in lexicographic order. After all valid profiles `p' of
@@ -292,22 +271,23 @@ def nextprof(p,n,char=2):
                 else:                          # inside n still, so reset to n
                     p[i] = n[i]
         return n + [0]*(len(p)-len(n)) + [1]    # fell off the end
-    else:  # odd primes
-        pQ = list(p[1])
-        nQ = list(n[1])
-        for i in range(len(pQ)):
-            if pQ[i] < 2:
-                pQ[i] += 1
-                return pQ
+
+    # odd primes
+    pQ = list(p[1])
+    nQ = list(n[1])
+    for i in range(len(pQ)):
+        if pQ[i] < 2:
+            pQ[i] += 1
+            return pQ
+        else:
+            if i > len(nQ) -1:
+                pQ[i] = 1
             else:
-                if i > len(nQ) -1:
-                    pQ[i] = 1
-                else:
-                    pQ[i] = nQ[i]
-        return nQ + [1]*(len(pQ)-len(nQ)) +[1]
+                pQ[i] = nQ[i]
+    return nQ + [1]*(len(pQ)-len(nQ)) +[1]
 
 
-def find_min_profile(prof,char=2):
+def find_min_profile(prof, char=2):
     """
     Given a tuple of integers (a pseudo-profile), this function will
     output the smallest legal profile function containing it. This
@@ -346,11 +326,11 @@ def find_min_profile(prof,char=2):
         while not valid(p,char):
             p = nextprof(p,n,char)
         return tuple(p)
-    else:
-        pP,pQ = list(prof[0]), list(prof[1])
-        P = find_min_profile(pP,char=2)
-        Q = copy(pQ)
-        while not valid([P,Q],char):
-            Q = nextprof([P,Q],[P,pQ],char)
-        return (P,Q)
+
+    pP,pQ = list(prof[0]), list(prof[1])
+    P = find_min_profile(pP,char=2)
+    Q = copy(pQ)
+    while not valid([P,Q],char):
+        Q = nextprof([P,Q],[P,pQ],char)
+    return (P,Q)
 
```



---

Comment by @sverre320 created at 2021-08-29 15:28:00

Thanks for making concrete suggestions, like using sage.combinat.free_module.  I am just not sure it's worth it.  When I look at the existing code, I see a lot of reference to the degree of elements.  All that code has to be put back into the class that inherits from combinat (which has no concept of gradings).  And so I am not convinced it's going to be saving a lot of lines of code in the end.

I think of the free module class as part of the private implementation of this package, and not an addition to Sage in itself.  Replacing it or letting it inherit from combinat would have implications on the rest of the code.  Since these kinds of changes usually take longer to implement than what one usually expects, I am hesitant about trying this out.

Am I just being too negative here, or are there any obvious benefits I am missing?


---

Comment by jhpalmieri created at 2021-08-29 20:17:15

Well, I find it annoying that there are two different implementations of free modules already, and adding another would only add to that. In general, the pieces of Sage should build on each other, rather than each developer building their own version of each thing they want.

When I first wrote the chain complex and simplicial complex code in Sage, I used the existing code for matrices and linear algebra (for the boundary maps), and as a result, I found a bunch of bugs in that code. The more the pieces of Sage are tied together, the stronger the pieces are, because they're used and tested in more different ways.

I will try to take a look to see how much work would need to be done to have your code inherit from `sage.combinat.free_module`.


---

Comment by dimpase created at 2021-08-30 11:42:58

maybe `sage.combinat.free_module` ought to be extended to accommodate for the needs of this ticket?

I find it surprising that 
`sage.combinat.free_module` has no concept of grading.


---

Comment by @sverre320 created at 2021-08-30 12:51:24

Back when I started refactoring the original code for this package, I tried to find a suitable class to build (free) graded modules on.  I failed to find one, and decided to write my own and make it an internal component of this package.

However, `@`jhpalmieri, I absolutely agree with what you are saying:  Ideally, I would have liked to open a separate ticket with the goal of adding a more general class for free graded modules.  

This seemed to me like a bigger task, and so I compromised.  It's a task I necessarily cannot do myself, as there are many opinions about what a graded module should be.  It is e.g. not clear to me that a class for representing free graded modules should inherit from the ungraded module class.  For example, I guess this relates directly to the question about allowing sums of elements of different degrees or not.

One option for the current ticket has always been to integrate the free module code into the class of the finitely presented modules (FP_xxx) and avoid the problem we are facing now.  However, it always made much more sense to me, in terms of code readability, to separate the code for free module representation.

So to conclude: If we to open a ticket and do graded modules in Sage correctly, I am willing to help out.  Otherwise, I suggest we accept the solution in this ticket and postpone the cleanup.

Of course,  if I am wrong and this
> I will try to take a look to see how much work would need to be done 
> to have your code inherit from sage.combinat.free_module.
turns out to make more sense, I am happy to take this path.


---

Comment by jhpalmieri created at 2021-09-08 21:31:11

My current plan is the following, time-permitting:
- move the files `fp_...` into a new directory `sage/modules/fp_graded/`, in the hopes that they will be of more general use.
- rewrite those files to base them on existing free module implementations.
- then see what's left after that.

I think this fits into tscrim's suggestion. Assuming there are no objections, then once I've made some progress, I will open a ticket for general finitely presented graded modules over graded rings, and we can rebase this ticket on top of that one.


---

Comment by jhpalmieri created at 2021-09-08 21:34:42

By the way, I don't see any reason to forbid sums of elements of different degrees; people can decide depending on their uses. It's unusual but not unheard of for the Steenrod algebra, and someone might try something strange and make a great new discovery.


---

Comment by jhpalmieri created at 2021-09-09 05:23:54

I have questions and comments:

- first, in other parts of Sage that use gradings, the zero element has no degree, and in fact `zero.degree()` raises an error rather than returning `None` as it does here. So I am changing the behavior here to raise an error.

- I'm not sure what to do with homsets and morphisms. Some people would insist that `Hom(M, N)` should contain only degree 0 maps; others (especially in algebraic topology, in my experience) allow maps of any degree. (Fortunately no one allows maps that do not preserve degrees, when considering categories of graded modules.) How do we handle this? Should there be two different structures, one for degree 0 maps, one for maps of arbitrary degree? Or just degree 0 maps, and then people can consider `Hom(Sigma^i M, Sigma N)` if they want maps of degree `i` from `M` to `N`?


---

Comment by jhpalmieri created at 2021-09-09 05:37:13

This may be more a question for Travis. Should the category be `GradedModules` or `GradedModulesWithBasis`? Maybe if we're working over an algebra with a distinguished basis, the module should inherit that basis, at least in the case of a free module. I'm not sure, though, and I really don't know what to do about non-free modules. (I haven't gotten that far in my modifications: I've just been dealing with free modules.)

I'm a little puzzled by the category setup in this context. Does "with basis" refer to a basis over the algebra over which we're working, or over the base field for that algebra? Consider this:

```
sage: R.<x> = QQ[]                                                                       
sage: R                                                                                  
Univariate Polynomial Ring in x over Rational Field
sage: M = FreeModule(R, ['a', 'b'])                                                      
sage: M.category()                                                                       
Category of finite dimensional modules with basis over Univariate Polynomial Ring in x over Rational Field
```

The "finite dimensional" part of that sounds odd unless you interpret it as meaning "free and finitely generated".

```
sage: M.basis()
Finite family {'a': B['a'], 'b': B['b']}
```

So this is viewing the basis as being over the polynomial ring.

On the other hand:

```
sage: A = GradedModulesWithBasis(QQ).example()                                           
sage: A                                                                                  
An example of a graded module with basis: the free module on partitions over Rational Field
sage: A.homogeneous_component_basis(4)                                                   
Lazy family (Term map from Partitions to An example of a graded module with basis: the free module on partitions over Rational Field(i))_{i in Partitions of the integer 4}
sage: list(A.homogeneous_component_basis(4))                                             
[P[4], P[3, 1], P[2, 2], P[2, 1, 1], P[1, 1, 1, 1]]
```

So `homogeneous_component_basis(...)` allows access to the vector space basis.

It looks like "with basis" means over the ring or algebra connected to the module, not the ground field. So maybe it should be in the categories
- `GradedModulesWithBasis(A)` only in the case of free modules
- `GradedModulesWithBasis(A.base_ring())` for all modules, assuming we can determine a basis of each homogeneous piece, and this should be possible as long as the algebra has a distinguished basis.
Does that make sense?


---

Comment by @sverre320 created at 2021-09-09 10:35:43

`@`jhpalimeri: I think your plan is perfect, and totally in tune with what I hoped could be done.  (I even think there is a comment about this in the beginning of fp_module.py.)

At any rate, I am happy about this turn and would gladly help out if I can.


---

Comment by jhpalmieri created at 2021-09-09 18:00:27

For degrees of morphisms, I propose:

- we allow construction of morphisms of any degree, but
- Hom(M,N) should consist only of morphisms of degree 0.

Comments?


---

Comment by @rrbruner created at 2021-09-09 18:47:54

Replying to [comment:37 jhpalmieri]:
> For degrees of morphisms, I propose:
> 
> - we allow construction of morphisms of any degree, but
> - Hom(M,N) should consist only of morphisms of degree 0.
> 
> Comments?
If Hom(M,N) is to contain morphisms of any degree, then it should be a graded vector space, and would not be of finite type, in general.  This suggests Hom(M,N) should contain morphisms of degree 0 only.

Counter-argument: a cochain representing an element of  Ext<sup>s,t</sup>(M,N) is a homomorphism of degree t from M _s (the s<sup>th</sup> stage in your free resolution of M) to N, or a homomorphism of degree 0 from M_s to \Sigma<sup>t</sup> N.   Then, lifting this to a chain map, you'll need degree 0 morphisms from M_{s+i} to \Sigma<sup>t</sup> N_i (where N_* is your resolution of N).

You end up needing to construct all (well, many of) the suspensions of every term in any resolution you create, which seems to be a lot of extra baggage.    Morphisms of any degree obviate this.

If you have morphisms of any degree, but Hom(M,N) only includes those of degree 0, where do the others live?


---

Comment by jhpalmieri created at 2021-09-09 20:47:45

Yesterday I browsed the internet, and a majority of places viewed Hom as containing only degree 0 maps. This agrees with my impression that many people view the category of graded modules as having degree 0 maps as the morphisms.

I think that computationally, constructing a suspension of a graded module should not be a burden. On the other hand, inheriting from  `UniqueRepresentation` may mean that Sage will never truly forget a graded module once it's been constructed, so maybe constructing lots of suspensions would be a burden. If this becomes a concern, we can create a new class for the suspension of a module: the input would be an already existing module (no new resources required there) and an integer.


---

Comment by jhpalmieri created at 2021-09-09 21:40:40

By the way, if we wanted separate classes for degree zero maps and maps of arbitrary degree, then `vector_presentation` would make sense for the zero map in the degree zero case: you would just get the zero matrix of the appropriate size.


---

Comment by jhpalmieri created at 2021-09-09 23:10:50

A more practical question: if we don't allow maps of nonzero degree in Hom, then how do we construct maps? Currently the easiest way to construct them is `Hom(M,N)(...values...)`, but that won't work if we change `Hom`. `Hom` does take an extra argument, `category`, so we could use a different category to allow nonzero degree maps, although I'm not sure what that category should be called.


---

Comment by tscrim created at 2021-09-09 23:33:16

Replying to [comment:30 dimpase]:
> maybe `sage.combinat.free_module` ought to be extended to accommodate for the needs of this ticket?

+1 and we can likely use a lot of the stuff from the category, which means just implementing stuff at the parent level. It might be a bit slower than directly implementing it, but it might not be the bottleneck.

> I find it surprising that 
> `sage.combinat.free_module` has no concept of grading.

It is all in the category, which get then you implement for the corresponding parent. Perhaps we could extend CFM that takes an optional `grading` parameter, but so far, every use-case of this required us to subclass for other functionality too.


---

Comment by jhpalmieri created at 2021-09-09 23:44:48

Replying to [comment:42 tscrim]:
> Replying to [comment:30 dimpase]:
> > maybe `sage.combinat.free_module` ought to be extended to accommodate for the needs of this ticket?
> 
> +1 and we can likely use a lot of the stuff from the category, which means just implementing stuff at the parent level. It might be a bit slower than directly implementing it, but it might not be the bottleneck.

Although `CombinatorialFreeModule` is not exactly right for the modules here. At least in the free module case (which is as far as I've gotten), you only care about the degrees of the generators, you don't want to give them names, so there is no named basis. A typical element is listed as `<a1, a2, ...>` which means the sum of `a_i * generator_i`, and this looks like a pretty efficient way to describe elements. We could create names, but they would be artificial.

Note that `sage.modules.free_module` is not suited for this, either: if you try to use it to create a free module over, say, the Steenrod algebra, you get

```
UserWarning: You are constructing a free module
over a noncommutative ring. Sage does not have a concept
of left/right and both sided modules, so be careful.
It's also not guaranteed that all multiplications are
done from the right side.
```


> > I find it surprising that 
> > `sage.combinat.free_module` has no concept of grading.
> 
> It is all in the category, which get then you implement for the corresponding parent. Perhaps we could extend CFM that takes an optional `grading` parameter, but so far, every use-case of this required us to subclass for other functionality too.


---

Comment by tscrim created at 2021-09-09 23:47:49

Replying to [comment:35 jhpalmieri]:
> This may be more a question for Travis. Should the category be `GradedModules` or `GradedModulesWithBasis`?

If there is a distinguished basis for the module, then `GradedModulesWithBasis`. Otherwise just `GradedModules`.

> Maybe if we're working over an algebra with a distinguished basis, the module should inherit that basis, at least in the case of a free module.

I would think that depends on the construction. However, having a distinguished basis means you can do linear algebra, which gives you a lot more functionality.

> I'm not sure, though, and I really don't know what to do about non-free modules. (I haven't gotten that far in my modifications: I've just been dealing with free modules.)

Since we don't have much if any support for nonfree modules in Sage, you are out there on your own to figure out what the best practice should be.

> I'm a little puzzled by the category setup in this context. Does "with basis" refer to a basis over the algebra over which we're working, or over the base field for that algebra? Consider this:
> {{{
> sage: R.<x> = QQ[]                                                                       
> sage: R                                                                                  
> Univariate Polynomial Ring in x over Rational Field
> sage: M = FreeModule(R, ['a', 'b'])                                                      
> sage: M.category()                                                                       
> Category of finite dimensional modules with basis over Univariate Polynomial Ring in x over Rational Field
> }}}
> The "finite dimensional" part of that sounds odd unless you interpret it as meaning "free and finitely generated".

Perhaps it would be a bit better to call it the category of "finite rank free modules", but that is something you are best discussing with Nicholas about.

> {{{
> sage: M.basis()
> Finite family {'a': B['a'], 'b': B['b']}
> }}}
> So this is viewing the basis as being over the polynomial ring.

Agreed.

> On the other hand:
> {{{
> sage: A = GradedModulesWithBasis(QQ).example()                                           
> sage: A                                                                                  
> An example of a graded module with basis: the free module on partitions over Rational Field
> sage: A.homogeneous_component_basis(4)                                                   
> Lazy family (Term map from Partitions to An example of a graded module with basis: the free module on partitions over Rational Field(i))_{i in Partitions of the integer 4}
> sage: list(A.homogeneous_component_basis(4))                                             
> [P[4], P[3, 1], P[2, 2], P[2, 1, 1], P[1, 1, 1, 1]]
> }}}
> So `homogeneous_component_basis(...)` allows access to the vector space basis.
> 
> It looks like "with basis" means over the ring or algebra connected to the module, not the ground field.

Yes, that is correct, it is the base ring `R`, not any underlying ground ring/field that might be used to construct `R`.

> So maybe it should be in the categories
> - `GradedModulesWithBasis(A)` only in the case of free modules
> - `GradedModulesWithBasis(A.base_ring())` for all modules, assuming we can determine a basis of each homogeneous piece, and this should be possible as long as the algebra has a distinguished basis.
> Does that make sense?

This sounds like more of a question with the underlying mathematics that I can't answer.


---

Comment by tscrim created at 2021-09-09 23:59:55

Replying to [comment:43 jhpalmieri]:
> Replying to [comment:42 tscrim]:
> > Replying to [comment:30 dimpase]:
> > > maybe `sage.combinat.free_module` ought to be extended to accommodate for the needs of this ticket?
> > 
> > +1 and we can likely use a lot of the stuff from the category, which means just implementing stuff at the parent level. It might be a bit slower than directly implementing it, but it might not be the bottleneck.
> 
> Although `CombinatorialFreeModule` is not exactly right for the modules here. At least in the free module case (which is as far as I've gotten), you only care about the degrees of the generators, you don't want to give them names, so there is no named basis. A typical element is listed as `<a1, a2, ...>` which means the sum of `a_i * generator_i`, and this looks like a pretty efficient way to describe elements. We could create names, but they would be artificial.

I don't think there is anything wrong with having an artificial name for the basis elements. This is just implicit in Sage's `R^n` version of free modules, but we give a name to the basis all the time in math once we want to start working with a basis. However, using CFM is generally slower because its implementation is in Python, always sparse, and has some extra overhead because it allows more generic basis indices. Yet, you do gain the ability to handle infinite dimensional objects.

> Note that `sage.modules.free_module` is not suited for this, either: if you try to use it to create a free module over, say, the Steenrod algebra, you get
> {{{
> UserWarning: You are constructing a free module
> over a noncommutative ring. Sage does not have a concept
> of left/right and both sided modules, so be careful.
> It's also not guaranteed that all multiplications are
> done from the right side.
> }}}

Let `S` be the Steenrod algebra over a (commutative) ring `R`. Perhaps we should think of the free module as a representation of `S` over `R`, something you alluded to in your other comments. Internally, this seems to be how it is storing elements, as an infinite dimensional `R`-module


---

Comment by tscrim created at 2021-09-10 00:03:16

Replying to [comment:41 jhpalmieri]:
> A more practical question: if we don't allow maps of nonzero degree in Hom, then how do we construct maps? Currently the easiest way to construct them is `Hom(M,N)(...values...)`, but that won't work if we change `Hom`. `Hom` does take an extra argument, `category`, so we could use a different category to allow nonzero degree maps, although I'm not sure what that category should be called.

Strictly speaking, I think a map that shifts degree should not live in the category of graded modules. You are always fine using a larger category, such as the category of modules. However, we could potentially allow a slight abuse here and extend the corresponding`Homset` to take nonzero degree maps.


---

Comment by jhpalmieri created at 2021-09-10 21:00:34

For now I am going to allow maps of nonzero degree, just because it makes it much easier to construct such maps.


---

Comment by jhpalmieri created at 2021-09-12 00:00:11

I've created #32505 and I will push a branch there soon.


---

Comment by jhpalmieri created at 2021-09-12 00:09:39

Comments on some changes made from here to #32505:

- Sage's other free module constructors take the ring/algebra as the first argument, so I've made the code here be consistent with that.
- I switched to use `CombinatorialFreeModule` for the modules, `IndexedFreeModuleElement` for the elements. The finitely presented modules are not free over the corresponding algebras, but they are of course free over the base fields, and that's good enough for me.
- As a result, the element classes no longer have `__init__` methods.


---

Comment by jhpalmieri created at 2021-09-15 20:47:29

Changing status from needs_review to needs_work.


---

Comment by jhpalmieri created at 2021-09-15 20:47:29

Marking as "needs work" because we should deal with #32505 first, then build this on top of that.


---

Comment by git created at 2022-02-01 23:56:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by jhpalmieri created at 2022-02-02 00:04:12

Here is a branch so that we can start working on this, now that #32505 is positively reviewed. I did some clean-up on the old code, and it's almost all working, but not quite. I think that the problem is this: morphisms between finitely presented modules over the Steenrod algebra (the class of modules is currently called `FPA_Module`) is not quite behaving the way I want, and in particular, some of the time, domains and codomains of such morphisms are not in the class `FPA_Module` anymore. It is important that they be in this class because the code is using special properties of the Steenrod algebra to determine, for example, whether a morphism is injective: given two finitely presented modules, one can find a finite-dimensional subalgebra B such that a morphism as A-modules is injective if and only if it is injective as a B-module map. The case over the finite subalgebra is tractable.

But if we can't remember where the objects live, then we lose these special methods for A-modules, and so we get doctest failures. I'm seeing a few failures in `module.py`, I think all due to this.

By the way, I rewrote lots of `profile.py` and added a few doctests for odd primes, although we don't have any odd primary examples in the rest of the code. The new version of `find_min_profile` is about 10 times faster than the old version. When I get around to it, I will try some odd primary examples of modules and morphisms. Should I expect those to work?


---

Comment by jhpalmieri created at 2022-02-02 00:17:53

The first two doctest failures:

```
sage -t --random-seed=52206228944996655655996976540735053542 src/sage/modules/fp_graded/steenrod/module.py
**********************************************************************
File "src/sage/modules/fp_graded/steenrod/module.py", line 484, in sage.modules.fp_graded.steenrod.module
Failed example:
    h.is_injective()        # Is ker(f) contained in K ?
Exception raised:
    Traceback (most recent call last):
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/doctest/forker.py", line 694, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/doctest/forker.py", line 1088, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.modules.fp_graded.steenrod.module[94]>", line 1, in <module>
        h.is_injective()        # Is ker(f) contained in K ?
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py", line 1634, in is_injective
        j0 = self._resolve_kernel(top_dim, verbose)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py", line 1752, in _resolve_kernel
        raise ValueError('a top dimension must be specified for this calculation to terminate')
    ValueError: a top dimension must be specified for this calculation to terminate
**********************************************************************
File "src/sage/modules/fp_graded/steenrod/module.py", line 540, in sage.modules.fp_graded.steenrod.module
Failed example:
    res = Hko.resolution(6, verbose=True)
Exception raised:
    Traceback (most recent call last):
      File "sage/misc/cachefunc.pyx", line 1943, in sage.misc.cachefunc.CachedMethodCaller.__call__ (build/cythonized/sage/misc/cachefunc.c:10347)
        return cache[k]
    KeyError: ((2,), ())

    During handling of the above exception, another exception occurred:

    Traceback (most recent call last):
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/vector_space_homspace.py", line 395, in __call__
        v = [C(a) for a in A]
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/vector_space_homspace.py", line 395, in <listcomp>
        v = [C(a) for a in A]
      File "sage/structure/parent.pyx", line 898, in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9388)
        return mor._call_(x)
      File "sage/structure/coerce_maps.pyx", line 161, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4665)
        raise
      File "sage/structure/coerce_maps.pyx", line 156, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4557)
        return C._element_constructor(x)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py", line 5769, in _element_constructor_
        return FreeModule_generic_field._element_constructor_(self, e, *args, **kwds)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py", line 1118, in _element_constructor_
        return self.element_class(self, x, coerce, copy)
      File "sage/modules/vector_mod2_dense.pyx", line 200, in sage.modules.vector_mod2_dense.Vector_mod2_dense.__init__ (build/cythonized/sage/modules/vector_mod2_dense.cpp:3952)
        raise TypeError("x must be a list of the right length")
    TypeError: x must be a list of the right length

    During handling of the above exception, another exception occurred:

    Traceback (most recent call last):
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/doctest/forker.py", line 694, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/doctest/forker.py", line 1088, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.modules.fp_graded.steenrod.module[105]>", line 1, in <module>
        res = Hko.resolution(Integer(6), verbose=True)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/steenrod/module.py", line 1049, in resolution
        res = FPModule.resolution(
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/module.py", line 1269, in resolution
        ret_complex.append(f._resolve_kernel(top_dim=top_dim,
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py", line 1768, in _resolve_kernel
        self_n = self.vector_presentation(n)
      File "sage/misc/cachefunc.pyx", line 1948, in sage.misc.cachefunc.CachedMethodCaller.__call__ (build/cythonized/sage/misc/cachefunc.c:10483)
        w = self._instance_call(*args, **kwds)
      File "sage/misc/cachefunc.pyx", line 1824, in sage.misc.cachefunc.CachedMethodCaller._instance_call (build/cythonized/sage/misc/cachefunc.c:9949)
        return self.f(self._instance, *args, **kwds)
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py", line 913, in vector_presentation
        return Hom(D_n, C_n)([C_n.zero() if e.is_zero() else e.vector_presentation()
      File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.5/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/vector_space_homspace.py", line 399, in __call__
        raise ArithmeticError(msg)
    ArithmeticError: some proposed image is not in the codomain, because
    x must be a list of the right length
```

(There are others which fail because `res` is not defined after line 540 fails.)

The first failure is definitely because of the issue I mentioned above: the code should auto-detect an appropriate finite-dimensional algebra to work over, in which case we should not have to specify a top dimension, but clearly something is going wrong. I think that one of the morphisms is in the class `FPMorphism` rather than the Steenrod-specific `FPA_Morphism`. An example:

```
sage: from sage.modules.fp_graded.steenrod.module import FPA_Module
sage: A = SteenrodAlgebra()
sage: Hko = FPA_Module(A, [0], [[Sq(2)], [Sq(1)]])
sage: gen = Hko.generator(0)
sage: homspace = Hom(Hko, Hko)
sage: values = [Sq(0, 0, 1)*gen]
sage: f = homspace(values)

sage:  # Good so far:

sage: type(f)
<class 'sage.modules.fp_graded.steenrod.homspace.FPA_ModuleHomspace_with_category_with_equality_by_id.element_class'>
sage: k = f.kernel_inclusion()
sage: type(k)
<class 'sage.modules.fp_graded.steenrod.homspace.FPA_ModuleHomspace_with_category_with_equality_by_id.element_class'>
sage: coker = k.cokernel_projection()
sage: type(coker)
<class 'sage.modules.fp_graded.steenrod.homspace.FPA_ModuleHomspace_with_category_with_equality_by_id.element_class'>

sage: # But this is a problem:

sage: type(coker.codomain())
<class 'sage.modules.fp_graded.module.FPModule_with_category'>
```

It should be `FPA_Module_with_category`. I don't know why this codomain is not in the right class.


---

Comment by jhpalmieri created at 2022-02-02 00:32:59

I can fix the first problem by defining a method `cokernel_projection` for `FPA_Morphism`, just reproducing the code for `FPMorphism`. I don't know if there is a better solution. I'm now working on the other doctest failure.


---

Comment by git created at 2022-02-02 02:59:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-02 03:05:22

Okay, I found a bug and fixed it, and that took care of most of the problems. Something like the first issue I mentioned is still occurring: I don't know how to naturally force a morphism to be in the right class. The remaining failure comes from this doctest:

```
    sage: def is_exact(res):
    ....:     for i in range(len(res)-1):
    ....:         h = res[i].homology(res[i+1])
    ....:         if not h.codomain().is_trivial():
    ....:             return False
    ....:     return True

    sage: is_exact(res)
    True
```

The problem is that the maps in `res` are maps of `FreeGradedModules`, so they are not in the Steenrod-specific world, so the `homology` computation doesn't work.

-----

In case you're interested, the bug is a subtle one in the code from #32505: to compute the coefficients of an element in a free module, we were using

```
        return self.dense_coefficient_list()
```

but the default ordering for the coefficients is in increasing order of degree, not the specified order for the generators. We were hitting a situation in which this mattered, and changing to this fixed it:

```
        order = self.parent()._indices
        return self.dense_coefficient_list(order)
```

I will add some doctests that capture this.


---

Comment by git created at 2022-02-02 03:09:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-02-02 03:12:01

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jhpalmieri created at 2022-02-02 03:14:28

We should now be at 100% coverage and one doctest failure. I'm sure there are typos and plenty of room for other improvements, but just about everything is now working. I still haven't tried odd primes.


---

Comment by tscrim created at 2022-02-02 03:17:04

One quick thought is to add an attribute or someway to let the morphism code know what type of modules to create. It might work by using `type(self.codomain())` or similar (with perhaps some care to make sure it is not the category-mangled object). This would avoid a lot of code and documentation duplication with making it more future-proof.

I am quite surprised by this bug and slightly worried because it should not matter about the order (as long as internally each class knows how to go back and forth between consistently).


---

Comment by git created at 2022-02-02 04:21:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jhpalmieri created at 2022-02-02 04:27:19

I wonder if there is some simple modification to the code for `resolution` for Steenrod algebra modules:

```python
    def resolution(self, k, top_dim=None, verbose=False):
        """
        (documentation omitted)
        """
        algebra = self.base_ring()
        finite_algebra = SteenrodAlgebra_generic(algebra.prime(), profile=self.profile())

        # Change rings to the finite algebra, and call the base class
        # implementation of this function.
        res = FPModule.resolution(
            self.change_ring(finite_algebra),
            k,
            top_dim=top_dim,
            verbose=verbose)

        # Change rings back to the original Steenrod algebra.
        return [j.change_ring(self.base_ring()) for j in res]
```

Something at the end that does more than just change the ring, but also forces the morphism to have the right class. This code explicitly calls `FPModule.resolution`, and that's probably the root of the problem. We could completely duplicate the general resolution code to the Steenrod algebra setting, but there must be a better way.

By the way, although `A` is a standard thing for homotopy theorists to call the Steenrod algebra, `FPA_Module` is not the most evocative name, I think. `SteenrodModule`? `SteenrodFPModule`? What should we call the class? (Have to get a jump on the bike-shedding.)


---

Comment by jhpalmieri created at 2022-02-02 04:56:47

Replying to [comment:63 jhpalmieri]:
> I wonder if there is some simple modification to the code for `resolution` for Steenrod algebra modules:

> Something at the end that does more than just change the ring, but also forces the morphism to have the right class. This code explicitly calls `FPModule.resolution`, and that's probably the root of the problem.

We could, for example, change each map by reconstructing each domain and codomain, using FPA_Module to instantiate them, and then reconstructing each morphism. It should be easy to write a method or a private function that does this.


---

Comment by jhpalmieri created at 2022-02-02 16:36:03

Replying to [comment:61 tscrim]:
> I am quite surprised by this bug and slightly worried because it should not matter about the order (as long as internally each class knows how to go back and forth between consistently).

Indeed, my "fix" has broken something. This works:

```
sage: from sage.modules.fp_graded.free_module import FreeGradedModule
sage: F.<x,y> = FreeGradedModule(A, (2, 0))
sage: x.degree()
2
sage: y.degree()
0
```

This doesn't:

```
sage: from sage.modules.fp_graded.module import FPModule
sage: A = SteenrodAlgebra()
sage: M.<x,y> = FPModule(A, (2, 0))
sage: x.degree()
0
sage: y.degree()
2
```

To compute the degree of an element of an `FPModule`, it first computes a lift to a free module and then computes the degree there, but when computing that lift, it mixes up the order of the generators.

```
sage: x.lift_to_free()
y
```

This is somehow due to imposing the order in `coefficients`.


---

Comment by jhpalmieri created at 2022-02-02 16:47:45

This fixes some of these problems, although I think I still need to specify the order in `dense_coefficient_list`:

```diff
diff --git a/src/sage/modules/fp_graded/element.py b/src/sage/modules/fp_graded/element.py
index 87f52b759a..51d48f405e 100755
--- a/src/sage/modules/fp_graded/element.py
+++ b/src/sage/modules/fp_graded/element.py
@@ -122,7 +122,7 @@ class FPElement(IndexedFreeModuleElement):
             sage: y.coefficients()
             [0, Sq(2)]
         """
-        return [self[i] for i in sorted(self.parent().indices())]
+        return [self[i] for i in self.parent().indices()]
 
 
     def _lmul_(self, a):
```



---

Comment by jhpalmieri created at 2022-02-02 17:57:13

Let's work on the bugs in finitely presented modules in #33275 (I hope quickly) and then deal with the issues specific to the Steenrod algebra here.


---

Comment by git created at 2022-02-02 18:01:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-02-02 18:03:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-02-03 05:46:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-02-03 05:55:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-02-03 06:08:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-02-03 09:18:27

I don't know for your other questions off the top of my head (I am out the door to go back home now), but I am a big +1 for renaming to something like `SteenrodFPModule`. I will think about the other questions and reply tomorrow.


---

Comment by git created at 2022-02-03 17:48:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-02-04 03:25:02

Thank you.

Okay, so I have two ways out of this issue of not having the correct class specified when building, e.g., the resolution:

1. We introduce a method, say, `_graded_module_class()` (that takes a parameter `free`) that returns the corresponding class.
2. We use `type(self.codomain())` and attach, via an attribute, the free module class to each FP module.

I am maybe slightly preferential towards 2 since it is local to the module implementation (which is what needs this information) rather than more global to the algebras. We might have some consistency issues to address (such as the free modules not taking a morphism as defining information), but these will likely improve the overall quality and robustness of the code.


---

Comment by jhpalmieri created at 2022-02-06 22:10:57

To make sure we're on the same page, there are (I think) two problems with `resolution`: (a) if `M` is an instance of `SteenrodFPModule`, then `M.resolution(...)` forgets that and returns morphisms that come from `FPModule` (or `FreeGradedModule`) rather than `SteenrodFPModule`. Then (b) if I fix that by converting all of the morphism back to `SteenrodFPModuleMorphism`, the resulting objects are not recognized as free, so for example they will be described in the string representation as being "finitely presented."

I think that since we used `FreeGradedModule` more than was originally planned by the authors in #32505, we may now need `SteenrodFreeModule` and similar classes for morphisms and homspaces.


---

Comment by jhpalmieri created at 2022-02-06 22:11:24

Here is what I'm currently using to convert the maps:

```diff
diff --git a/src/sage/modules/fp_graded/steenrod/module.py b/src/sage/modules/fp_graded/steenrod/module.py
index c74ed1535ca..9a19a87f65f 100755
--- a/src/sage/modules/fp_graded/steenrod/module.py
+++ b/src/sage/modules/fp_graded/steenrod/module.py
@@ -827,6 +827,7 @@ AUTHORS:
 #                  https://www.gnu.org/licenses/
 # ****************************************************************************
 
+from sage.categories.homset import Hom
 from sage.rings.infinity import infinity
 from sage.algebras.steenrod.steenrod_algebra import SteenrodAlgebra_generic
 from sage.modules.fp_graded.module import FPModule
@@ -1056,7 +1057,7 @@ class SteenrodFPModule(FPModule):
             verbose=verbose)
 
         # Change rings back to the original Steenrod algebra.
-        return [j.change_ring(self.base_ring()) for j in res]
+        return [convert_map(j.change_ring(self.base_ring())) for j in res]
 
 
     def export_module_definition(self, powers_of_two_only=True):
@@ -1181,3 +1182,21 @@ class SteenrodFPModule(FPModule):
                             len(values),
                             " ".join(["%d" % x for x in values])))
                     element_index += 1
+
+
+def convert_map(f):
+    if f.domain().has_relations():
+        D = SteenrodFPModule(f.domain()._j)
+    else:
+        try:
+            D = SteenrodFPModule(f.domain()._free_module())
+        except AttributeError:
+            D = SteenrodFPModule(f.domain().base_ring(), f.domain()._generator_degrees)
+    if f.codomain().has_relations():
+        C = SteenrodFPModule(f.codomain()._j)
+    else:
+        try:
+            C = SteenrodFPModule(f.codomain()._free_module())
+        except AttributeError:
+            C = SteenrodFPModule(f.codomain().base_ring(), f.codomain()._generator_degrees)
+    return Hom(D, C)(f.values())
```



---

Comment by jhpalmieri created at 2022-02-07 00:58:26

Maybe you're proposing that we don't have to do an explicit conversion of the maps if we handle free modules over the Steenrod algebra differently.


---

Comment by tscrim created at 2022-02-07 01:41:25

I think the code is trying telling us something here. With everything being a free module (and we don't have a special class for free modules over the Steenrod algebra), we should not need to change anything with the resolution. Likely there is an incompatibility between the classes. Perhaps we just need a `change_ring()` in the free module code that calls the new ring's `free_graded_module()` method? Any subsequent failures likely means that we need to add methods to the free module and/or subclass it for the Steenrod algebra as per your comment:77. We might also want to consider having different tests for freeness via the `has_relations()` method, which now that I think of it should be refactored to an `is_free()` method (or perhaps the latter method just added).

Actually, in comment:76, we already basically have 1. with the `free_graded_module()` method to the `base_ring()`. We might want to actually use that instead in `resolution()`.


---

Comment by git created at 2022-02-07 18:54:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-07 21:00:20

I have an alternate proposal for some of this: change various `_repr_` methods. I don't see why free module morphisms need to be written as "Free module morphism from Free module ...", so I propose changing it to "Module morphism from Free module ...". The information about the types of modules is still there in the domain and codomain.

Also, for modules which are defined as `FPModule` but with no relations, why not print those as "Free graded left module on 3 generators" rather than "Finitely presented left module on 3 generators and 0 relations"? Whether they are an instance of `FPModule` or `FreeGradedModule`, the print representation could be the same.


---

Comment by tscrim created at 2022-02-08 01:54:22

Both of those are fine with me, but it could make it harder to detect incompatibilities between the objects as we would need to look at the `type` rather than the printing output. Although I don't think the particular repr output for the resolution is so important though since it is just updating some doctests.


---

Comment by git created at 2022-02-08 04:36:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-02-08 04:42:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-02-08 23:36:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-08 23:39:40

Changing status from needs_work to needs_review.


---

Comment by jhpalmieri created at 2022-02-08 23:39:40

Here's a patch that implements the conversion. In order to make the conversion as nice as possible, including keeping track of the names of the generators, I added an argument `names` to the main `Module` class (in `sage/modules/module.pyx`): that class already calls `Parent.__init__(...)` and `Parent` can take a `names` argument, so this seemed like the best way to manage names for module generators. This was already done in the free module case because `CombinatorialFreeModule` handles names right, but in the non-free case we are just using `Module.__init__(...)`.

Everything in `sage/modules` passes tests for me. I'll run full tests, too, but meanwhile I'm marking this as "needs review".


---

Comment by jhpalmieri created at 2022-02-08 23:45:06

By the way, it would be nice to add some odd primary examples. I will try to work on that, but I'm happy for suggestions/contributions, too.


---

Comment by jhpalmieri created at 2022-02-09 04:39:19

The first odd primary example I tried didn't work. First I found a few bugs:

```diff
diff --git a/src/sage/modules/fp_graded/steenrod/module.py b/src/sage/modules/fp_graded/steenrod/module.py
index 5160ad7351a..21b81b10838 100755
--- a/src/sage/modules/fp_graded/steenrod/module.py
+++ b/src/sage/modules/fp_graded/steenrod/module.py
@@ -941,7 +941,8 @@ class SteenrodFPModule(FPModule):
 
         elements = [a for a in elements if a not in (0, 1)]
 
-        profile = enveloping_profile_elements(elements)
+        profile = enveloping_profile_elements(elements,
+                                              char=self.base_ring().characteristic())
 
         # Avoid returning the zero profile because it triggers a corner case
         # in FPModule.resolution().
diff --git a/src/sage/modules/fp_graded/steenrod/morphism.py b/src/sage/modules/fp_graded/steenrod/morphism.py
index c5be7ba71ff..f35ae0f1117 100755
--- a/src/sage/modules/fp_graded/steenrod/morphism.py
+++ b/src/sage/modules/fp_graded/steenrod/morphism.py
@@ -141,7 +141,8 @@ class SteenrodFPModuleMorphism(FPModuleMorphism):
 
         elements = [a for a in elements if a not in (0, 1)]
 
-        profile = enveloping_profile_elements(elements)
+        profile = enveloping_profile_elements(elements,
+                                              char=self.base_ring().characteristic())
 
         # Avoid returning the zero profile because it triggers a corner case
         # in FPModule.resolution().
```

Then this happens:

```
sage: from sage.modules.fp_graded.steenrod.module import SteenrodFPModule
sage: A3 = SteenrodAlgebra(3)
sage: M = SteenrodFPModule(A3, [0], [[A3.P(3)]])
sage: res = M.resolution(3, verbose=True)
Computing f_1 (1/3)
Computing f_2 (2/3)
Resolving the kernel in the range of dimensions [12, 76]: 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76.
Computing f_3 (3/3)
Resolving the kernel in the range of dimensions [44, 116]: 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in quotient(self, sub, check)
   4530             try:
-> 4531                 sub = self.subspace(sub)
   4532             except (TypeError, ArithmeticError):

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in subspace(self, gens, check, already_echelonized)
   4089         """
-> 4090         return self.submodule(gens, check=check, already_echelonized=already_echelonized)
   4091 

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in submodule(self, gens, check, already_echelonized)
   3358             if not V.is_submodule(self):
-> 3359                 raise ArithmeticError("Argument gens (= %s) does not generate a submodule of self."%gens)
   3360         return V

TypeError: not all arguments converted during string formatting

During handling of the above exception, another exception occurred:

ArithmeticError                           Traceback (most recent call last)
<ipython-input-4-71aff3686c72> in <module>
----> 1 res = M.resolution(Integer(3), verbose=True)

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/steenrod/module.py in resolution(self, k, top_dim, verbose)
   1050         # Change rings to the finite algebra, and call the base class
   1051         # implementation of this function.
-> 1052         res = FPModule.resolution(
   1053             self.change_ring(finite_algebra),
   1054             k,

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/module.py in resolution(self, k, top_dim, verbose)
   1273 
   1274             f = ret_complex[i-1]
-> 1275             ret_complex.append(f._resolve_kernel(top_dim=top_dim,
   1276                                                  verbose=verbose))
   1277 

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py in _resolve_kernel(self, top_dim, verbose)
   1786 
   1787             else:
-> 1788                 Q_n = kernel_n.quotient(j.vector_presentation(n).image())
   1789 
   1790                 if not Q_n.rank():

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in quotient(self, sub, check)
   4531                 sub = self.subspace(sub)
   4532             except (TypeError, ArithmeticError):
-> 4533                 raise ArithmeticError("sub must be a subspace of self")
   4534         A, L = self.__quotient_matrices(sub)
   4535         from . import quotient_module

ArithmeticError: sub must be a subspace of self
```

If I use `M = SteenrodFPModule(A3, [0], [This is the Trac macro *A3.P* that was inherited from the migration called with arguments (1))](https://trac.sagemath.org/wiki/WikiMacros#A3.P-macro))`, everything seems to work, but it fails with `SteenrodFPModule(A3, [0], [This is the Trac macro *A3.P* that was inherited from the migration called with arguments (?))](https://trac.sagemath.org/wiki/WikiMacros#A3.P-macro))` where `?` is replaced with any number 3 or larger. Similar at the prime 5: `SteenrodFPModule(A5, [0], [This is the Trac macro *A5.P* that was inherited from the migration called with arguments (5))](https://trac.sagemath.org/wiki/WikiMacros#A5.P-macro)).resolution(3)` fails.


---

Comment by jhpalmieri created at 2022-02-09 06:11:35

To reproduce the problem:

```
sage: from sage.modules.fp_graded.steenrod.module import SteenrodFPModule
sage: A3 = SteenrodAlgebra(3)
sage: F0 = SteenrodFPModule(A3, [44, 52])
sage: F1 = SteenrodFPModule(A3, [12])
sage: g12 = F1.generator(0)
sage: f = Hom(F0, F1)([A3.P(8)*g12, (A3.P(2,2) + A3.P(6,1))*g12])
sage: f
Module morphism:
  From: Free graded left module on 2 generators over mod 3 Steenrod algebra, milnor basis
  To:   Free graded left module on 1 generator over mod 3 Steenrod algebra, milnor basis
  Defn: g[44] |--> P(8)*g[12]
        g[52] |--> (P(2,2)+P(6,1))*g[12]
sage: f._resolve_kernel()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in quotient(self, sub, check)
   4530             try:
-> 4531                 sub = self.subspace(sub)
   4532             except (TypeError, ArithmeticError):

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in subspace(self, gens, check, already_echelonized)
   4089         """
-> 4090         return self.submodule(gens, check=check, already_echelonized=already_echelonized)
   4091 

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in submodule(self, gens, check, already_echelonized)
   3358             if not V.is_submodule(self):
-> 3359                 raise ArithmeticError("Argument gens (= %s) does not generate a submodule of self."%gens)
   3360         return V

TypeError: not all arguments converted during string formatting

During handling of the above exception, another exception occurred:

ArithmeticError                           Traceback (most recent call last)
<ipython-input-45-219e86205adc> in <module>
----> 1 f._resolve_kernel()

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/steenrod/morphism.py in _resolve_kernel(self, top_dim, verbose)
    360                     g[3, 1] |--> Sq(3)*g[0, 0]
    361         """
--> 362         return self._action(FPModuleMorphism._resolve_kernel, verbose)
    363 
    364 

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/steenrod/morphism.py in _action(self, method, verbose)
    427         # Perform the chosen action on the module after having changed rings
    428         # to the finite algebra.
--> 429         fp_result = method(
    430             self.change_ring(finite_algebra),
    431             verbose=verbose)

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py in _resolve_kernel(self, top_dim, verbose)
   1793                     print('im(j):    {}'.format(j.vector_presentation(n).image()))
   1794 
-> 1795                 Q_n = kernel_n.quotient(j.vector_presentation(n).image())
   1796 
   1797                 if not Q_n.rank():

~/Desktop/Sage/git/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/modules/free_module.py in quotient(self, sub, check)
   4531                 sub = self.subspace(sub)
   4532             except (TypeError, ArithmeticError):
-> 4533                 raise ArithmeticError("sub must be a subspace of self")
   4534         A, L = self.__quotient_matrices(sub)
   4535         from . import quotient_module

ArithmeticError: sub must be a subspace of self
```



---

Comment by git created at 2022-02-09 21:24:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-09 21:26:17

I have not tracked down the odd primary bug, but I did edit the documentation: minor rewordings, modified some lines that were too long, etc. I also fixed the two small bugs mentioned in comment:89.


---

Comment by jhpalmieri created at 2022-02-09 22:42:01

A very slightly simpler example that fails:

```
sage: from sage.modules.fp_graded.steenrod.module import SteenrodFPModule
sage: A3 = SteenrodAlgebra(3)
sage: F0 = SteenrodFPModule(A3, [32, 40])
sage: F1 = SteenrodFPModule(A3, [0])
sage: g0 = F1.generator(0)
sage: f = Hom(F0, F1)([A3.P(8)*g0, (A3.P(6,1))*g0])
```



---

Comment by jhpalmieri created at 2022-02-09 23:30:35

For what it's worth, I see the same bug if I use the original code posted to this ticket back in the dawn of time.


---

Comment by tscrim created at 2022-02-10 01:55:55

I want to get rid of the `_convert_map` function as it is not sustainable if we start adding in other algebra specific FP modules. It also doesn't seem very efficient to me either. Anything I should pay attention to or be careful with this?

I will also look into the comment:90 / comment:93 bug too.


---

Comment by jhpalmieri created at 2022-02-10 02:27:39

Replying to [comment:95 tscrim]:
> I want to get rid of the `_convert_map` function as it is not sustainable if we start adding in other algebra specific FP modules. It also doesn't seem very efficient to me either. Anything I should pay attention to or be careful with this?

Not that I can think of.
 
> I will also look into the comment:90 / comment:93 bug too.

I wonder if somewhere we're assuming that all nonzero field coefficients are 1, so something gets screwed up in occasional situations in characteristics other than 2. That's just a guess, though. I'm pretty sure that the problem is in `_resolve_kernel`, in any case.


---

Comment by tscrim created at 2022-02-10 04:18:52

Making the `FPModule` return the corresponding free module when it has no relations has been great for finding bugs and incompatibilities between the two objects. Right now I am at figuring this one out:

```
sage: A = SteenrodAlgebra(2)
sage: F = A.free_graded_module([0])
sage: G = A.free_graded_module([-1])
sage: H = Hom(G, F)
sage: H._basis_elements(0, False)
Module morphism:
  From: Free graded left module on 1 generator over mod 2 Steenrod algebra, milnor basis
  To:   Free graded left module on 1 generator over mod 2 Steenrod algebra, milnor basis
  Defn: g[-1] |--> 0
```

The exterior algebra has the same behavior:

```
sage: E.<x,y,z> = ExteriorAlgebra(QQ)
sage: F = E.free_graded_module([0])
sage: G = E.free_graded_module([-1])
sage: H = Hom(G, F)
sage: H._basis_elements(0, True)
[Module morphism:
   From: Free graded left module on 1 generator over The exterior algebra of rank 3 over Rational Field
   To:   Free graded left module on 1 generator over The exterior algebra of rank 3 over Rational Field
   Defn: g[-1] |--> 0]
sage: H._basis_elements(1, False)
Module morphism:
  From: Free graded left module on 1 generator over The exterior algebra of rank 3 over Rational Field
  To:   Free graded left module on 1 generator over The exterior algebra of rank 3 over Rational Field
  Defn: g[-1] |--> 0
sage: H._basis_elements(1, True)
/home/travis/sage-build/local/lib/python3.9/site-packages/sage/modules/free_module.py:236: UserWarning: You are constructing a free module
over a noncommutative ring. Sage does not have a concept
of left/right and both sided modules, so be careful.
It's also not guaranteed that all multiplications are
done from the right side.
  warn("""You are constructing a free module
```

The last computation finished quite quickly for `A` but the last one didn't finish within 1 minute on my laptop (and `E` is an 8 dimensional skew-commutative algebra!). My guess is this is accidentally passing the algebra somehow rather than the underlying scalar ring for the algebra, which is why we get the warning.

I suspect the fix to the first bug is simply checking if the corresponding morphism is the zero morphism or not.

I also removed the `_repr_` as I think it is useful to distinguish when someone has passed something that is secretly free but is not such a class. This is was useful for me to tell when  was `Hom` not being an endomorphism space despite the output suggesting it was. Since basically all things that are free will be a `FreeGradedModule` (or a subclass), I think this will obtain the print representation you wanted.

There are also a few other tests failing that I don't yet know why.

I am going to get lunch now and do a little bit of other work. I will return to this later today.
----
New commits:


---

Comment by tscrim created at 2022-02-10 05:24:45

I traced the problem down to this difference in behaviour:

```
sage: F = FPModule(A, [0], [[]])
sage: Gp = FPModule(A, [-1], [[0]])
sage: Fp = FPModule(A, [0], [[]])
sage: F = E.free_graded_module([0])
sage: G = E.free_graded_module([-1])

sage: F[G.gen(0).degree() + 0]
Vector space of dimension 0 over Rational Field
sage: Fp[Gp.gen(0).degree() + 0]
()
```

So I can fix the symptom easily enough by not using `__getitem__` in the code (which I think is better anyways for the explicitness). However, we should (quickly) decide which behavior we want and change one of these.


---

Comment by git created at 2022-02-10 05:27:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-10 05:46:50

I agree that we should avoid using `__getitem__` in the code. I think if `__getitem__(n)` should mean anything, then it should mean the `n`th homogeneous piece as a vector space rather than a basis (is that what it's doing?) for that space.

Re your comment "FIXME: Do not rely on this behavior!" in profile.py: why not? It is documented Python behavior.


---

Comment by tscrim created at 2022-02-10 05:51:08

Replying to [comment:100 jhpalmieri]:
> I agree that we should avoid using `__getitem__` in the code. I think if `__getitem__(n)` should mean anything, then it should mean the `n`th homogeneous piece as a vector space rather than a basis (is that what it's doing?) for that space.

I agree as well. I will make the corresponding change.

> Re your comment "FIXME: Do not rely on this behavior!" in profile.py: why not? It is documented Python behavior.

Yes, but they could decide to change it in a future version. IMO, we should avoid as much as possible treating unordered objects as having a specified order. I think this is more future-proof  in case we end up doing some alteration to the `dict`.


---

Comment by tscrim created at 2022-02-10 05:54:51

Question regarding the general graded modules: Why do we have a more interesting `an_element` for the `FPModuleHomset` that we override for `FreeModuleHomset` (which is just the zero morphism)? (I recognize that previously they were separate classes, but the underlying question still remains why the free one is a more boring element.)


---

Comment by tscrim created at 2022-02-10 08:03:25

I have fixed a the `__getitem__` and a number of other compatibility issues (such as not passing `top_dim` along). There are still the following:

- The `FIXME`/`TODO` I have marked.
- Returning a free module once we remove all trivial relations. This will likely require us to update some doctests.
- Some trivial output difference because of the new Steenrod modules and verbose output. Likely we will just update the output, but I wanted to see if we wanted to actually change the objects we are testing.
- Go over the entire documentation to look for other ways to improve it.
- Fixing the comment:90 bug.

With regards to the comment:90 bug, it is deeper than the Steenrod algebra:

```
sage: from sage.modules.fp_graded.module import FPModule
sage: s = SymmetricFunctions(QQ).s()
sage: F = s.free_graded_module([0,0])
sage: L = FPModule(s, [0,0], [[s[3],s[2,1]], [0,s[2]]])
sage: f = Hom(F, L)([L([s[2], 0]), L([0, s[2]])])
sage: f._resolve_kernel()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
~/sage-build/local/lib/python3.9/site-packages/sage/modules/free_module.py in quotient(self, sub, check)
   4530             try:
-> 4531                 sub = self.subspace(sub)
   4532             except (TypeError, ArithmeticError):

~/sage-build/local/lib/python3.9/site-packages/sage/modules/free_module.py in subspace(self, gens, check, already_echelonized)
   4089         """
-> 4090         return self.submodule(gens, check=check, already_echelonized=already_echelonized)
   4091 

~/sage-build/local/lib/python3.9/site-packages/sage/modules/free_module.py in submodule(self, gens, check, already_echelonized)
   3358             if not V.is_submodule(self):
-> 3359                 raise ArithmeticError("Argument gens (= %s) does not generate a submodule of self."%gens)
   3360         return V

TypeError: not all arguments converted during string formatting

During handling of the above exception, another exception occurred:

ArithmeticError                           Traceback (most recent call last)
<ipython-input-2-f807e560671a> in <module>
      4 L = FPModule(s, [Integer(0),Integer(0)], [[s[Integer(3)],s[Integer(2),Integer(1)]], [Integer(0),s[Integer(2)]]])
      5 f = Hom(F, L)([L([s[Integer(2)], Integer(0)]), L([Integer(0), s[Integer(2)]])])
----> 6 f._resolve_kernel(top_dim=Integer(10))

~/sage-build/local/lib/python3.9/site-packages/sage/modules/fp_graded/morphism.py in _resolve_kernel(self, top_dim, verbose)
   1783 
   1784             else:
-> 1785                 Q_n = kernel_n.quotient(j.vector_presentation(n).image())
   1786 
   1787                 if not Q_n.rank():

~/sage-build/local/lib/python3.9/site-packages/sage/modules/free_module.py in quotient(self, sub, check)
   4531                 sub = self.subspace(sub)
   4532             except (TypeError, ArithmeticError):
-> 4533                 raise ArithmeticError("sub must be a subspace of self")
   4534         A, L = self.__quotient_matrices(sub)
   4535         from . import quotient_module

ArithmeticError: sub must be a subspace of self
```

I am not sure how to make this smaller. Yet at least it is likely more "simple" because it for an infinite commutative graded algebra of characteristic 0 and exists without this new specific code.
----
New commits:


---

Comment by jhpalmieri created at 2022-02-10 19:54:39

Regarding "User guide  FIXME: Find a better title, possibly (re)move header": I think it is useful to have the previous section "Theoretical background," and so it is useful to have a new section to mark the end of that one. We could call it "Implementation" instead. Other ideas?

Regarding "# FIXME: This seems circular as FPModule builds a morphism": this is in the `cokernel_projection` method for morphisms. I would be concerned if the `__init__` method for morphisms relied on constructing modules and vice versa, but I don't see a problem with this.

It's easy to change `profile.py`:

```diff
diff --git a/src/sage/modules/fp_graded/steenrod/profile.py b/src/sage/modules/fp_graded/steenrod/profile.py
index fa2f78f6d10..679ac0c23af 100755
--- a/src/sage/modules/fp_graded/steenrod/profile.py
+++ b/src/sage/modules/fp_graded/steenrod/profile.py
@@ -228,10 +228,6 @@ def find_min_profile(prof, char=2):
         for i in range(1, max(P)+1):
             if P[i-1] > j and newQ[j] == 2:
                 newQ[i+j] = 2
-    # Convert the dictionary back to a list. As of Python 3.7,
-    # converting values of a dictionary to a list or tuple will result
-    # in the expected order:
-    # https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6/39980744#39980744
-    # FIXME: Do not rely on this behavior!
-    return (P, tuple(newQ.values()))
-
+    # Convert the dictionary back to a list.
+    Q = [newQ[i] for i in sorted(newQ)]
+    return (P, tuple(Q))
```


By the way, I tried using all of this with instances of `GradedCommutativeAlgebra` and ran into problems. It would be nice if we could use the classes here with those graded commutative algebras. (I think I fixed them by defining an alias `coefficients = basis_coefficients` and defining a `rank` method for those algebras.) That could wait for a followup ticket.


---

Comment by jhpalmieri created at 2022-02-10 22:57:04

I made the change in `profile.py`.
----
New commits:


---

Comment by tscrim created at 2022-02-11 02:22:04

Here is my proposal for the documentation: To move the (very nice) explanation of the modules to its own thematic tutorial. Since it is more of a walkthrough of the capabilities of the code and longer, I felt this was a more natural place for it. In part because the best title I could come up with for that section was "tutorial."

For the `#FIXME` in the `cokernel_projection`, I was thinking the morphism that was being created was basically the one defining the cokernel. However this is not the case when the domain is not a free module. So I removed this.

For GCAs, those are not in `GradedModulesWithBasis`, so it is not so surprising to me they do not work. That being said, they are implemented essentially with a distinguished basis and are already basically in this category. (I have the same gripe about polynomial rings too.) Thus, it should be easy enough to make them work. Another thing I would like to do is rewrite it without using plural, which would likely make it a bit easier to put it in `GradedModulesWithBasis`.

I tweaked the `profile()` to avoid going through a `dict`, so it should be faster (not that it was necessarily a bottleneck before).

I renamed `min_presentation()` to `minimal_presentation()` to be more explicit. I don't think we need to deprecate it since this should be merged before the next release. We can setup an (deprecated) alias if we want too.

All that is left is the `_resolve_kernel` bug I believe (assuming my changes are good).
----
New commits:


---

Comment by git created at 2022-02-11 03:09:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-02-11 03:11:00

I made some additional changes to enable working over PIDs (well, at least `ZZ`). This was something we claimed to do on the base ticket, but now we have a nontrivial test and can compute resolutions of `ZZ`-modules. It was some very simple tweaks (the FGP module code could benefit from a cleanup to major refactoring).

Some thoughts on other possible followup tickets (beyond John's suggestion for GCAs):

- As I have mentioned before, since this does a lot of computation using dense vectors in a fixed order, we might want to rework the data structure for the elements to utilize this. Hopefully this will improve the linear algebra speed a bit by simplifying the conversion between elements (which will become trivial).
- We should implement a dedicated class for resolutions that keeps track of what computations have been done and can be used to model infinite length resolutions. One possibility is modeling the implementation on [Hochschild complex implementation](https://doc.sagemath.org/html/en/reference/homology/sage/homology/hochschild_complex.html) (or providing a common ABC for infinite chain complexes).
- Add a lightweight wrapper class to consider any algebra (with basis) as a graded algebra concentrated  in degree 0, including the ground ring as a rank 1 algebra. I have a hack in the doctest using a rank 0 exterior algebra for the base ring, but it is a heavier and likely slower way of doing things than what I would expect.


---

Comment by jhpalmieri created at 2022-02-11 03:58:21

I think I understand the `_resolve_kernel` bug, and it's actually in `vector_presentation` for free modules: when we have a module generator `g0` and algebra elements `a` and `b` in the same degree, then the module basis in that degree might be `(a*g0, b*g0)`, but sometimes the method ends up using `(b*g0, a*g0)`. So the vectors get screwed up, hence the images of the matrices are wrong. I will try to fix this by being careful about the ordering of the basis in `vector_presentation`.


---

Comment by jhpalmieri created at 2022-02-11 04:04:54

Or rather, when extracting the coefficients from `(a+b)*g0`, the terms might arise in the wrong order because it will use the order from the basis for the algebra, not the order from the basis for the module.


---

Comment by tscrim created at 2022-02-11 04:35:56

I see. Do you happen to have a (small) example of this behavior?

Slightly related, I am wondering if we need to use `dense_coefficient_list()` in `vector_presentation()`. It seems like we just want to use `_monomial_coefficients` directly since it is using a sparse implementation just unrolled into a list of indices (the `sparse_coeffs`). There might be other such optimizations that can be done elsewhere. I will wait until you push your fix before doing anything more.


---

Comment by jhpalmieri created at 2022-02-11 04:56:05

Here is an example:

```
sage: A31 = SteenrodAlgebra(3, profile=((2,1), ()))
sage: F0 = A31.free_graded_module([36, 44])
sage: F1 = A31.free_graded_module([32, 40])
sage: values = [A31.P(1)*F1.generator(0), A31.P(3)*F1.generator(0) + 2*A31.P(1)*F1.generat
....: or(1)]
sage: j = Hom(F0, F1)(values)
sage: b = [j(x) for x in j.domain().basis_elements(56)][2]
sage: b
(P(2,1)+2P(6))*g[32] + (2P(0,1)+2P(4))*g[40]
sage: a = b.dense_coefficient_list()[0]
sage: a
P(2,1) + 2 P(6)
sage: a.monomials()
[P(6), P(2,1)]
sage: a.coefficients()
[1, 2]
```

Note the mismatch in order in `a.monomials()` compared to `a.coefficients()`. Note also that this works as expected, and in particular the monomials are in a different order:

```
sage: d = (A31.P(2,1) + 2*A31.P(6)) * F1.generator(0) + (2*A31.P(0,1) + 2*A31.P(4)) * F1.g
....: enerator(1)
sage: c = d.dense_coefficient_list()[0]
sage: c.monomials()
[P(2,1), P(6)]
sage: c.coefficients()
[1, 2]
sage: b == d
True
sage: a == c
True
```



---

Comment by jhpalmieri created at 2022-02-11 05:01:27

The problem with using `_monomial_coefficients` is this: with `b` as above,

```
sage: b._monomial_coefficients
{32: P(2,1) + 2 P(6), 40: 2 P(0,1) + 2 P(4)}
```

We need to match up `P(2,1) * g[32]`, `P(6) * g[32]`, etc., with the module basis elements in that dimension, so we have to split up the values anyway. We might be able to use `_monomial_coefficients`, but it's not entirely trivial.


---

Comment by jhpalmieri created at 2022-02-11 05:05:19

I'm not entirely happy with this, but it seems to work.
----
New commits:


---

Comment by git created at 2022-02-11 05:07:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-11 05:08:38

Here's a doctest. I checked this by hand through degree 56 (which is where the problem was before).


---

Comment by jhpalmieri created at 2022-02-11 06:13:23

I'm not planning to make any more changes tonight. I am never sure of the right way to iterate through the terms in a combinatorial free module; I thought that `map_item` might be right but I couldn't get it to work in this case. I think that we should only get monomials in the current code so `leading_support` should give us the right index (the support should have just one element in it), but I'm not completely positive. Maybe this can be cleaned up.


---

Comment by tscrim created at 2022-02-11 07:16:47

Thank you for figuring out the issue.

Using the example in `element_from_coordinates`

```
sage: A = SteenrodAlgebra(2)
sage: from sage.modules.fp_graded.steenrod.module import SteenrodFPModule
sage: rels = [[Sq(1),0,0,0], [Sq(2),0,0,0], [Sq(4),0,0,0], [Sq(8),0,0,0],
....:  [0,Sq(1),0,0], [0,Sq(2),0,0], [0,Sq(4),0,0], [Sq(31),Sq(14),0,0],
....:  [0,Sq(20),0,0], [0,0,Sq(1),0], [0,0,Sq(2),0], [0,Sq(31),Sq(6),0],
....:  [0,0,Sq(8),0], [0,0,0,Sq(1)], [0,0,Sq(31),Sq(2)], [0,0,0,Sq(4)], [0,0,0,Sq(8)] ]
sage: M = SteenrodFPModule(A, [0, 17, 42, 71], relations=rels)
sage: %prun res = M.resolution(2, top_dim=30, verbose=True)
```

the changes I just pushed make the time go from ~38s to ~17s on my laptop. From my understanding, a chokepoint is converting to/from dense vectors. This now once-and-forever fixes a number of basis orders.

Hopefully nothing fundamentally relies on the underlying algebra being a `CFM` (just in the category of `GradedModulesWithBasis`). If we encounter issues as we add further algebras, mainly CGAs, then we can make fixes here as necessary IMO.

We can re-enable the caching on the higher level method of `basis_element()`, but I don't think it is called frequently enough to warrant the caching.

I made a new ticket for a bug in partitions #33323 that was exposed by this change.

Doctests now fully pass for me. So I am ready to set a positive review if you agree with my latest push.
----
Last 10 new commits:


---

Comment by jhpalmieri created at 2022-02-11 23:20:05

Should the thematic tutorial be added to the thematic tutorial index, in addition to the "tutorial document tree"?


---

Comment by jhpalmieri created at 2022-02-12 00:00:53

Some typos and other minor fixes. I want to do one or two more passes before declaring it done, but it's looking very good. Thanks for all of your work on it, Travis.
----
New commits:


---

Comment by jhpalmieri created at 2022-02-12 00:02:40

By the way, regarding this for the `profile` method for modules over the Steenrod algebra:

```
        # Avoid returning the zero profile because it triggers a corner case
        # in FPModule.resolution().
        #
        # XXX todo: Fix FPModule_class.resolution().
        #
        return (1,) if profile == (0,) else profile
```

I changed it to just `return profile` and it worked fine, so other changes must have fixed the problem.


---

Comment by tscrim created at 2022-02-12 06:38:48

Thank you for all your work on this as well, as well as to the authors for taking the time to write this patch and initial documentation.

I have pushed a few other minor tweaks for the documentation after looking at the final compiled version.
----
New commits:


---

Comment by jhpalmieri created at 2022-02-12 18:34:09

Is this a problem or does it just have to be documented?

```
sage: from sage.modules.fp_graded.module import FPModule
sage: E.<x,y> = ExteriorAlgebra(QQ)
sage: M = FPModule(E, [0, 0], [[x, y]])
sage: M._indices
{(0, 0), (0, 1)}
sage: M.monomial(3)
g[3]
sage: M.monomial(3) in M
True
sage: M.monomial(3) == 0  # This makes it okay, I think.
True
```



---

Comment by jhpalmieri created at 2022-02-12 19:49:48

More tweaks
----
New commits:


---

Comment by jhpalmieri created at 2022-02-12 20:55:17

What do you think about this change?

```diff
diff --git a/src/sage/modules/fp_graded/free_element.py b/src/sage/modules/fp_graded/free_element.py
index 8fda1b44115..4da43770af5 100755
--- a/src/sage/modules/fp_graded/free_element.py
+++ b/src/sage/modules/fp_graded/free_element.py
@@ -84,7 +84,7 @@ class FreeGradedModuleElement(IndexedFreeModuleElement):
         """
         if order is None:
             order = self.parent()._indices
-        return super().dense_coefficient_list(order)
+        return [self[i] for i in order]
 
 
     def degree(self):
```

This would make the definition of `dense_coefficient_list` consistent between `element.py` and `free_element.py` (and we need methods for both classes because the `lift_to_free` method calls `dense_coefficient_list`).


---

Comment by jhpalmieri created at 2022-02-12 21:29:21

Replying to [comment:102 tscrim]:
> Question regarding the general graded modules: Why do we have a more interesting `an_element` for the `FPModuleHomset` that we override for `FreeModuleHomset` (which is just the zero morphism)? (I recognize that previously they were separate classes, but the underlying question still remains why the free one is a more boring element.)

I agree, and I'm going to push a branch that deletes the `_an_element_` method for `FreeModuleHomset`. It doesn't add anything: users should use `an_element`, and if they really want `_an_element_`, then the one in `parent.pyx` will still be available and will still return the zero morphism.


---

Comment by git created at 2022-02-12 21:46:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-12 21:48:30

I removed `_an_element_`, also `_repr_type` for free morphisms (because that class inherits from the morphism class and they have the same `_repr_type`), also `minimal_presentation` for `SteenrodFPModule` (because it's the same as for `FPModule`). I moved some of the doctests from the deleted methods so the tests are still being run.


---

Comment by jhpalmieri created at 2022-02-12 21:49:53

I also changed `dense_coefficient_list` for free module elements, as I proposed in comment:129.


---

Comment by tscrim created at 2022-02-13 00:00:48

I strongly think we should not put in the `monomial` "bug" in the documentation as it just is not checking the input. This is something that comes from the abstract code and was decided not to do this check for speed reasons. Essentially I think of it as garbage-in-garbage-out.

I am not sure I fully agree with the comment:129 change as it could mean if there are improvements in a base class, it will not benefit from it. I am okay with having a different implementation for the FP module since it is not a (finite dimensional) module with a basis. However, I don't mind this change because of the uniformity. The only reason we need for the free module element is because of the ordering issue we came across above.

Everything else is good.


---

Comment by jhpalmieri created at 2022-02-13 00:29:02

Replying to [comment:134 tscrim]:
> I strongly think we should not put in the `monomial` "bug" in the documentation as it just is not checking the input. This is something that comes from the abstract code and was decided not to do this check for speed reasons. Essentially I think of it as garbage-in-garbage-out.

I am concerned that a user will think that `M.monomial(0)` will return the 0th generator, leading to an issue that will be a little difficult to debug, especially in this case where `M.monomial(3)` prints as `g[3]`, not as 0; you have to actually ask whether it's zero to realize what's going on. In other words, users may not realize that it's "garbage-in". So I would prefer to make it explicit.

> I am not sure I fully agree with the comment:129 change as it could mean if there are improvements in a base class, it will not benefit from it. I am okay with having a different implementation for the FP module since it is not a (finite dimensional) module with a basis. However, I don't mind this change because of the uniformity. The only reason we need for the free module element is because of the ordering issue we came across above.

The uniformity is the main issue for me. I am worried that some change elsewhere (for example in `super().dense_coefficient_list()`) will result in different behavior in these two cases which would lead to subtle problems.


---

Comment by jhpalmieri created at 2022-02-13 00:51:21

Replying to [comment:135 jhpalmieri]:
> Replying to [comment:134 tscrim]:
> > I strongly think we should not put in the `monomial` "bug" in the documentation as it just is not checking the input. This is something that comes from the abstract code and was decided not to do this check for speed reasons. Essentially I think of it as garbage-in-garbage-out.
> 
> I am concerned that a user will think that `M.monomial(0)` will return the 0th generator, leading to an issue that will be a little difficult to debug, especially in this case where `M.monomial(3)` prints as `g[3]`, not as 0; you have to actually ask whether it's zero to realize what's going on. In other words, users may not realize that it's "garbage-in". So I would prefer to make it explicit.

But we can remove those changes if you want.


---

Comment by tscrim created at 2022-02-13 00:51:42

Replying to [comment:135 jhpalmieri]:
> Replying to [comment:134 tscrim]:
> > I strongly think we should not put in the `monomial` "bug" in the documentation as it just is not checking the input. This is something that comes from the abstract code and was decided not to do this check for speed reasons. Essentially I think of it as garbage-in-garbage-out.
> 
> I am concerned that a user will think that `M.monomial(0)` will return the 0th generator, leading to an issue that will be a little difficult to debug, especially in this case where `M.monomial(3)` prints as `g[3]`, not as 0; you have to actually ask whether it's zero to realize what's going on. In other words, users may not realize that it's "garbage-in". So I would prefer to make it explicit.

If they haven't read the documentation on this method, they aren't going to read the warning. I think you are also relying on undocumented behavior that could change at any time. Actually, what we should do I think, since we define our own `_monomial` function, is do the check and raise an error on invalid input.

> > I am not sure I fully agree with the comment:129 change as it could mean if there are improvements in a base class, it will not benefit from it. I am okay with having a different implementation for the FP module since it is not a (finite dimensional) module with a basis. However, I don't mind this change because of the uniformity. The only reason we need for the free module element is because of the ordering issue we came across above.
> 
> The uniformity is the main issue for me. I am worried that some change elsewhere (for example in `super().dense_coefficient_list()`) will result in different behavior in these two cases which would lead to subtle problems.

Since we are explicitly passing the `order` and the method's API specifies a particular behavior for this, any subtle problem is definitely an honest bug in the result of `super().dense_coefficient_list()`. This discussion is solidifying something I had thought about introducing: an ABC or mixin class for the two element methods to enforce more consistency between the two. Well, we can easily enough refactor this later if we deem it necessary. We can leave this as-is to suggest that in the code as well.


---

Comment by git created at 2022-02-13 01:00:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-13 01:02:36

Replying to [comment:137 tscrim]:
> Replying to [comment:135 jhpalmieri]:
> > Replying to [comment:134 tscrim]:
> > > I strongly think we should not put in the `monomial` "bug" in the documentation as it just is not checking the input. This is something that comes from the abstract code and was decided not to do this check for speed reasons. Essentially I think of it as garbage-in-garbage-out.
> > 
> > I am concerned that a user will think that `M.monomial(0)` will return the 0th generator, leading to an issue that will be a little difficult to debug, especially in this case where `M.monomial(3)` prints as `g[3]`, not as 0; you have to actually ask whether it's zero to realize what's going on. In other words, users may not realize that it's "garbage-in". So I would prefer to make it explicit.
> 
> If they haven't read the documentation on this method, they aren't going to read the warning. I think you are also relying on undocumented behavior that could change at any time. Actually, what we should do I think, since we define our own `_monomial` function, is do the check and raise an error on invalid input.

I added a check to `_monomial`. My earlier point is that once they see the error, then they will look at the documentation and may not still realize the problem, until they remember/realize that "indices" doesn't just mean 0, 1, 2, .... Now it should be better because we will just raise an error.

By the way, I tried a few computations and this check doesn't seem to have slowed things down.


---

Comment by tscrim created at 2022-02-13 01:08:24

Replying to [comment:139 jhpalmieri]:
> I added a check to `_monomial`. My earlier point is that once they see the error, then they will look at the documentation and may not still realize the problem, until they remember/realize that "indices" doesn't just mean 0, 1, 2, .... Now it should be better because we will just raise an error.

Thank you. I think it would have be a little tricky to track the input down to this without knowing what to look for ahead of time.

> By the way, I tried a few computations and this check doesn't to have slowed things down.

I am not surprised as this method is not called very often and the check is very quick. This is not the case for other instances in the wild.

I am thinking of setting a positive review now. Any objections?


---

Comment by jhpalmieri created at 2022-02-13 01:12:05

I think I'm ready. We can tinker more in a follow-up if we see any more issues, plus the list in comment:109.


---

Comment by tscrim created at 2022-02-13 01:16:12

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-02-13 01:16:12

Thank you for all of your work on this. If #33323 starts looking like it will take a long time, we can simply change the doctests that depend on that.


---

Comment by jhpalmieri created at 2022-02-13 02:03:53

And there was much rejoicing!


---

Comment by @sverre320 created at 2022-02-16 22:01:52

Replying to [comment:143 jhpalmieri]:
> And there was much rejoicing!
Indeed!

I am very happy this code finally seems to be in the right place with regards to the rest of Sage.  In particular, it's great that FPModules can be created over other algebras than the Steenrod algebra!  

I ran some tests today, comparing the performance of the code we submitted for review with the current version:  Computing the free resolution of the module M = A/(Sq^12, Sq^7) (A = the mod 2 Steenrod algebra) is 3x faster now!  In my example, I computed the length 3 resolution which took ~303 seconds before, and ~106 seconds now, on my laptop.  I ran similar tests with other modules, with consistent conclusions.

Thanks a lot, both of you, for your great effort!


---

Comment by dimpase created at 2022-02-17 16:59:34

Can we now do e.g. FPModules over finitely presented group algebras?


---

Comment by jhpalmieri created at 2022-02-17 17:05:49

Well, the basic setup in #32505 is for f.p. modules specifically over graded rings, and in parts of the code you want to compute the basis for a particular homogeneous piece, so this relies on the graded ring and the graded module being finite enough that each homogeneous piece is finite-dimensional. It's certainly worth exploring how much the code can be pushed when the graded ring is concentrated in degree zero and is infinite dimensional, but I don't know if anything would work with the current state of things.


---

Comment by jhpalmieri created at 2022-02-17 17:08:50

One of the nice observations about the Steenrod algebra is that it is a union of finite-dimensional subalgebras, and you can do many useful calculations by restricting to those subalgebras. So maybe everything should in principle work if you have something like an algebra which is filtered by finite-dimensional subalgebras (and if you want to do homological algebra, you probably want each algebra filtration piece to be free over its subalgebra filtration pieces). Some motivated person should look into this.


---

Comment by vbraun created at 2022-02-22 00:04:05

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2022-02-22 00:04:05

Documentation doesn't build


---

Comment by tscrim created at 2022-02-22 04:27:17

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2022-02-22 04:27:17

Without this change, I see the same error as reported by the patchbot. I figured my linking to the `index.rst` was harmless, but it exposed something that wasn't done properly.
----
New commits:


---

Comment by jhpalmieri created at 2022-02-22 06:08:31

Changing status from needs_review to positive_review.


---

Comment by jhpalmieri created at 2022-02-22 06:08:31

I was independently trying basically the same thing. I've added one line.
----
New commits:


---

Comment by jhpalmieri created at 2022-02-22 19:32:27

PDF documentation doesn't build. I'm looking into it.


---

Comment by jhpalmieri created at 2022-02-22 19:32:27

Changing status from positive_review to needs_work.


---

Comment by git created at 2022-02-22 20:13:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-02-22 20:14:36

Fixed. It's an issue mentioned in [our documentation](https://doc.sagemath.org/html/en/developer/coding_basics.html#latex-typesetting) about the `:nowrap:` directive.


---

Comment by jhpalmieri created at 2022-02-22 20:14:36

Changing status from needs_work to positive_review.


---

Comment by tscrim created at 2022-02-23 03:21:31

Thank you for the catch and fix. I probably would have used `aligned` instead, but this fix is good too. `:)`


---

Comment by vbraun created at 2022-02-27 22:00:50

Resolution: fixed
