# Issue 29905: Combinatorics: implementation of an AssociationScheme class

Issue created by migration from https://trac.sagemath.org/ticket/30142

Original creator: @Ivo-Maffei

Original creation time: 2020-07-14 15:03:03

CC:  dimpase

Introducing a class to represent association schemes.
We represent a scheme with:
* the points of the scheme
* the relations as a matrix

We compute the intersection numbers and the relations lazily and use memoization for later uses.


---

Comment by @Ivo-Maffei created at 2020-07-14 15:13:52

Dima could you have a look at the class structure?
I would really appreciate your opinion on the implementation of the class before I invest a lot of time writing up all the documentation.

Roughly speaking, I store the set of points given in `self._X` and use the matrix `self._matrix` to represent relations via the abstraction:
`self._matrix[i,j] = k => (self._X[i], self._X[j]) in R_k`.
`self._R` is the list of all relations, i.e. `self._R[k]` represents `R_k` via `R_k = {(self._X[i], self._X[j]) | (i,j) in self._R[k]}` .
`self._P` is a dictionary for the intersection numbers: `p_{ij}^k = self._P[i][j][k]`.
All entries in `self._R` and `self._P` are initialised to `None` and computed only when needed.


---

Comment by dimpase created at 2020-07-14 18:43:41

There are things to take into account - I do have some code to work with association schemes, mostly written in GAP; some of it went into MSc thesis of my student last year:
https://arxiv.org/abs/2007.02459 (and https://github.com/gap-packages/RepnDecomp)

- which was in turn taken from 
https://bitbucket.org/dimpase/cohcfg/src/default/
described in https://link.springer.com/chapter/10.1007%2F978-3-642-15582-6_14

These are principally concerned with creating association schemes (or somewhat more general objects, known as coherent configurations) from permutation groups - their orbitals, to be precise.


---

Comment by @Ivo-Maffei created at 2020-07-15 09:34:23

I don't see where association schemes (or coherent configurations) are used in the package "RepnDecomp".

I got access to the book about the "cohcfg" package and I'll have a look at the implementation.
Interestingly on SOLO I found the a book titled "A GAP/Sage package for computation with coherent configurations" (http://solo.bodleian.ox.ac.uk/permalink/f/89vilt/ORAfefb05b0-8274-440d-a222-d8b9aea78344) (authored by you), so I was wondering if you ported the GAP package to Sage already.\\
If this is not the case, could you explain me how do I install the "cohcfg" package in the GAP installation used by Sage?


---

Comment by dimpase created at 2020-07-15 10:36:37

Replying to [comment:3 gh-Ivo-Maffei]:
> I don't see where association schemes (or coherent configurations) are used in the package "RepnDecomp".

see https://github.com/gap-packages/RepnDecomp/tree/master/lib/cohcfg

> 
> I got access to the book about the "cohcfg" package and I'll have a look at the implementation.
> Interestingly on SOLO I found the a book titled "A GAP/Sage package for computation with coherent configurations" (http://solo.bodleian.ox.ac.uk/permalink/f/89vilt/ORAfefb05b0-8274-440d-a222-d8b9aea78344) (authored by you),

this is just a conference abstract, 3 pages - page numbers are given there.
Nothing more than in the other publication.

>  so I was wondering if you ported the GAP package to Sage already.\\
> If this is not the case, could you explain me how do I install the "cohcfg" package in the GAP installation used by Sage?

no, it's not in GAP, I didn't have time for it. :-(

for GAP there are actively maintained/developed packages:
 http://www.jesselansdown.com/AssociationSchemes/ (this is mostly to deal with complete enumeration of small associatuion schemes, but not only)

 https://github.com/chpech/COCO2P/

--------------

What functionality of association schemes do you need?


---

Comment by @Ivo-Maffei created at 2020-07-15 11:33:49

To build a drg from an association scheme I only need to be able to query `(x,y) in R_k`. So nothing complex.

Checking if a given association scheme will produce a drg is more complicated.
I need to check that the association scheme is pseudo cyclic (so I need the intersection numbers) and that there is a commutative binary operation `+` s.t. `p_{i+l, j+l}^{k+l} = p_{i,j}^k` for any `i, j, k, l`.

I'm not concerned with the `+` at the moment, since the association schemes I built all have the same `+`.


---

Comment by dimpase created at 2020-07-15 13:15:04

there are some pseudocyclic association schemes used in construction of s.r.g. (constructions by Mathon, so you can find it - I am away from the computer now, so can't easily provide a link)

Why do you need to check that a particular assoc. scheme is pseudocyclic - cannot you just use known constructions?


---

Comment by @Ivo-Maffei created at 2020-07-15 14:32:43

I was planning to have a function like `strongly_regular_graph` or `balanced_incomplete_block_desgin`, etc... to build association schemes and in this case I would need to check pseudocyclicity if the optional parameter `check` is `True`. However, the check is not expensive if one already have all intersection numbers.


---

Comment by dimpase created at 2020-07-15 15:55:51

this looks like an ambitious undertaking. In particular, as s.r.g.'s and d.r.g.'s are subclasses of assoc. schemes. Do you have enough time?


---

Comment by @Ivo-Maffei created at 2020-07-15 18:41:01

Let me explain my whole plan, so that you can give me your opinion.\\
To build my drg function that generates the graphs from the intersection array, I'd would like a function that checks if Sage can build an association scheme whose graph is distance regular with the given intersection array.

Instead of going case by case, i.e. having checks such as "if array can be done with cyclotomic schemes (which we know are pseudo cyclic etc...), then build graph from cyclotomic scheme; else if ...." I would like a function that groups together all association schemes constructions (I guess it could just wrap the constructions avialable in http://www.jesselansdown.com/AssociationSchemes/).
This means that whenever a new association scheme, whose graph is distance regular, is added to the above function, then the related drgs can be constructed by Sage without any additional code.

As an example, for BIBDs I have the following code

```python
def is_from_square_BIBD(array) 
# function that take an intersection array and returns (v, k)
# if Sage can build a symmetric (v, k) BIBD whose graph has the given intersection array
# otherwise it returns False

def graph_from_square_BIBD(v, k):
lambd = (k*(k-1))//(v-1)
D = designs.balanced_incomplete_block_design(v,k,lambd=lambd)
return D.incidence_graph()

def distance_regular_graph(array):
# this is the function creating the distance regular graphs
...
t = is_from_square_BIBD(array)
if t is not False:
     G = graph_from_square_BIBD(*t)
...
return G
```


That's the pattern I would like to use for association schemes as well.
I don't plan to start adding more association scheme constructions that those available in the 2 gap packages.
Moreover, the function building the association schemes can't rely on the one building distance regular graphs as we will end up with an infinite loop.

Hope this explain my plan clearly. If you consider it to be too ambitious or simply flawed, then I can work on other parts of the project while we find an alternative solution.


---

Comment by dimpase created at 2020-07-15 20:36:07

There are many more association schemes than d.r.g.'s (a.k.a. P-polynomial assoc. schemes) - unless it's a 2-class symmetric assoc. scheme, i.e. a pair of complementary s.r.g.'s.

I thought you need assoc. schemes for constructions such as ones in 12.7 of [BCN] - bur otherwise it's about as useful for dealing with d.r.g.'s as databases of all graphs.


---

Comment by @Ivo-Maffei created at 2020-07-16 08:52:35

Yes, in [BCN] 12.7 is described the particular construction I use. Moreover, proposition 12.7.1 characterises the association schemes I'm interested in. I doubt the three examples provided (12.7.A,B,C) are an exhaustive list of all association schemes satisfying 12.7.1 (probably not even 12.7.2), so I would like to have a function that groups together those 3 examples plus any other case that people may end up finding.


---

Comment by dimpase created at 2020-07-16 16:57:40

You might like to check out `_EllipticLinesProjectivePlaneScheme()` in sage/graphs/generators/smallgraphs.py and
`MathonPseudocyclicMergingGraph()` in sage/graphs/generators/families.py

Perhaps you re-use `_EllipticLinesProjectivePlaneScheme()` (or using a similar low-tech
appoach to get data you need)


---

Comment by @Ivo-Maffei created at 2020-07-17 10:43:09

I think I understood your view and I'm writing down some code to see how this will work out.
Is taking more time than I initially thought, but I'll soon update this ticket with the result.


---

Comment by git created at 2020-07-17 17:41:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Ivo-Maffei created at 2020-07-17 17:45:53

I had a lot of issues with coding a function that given an association scheme finds the correct quasi group and I gave up.
Hopefully, it will be easy to determine it mathematically for each case.
In the code I use the gap package "AssociationSchemes", I'll also add "COCO2P" if it will prove useful.


---

Comment by git created at 2020-07-17 18:20:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-07-17 22:51:49

Replying to [comment:15 gh-Ivo-Maffei]:
> I had a lot of issues with coding a function that given an association scheme finds the correct quasi group and I gave up.

Did you realise that quasigroups are basically Latin squares?
Cf. Sage's `LatinSquare_generator`, by the way.


> Hopefully, it will be easy to determine it mathematically for each case.

the small cases can just be hardcoded, I guess.


---

Comment by dimpase created at 2020-07-18 10:43:00

I also don't understand why for purposes of constructing you need commutative quasi-groups which are not (commutative) groups? Can't you just take a cyclic group, or an elementary abelian 2-group (for the other case, where all elements should be of order 2)?


---

Comment by @Ivo-Maffei created at 2020-07-19 13:03:49

What I understand from [BCN] 12.7 is that an association scheme S with a commutative quasi group I gives a distance regular graph if and only if S and I satisfy proposition 12.7.1.
Let I and I' be two distinct commutative quasi groups. Then we may have that S,I produces a drg but S,I' does not.
For instance, let S be the 4-class cyclotomic scheme. Then with I = C_4 we have a drg, but if I = C_2 x C_2, then we get a graph which is not distance regular.

That's why I have the function `_find_quasigroup` since, given S, I need to find the quasi group (if it exists) that will satisfy 12.7.1.

I looked at `LatinSquare_generator` and I have 2 doubts:
1. will it generate (eventually) all Latin squares of the same order as the input?
2. how can I tell if I've seen all Latin squares?

Trying out some examples, it looks like 2 may be an issue as the sequence generated can repeat before having shown all possible Latin squares. Sadly I don't think it is a possible route, yet I can't see any other way... Unless you have some ideas, we might have to ditch `_find_quasigroup` completely.


---

Comment by git created at 2020-07-19 13:04:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-07-19 14:02:53

Replying to [comment:19 gh-Ivo-Maffei]:
> What I understand from [BCN] 12.7 is that an association scheme S with a commutative quasi group I gives a distance regular graph if and only if S and I satisfy proposition 12.7.1.
> Let I and I' be two distinct commutative quasi groups. Then we may have that S,I produces a drg but S,I' does not.
> For instance, let S be the 4-class cyclotomic scheme. Then with I = C_4 we have a drg, but if I = C_2 x C_2, then we get a graph which is not distance regular.
> 


> That's why I have the function `_find_quasigroup` since, given S, I need to find the quasi group (if it exists) that will satisfy 12.7.1.

perhaps C2xC2 is special - it seems that (b), in the group case, essentially allows only elementary abelian 2-groups, with a the group identify element.

> 
> I looked at `LatinSquare_generator` and I have 2 doubts:
> 1. will it generate (eventually) all Latin squares of the same order as the input?
> 2. how can I tell if I've seen all Latin squares?
> 

iirc it is known how many Latin squares there are -- check oeis.org


> Trying out some examples, it looks like 2 may be an issue as the sequence generated can repeat before having shown all possible Latin squares. Sadly I don't think it is a possible route, yet I can't see any other way... Unless you have some ideas, we might have to ditch `_find_quasigroup` completely.


---

Comment by dimpase created at 2020-07-19 22:51:12

On the practical side, you have cyclotomic schemes (12.7.A), for which the quasigroup to use is actually the cyclic group.
In the examples 12.7.B and C the quasigroups are not specified, and it looks like the authors of the book actually didn't know what they are.

There also some corrections to Chapter 12:
https://www.win.tue.nl/~aeb/drg/ch12
(some to 12.7, have a look)


---

Comment by @Ivo-Maffei created at 2020-07-20 09:01:05

Looking at oeis I think there is no formula for the number of Latin squares of a given order, but they computed it for orders up to 11 (https://oeis.org/A002860/list). Anything with order 6 or more will be very slow.

Both 12.7.B and 12.7.C are pseudocyclic with 3 classes, hence their intersection numbers are given in 12.7.4.
Using the group C_3, they satisfy 12.7.2 ( which is 12.7.1(a) ). I have already built 12.7.B yesterday. I'm having issues finding the paper where the construction of 12.7.C is described, but now I'll try to modify `_EllipticLinesProjectivePlaneScheme` and see if I get what I need.


---

Comment by dimpase created at 2020-07-20 09:05:46

12.7.B and C are 3-class only for a particular  value of q. The general q is not known, it seems.
I'll ask Andries Brouwer.


---

Comment by @Ivo-Maffei created at 2020-07-20 10:18:38

For 12.7.C the group PSigmaO(3,q) is used. However, I can't find much on that group online. With the GAP package FinInG I can obtain groups like PO, PGO, PSO and PGammaO (http://cage.ugent.be/fining/doc/chap7.html#X7988AF9978E75E37).
Do you know what PSigmaO is?


---

Comment by dimpase created at 2020-07-20 20:45:49

Replying to [comment:25 gh-Ivo-Maffei]:
> For 12.7.C the group PSigmaO(3,q) is used. However, I can't find much on that group online. With the GAP package FinInG I can obtain groups like PO, PGO, PSO and PGammaO (http://cage.ugent.be/fining/doc/chap7.html#X7988AF9978E75E37).
> Do you know what PSigmaO is?

It is PSO extended by the Galois automorphisms - which for q=p<sup>k</sup>, p prime, form a cyclic group of order r, generated by the maps t->t<sup>p</sup> for each t in GF(q). (and the the action on the vectors is coordinatewise).

This notation may be found e.g. in the Altlas of Finite Groups by Conway et al.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
