# Issue 29905: Combinatorics: implementation of an AssociationScheme class

archive/issues_029905.json:
```json
{
    "body": "CC:  dimpase\n\nIntroducing a class to represent association schemes.\nWe represent a scheme with:\n* the points of the scheme\n* the relations as a matrix\n\nWe compute the intersection numbers and the relations lazily and use memoization for later uses.\n\nIssue created by migration from https://trac.sagemath.org/ticket/30142\n\n",
    "created_at": "2020-07-14T15:03:03Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Combinatorics: implementation of an AssociationScheme class",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29905",
    "user": "@Ivo-Maffei"
}
```
CC:  dimpase

Introducing a class to represent association schemes.
We represent a scheme with:
* the points of the scheme
* the relations as a matrix

We compute the intersection numbers and the relations lazily and use memoization for later uses.

Issue created by migration from https://trac.sagemath.org/ticket/30142





---

archive/issue_comments_424775.json:
```json
{
    "body": "Dima could you have a look at the class structure?\nI would really appreciate your opinion on the implementation of the class before I invest a lot of time writing up all the documentation.\n\nRoughly speaking, I store the set of points given in `self._X` and use the matrix `self._matrix` to represent relations via the abstraction:\n`self._matrix[i,j] = k => (self._X[i], self._X[j]) in R_k`.\n`self._R` is the list of all relations, i.e. `self._R[k]` represents `R_k` via `R_k = {(self._X[i], self._X[j]) | (i,j) in self._R[k]}` .\n`self._P` is a dictionary for the intersection numbers: `p_{ij}^k = self._P[i][j][k]`.\nAll entries in `self._R` and `self._P` are initialised to `None` and computed only when needed.",
    "created_at": "2020-07-14T15:13:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424775",
    "user": "@Ivo-Maffei"
}
```

Dima could you have a look at the class structure?
I would really appreciate your opinion on the implementation of the class before I invest a lot of time writing up all the documentation.

Roughly speaking, I store the set of points given in `self._X` and use the matrix `self._matrix` to represent relations via the abstraction:
`self._matrix[i,j] = k => (self._X[i], self._X[j]) in R_k`.
`self._R` is the list of all relations, i.e. `self._R[k]` represents `R_k` via `R_k = {(self._X[i], self._X[j]) | (i,j) in self._R[k]}` .
`self._P` is a dictionary for the intersection numbers: `p_{ij}^k = self._P[i][j][k]`.
All entries in `self._R` and `self._P` are initialised to `None` and computed only when needed.



---

archive/issue_comments_424776.json:
```json
{
    "body": "There are things to take into account - I do have some code to work with association schemes, mostly written in GAP; some of it went into MSc thesis of my student last year:\nhttps://arxiv.org/abs/2007.02459 (and https://github.com/gap-packages/RepnDecomp)\n\n- which was in turn taken from \nhttps://bitbucket.org/dimpase/cohcfg/src/default/\ndescribed in https://link.springer.com/chapter/10.1007%2F978-3-642-15582-6_14\n\nThese are principally concerned with creating association schemes (or somewhat more general objects, known as coherent configurations) from permutation groups - their orbitals, to be precise.",
    "created_at": "2020-07-14T18:43:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424776",
    "user": "dimpase"
}
```

There are things to take into account - I do have some code to work with association schemes, mostly written in GAP; some of it went into MSc thesis of my student last year:
https://arxiv.org/abs/2007.02459 (and https://github.com/gap-packages/RepnDecomp)

- which was in turn taken from 
https://bitbucket.org/dimpase/cohcfg/src/default/
described in https://link.springer.com/chapter/10.1007%2F978-3-642-15582-6_14

These are principally concerned with creating association schemes (or somewhat more general objects, known as coherent configurations) from permutation groups - their orbitals, to be precise.



---

archive/issue_comments_424777.json:
```json
{
    "body": "I don't see where association schemes (or coherent configurations) are used in the package \"RepnDecomp\".\n\nI got access to the book about the \"cohcfg\" package and I'll have a look at the implementation.\nInterestingly on SOLO I found the a book titled \"A GAP/Sage package for computation with coherent configurations\" (http://solo.bodleian.ox.ac.uk/permalink/f/89vilt/ORAfefb05b0-8274-440d-a222-d8b9aea78344) (authored by you), so I was wondering if you ported the GAP package to Sage already.\\\\\nIf this is not the case, could you explain me how do I install the \"cohcfg\" package in the GAP installation used by Sage?",
    "created_at": "2020-07-15T09:34:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424777",
    "user": "@Ivo-Maffei"
}
```

I don't see where association schemes (or coherent configurations) are used in the package "RepnDecomp".

I got access to the book about the "cohcfg" package and I'll have a look at the implementation.
Interestingly on SOLO I found the a book titled "A GAP/Sage package for computation with coherent configurations" (http://solo.bodleian.ox.ac.uk/permalink/f/89vilt/ORAfefb05b0-8274-440d-a222-d8b9aea78344) (authored by you), so I was wondering if you ported the GAP package to Sage already.\\
If this is not the case, could you explain me how do I install the "cohcfg" package in the GAP installation used by Sage?



---

archive/issue_comments_424778.json:
```json
{
    "body": "Replying to [comment:3 gh-Ivo-Maffei]:\n> I don't see where association schemes (or coherent configurations) are used in the package \"RepnDecomp\".\n\nsee https://github.com/gap-packages/RepnDecomp/tree/master/lib/cohcfg\n\n> \n> I got access to the book about the \"cohcfg\" package and I'll have a look at the implementation.\n> Interestingly on SOLO I found the a book titled \"A GAP/Sage package for computation with coherent configurations\" (http://solo.bodleian.ox.ac.uk/permalink/f/89vilt/ORAfefb05b0-8274-440d-a222-d8b9aea78344) (authored by you),\n\nthis is just a conference abstract, 3 pages - page numbers are given there.\nNothing more than in the other publication.\n\n>  so I was wondering if you ported the GAP package to Sage already.\\\\\n> If this is not the case, could you explain me how do I install the \"cohcfg\" package in the GAP installation used by Sage?\n\nno, it's not in GAP, I didn't have time for it. :-(\n\nfor GAP there are actively maintained/developed packages:\n http://www.jesselansdown.com/AssociationSchemes/ (this is mostly to deal with complete enumeration of small associatuion schemes, but not only)\n\n https://github.com/chpech/COCO2P/\n\n--------------\n\nWhat functionality of association schemes do you need?",
    "created_at": "2020-07-15T10:36:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424778",
    "user": "dimpase"
}
```

Replying to [comment:3 gh-Ivo-Maffei]:
> I don't see where association schemes (or coherent configurations) are used in the package "RepnDecomp".

see https://github.com/gap-packages/RepnDecomp/tree/master/lib/cohcfg

> 
> I got access to the book about the "cohcfg" package and I'll have a look at the implementation.
> Interestingly on SOLO I found the a book titled "A GAP/Sage package for computation with coherent configurations" (http://solo.bodleian.ox.ac.uk/permalink/f/89vilt/ORAfefb05b0-8274-440d-a222-d8b9aea78344) (authored by you),

this is just a conference abstract, 3 pages - page numbers are given there.
Nothing more than in the other publication.

>  so I was wondering if you ported the GAP package to Sage already.\\
> If this is not the case, could you explain me how do I install the "cohcfg" package in the GAP installation used by Sage?

no, it's not in GAP, I didn't have time for it. :-(

for GAP there are actively maintained/developed packages:
 http://www.jesselansdown.com/AssociationSchemes/ (this is mostly to deal with complete enumeration of small associatuion schemes, but not only)

 https://github.com/chpech/COCO2P/

--------------

What functionality of association schemes do you need?



---

archive/issue_comments_424779.json:
```json
{
    "body": "To build a drg from an association scheme I only need to be able to query `(x,y) in R_k`. So nothing complex.\n\nChecking if a given association scheme will produce a drg is more complicated.\nI need to check that the association scheme is pseudo cyclic (so I need the intersection numbers) and that there is a commutative binary operation `+` s.t. `p_{i+l, j+l}^{k+l} = p_{i,j}^k` for any `i, j, k, l`.\n\nI'm not concerned with the `+` at the moment, since the association schemes I built all have the same `+`.",
    "created_at": "2020-07-15T11:33:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424779",
    "user": "@Ivo-Maffei"
}
```

To build a drg from an association scheme I only need to be able to query `(x,y) in R_k`. So nothing complex.

Checking if a given association scheme will produce a drg is more complicated.
I need to check that the association scheme is pseudo cyclic (so I need the intersection numbers) and that there is a commutative binary operation `+` s.t. `p_{i+l, j+l}^{k+l} = p_{i,j}^k` for any `i, j, k, l`.

I'm not concerned with the `+` at the moment, since the association schemes I built all have the same `+`.



---

archive/issue_comments_424780.json:
```json
{
    "body": "there are some pseudocyclic association schemes used in construction of s.r.g. (constructions by Mathon, so you can find it - I am away from the computer now, so can't easily provide a link)\n\nWhy do you need to check that a particular assoc. scheme is pseudocyclic - cannot you just use known constructions?",
    "created_at": "2020-07-15T13:15:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424780",
    "user": "dimpase"
}
```

there are some pseudocyclic association schemes used in construction of s.r.g. (constructions by Mathon, so you can find it - I am away from the computer now, so can't easily provide a link)

Why do you need to check that a particular assoc. scheme is pseudocyclic - cannot you just use known constructions?



---

archive/issue_comments_424781.json:
```json
{
    "body": "I was planning to have a function like `strongly_regular_graph` or `balanced_incomplete_block_desgin`, etc... to build association schemes and in this case I would need to check pseudocyclicity if the optional parameter `check` is `True`. However, the check is not expensive if one already have all intersection numbers.",
    "created_at": "2020-07-15T14:32:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424781",
    "user": "@Ivo-Maffei"
}
```

I was planning to have a function like `strongly_regular_graph` or `balanced_incomplete_block_desgin`, etc... to build association schemes and in this case I would need to check pseudocyclicity if the optional parameter `check` is `True`. However, the check is not expensive if one already have all intersection numbers.



---

archive/issue_comments_424782.json:
```json
{
    "body": "this looks like an ambitious undertaking. In particular, as s.r.g.'s and d.r.g.'s are subclasses of assoc. schemes. Do you have enough time?",
    "created_at": "2020-07-15T15:55:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424782",
    "user": "dimpase"
}
```

this looks like an ambitious undertaking. In particular, as s.r.g.'s and d.r.g.'s are subclasses of assoc. schemes. Do you have enough time?



---

archive/issue_comments_424783.json:
```json
{
    "body": "Let me explain my whole plan, so that you can give me your opinion.\\\\\nTo build my drg function that generates the graphs from the intersection array, I'd would like a function that checks if Sage can build an association scheme whose graph is distance regular with the given intersection array.\n\nInstead of going case by case, i.e. having checks such as \"if array can be done with cyclotomic schemes (which we know are pseudo cyclic etc...), then build graph from cyclotomic scheme; else if ....\" I would like a function that groups together all association schemes constructions (I guess it could just wrap the constructions avialable in http://www.jesselansdown.com/AssociationSchemes/).\nThis means that whenever a new association scheme, whose graph is distance regular, is added to the above function, then the related drgs can be constructed by Sage without any additional code.\n\nAs an example, for BIBDs I have the following code\n\n```python\ndef is_from_square_BIBD(array) \n# function that take an intersection array and returns (v, k)\n# if Sage can build a symmetric (v, k) BIBD whose graph has the given intersection array\n# otherwise it returns False\n\ndef graph_from_square_BIBD(v, k):\nlambd = (k*(k-1))//(v-1)\nD = designs.balanced_incomplete_block_design(v,k,lambd=lambd)\nreturn D.incidence_graph()\n\ndef distance_regular_graph(array):\n# this is the function creating the distance regular graphs\n...\nt = is_from_square_BIBD(array)\nif t is not False:\n     G = graph_from_square_BIBD(*t)\n...\nreturn G\n```\n\n\nThat's the pattern I would like to use for association schemes as well.\nI don't plan to start adding more association scheme constructions that those available in the 2 gap packages.\nMoreover, the function building the association schemes can't rely on the one building distance regular graphs as we will end up with an infinite loop.\n\nHope this explain my plan clearly. If you consider it to be too ambitious or simply flawed, then I can work on other parts of the project while we find an alternative solution.",
    "created_at": "2020-07-15T18:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424783",
    "user": "@Ivo-Maffei"
}
```

Let me explain my whole plan, so that you can give me your opinion.\\
To build my drg function that generates the graphs from the intersection array, I'd would like a function that checks if Sage can build an association scheme whose graph is distance regular with the given intersection array.

Instead of going case by case, i.e. having checks such as "if array can be done with cyclotomic schemes (which we know are pseudo cyclic etc...), then build graph from cyclotomic scheme; else if ...." I would like a function that groups together all association schemes constructions (I guess it could just wrap the constructions avialable in http://www.jesselansdown.com/AssociationSchemes/).
This means that whenever a new association scheme, whose graph is distance regular, is added to the above function, then the related drgs can be constructed by Sage without any additional code.

As an example, for BIBDs I have the following code

```python
def is_from_square_BIBD(array) 
# function that take an intersection array and returns (v, k)
# if Sage can build a symmetric (v, k) BIBD whose graph has the given intersection array
# otherwise it returns False

def graph_from_square_BIBD(v, k):
lambd = (k*(k-1))//(v-1)
D = designs.balanced_incomplete_block_design(v,k,lambd=lambd)
return D.incidence_graph()

def distance_regular_graph(array):
# this is the function creating the distance regular graphs
...
t = is_from_square_BIBD(array)
if t is not False:
     G = graph_from_square_BIBD(*t)
...
return G
```


That's the pattern I would like to use for association schemes as well.
I don't plan to start adding more association scheme constructions that those available in the 2 gap packages.
Moreover, the function building the association schemes can't rely on the one building distance regular graphs as we will end up with an infinite loop.

Hope this explain my plan clearly. If you consider it to be too ambitious or simply flawed, then I can work on other parts of the project while we find an alternative solution.



---

archive/issue_comments_424784.json:
```json
{
    "body": "There are many more association schemes than d.r.g.'s (a.k.a. P-polynomial assoc. schemes) - unless it's a 2-class symmetric assoc. scheme, i.e. a pair of complementary s.r.g.'s.\n\nI thought you need assoc. schemes for constructions such as ones in 12.7 of [BCN] - bur otherwise it's about as useful for dealing with d.r.g.'s as databases of all graphs.",
    "created_at": "2020-07-15T20:36:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424784",
    "user": "dimpase"
}
```

There are many more association schemes than d.r.g.'s (a.k.a. P-polynomial assoc. schemes) - unless it's a 2-class symmetric assoc. scheme, i.e. a pair of complementary s.r.g.'s.

I thought you need assoc. schemes for constructions such as ones in 12.7 of [BCN] - bur otherwise it's about as useful for dealing with d.r.g.'s as databases of all graphs.



---

archive/issue_comments_424785.json:
```json
{
    "body": "Yes, in [BCN] 12.7 is described the particular construction I use. Moreover, proposition 12.7.1 characterises the association schemes I'm interested in. I doubt the three examples provided (12.7.A,B,C) are an exhaustive list of all association schemes satisfying 12.7.1 (probably not even 12.7.2), so I would like to have a function that groups together those 3 examples plus any other case that people may end up finding.",
    "created_at": "2020-07-16T08:52:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424785",
    "user": "@Ivo-Maffei"
}
```

Yes, in [BCN] 12.7 is described the particular construction I use. Moreover, proposition 12.7.1 characterises the association schemes I'm interested in. I doubt the three examples provided (12.7.A,B,C) are an exhaustive list of all association schemes satisfying 12.7.1 (probably not even 12.7.2), so I would like to have a function that groups together those 3 examples plus any other case that people may end up finding.



---

archive/issue_comments_424786.json:
```json
{
    "body": "You might like to check out `_EllipticLinesProjectivePlaneScheme()` in sage/graphs/generators/smallgraphs.py and\n`MathonPseudocyclicMergingGraph()` in sage/graphs/generators/families.py\n\nPerhaps you re-use `_EllipticLinesProjectivePlaneScheme()` (or using a similar low-tech\nappoach to get data you need)",
    "created_at": "2020-07-16T16:57:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424786",
    "user": "dimpase"
}
```

You might like to check out `_EllipticLinesProjectivePlaneScheme()` in sage/graphs/generators/smallgraphs.py and
`MathonPseudocyclicMergingGraph()` in sage/graphs/generators/families.py

Perhaps you re-use `_EllipticLinesProjectivePlaneScheme()` (or using a similar low-tech
appoach to get data you need)



---

archive/issue_comments_424787.json:
```json
{
    "body": "I think I understood your view and I'm writing down some code to see how this will work out.\nIs taking more time than I initially thought, but I'll soon update this ticket with the result.",
    "created_at": "2020-07-17T10:43:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424787",
    "user": "@Ivo-Maffei"
}
```

I think I understood your view and I'm writing down some code to see how this will work out.
Is taking more time than I initially thought, but I'll soon update this ticket with the result.



---

archive/issue_comments_424788.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-17T17:41:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424788",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424789.json:
```json
{
    "body": "I had a lot of issues with coding a function that given an association scheme finds the correct quasi group and I gave up.\nHopefully, it will be easy to determine it mathematically for each case.\nIn the code I use the gap package \"AssociationSchemes\", I'll also add \"COCO2P\" if it will prove useful.",
    "created_at": "2020-07-17T17:45:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424789",
    "user": "@Ivo-Maffei"
}
```

I had a lot of issues with coding a function that given an association scheme finds the correct quasi group and I gave up.
Hopefully, it will be easy to determine it mathematically for each case.
In the code I use the gap package "AssociationSchemes", I'll also add "COCO2P" if it will prove useful.



---

archive/issue_comments_424790.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-17T18:20:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424790",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424791.json:
```json
{
    "body": "Replying to [comment:15 gh-Ivo-Maffei]:\n> I had a lot of issues with coding a function that given an association scheme finds the correct quasi group and I gave up.\n\nDid you realise that quasigroups are basically Latin squares?\nCf. Sage's `LatinSquare_generator`, by the way.\n\n\n> Hopefully, it will be easy to determine it mathematically for each case.\n\nthe small cases can just be hardcoded, I guess.",
    "created_at": "2020-07-17T22:51:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424791",
    "user": "dimpase"
}
```

Replying to [comment:15 gh-Ivo-Maffei]:
> I had a lot of issues with coding a function that given an association scheme finds the correct quasi group and I gave up.

Did you realise that quasigroups are basically Latin squares?
Cf. Sage's `LatinSquare_generator`, by the way.


> Hopefully, it will be easy to determine it mathematically for each case.

the small cases can just be hardcoded, I guess.



---

archive/issue_comments_424792.json:
```json
{
    "body": "I also don't understand why for purposes of constructing you need commutative quasi-groups which are not (commutative) groups? Can't you just take a cyclic group, or an elementary abelian 2-group (for the other case, where all elements should be of order 2)?",
    "created_at": "2020-07-18T10:43:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424792",
    "user": "dimpase"
}
```

I also don't understand why for purposes of constructing you need commutative quasi-groups which are not (commutative) groups? Can't you just take a cyclic group, or an elementary abelian 2-group (for the other case, where all elements should be of order 2)?



---

archive/issue_comments_424793.json:
```json
{
    "body": "What I understand from [BCN] 12.7 is that an association scheme S with a commutative quasi group I gives a distance regular graph if and only if S and I satisfy proposition 12.7.1.\nLet I and I' be two distinct commutative quasi groups. Then we may have that S,I produces a drg but S,I' does not.\nFor instance, let S be the 4-class cyclotomic scheme. Then with I = C_4 we have a drg, but if I = C_2 x C_2, then we get a graph which is not distance regular.\n\nThat's why I have the function `_find_quasigroup` since, given S, I need to find the quasi group (if it exists) that will satisfy 12.7.1.\n\nI looked at `LatinSquare_generator` and I have 2 doubts:\n1. will it generate (eventually) all Latin squares of the same order as the input?\n2. how can I tell if I've seen all Latin squares?\n\nTrying out some examples, it looks like 2 may be an issue as the sequence generated can repeat before having shown all possible Latin squares. Sadly I don't think it is a possible route, yet I can't see any other way... Unless you have some ideas, we might have to ditch `_find_quasigroup` completely.",
    "created_at": "2020-07-19T13:03:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424793",
    "user": "@Ivo-Maffei"
}
```

What I understand from [BCN] 12.7 is that an association scheme S with a commutative quasi group I gives a distance regular graph if and only if S and I satisfy proposition 12.7.1.
Let I and I' be two distinct commutative quasi groups. Then we may have that S,I produces a drg but S,I' does not.
For instance, let S be the 4-class cyclotomic scheme. Then with I = C_4 we have a drg, but if I = C_2 x C_2, then we get a graph which is not distance regular.

That's why I have the function `_find_quasigroup` since, given S, I need to find the quasi group (if it exists) that will satisfy 12.7.1.

I looked at `LatinSquare_generator` and I have 2 doubts:
1. will it generate (eventually) all Latin squares of the same order as the input?
2. how can I tell if I've seen all Latin squares?

Trying out some examples, it looks like 2 may be an issue as the sequence generated can repeat before having shown all possible Latin squares. Sadly I don't think it is a possible route, yet I can't see any other way... Unless you have some ideas, we might have to ditch `_find_quasigroup` completely.



---

archive/issue_comments_424794.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-19T13:04:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424794",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424795.json:
```json
{
    "body": "Replying to [comment:19 gh-Ivo-Maffei]:\n> What I understand from [BCN] 12.7 is that an association scheme S with a commutative quasi group I gives a distance regular graph if and only if S and I satisfy proposition 12.7.1.\n> Let I and I' be two distinct commutative quasi groups. Then we may have that S,I produces a drg but S,I' does not.\n> For instance, let S be the 4-class cyclotomic scheme. Then with I = C_4 we have a drg, but if I = C_2 x C_2, then we get a graph which is not distance regular.\n> \n\n\n> That's why I have the function `_find_quasigroup` since, given S, I need to find the quasi group (if it exists) that will satisfy 12.7.1.\n\nperhaps C2xC2 is special - it seems that (b), in the group case, essentially allows only elementary abelian 2-groups, with a the group identify element.\n\n> \n> I looked at `LatinSquare_generator` and I have 2 doubts:\n> 1. will it generate (eventually) all Latin squares of the same order as the input?\n> 2. how can I tell if I've seen all Latin squares?\n> \n\niirc it is known how many Latin squares there are -- check oeis.org\n\n\n> Trying out some examples, it looks like 2 may be an issue as the sequence generated can repeat before having shown all possible Latin squares. Sadly I don't think it is a possible route, yet I can't see any other way... Unless you have some ideas, we might have to ditch `_find_quasigroup` completely.",
    "created_at": "2020-07-19T14:02:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424795",
    "user": "dimpase"
}
```

Replying to [comment:19 gh-Ivo-Maffei]:
> What I understand from [BCN] 12.7 is that an association scheme S with a commutative quasi group I gives a distance regular graph if and only if S and I satisfy proposition 12.7.1.
> Let I and I' be two distinct commutative quasi groups. Then we may have that S,I produces a drg but S,I' does not.
> For instance, let S be the 4-class cyclotomic scheme. Then with I = C_4 we have a drg, but if I = C_2 x C_2, then we get a graph which is not distance regular.
> 


> That's why I have the function `_find_quasigroup` since, given S, I need to find the quasi group (if it exists) that will satisfy 12.7.1.

perhaps C2xC2 is special - it seems that (b), in the group case, essentially allows only elementary abelian 2-groups, with a the group identify element.

> 
> I looked at `LatinSquare_generator` and I have 2 doubts:
> 1. will it generate (eventually) all Latin squares of the same order as the input?
> 2. how can I tell if I've seen all Latin squares?
> 

iirc it is known how many Latin squares there are -- check oeis.org


> Trying out some examples, it looks like 2 may be an issue as the sequence generated can repeat before having shown all possible Latin squares. Sadly I don't think it is a possible route, yet I can't see any other way... Unless you have some ideas, we might have to ditch `_find_quasigroup` completely.



---

archive/issue_comments_424796.json:
```json
{
    "body": "On the practical side, you have cyclotomic schemes (12.7.A), for which the quasigroup to use is actually the cyclic group.\nIn the examples 12.7.B and C the quasigroups are not specified, and it looks like the authors of the book actually didn't know what they are.\n\nThere also some corrections to Chapter 12:\nhttps://www.win.tue.nl/~aeb/drg/ch12\n(some to 12.7, have a look)",
    "created_at": "2020-07-19T22:51:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424796",
    "user": "dimpase"
}
```

On the practical side, you have cyclotomic schemes (12.7.A), for which the quasigroup to use is actually the cyclic group.
In the examples 12.7.B and C the quasigroups are not specified, and it looks like the authors of the book actually didn't know what they are.

There also some corrections to Chapter 12:
https://www.win.tue.nl/~aeb/drg/ch12
(some to 12.7, have a look)



---

archive/issue_comments_424797.json:
```json
{
    "body": "Looking at oeis I think there is no formula for the number of Latin squares of a given order, but they computed it for orders up to 11 (https://oeis.org/A002860/list). Anything with order 6 or more will be very slow.\n\nBoth 12.7.B and 12.7.C are pseudocyclic with 3 classes, hence their intersection numbers are given in 12.7.4.\nUsing the group C_3, they satisfy 12.7.2 ( which is 12.7.1(a) ). I have already built 12.7.B yesterday. I'm having issues finding the paper where the construction of 12.7.C is described, but now I'll try to modify `_EllipticLinesProjectivePlaneScheme` and see if I get what I need.",
    "created_at": "2020-07-20T09:01:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424797",
    "user": "@Ivo-Maffei"
}
```

Looking at oeis I think there is no formula for the number of Latin squares of a given order, but they computed it for orders up to 11 (https://oeis.org/A002860/list). Anything with order 6 or more will be very slow.

Both 12.7.B and 12.7.C are pseudocyclic with 3 classes, hence their intersection numbers are given in 12.7.4.
Using the group C_3, they satisfy 12.7.2 ( which is 12.7.1(a) ). I have already built 12.7.B yesterday. I'm having issues finding the paper where the construction of 12.7.C is described, but now I'll try to modify `_EllipticLinesProjectivePlaneScheme` and see if I get what I need.



---

archive/issue_comments_424798.json:
```json
{
    "body": "12.7.B and C are 3-class only for a particular  value of q. The general q is not known, it seems.\nI'll ask Andries Brouwer.",
    "created_at": "2020-07-20T09:05:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424798",
    "user": "dimpase"
}
```

12.7.B and C are 3-class only for a particular  value of q. The general q is not known, it seems.
I'll ask Andries Brouwer.



---

archive/issue_comments_424799.json:
```json
{
    "body": "For 12.7.C the group PSigmaO(3,q) is used. However, I can't find much on that group online. With the GAP package FinInG I can obtain groups like PO, PGO, PSO and PGammaO (http://cage.ugent.be/fining/doc/chap7.html#X7988AF9978E75E37).\nDo you know what PSigmaO is?",
    "created_at": "2020-07-20T10:18:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424799",
    "user": "@Ivo-Maffei"
}
```

For 12.7.C the group PSigmaO(3,q) is used. However, I can't find much on that group online. With the GAP package FinInG I can obtain groups like PO, PGO, PSO and PGammaO (http://cage.ugent.be/fining/doc/chap7.html#X7988AF9978E75E37).
Do you know what PSigmaO is?



---

archive/issue_comments_424800.json:
```json
{
    "body": "Replying to [comment:25 gh-Ivo-Maffei]:\n> For 12.7.C the group PSigmaO(3,q) is used. However, I can't find much on that group online. With the GAP package FinInG I can obtain groups like PO, PGO, PSO and PGammaO (http://cage.ugent.be/fining/doc/chap7.html#X7988AF9978E75E37).\n> Do you know what PSigmaO is?\n\nIt is PSO extended by the Galois automorphisms - which for q=p<sup>k</sup>, p prime, form a cyclic group of order r, generated by the maps t->t<sup>p</sup> for each t in GF(q). (and the the action on the vectors is coordinatewise).\n\nThis notation may be found e.g. in the Altlas of Finite Groups by Conway et al.",
    "created_at": "2020-07-20T20:45:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424800",
    "user": "dimpase"
}
```

Replying to [comment:25 gh-Ivo-Maffei]:
> For 12.7.C the group PSigmaO(3,q) is used. However, I can't find much on that group online. With the GAP package FinInG I can obtain groups like PO, PGO, PSO and PGammaO (http://cage.ugent.be/fining/doc/chap7.html#X7988AF9978E75E37).
> Do you know what PSigmaO is?

It is PSO extended by the Galois automorphisms - which for q=p<sup>k</sup>, p prime, form a cyclic group of order r, generated by the maps t->t<sup>p</sup> for each t in GF(q). (and the the action on the vectors is coordinatewise).

This notation may be found e.g. in the Altlas of Finite Groups by Conway et al.



---

archive/issue_comments_424801.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29905",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29905#issuecomment-424801",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
