# Issue 16629: (q,4,1) and (q,5,1) difference families (Buratti 1995)

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2014-08-22 11:43:32

CC:  ncohen

Implementation of Buratti constructions.


---

Comment by vdelecroix created at 2014-08-22 11:58:05

Last 10 new commits:


---

Comment by vdelecroix created at 2014-08-22 11:58:05

Changing status from new to needs_review.


---

Comment by ncohen created at 2014-08-22 13:32:45

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2014-08-22 13:33:18

(Vincent found a more general version of this construction, and it is not worth merging this only to remove it later)


---

Comment by vdelecroix created at 2014-08-22 13:46:11

Changing status from positive_review to needs_work.


---

Comment by vdelecroix created at 2014-08-22 13:46:11

I will use the ticket for the more general version...


---

Comment by git created at 2015-01-18 19:21:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-01-18 19:22:44

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-01-18 19:29:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-01-18 21:28:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-01-19 19:29:40

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-01-19 19:30:54

Hi,

I ended up with some modifs in `incidence_structure.py` that has nothing to do with this ticket... sorry for the forced push.

Vincent


---

Comment by ncohen created at 2015-01-21 09:53:34

Hello !

I am trying to review this patch but I am lost in many places for the moment, so it may not be ligthning quick. About `one_cyclic_tiling`: the DLX algorithm is a pure exhaustive search. It enumerates all subsets of tiles, and explores everything until the current set cannot be extended anymore. There is no "smart cut" to detect easily that something cannot be completed. That algorithm is nothing but a "very careful and smart" implementation of that search, and so I do not believe that it is always the best.

Theoretically, what should be called there is `IncidenceStructure.packing` (this is exactly the problem that you want to solve).

Nathann


---

Comment by vdelecroix created at 2015-01-21 10:22:52

Replying to [comment:11 ncohen]:
> Hello !
> 
> About `one_cyclic_tiling`: the DLX algorithm is a pure exhaustive search.

I do not expect it to be the best.

> Theoretically, what should be called there is `IncidenceStructure.packing` (this is exactly the problem that you want to solve).

I would agree but the timings I got are not convincing. Please test the file I attached to the ticket

```
sage: timeit("t = test_all1(5,10)")
5 loops, best of 3: 78 ms per loop
sage: timeit("t = test_all1(6,12)")
5 loops, best of 3: 444 ms per loop
```

against

```
sage: timeit("t = test_all2(5,10)")
5 loops, best of 3: 267 ms per loop
sage: timeit("t = test_all2(6,12)")
5 loops, best of 3: 1.21 s per loop
```


The case of one tile on a circle is very symmetric and there might even be something better. Note also that for my instances the size of the tile is small compared to the size of the set.

Vincent


---

Attachment

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-01-23 13:01:31

Changing status from needs_review to needs_info.


---

Comment by ncohen created at 2015-01-23 13:01:31

Hello,

I tried to simplify the explanations a bit but I still do not understand the implementation. In particular I do not understand why you have this `-1` in the definition of `A`, and why you seem to solve a tiling problem on `A` and not on `\Delta A`.

Also, what would you think of removing the `one_cyclic_tiling` function? The name is not particularly meaningful, it is three lines long, only used once?...

Could you also add your new functions to the index at the top of the file?

My modifications can be found at `u/ncohen/16866`, but of course in that version your comments in the code use notations that I removed from the function's doc.

I can change that once I understand the implementation better.

Thanks,

Nathann


---

Comment by vdelecroix created at 2015-01-23 13:11:13

Replying to [comment:14 ncohen]:
> Hello,
> 
> I tried to simplify the explanations a bit but I still do not understand the implementation. In particular I do not understand why you have this `-1` in the definition of `A`, and why you seem to solve a tiling problem on `A` and not on `\Delta A`.

`A` appears explicitly when you compute `\Delta {1,r,r<sup>2,...,r</sup>(k-1)\}`. Its definition is obtained from differences already.
 
> Also, what would you think of removing the `one_cyclic_tiling` function? The name is not particularly meaningful, it is three lines long, only used once?...

True. But I wonder if we can do better for that particular problem. I also thought about moving it in some tiling stuff in `sage.combinat`. That way it would be better advertised.

> Could you also add your new functions to the index at the top of the file?

Right

> My modifications can be found at `u/ncohen/16866`, but of course in that version your comments in the code use notations that I removed from the function's doc.

I am having a look right now.

Vincent


---

Comment by ncohen created at 2015-01-23 13:14:10

Yo !

> `A` appears explicitly when you compute `\Delta {1,r,r<sup>2,...,r</sup>(k-1)\}`. Its definition is obtained from differences already.

I still don't get it. I expect to have a set of cardinality `k(k-1)` and I don't find it anywhere.

> True. But I wonder if we can do better for that particular problem. I also thought about moving it in some tiling stuff in `sage.combinat`. That way it would be better advertised.

Well, if it belongs to some tiling library (but really, for me tiling and packing are the same things..) and has a more meaningful name then no problem of course.

Nathann


---

Comment by vdelecroix created at 2015-01-23 13:25:26

Replying to [comment:16 ncohen]:
> Yo !
> 
> > `A` appears explicitly when you compute `\Delta {1,r,r<sup>2,...,r</sup>(k-1)\}`. Its definition is obtained from differences already.
> 
> I still don't get it. I expect to have a set of cardinality `k(k-1)` and I don't find it anywhere.

True but there is a formula in my docstring:

```
   It is easy to verify (see [Wi72]_) that we have for `k` odd `\Delta H^{2mt}
    =  A H^{mt}` while for `k` even `\Delta (H^{2mt} \cup \{0\}) = A H^{mt}`.
    Here `\Delta B` is the set of differences of distinct elements in `B`.
```

And you can check that `# (A H^{mt}) = #A # H^{mt}` has cardinality k(k-1).

> > True. But I wonder if we can do better for that particular problem. I also thought about moving it in some tiling stuff in `sage.combinat`. That way it would be better advertised.
> 
> Well, if it belongs to some tiling library (but really, for me tiling and packing are the same things..) and has a more meaningful name then no problem of course.

Right, tiling/packing I do not care but there exists `sage.combinat.tiling` for some 2-dimensional tilings with polyominos.

Vincent


---

Comment by ncohen created at 2015-01-23 14:56:31

Yo !

> And you can check that `# (A H^{mt}) = #A # H^{mt}` has cardinality k(k-1).

Do you create this set of cardinality k(k-1) in your code ?

> Right, tiling/packing I do not care but there exists `sage.combinat.tiling` for some 2-dimensional tilings with polyominos.

Oh nice.

Nathann


---

Comment by vdelecroix created at 2015-01-23 15:05:43

Replying to [comment:18 ncohen]:
> Yo !
> 
> > And you can check that `# (A H^{mt}) = #A # H^{mt}` has cardinality k(k-1).
> 
> Do you create this set of cardinality k(k-1) in your code ?

Nope, and I do not need to do so. I want that my set of differences cover the whole H. Because all differences are a union of cosets of H<sup>mt</sup>, you can quotient out by H<sup>mt</sup> (i.e. reasoning in terms of the cosets xH<sup>mt</sup>).

Once you checked that the elements of A belong to distinct cosets mod H<sup>mt</sup>, you need to find a set of translates {x_1 A, x_2 A, ..., x_k A} that tile (or pack) the quotient H/H<sup>mt</sup>

Vincent


---

Comment by ncohen created at 2015-01-23 17:06:01

Yo!

> Nope, and I do not need to do so. I want that my set of differences cover the whole H. Because all differences are a union of cosets of H<sup>mt</sup>, you can quotient out by H<sup>mt</sup> (i.e. reasoning in terms of the cosets xH<sup>mt</sup>).

Hmmmm... I spent the last hour in front of that code, and I still don't understand how exactly it works. Besides, I wonder: do you think that it makes any difference in the computations? If you want to compute a tiling with the sets A0, A1, ... it will take the same time as doing it on A0 U A0', A1 U A1', ... where the Ai' are copies of the Ai on a disjoint set.

What do you think ?

Nathann


---

Comment by vdelecroix created at 2015-01-23 17:25:45

Replying to [comment:20 ncohen]:
> Yo!
> 
> > Nope, and I do not need to do so. I want that my set of differences cover the whole H. Because all differences are a union of cosets of H<sup>mt</sup>, you can quotient out by H<sup>mt</sup> (i.e. reasoning in terms of the cosets xH<sup>mt</sup>).
> 
> Hmmmm... I spent the last hour in front of that code, and I still don't understand how exactly it works.

Too bad. If you tell me where, I can be clearer in the comments.

> Besides, I wonder: do you think that it makes any difference in the computations? If you want to compute a tiling with the sets A0, A1, ... it will take the same time as doing it on A0 U A0', A1 U A1', ... where the Ai' are copies of the Ai on a disjoint set.

What do you mean by "the same time". There is the same number of tiles in the packing at the end but if you ignore the symmetries there are much more possible translations.

> What do you think ?

That my code works and that it is good to have smaller instances of the problem to solve.

Vincent


---

Comment by ncohen created at 2015-01-23 17:35:36

Yo!

> Too bad. If you tell me where, I can be clearer in the comments.

Well, for a start I had no idea at first what was this "A" that you defined, least of all why you have this `-1`. Then you seemed to say that all differences belonged to different cosets of `H^{mt}` (I don't understand what this set is), but it seems to mean that you can only consider the differences obtained with 1.

I don't get why you have this `A.append(K.one())`, I would have expected `-K.one()` (i.e. the difference 0-1). Then I do not understand the cut with the `len(set(logA))`.

> What do you mean by "the same time". There is the same number of tiles in the packing at the end but if you ignore the symmetries there are much more possible translations.

I do not get exactly what your reduction of the ground set means with respect to the partition instance. What I mean is that an instance with the A0 U A0', A1 U A1', ... above is totally equivalent (in terms of resolution, and in terms of time) to an instance with A0, A1, ...

I was wondering if that was the difference that there is, in this branch, between considering the cosets that you mention and not considering them.

> That my code works and that it is good to have smaller instances of the problem to solve.

It is not necessarily an improvement to reduce the number of vertices, e.g. the example above. And so far I do not understand how your code works.

Nathann


---

Comment by vdelecroix created at 2015-01-23 17:56:49

Replying to [comment:22 ncohen]:
> Yo!
> 
> > Too bad. If you tell me where, I can be clearer in the comments.
> 
> Well, for a start I had no idea at first what was this "A" that you defined, least of all why you have this `-1`. Then you seemed to say that all differences belonged to different cosets of `H^{mt}` (I don't understand what this set is), but it seems to mean that you can only consider the differences obtained with 1.

No. I want that all differences belong to different coset. This is something that need to be checked and which are precisely the two lines

```
    if len(set(logA)) != m:
        return None
```


> I don't get why you have this `A.append(K.one())`, I would have expected `-K.one()` (i.e. the difference 0-1). Then I do not understand the cut with the `len(set(logA))`.

This comes from computing what is Delta {1, r, r<sup>2</sup>, ..., r<sup>k-1</sup>} (where r is a k-th root of unity). If you do that you will see that it is the same as {+1, -1} A H<sup>mt</sup>. In the case of k even you want to compute Delta {0, 1, r, ..., r<sup>k-2</sup>} (where r is a (k-1)-th root of unity).

For the cut, see above.

> > What do you mean by "the same time". There is the same number of tiles in the packing at the end but if you ignore the symmetries there are much more possible translations.
> 
> I do not get exactly what your reduction of the ground set means with respect to the partition instance. What I mean is that an instance with the A0 U A0', A1 U A1', ... above is totally equivalent (in terms of resolution, and in terms of time) to an instance with A0, A1, ...

H has cardinality q-1 while H/H<sup>mt</sup> has cardinality mt = (q-1)/(k-1) or (q-1)/k depending on the parity of k.
 
> I was wondering if that was the difference that there is, in this branch, between considering the cosets that you mention and not considering them.
> 
> > That my code works and that it is good to have smaller instances of the problem to solve.
> 
> It is not necessarily an improvement to reduce the number of vertices, e.g. the example above.
> And so far I do not understand how your code works.

Good point

Vincent


---

Comment by ncohen created at 2015-01-23 19:50:40

> No. I want that all differences belong to different coset.

Why can you make that assumption ?

> This comes from computing what is Delta {1, r, r<sup>2</sup>, ..., r<sup>k-1</sup>} (where r is a k-th root of unity). If you do that you will see that it is the same as {+1, -1} A H<sup>mt</sup>. In the case of k even you want to compute Delta {0, 1, r, ..., r<sup>k-2</sup>} (where r is a (k-1)-th root of unity).

I have absolutely no intuition of what H<sup>mt</sup> represents.

> > And so far I do not understand how your code works.
> 
> Good point

Do you think that the tiling problem that you solve is equivalent, by the previous remarks, to the non-reduced problem ? If so, that would make it easier for me to understand.

Nathann


---

Comment by vdelecroix created at 2015-01-23 20:24:24

Replying to [comment:24 ncohen]:
> > No. I want that all differences belong to different coset.
> 
> Why can you make that assumption ?

Because you want a difference family at the end! Let me recall that B = \Delta H<sup>2mt</sup> = A H<sup>mt</sup> is your basic block (see below for explanation). If two class of A belong to the same set modulo H<sup>mt</sup> them it means that in the product A H<sup>mt</sup> you have zero. Which contradict the definition of difference family which needs to cover K \ {0}.
 
> > This comes from computing what is Delta {1, r, r<sup>2</sup>, ..., r<sup>k-1</sup>} (where r is a k-th root of unity). If you do that you will see that it is the same as {+1, -1} A H<sup>mt</sup>. In the case of k even you want to compute Delta {0, 1, r, ..., r<sup>k-2</sup>} (where r is a (k-1)-th root of unity).
> 
> I have absolutely no intuition of what H<sup>mt</sup> represents.

H is the set of invertible elements in the finite field (it has cardinal q-1 and form a group under multiplication. H<sup>j</sup> is the set of j-th power in H.

In our context, H<sup>mt</sup> is the set of (2k)-th root of unity or 2(k-1)-th root of unity depending on the parity of k. It is also {+1, -1} H<sup>2mt</sup> where H<sup>2mt</sup> is the set of k-th root of unity or (k-1)-th root of unity (depending on the parity.

> > > And so far I do not understand how your code works.
> > 
> > Good point
> 
> Do you think that the tiling problem that you solve is equivalent, by the previous remarks, to the non-reduced problem ? If so, that would make it easier for me to understand.

Yes. If you solve the big one, you solve the small one (and conversly).

Vincent


---

Comment by ncohen created at 2015-01-23 21:02:50

> Yes. If you solve the big one, you solve the small one (and conversly).
Do you have reasons to believe that it would make a difference in the runtimes to solve the non reduced version? It is the only one that I understand so far.

Nathann


---

Comment by vdelecroix created at 2015-01-23 21:16:41

Replying to [comment:26 ncohen]:
> > Yes. If you solve the big one, you solve the small one (and conversly).
> Do you have reasons to believe that it would make a difference in the runtimes to solve the non reduced version? It is the only one that I understand so far.

I do have reasons (but it is not very important though).

More importantly, I want to keep the shortcut if some element of A belong to the same coset of H<sup>mt</sup>. And I do not want to compute these cosets and then forgot about them...

Vincent


---

Comment by vdelecroix created at 2015-04-01 09:14:45

Changing status from needs_info to needs_review.


---

Comment by git created at 2015-04-01 10:08:07

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by ncohen created at 2015-04-03 08:46:06

Helloooo Vincent !

I added at public/16866 a commit that rewrites the documentation. I began to touch the code itself but so far I do not understand the reason behind this `m=k//2`, and why your set `A` has cardinality `k/2` instead of `k-1`. I made that change and many doctests broke, so could you please enlighten me?

Thanks,

Nathann

P.S.: the doc's notations match the code


---

Comment by ncohen created at 2015-04-03 08:46:06

Changing status from needs_review to needs_info.


---

Comment by git created at 2015-04-03 13:57:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-04-03 13:58:22

Thanks! I adopted your commit and added two:
- one to explain in the doc the `m/2`
- the other one to get rid of the `wilson_XXX` that can be thought as a special case of the newly created one

Vincent


---

Comment by vdelecroix created at 2015-04-03 13:59:10

Changing status from needs_info to positive_review.


---

Comment by vdelecroix created at 2015-04-03 14:52:33

Changing status from positive_review to needs_work.


---

Comment by vdelecroix created at 2015-04-03 14:52:41

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2015-04-04 06:26:03

Helloooooooooooooo !

I am finally convinced by everything that was done in this patch. I only have two commits to offer at public/16866.

1) One that makes the notations of the doc and code match
2) One that changes `print_tiling` to display '.' instead of blank spaces.

You turn `;-)`

Nathann


---

Comment by ncohen created at 2015-04-04 06:45:25

Changing keywords from "" to "sd66".


---

Comment by git created at 2015-04-05 17:48:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-05 18:29:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-04-05 18:31:01

I am happy with the current situation.


---

Comment by ncohen created at 2015-04-05 18:53:41

Making you happy is Sage's purpose.

Thanks for the branch,

Nathann


---

Comment by ncohen created at 2015-04-05 18:53:41

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-04-14 19:44:11

Resolution: fixed
