# Issue 19349: Add is_cayley_graph

Issue created by migration from https://trac.sagemath.org/ticket/19586

Original creator: jaanos

Original creation time: 2015-11-14 13:07:00

CC:  ncohen dimpase




---

Comment by jaanos created at 2015-11-14 13:33:23

Changing component from PLEASE CHANGE to graph theory.


---

Comment by jaanos created at 2015-11-14 13:33:23

Changing keywords from "" to "Cayley graphs groups".


---

Comment by jaanos created at 2015-11-14 13:33:23

I should point out some questions and issues I have with this before it goes into review.

* Should the method be called `is_cayley_graph`, or just `is_cayley`?
* The current implementation is slow, mainly due to the slow GAP interface and the unneeded work done by `conjugacy_classes_subgroups`. Ticket #19585 already improves this, but it would be even better to do something like this:


```python
gap = A._gap_().parent()
C = gap.new("""
    First(ConjugacyClassesSubgroups(%s),
        x -> Order(Representative(x)) = %d
            and IsTransitive(Representative(x), [1..%d]));
""" % (A._gap_().name(), n, n))
c = (gap.eval('%s = fail' % C.name()) != 'true')
if c and certificate:
    G = A.subgroup(gap_group=C.Representative())
```

Now, I guess that maybe this doesn't really belong in `generic_graph.py`. But maybe we could have a method in `PermutationGroup_generic` which checks for the existence of such a group (and have it returned if requested)?

* I should probably check whether the function works correctly with graphs with loops and multigraphs (my instinct says yes for the former and no for the latter).
* Can we have Unicode characters in the docstrings? If I spell my name properly, Sage compiles, but the documentation doesn't. I guess I could add `# -*- coding: utf-8 -*-` to the top of the file (haven't tested it), but I don't know if we want to do it:)

----
New commits:


---

Comment by jaanos created at 2015-11-14 13:33:23

Changing type from PLEASE CHANGE to enhancement.


---

Comment by ncohen created at 2015-11-14 19:14:20

Hellooooo,

> I should point out some questions and issues I have with this before it goes into review.

I will try t answer them.

> * Should the method be called `is_cayley_graph`, or just `is_cayley`?

We have 'is_perfect', 'is_chordal', 'is_cartesian_product', so I'd vote for 'is_cayley'.

> Now, I guess that maybe this doesn't really belong in `generic_graph.py`. But maybe we could have a method in `PermutationGroup_generic` which checks for the existence of such a group (and have it returned if requested)?

Do you know how such a function could be named? Having 'nice and natural name' for this function would rule out the alternative of having a 'hidden helper function' for this code.

> * I should probably check whether the function works correctly with graphs with loops and multigraphs (my instinct says yes for the former and no for the latter).

You are not 'forced' to make it work in those cases. If it is complicated or if you do not want to deal with those cases, you should look at 'scream_if_not_simple'. It happens very often throughout the graph/ code.

> * Can we have Unicode characters in the docstrings?

We can, and you can add this directive to the top of the file if you need to. Now, I am not really a big fan of adding a name every time one adds a function. That's just me, and perhaps some others. We already have 'git blame' to figure out who wrote a function, and having in each function the names of all people who ever touched it could quickly grow out of hands. And I personally don't see the added value, and I personally don't want to see Sage's source code turn out into a way to advertise its developers.

I added 'personally' everywhere to insist that it is my view, and that other developers have different opinions. By our customs, you are totally allowed to add your name in an author block if you want to.

Thanks for adding this function,

Nathann


---

Comment by jaanos created at 2015-11-14 19:46:51

Changing status from new to needs_info.


---

Comment by jaanos created at 2015-11-14 19:46:51

Hi!

> > * Should the method be called `is_cayley_graph`, or just `is_cayley`?
> 
> We have 'is_perfect', 'is_chordal', 'is_cartesian_product', so I'd vote for 'is_cayley'.

OK, will change.

> > Now, I guess that maybe this doesn't really belong in `generic_graph.py`. But maybe we could have a method in `PermutationGroup_generic` which checks for the existence of such a group (and have it returned if requested)?
> 
> Do you know how such a function could be named? Having 'nice and natural name' for this function would rule out the alternative of having a 'hidden helper function' for this code.

Maybe `has_transitive_subgroup(order = None, certificate = False)`? By default, it would just tell whether the group itself is transitive; otherwise, a subgroup of given order would be looked for (and returned if `certificate` is `True`).

> > * I should probably check whether the function works correctly with graphs with loops and multigraphs (my instinct says yes for the former and no for the latter).
> 
> You are not 'forced' to make it work in those cases. If it is complicated or if you do not want to deal with those cases, you should look at 'scream_if_not_simple'. It happens very often throughout the graph/ code.

I don't think it will be too complicated, I just haven't thought about it when coding. But thanks for the info, it is certainly useful to know about this option.

> > * Can we have Unicode characters in the docstrings?
> 
> We can, and you can add this directive to the top of the file if you need to. Now, I am not really a big fan of adding a name every time one adds a function. That's just me, and perhaps some others. We already have 'git blame' to figure out who wrote a function, and having in each function the names of all people who ever touched it could quickly grow out of hands. And I personally don't see the added value, and I personally don't want to see Sage's source code turn out into a way to advertise its developers.
> 
> I added 'personally' everywhere to insist that it is my view, and that other developers have different opinions. By our customs, you are totally allowed to add your name in an author block if you want to. 

OK, I will remove my name (indeed, I had copied the docstring of one of your functions, so the author field was there) - I am certainly not claiming to have invented this algorithm:)

> Thanks for adding this function,
No problem!

Janoš


---

Comment by ncohen created at 2015-11-14 20:21:52

Helloooooo,

> Maybe `has_transitive_subgroup(order = None, certificate = False)`? By default, it would just tell whether the group itself is transitive; otherwise, a subgroup of given order would be looked for (and returned if `certificate` is `True`).

+1 to that.

> OK, I will remove my name (indeed, I had copied the docstring of one of your functions, so the author field was there) - I am certainly not claiming to have invented this algorithm:)

Oh. Well, then it probably sounds very hypocritical of me to say that when you copy/pasted a function which contained my own name in an author field `O_o`

I cannot tell which function it was, but I really do try to keep this to a minimum (at least when it comes to my own name).

Nathann


---

Comment by git created at 2015-11-14 20:45:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-14 21:45:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-14 22:11:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jaanos created at 2015-11-14 22:13:24

OK, I think I have addressed all the issues. If this is OK, I guess we can also make more direct calls to GAP in the methods `conjugacy_classes_subgroups` and `subgroups` (in another ticket, of course).


---

Comment by jaanos created at 2015-11-14 22:13:24

Changing status from needs_info to needs_review.


---

Comment by ncohen created at 2015-11-15 09:15:34

Dima, I add you to this ticket just in case you might have some time to look at `PermutationGroup.has_transitive_subgroup`.


---

Comment by ncohen created at 2015-11-15 09:44:14

Hello Janoš,

I wonder about the 'is_connected' case in your algorithm. Does it really make a different in the running times? I thought that perhaps the 'isomorphism_group' implementations already handled that, in which cas it may not make any significant difference and so we could do without this specific block of code?

Nathann


---

Comment by jaanos created at 2015-11-15 10:46:57

Hi!

Testing with the example in the docstring (5*Paley(9)) confirms that there is a big difference in running times. The reason is of course that disconnected vertex-transitive graphs will have a very large group of automorphisms, and GAP will take very long to compute the lattice of subgroups. So, in most cases it will be cheaper to do the check for a connected component, and then inflate the certificate if requested (what the method actually does is return the direct product of the group for a connected component and a cyclic group).

Janoš


---

Comment by ncohen created at 2015-11-15 11:38:12

Oh, of course. Sorry for this question: I had first thought that you were optimizing the computation of `automorphism_group`, but of course you were optimizing the call to `conjugacy_classes_subgroups`.


---

Comment by ncohen created at 2015-11-15 13:50:07


```
adj = [y if v == x else x for x, y, z in self.edge_iterator(v)]
```


Are you looking for `Graph.neighbors` ?

Nathann


---

Comment by jaanos created at 2015-11-15 15:18:17

Hi!

> Are you looking for `Graph.neighbors` ?

I had this, but changed to `edge_iterator` since `neighbors` does not list a vertex multiple times if there are multiple edges to it (so maybe this is something that should be changed?). Also, this covers digraphs without needing an additional `if`.

Janoš


---

Comment by ncohen created at 2015-11-15 15:32:07

Yo,

I am impressed with your code: not a single line seems out of place. Could you add a comment around this call to 'edge_iterator', to say that you mean to deal with all (out-)neighbors with multiplicity?

Could you also add a doctest (possibly in a 'TESTS:' section) for those directed/multigraph cases?

I believe that the graph part of your code is good to go, but I would like to have Dima's input for the 'gap'-specific code.

Thanks,

Nathann


---

Comment by jaanos created at 2015-11-15 16:35:18

Hi!

> I am impressed with your code: not a single line seems out of place. Could you add a comment around this call to 'edge_iterator', to say that you mean to deal with all (out-)neighbors with multiplicity?
Thanks! Will do, just a bit later (currently I'm trying various solutions for #19585).

> Could you also add a doctest (possibly in a 'TESTS:' section) for those directed/multigraph cases?
Sure. By the way, do we have any easily-constructible multigraphs/graphs with loops ready? Otherwise there'd be a few lines of code just to construct the graph.

Also, `cayley_graph` on a group will not return multiedges or loops, even when the generators contain repeated elements or the identity and `simple` is set to `False`. So maybe this is something that should be changed.

Janoš


---

Comment by ncohen created at 2015-11-15 16:42:38

Hello,

> Thanks! Will do, just a bit later (currently I'm trying various solutions for #19585).

Okayyyyyy.

> Sure. By the way, do we have any easily-constructible multigraphs/graphs with loops ready? Otherwise there'd be a few lines of code just to construct the graph.

The only ones I know are the directed GNP:

```
sage: digraphs.RandomDirectedGNP(5,.2,loops=True)
RandomDirectedGNP(5,0.200000000000000): Looped digraph on 5 vertices
```


> Also, `cayley_graph` on a group will not return multiedges or loops, even when the generators contain repeated elements or the identity and `simple` is set to `False`. So maybe this is something that should be changed.

If you have a use for something like that, of course.

Nathann


---

Comment by git created at 2015-11-15 18:11:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jaanos created at 2015-11-15 18:15:42

Hi!

OK, I added the comment and the doctest.

> The only ones I know are the directed GNP:

Thanks, but of course these won't help here. I've used an augmented Paley(9) graph instead.

> > Also, `cayley_graph` on a group will not return multiedges or loops, even when the generators contain repeated elements or the identity and `simple` is set to `False`. So maybe this is something that should be changed.
> 
> If you have a use for something like that, of course.

Not really, except possibly for doctesting (and consistency).

Janoš


---

Comment by dimpase created at 2015-11-15 21:24:37

I'd investigate whether being more careful with computing subgroups might help. Perhaps you can use some lower level GAP calls to find a lattice of transitive subgroups, which ought to be much smaller.

Or you can compute maximal subgroup classes (cf. GAP's `ConjugacyClassesMaximalSubgroups`), and recurse on these which are transitive.


---

Comment by jaanos created at 2015-11-16 01:48:24

Hello!

Thanks, will look into it. It seems that it could be done without too much trouble using `MaximalSubgroupClassReps`.

Janoš


---

Comment by jaanos created at 2015-11-28 09:34:52

Hello again!

Sorry about the inactivity, I have been pretty busy. Also, I was probably too quick to judge that a more low-level GAP procedure could be done without too much trouble.

Would it be OK to accept this as is, and then possibly improve the search for transitive subgroups in another ticket?

Janoš


---

Comment by ncohen created at 2015-11-28 09:41:58

> Sorry about the inactivity, I have been pretty busy. Also, I was probably too quick to judge that a more low-level GAP procedure could be done without too much trouble.
> 
> Would it be OK to accept this as is, and then possibly improve the search for transitive subgroups in another ticket?

No, all the code has to be reviewed. I expect it to be as clean as the part I reviewed, yet somebody has to do check it. I cannot tell about the code, but the name 'has_transitive_subgroup', for instance, sounds misleading. It does not mention any kind of 'order', so by just lookig at the function's name you would not understand how it could return anything different from `.is_transitive`. That's also the kind of things a reviewer should look at, besides the GAP technicalities.

Nathann


---

Comment by jaanos created at 2015-11-28 11:41:44

Hi!

> No, all the code has to be reviewed. I expect it to be as clean as the part I reviewed, yet somebody has to do check it. I cannot tell about the code, but the name 'has_transitive_subgroup', for instance, sounds misleading. It does not mention any kind of 'order', so by just lookig at the function's name you would not understand how it could return anything different from `.is_transitive`. That's also the kind of things a reviewer should look at, besides the GAP technicalities.

Yes, I understand it has to be reviewed - I was just saying that maybe we don't try to optimize the GAP code within this ticket (if that's acceptable, of course).

As for the function name, do you have any suggestions? Maybe something like `has_transitive_subgroup_of_order`?

Janoš


---

Comment by ncohen created at 2015-11-28 11:44:25

> Yes, I understand it has to be reviewed - I was just saying that maybe we don't try to optimize the GAP code within this ticket (if that's acceptable, of course).

Oh, I see. Well, then I cannot answer the question as I do nto understand what the gap code does.

> As for the function name, do you have any suggestions? Maybe something like `has_transitive_subgroup_of_order`?

Nothing better than that, and the name is so ugly that it might as well be a hidden 'helper' function `:-/`

Isn't there a group-theoretic notion that would 'mean the same'? `:-/`

Nathann


---

Comment by dimpase created at 2015-11-28 11:58:38

Replying to [comment:26 ncohen]:
> > Yes, I understand it has to be reviewed - I was just saying that maybe we don't try to optimize the GAP code within this ticket (if that's acceptable, of course).
> 
> Oh, I see. Well, then I cannot answer the question as I do nto understand what the gap code does.
> 
> > As for the function name, do you have any suggestions? Maybe something like `has_transitive_subgroup_of_order`?

How about naming it `transitive_subgroup`, and simplifying the interface,` so that it either returns a subgroup of order `n` (the parameter) or `None`, and no pairs...


---

Comment by dimpase created at 2015-11-28 12:20:00

as well, I'd propose to remove `certificate` business totally, and rename the main function  `caley_graph_group()`: it would return a group if one exists, or `None` if there is no such group; indeed, the extra cost of returning a group is zero, compared to the overall complexity of the task at hand.


---

Comment by jaanos created at 2015-11-28 13:39:23

Hi!

Hmm, I would still like to have an `is_cayley` method for graphs. But I agree about having a method `transitive_subgroup` for permutation groups. Still, I'm a bit worried about cases when we have a large graph with a relatively small automorphism group (say, twice the order of the graph) - then finding an appropriate subgroup will be fast, but actually returning it (so a Sage subgroup can be built) may make a non-negligible contribution to the running time (since reading GAP output can be slow). So I propose:
- we have a `transitive_subgroup` method, which by default returns a transitive subgroup of given order,
- `transitive_subgroup` may be explicitly told not to return the group (by setting, say, `return_group` to `False`),
- we add a helper method (say, `_transitive_subgroup_gap`) which returns a GAP object containing the subgroup (we could make the result cached, so if one first asks whether a graph is Cayley and then wants to know the group, it needn't be recomputed).

This way, `transitive_subgroup` can call the helper function, and then avoid actually reading the GAP subgroup if it is told not to return it.

What do you think?

Janoš


---

Comment by git created at 2015-11-28 18:53:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jaanos created at 2015-11-28 19:03:30

I have implemented the ideas from the previous comment. I have marked both `transitive_subgroup` and `_transitive_subgroup_gap` as cached, although currently it seems that this will not affect the (re)running times of `is_cayley`, as the automorphism group of a graph is not cached. Is this something that should be changed (in another ticket, of course), or should I just remove caching for the two methods?


---

Comment by dimpase created at 2015-11-28 20:02:42

Replying to [comment:29 jaanos]:

> Hmm, I would still like to have an `is_cayley` method for graphs.

sure, such a method can just check whether `cayley_graph_group()` is `None`.


> But I agree about having a method `transitive_subgroup` for permutation groups. Still, I'm a bit > worried about cases when we have a large graph with a relatively small automorphism group (say, twice the order of the graph) - then finding an appropriate subgroup will be fast, but actually returning it (so a Sage subgroup can be built) may make a non-negligible contribution to the running time (since reading GAP output can be slow). 

as a switch to `libgap` will happen sooner or later, optimising for not reading GAP output
does not seem to be that important.


> So I propose:
> - we have a `transitive_subgroup` method, which by default returns a transitive subgroup of given order,
> - `transitive_subgroup` may be explicitly told not to return the group (by setting, say, `return_group` to `False`),
> - we add a helper method (say, `_transitive_subgroup_gap`) which returns a GAP object containing the subgroup (we could make the result cached, so if one first asks whether a graph is Cayley and then wants to know the group, it needn't be recomputed).
> 
> This way, `transitive_subgroup` can call the helper function, and then avoid actually reading the GAP subgroup if it is told not to return it.
> 
> What do you think?

this ceritainly looks better, but again, I don't like the counter-intuitive parameters of `is_cayley()` and weird sort of output (a pair) that you currently have. In particular the latter.


---

Comment by jaanos created at 2015-11-29 01:18:25

Hi!

> as a switch to `libgap` will happen sooner or later, optimising for not reading GAP output
> does not seem to be that important.

I see. But should I do anything about it at this point?

> this ceritainly looks better, but again, I don't like the counter-intuitive parameters of `is_cayley()` and weird sort of output (a pair) that you currently have. In particular the latter.

I have modelled both input and output of `is_cayley` after methods such as `is_chordal` and `is_circulant`. I guess we could be even more specific and have the function return only the group or only the generators if requested - or maybe `cayley_graph_group` could do that, and `is_cayley` would then simply call `cayley_graph_group` without requesting either.

Janoš


---

Comment by dimpase created at 2015-11-29 07:59:03

Replying to [comment:33 jaanos]:
> Hi!
> 
> > as a switch to `libgap` will happen sooner or later, optimising for not reading GAP output
> > does not seem to be that important.
> 
> I see. But should I do anything about it at this point?
> 
> > this ceritainly looks better, but again, I don't like the counter-intuitive parameters of `is_cayley()` and weird sort of output (a pair) that you currently have. In particular the latter.
> 
> I have modelled both input and output of `is_cayley` after methods such as `is_chordal` and `is_circulant`. 

not all silly designs in Sage should be copied...
Looks like someone didn't know, or forgot, about `None`

> I guess we could be even more specific and have the function return only the group or only the generators if requested - or maybe `cayley_graph_group` could do that,

only the generators? Why? it's one quick function call away from the group, why would you
do this in library code? In particular, as you are computing the group, not its generators, in the first place.

> and `is_cayley` would then simply call `cayley_graph_group` without requesting either.e.
sure.


---

Comment by jaanos created at 2015-11-29 13:02:55

Hello!

> not all silly designs in Sage should be copied...
> Looks like someone didn't know, or forgot, about `None`

I don't know, it seems pretty reasonable to me to have an `is_property` method with the option to return a certificate for either having or not having this property. Now, I don't know of any way to provide an easy-to-check certificate of non-Cayleyness, but if one is eventually found, it can be returned alongside the boolean telling whether a graph is a Cayley graph - so the user doesn't need to check what kind of certificate the function returned.

As for the certificate of Cayleyness, I am thinking that a better option would be to return a map from vertices to group elements (which the current function already computes when computing the generators) - now it can be easily checked that the elements form a group, and that the generating set is well defined (instead of having to compute an isomorphism between the graph and the Cayley graph built from the group and generating set). Actually computing the group (and returning it alongside the generating set and the map, if requested) would then be delegated to `cayley_graph_group`, as you proposed.


> only the generators? Why? it's one quick function call away from the group, why would you
> do this in library code? In particular, as you are computing the group, not its generators, in the first place.

Well, I think if we're giving the user the choice of what they want returned, it would be unreasonable to forbid a certain choice just because we see no use for it.

Janoš


---

Comment by dimpase created at 2015-11-29 15:32:32

Replying to [comment:35 jaanos]:
> 
> > only the generators? Why? it's one quick function call away from the group, why would you
> > do this in library code? In particular, as you are computing the group, not its generators, in the first place.
> 
> Well, I think if we're giving the user the choice of what they want returned, it would be unreasonable to forbid a certain choice just because we see no use for it.

it's an unreasonable code bloat to include a special function for anything that is
a trivial one-liner; e.g. if you start returning the generators, you might be tempted to add a function that only returns the number of generators, etc etc :-)

And you are not depriving the user from getting what he wants in any way by not providing
an option for any trivial one-liner applied to the return value, not at all..

IMHO it's also against the spirit of OOP to have an option in a function `f` to return either `X` or `X.blah()`; the user can call `.blah()` on the answer he gets himself; and `X` is already created in `f`, there is no performance gain in returning X.blah() instead of `X`.


---

Comment by ncohen created at 2015-11-29 15:56:39

> IMHO it's also against the spirit of OOP to have an option in a function `f` to return either `X` or `X.blah()`; the user can call `.blah()` on the answer he gets himself; and `X` is already created in `f`, there is no performance gain in returning X.blah() instead of `X`.

Are we sure that a permuation group defined from a set of generators returns the *very same* set of generators when you call `.gen()`? Or could they be simplified/reduced if Gap believe that another representation is better?

Nathann


---

Comment by dimpase created at 2015-11-29 16:05:54

Replying to [comment:37 ncohen]:
> > IMHO it's also against the spirit of OOP to have an option in a function `f` to return either `X` or `X.blah()`; the user can call `.blah()` on the answer he gets himself; and `X` is already created in `f`, there is no performance gain in returning X.blah() instead of `X`.
> 
> Are we sure that a permuation group defined from a set of generators returns the *very same* set of generators when you call `.gen()`? Or could they be simplified/reduced if Gap believe that another representation is better?

In GAP `GeneratorsOfGroup` need not return the original list of generators used to define the group in the first place.

```
  39.2-2 GroupByGenerators
  
  ‣ GroupByGenerators( gens ) ──────────────────────────────────────────────────────────────── operation
  ‣ GroupByGenerators( gens, id ) ──────────────────────────────────────────────────────────── operation
  
  GroupByGenerators  returns  the group G generated by the list gens. If a second argument id is present
  then this is stored as the identity element of the group.
  
  The   value   of   the  attribute  GeneratorsOfGroup  (39.2-4)  of  G  need  not  be  equal  to  gens.
  GroupByGenerators is the underlying operation called by Group (39.2-1).
```


I don't know how to recover the original generators from `Group`; it could very well be that they get lost, by design.

If one needs to keep the original ones, he can use `GroupWithGenerators`.


---

Comment by jaanos created at 2015-11-29 16:37:18

Perhaps I was not being precise enough: I was talking about the generating set of the Cayley graph, not about the generators of the group.

So, a user may want any of the following (where computing each relies on the previous):
1. whether there exists a transitive subgroup of the automorphism group with the same order as the graph,
2. one such group,
3. a map from vertices to group elements,
4. a (multi)set of group elements that acts as the generating set for the Cayley graph.

Now, going from step 2 to steps 3 and 4 surely is not hard (4 lines of code), but it is not something that can be done with a simple method call, and step 4 it is certainly not something that can be computed from the group itself.

Anyway, I was probably wrong that the map would be a better certificate than the group, as the former is clearly easily computable from the latter.

By the way, what we're actually looking for here is a regular subgroup, so that's what the group method should be called (and we can also simplify the GAP call).

Janoš


---

Comment by dimpase created at 2015-11-29 18:17:05

Replying to [comment:39 jaanos]:
> Perhaps I was not being precise enough: I was talking about the generating set of the Cayley graph, not about the generators of the group.


well, how about having a proper `digraphs.CayleyGraph()` constructor?
(one can use GRAPE package of GAP, which is going to be re-released under GPL)
e.g.

```
gap> LoadPackage("grape");
true
gap> C:=CayleyGraph(SymmetricGroup(4),[(1,2),(2,3),(3,4)]);
rec( adjacencies := [ [ 2, 3, 7 ] ], group := Group([ (1,10,17,19)(2,9,18,20)(3,12,14,21)(4,11,13,22)
  (5,7,16,23)(6,8,15,24), (1,7)(2,8)(3,9)(4,10)(5,11)(6,12)(13,15)(14,16)(17,18)(19,21)(20,22)
  (23,24) ]), isGraph := true, isSimple := true, 
  names := [ (), (3,4), (2,3), (2,3,4), (2,4,3), (2,4), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4), 
      (1,2,4,3), (1,2,4), (1,3,2), (1,3,4,2), (1,3), (1,3,4), (1,3)(2,4), (1,3,2,4), (1,4,3,2), 
      (1,4,2), (1,4,3), (1,4), (1,4,2,3), (1,4)(2,3) ], order := 24, representatives := [ 1 ], 
  schreierVector := [ -1, 1, 1, 2, 2, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2 ] )
gap> 
```



---

Comment by jaanos created at 2015-11-30 12:46:06

Hi!

> well, how about having a proper `digraphs.CayleyGraph()` constructor?

I'm not sure what you're trying to achieve here. The method being added here is supposed to recognize Cayley graphs, no matter how they were constructed.

That said, I think we do need a backend for GRAPE-like graphs (i.e., using an automorphism group and orbit representatives).

Janoš


---

Comment by dimpase created at 2015-11-30 12:50:13

Replying to [comment:41 jaanos]:
> > well, how about having a proper `digraphs.CayleyGraph()` constructor?
> 
> I'm not sure what you're trying to achieve here. The method being added here is supposed to recognize Cayley graphs, no matter how they were constructed.

a part of interface issue is that we lack `(di)graphs.CayleyGraph()`; if it was there it would be most natural to return such a thing on success.

> 
> That said, I think we do need a backend for GRAPE-like graphs (i.e., using an automorphism group and orbit representatives).

I have been advocating this for years, but never had time to implement it.


---

Comment by jaanos created at 2015-11-30 13:01:37

> a part of interface issue is that we lack `(di)graphs.CayleyGraph()`; if it was there it would be most natural to return such a thing on success.

So you're saying that we should return an isomorphic graph that is marked as a Cayley graph as a certificate? Interesting, although this is probably something the user should do by themselves given the group.

Even if we don't have such a constructor, we can always relabel the vertices with group elements, and then set edge labels, just like the `cayley_graph` method on a group would do.

Janoš


---

Comment by ncohen created at 2015-11-30 13:04:13

Hmmmm.. True. Returning a graph whose vertices are group elements and whose edges are labelled with a group element looks cool. Plus one can even get the actual group from `anyvertex.parent()`...

Nathann


---

Comment by dimpase created at 2015-11-30 13:33:48

Replying to [comment:44 ncohen]:
> Hmmmm.. True. Returning a graph whose vertices are group elements and whose edges are labelled with a group element looks cool. Plus one can even get the actual group from `anyvertex.parent()`...

vertices and edge labels ought to be words in group generators (you always need at most log_2(n) generators, at least if my memory is correct that the elementary abelian 2-groups are the worst case for the number of generators; and multiplying permutations is fast). 
Actually, all you need to store is  ["Schreier vector"](https://en.wikipedia.org/wiki/Schreier_vector), and compute vertex and edge labels on the fly.

Certainly keeping edge labels for each edge is silly, as they are trivially computed from the edge labels for one fixed vertex.


---

Comment by ncohen created at 2015-11-30 13:40:22

Yo

> vertices and edge labels ought to be words in group generators

Why ? A group element does the job already.

> Actually, all you need to store is  ["Schreier vector"](https://en.wikipedia.org/wiki/Schreier_vector), and compute vertex and edge labels on the fly.

That sounds like "something you might want to have", not "something that you can request the ticket's author to implement for you, as a reviewer"

> Certainly keeping edge labels for each edge is silly, as they are trivially computed from the edge labels for one fixed vertex.

Sure, but this way if you type `g.edge_labels()` you obtain the list of generators. It is only a proposition: I don't use cayley graph much, and though I can review some of the code the design is best chosen by those who might need the feature. You two, in the current situation.

Nathann


---

Comment by git created at 2015-11-30 13:55:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2015-11-30 14:00:13

Replying to [comment:46 ncohen]:
> Yo
> 
> > vertices and edge labels ought to be words in group generators
> 
> Why ? A group element does the job already.
cause you need `n^2` as opposed to `n log(n)` storage, making graphs that are easily handled by GRAPE out of reach.

> 
> > Actually, all you need to store is  ["Schreier vector"](https://en.wikipedia.org/wiki/Schreier_vector), and compute vertex and edge labels on the fly.
> 
> That sounds like "something you might want to have", not "something that you can request the ticket's author to implement for you, as a reviewer"

Certainly. It seems to be better to write it here than per email. I certainly not insist on it being implemented here on this ticket.

> 
> > Certainly keeping edge labels for each edge is silly, as they are trivially computed from the edge labels for one fixed vertex.
> 
> Sure, but this way if you type `g.edge_labels()` you obtain the list of generators. It is only a proposition: I don't use cayley graph much, and though I can review some of the code the design is best chosen by those who might need the feature. You two, in the current situation.
----
New commits:


---

Comment by dimpase created at 2015-11-30 14:05:48

Replying to [comment:34 dimpase]:
> Replying to [comment:33 jaanos]:
> > Hi!
> > 
> > > as a switch to `libgap` will happen sooner or later, optimising for not reading GAP output
> > > does not seem to be that important.
> > 
> > I see. But should I do anything about it at this point?
> > 
> > > this ceritainly looks better, but again, I don't like the counter-intuitive parameters of `is_cayley()` and weird sort of output (a pair) that you currently have. In particular the latter.
> > 
> > I have modelled both input and output of `is_cayley` after methods such as `is_chordal` and `is_circulant`. 

interestingly,  `is_circulant` implements a naive brute-force algorithm, and docs don't mention that there is a [polynomial-time algorithm](http://www.ams.org/journals/spmj/2004-15-06/S1061-0022-04-00833-7/S1061-0022-04-00833-7.pdf). (Which is also not mentioned on the wikipedia page it refers to. Perhaps I should edit the latter...)

PS. just edited the wikipedia page...


---

Comment by jaanos created at 2015-11-30 14:17:20

OK, I have just renamed the group method now, and haven't done any of the other things yet.

About a Cayley graph as a certificate: when we have an appropriate backend, sure, we should use that (or even a subclass dedicated to Cayley graphs which can compute the vertex name and edge labels on the fly). But until then we should decide what exactly to return as certificate, and that should remain so in the future.

If we want to return a Cayley graph, we could either always return a digraph (which can be nicely labelled, but won't be isomorphic to an undirected graph), or simply relabel the input graph (in case of undirected graphs we should then not use mutually inverse labels). I prefer the second option.

Janoš


---

Comment by git created at 2016-01-10 02:44:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jaanos created at 2016-01-10 02:45:54

I have finally gotten around to continuing work on this ticket. So, now we've got this:

* I have added a method `cayley_graph_group`, as suggested, which takes care of obtaining the group (or actually computing it in the case of disconnected graphs). It can be instructed not to actually return the group, but only to tell whether the graph is Cayley or not.

* `is_cayley` calls the above method, requesting the group if a certificate is requested. The certificate is now a copy of the graph with edges labelled by members of the generating set, and vertices associated to group elements (vertex names are not changed). One may then test that the result is indeed a Cayley graph - an example is in the doctest. Of course, once we will have a separate class/backend for Cayley graphs, we can use that here.

* Since `set_edge_label` does not work for multiedges, I have added three new parameters to `copy`. One is `data`, specifying the actual graph data to be copied (so this can be anything `Graph` and `DiGraph` accept - in this case, a list of vertices and a list of labelled edges). The other two are `loops` and `multiedges` (I don't actually use them in the final version, but I figured it might be still useful to keep them). Any of the properties of the graph not specified as a parameter are obtained from the graph itself, not from whatever `data` is.

So, what do you guys think?

Janoš
----
New commits:


---

Comment by ncohen created at 2016-01-10 08:03:00

Please remove this ugly 'data' argument in 'copy'. It will not happen.

Nathann


---

Comment by ncohen created at 2016-01-10 08:10:27

Sorry, I was rather angry. Longer answer:

> * I have added a method `cayley_graph_group`, as suggested, which takes care of obtaining the group (or actually computing it in the case of disconnected graphs). It can be instructed not to actually return the group, but only to tell whether the graph is Cayley or not.
> 
> * `is_cayley` calls the above method, requesting the group if a certificate is requested. The certificate is now a copy of the graph with edges labelled by members of the generating set, and vertices associated to group elements (vertex names are not changed). One may then test that the result is indeed a Cayley graph - an example is in the doctest. Of course, once we will have a separate class/backend for Cayley graphs, we can use that here.

I am still against the presence of both 'is_cayley' and 'cayley_graph_group', especially if you say that the first does the job of the second already. Let us not have 300 ways to do the same thing.

In particular, I often saw often users do things like:


```
if self.is_cayley():
    G = self.cayley_graph_group()
```


Which means that they compute things twice, whenever they have both a `is_*` function and another one which returns the data they are actually after.

I'm beginning to think that a `is_cayley_graph` that would return the group if possible and False otherwise would do the job, though that's only me.

> * Since `set_edge_label` does not work for multiedges, I have added three new parameters to `copy`. One is `data`, specifying the actual graph data to be copied (so this can be anything `Graph` and `DiGraph` accept - in this case, a list of vertices and a list of labelled edges). The other two are `loops` and `multiedges` (I don't actually use them in the final version, but I figured it might be still useful to keep them). Any of the properties of the graph not specified as a parameter are obtained from the graph itself, not from whatever `data` is.

Keywords like 'data' caused me endless troubles in this library. It is far too unspecific, and I do not even think that you need it. From what you said it seems that you only need to perform a copy then call `to_simple`. Tell me if it isn't what you want.

Nathann


---

Comment by jaanos created at 2016-01-10 21:33:46

Hi!

Replying to [comment:54 ncohen]:
> Sorry, I was rather angry. Longer answer:

Sorry about that, I thought you wouldn't like it. Anyway:

> I am still against the presence of both 'is_cayley' and 'cayley_graph_group', especially if you say that the first does the job of the second already. Let us not have 300 ways to do the same thing.
> 
> I'm beginning to think that a `is_cayley_graph` that would return the group if possible and False otherwise would do the job, though that's only me.

I actually agree - I was just trying to implement what Dima had suggested. But anyway, I think it would not be wrong to let the user also have the generating set and a labelled copy of the graph if requested.

> Keywords like 'data' caused me endless troubles in this library. It is far too unspecific, and I do not even think that you need it. From what you said it seems that you only need to perform a copy then call `to_simple`. Tell me if it isn't what you want.

I agree that having `data` as a parameter to `copy` is ugly and counter-intuitive. However, lacking a way to label the edges of a multigraph, I thought it would be easiest to just rebuild a graph with the labels, and `copy` already provides all copying-related stuff (an alternative would be to replicate its code).

`to_simple` would not work here, since I want to keep all loops and multiedges. What would be needed is a method like `set_edge_labels` which allows setting all labels simultaneously (including multiedges). For the purpose of this function, it would also suffice to have a parameter to `set_edge_label` that makes it set the same label to all parallel multiedges.

Janoš


---

Comment by jaanos created at 2016-01-10 21:33:46

Changing status from needs_review to needs_work.


---

Comment by ncohen created at 2016-01-10 21:48:34

Yo !!

> I actually agree - I was just trying to implement what Dima had suggested. But anyway, I think it would not be wrong to let the user also have the generating set and a labelled copy of the graph if requested.

I quite like to abuse of Python's features in this respect (though I know Dima hates it), and have the same function return as much stuff as needed: `G.is_cayley_graph(group=True,labelled_graph=True)`.

> I agree that having `data` as a parameter to `copy` is ugly and counter-intuitive. However, lacking a way to label the edges of a multigraph, I thought it would be easiest to just rebuild a graph with the labels, and `copy` already provides all copying-related stuff (an alternative would be to replicate its code).

Is there any reason why you don't create an empty digraph and add the necessary edges? I first thought that you were trying to avoid distinguishing graph and digraph, but then I wondered what the label would be on an *unlabeled* edge. `u/v` or `v/u`? Seems better to always use a digraph, doesn't it?

Nathann


---

Comment by jaanos created at 2016-01-10 22:36:19

Hi!

> Is there any reason why you don't create an empty digraph and add the necessary edges? I first thought that you were trying to avoid distinguishing graph and digraph, but then I wondered what the label would be on an *unlabeled* edge. `u/v` or `v/u`? Seems better to always use a digraph, doesn't it?

I guess this would be doable, but then other properties would also have to be set, which means duplicating the `copy` code. So essentially this is what the current code is doing. But then again maybe we should be happy with just copying what we really need.

As for graphs vs. digraphs, I prefer returning a graph which is actually isomorphic to the original one. Of course, the resulting digraph could always be converted to an undirected graph, but if the original graph has multiedges, this conversion would double the edges.

For the labels on undirected edges, what I currently do is pick one label and use it whenever its inverse could be used. Since vertices are associated with group elements (via `set_vertices`), this does not appear to be a problem.

Janoš


---

Comment by ncohen created at 2016-01-10 22:50:38

Hello,

> I guess this would be doable, but then other properties would also have to be set, which means duplicating the `copy` code.

Don't feel forced to preserve them if you see no reason to. Most of Sage's graph methods do not do it, so it is far from being a standard. If you want to do it, however, you are quite free to do so.

> As for graphs vs. digraphs, I prefer returning a graph which is actually isomorphic to the original one. Of course, the resulting digraph could always be converted to an undirected graph, but if the original graph has multiedges, this conversion would double the edges.
> 
> For the labels on undirected edges, what I currently do is pick one label and use it whenever its inverse could be used.

Sorry, I do not understand this sentence.

> Since vertices are associated with group elements (via `set_vertices`), this does not appear to be a problem.

Nooooooo... `set_vertices`? You use it to store the bijection between vertices and group elements? Can't you return a dictionary instead ?

I hate those "gadget properties". They seem nice when you add them, and then you see yourself spending your nights answering idiotic questions like "what on earth should I do with set_vertices inside of merge_vertices" or something like that `>_<`

Nathann


---

Comment by jaanos created at 2016-01-10 23:07:45

Hi!

> > For the labels on undirected edges, what I currently do is pick one label and use it whenever its inverse could be used.
> 
> Sorry, I do not understand this sentence.

I meant that all undirected edges `(u, v)` such that `u*g == v` or `u*g^-1 == v`, the same label `g` is used (of course, `g^-1` would be just as good).

> Nooooooo... `set_vertices`? You use it to store the bijection between vertices and group elements? Can't you return a dictionary instead ?
> 
> I hate those "gadget properties". They seem nice when you add them, and then you see yourself spending your nights answering idiotic questions like "what on earth should I do with set_vertices inside of merge_vertices" or something like that `>_<`

Haha, it seems I hit something that shouldn't be:)

Maybe we should revert to the last commit, and just add an option to let the user have exactly what they want (group/mapping/generating set). As for the graph, I guess the best thing would be to let the user construct it themselves the way that they want.

Janoš


---

Comment by git created at 2016-01-13 09:01:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jaanos created at 2016-01-13 09:08:42

OK, I've reverted the last commit, and instead added the parameters `return_group`, `mapping` and `generators` instead of `certificate`. I hope it's better this way:)

By the way, should the parameters all be named `return_*`? `return_group` seems to be established, while, for example, `automorphism_group` has a parameter `orbits` to specify that orbits should be returned.

Janoš


---

Comment by ncohen created at 2016-01-14 09:20:37

Hellooooooooooo,

Thank you very much for this update. Here are some comments:

- Some people sometimes fight about whether 'self' should be allowed in the docstrings, .e.g:
  `Check whether self is a Cayley graph.`
  I don't insist on any such rule, but I usually write it on the pattern 'Check
  whether the graph is a Cayley graph'. As you rightfully added your method to
  the index, you can see that only the *name* of the function appears before
  `Check whether self is a Cayley graph.`. In this context, the meaning of
  'self' is not clear. This being said, you will probably see it occur in some
  other places of Sage's code: make the change or do not make it, according to
  your taste. I just thought worth mentionning.

- About the doctest `sage: S`. I am not sure that the output will be
  identital on all platforms: the order of the generators can change on a
  different architecture, and this would be reported as a broken doctest. If you
  have reasons to believe that it will work on all platform then it can stay,
  otherwise the test must be made platform-independent. This can be done by
  building the graph from the generators for instance. If you do not believe
  that it is worth checking (e.g. if it is already tested elsewhere) then you
  can just remove this line, or test something different.

- `regular_subgroup` given that the default behaviour is to return a boolean,
  shouldn't it be named `has_regular_subgroup` instead?

- about `is_cayley` returning generators: do you think that it is necessary to
  have this option, or should we let users call `.generators()` on the group
  object?

- `c, G, d, S` could you give more meaningful names to those variables? I
  guess that 'G' is alright (even though, in a Graph function...) but `d` and
  `S` could easily be `graph_to_group_map` and `generators`. Or anything else
  you might prefer.

- You do not need `\` at the end of the line when a `[({` is open and remains to
  be closed.

- Can this
  {{{
  +                t = C[0].is_cayley(return_group=certificate)
  +                if certificate:
  +                    c, CG = t
  }}}
  be replaced by that?
  {{{
  +                c, CG = C[0].is_cayley(return_group=certificate)
  +                if certificate:
  }}}
  The value `None` may be replaced by `None` uselessly, but that's not a big
  problem (if I don't get anything wrong)

- About `return tuple(out)` -- there is nothing wrong with this, though I
  don't think it is necessary to force a 'tuple'. This is no request to change
  it of course, it is fine as it is if you prefer it this way.

- It is better to call `self.degree()` than `len(self.domain())`.

Nathann

P.S.: Don't forget to set a ticket back to `needs_review` once you are done with the changes.


---

Comment by jaanos created at 2016-01-14 12:15:08

Hi!

Some quick replies:

> - About the doctest `sage: S`. I am not sure that the output will be
>   identital on all platforms: the order of the generators can change on a
>   different architecture, and this would be reported as a broken doctest. If you
>   have reasons to believe that it will work on all platform then it can stay,
>   otherwise the test must be made platform-independent. This can be done by
>   building the graph from the generators for instance. If you do not believe
>   that it is worth checking (e.g. if it is already tested elsewhere) then you
>   can just remove this line, or test something different.

Yes, I was a bit worried about that. Anyway, this was intended more as a demonstration that the method works on non-simple graphs, so maybe it should be moved to the Examples section. Instead of printing out the generating set, maybe we should just print its length and the number of distinct elements, and maybe check that it contains the identity element.

> - about `is_cayley` returning generators: do you think that it is necessary to
>   have this option, or should we let users call `.generators()` on the group
>   object?

Yes, because the generating set of a Cayley graph is not the same as the set of generators of a group. A trivial example would be a complete graph - its generating set as a Cayley graph is the whole group, which can of course be generated by some subset of its elements. For a disconnected Cayley graph, on the other hand, the generating set will not even generate the whole group.

This reminds me that I should probably add a further optimization: if a (simple) graph is connected and dense (say, vertex degree more than half the order), then it may be more efficient to check for Cayleyness of its complement (in case it is disconnected it will be more efficient, otherwise the same).

> - Can this
>   {{{
>   +                t = C[0].is_cayley(return_group=certificate)
>   +                if certificate:
>   +                    c, CG = t
>   }}}
>   be replaced by that?
>   {{{
>   +                c, CG = C[0].is_cayley(return_group=certificate)
>   +                if certificate:
>   }}}
>   The value `None` may be replaced by `None` uselessly, but that's not a big
>   problem (if I don't get anything wrong)

No, because we are not guaranteed that a tuple will be returned.

> - About `return tuple(out)` -- there is nothing wrong with this, though I
>   don't think it is necessary to force a 'tuple'. This is no request to change
>   it of course, it is fine as it is if you prefer it this way.

True, but other methods returning multiple data also return tuples, so I think it should stay (IMO lists should be used when the size of the output is not predetermined, and its members have the same type).

I agree with the comments that I haven't replied to. I'm a bit busy these days, so (anyone) feel free to implement these suggestions if you feel like it.

Janoš


---

Comment by ncohen created at 2016-01-14 12:55:14

> Yes, I was a bit worried about that. Anyway, this was intended more as a demonstration that the method works on non-simple graphs, so maybe it should be moved to the Examples section. Instead of printing out the generating set, maybe we should just print its length and the number of distinct elements, and maybe check that it contains the identity element.

If you meant it as a 'pedagogical' doctest, then there is an easy way out: just add a '# random' flag to the doctest.

file:///home/ncohen/.Sage/src/doc/output/html/en/developer/coding_basics.html#special-markup-to-influence-tests

> Yes, because the generating set of a Cayley graph is not the same as the set of generators of a group.

Arg... Sorry. Not only I am an idiot, but I already asked the same question and you gave me the very same answer `>_<`

> This reminds me that I should probably add a further optimization: if a (simple) graph is connected and dense (say, vertex degree more than half the order), then it may be more efficient to check for Cayleyness of its complement (in case it is disconnected it will be more efficient, otherwise the same).

The .density() and .complement() method raise exceptions on non-simple graphs. I think that it is better to not care about this, unless you really need those cases and the speedup is obvious.

> No, because we are not guaranteed that a tuple will be returned.

Weird. I thought you said in the doctest that a tuple will always be returned, whether the graph is a cayley graph or not, and that the additional values would be set to `None` if necessary.

> True, but other methods returning multiple data also return tuples, so I think it should stay (IMO lists should be used when the size of the output is not predetermined, and its members have the same type).

`O_o`

Okay. Well. Tastes `:-P`

Nathann


---

Comment by jaanos created at 2016-01-14 13:19:27

Hi!

> > This reminds me that I should probably add a further optimization: if a (simple) graph is connected and dense (say, vertex degree more than half the order), then it may be more efficient to check for Cayleyness of its complement (in case it is disconnected it will be more efficient, otherwise the same).
> 
> The .density() and .complement() method raise exceptions on non-simple graphs. I think that it is better to not care about this, unless you really need those cases and the speedup is obvious.

That's why I said simple (and I hadn't thought out the implications of non-simple graphs). But yes, the denser the graph, the greater the probability that such a speedup will be achieved, and the greater potential of speedup in this case. In the case of multiple edges, this potential is smaller (the current method will be faster in general due to the potentially smaller automorphism group), and I agree that we should not even care about the cases when speedup is actually possible (e.g. when all multiedges appear with the same multiplicity).

> > No, because we are not guaranteed that a tuple will be returned.
> 
> Weird. I thought you said in the doctest that a tuple will always be returned, whether the graph is a cayley graph or not, and that the additional values would be set to `None` if necessary.

A tuple will be returned whenever some form of certificate is requested, regardless of whether the graph is Cayley or not. What is being differentiated here is whether the group has been requested in the first place. Although if you prefer, a call to `is_cayley` could be made in each branch of the `if` statement.

Janoš


---

Comment by ncohen created at 2016-01-14 13:22:41

Yooooooo,

> A tuple will be returned whenever some form of certificate is requested, regardless of whether the graph is Cayley or not. What is being differentiated here is whether the group has been requested in the first place. 

Right right, sorry.

> Although if you prefer, a call to `is_cayley` could be made in each branch of the `if` statement.

The simpler the better, that's all I am looking for.

Nathann


---

Comment by git created at 2016-01-23 15:10:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jaanos created at 2016-01-23 15:25:23

Hi!

I have implemented your suggestions. Some comments:

> - About the doctest `sage: S`. I am not sure that the output will be
>   identital on all platforms: the order of the generators can change on a
>   different architecture, and this would be reported as a broken doctest. If you
>   have reasons to believe that it will work on all platform then it can stay,
>   otherwise the test must be made platform-independent. This can be done by
>   building the graph from the generators for instance. If you do not believe
>   that it is worth checking (e.g. if it is already tested elsewhere) then you
>   can just remove this line, or test something different.

I've moved it to the Examples section and added a `# random` flag. I've also added this flag to the doctests in `permgroup.py` where the generators of a group are output.

> - `regular_subgroup` given that the default behaviour is to return a boolean,
>   shouldn't it be named `has_regular_subgroup` instead?

Actually, the default behaviour was to return a group, but I changed it now. It seems more appropriate this way, since the method will return _a_ regular subgroup, not _the_ regular subgroup (if there is one in the first place). Now, the returned group (if requested) can be thought of as a certificate. Anyway, `is_cayley` now explicitly specifies the `return_group` parameter of `has_regular_subgroup` in both cases.

> - `c, G, d, S` could you give more meaningful names to those variables? I
>   guess that 'G' is alright (even though, in a Graph function...) but `d` and
>   `S` could easily be `graph_to_group_map` and `generators`. Or anything else
>   you might prefer.

OK, I have now changed `map`, `d` and `S` to `compute_map`, `map` and `genset`, respectively.

> - You do not need `\` at the end of the line when a `[({` is open and remains to
>   be closed.

True, but the `\` in line 20891 of `generic_graph.py` is actually outside any parentheses.

Janoš


---

Comment by jaanos created at 2016-01-23 15:25:23

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2016-01-23 16:09:04

Hellooooooo,

> True, but the `\` in line 20891 of `generic_graph.py` is actually outside any parentheses.

Sigh... Right. You write extremely clean code, y'know?

I re-read everything and added a couple of 'default values' for the arguments in the INPUT section, in a commit at public/19586. You can change the branch's name on this ticket if you agree with it.

Dima? Could you please review the code of `_regular_subgroup_gap`? I reviewed everything else but I'm not knowledgeable for that.

If this part is good for you, then this ticket can be changed to `positive_review`.

THaaaaaaaaaaaaanks,

Nathann


---

Comment by git created at 2016-01-23 19:07:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jaanos created at 2016-01-23 19:10:50

Hi!

> > True, but the `\` in line 20891 of `generic_graph.py` is actually outside any parentheses.
> 
> Sigh... Right. You write extremely clean code, y'know?

Thanks :)

> I re-read everything and added a couple of 'default values' for the arguments in the INPUT section, in a commit at public/19586. You can change the branch's name on this ticket if you agree with it.

Thank you - I've also added the optimization for dense simple graphs that I was talking about.

Janoš


---

Comment by dimpase created at 2016-01-23 19:40:45

I probably don't understand something, but why is the existence of a regular subgroup sufficient for the graph to be Cayley? Indeed, one seem to need in addition that this subgroup is generated by the elements corresponding to the neighbours of a vertex.

E.g. I can construct a cubic, arc-transitive, digraph on 16 vertices, with a regular subgroup being elementary abelian, i.e. in particular having 4 generators. The underlying graph has degree 6, so it is OK as a Cayley graph, but not OK as a Cayley digraph, as 3 generators (the out-degree of the digraph)  are not enough!
----
New commits:


---

Comment by dimpase created at 2016-01-23 19:40:45

Changing status from needs_review to needs_info.


---

Comment by ncohen created at 2016-01-23 20:14:22

Hmmmmmmm `:-/`


---

Comment by ncohen created at 2016-01-23 20:58:39

It's true that almost everybody seems to suppose that a cayley graph is connected.


---

Comment by ncohen created at 2016-01-23 21:06:34

Should this raise an exception, by the way? `:-/`


```
sage: groups.permutation.Dihedral(4).cayley_graph(generators=[(1,2,3,4)]).show()
```


Nathann


---

Comment by dimpase created at 2016-01-23 21:08:07

Replying to [comment:74 ncohen]:
> It's true that almost everybody seems to suppose that a cayley graph is connected. 

I think I can construct a connected cubic arc-transitive digraph on 2<sup>10</sup> vertices, and thus a connected vertex-transitive graph of degree 6, that has a regular subgroup of automorphisms that is elementary abelian, i.e. needs 10 generators to be generated.  Thus this graph won't be a Cayley for this subgroup. But this code would happily say that the graph is Cayley...


---

Comment by ncohen created at 2016-01-23 21:32:26

I don't get it: if what you say were true, it would mean that the action of that regular subgroup upon the edges incident to a fixed vertex would yield a disconnected 6-regular graph.

On the other hand, this 6-regular disconnected graph is a subgraph of the connected 6-regular graph you started from, so ... no?

Nathann


---

Comment by jaanos created at 2016-01-23 21:40:45

Hi!

Let's see... if the automorphism group has a regular subgroup `G`, then we can pick any vertex `w` and construct a bijective mapping that maps a group element `g` to the vertex `g^w`. Now, suppose we have an arc `uv` such that group elements `g` and `h` map to `u` and `v`, respectively. Then we may label the arc by `e = g^-1 h`, and any automorphism `a` from `G` will map `uv = g^w h^w` to `(ag)^w (ah)^w`, i.e. an arc with the same label. Since such a graph is necessarily vertex-transitive, it follows that the (multi)set of labels on arcs starting in a vertex is independent of the choice of said vertex. The Cayley graph of `G` with said (multi)set as its generating set is then isomorphic to our graph.

Do you find any flaw in the above argument? Also, can you provide the graphs which you claim to be counterexamples?

Janoš


---

Comment by dimpase created at 2016-01-23 21:44:04

Replying to [comment:77 ncohen]:
> I don't get it: if what you say were true, it would mean that the action of that regular subgroup upon the edges incident to a fixed vertex would yield a disconnected 6-regular graph.

no, it would not, it would give the whole graph. But the subgroup will not be generated by the 
neighbours of the identity in the graph. Indeed, the minimal degree of a [Cayley graph](https://en.wikipedia.org/wiki/Cayley_graph) of this group is 10 (as one needs at least 10 generators). Thus this graph is not a Cayley graph of this group.


---

Comment by ncohen created at 2016-01-23 21:47:05

> no, it would not, it would give the whole graph.

Arg. We miss each other: I use a different observation: because you tell me that your group cannot be generated by <10 elements, then surely when your compute the orbit of those edges there cannot be a *path* from every vertex to every other. Because otherwise, well, your 6 vertices would be sufficient to generate the subgroup.

So it is both disconnected (by this observation) and connected (by yours) and so it is impossible?...

Nathann


---

Comment by ncohen created at 2016-01-23 21:51:42

> Do you find any flaw in the above argument? Also, can you provide the graphs which you claim to be counterexamples?

I agree with you everywhere short of one thing: if the graph you started with is not connected, then the set you are talking about is not a *generating* set, e.g. : take the disjoint union of two cliques of size n, and as a regular subgroup take two disjoint cycles of order n plus a reflections that exchanges both.

Nathann


---

Comment by jaanos created at 2016-01-23 22:08:51

Replying to [comment:81 ncohen]:
> > Do you find any flaw in the above argument? Also, can you provide the graphs which you claim to be counterexamples?
> 
> I agree with you everywhere short of one thing: if the graph you started with is not connected, then the set you are talking about is not a *generating* set, e.g. : take the disjoint union of two cliques of size n, and as a regular subgroup take two disjoint cycles of order n plus a reflections that exchanges both.

In this case the set does not generate the group, but it still is a generating set in the sense that it generates the graph. In any case, disconnected graphs are given a special treatment, checking Cayleyness only for a connected component.

Now, whether we allow Cayley graphs to be disconnected is just a matter of definition. I know that usually they are assumed to be connected, but in my opinion we should allow disconnected graphs to be called Cayley (it even allows this method to make optimizations by looking at complements). So the example you gave above is fine without raising an exception IMO.

Janoš


---

Comment by dimpase created at 2016-01-23 22:46:19

Replying to [comment:78 jaanos]:

> Let's see... if the automorphism group has a regular subgroup `G`, then we can pick any vertex `w` and construct a bijective mapping that maps a group element `g` to the vertex `g^w`. Now, suppose we have an arc `uv` such that group elements `g` and `h` map to `u` and `v`, respectively. Then we may label the arc by `e = g^-1 h`, and any automorphism `a` from `G` will map `uv = g^w h^w` to `(ag)^w (ah)^w`, i.e. an arc with the same label. Since such a graph is necessarily vertex-transitive, it follows that the (multi)set of labels on arcs starting in a vertex is independent of the choice of said vertex. The Cayley graph of `G` with said (multi)set as its generating set is then isomorphic to our graph.

> Do you find any flaw in the above argument?

it is certainly true that you can assume w=1. So you have the neighbours of 1 in the graph (with its vertices labelled by the elements of G) say g<sub>1</sub>,...,g<sub>k</sub>. Now you need an argument that g<sub>1</sub>,...,g<sub>k</sub> generate G. I don't see it in what you wrote above.
 
> Also, can you provide the graphs which you claim to be counterexamples?
I'll try. (Or show me that they don't exist...)


---

Comment by jaanos created at 2016-01-23 23:12:40

Replying to [comment:83 dimpase]:
> it is certainly true that you can assume w=1. So you have the neighbours of 1 in the graph (with its vertices labelled by the elements of G) say g<sub>1</sub>,...,g<sub>k</sub>. Now you need an argument that g<sub>1</sub>,...,g<sub>k</sub> generate G. I don't see it in what you wrote above.

If the graph is connected, they clearly do (if the graph is directed, vertex-transitivity then implies that it is also strongly connected). But they don't need to generate the group in the general case - it suffices that we get an isomorphic graph from the Cayley construction.

Janoš


---

Comment by dimpase created at 2016-01-23 23:29:52

Changing status from needs_info to positive_review.


---

Comment by dimpase created at 2016-01-23 23:29:52

Replying to [comment:84 jaanos]:
> Replying to [comment:83 dimpase]:
> > it is certainly true that you can assume w=1. So you have the neighbours of 1 in the graph (with its vertices labelled by the elements of G) say g<sub>1</sub>,...,g<sub>k</sub>. Now you need an argument that g<sub>1</sub>,...,g<sub>k</sub> generate G. I don't see it in what you wrote above.
> 
> If the graph is connected, they clearly do (if the graph is directed, vertex-transitivity then implies that it is also strongly connected).  

Ah, right. Sorry, I'm not very bright tonight. It's all good.


---

Comment by ncohen created at 2016-01-24 08:37:22

Changing status from positive_review to needs_work.


---

Comment by ncohen created at 2016-01-24 08:37:22

> Now, whether we allow Cayley graphs to be disconnected is just a matter of definition.

Hmmm... I'm sorry to switch this ticket back but I do not think that we should allow that. From what I know (which is very few) I also believe that your definition is better, but when there is a widespread definition of something then Sage *must* follow it. Corner-cases are okay when the definitions does not tell, but.. Well, what if people start counting those graphs, or filter only cayley graphs, and stuff?

I believe we should stick to the seemingly widespread definition and only allow connected ones.

It is particularly unpleasant because of the line from [comment:75]. Right now the `.cayley_graph` command outputs disconnected graphs, thus somebody will complain eventually that it does not always return cayley graphs `>_<`

Nathann


---

Comment by jaanos created at 2016-01-24 11:24:18

Hi!

Replying to [comment:86 ncohen]:
> I believe we should stick to the seemingly widespread definition and only allow connected ones.

I see... but an easy solution to this would be to add an `allow_disconnected` parameter. Then the recursive call on the complement would set this to `True` - the original setting only matters for the initial graph, anyway.

What about non-simple graphs? I don't think the definitions say much about those, so we're probably good? Although the Wikipedia article linked above does say that a Cayley graph does not contain loops...

Janoš


---

Comment by vbraun created at 2016-01-24 12:52:47

Resolution: fixed


---

Comment by vbraun created at 2016-01-24 12:55:05

Changing status from closed to new.


---

Comment by vbraun created at 2016-01-24 12:55:05

Resolution changed from fixed to 


---

Comment by jaanos created at 2016-01-24 14:41:01

Hi all!

I've added an `allow_disconnected` parameter. I hope it's OK this way.

By the way, is there any reason why the milestone has been changed to sage-7.2 when 7.1 has not been released yet?

Janoš
----
Last 10 new commits:


---

Comment by jaanos created at 2016-01-24 14:49:57

Changing status from new to needs_review.


---

Comment by ncohen created at 2016-01-24 16:26:27

> I've added an `allow_disconnected` parameter. I hope it's OK this way.

It's perfect this way! Thanks!

> By the way, is there any reason why the milestone has been changed to sage-7.2 when 7.1 has not been released yet?

I don't think so. I set it back to what it was.

About loops, I wonder however. Is it still correct to look for a *regular* subgroup if there are loops?

Nathann


---

Comment by ncohen created at 2016-01-24 16:28:42

P.S.: I used this code and the OEIS to count how many vertex-transitive graphs are not cayley graphs. The first counter-examples have cardinality 10, and there are exactly 2. Which is what this code found.


---

Comment by jaanos created at 2016-01-24 16:36:35

Hi!

> About loops, I wonder however. Is it still correct to look for a *regular* subgroup if there are loops?

Why not? If there are any loops, there must be a loop on every vertex (otherwise the graph is not vertex-transitive and there is no regular subgroup). But then loops don't matter any more.

Janoš


---

Comment by ncohen created at 2016-01-24 16:41:43

Would it be incorrect to imagine a graph in which the loops is not always due to the same generator? If the group is not regular.

Nathann


---

Comment by jaanos created at 2016-01-24 16:46:17

As vertices correspond to group elements, loops can only correspond to identity.

Janoš


---

Comment by ncohen created at 2016-01-24 16:49:46

Sigh... Reading this group theory group will do me good.

Thank you very much for this branch, no other question, good to go `:-P`

Nathann


---

Comment by ncohen created at 2016-01-24 16:49:46

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-01-24 17:08:41

I set the milestone since you apparently need more time


---

Comment by ncohen created at 2016-01-24 17:11:28

I'm sorry Volker... There was something I noticed just after changing the status....

Nathann


---

Comment by vbraun created at 2016-01-28 17:14:28

Resolution: fixed


---

Comment by jaanos created at 2016-01-28 18:13:03

Thanks everybody!

Janoš


---

Comment by ncohen created at 2016-01-28 18:13:39

Ahahah. You did all the work, man!


---

Comment by tmonteil created at 2016-01-29 17:27:42

Very nice feature ! If `gap_packages` and `database_gap` are required (in the doc), how do the doctest pass without any `# optional` flag ?


---

Comment by ncohen created at 2016-01-29 18:25:35

Probably because of the 'all' that appears in this piece of doc.


---

Comment by jaanos created at 2016-01-30 03:01:44

Indeed, GAP's `ConjugacyClassesSubgroups` works for some small groups (which include all groups in question in the doc) without any additional packages. However, `TomLib` and `AtlasRep` are required for a complete coverage.

Janoš


---

Comment by tmonteil created at 2016-01-30 10:01:38

Replying to [comment:107 jaanos]:
> Indeed, GAP's `ConjugacyClassesSubgroups` works for some small groups (which include all groups in question in the doc) without any additional packages. However, `TomLib` and `AtlasRep` are required for a complete coverage.

I see. So, perhaps could some of the extra cases be tested as well since they use another (less tested) route.


---

Comment by ncohen created at 2016-01-30 10:03:24

> I see. So, perhaps could some of the extra cases be tested as well since they use another (less tested) route.

That would be testing GAP more than testing Sage. But well, no reason to stop you from doing so either I guess.
