# Issue 21886: Update Three.js template

Issue created by migration from Trac.

Original creator: paulmasson

Original creation time: 2017-01-03 01:52:25

CC:  novoselt




---

Comment by paulmasson created at 2017-01-03 01:53:21

Changing type from PLEASE CHANGE to defect.


---

Comment by paulmasson created at 2017-01-03 01:53:21

Changing component from PLEASE CHANGE to graphics.


---

Comment by paulmasson created at 2017-01-07 20:35:07

New commits:


---

Comment by paulmasson created at 2017-01-07 20:35:07

Changing status from new to needs_review.


---

Comment by paulmasson created at 2017-01-07 22:35:16

Changing status from needs_review to needs_work.


---

Comment by novoselt created at 2017-01-08 18:27:05

So - what else needs work for these issues?

Regarding embedding this template as iframe - perhaps it would be better to have a visible border of the plot, given that it changes mouse behaviour? Nothing drastic, thin gray line would suffice.


---

Comment by paulmasson created at 2017-01-08 21:32:50

Replying to [comment:5 novoselt]:
> So - what else needs work for these issues?
Nothing for the issues already identified, but there is an outstanding transparency issue that I just figured out how to fix yesterday. I changed the status of the ticket so that no one would need to review it twice. The solution to this third issue is a bit involved and I want to clean up the code before pushing it here.
> Regarding embedding this template as iframe - perhaps it would be better to have a visible border of the plot, given that it changes mouse behaviour? Nothing drastic, thin gray line would suffice.
The embedding is controlled [server side](https://github.com/sagemath/sagecell/blob/develop/backend_cell.py#L133) so you can make that change any time. This ticket will only touch JavaScript.


---

Comment by git created at 2017-01-10 01:14:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by paulmasson created at 2017-01-10 01:20:24

Changing status from needs_work to needs_review.


---

Comment by paulmasson created at 2017-01-10 01:45:59

For future reference, the rendering of transparent objects in Three.js is controlled by the position of the mesh. Two objects with the exact same center will render in the order in which they are added to the scene, so that one will always occlude the other. This will be a problem with intersecting planes and Jmol will always be more adept at handling this. One workaround will be to split planes into two parts along the line of intersection and add them to the scene as separate objects.


---

Comment by novoselt created at 2017-01-10 06:17:38

How could one implement it in a sensible way? Compute intersections of all sub-pieces on adding plots?

Perhaps it would make more sense to subdivide all planes into smaller pieces, or at least have some option for this?


---

Comment by paulmasson created at 2017-01-11 01:09:07

My comment was meant as an advisory to the end user and I can add something like it to the documentation for this viewer if desired. I should have been clearer since there are really two issues:

1) Compact objects need to have different positions for transparency to render properly.

2) Intersecting extended objects will have transparency issues even with different positions. It will be most immediately noticeable for planes but will exist for other objects, such as cylinders. This is an issue with WebGL in general, not just Three.js.

By the time the objects get to Three.js they're just vertices and faces, so the splitting would have to happen in Python, at least in `implicit_plot3d` and `parametric_plot3d`. Again, this is only for transparent objects as seen from certain angles, so I think we should wait and see how much of a problem it is for end users before making any complicated changes.

In any case, that's beyond the scope of this ticket.


---

Comment by novoselt created at 2017-01-15 01:05:13

Changing status from needs_review to positive_review.


---

Comment by novoselt created at 2017-01-15 01:05:13

OK, it does improve the transparency situation! Can you please clarify multiplication by -1?

Continuing overall discussion - do I understand correctly that say several nested cylinders with the same parameters except for radius will not be drawn correctly ever??? And WebGL has no interest in fixing this situation? If so, what can be a sensible automatic workaround? Break all complicated objects into something like 1000 little triangles so that they almost never will intersect and when they do, defects will be small? Or we just hope that such situations are rare? Even a simple cube looks strange with opacity - as you rotate it it is obvious that facets are different! And they aren't exactly intersecting each other, just touching.


---

Comment by paulmasson created at 2017-01-16 01:26:40

Replying to [comment:12 novoselt]:
> OK, it does improve the transparency situation! Can you please clarify multiplication by -1?
The method `center()` returns the vector used to center vertices in their own frame of reference, so moving the entire object needs to happen in the opposite direction.
> Continuing overall discussion - do I understand correctly that say several nested cylinders with the same parameters except for radius will not be drawn correctly ever???
No, but the process will be difficult to automate. The is an additional parameter named `renderOrder` that can be manually attached to objects to help in these sorts of situations. It would be easy enough to add the feature but would take some explaining for people to understand why it might help.
> And WebGL has no interest in fixing this situation?
Part of the reason to use Three.js is avoid having to learn too much about WebGL, but I guess now I'm committed to getting more details. I do know that the depth buffer that tracks object position does not respect transparency and that's the source of the problem. Here's an [example](http://sagecell.sagemath.org/?z=eJyNzrEKwyAUheG90HdwU9ubQiwZ77MUSW6IxaCoSdSnbxw6Frr9y-E7uw6CZ1ZY5fJ68T1DZlZvzWjSy1uXnpOoiKpTtwwiQ6dASRDlG7XFIMF5fS4KPgbYDR0UkKclEL0jhznolXDWNhLoTBFT2Khh6gf2NzU6604p0NTOx8Udwvd3r-QH0vM_uQ==&lang=sage) that I think encapsulates that: rotate the planes vertically and you see how the transparency of each half shifts based on which one's center is closest to the front of the scene.

I don't yet know more details of the implementation, but I assume a choice had to be made to get 3D rendering to work at all in the browser, where resources are more limited than with a Java desktop environment. That might change as browsers gain calculational power. 
> If so, what can be a sensible automatic workaround? Break all complicated objects into something like 1000 little triangles so that they almost never will intersect and when they do, defects will be small?
That is possible, but would probably crash the browser. I can try testing it for possible future use. We should also look at how Jmol passes objects to JavaScript, even though it doesn't use WebGL.
> Or we just hope that such situations are rare?
I think waiting for some feedback from users would be appropriate.  My interest till now has been with opaque objects and WebGL is great for that. Let's see how important opacity is in practice.
> Even a simple cube looks strange with opacity - as you rotate it it is obvious that facets are different! And they aren't exactly intersecting each other, just touching.
This is partly a result of the existing lighting. In order to get things started I just put lights above and below the frame, but we can change the default lighting. The current `threejs` implementation has lights from six directions IIRC: does it look better to you for a single cube?


---

Comment by vbraun created at 2017-01-21 16:34:40

Resolution: fixed


---

Comment by novoselt created at 2017-01-22 18:48:49

Replying to [comment:13 paulmasson]:
> Replying to [comment:12 novoselt]:
> > And WebGL has no interest in fixing this situation?
> Part of the reason to use Three.js is avoid having to learn too much about WebGL, but I guess now I'm committed to getting more details. I do know that the depth buffer that tracks object position does not respect transparency and that's the source of the problem. Here's an [example](http://sagecell.sagemath.org/?z=eJyNzrEKwyAUheG90HdwU9ubQiwZ77MUSW6IxaCoSdSnbxw6Frr9y-E7uw6CZ1ZY5fJ68T1DZlZvzWjSy1uXnpOoiKpTtwwiQ6dASRDlG7XFIMF5fS4KPgbYDR0UkKclEL0jhznolXDWNhLoTBFT2Khh6gf2NzU6604p0NTOx8Udwvd3r-QH0vM_uQ==&lang=sage) that I think encapsulates that: rotate the planes vertically and you see how the transparency of each half shifts based on which one's center is closest to the front of the scene.

Great example!
 
> > If so, what can be a sensible automatic workaround? Break all complicated objects into something like 1000 little triangles so that they almost never will intersect and when they do, defects will be small?
> That is possible, but would probably crash the browser. I can try testing it for possible future use. We should also look at how Jmol passes objects to JavaScript, even though it doesn't use WebGL.

Note that [Jmol actually has some WebGL implementation](http://wiki.jmol.org/index.php/Jmol_JavaScript_Object/WebGL) as well, maybe they have a workaround/solution - it is experimental and I never looked at it myself.
> > Even a simple cube looks strange with opacity - as you rotate it it is obvious that facets are different! And they aren't exactly intersecting each other, just touching.
> This is partly a result of the existing lighting. In order to get things started I just put lights above and below the frame, but we can change the default lighting. The current `threejs` implementation has lights from six directions IIRC: does it look better to you for a single cube?

That was a complaint about transparency. Lighting-wise I think it would be nice to have different lights from different directions, not the same flood from everywhere. Try to rotate [these spheres](http://sagecell.sagemath.org/?z=eJwrULBVKC7ISC1K1UgrSsxNtXVLzClO1eTlKskoSk3NKtYoALIL9Ioz8ss1yjJTy1OLbJWgUkqYMlm5-TkgYQDkZRw4&lang=sage). For the old one the only reason you can notice rotation is that it is not a sphere, it has some corners. Your variant clearly shows where are top and bottom, but not left-right. I find it confusing and even with less contrived examples the lighting is kind of "flat". Now I noticed that jmol's version also has visible rotation only due to defects of the surface, but it is the most pleasing one, IMHO. And a big difference seems to be that jmol rotates everything keeping (a single?) light fixed, while threejs rotates objects together with lights. Is it possible to have fixed lights in threejs? That's is ideal for our applications, I think - you kind of have an object under a desk lamp, and rotate it to see different sides.


---

Comment by paulmasson created at 2017-01-26 00:04:07

Moving lighting discussion to #22261
