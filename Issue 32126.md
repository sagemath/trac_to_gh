# Issue 32126: issues with SAGE_FAT_BINARY

archive/issues_032126.json:
```json
{
    "body": "CC:  @kliem jhpalmieri\n\nAs far as I can tell this configuration flag affects only the gmp and givaro packages.  There are two problems that I have run into with it.\n\n1. It is misnamed.  What Apple means by a \"fat binary\" is a single mach-O file containing multiple binaries for different CPU architectures.  That is not what this flag produces.  The name was probably derived from the gmp configure flag --enable-fat, which is used when SAGE_FAT_BINARY is yes.  That gmp flag causes gmp to include assembly language modules for all possible Intel variants, and to add code that selects which of those modules to use at run time.\n\n2. It does the wrong thing for givaro.  Currently in the givaro package it disables all intel extensions (the opposite of making it \"fat\") by setting the configure flags: -mno-sse, -mno-sse2, -mno-avx, -mno-avx2, and -mno-bmi2.  But sse and sse2 should not be disabled, at least not on macOS.  All of the relevent Intel chips used by Apple support those instruction sets.  (And conda does not disable them, by the way.)  Sage will not build on Apple systems with older Intel chips for other reasons.\n\nA better name might be ENABLE_INTEL_COMPATIBILITY.\n\nIssue created by migration from https://trac.sagemath.org/ticket/32363\n\n",
    "created_at": "2021-08-10T21:58:30Z",
    "labels": [
        "build: configure",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "issues with SAGE_FAT_BINARY",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/32126",
    "user": "culler"
}
```
CC:  @kliem jhpalmieri

As far as I can tell this configuration flag affects only the gmp and givaro packages.  There are two problems that I have run into with it.

1. It is misnamed.  What Apple means by a "fat binary" is a single mach-O file containing multiple binaries for different CPU architectures.  That is not what this flag produces.  The name was probably derived from the gmp configure flag --enable-fat, which is used when SAGE_FAT_BINARY is yes.  That gmp flag causes gmp to include assembly language modules for all possible Intel variants, and to add code that selects which of those modules to use at run time.

2. It does the wrong thing for givaro.  Currently in the givaro package it disables all intel extensions (the opposite of making it "fat") by setting the configure flags: -mno-sse, -mno-sse2, -mno-avx, -mno-avx2, and -mno-bmi2.  But sse and sse2 should not be disabled, at least not on macOS.  All of the relevent Intel chips used by Apple support those instruction sets.  (And conda does not disable them, by the way.)  Sage will not build on Apple systems with older Intel chips for other reasons.

A better name might be ENABLE_INTEL_COMPATIBILITY.

Issue created by migration from https://trac.sagemath.org/ticket/32363





---

archive/issue_comments_458739.json:
```json
{
    "body": "Yes, it's misnamed.",
    "created_at": "2021-08-10T22:25:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32126#issuecomment-458739",
    "user": "mkoeppe"
}
```

Yes, it's misnamed.



---

archive/issue_comments_458740.json:
```json
{
    "body": "As (I think) this is not specific to intel architectures, we could rename the configure option `--enable-fat-binary` (introduced in #30375) to something like `--enable-portable-binary`.\n\n`numpy` >= 1.20 has a more fine-grained flag for its use of processor intrinsics, something that we may want to emulate; see #32021",
    "created_at": "2021-08-10T22:32:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32126#issuecomment-458740",
    "user": "mkoeppe"
}
```

As (I think) this is not specific to intel architectures, we could rename the configure option `--enable-fat-binary` (introduced in #30375) to something like `--enable-portable-binary`.

`numpy` >= 1.20 has a more fine-grained flag for its use of processor intrinsics, something that we may want to emulate; see #32021



---

archive/issue_comments_458741.json:
```json
{
    "body": "Possibly the sense should also be inverted, meaning that maximum portability would be the default while optimizing for a specific CPU type would require additional configuration flags.  Perhaps a flag like --optimize-for-native-cpu would make sense for people who are building sage themselves for their personal use.",
    "created_at": "2021-08-11T03:07:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32126#issuecomment-458741",
    "user": "culler"
}
```

Possibly the sense should also be inverted, meaning that maximum portability would be the default while optimizing for a specific CPU type would require additional configuration flags.  Perhaps a flag like --optimize-for-native-cpu would make sense for people who are building sage themselves for their personal use.



---

archive/issue_comments_458742.json:
```json
{
    "body": "Replying to [comment:3 culler]:\n> Possibly the sense should also be inverted, meaning that maximum portability would be the default while optimizing for a specific CPU type would require additional configuration flags.\n-1 on this. Building a portable binary is clearly a more specialized use case than building an optimized binary.",
    "created_at": "2021-08-11T05:44:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32126#issuecomment-458742",
    "user": "mkoeppe"
}
```

Replying to [comment:3 culler]:
> Possibly the sense should also be inverted, meaning that maximum portability would be the default while optimizing for a specific CPU type would require additional configuration flags.
-1 on this. Building a portable binary is clearly a more specialized use case than building an optimized binary.



---

archive/issue_comments_458743.json:
```json
{
    "body": "-1\n\nNon-portable build appears to be the standard use case, when compiling something yourself from source.",
    "created_at": "2021-08-11T05:50:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32126#issuecomment-458743",
    "user": "@kliem"
}
```

-1

Non-portable build appears to be the standard use case, when compiling something yourself from source.



---

archive/issue_comments_458744.json:
```json
{
    "body": "I agree that the name `--enable-fat-binary` is confusing and incorrect.",
    "created_at": "2021-08-11T05:51:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32126#issuecomment-458744",
    "user": "@kliem"
}
```

I agree that the name `--enable-fat-binary` is confusing and incorrect.
