# Issue 13321: PALP/Laurent Normal Form

Issue created by migration from https://trac.sagemath.org/ticket/13525

Original creator: sjg10

Original creation time: 2012-09-24 13:06:09

Assignee: mhampton

CC:  novoselt tomc trehn jkeitel

This patch adds the PALP normal form algorithm natively into the `lattice_polytope` class, as well as a modified algorithm that is more efficient for some polytopes. This is then also used directly to calculate a normal form for Laurent polynomials.

These algorithms require abilities to permute rows and columns of matrices, as well as find automorphisms of matrices under these operations, and lattice polytopes under GL(n,Z) transformations. These are also implemented here.


---

Comment by sjg10 created at 2012-09-24 13:11:26

Changing status from new to needs_review.


---

Comment by vbraun created at 2012-09-24 13:51:43

Very nice! Thanks for tackling this, I always wanted this implemented!

Some minor nitpicks: Whenever you return a list of stuff, its better to return a tuple (which is immutable).


```
def matrix_transformation(self,NewPolytope): 
```

CamelCase should only be used for class names, not parameters. Also, space after comma. Thats just the standard Python code style.


```
def lexicographical_order(self,certify=False): 
```

The name is a bit confusing, how about `permutation_normal_form()` or something like that?



```
def is_isomorphic(self,N,certify=False): 
```

The linear algebra people will probably object to that kind of isomorphism check of matrices. How about `is_permutation_of()`?


```
By default, in general one can't mix matrices and permutations
```

Should be just "in general, ...".


---

Comment by dimpase created at 2012-09-24 16:03:26

The reference you give in the code does not define the normal form you are computing. Is this published anywhere? If yes, please give a proper reference. If not, it would be great if you give a definition in the docstrings. 

PS. Well, I am very curious to find out what it is. That's one of the reasons I ask :–)


---

Comment by dimpase created at 2012-09-24 16:57:27

Replying to [comment:3 dimpase]:
> The reference you give in the code does not define the normal form you are computing. Is this published anywhere? If yes, please give a proper reference. If not, it would be great if you give a definition in the docstrings. 
> 
> PS. Well, I am very curious to find out what it is. That's one of the reasons I ask :–)

Volker kindly [wrote](https://groups.google.com/d/msg/sage-devel/3o7vRy2FByI/pLPEAPgNbn4J):
See Section 3.4 of http://arxiv.org/pdf/hep-th/9805190.pdf for the definition of the PALP normal form. 
So this would be a reference to add.


---

Comment by trehn created at 2012-09-26 10:49:23

I have one brief remark about the method _automorphisms()_. If I see this correctly, you build the complete face lattice, compute its automorphism group (i.e. the combinatorial automorphism group of the polytope) and filter those permutations that correspond to GL(n,ZZ)-transformations.

There seems to be already a method of _Polyhedron_ that computes the combinatorial automorphism group, so you could use this method. For the combinatorial automorphisms of the polytope you don't need the whole face lattice, but the bipartite vertex-facet-incidence graph is enough.


---

Comment by sjg10 created at 2012-09-27 08:30:36

Thanks all, fixing up the small issues now. Regarding what [comment:6 trehn] said, firstly, `LatticePolytope` does not inherit at all from `Polyhedron` and there does not seem to be an easy way to cast between the two, though as an aside, maybe this should be rectified?

Secondly it is possible, and such was the intent (though I haven't personally checked this out, but have been told) that checking if a permutation corresponds to a GL(n,ZZ) transformation is a more hefty computation than constructing the face lattice. Doing so (especially as it is decorated with some lattice polytope invariants) and reducing the number of permutations to check, over just finding the combinatorial automorphisms and checking all of these may be quicker.


---

Comment by trehn created at 2012-09-27 13:52:33

Replying to [comment:7 sjg10]:
> Secondly it is possible, and such was the intent (though I haven't personally checked this out, but have been told) that checking if a permutation corresponds to a GL(n,ZZ) transformation is a more hefty computation than constructing the face lattice. Doing so (especially as it is decorated with some lattice polytope invariants) and reducing the number of permutations to check, over just finding the combinatorial automorphisms and checking all of these may be quicker.

Sorry, I didn't see the lattice index invariants at first. Of course, my comment is not relevant if your input is "easy". Because you check all permutations whether they correspond to GL(n,ZZ)-transformations, trying to keep this number small seems reasonable. 

I think that, depending on the polytope, either the size of the face lattice or the number of group elements will cause problems if you go to dimensions beyond the PALP limit.


---

Comment by sjg10 created at 2012-10-02 12:48:35

Replying to [comment:8 trehn]:
> I think that, depending on the polytope, either the size of the face lattice or the number of group elements will cause problems if you go to dimensions beyond the PALP limit.

This is one of the main reasons of having implemented the PALP algorithm natively, the overflow errors that PALP is susceptible to in higher dimensions is removed when running the algorithm through python.


---

Attachment

Issues in comments addressed


---

Comment by vbraun created at 2013-05-01 09:11:09

#14319 improves the graph automorphisms so you don't have to track the relabeling any more. This would simplify the code here, too. 

As a minor nitpick, pep8 would be nice:

```
def palp_modified_normal_form(L,affine_transform=False,certify=False):    # no
def palp_modified_normal_form(L, affine_transform=False, certify=False):  # yes
```

Also, docstring should be imperative: "Return foobar". Not: "Returns foobar" or "We return foobar".


---

Comment by git created at 2013-09-28 16:40:58

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by jkeitel created at 2013-09-28 16:44:06

I have tried to rebase the patch and, in particular, tried to adapt to the changes from #14319. However, automorphisms of LatticePolytopes do not work yet and there is probably much code that could be rewritten.

As far as the code in lattice_polytope.py is concerned, I've only reformated and not checked what the code actually does.
The same is true for all other normal_form methods.


---

Comment by jkeitel created at 2013-09-28 16:51:19

Changing status from needs_review to needs_work.


---

Comment by git created at 2013-10-23 14:49:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jkeitel created at 2013-10-23 14:51:36

This is now almost at a point where things are working. For now I have removed the attempts at a method finding isomorphisms between two given polytopes.
The plan is to write a proper method for general affine transformations in #15280.


---

Comment by git created at 2013-10-28 10:16:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2013-10-30 11:11:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jkeitel created at 2013-10-30 12:41:53

Alright, I think I am more or less done rewriting the patch. I have
* removed functionality for Laurent normal form and finding isomorphisms between LatticePolytopes. These were broken and at least the latter will be reintroduced (in more general form) in #15280
* restructured the _palp* methods for computing normal forms in lattice_polytope.py
* rebased and partially rewritten the code and tried to use the common formatting conventions
* included permutation read-out directly from PALP
* extended docstrings and tests

There are some issues:
Two key functions, namely LatticePolytopeClass._palp_normal_form_native and Matrix.permutation_normal_form, both of which calculate the maximal form of a matrix under permutations of columns and rows have fairly tense bits of code and I did not understand everything.
While I verified that after fixing a couple of small errors they now give the correct results for several thousand examples, there may additional bugs. There might also be potential for optimization.

What should be done in this case?


---

Comment by jkeitel created at 2013-10-30 13:55:43

Changing status from needs_work to needs_review.


---

Comment by rws created at 2014-05-09 08:11:23

Changing status from needs_review to needs_work.


---

Comment by git created at 2014-05-12 13:16:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-05-12 13:17:27

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2014-05-12 13:17:27

I've fixed the merge conflict and some minor nitpicks (unnused `_normal_form`, doc build). Functionality looks good to me.


---

Comment by novoselt created at 2014-05-12 19:04:58

This branch "undoes" some of the deprecation-related changes from #15240, let me try to go over it too, will have a version in a few hours.


---

Comment by novoselt created at 2014-05-12 19:04:58

Changing status from positive_review to needs_work.


---

Comment by novoselt created at 2014-05-12 21:48:50

Changing status from needs_work to needs_review.


---

Comment by novoselt created at 2014-05-12 21:48:50

Done!
----
New commits:


---

Comment by vbraun created at 2014-05-13 08:30:24

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-05-13 13:11:41

Resolution: fixed
