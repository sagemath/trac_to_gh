# Issue 14267: Exception KeyError: in WeakValueDictionary remove ignored

archive/issues_014267.json:
```json
{
    "body": "Assignee: rlm\n\nCC:  simonking nbruin nthiery hivert\n\nUnder some circumstances the WeakValueDictionary remove callback is being called when the internal dictionary is in a bad state. The attached patch to demonstrate the issue just calls `hasattr` from the displayhook, which ends up generating weak references somewhere. The exact place for where the exception occurs depends on the garbage collector, but I always do get some unwanted exceptions with it.\n\n```\nsage -t devel/sage/sage/matrix/matrix0.pyx\nException KeyError: (((<class 'sage.matrix.matrix_space.MatrixSpace'>, Callable function ring with arguments (x, y), 2, 2, False), ()),) in <function remove at 0x18d8758> ignored\n**********************************************************************\nFile \"devel/sage/sage/matrix/matrix0.pyx\", line 3370, in sage.matrix.matrix0.Matrix.is_hermitian\nFailed example:\n    B.is_hermitian()\nExpected:\n    True\nGot:\n    Exception KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),) in <function remove at 0x18d8758> ignored\n    True\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/14471\n\n",
    "created_at": "2013-04-21T15:33:16Z",
    "labels": [
        "memleak",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.12",
    "title": "Exception KeyError: in WeakValueDictionary remove ignored",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14267",
    "user": "vbraun"
}
```
Assignee: rlm

CC:  simonking nbruin nthiery hivert

Under some circumstances the WeakValueDictionary remove callback is being called when the internal dictionary is in a bad state. The attached patch to demonstrate the issue just calls `hasattr` from the displayhook, which ends up generating weak references somewhere. The exact place for where the exception occurs depends on the garbage collector, but I always do get some unwanted exceptions with it.

```
sage -t devel/sage/sage/matrix/matrix0.pyx
Exception KeyError: (((<class 'sage.matrix.matrix_space.MatrixSpace'>, Callable function ring with arguments (x, y), 2, 2, False), ()),) in <function remove at 0x18d8758> ignored
**********************************************************************
File "devel/sage/sage/matrix/matrix0.pyx", line 3370, in sage.matrix.matrix0.Matrix.is_hermitian
Failed example:
    B.is_hermitian()
Expected:
    True
Got:
    Exception KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),) in <function remove at 0x18d8758> ignored
    True
```


Issue created by migration from https://trac.sagemath.org/ticket/14471





---

archive/issue_comments_179547.json:
```json
{
    "body": "Attachment [trac_14471_demonstrate.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471_demonstrate.patch) by vbraun created at 2013-04-21 15:34:18\n\nInitial patch",
    "created_at": "2013-04-21T15:34:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179547",
    "user": "vbraun"
}
```

Attachment [trac_14471_demonstrate.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471_demonstrate.patch) by vbraun created at 2013-04-21 15:34:18

Initial patch



---

archive/issue_comments_179548.json:
```json
{
    "body": "Initial patch",
    "created_at": "2013-04-21T15:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179548",
    "user": "vbraun"
}
```

Initial patch



---

archive/issue_comments_179549.json:
```json
{
    "body": "Attachment [debug_ignored_exceptions.patch](tarball://root/attachments/some-uuid/ticket14471/debug_ignored_exceptions.patch) by vbraun created at 2013-04-21 15:38:47\n\nThe [attachment:debug_ignored_exceptions.patch] is a backport from Python-3.3 to give better diagnosis of ignored exceptions. With it, I get\n\n```\n    Exception ignored in: <function remove at 0x2472938>\n    Traceback (most recent call last):\n      File \"/home/vbraun/opt/sage-5.9.beta5/local/lib/python/weakref.py\", line 51, in remove\n        del self.data[wr.key]\n    KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),)\n```\n\nso the KeyError really comes from the WeakValueDictionary remove callback.",
    "created_at": "2013-04-21T15:38:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179549",
    "user": "vbraun"
}
```

Attachment [debug_ignored_exceptions.patch](tarball://root/attachments/some-uuid/ticket14471/debug_ignored_exceptions.patch) by vbraun created at 2013-04-21 15:38:47

The [attachment:debug_ignored_exceptions.patch] is a backport from Python-3.3 to give better diagnosis of ignored exceptions. With it, I get

```
    Exception ignored in: <function remove at 0x2472938>
    Traceback (most recent call last):
      File "/home/vbraun/opt/sage-5.9.beta5/local/lib/python/weakref.py", line 51, in remove
        del self.data[wr.key]
    KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),)
```

so the KeyError really comes from the WeakValueDictionary remove callback.



---

archive/issue_comments_179550.json:
```json
{
    "body": "Adding some debugging in `remove()` shows that the `wr.key` is still in `self.dict.keys()` but `del self.dict[wr.key]` fails with a KeyError. Presumably because the whole thing is running during the garbage collection cycle. I tried #14159 but it didn't change anything. \n\nI haven't figured out exactly which cache in the Sage library is the culprit, maybe Simon knows?",
    "created_at": "2013-04-21T15:43:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179550",
    "user": "vbraun"
}
```

Adding some debugging in `remove()` shows that the `wr.key` is still in `self.dict.keys()` but `del self.dict[wr.key]` fails with a KeyError. Presumably because the whole thing is running during the garbage collection cycle. I tried #14159 but it didn't change anything. 

I haven't figured out exactly which cache in the Sage library is the culprit, maybe Simon knows?



---

archive/issue_comments_179551.json:
```json
{
    "body": "`WeakValueDict` is a standard python library class, not one of our own brew. So once we can put the finger on the bug we should likely report upstream. See also #13394, although I doubt the issue pointed out there is what is at play here.\n\nMy first guess would be that the cache at play is a \"cached_method\" or a \"cached_function\" cache, probably the one from `UniqueRepresentation`, but I'm not entirely sure. The entries in:\n\n```\nsuper(MatrixSpace,sage.matrix.matrix_space.MatrixSpace).__classcall__.get_cache().keys()\n```\n\naren't quite of the shape you're finding.\n\nA quick analysis; This is `WeakValueDictionary.__init__`:\n\n```\n    def __init__(self, *args, **kw):\n        def remove(wr, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                del self.data[wr.key]\n        self._remove = remove\n        UserDict.UserDict.__init__(self, *args, **kw)\n```\n\nAs you can see, `remove` only stores a link to the dictionary via a weak reference, so that the dictionary can get deallocated before the callback (and the callback finds that the dict doesn't exist anymore and simply does nothing). So that's correct.\n\nWe also see that `remove` *only* removes the key. It doesn't check whether the value is still what it's supposed to be and it also doesn't check if the key is still there in the first place. That would be safe if there's a guarantee that as soon as a value gets removed from the dictionary, the `KeyedRef` gets removed as well (in which case the callback dies without getting executed).\n\nThe bug we're seeing indicates that we end up with:\n- `weakvaluedict[key]=value`\n- `key:KeyedRef(value)` pair gets removed from dict - this *should* more or less atomically destroy the `KeyedRef(value)`.\n- somehow, the callback from the `KeyedRef(value)` stored gets called before it gets destroyed.\n\nSince the `KeyedRef(value)`  should really only be referenced from the `weakvaluedict`, it's a bit hard to let it survive: As soon it gets decreffed it should get deallocated.\n\nMy guess is that this happens IN cyclic garbage removal, where callbacks do get separated from deletions. Python tries hard to avoid calling such callbacks unnecessarily or in situations where it's unsafe to do so, but perhaps cleaning up extremely complicated cyclic structures (which we do create) could fool the detection.\n\nIf this is right, then these keyerrors should be relatively harmless: They would be happening on a dictionary that is slated for demolition anyway. That would suggest we could just catch and ignore the keyerror in the WeakValueDictionary removal function. It would be good to identify the scenario that justifies doing so, however.",
    "created_at": "2013-04-21T19:12:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179551",
    "user": "nbruin"
}
```

`WeakValueDict` is a standard python library class, not one of our own brew. So once we can put the finger on the bug we should likely report upstream. See also #13394, although I doubt the issue pointed out there is what is at play here.

My first guess would be that the cache at play is a "cached_method" or a "cached_function" cache, probably the one from `UniqueRepresentation`, but I'm not entirely sure. The entries in:

```
super(MatrixSpace,sage.matrix.matrix_space.MatrixSpace).__classcall__.get_cache().keys()
```

aren't quite of the shape you're finding.

A quick analysis; This is `WeakValueDictionary.__init__`:

```
    def __init__(self, *args, **kw):
        def remove(wr, selfref=ref(self)):
            self = selfref()
            if self is not None:
                del self.data[wr.key]
        self._remove = remove
        UserDict.UserDict.__init__(self, *args, **kw)
```

As you can see, `remove` only stores a link to the dictionary via a weak reference, so that the dictionary can get deallocated before the callback (and the callback finds that the dict doesn't exist anymore and simply does nothing). So that's correct.

We also see that `remove` *only* removes the key. It doesn't check whether the value is still what it's supposed to be and it also doesn't check if the key is still there in the first place. That would be safe if there's a guarantee that as soon as a value gets removed from the dictionary, the `KeyedRef` gets removed as well (in which case the callback dies without getting executed).

The bug we're seeing indicates that we end up with:
- `weakvaluedict[key]=value`
- `key:KeyedRef(value)` pair gets removed from dict - this *should* more or less atomically destroy the `KeyedRef(value)`.
- somehow, the callback from the `KeyedRef(value)` stored gets called before it gets destroyed.

Since the `KeyedRef(value)`  should really only be referenced from the `weakvaluedict`, it's a bit hard to let it survive: As soon it gets decreffed it should get deallocated.

My guess is that this happens IN cyclic garbage removal, where callbacks do get separated from deletions. Python tries hard to avoid calling such callbacks unnecessarily or in situations where it's unsafe to do so, but perhaps cleaning up extremely complicated cyclic structures (which we do create) could fool the detection.

If this is right, then these keyerrors should be relatively harmless: They would be happening on a dictionary that is slated for demolition anyway. That would suggest we could just catch and ignore the keyerror in the WeakValueDictionary removal function. It would be good to identify the scenario that justifies doing so, however.



---

archive/issue_comments_179552.json:
```json
{
    "body": "I agree and verified with `gc.get_referrers` that it is `sage.structure.unique_representation.CachedRepresentation.__classcall__.cache`\n\nIf I change the remove() callback to\n\n```\n                import sys\n                print >> sys.stderr, 'removing', wr.key in self.data.keys()\n                del self.data[wr.key]\n                print >> sys.stderr, 'finished removing'\n```\n\nthen I get \n\n```\n    ...\n    removing True\n    finished removing\n    removing True\n    Exception KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),) in <function remove at 0x1acf758> ignored\n    removing True\n    finished removing\n    removing True\n    finished removing\n    ...\n```\n\nSo the weakvaluedict (self.data) is in a bad state...",
    "created_at": "2013-04-21T19:46:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179552",
    "user": "vbraun"
}
```

I agree and verified with `gc.get_referrers` that it is `sage.structure.unique_representation.CachedRepresentation.__classcall__.cache`

If I change the remove() callback to

```
                import sys
                print >> sys.stderr, 'removing', wr.key in self.data.keys()
                del self.data[wr.key]
                print >> sys.stderr, 'finished removing'
```

then I get 

```
    ...
    removing True
    finished removing
    removing True
    Exception KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),) in <function remove at 0x1acf758> ignored
    removing True
    finished removing
    removing True
    finished removing
    ...
```

So the weakvaluedict (self.data) is in a bad state...



---

archive/issue_comments_179553.json:
```json
{
    "body": "Replying to [comment:5 vbraun]:\n> So the weakvaluedict (self.data) is in a bad state...\n\n`self.data` is a normal dict. Your example doesn't quite show the dict is in a \"bad state\". It shows that between testing whether the key is in the dict and doing the delete, the key has been removed. That's not quite the same as `self.data` beng corrupted.\n\nSomething is going wrong of course, though. Something seems to be mutating self.data in between. The only methods that seem to be mutating the underlying `self.data` for a  `WeakValueDictionary` are `__setitem__`, `popitem`, `pop`, `setdefault`, `update` (and of course `__delitem__` and `clear` it inherits from `UserDict`). Perhaps I don't have enough imagination, but indeed the only scenario in which I could see one of those happening during a callback is when a GC gets triggered and basically the whole dict gets cleaned up.\n\nSome of the \"iterator\" methods on `WeakValueDict` don't quite seem safe to me, by the way. The `iteritems` method, for instance, iterates over `self.data.itervalues()`, but `self.data` can be mutated outside of your control due to GC callbacks, and iterators over a mutating dict are generally not safe.\nI doubt that's what's hurting us here, though.",
    "created_at": "2013-04-21T20:50:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179553",
    "user": "nbruin"
}
```

Replying to [comment:5 vbraun]:
> So the weakvaluedict (self.data) is in a bad state...

`self.data` is a normal dict. Your example doesn't quite show the dict is in a "bad state". It shows that between testing whether the key is in the dict and doing the delete, the key has been removed. That's not quite the same as `self.data` beng corrupted.

Something is going wrong of course, though. Something seems to be mutating self.data in between. The only methods that seem to be mutating the underlying `self.data` for a  `WeakValueDictionary` are `__setitem__`, `popitem`, `pop`, `setdefault`, `update` (and of course `__delitem__` and `clear` it inherits from `UserDict`). Perhaps I don't have enough imagination, but indeed the only scenario in which I could see one of those happening during a callback is when a GC gets triggered and basically the whole dict gets cleaned up.

Some of the "iterator" methods on `WeakValueDict` don't quite seem safe to me, by the way. The `iteritems` method, for instance, iterates over `self.data.itervalues()`, but `self.data` can be mutated outside of your control due to GC callbacks, and iterators over a mutating dict are generally not safe.
I doubt that's what's hurting us here, though.



---

archive/issue_comments_179554.json:
```json
{
    "body": "Replying to [comment:6 nbruin]:\n> Replying to [comment:5 vbraun]:\n> > So the weakvaluedict (self.data) is in a bad state...\n> \n> `self.data` is a normal dict. Your example doesn't quite show the dict is in a \"bad state\".\n\nFair enough, but even after I catch the KeyError the `wr.key in self.data.keys()` is still `True`. So the `self.data` dict is in a weird place for sure.\n\nI agree that this smells like something else is mutating `self.data` in-between. It is possible that deallocation somewhere triggers a call to `CachedRepresentation`, but I don't see where that would be the case.",
    "created_at": "2013-04-22T08:58:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179554",
    "user": "vbraun"
}
```

Replying to [comment:6 nbruin]:
> Replying to [comment:5 vbraun]:
> > So the weakvaluedict (self.data) is in a bad state...
> 
> `self.data` is a normal dict. Your example doesn't quite show the dict is in a "bad state".

Fair enough, but even after I catch the KeyError the `wr.key in self.data.keys()` is still `True`. So the `self.data` dict is in a weird place for sure.

I agree that this smells like something else is mutating `self.data` in-between. It is possible that deallocation somewhere triggers a call to `CachedRepresentation`, but I don't see where that would be the case.



---

archive/issue_comments_179555.json:
```json
{
    "body": "gdb/cython backtrace",
    "created_at": "2013-04-22T09:14:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179555",
    "user": "vbraun"
}
```

gdb/cython backtrace



---

archive/issue_comments_179556.json:
```json
{
    "body": "Attachment [sage_crash_IfVSEK.log](tarball://root/attachments/some-uuid/ticket14471/sage_crash_IfVSEK.log) by vbraun created at 2013-04-22 09:27:39\n\ngdb/cython backtrace in a debug build",
    "created_at": "2013-04-22T09:27:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179556",
    "user": "vbraun"
}
```

Attachment [sage_crash_IfVSEK.log](tarball://root/attachments/some-uuid/ticket14471/sage_crash_IfVSEK.log) by vbraun created at 2013-04-22 09:27:39

gdb/cython backtrace in a debug build



---

archive/issue_comments_179557.json:
```json
{
    "body": "I've added an `unguarded_abort` to force a gdb backtrace but it looks as it should to me: A object is being deallocated and triggers the WeakValueDictionary remove callback. The only dict that is being cleaned at that time are the globals of the doctest runner.",
    "created_at": "2013-04-22T09:53:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179557",
    "user": "vbraun"
}
```

I've added an `unguarded_abort` to force a gdb backtrace but it looks as it should to me: A object is being deallocated and triggers the WeakValueDictionary remove callback. The only dict that is being cleaned at that time are the globals of the doctest runner.



---

archive/issue_comments_179558.json:
```json
{
    "body": "Replying to [comment:7 vbraun]:\n> Fair enough, but even after I catch the KeyError the `wr.key in self.data.keys()` is still `True`. So the `self.data` dict is in a weird place for sure.\n\nThat is weird, and sounds to me like `self.data` is indeed corrupted. Given that key/value pairs are stored together in a dictionary, it's very hard for this to be true too. Caching the result from data.keys wouldn't make sense at all, so I don't think python will be doing that. Perhaps check that something like `wr.key in self.data` or `self.data.__contains__(wr.key)` returns true and/or if `value=self.data[wr.key]` succeeds (and what kind of value you get back: whether it's `wr`)\n\nThat might give you some indication of what exactly is wrong with the entry and hence where the problem might be coming from.\n\nOne thing your traceback is confirming:\n- There is no GC going on, so callbacks are happening when you think they should.\n- Hence there's also not a circular data structure directly involved\n- Things are happening during cleanup, so these callbacks are probably indeed happening on a dict that will be deleted too. It's still bad they don't properly execute, of course, but we've seen before that order in cleanup can sometimes lead to subtle problems (i.e., whether things are stored in a cdef attribute or in a conventional dict).\n\nOne possible scenario:\n- self.data is in the process of being cleared. The dict is actually emptied then before any entries are decreffed (to prevent dict reshaping during deallocation).\n- One of the weakreffed values also occurs as a key in the dict (and that's the only strong ref)\n- decreffing that key causes the callback, but the callback finds a dict that is now empty, so of course we get a key error.\n\nYour diagnosis that `wr.key in self.data` is still true is not consistent with that, but the scenario indeed leads to ignored keyerrors:\n\n\n```\nimport weakref\n\nclass A(object):\n  def __init__(self,n):\n    self.n=n\n  def __repr__(self):\n    return \"A(%d)\"%self.n\n\ndef mess(n):\n  D=weakref.WeakValueDictionary()\n  L=[A(i) for i in range(n)]\n  for i in range(n-1):\n      j=(i+10)%n\n      D[L[i]]=L[j]\n  return D\n\nD=mess(10000)\nD.clear()\n```\n\n\n(how many you ignored keyerrors you get depends a bit on memory layout etc.)\n\nThis is definitely a bug in the python library. The problem is that `remove` does check if the dict still exists (via the weakref, which is mainly to ensure that presence of callbacks doesn't extend the life of the dict), but doesn't check if the dict is otherwise in a funny state, such as \"in the process of a `clear`\".\n\nThis is now [Python issue 17816](http://bugs.python.org/issue17816). Python3 does not seem to have this problem and it may not be the problem we're running into here.",
    "created_at": "2013-04-22T16:20:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179558",
    "user": "nbruin"
}
```

Replying to [comment:7 vbraun]:
> Fair enough, but even after I catch the KeyError the `wr.key in self.data.keys()` is still `True`. So the `self.data` dict is in a weird place for sure.

That is weird, and sounds to me like `self.data` is indeed corrupted. Given that key/value pairs are stored together in a dictionary, it's very hard for this to be true too. Caching the result from data.keys wouldn't make sense at all, so I don't think python will be doing that. Perhaps check that something like `wr.key in self.data` or `self.data.__contains__(wr.key)` returns true and/or if `value=self.data[wr.key]` succeeds (and what kind of value you get back: whether it's `wr`)

That might give you some indication of what exactly is wrong with the entry and hence where the problem might be coming from.

One thing your traceback is confirming:
- There is no GC going on, so callbacks are happening when you think they should.
- Hence there's also not a circular data structure directly involved
- Things are happening during cleanup, so these callbacks are probably indeed happening on a dict that will be deleted too. It's still bad they don't properly execute, of course, but we've seen before that order in cleanup can sometimes lead to subtle problems (i.e., whether things are stored in a cdef attribute or in a conventional dict).

One possible scenario:
- self.data is in the process of being cleared. The dict is actually emptied then before any entries are decreffed (to prevent dict reshaping during deallocation).
- One of the weakreffed values also occurs as a key in the dict (and that's the only strong ref)
- decreffing that key causes the callback, but the callback finds a dict that is now empty, so of course we get a key error.

Your diagnosis that `wr.key in self.data` is still true is not consistent with that, but the scenario indeed leads to ignored keyerrors:


```
import weakref

class A(object):
  def __init__(self,n):
    self.n=n
  def __repr__(self):
    return "A(%d)"%self.n

def mess(n):
  D=weakref.WeakValueDictionary()
  L=[A(i) for i in range(n)]
  for i in range(n-1):
      j=(i+10)%n
      D[L[i]]=L[j]
  return D

D=mess(10000)
D.clear()
```


(how many you ignored keyerrors you get depends a bit on memory layout etc.)

This is definitely a bug in the python library. The problem is that `remove` does check if the dict still exists (via the weakref, which is mainly to ensure that presence of callbacks doesn't extend the life of the dict), but doesn't check if the dict is otherwise in a funny state, such as "in the process of a `clear`".

This is now [Python issue 17816](http://bugs.python.org/issue17816). Python3 does not seem to have this problem and it may not be the problem we're running into here.



---

archive/issue_comments_179559.json:
```json
{
    "body": "I've looked at the Python 3 code and there weakref keeps a separate list of keys to remove to work around this issue.\n\nAny further non-Sage related discussion should probably move to the Python bugtracker.\n\nAs for Sage, should we patch Python for this? I hit this bug in #14469 and its likely that we'll trip over it again.",
    "created_at": "2013-04-22T17:00:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179559",
    "user": "vbraun"
}
```

I've looked at the Python 3 code and there weakref keeps a separate list of keys to remove to work around this issue.

Any further non-Sage related discussion should probably move to the Python bugtracker.

As for Sage, should we patch Python for this? I hit this bug in #14469 and its likely that we'll trip over it again.



---

archive/issue_comments_179560.json:
```json
{
    "body": "Replying to [comment:10 vbraun]:\n\n> As for Sage, should we patch Python for this? I hit this bug in #14469 and its likely that we'll trip over it again.\n\nI would suggest a paranoid `remove` function for this:\n\n```\n        def remove(wr, selfref=ref(self)):\n            self = selfref()\n            if self is not None and self.data.get(wr.key) is wr:\n                del self.data[wr.key]\n```\n\nThe `get` method avoids exception handling and hopefully avoids allocation as much as possible (thus avoiding triggering GC) and will return `None` if the reference is not present. Furthermore, we verify that the correct value is still stored in the dictionary, in case a callback gets delayed so much that another value makes it into that dict under the same key (that shouldn't really happen, so that's the paranoid bit).\n\nI tried. Making the test\n\n```\n            if self is not None and wr.key in self.data:\n```\n\nalso makes the error go away (but is less paranoid than the option above), but indeed, making the test\n\n```\n            if self is not None and wr.key in self.data.keys():\n```\n\ndoes not!! So there is something wrong with self.data.keys(). Indeed, putting\n\n```\n        def remove(wr, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if wr.key in self.data.keys() and wr.key not in self.data:\n                    raise RuntimeError(\"BAD KEY:%s\"%(wr.key,))\n                del self.data[wr.key]\n```\n\nin there makes for \"ignored runtime error\". On the other hand, if I run the example above with the `BAD KEY` test, I do not get these problems. Therefore, the discrepancy between `in data.keys()` and `in data` does not occur in the example above.\n\nSo:\n- there is a fix that apparently solves both problems\n- there is something different in the problem originally reported here, since `keys()` seems to report an erroneous list.\n\nOne difference between `data.keys()` and `__contains__` is that `dictobject.c/dict_keys` just iterates over the table storing the dict and extracts the keys of all dictentries that have a non-NULL value field, whereas `__contains__` will go through a `dictlookup`.\nGiven that some of the key components may well be in the process of being torn down, could it be that their hash is broken? One would still be able to find the corresponding key by iterating through all of them (as `wr.key in data.keys()` does), but finding it by hash would not work. Both `__contains__` and `__delitem__` would suffer from that.\n\nThis could happen if the MRO of some class changed to insert/remove `WithEqualityById` in it. Changing the hash on a key component for which a callback happens would have exactly this effect. So my bet is that it's an artifact of the mro voodoo the dynamical category stuff does or it's an unfortunate clearing/changing of a cached hash value somewhere due to a deletion-in-progress.",
    "created_at": "2013-04-22T18:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179560",
    "user": "nbruin"
}
```

Replying to [comment:10 vbraun]:

> As for Sage, should we patch Python for this? I hit this bug in #14469 and its likely that we'll trip over it again.

I would suggest a paranoid `remove` function for this:

```
        def remove(wr, selfref=ref(self)):
            self = selfref()
            if self is not None and self.data.get(wr.key) is wr:
                del self.data[wr.key]
```

The `get` method avoids exception handling and hopefully avoids allocation as much as possible (thus avoiding triggering GC) and will return `None` if the reference is not present. Furthermore, we verify that the correct value is still stored in the dictionary, in case a callback gets delayed so much that another value makes it into that dict under the same key (that shouldn't really happen, so that's the paranoid bit).

I tried. Making the test

```
            if self is not None and wr.key in self.data:
```

also makes the error go away (but is less paranoid than the option above), but indeed, making the test

```
            if self is not None and wr.key in self.data.keys():
```

does not!! So there is something wrong with self.data.keys(). Indeed, putting

```
        def remove(wr, selfref=ref(self)):
            self = selfref()
            if self is not None:
                if wr.key in self.data.keys() and wr.key not in self.data:
                    raise RuntimeError("BAD KEY:%s"%(wr.key,))
                del self.data[wr.key]
```

in there makes for "ignored runtime error". On the other hand, if I run the example above with the `BAD KEY` test, I do not get these problems. Therefore, the discrepancy between `in data.keys()` and `in data` does not occur in the example above.

So:
- there is a fix that apparently solves both problems
- there is something different in the problem originally reported here, since `keys()` seems to report an erroneous list.

One difference between `data.keys()` and `__contains__` is that `dictobject.c/dict_keys` just iterates over the table storing the dict and extracts the keys of all dictentries that have a non-NULL value field, whereas `__contains__` will go through a `dictlookup`.
Given that some of the key components may well be in the process of being torn down, could it be that their hash is broken? One would still be able to find the corresponding key by iterating through all of them (as `wr.key in data.keys()` does), but finding it by hash would not work. Both `__contains__` and `__delitem__` would suffer from that.

This could happen if the MRO of some class changed to insert/remove `WithEqualityById` in it. Changing the hash on a key component for which a callback happens would have exactly this effect. So my bet is that it's an artifact of the mro voodoo the dynamical category stuff does or it's an unfortunate clearing/changing of a cached hash value somewhere due to a deletion-in-progress.



---

archive/issue_comments_179561.json:
```json
{
    "body": "Replying to [comment:5 vbraun]:\n> {{{\n>     Exception KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),) in <function remove at 0x1acf758> ignored\n> }}}\nThis entry is produced by the `__call__` doctest in `matrix0.pyx`:\n\n```diff\n            sage: f(x,y) = x^2+y\n            sage: m = matrix([[f,f*f],[f^3,f^4]]); m\n            [    (x, y) |--> x^2 + y (x, y) |--> (x^2 + y)^2]\n            [(x, y) |--> (x^2 + y)^3 (x, y) |--> (x^2 + y)^4]\n            sage: m(1,2)\n            [ 3  9]\n            [27 81]\n            sage: m(y=2,x=1)\n            [ 3  9]\n            [27 81]\n            sage: m(2,1)\n            [  5  25]\n            [125 625]\n+           sage: D=UniqueRepresentation.__classcall__.get_cache()\n+           sage: [k for k in D.data.keys() if k not in D.data]\n+           []\n```\n\nWith the added doctest, we get different behaviour depending on whether \nattachment:trac_14471_demonstrate.patch is applied or not: Without the patch, the test passes; with the patch the test fails. That means that the line\n\n```\nhasattr(obj, '_foobar_')\n```\n\nchanges the hash of one of the key components involved; probably the \"callable function ring\", i.e., `parent(f)`. Indeed:\n\n```\nsage: f(x,y) = x^2+y\nsage: H=hash(parent(f))\nsage: m = matrix([[f,f*f],[f^3,f^4]]);\nsage: hasattr(m,'a')\nFalse\nsage: H == hash(parent(f))\nFalse\n```\n\nthat last one's really bad! The `hasattr` on that matrix apparently clobbers the hash of its base ring!",
    "created_at": "2013-04-23T01:27:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179561",
    "user": "nbruin"
}
```

Replying to [comment:5 vbraun]:
> {{{
>     Exception KeyError: (((<class 'sage.categories.algebras.Algebras'>, Callable function ring with arguments (x, y)), ()),) in <function remove at 0x1acf758> ignored
> }}}
This entry is produced by the `__call__` doctest in `matrix0.pyx`:

```diff
            sage: f(x,y) = x^2+y
            sage: m = matrix([[f,f*f],[f^3,f^4]]); m
            [    (x, y) |--> x^2 + y (x, y) |--> (x^2 + y)^2]
            [(x, y) |--> (x^2 + y)^3 (x, y) |--> (x^2 + y)^4]
            sage: m(1,2)
            [ 3  9]
            [27 81]
            sage: m(y=2,x=1)
            [ 3  9]
            [27 81]
            sage: m(2,1)
            [  5  25]
            [125 625]
+           sage: D=UniqueRepresentation.__classcall__.get_cache()
+           sage: [k for k in D.data.keys() if k not in D.data]
+           []
```

With the added doctest, we get different behaviour depending on whether 
attachment:trac_14471_demonstrate.patch is applied or not: Without the patch, the test passes; with the patch the test fails. That means that the line

```
hasattr(obj, '_foobar_')
```

changes the hash of one of the key components involved; probably the "callable function ring", i.e., `parent(f)`. Indeed:

```
sage: f(x,y) = x^2+y
sage: H=hash(parent(f))
sage: m = matrix([[f,f*f],[f^3,f^4]]);
sage: hasattr(m,'a')
False
sage: H == hash(parent(f))
False
```

that last one's really bad! The `hasattr` on that matrix apparently clobbers the hash of its base ring!



---

archive/issue_comments_179562.json:
```json
{
    "body": "I think this illustrates the problem rather well:\n\n```\nsage: f(x,y) = x^2+y\nsage: P=parent(f)\nsage: P.__class__\nsage.symbolic.callable.CallableSymbolicExpressionRing_class\nsage: H=hash(P.__class__)\nsage: m = matrix([[f,f*f],[f^3,f^4]])\nsage: H == hash(P.__class__)\nTrue\nsage: hasattr(m,'a')\nFalse\nsage: P.__class__\nsage.symbolic.callable.CallableSymbolicExpressionRing_class_with_category\nsage: H == hash(P.__class__)\nFalse\n```\n\nWe have that `P.__hash__` looks like:\n\n```\n    def __hash__(self):\n        return hash((self.__class__, self._arguments))\n```\n\nObviously, when class is not fixed, it's a bad ingredient for a hash. Given that\n\n```\nsage: T=type(P)\nsage: [t for t in T.mro() if '__hash__' in t.__dict__]\n[sage.symbolic.callable.CallableSymbolicExpressionRing_class,\n sage.symbolic.ring.SymbolicRing,\n sage.structure.category_object.CategoryObject,\n sage.structure.sage_object.SageObject,\n object]\n```\n\nwe do need to do something about hashing, since `sage.symbolic.ring.SymbolicRing.__hash__` is just a fixed value and these CallableExpression rings do come in different flavours. The `__cmp__` method there also depends on `self.__class__` which should obviously not be relied upon.\n\nGiven that this code stems from #5930, it predates these dynamic classes voodoo by quite a bit, so the fact that it doesn't operate well with it is a bug in the dynamic classes stuff. A job for Simon, Nicholas and the gang!\n\nFurthermore, note that `type(parent(m))` inherits from `UniqueRepresentation` but that `type(parent(f))` does not.  It doesn't seem easy to do, but it might be possible to make two equal-but-not-identical callable expression rings. Building matrix rings over them will wreak havoc, because the constructor will use equality testing on the ingredients (and hence return identical matrix rings), but the coercion framework will not honour \"equality\" between the non-identical base rings.\n\n**EDIT:** The last bit is not the case. `CallableSymbolicExpressionRing` is a `UniqueFactory`. Furthermore, it seems the coercion framework does detect \"equal but nonidentical\" parent and can sometimes figure out coercions between them.",
    "created_at": "2013-04-23T07:36:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179562",
    "user": "nbruin"
}
```

I think this illustrates the problem rather well:

```
sage: f(x,y) = x^2+y
sage: P=parent(f)
sage: P.__class__
sage.symbolic.callable.CallableSymbolicExpressionRing_class
sage: H=hash(P.__class__)
sage: m = matrix([[f,f*f],[f^3,f^4]])
sage: H == hash(P.__class__)
True
sage: hasattr(m,'a')
False
sage: P.__class__
sage.symbolic.callable.CallableSymbolicExpressionRing_class_with_category
sage: H == hash(P.__class__)
False
```

We have that `P.__hash__` looks like:

```
    def __hash__(self):
        return hash((self.__class__, self._arguments))
```

Obviously, when class is not fixed, it's a bad ingredient for a hash. Given that

```
sage: T=type(P)
sage: [t for t in T.mro() if '__hash__' in t.__dict__]
[sage.symbolic.callable.CallableSymbolicExpressionRing_class,
 sage.symbolic.ring.SymbolicRing,
 sage.structure.category_object.CategoryObject,
 sage.structure.sage_object.SageObject,
 object]
```

we do need to do something about hashing, since `sage.symbolic.ring.SymbolicRing.__hash__` is just a fixed value and these CallableExpression rings do come in different flavours. The `__cmp__` method there also depends on `self.__class__` which should obviously not be relied upon.

Given that this code stems from #5930, it predates these dynamic classes voodoo by quite a bit, so the fact that it doesn't operate well with it is a bug in the dynamic classes stuff. A job for Simon, Nicholas and the gang!

Furthermore, note that `type(parent(m))` inherits from `UniqueRepresentation` but that `type(parent(f))` does not.  It doesn't seem easy to do, but it might be possible to make two equal-but-not-identical callable expression rings. Building matrix rings over them will wreak havoc, because the constructor will use equality testing on the ingredients (and hence return identical matrix rings), but the coercion framework will not honour "equality" between the non-identical base rings.

**EDIT:** The last bit is not the case. `CallableSymbolicExpressionRing` is a `UniqueFactory`. Furthermore, it seems the coercion framework does detect "equal but nonidentical" parent and can sometimes figure out coercions between them.



---

archive/issue_comments_179563.json:
```json
{
    "body": "I did a very quick search for lines in source containing both `hash` and `__class__`. Lines 73 and 75 in `sage/combinat/species/recursive_species.py` are also guilty, so whoever is going to fix this might want to look at those lines too.",
    "created_at": "2013-04-23T15:38:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179563",
    "user": "nbruin"
}
```

I did a very quick search for lines in source containing both `hash` and `__class__`. Lines 73 and 75 in `sage/combinat/species/recursive_species.py` are also guilty, so whoever is going to fix this might want to look at those lines too.



---

archive/issue_comments_179564.json:
```json
{
    "body": "Isn't this super-dangerous, changing the hash can potentially give you wrong results.\n\nAlso, I thought it is already wrong to make the bare class (not `_with_category`) accessible through `parent()`? Of course that ought to be spelled out in the documentation.",
    "created_at": "2013-05-02T18:01:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179564",
    "user": "vbraun"
}
```

Isn't this super-dangerous, changing the hash can potentially give you wrong results.

Also, I thought it is already wrong to make the bare class (not `_with_category`) accessible through `parent()`? Of course that ought to be spelled out in the documentation.



---

archive/issue_comments_179565.json:
```json
{
    "body": "Replying to [comment:16 vbraun]:\n> Isn't this super-dangerous, changing the hash can potentially give you wrong results.\n\nExperience shows you don't have to change hashes for that, but yes, feel free to up the severity of the ticket if you feel strongly about this.\n\n>Also, I thought it is already wrong to make the bare class (not _with_category) accessible through parent()? Of course that ought to be spelled out in the documentation. \n\nI think the system just gets tricked into that here and I think it's unavoidable: If I remember correctly, the category initialization gets delayed for efficiency reasons. Fixing that would probably cause unacceptable loss of performance in other places.",
    "created_at": "2013-05-03T00:09:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179565",
    "user": "nbruin"
}
```

Replying to [comment:16 vbraun]:
> Isn't this super-dangerous, changing the hash can potentially give you wrong results.

Experience shows you don't have to change hashes for that, but yes, feel free to up the severity of the ticket if you feel strongly about this.

>Also, I thought it is already wrong to make the bare class (not _with_category) accessible through parent()? Of course that ought to be spelled out in the documentation. 

I think the system just gets tricked into that here and I think it's unavoidable: If I remember correctly, the category initialization gets delayed for efficiency reasons. Fixing that would probably cause unacceptable loss of performance in other places.



---

archive/issue_comments_179566.json:
```json
{
    "body": "Replying to [comment:17 nbruin]:\n> I think the system just gets tricked into that here and I think it's unavoidable: If I remember correctly, the category initialization gets delayed for efficiency reasons. Fixing that would probably cause unacceptable loss of performance in other places.\n\nIs that actually true? This is about constructing a parent, after all. Though maybe somebody who actually wrote the category code could chime in and tell us what he/she envisioned and where it is documented (j/k).",
    "created_at": "2013-05-03T09:22:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179566",
    "user": "vbraun"
}
```

Replying to [comment:17 nbruin]:
> I think the system just gets tricked into that here and I think it's unavoidable: If I remember correctly, the category initialization gets delayed for efficiency reasons. Fixing that would probably cause unacceptable loss of performance in other places.

Is that actually true? This is about constructing a parent, after all. Though maybe somebody who actually wrote the category code could chime in and tell us what he/she envisioned and where it is documented (j/k).



---

archive/issue_comments_179567.json:
```json
{
    "body": "See `sage.matrix.matrix_space.MatrixSpace.full_category_initialisation` for documentation. See #11900 for timings.\n\nThe difference of `MatrixSpace` with respect to other parents is that some code (namely on elliptic curves) creates many different matrix spaces, but uses them *only* as a container, but not as a fully grown parent.",
    "created_at": "2013-05-03T09:28:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179567",
    "user": "SimonKing"
}
```

See `sage.matrix.matrix_space.MatrixSpace.full_category_initialisation` for documentation. See #11900 for timings.

The difference of `MatrixSpace` with respect to other parents is that some code (namely on elliptic curves) creates many different matrix spaces, but uses them *only* as a container, but not as a fully grown parent.



---

archive/issue_comments_179568.json:
```json
{
    "body": "PS: A further difference is that finding the correct category is a bit more involved than in other examples. It may be an algebra or a module, depending on whether we talk about general or square matrices. And concerning module, this involves checking whether the base ring is a field, which also tends to be slow. And all this effort would be in vain, because the category framework isn't used for matrix spaces in the elliptic curve code.",
    "created_at": "2013-05-03T09:41:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179568",
    "user": "SimonKing"
}
```

PS: A further difference is that finding the correct category is a bit more involved than in other examples. It may be an algebra or a module, depending on whether we talk about general or square matrices. And concerning module, this involves checking whether the base ring is a field, which also tends to be slow. And all this effort would be in vain, because the category framework isn't used for matrix spaces in the elliptic curve code.



---

archive/issue_comments_179569.json:
```json
{
    "body": "But the problem is `CallableSymbolicExpressionRing_class`, not `MatrixSpace`? The matrices only trigger the problem by initializing the `CallableSymbolicExpressionRing_class_with_category`. Presumably matrices are smart enough to not use `__class__` for hashes and comparison if they delay category initialization.",
    "created_at": "2013-05-03T10:01:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179569",
    "user": "vbraun"
}
```

But the problem is `CallableSymbolicExpressionRing_class`, not `MatrixSpace`? The matrices only trigger the problem by initializing the `CallableSymbolicExpressionRing_class_with_category`. Presumably matrices are smart enough to not use `__class__` for hashes and comparison if they delay category initialization.



---

archive/issue_comments_179570.json:
```json
{
    "body": "Replying to [comment:21 vbraun]:\n> But the problem is `CallableSymbolicExpressionRing_class`, not `MatrixSpace`? The matrices only trigger the problem by initializing the `CallableSymbolicExpressionRing_class_with_category`.\n\nAs much as I know, I never touched `CallableSymbolicExpressionRing`.\n\n> Presumably matrices are smart enough to not use `__class__` for hashes and comparison if they delay category initialization. \n\nI hope so.",
    "created_at": "2013-05-03T12:12:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179570",
    "user": "SimonKing"
}
```

Replying to [comment:21 vbraun]:
> But the problem is `CallableSymbolicExpressionRing_class`, not `MatrixSpace`? The matrices only trigger the problem by initializing the `CallableSymbolicExpressionRing_class_with_category`.

As much as I know, I never touched `CallableSymbolicExpressionRing`.

> Presumably matrices are smart enough to not use `__class__` for hashes and comparison if they delay category initialization. 

I hope so.



---

archive/issue_comments_179571.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-05-29T21:35:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179571",
    "user": "vbraun"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_179572.json:
```json
{
    "body": "Ok, fixing the offending `__hash__` functions is easy of course. I thought long about how we can ensure that it doesn't happen again, and the best way I can see is to check that the hash does not change in `Parent._refine_category_' during doctests. The patch implements that.",
    "created_at": "2013-05-29T21:35:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179572",
    "user": "vbraun"
}
```

Ok, fixing the offending `__hash__` functions is easy of course. I thought long about how we can ensure that it doesn't happen again, and the best way I can see is to check that the hash does not change in `Parent._refine_category_' during doctests. The patch implements that.



---

archive/issue_comments_179573.json:
```json
{
    "body": "Patchbot:\n\nApply trac_14471_dynamic_class_hash.patch",
    "created_at": "2013-05-30T15:23:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179573",
    "user": "vbraun"
}
```

Patchbot:

Apply trac_14471_dynamic_class_hash.patch



---

archive/issue_comments_179574.json:
```json
{
    "body": "I'm setting the priority to critical since it is a structural issue that we must get right in order to trust computations.\n\nRediffed to sage-5.11.beta3",
    "created_at": "2013-06-26T14:31:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179574",
    "user": "vbraun"
}
```

I'm setting the priority to critical since it is a structural issue that we must get right in order to trust computations.

Rediffed to sage-5.11.beta3



---

archive/issue_comments_179575.json:
```json
{
    "body": "Changing priority from major to critical.",
    "created_at": "2013-06-26T14:31:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179575",
    "user": "vbraun"
}
```

Changing priority from major to critical.



---

archive/issue_comments_179576.json:
```json
{
    "body": "patchbot:\n\napply trac_14471_dynamic_class_hash.patch",
    "created_at": "2013-06-26T14:32:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179576",
    "user": "vbraun"
}
```

patchbot:

apply trac_14471_dynamic_class_hash.patch



---

archive/issue_comments_179577.json:
```json
{
    "body": "All tests pass (based on sage-5.11.b3). I think the patch solves the problem in a clean way.\n\nI think one should add a new test to `_refine_category`, demonstrating that the class is *not* changed, if its hash depends on it. I plan to add this in a review patch.\n\nOne might argue that any new class (such as `DebugOptions_class`) requires new doctests. But it is just a means to store certain attributes, hence, I think doctests will not be needed in this case.\n\nUnfortunately the patchbot has not finished testing yet. But unless there is a clear regression in startup time, I'll give it a positive review (as soon as I have posted my review patch).",
    "created_at": "2013-06-26T16:26:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179577",
    "user": "SimonKing"
}
```

All tests pass (based on sage-5.11.b3). I think the patch solves the problem in a clean way.

I think one should add a new test to `_refine_category`, demonstrating that the class is *not* changed, if its hash depends on it. I plan to add this in a review patch.

One might argue that any new class (such as `DebugOptions_class`) requires new doctests. But it is just a means to store certain attributes, hence, I think doctests will not be needed in this case.

Unfortunately the patchbot has not finished testing yet. But unless there is a clear regression in startup time, I'll give it a positive review (as soon as I have posted my review patch).



---

archive/issue_comments_179578.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-06-26T20:51:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179578",
    "user": "SimonKing"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_179579.json:
```json
{
    "body": "There is no regression in startup time. However, I did not succeed to get the warning when changing the hash. I tried:\n\n```\n        Here is a test against :trac:`14471`. Refining the category will issue\n        a warning, if this change affects the hash value (note that this will\n        only be seen in doctest mode)::\n\n            sage: class MyParent(Parent):\n            ....:     def __hash__(self):\n            ....:         return hash(type(self))\n            ....: \n            sage: a = MyParent(category=Rings())\n            sage: h = hash(a)\n            sage: a._refine_category_(Algebras(QQ))\n            hash of <class '__main__.MyParent_with_category'> changed in Parent._refine_category_\n            sage: h == hash(a)\n            False\n```\n\n\nIf I understand correctly, the check of refine category will by default be done in doctests. But I get:\n\n```\nFailed example:\n    a._refine_category_(Algebras(QQ))\nExpected:\n    hash of <class '__main__.MyParent_with_category'> changed in Parent._refine_category_\nGot:\n    <BLANKLINE>\n```\n\n\nSo, what shall one do?",
    "created_at": "2013-06-26T20:51:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179579",
    "user": "SimonKing"
}
```

There is no regression in startup time. However, I did not succeed to get the warning when changing the hash. I tried:

```
        Here is a test against :trac:`14471`. Refining the category will issue
        a warning, if this change affects the hash value (note that this will
        only be seen in doctest mode)::

            sage: class MyParent(Parent):
            ....:     def __hash__(self):
            ....:         return hash(type(self))
            ....: 
            sage: a = MyParent(category=Rings())
            sage: h = hash(a)
            sage: a._refine_category_(Algebras(QQ))
            hash of <class '__main__.MyParent_with_category'> changed in Parent._refine_category_
            sage: h == hash(a)
            False
```


If I understand correctly, the check of refine category will by default be done in doctests. But I get:

```
Failed example:
    a._refine_category_(Algebras(QQ))
Expected:
    hash of <class '__main__.MyParent_with_category'> changed in Parent._refine_category_
Got:
    <BLANKLINE>
```


So, what shall one do?



---

archive/issue_comments_179580.json:
```json
{
    "body": "Fixed. The debug flag was actually not set during doctests (initialization order). Now is being set explicitly. I added your doctest.",
    "created_at": "2013-06-27T04:54:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179580",
    "user": "vbraun"
}
```

Fixed. The debug flag was actually not set during doctests (initialization order). Now is being set explicitly. I added your doctest.



---

archive/issue_comments_179581.json:
```json
{
    "body": "Attachment [trac_14471_dynamic_class_hash.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471_dynamic_class_hash.patch) by vbraun created at 2013-06-27 05:20:01\n\nUpdated patch",
    "created_at": "2013-06-27T05:20:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179581",
    "user": "vbraun"
}
```

Attachment [trac_14471_dynamic_class_hash.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471_dynamic_class_hash.patch) by vbraun created at 2013-06-27 05:20:01

Updated patch



---

archive/issue_comments_179582.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-06-27T12:49:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179582",
    "user": "SimonKing"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_179583.json:
```json
{
    "body": "Attachment [trac_14471-review.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471-review.patch) by SimonKing created at 2013-06-27 12:51:15",
    "created_at": "2013-06-27T12:51:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179583",
    "user": "SimonKing"
}
```

Attachment [trac_14471-review.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471-review.patch) by SimonKing created at 2013-06-27 12:51:15



---

archive/issue_comments_179584.json:
```json
{
    "body": "I think it would be a good idea to show that the hash actually did change. I extended the new test accordingly, in a review patch.\n\nPositive review, then!",
    "created_at": "2013-06-27T12:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179584",
    "user": "SimonKing"
}
```

I think it would be a good idea to show that the hash actually did change. I extended the new test accordingly, in a review patch.

Positive review, then!



---

archive/issue_comments_179585.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-06-27T12:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179585",
    "user": "SimonKing"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_179586.json:
```json
{
    "body": "No, I spoke to soon. Now, as the debug flag is set, it makes sense to run the full doc tests. After all, it could be that the debug flag uncovers a bug.",
    "created_at": "2013-06-27T12:53:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179586",
    "user": "SimonKing"
}
```

No, I spoke to soon. Now, as the debug flag is set, it makes sense to run the full doc tests. After all, it could be that the debug flag uncovers a bug.



---

archive/issue_comments_179587.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2013-06-27T12:53:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179587",
    "user": "SimonKing"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_179588.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2013-06-27T13:17:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179588",
    "user": "vbraun"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_179589.json:
```json
{
    "body": "Doctests pass on my machine, of course",
    "created_at": "2013-06-27T13:17:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179589",
    "user": "vbraun"
}
```

Doctests pass on my machine, of course



---

archive/issue_comments_179590.json:
```json
{
    "body": "Replying to [comment:35 vbraun]:\n> Doctests pass on my machine, of course\n\nConfirmed!",
    "created_at": "2013-06-27T14:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179590",
    "user": "SimonKing"
}
```

Replying to [comment:35 vbraun]:
> Doctests pass on my machine, of course

Confirmed!



---

archive/issue_comments_179591.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-06-27T14:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179591",
    "user": "SimonKing"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_179592.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2013-07-25T06:17:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179592",
    "user": "jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_179593.json:
```json
{
    "body": "The PDF documentation doesn't build due to the use of single instead of double backticks:\n\n```\n! Missing { inserted.\n<to be read again> \n                   _\nl.14636 when the constructor calls $Parent.__\n                                             init__()$ directly or\n?\n! Emergency stop.\n<to be read again> \n                   _\nl.14636 when the constructor calls $Parent.__\n                                             init__()$ directly or\n!  ==> Fatal error occurred, no output PDF file produced!\nTranscript written on geometry.log.\n [180[combinat ] /mazur/release/merger/sage-5.11.rc0/devel/sage/doc/en/reference/combinat/sage/combinat/crystals/alcove_path.rst:: WARNING: unusable reference target fo\nund: ../../../../../../../html/en/reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation\n[combinat ] /mazur/release/merger/sage-5.11.rc0/devel/sage/doc/en/reference/combinat/sage/combinat/crystals/alcove_path.rst:: WARNING: unusable reference target found:\n../../../../../../../html/en/reference/structure/sage/structure/parent.html#sage.structure.parent.Parent\nmake[1]: *** [geometry.pdf] Error 1\n```\n",
    "created_at": "2013-07-25T06:17:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179593",
    "user": "jdemeyer"
}
```

The PDF documentation doesn't build due to the use of single instead of double backticks:

```
! Missing { inserted.
<to be read again> 
                   _
l.14636 when the constructor calls $Parent.__
                                             init__()$ directly or
?
! Emergency stop.
<to be read again> 
                   _
l.14636 when the constructor calls $Parent.__
                                             init__()$ directly or
!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on geometry.log.
 [180[combinat ] /mazur/release/merger/sage-5.11.rc0/devel/sage/doc/en/reference/combinat/sage/combinat/crystals/alcove_path.rst:: WARNING: unusable reference target fo
und: ../../../../../../../html/en/reference/structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation
[combinat ] /mazur/release/merger/sage-5.11.rc0/devel/sage/doc/en/reference/combinat/sage/combinat/crystals/alcove_path.rst:: WARNING: unusable reference target found:
../../../../../../../html/en/reference/structure/sage/structure/parent.html#sage.structure.parent.Parent
make[1]: *** [geometry.pdf] Error 1
```




---

archive/issue_comments_179594.json:
```json
{
    "body": "Attachment [trac_14471-pdf-fix.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471-pdf-fix.patch) by vbraun created at 2013-07-25 14:44:15\n\nInitial patch",
    "created_at": "2013-07-25T14:44:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179594",
    "user": "vbraun"
}
```

Attachment [trac_14471-pdf-fix.patch](tarball://root/attachments/some-uuid/ticket14471/trac_14471-pdf-fix.patch) by vbraun created at 2013-07-25 14:44:15

Initial patch



---

archive/issue_comments_179595.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2013-07-25T14:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179595",
    "user": "vbraun"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_179596.json:
```json
{
    "body": "Fixed.",
    "created_at": "2013-07-25T14:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179596",
    "user": "vbraun"
}
```

Fixed.



---

archive/issue_comments_179597.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-08-02T14:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14267",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14267#issuecomment-179597",
    "user": "jdemeyer"
}
```

Resolution: fixed
