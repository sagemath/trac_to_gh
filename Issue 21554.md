# Issue 21554: Improve Order Ideals Lattice and Linear Extension Cardinality.

Issue created by migration from https://trac.sagemath.org/ticket/21791

Original creator: kdilks

Original creation time: 2016-11-01 08:40:54

CC:  sage-combinat jmantysalo tscrim

Previously in ticket #14126, we changed the way that we count linear extensions of a poset from iterating over all of them to counting maximal chains in the lattice of order ideals. This lead to a significant speed improvement, but performance was still lacking compared to Stembridge's Posets package for Maple due to using the basic implementation of `order_ideals_lattice()`.

I now have some working code following Stembridge's algorithm which takes a naturally labelled poset P (which we can get by considering the underlying hasse diagram), and constructs a dictionary of covering relations for a naturally labelled poset isomorphic to the lattice of order ideals J(P). This dictionary is sufficient to compute the number of maximal chains of J(P) (and thus the number of linear extensions of P). 

In terms of computing linear extensions, this new method is about an order of magnitude faster than the current implementation. In the case of `P=Posets.StandardExample(8)`, a poset on 16 elements, who knows how long the iteration method would have taken to count all 1828915200 linear extensions, the existing implementation did it in 6.15 seconds, and the code I have now did it in .34 seconds. 

Presumably, it would also be worthwhile to use this algorithm as a replacement for whatever currently exists for `P.order_ideals_lattice(as_ideals=False)`.

It also might take a little time to clean up the code, figure out where everything should go, and make sure it's well documented (since I think the idea behind the algorithm is pretty nifty).


---

Comment by kdilks created at 2016-11-01 08:41:22

Set assignee to kdilks.


---

Comment by tscrim created at 2016-11-01 13:56:27

Changing type from PLEASE CHANGE to enhancement.


---

Comment by jmantysalo created at 2016-11-01 19:31:45

This may also speed up random distributive lattice generation, see #21626.


---

Comment by kdilks created at 2016-11-09 01:01:32

This is what I have for an initial implementation for `linear_extensions().cardinality()`. Tried to include a lot of documentation to make the algorithm clear, and in case somebody can notice potential optimizations in any steps. 

In particular, there are two parts where I need to compute an order filter of some element x when I'm just given covering relations. The method I use makes a list of lists, initialized with a singleton list of x, and each successive list consists of anything covering something in the previous list. This loops until there's nothing left, and then the list of lists is flattened and sorted. In general, an element y is going to appear once for every saturated chain from x to y, so maybe you could try and remove some of that duplication along the way. But maybe the amount of duplication is negligible compared to the cost of checking for duplicates at each step of the way.

Eventually, `order_ideals_lattice(as_ideals=False)` can be replaced with the exact same code, except instead of doing the final loop to count maximal chains, we use `Jup` as the input for the poset/lattice constructor and return that. I think it might also be nice to have a `P.number_of_linear_extensions()` alias for `P.linear_extensions().cardinality()`.
----
New commits:


---

Comment by jmantysalo created at 2016-11-10 08:39:23

Is the Stembridge's algorithm explained somewhere, or is it only readable as code?


---

Comment by chapoton created at 2017-05-21 20:43:20

I made a little cleanup of the code, and doctests do now pass.
----
New commits:


---

Comment by git created at 2017-05-22 01:26:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-05-22 01:27:13

Did an `%lprun` and found that almost all of the time was spent in the line `K[j + 1] = K[j + 1] + [b]`. So I changed that to use a faster Python idiom and got a huge speed boost:

```
sage: P = Posets.StandardExample(9)
sage: L = P.linear_extensions()
sage: %time L.cardinality()
CPU times: user 44 ms, sys: 4 ms, total: 48 ms
Wall time: 45.6 ms
146313216000
```

vs old:

```
sage: P = Posets.StandardExample(9)
sage: L = P.linear_extensions()
sage: %time L.cardinality()
CPU times: user 13.7 s, sys: 12 ms, total: 13.7 s
Wall time: 13.7 s
146313216000
```

So now this line takes ~65% of the time and the ~31% is in

```
K = sorted(set([item for sublist in K for item in sublist]))
```

However, I think this is probably the best we could get.
----
New commits:


---

Comment by chapoton created at 2017-05-22 06:42:50

For this 31% line, do we have a more efficient way to flatten ?


---

Comment by git created at 2017-05-22 07:02:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-05-22 07:03:13

It's not flattening but removing duplicates and sorting. Well, one (trivial) thing we could do is remove the inner list, which drops the time by a very small amount. This pushes that line to 15% of the time (`%lprun` is so great for profiling). I don't think we will get much better because of the Python overhead.


---

Comment by chapoton created at 2017-05-22 07:19:32

Maybe we should think of a "sort-and-deduplicate" fast algorithm. but not in this ticket.

ok, anyway it is already so much better than before..


---

Comment by chapoton created at 2017-05-22 14:51:57

Changing status from new to needs_review.


---

Comment by chapoton created at 2017-05-22 14:51:57

let it be


---

Comment by chapoton created at 2017-05-22 14:52:22

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2017-05-22 14:58:20

Thank you. Big thank you to Kevin for the initial port of Stembridge's code.


---

Comment by vbraun created at 2017-05-23 06:57:30

Resolution: fixed
