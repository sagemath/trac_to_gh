# Issue 21554: Improve Order Ideals Lattice and Linear Extension Cardinality.

archive/issues_021554.json:
```json
{
    "body": "CC:  sage-combinat @jm58660 @tscrim\n\nPreviously in ticket #14126, we changed the way that we count linear extensions of a poset from iterating over all of them to counting maximal chains in the lattice of order ideals. This lead to a significant speed improvement, but performance was still lacking compared to Stembridge's Posets package for Maple due to using the basic implementation of `order_ideals_lattice()`.\n\nI now have some working code following Stembridge's algorithm which takes a naturally labelled poset P (which we can get by considering the underlying hasse diagram), and constructs a dictionary of covering relations for a naturally labelled poset isomorphic to the lattice of order ideals J(P). This dictionary is sufficient to compute the number of maximal chains of J(P) (and thus the number of linear extensions of P). \n\nIn terms of computing linear extensions, this new method is about an order of magnitude faster than the current implementation. In the case of `P=Posets.StandardExample(8)`, a poset on 16 elements, who knows how long the iteration method would have taken to count all 1828915200 linear extensions, the existing implementation did it in 6.15 seconds, and the code I have now did it in .34 seconds. \n\nPresumably, it would also be worthwhile to use this algorithm as a replacement for whatever currently exists for `P.order_ideals_lattice(as_ideals=False)`.\n\nIt also might take a little time to clean up the code, figure out where everything should go, and make sure it's well documented (since I think the idea behind the algorithm is pretty nifty).\n\nIssue created by migration from https://trac.sagemath.org/ticket/21791\n\n",
    "created_at": "2016-11-01T08:40:54Z",
    "labels": [
        "combinatorics",
        "major"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Improve Order Ideals Lattice and Linear Extension Cardinality.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21554",
    "user": "@kevindilks"
}
```
CC:  sage-combinat @jm58660 @tscrim

Previously in ticket #14126, we changed the way that we count linear extensions of a poset from iterating over all of them to counting maximal chains in the lattice of order ideals. This lead to a significant speed improvement, but performance was still lacking compared to Stembridge's Posets package for Maple due to using the basic implementation of `order_ideals_lattice()`.

I now have some working code following Stembridge's algorithm which takes a naturally labelled poset P (which we can get by considering the underlying hasse diagram), and constructs a dictionary of covering relations for a naturally labelled poset isomorphic to the lattice of order ideals J(P). This dictionary is sufficient to compute the number of maximal chains of J(P) (and thus the number of linear extensions of P). 

In terms of computing linear extensions, this new method is about an order of magnitude faster than the current implementation. In the case of `P=Posets.StandardExample(8)`, a poset on 16 elements, who knows how long the iteration method would have taken to count all 1828915200 linear extensions, the existing implementation did it in 6.15 seconds, and the code I have now did it in .34 seconds. 

Presumably, it would also be worthwhile to use this algorithm as a replacement for whatever currently exists for `P.order_ideals_lattice(as_ideals=False)`.

It also might take a little time to clean up the code, figure out where everything should go, and make sure it's well documented (since I think the idea behind the algorithm is pretty nifty).

Issue created by migration from https://trac.sagemath.org/ticket/21791





---

archive/issue_comments_299230.json:
```json
{
    "body": "Set assignee to @kevindilks.",
    "created_at": "2016-11-01T08:41:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299230",
    "user": "@kevindilks"
}
```

Set assignee to @kevindilks.



---

archive/issue_comments_299231.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2016-11-01T13:56:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299231",
    "user": "@tscrim"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_299232.json:
```json
{
    "body": "This may also speed up random distributive lattice generation, see #21626.",
    "created_at": "2016-11-01T19:31:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299232",
    "user": "@jm58660"
}
```

This may also speed up random distributive lattice generation, see #21626.



---

archive/issue_comments_299233.json:
```json
{
    "body": "This is what I have for an initial implementation for `linear_extensions().cardinality()`. Tried to include a lot of documentation to make the algorithm clear, and in case somebody can notice potential optimizations in any steps. \n\nIn particular, there are two parts where I need to compute an order filter of some element x when I'm just given covering relations. The method I use makes a list of lists, initialized with a singleton list of x, and each successive list consists of anything covering something in the previous list. This loops until there's nothing left, and then the list of lists is flattened and sorted. In general, an element y is going to appear once for every saturated chain from x to y, so maybe you could try and remove some of that duplication along the way. But maybe the amount of duplication is negligible compared to the cost of checking for duplicates at each step of the way.\n\nEventually, `order_ideals_lattice(as_ideals=False)` can be replaced with the exact same code, except instead of doing the final loop to count maximal chains, we use `Jup` as the input for the poset/lattice constructor and return that. I think it might also be nice to have a `P.number_of_linear_extensions()` alias for `P.linear_extensions().cardinality()`.\n----\nNew commits:",
    "created_at": "2016-11-09T01:01:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299233",
    "user": "@kevindilks"
}
```

This is what I have for an initial implementation for `linear_extensions().cardinality()`. Tried to include a lot of documentation to make the algorithm clear, and in case somebody can notice potential optimizations in any steps. 

In particular, there are two parts where I need to compute an order filter of some element x when I'm just given covering relations. The method I use makes a list of lists, initialized with a singleton list of x, and each successive list consists of anything covering something in the previous list. This loops until there's nothing left, and then the list of lists is flattened and sorted. In general, an element y is going to appear once for every saturated chain from x to y, so maybe you could try and remove some of that duplication along the way. But maybe the amount of duplication is negligible compared to the cost of checking for duplicates at each step of the way.

Eventually, `order_ideals_lattice(as_ideals=False)` can be replaced with the exact same code, except instead of doing the final loop to count maximal chains, we use `Jup` as the input for the poset/lattice constructor and return that. I think it might also be nice to have a `P.number_of_linear_extensions()` alias for `P.linear_extensions().cardinality()`.
----
New commits:



---

archive/issue_comments_299234.json:
```json
{
    "body": "Is the Stembridge's algorithm explained somewhere, or is it only readable as code?",
    "created_at": "2016-11-10T08:39:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299234",
    "user": "@jm58660"
}
```

Is the Stembridge's algorithm explained somewhere, or is it only readable as code?



---

archive/issue_comments_299235.json:
```json
{
    "body": "I made a little cleanup of the code, and doctests do now pass.\n----\nNew commits:",
    "created_at": "2017-05-21T20:43:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299235",
    "user": "@fchapoton"
}
```

I made a little cleanup of the code, and doctests do now pass.
----
New commits:



---

archive/issue_comments_299236.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-05-22T01:26:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299236",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_299237.json:
```json
{
    "body": "Did an `%lprun` and found that almost all of the time was spent in the line `K[j + 1] = K[j + 1] + [b]`. So I changed that to use a faster Python idiom and got a huge speed boost:\n\n```\nsage: P = Posets.StandardExample(9)\nsage: L = P.linear_extensions()\nsage: %time L.cardinality()\nCPU times: user 44 ms, sys: 4 ms, total: 48 ms\nWall time: 45.6 ms\n146313216000\n```\n\nvs old:\n\n```\nsage: P = Posets.StandardExample(9)\nsage: L = P.linear_extensions()\nsage: %time L.cardinality()\nCPU times: user 13.7 s, sys: 12 ms, total: 13.7 s\nWall time: 13.7 s\n146313216000\n```\n\nSo now this line takes ~65% of the time and the ~31% is in\n\n```\nK = sorted(set([item for sublist in K for item in sublist]))\n```\n\nHowever, I think this is probably the best we could get.\n----\nNew commits:",
    "created_at": "2017-05-22T01:27:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299237",
    "user": "@tscrim"
}
```

Did an `%lprun` and found that almost all of the time was spent in the line `K[j + 1] = K[j + 1] + [b]`. So I changed that to use a faster Python idiom and got a huge speed boost:

```
sage: P = Posets.StandardExample(9)
sage: L = P.linear_extensions()
sage: %time L.cardinality()
CPU times: user 44 ms, sys: 4 ms, total: 48 ms
Wall time: 45.6 ms
146313216000
```

vs old:

```
sage: P = Posets.StandardExample(9)
sage: L = P.linear_extensions()
sage: %time L.cardinality()
CPU times: user 13.7 s, sys: 12 ms, total: 13.7 s
Wall time: 13.7 s
146313216000
```

So now this line takes ~65% of the time and the ~31% is in

```
K = sorted(set([item for sublist in K for item in sublist]))
```

However, I think this is probably the best we could get.
----
New commits:



---

archive/issue_comments_299238.json:
```json
{
    "body": "For this 31% line, do we have a more efficient way to flatten ?",
    "created_at": "2017-05-22T06:42:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299238",
    "user": "@fchapoton"
}
```

For this 31% line, do we have a more efficient way to flatten ?



---

archive/issue_comments_299239.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-05-22T07:02:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299239",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_299240.json:
```json
{
    "body": "It's not flattening but removing duplicates and sorting. Well, one (trivial) thing we could do is remove the inner list, which drops the time by a very small amount. This pushes that line to 15% of the time (`%lprun` is so great for profiling). I don't think we will get much better because of the Python overhead.",
    "created_at": "2017-05-22T07:03:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299240",
    "user": "@tscrim"
}
```

It's not flattening but removing duplicates and sorting. Well, one (trivial) thing we could do is remove the inner list, which drops the time by a very small amount. This pushes that line to 15% of the time (`%lprun` is so great for profiling). I don't think we will get much better because of the Python overhead.



---

archive/issue_comments_299241.json:
```json
{
    "body": "Maybe we should think of a \"sort-and-deduplicate\" fast algorithm. but not in this ticket.\n\nok, anyway it is already so much better than before..",
    "created_at": "2017-05-22T07:19:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299241",
    "user": "@fchapoton"
}
```

Maybe we should think of a "sort-and-deduplicate" fast algorithm. but not in this ticket.

ok, anyway it is already so much better than before..



---

archive/issue_comments_299242.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-05-22T14:51:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299242",
    "user": "@fchapoton"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_299243.json:
```json
{
    "body": "let it be",
    "created_at": "2017-05-22T14:51:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299243",
    "user": "@fchapoton"
}
```

let it be



---

archive/issue_comments_299244.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-05-22T14:52:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299244",
    "user": "@fchapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_299245.json:
```json
{
    "body": "Thank you. Big thank you to Kevin for the initial port of Stembridge's code.",
    "created_at": "2017-05-22T14:58:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299245",
    "user": "@tscrim"
}
```

Thank you. Big thank you to Kevin for the initial port of Stembridge's code.



---

archive/issue_comments_299246.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-05-23T06:57:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21554",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21554#issuecomment-299246",
    "user": "@vbraun"
}
```

Resolution: fixed
