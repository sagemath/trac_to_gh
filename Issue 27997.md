# Issue 27997: Sage Integers are incompatible with Python Fractions

archive/issues_027997.json:
```json
{
    "body": "CC:  jdemeyer mcbell slelievre vdelecroix simonking @posita tscrim\n\nKeywords: days100\n\nIn Sage 8.8 the code:\n\n```\nsage: from fractions import Fraction\nsage: Fraction(1, 1)\n```\n\n\nraises the following error:\n\n```\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-4-0c4690dff1ca> in <module>()\n----> 1 Fraction(Integer(1), Integer(1))\n\n/Applications/SageMath-8.6.app/Contents/Resources/sage/local/lib/python2.7/fractions.pyc in __new__(cls, numerator, denominator)\n    152             isinstance(denominator, Rational)):\n    153             numerator, denominator = (\n--> 154                 numerator.numerator * denominator.denominator,\n    155                 denominator.numerator * numerator.denominator\n    156                 )\n\nTypeError: unsupported operand type(s) for *: 'builtin_function_or_method' and 'builtin_function_or_method'\n```\n\n\nThis appears to be because of the fact that Sage marks its integers as a numbers.rational and so Fraction expects these to provide Fraction.numerator and Fraction.denominator properties. However for Sage integers these are methods.\n\nNote, turning off the pre-parser or doing:\n\n```\nsage: Fraction(int(1), int(1))\nFraction(1, 1)\n```\n\nworks.\n\nIssue created by migration from https://trac.sagemath.org/ticket/28234\n\n",
    "created_at": "2019-07-23T08:39:12Z",
    "labels": [
        "basic arithmetic",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Sage Integers are incompatible with Python Fractions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27997",
    "user": "mcbell"
}
```
CC:  jdemeyer mcbell slelievre vdelecroix simonking @posita tscrim

Keywords: days100

In Sage 8.8 the code:

```
sage: from fractions import Fraction
sage: Fraction(1, 1)
```


raises the following error:

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-0c4690dff1ca> in <module>()
----> 1 Fraction(Integer(1), Integer(1))

/Applications/SageMath-8.6.app/Contents/Resources/sage/local/lib/python2.7/fractions.pyc in __new__(cls, numerator, denominator)
    152             isinstance(denominator, Rational)):
    153             numerator, denominator = (
--> 154                 numerator.numerator * denominator.denominator,
    155                 denominator.numerator * numerator.denominator
    156                 )

TypeError: unsupported operand type(s) for *: 'builtin_function_or_method' and 'builtin_function_or_method'
```


This appears to be because of the fact that Sage marks its integers as a numbers.rational and so Fraction expects these to provide Fraction.numerator and Fraction.denominator properties. However for Sage integers these are methods.

Note, turning off the pre-parser or doing:

```
sage: Fraction(int(1), int(1))
Fraction(1, 1)
```

works.

Issue created by migration from https://trac.sagemath.org/ticket/28234





---

archive/issue_comments_395592.json:
```json
{
    "body": "This issue also appears to affect Sage rationals where\n\n```\nsage: from fractions import Fraction\nsage: Fraction(3/4)\nFraction(<built-in method numerator of sage.rings.rational.Rational object at 0x17d185ad0>, <built-in method denominator of sage.rings.rational.Rational object at 0x17d185ad0>)\n```\n\n\nsince 3/4 is a sage Rational, which is a numbers.Rational and so during initialisation this block is triggered:\n\n\n```\n101         if denominator is None:\n102             if isinstance(numerator, Rational):\n103                 self._numerator = numerator.numerator\n104                 self._denominator = numerator.denominator\n105                 return self\n```\n\n\nwhich sets the numerator and denominator of the fraction to be the numerator and denominator *methods* of 3/4.",
    "created_at": "2019-07-23T12:13:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395592",
    "user": "mcbell"
}
```

This issue also appears to affect Sage rationals where

```
sage: from fractions import Fraction
sage: Fraction(3/4)
Fraction(<built-in method numerator of sage.rings.rational.Rational object at 0x17d185ad0>, <built-in method denominator of sage.rings.rational.Rational object at 0x17d185ad0>)
```


since 3/4 is a sage Rational, which is a numbers.Rational and so during initialisation this block is triggered:


```
101         if denominator is None:
102             if isinstance(numerator, Rational):
103                 self._numerator = numerator.numerator
104                 self._denominator = numerator.denominator
105                 return self
```


which sets the numerator and denominator of the fraction to be the numerator and denominator *methods* of 3/4.



---

archive/issue_comments_395593.json:
```json
{
    "body": "Note: this or a similar issue was previously reported at:\n\n- [Sage Trac ticket 20861: numbers.Rational, numbers.Integer, etc. interfaces not implemented correctly](https://trac.sagemath.org/ticket/20861)\n\n- [Ask Sage question 39717: Python's Fraction Incompatibility](https://ask.sagemath.org/question/39717)",
    "created_at": "2019-07-23T12:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395593",
    "user": "slelievre"
}
```

Note: this or a similar issue was previously reported at:

- [Sage Trac ticket 20861: numbers.Rational, numbers.Integer, etc. interfaces not implemented correctly](https://trac.sagemath.org/ticket/20861)

- [Ask Sage question 39717: Python's Fraction Incompatibility](https://ask.sagemath.org/question/39717)



---

archive/issue_comments_395594.json:
```json
{
    "body": "Note that the https://docs.python.org/3/library/numbers.html says that these should be properties:\n\n\n```\nclass numbers.Rational\nSubtypes Real and adds numerator and denominator properties, which should be in lowest terms. With these, it provides a default for float().\n\nnumerator\nAbstract.\n\ndenominator\nAbstract.\n```\n\n\nSimilar is true for numbers.Integral",
    "created_at": "2019-07-23T15:39:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395594",
    "user": "mcbell"
}
```

Note that the https://docs.python.org/3/library/numbers.html says that these should be properties:


```
class numbers.Rational
Subtypes Real and adds numerator and denominator properties, which should be in lowest terms. With these, it provides a default for float().

numerator
Abstract.

denominator
Abstract.
```


Similar is true for numbers.Integral



---

archive/issue_comments_395595.json:
```json
{
    "body": "Indeed, when Sage number classes were registered into Python numbers abstract base classes (#19571),\nit was overlooked that the Python numbers abc specifies rationals should have a numerator property\nand denominator property, while in Sage they are methods that one needs to call.\n\nSome solutions discussed at Sage Days 100:\n\n- do nothing: then users must do different things for Sage numbers or Python numbers\n- change Sage, with a deprecation period and temporary fix where calling a Sage integer with no arguments returns this integer, with a warning\n- change Python",
    "created_at": "2019-07-23T15:46:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395595",
    "user": "slelievre"
}
```

Indeed, when Sage number classes were registered into Python numbers abstract base classes (#19571),
it was overlooked that the Python numbers abc specifies rationals should have a numerator property
and denominator property, while in Sage they are methods that one needs to call.

Some solutions discussed at Sage Days 100:

- do nothing: then users must do different things for Sage numbers or Python numbers
- change Sage, with a deprecation period and temporary fix where calling a Sage integer with no arguments returns this integer, with a warning
- change Python



---

archive/issue_comments_395596.json:
```json
{
    "body": "I have attached a potential patch for discussion which:\n1. Marks the numerator and denominator methods of Integer and Rational as properties using the property decorator\n2. Creates full numer and denom methods of Rational which return these properties\n3. Makes integers callable but:\n   a. Raises a TypeError (as before) if they are called with anything\n   b. Generates a sage.misc.superseded.deprecation warning referring to this ticket and returns self if they are called without any arguments.\n\nThis means that if `x = 7` then doing `x.numerator` returns `7` while doing `x.numerator()` is evaluated via `7()` which, thanks to case 3b, generates a deprecation and then returns `7`. A similar process happens if `x = 7/3`, although in this case no deprecation warning is raised when using the `x.denom()` which is provided as an alias.",
    "created_at": "2019-07-23T19:01:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395596",
    "user": "mcbell"
}
```

I have attached a potential patch for discussion which:
1. Marks the numerator and denominator methods of Integer and Rational as properties using the property decorator
2. Creates full numer and denom methods of Rational which return these properties
3. Makes integers callable but:
   a. Raises a TypeError (as before) if they are called with anything
   b. Generates a sage.misc.superseded.deprecation warning referring to this ticket and returns self if they are called without any arguments.

This means that if `x = 7` then doing `x.numerator` returns `7` while doing `x.numerator()` is evaluated via `7()` which, thanks to case 3b, generates a deprecation and then returns `7`. A similar process happens if `x = 7/3`, although in this case no deprecation warning is raised when using the `x.denom()` which is provided as an alias.



---

archive/issue_comments_395597.json:
```json
{
    "body": "Attachment [properties.patch](tarball://root/attachments/some-uuid/ticket28234/properties.patch) by mcbell created at 2019-07-23 19:01:56\n\nPatch to make numerator and denominator properties",
    "created_at": "2019-07-23T19:01:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395597",
    "user": "mcbell"
}
```

Attachment [properties.patch](tarball://root/attachments/some-uuid/ticket28234/properties.patch) by mcbell created at 2019-07-23 19:01:56

Patch to make numerator and denominator properties



---

archive/issue_comments_395598.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-23T19:49:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395598",
    "user": "vdelecroix"
}
```

New commits:



---

archive/issue_comments_395599.json:
```json
{
    "body": "a good point:\n- It indeed solves the problem and remains backward compatible\n\nSome problems:\n- It affects a *lot* of files inside the Sage source code (at least 142 present doctest error) - this is easily solvable by patching the said files. But this kind of patch bomb might overlap with ongoing work of other people.\n- There are several other objects with a `numerator/denominator` method in Sage. Having integers and rationals behaving differently than the rest of Sage would be really weird. A solution would be: just do the same for other objects. But then the patch bomb becomes even bigger...",
    "created_at": "2019-07-23T20:46:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395599",
    "user": "vdelecroix"
}
```

a good point:
- It indeed solves the problem and remains backward compatible

Some problems:
- It affects a *lot* of files inside the Sage source code (at least 142 present doctest error) - this is easily solvable by patching the said files. But this kind of patch bomb might overlap with ongoing work of other people.
- There are several other objects with a `numerator/denominator` method in Sage. Having integers and rationals behaving differently than the rest of Sage would be really weird. A solution would be: just do the same for other objects. But then the patch bomb becomes even bigger...



---

archive/issue_comments_395600.json:
```json
{
    "body": "Replying to [comment:9 vdelecroix]:\n\n> Some problems:\n> - It affects a *lot* of files inside the Sage source code (at least 142 present doctest error) - this is easily solvable by patching the said files. But this kind of patch bomb might overlap with ongoing work of other people.\n\nRegarding this, these appear to come in two flavours:\n1. The testing framework is not happy with deprecation warnings, \n2. This now makes the Sage Integer class callable and it appears that there are doctest that determine whether an object is an integer or not by testing whether it is callable!\n\nWhile 1 could be solved by just removing the warning, 2 will involve making changes to hundreds of tests.",
    "created_at": "2019-07-24T05:21:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395600",
    "user": "mcbell"
}
```

Replying to [comment:9 vdelecroix]:

> Some problems:
> - It affects a *lot* of files inside the Sage source code (at least 142 present doctest error) - this is easily solvable by patching the said files. But this kind of patch bomb might overlap with ongoing work of other people.

Regarding this, these appear to come in two flavours:
1. The testing framework is not happy with deprecation warnings, 
2. This now makes the Sage Integer class callable and it appears that there are doctest that determine whether an object is an integer or not by testing whether it is callable!

While 1 could be solved by just removing the warning, 2 will involve making changes to hundreds of tests.



---

archive/issue_comments_395601.json:
```json
{
    "body": "For an explicit example of the previous behaviour see: https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523",
    "created_at": "2019-07-24T12:00:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395601",
    "user": "mcbell"
}
```

For an explicit example of the previous behaviour see: https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523



---

archive/issue_comments_395602.json:
```json
{
    "body": "Replying to [comment:11 mcbell]:\n> For an explicit example of the previous behaviour see: https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523\n\nCool. I didn't recall that I had used callability at some point...",
    "created_at": "2019-07-24T15:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395602",
    "user": "SimonKing"
}
```

Replying to [comment:11 mcbell]:
> For an explicit example of the previous behaviour see: https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523

Cool. I didn't recall that I had used callability at some point...



---

archive/issue_comments_395603.json:
```json
{
    "body": "I'm not sure that such a hack is worth it. We could at least ask Python upstream. One could argue that Python should use special methods for this like `__numerator__`.",
    "created_at": "2019-07-24T20:17:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395603",
    "user": "jdemeyer"
}
```

I'm not sure that such a hack is worth it. We could at least ask Python upstream. One could argue that Python should use special methods for this like `__numerator__`.



---

archive/issue_comments_395604.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> I'm not sure that such a hack is worth it. We could at least ask Python upstream. One could argue that Python should use special methods for this like `__numerator__`.\n\nIt makes sense. Would you make such a proposal? Note that it affects Python but also `numpy`.",
    "created_at": "2019-07-24T20:23:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395604",
    "user": "vdelecroix"
}
```

Replying to [comment:14 jdemeyer]:
> I'm not sure that such a hack is worth it. We could at least ask Python upstream. One could argue that Python should use special methods for this like `__numerator__`.

It makes sense. Would you make such a proposal? Note that it affects Python but also `numpy`.



---

archive/issue_comments_395605.json:
```json
{
    "body": "Another suggestion that could be considered, is to make numerator and denominator properties throughout Sage. Obviously such a change would not be backward compatible. Therefore it may have a major impact on external code that others have written - which must be taken into consideration. \n\nHowever, within /src/sage/:\n1. There are only only 22 instances of \"def numerator(\" and 36 instances of \"def denominator(\"\n2. In both cases, one is a function and the remainder are methods of classes. Of the latter, all-bar-two are properties (that is, their only argument is self)\n3. There are 482 uses of .numerator() and 650 uses of .denominator()\n4. Of these 31 and 31 are calls of the non-properties methods.\n\nThis suggest that 52 of these methods could have the `@`property decorators added relatively simply, and 4 exception methods will require some thought / care*. Similarly 1070 uses of these methods could be replaced via a direct substitution and 62 uses will require some care. So it appears that the effort required to implement within the Sage source, while large, would be relatively low as the majority of the work could be done with a find-and-replace.\n\n*The exceptional methods are:\n\n```\n./src/sage/rings/continued_fraction.py:    def denominator(self, n):\n./src/sage/symbolic/expression.pyx:    def denominator(self, bint normalize=True):\n```\n\nWhile the exceptional function that does not need to be changed is:\n\n```\n./src/sage/misc/functional.py:def denominator(x):\n```\n",
    "created_at": "2019-07-24T21:18:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395605",
    "user": "mcbell"
}
```

Another suggestion that could be considered, is to make numerator and denominator properties throughout Sage. Obviously such a change would not be backward compatible. Therefore it may have a major impact on external code that others have written - which must be taken into consideration. 

However, within /src/sage/:
1. There are only only 22 instances of "def numerator(" and 36 instances of "def denominator("
2. In both cases, one is a function and the remainder are methods of classes. Of the latter, all-bar-two are properties (that is, their only argument is self)
3. There are 482 uses of .numerator() and 650 uses of .denominator()
4. Of these 31 and 31 are calls of the non-properties methods.

This suggest that 52 of these methods could have the `@`property decorators added relatively simply, and 4 exception methods will require some thought / care*. Similarly 1070 uses of these methods could be replaced via a direct substitution and 62 uses will require some care. So it appears that the effort required to implement within the Sage source, while large, would be relatively low as the majority of the work could be done with a find-and-replace.

*The exceptional methods are:

```
./src/sage/rings/continued_fraction.py:    def denominator(self, n):
./src/sage/symbolic/expression.pyx:    def denominator(self, bint normalize=True):
```

While the exceptional function that does not need to be changed is:

```
./src/sage/misc/functional.py:def denominator(x):
```




---

archive/issue_comments_395606.json:
```json
{
    "body": "So having attempted the solution I proposed in comment 16 (via a small sed script) I do not think that this option will work. This is due to some of the .numerator() calls being calls on non-sage classes. For example, in rings/number_field/number_field_ideal.py the line\n\n```\n        return ZZ(q.numerator())\n```\n\ncannot be substitute since here q is a pari object and does not have a numer method.",
    "created_at": "2019-07-25T11:59:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395606",
    "user": "mcbell"
}
```

So having attempted the solution I proposed in comment 16 (via a small sed script) I do not think that this option will work. This is due to some of the .numerator() calls being calls on non-sage classes. For example, in rings/number_field/number_field_ideal.py the line

```
        return ZZ(q.numerator())
```

cannot be substitute since here q is a pari object and does not have a numer method.



---

archive/issue_comments_395607.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-26T07:54:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395607",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_395608.json:
```json
{
    "body": "The above commits deals with the issues raised in comment 9. It does this by \n1. removing the deprecation warning - this could be added in in a later ticket and updating the relevant doctests to reflect this.\n2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`\n3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`\n\nThis now means that the doctests pass and that doing \n\n```\nsage: from fractions import Fraction\nsage: Fraction(3, 7)\nFraction(3, 7)\nsage: Fraction(3/7)\nFraction(3, 7)\n```\n\nworks.",
    "created_at": "2019-07-26T07:59:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395608",
    "user": "mcbell"
}
```

The above commits deals with the issues raised in comment 9. It does this by 
1. removing the deprecation warning - this could be added in in a later ticket and updating the relevant doctests to reflect this.
2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`
3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`

This now means that the doctests pass and that doing 

```
sage: from fractions import Fraction
sage: Fraction(3, 7)
Fraction(3, 7)
sage: Fraction(3/7)
Fraction(3, 7)
```

works.



---

archive/issue_comments_395609.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-07-26T08:12:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395609",
    "user": "mcbell"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_395610.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-26T10:35:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395610",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_395611.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-26T11:45:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395611",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_395612.json:
```json
{
    "body": "See https://discuss.python.org/t/pep-3141-numerator-instead-of-numerator/2037/4",
    "created_at": "2019-07-27T14:12:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395612",
    "user": "jdemeyer"
}
```

See https://discuss.python.org/t/pep-3141-numerator-instead-of-numerator/2037/4



---

archive/issue_comments_395613.json:
```json
{
    "body": "Discussion on Sage-devel here: https://groups.google.com/forum/#!topic/sage-devel/3qgud0cdh-U",
    "created_at": "2019-07-27T16:51:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395613",
    "user": "mcbell"
}
```

Discussion on Sage-devel here: https://groups.google.com/forum/#!topic/sage-devel/3qgud0cdh-U



---

archive/issue_comments_395614.json:
```json
{
    "body": "To the OP: why do you care about Python fractions? It's a serious question since Guido van Rossum seems quite negative about them (see the link at [comment:23]).",
    "created_at": "2019-08-02T17:01:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395614",
    "user": "jdemeyer"
}
```

To the OP: why do you care about Python fractions? It's a serious question since Guido van Rossum seems quite negative about them (see the link at [comment:23]).



---

archive/issue_comments_395615.json:
```json
{
    "body": "Replying to [comment:19 mcbell]:\n>   2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`\n\nThis is independent of the issue at hand and should be done in a separate ticket.",
    "created_at": "2019-08-02T17:02:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395615",
    "user": "jdemeyer"
}
```

Replying to [comment:19 mcbell]:
>   2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`

This is independent of the issue at hand and should be done in a separate ticket.



---

archive/issue_comments_395616.json:
```json
{
    "body": "Replying to [comment:15 vdelecroix]:\n> Note that it affects Python but also `numpy`.\n\nPlease elaborate. Does numpy have fractions? I couldn't find anything like that.",
    "created_at": "2019-08-02T17:03:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395616",
    "user": "jdemeyer"
}
```

Replying to [comment:15 vdelecroix]:
> Note that it affects Python but also `numpy`.

Please elaborate. Does numpy have fractions? I couldn't find anything like that.



---

archive/issue_comments_395617.json:
```json
{
    "body": "Replying to [comment:27 jdemeyer]:\n> Replying to [comment:15 vdelecroix]:\n> > Note that it affects Python but also `numpy`.\n> \n> Please elaborate. Does numpy have fractions? I couldn't find anything like that.\n\nI meant that they are complient with the numbers abc protocol\n\n```\n>>> import numpy as np\n>>> np.int16(123).numerator\n123\n>>> np.int16(123).denominator\n1\n```\n",
    "created_at": "2019-08-02T18:48:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395617",
    "user": "vdelecroix"
}
```

Replying to [comment:27 jdemeyer]:
> Replying to [comment:15 vdelecroix]:
> > Note that it affects Python but also `numpy`.
> 
> Please elaborate. Does numpy have fractions? I couldn't find anything like that.

I meant that they are complient with the numbers abc protocol

```
>>> import numpy as np
>>> np.int16(123).numerator
123
>>> np.int16(123).denominator
1
```




---

archive/issue_comments_395618.json:
```json
{
    "body": "Replying to [comment:19 mcbell]:\n>   3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`\n\nI really don't like this change because it's an ugly hack and it may be bad for performance (since `numbers.Integral` is an abstract base class that arbitrary classes can register for, this is quite slow). Are those changes really needed?",
    "created_at": "2019-08-02T20:04:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395618",
    "user": "jdemeyer"
}
```

Replying to [comment:19 mcbell]:
>   3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`

I really don't like this change because it's an ugly hack and it may be bad for performance (since `numbers.Integral` is an abstract base class that arbitrary classes can register for, this is quite slow). Are those changes really needed?



---

archive/issue_comments_395619.json:
```json
{
    "body": "This is silly:\n\n```\n    def __call__(self, *args, **kwargs):\n        if args or kwargs:\n            raise TypeError(\"'{}.{}' object is not callable\".format(self.__class__.__module__, self.__class__.__name__))\n```\n\nIf you don't want to support `*args` or `**kwargs`, just write\n\n```\n    def __call__(self):\n        return self\n```\n\nwhich is more efficient.\n\nI also disagree with\n\n```\n        # If in the future we decide to deprecate this functionality then we can add:\n        #   deprecation(28234, 'callable integers are only intended as a tempory patch until .numerator and .denominator properties are used everywhere')\n        # This will require updating a large number of doctests to reflect this warning so we leave this for a future ticket.\n```\n\nI would rather keep the method as normal usage instead of deprecating it.",
    "created_at": "2019-08-02T20:09:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395619",
    "user": "jdemeyer"
}
```

This is silly:

```
    def __call__(self, *args, **kwargs):
        if args or kwargs:
            raise TypeError("'{}.{}' object is not callable".format(self.__class__.__module__, self.__class__.__name__))
```

If you don't want to support `*args` or `**kwargs`, just write

```
    def __call__(self):
        return self
```

which is more efficient.

I also disagree with

```
        # If in the future we decide to deprecate this functionality then we can add:
        #   deprecation(28234, 'callable integers are only intended as a tempory patch until .numerator and .denominator properties are used everywhere')
        # This will require updating a large number of doctests to reflect this warning so we leave this for a future ticket.
```

I would rather keep the method as normal usage instead of deprecating it.



---

archive/issue_comments_395620.json:
```json
{
    "body": "For the record, I'm not saying yet that I agree with this ticket. I'm just giving comments in case that we decide to go with this approach.\n\nI certainly want to wait a bit to see where the Python discussion goes. It would help to have a convincing use case, instead of \"I want to use `fractions.Fraction` in Sage just because\".",
    "created_at": "2019-08-02T20:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395620",
    "user": "jdemeyer"
}
```

For the record, I'm not saying yet that I agree with this ticket. I'm just giving comments in case that we decide to go with this approach.

I certainly want to wait a bit to see where the Python discussion goes. It would help to have a convincing use case, instead of "I want to use `fractions.Fraction` in Sage just because".



---

archive/issue_comments_395621.json:
```json
{
    "body": "Replying to [comment:29 jdemeyer]:\n> Replying to [comment:19 mcbell]:\n> >   3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`\n> \n> I really don't like this change because it's an ugly hack and it may be bad for performance (since `numbers.Integral` is an abstract base class that arbitrary classes can register for, this is quite slow). Are those changes really needed?\n\nI agree that this is ugly and that it may impact performance. However it is necessary in at least some (in fact I believe a large percentage) of the `callable(x)` cases (for example, see \u200bhttps://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523). Without these the route through the code changes and so if they are omitted then the code raises an error. The tricky thing here is that (like in the above example) the error is often raised far away from where the callable(x) occurred, making these hard to track down.\n\nIt may be possible to remove some of these uses when you explicitly know that `x` is never a Sage Integer. However I would be extremely worried about these cases since if you are wrong then it is possible that the code does not raise an error but may compute a incorrect result. Now hopefully there would be doctests that would run all of these different possibilities but this may be a situation that people aren't expecting and so I'm not sure that we can rely on the doctests to save us.\n\nTherefore I would strongly argue that these changes are needed everywhere. In fact, even in the few cases where it is completely obvious that `x` cannot be a Sage Integer, it may be better to keep these purely for consistency.",
    "created_at": "2019-08-02T22:42:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395621",
    "user": "mcbell"
}
```

Replying to [comment:29 jdemeyer]:
> Replying to [comment:19 mcbell]:
> >   3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`
> 
> I really don't like this change because it's an ugly hack and it may be bad for performance (since `numbers.Integral` is an abstract base class that arbitrary classes can register for, this is quite slow). Are those changes really needed?

I agree that this is ugly and that it may impact performance. However it is necessary in at least some (in fact I believe a large percentage) of the `callable(x)` cases (for example, see â€‹https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523). Without these the route through the code changes and so if they are omitted then the code raises an error. The tricky thing here is that (like in the above example) the error is often raised far away from where the callable(x) occurred, making these hard to track down.

It may be possible to remove some of these uses when you explicitly know that `x` is never a Sage Integer. However I would be extremely worried about these cases since if you are wrong then it is possible that the code does not raise an error but may compute a incorrect result. Now hopefully there would be doctests that would run all of these different possibilities but this may be a situation that people aren't expecting and so I'm not sure that we can rely on the doctests to save us.

Therefore I would strongly argue that these changes are needed everywhere. In fact, even in the few cases where it is completely obvious that `x` cannot be a Sage Integer, it may be better to keep these purely for consistency.



---

archive/issue_comments_395622.json:
```json
{
    "body": "Replying to [comment:30 jdemeyer]:\n> If you don't want to support `*args` or `**kwargs`, just write\n> {{{\n>     def __call__(self):\n>         return self\n> }}}\n> which is more efficient.\n\nI agree that this is a better way to go initially. Thank you for pointing this out.",
    "created_at": "2019-08-02T22:44:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395622",
    "user": "mcbell"
}
```

Replying to [comment:30 jdemeyer]:
> If you don't want to support `*args` or `**kwargs`, just write
> {{{
>     def __call__(self):
>         return self
> }}}
> which is more efficient.

I agree that this is a better way to go initially. Thank you for pointing this out.



---

archive/issue_comments_395623.json:
```json
{
    "body": "The fact that making Sage integers callable breaks stuff is bad. So we should consider the pros and cons of this approach. I'm not sufficiently convinced about the pros (as Guido van Rossum said: what real world problems would this solve?). Note that the submitter at #20861 admitted to not really caring about fractions, so for the moment my feeling goes towards rejecting this fix.",
    "created_at": "2019-08-03T21:11:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395623",
    "user": "jdemeyer"
}
```

The fact that making Sage integers callable breaks stuff is bad. So we should consider the pros and cons of this approach. I'm not sufficiently convinced about the pros (as Guido van Rossum said: what real world problems would this solve?). Note that the submitter at #20861 admitted to not really caring about fractions, so for the moment my feeling goes towards rejecting this fix.



---

archive/issue_comments_395624.json:
```json
{
    "body": "I do find it a shame, in general, that there are so many methods on classes in Sage that should really be properties.  I understand the reason (\"what if you *do* want to add some optional arguments to that property later?\").  But in that case I think there should be a separate method from the argument-less property.\n\nIt's also an unfortunate shortcoming in Python that there's know way to easily know ahead of time that when an attribute is looked up on an object, it will be subsequently *called* as in method call syntax.  So there is no opportunity to return a different type for attribute access when doing something like `a.property` versus `a.property()`.  It's fundamentally baked into Python's design that these cases can't be distinguished in some way.\n\nI've thought in the past of working around this limitation by coming up with a generic way of proxying arbitrary types in such a way as to make them callable.  So rather than making Integer callable as this ticket proposes, something like `Rational.numerator` would instead return an Integer instance wrapped in a proxy, which when called does something special with that instance, likely with reference to the original Rational that returned it (in this case the call method on the proxy would be trivial--it would just return the Integer itself).\n\nUnfortunately that's a whole other can of worms itself, especially when you want to add a callable-proxy to types that are already callable in the first place.",
    "created_at": "2019-08-07T11:28:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395624",
    "user": "embray"
}
```

I do find it a shame, in general, that there are so many methods on classes in Sage that should really be properties.  I understand the reason ("what if you *do* want to add some optional arguments to that property later?").  But in that case I think there should be a separate method from the argument-less property.

It's also an unfortunate shortcoming in Python that there's know way to easily know ahead of time that when an attribute is looked up on an object, it will be subsequently *called* as in method call syntax.  So there is no opportunity to return a different type for attribute access when doing something like `a.property` versus `a.property()`.  It's fundamentally baked into Python's design that these cases can't be distinguished in some way.

I've thought in the past of working around this limitation by coming up with a generic way of proxying arbitrary types in such a way as to make them callable.  So rather than making Integer callable as this ticket proposes, something like `Rational.numerator` would instead return an Integer instance wrapped in a proxy, which when called does something special with that instance, likely with reference to the original Rational that returned it (in this case the call method on the proxy would be trivial--it would just return the Integer itself).

Unfortunately that's a whole other can of worms itself, especially when you want to add a callable-proxy to types that are already callable in the first place.



---

archive/issue_comments_395625.json:
```json
{
    "body": "Though I did just see Jeroen's point [here](https://discuss.python.org/t/pep-3141-ratio-instead-of-numerator-denominator/2037/7) that technically one could implement specialized method call syntax.  But it's still really confusing.  For example you'd have `a.foo()` do something different from `x = a.foo; x()`.  And yes, it would be very CPython specific--but maybe that's okay, for special cases in Sage, to take advantage of?\n\nAnother super hacky workaround I've considered in the past for this (which would only work in CPython with pure Python code) would be to have a special kind of descriptor that actually looks ahead in the bytecode to see if (within some reasonable localization) the object returned by the descriptor will be called, and thus allow different behavior in that case.  Again, a hugely problematic hack, but possibly \"good enough\" for some common cases?",
    "created_at": "2019-08-07T11:38:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395625",
    "user": "embray"
}
```

Though I did just see Jeroen's point [here](https://discuss.python.org/t/pep-3141-ratio-instead-of-numerator-denominator/2037/7) that technically one could implement specialized method call syntax.  But it's still really confusing.  For example you'd have `a.foo()` do something different from `x = a.foo; x()`.  And yes, it would be very CPython specific--but maybe that's okay, for special cases in Sage, to take advantage of?

Another super hacky workaround I've considered in the past for this (which would only work in CPython with pure Python code) would be to have a special kind of descriptor that actually looks ahead in the bytecode to see if (within some reasonable localization) the object returned by the descriptor will be called, and thus allow different behavior in that case.  Again, a hugely problematic hack, but possibly "good enough" for some common cases?



---

archive/issue_comments_395626.json:
```json
{
    "body": "Replying to [comment:36 embray]:\n> Though I did just see Jeroen's point [here](https://discuss.python.org/t/pep-3141-ratio-instead-of-numerator-denominator/2037/7) that technically one could implement specialized method call syntax.  But it's still really confusing.  For example you'd have `a.foo()` do something different from `x = a.foo; x()`.\n\nTo expand on this, this is part of the work on [PEP 590](https://www.python.org/dev/peps/pep-0590/). Note the different bytecode generated:\n\n```\n>>> from dis import dis\n>>> def f(obj):\n...     return obj.meth()\n>>> def g(obj):\n...     x = obj.meth\n...     return x()\n>>> dis(f)\n  2           0 LOAD_FAST                0 (obj)\n              2 LOAD_METHOD              0 (meth)\n              4 CALL_METHOD              0\n              6 RETURN_VALUE                                                                                                                                            \n>>> dis(g)                                                                                                                                                             \n  2           0 LOAD_FAST                0 (obj)                                                                                                                        \n              2 LOAD_ATTR                0 (meth)                                                                                                                       \n              4 STORE_FAST               1 (x)\n\n  3           6 LOAD_FAST                1 (x)\n              8 CALL_FUNCTION            0\n             10 RETURN_VALUE\n```\n\n`LOAD_METHOD` and `CALL_METHOD` are an optimization to avoid creating a temporary bound method object when executing `obj.meth()`. It basically turns the call into a call of the *unbound* method. This optimization used to be enabled only for two specific method classes (one for Python methods and one for C methods). But PEP 590 allows this optimization for arbitrary classes. In theory, it should just be an optimization not affecting the actual behaviour. But it does allow doing arbitrary hacky stuff when `LOAD_METHOD`/`CALL_METHOD` is used.\n\n> And yes, it would be very CPython specific--but maybe that's okay, for special cases in Sage, to take advantage of?\n\nWe need to make sure that Cython supports it too. Since PEP 590 is so new, it's not in the current stable release. But the big upcoming Cython 3.0 should at least partially support it.",
    "created_at": "2019-08-07T12:33:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395626",
    "user": "jdemeyer"
}
```

Replying to [comment:36 embray]:
> Though I did just see Jeroen's point [here](https://discuss.python.org/t/pep-3141-ratio-instead-of-numerator-denominator/2037/7) that technically one could implement specialized method call syntax.  But it's still really confusing.  For example you'd have `a.foo()` do something different from `x = a.foo; x()`.

To expand on this, this is part of the work on [PEP 590](https://www.python.org/dev/peps/pep-0590/). Note the different bytecode generated:

```
>>> from dis import dis
>>> def f(obj):
...     return obj.meth()
>>> def g(obj):
...     x = obj.meth
...     return x()
>>> dis(f)
  2           0 LOAD_FAST                0 (obj)
              2 LOAD_METHOD              0 (meth)
              4 CALL_METHOD              0
              6 RETURN_VALUE                                                                                                                                            
>>> dis(g)                                                                                                                                                             
  2           0 LOAD_FAST                0 (obj)                                                                                                                        
              2 LOAD_ATTR                0 (meth)                                                                                                                       
              4 STORE_FAST               1 (x)

  3           6 LOAD_FAST                1 (x)
              8 CALL_FUNCTION            0
             10 RETURN_VALUE
```

`LOAD_METHOD` and `CALL_METHOD` are an optimization to avoid creating a temporary bound method object when executing `obj.meth()`. It basically turns the call into a call of the *unbound* method. This optimization used to be enabled only for two specific method classes (one for Python methods and one for C methods). But PEP 590 allows this optimization for arbitrary classes. In theory, it should just be an optimization not affecting the actual behaviour. But it does allow doing arbitrary hacky stuff when `LOAD_METHOD`/`CALL_METHOD` is used.

> And yes, it would be very CPython specific--but maybe that's okay, for special cases in Sage, to take advantage of?

We need to make sure that Cython supports it too. Since PEP 590 is so new, it's not in the current stable release. But the big upcoming Cython 3.0 should at least partially support it.



---

archive/issue_comments_395627.json:
```json
{
    "body": "I forgot to mention that PEP 590 needs Python 3.8, for which there is no stable release yet.",
    "created_at": "2019-08-07T12:35:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395627",
    "user": "jdemeyer"
}
```

I forgot to mention that PEP 590 needs Python 3.8, for which there is no stable release yet.



---

archive/issue_comments_395628.json:
```json
{
    "body": "How does it know to generate special bytecode in this case?  Is it just hacked into the parser somehow?\n\nPart of me really does think there should be a way to exploit direct method calls as a special case, even though it would be a slightly confusing inconsistency.",
    "created_at": "2019-08-07T13:38:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395628",
    "user": "embray"
}
```

How does it know to generate special bytecode in this case?  Is it just hacked into the parser somehow?

Part of me really does think there should be a way to exploit direct method calls as a special case, even though it would be a slightly confusing inconsistency.



---

archive/issue_comments_395629.json:
```json
{
    "body": "Replying to [comment:34 jdemeyer]:\n> as Guido van Rossum said: what real world problems would this solve?\n\nSome mathematical packages for dynamics, geometry and topology of\nsurfaces and 3-manifolds, such as Curver, Flipper, SnapPy, Twister,\nVeerer, can be run either with pure Python, or with Sage. Some of\nthem use the `Fraction` constructor from Python's `fractions` module,\nwhich works with Python ints or rationals and fails with Sage\nintegers or rationals. That's the real-world problem.",
    "created_at": "2019-08-08T02:41:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395629",
    "user": "slelievre"
}
```

Replying to [comment:34 jdemeyer]:
> as Guido van Rossum said: what real world problems would this solve?

Some mathematical packages for dynamics, geometry and topology of
surfaces and 3-manifolds, such as Curver, Flipper, SnapPy, Twister,
Veerer, can be run either with pure Python, or with Sage. Some of
them use the `Fraction` constructor from Python's `fractions` module,
which works with Python ints or rationals and fails with Sage
integers or rationals. That's the real-world problem.



---

archive/issue_comments_395630.json:
```json
{
    "body": "Replying to [comment:39 embray]:\n> Is it just hacked into the parser somehow?\n\nYes. When the parser sees something of the form `obj.attr()`, it uses those special bytecodes. Further details in https://bugs.python.org/issue26110",
    "created_at": "2019-08-08T08:46:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395630",
    "user": "jdemeyer"
}
```

Replying to [comment:39 embray]:
> Is it just hacked into the parser somehow?

Yes. When the parser sees something of the form `obj.attr()`, it uses those special bytecodes. Further details in https://bugs.python.org/issue26110



---

archive/issue_comments_395631.json:
```json
{
    "body": "Replying to [comment:40 slelievre]:\n> Some mathematical packages for dynamics, geometry and topology of\n> surfaces and 3-manifolds, such as Curver, Flipper, SnapPy, Twister,\n> Veerer, can be run either with pure Python, or with Sage. Some of\n> them use the `Fraction` constructor from Python's `fractions` module\n\nOK, I quickly looked at these packages. First of all, I couldn't find a package called \"Veerer\".\n\nTwo don't use fractions:\n\n- [flipper](https://github.com/MarkCBell/flipper)\n- [twister](https://bitbucket.org/Mark_Bell/twister/src/default/)\n\nTwo do use fractions:\n\n- [curver](https://github.com/MarkCBell/curver)\n- [snappy](https://pypi.org/project/snappy/2.7)\n\nHowever, it's not obvious to me how Sage integers or rationals could end up as an argument to `Fraction` in these packages. curver doesn't use Sage at all. snappy does use Sage (for example, for Gr\u00f6bner basis computations), but it seems that output from Sage is converted to snappy data structures, so it doesn't really do computations with Sage data types.",
    "created_at": "2019-08-08T09:36:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395631",
    "user": "jdemeyer"
}
```

Replying to [comment:40 slelievre]:
> Some mathematical packages for dynamics, geometry and topology of
> surfaces and 3-manifolds, such as Curver, Flipper, SnapPy, Twister,
> Veerer, can be run either with pure Python, or with Sage. Some of
> them use the `Fraction` constructor from Python's `fractions` module

OK, I quickly looked at these packages. First of all, I couldn't find a package called "Veerer".

Two don't use fractions:

- [flipper](https://github.com/MarkCBell/flipper)
- [twister](https://bitbucket.org/Mark_Bell/twister/src/default/)

Two do use fractions:

- [curver](https://github.com/MarkCBell/curver)
- [snappy](https://pypi.org/project/snappy/2.7)

However, it's not obvious to me how Sage integers or rationals could end up as an argument to `Fraction` in these packages. curver doesn't use Sage at all. snappy does use Sage (for example, for GrÃ¶bner basis computations), but it seems that output from Sage is converted to snappy data structures, so it doesn't really do computations with Sage data types.



---

archive/issue_comments_395632.json:
```json
{
    "body": "`flipper` does indirectly uses `Fraction` through [realalg](https://github.com/MarkCBell/realalg). And it is easy to break\n\n```\nsage: import realalg\nsage: realalg.RealNumberField([1,0,-2])\nTraceback (most recent call last):\n...\nTypeError: invalid input: <built-in method numerator of sage.rings.integer.Integer object at 0x7fca4682fd20>\n```\n\n\nI thought about providing support for sage `Rational` in `realalg`... but it is a can of worms.",
    "created_at": "2019-08-08T09:44:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395632",
    "user": "vdelecroix"
}
```

`flipper` does indirectly uses `Fraction` through [realalg](https://github.com/MarkCBell/realalg). And it is easy to break

```
sage: import realalg
sage: realalg.RealNumberField([1,0,-2])
Traceback (most recent call last):
...
TypeError: invalid input: <built-in method numerator of sage.rings.integer.Integer object at 0x7fca4682fd20>
```


I thought about providing support for sage `Rational` in `realalg`... but it is a can of worms.



---

archive/issue_comments_395633.json:
```json
{
    "body": "Replying to [comment:43 vdelecroix]:\n> but it is a can of worms.\n\nA can of worms is precisely what we're looking for here. Guido claims that there is no problem, so we some data to prove him wrong.",
    "created_at": "2019-08-08T10:07:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395633",
    "user": "jdemeyer"
}
```

Replying to [comment:43 vdelecroix]:
> but it is a can of worms.

A can of worms is precisely what we're looking for here. Guido claims that there is no problem, so we some data to prove him wrong.



---

archive/issue_comments_395634.json:
```json
{
    "body": "Replying to [comment:44 jdemeyer]:\n> Replying to [comment:43 vdelecroix]:\n> > but it is a can of worms.\n> \n> A can of worms is precisely what we're looking for here. Guido claims that there is no problem, so we some data to prove him wrong.\n\nAgreed.\n\nAs we make the PEP idea better, we should also think about making `Rational` an easy drop-in replacement for `Fraction`. In other words, the following kind of thing should work\n\n```\ntry:\n    from sage.rings.rational import Rational as Fraction\nexcept ImportError:\n    try:\n        from gmpy2 import mpq as Fraction\n    except ImportError:\n        from fractions import Fraction\n```\n\nI see a serious obstruction for now: the constructors are not compatible.\n\n```\nsage: from fractions import Fraction\nsage: from gmpy2 import mpq\nsage: Fraction(2r, 3r)\nFraction(2, 3)\nsage: mpq(2,3)\nmpq(2,3)\nsage: Rational(2,3)   # second argument is \"base\"\n2\n```\n",
    "created_at": "2019-08-08T10:21:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395634",
    "user": "vdelecroix"
}
```

Replying to [comment:44 jdemeyer]:
> Replying to [comment:43 vdelecroix]:
> > but it is a can of worms.
> 
> A can of worms is precisely what we're looking for here. Guido claims that there is no problem, so we some data to prove him wrong.

Agreed.

As we make the PEP idea better, we should also think about making `Rational` an easy drop-in replacement for `Fraction`. In other words, the following kind of thing should work

```
try:
    from sage.rings.rational import Rational as Fraction
except ImportError:
    try:
        from gmpy2 import mpq as Fraction
    except ImportError:
        from fractions import Fraction
```

I see a serious obstruction for now: the constructors are not compatible.

```
sage: from fractions import Fraction
sage: from gmpy2 import mpq
sage: Fraction(2r, 3r)
Fraction(2, 3)
sage: mpq(2,3)
mpq(2,3)
sage: Rational(2,3)   # second argument is "base"
2
```




---

archive/issue_comments_395635.json:
```json
{
    "body": "Replying to [comment:42 jdemeyer]:\n> Two do use fractions:\n> \n> - [curver](https://github.com/MarkCBell/curver)\n> - [snappy](https://pypi.org/project/snappy/2.7)\n> \n> However, it's not obvious to me how Sage integers or rationals could end up as an argument to `Fraction` in these packages. curver doesn't use Sage at all.\n\nSage Integers can end up in Fractions whenever a user uses these packages interactively or from within a sage script / notebook. For example:\n\n\n```\nsage: import curver\nsage: curver.load(2, 1).triangulation([0, 99, 99, 1, 100, 0, 0, 0, 0])\n```\n\n\ncrashes since the values that are passed to the functions within curver are sage Integers. This happens even though curver has scattered throughout it lines (equivalent to):\n\n```\n    assert isinstance(n, numbers.Integral)\n```\n\nbut since Sage Integers have been registered as Integral these catches do not work.\n\nOf course, doing\n\n```\nsage: curver.load(2, 1).triangulation([0r, 99r, 99r, 1r, 100r, 0r, 0r, 0r, 0r])\n```\n\nworks without an issue.",
    "created_at": "2019-08-10T09:00:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395635",
    "user": "mcbell"
}
```

Replying to [comment:42 jdemeyer]:
> Two do use fractions:
> 
> - [curver](https://github.com/MarkCBell/curver)
> - [snappy](https://pypi.org/project/snappy/2.7)
> 
> However, it's not obvious to me how Sage integers or rationals could end up as an argument to `Fraction` in these packages. curver doesn't use Sage at all.

Sage Integers can end up in Fractions whenever a user uses these packages interactively or from within a sage script / notebook. For example:


```
sage: import curver
sage: curver.load(2, 1).triangulation([0, 99, 99, 1, 100, 0, 0, 0, 0])
```


crashes since the values that are passed to the functions within curver are sage Integers. This happens even though curver has scattered throughout it lines (equivalent to):

```
    assert isinstance(n, numbers.Integral)
```

but since Sage Integers have been registered as Integral these catches do not work.

Of course, doing

```
sage: curver.load(2, 1).triangulation([0r, 99r, 99r, 1r, 100r, 0r, 0r, 0r, 0r])
```

works without an issue.



---

archive/issue_comments_395636.json:
```json
{
    "body": "Personally, I am more worried about code that does incorrect / dangerous things when it encounters. For example, I could imagine something like:\n\n\n```\ndef prod_numerator_denominator(x):\n    ''' Since x = p / q (where q is possibly 1), return p * q. '''\n    try:\n        # If x is Rational then this will work.\n        return x.numerator * x.denominator\n    except:\n        # x was not a Rational, so we can take q == 1 and just return x\n        return x\n\nassert prod_numerator_denominator(Fraction(3r, 2r)) == 6\nassert prod_numerator_denominator(3) == 3\nassert prod_numerator_denominator(3 / 2) == 6  # Fails since prod_numerator_denominator(3 / 2) returns 3\n }}}\n\nOr even\n\n{{{\ndef f(x):\n    if not isinstance(x, numbers.Rational):\n        return NotImplemented\n\n    # So now I know x is a Rational and so implements .numerator and .denominator properties\n    try:\n        return x.numerator + x.denominator\n    except:\n        # I know the code here can never be run so I can it should be safe to put something bad here\n        import os\n        os.remove('/')\n}}}",
    "created_at": "2019-08-10T09:26:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395636",
    "user": "mcbell"
}
```

Personally, I am more worried about code that does incorrect / dangerous things when it encounters. For example, I could imagine something like:


```
def prod_numerator_denominator(x):
    ''' Since x = p / q (where q is possibly 1), return p * q. '''
    try:
        # If x is Rational then this will work.
        return x.numerator * x.denominator
    except:
        # x was not a Rational, so we can take q == 1 and just return x
        return x

assert prod_numerator_denominator(Fraction(3r, 2r)) == 6
assert prod_numerator_denominator(3) == 3
assert prod_numerator_denominator(3 / 2) == 6  # Fails since prod_numerator_denominator(3 / 2) returns 3
 }}}

Or even

{{{
def f(x):
    if not isinstance(x, numbers.Rational):
        return NotImplemented

    # So now I know x is a Rational and so implements .numerator and .denominator properties
    try:
        return x.numerator + x.denominator
    except:
        # I know the code here can never be run so I can it should be safe to put something bad here
        import os
        os.remove('/')
}}}



---

archive/issue_comments_395637.json:
```json
{
    "body": "To me an obvious answer here is for Sage `Rational`s and `Integer`s to just get some kind of `.as_pyfraction()` method to convert them to a `Fraction`.\n\nIt's not ideal of course. One would really prefer to see it just work, transparently. But when interfaces collide the only recourse, if you can't easily change the interfaces, is to make some kind of adapter.\n\nI liked Jeroen's `__ratio__` proposal and thought it made a lot of sense. But it seems it wasn't too popular. And even if it did happen one day we'd have to wait for the change in Python (or monkey-patch the `fractions` module which I suppose is another possibility...)",
    "created_at": "2019-08-12T08:59:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395637",
    "user": "embray"
}
```

To me an obvious answer here is for Sage `Rational`s and `Integer`s to just get some kind of `.as_pyfraction()` method to convert them to a `Fraction`.

It's not ideal of course. One would really prefer to see it just work, transparently. But when interfaces collide the only recourse, if you can't easily change the interfaces, is to make some kind of adapter.

I liked Jeroen's `__ratio__` proposal and thought it made a lot of sense. But it seems it wasn't too popular. And even if it did happen one day we'd have to wait for the change in Python (or monkey-patch the `fractions` module which I suppose is another possibility...)



---

archive/issue_comments_395638.json:
```json
{
    "body": "I often wished there was `a.num_denom()` to get\n`a.numerator()` and `a.denominator()` at once,\nthe same way `a.quo_rem(b)` gives the quotient\n`a // b` and the remainder `a % b` at once.",
    "created_at": "2019-08-13T10:32:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395638",
    "user": "slelievre"
}
```

I often wished there was `a.num_denom()` to get
`a.numerator()` and `a.denominator()` at once,
the same way `a.quo_rem(b)` gives the quotient
`a // b` and the remainder `a % b` at once.



---

archive/issue_comments_395639.json:
```json
{
    "body": "Replying to [comment:49 slelievre]:\n> I often wished there was `a.num_denom()`\n\nIt's called `.as_integer_ratio()` and it will be supported in Python 3.8 for all standard numeric types (`int`, `float`, `decimal.Decimal` and `fractions.Fraction`). Clearly, this is something that Sage types should also have.\n\nThis doesn't yet solve the problem that this ticket wants to solve, but it's getting closer.",
    "created_at": "2019-08-13T10:40:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395639",
    "user": "jdemeyer"
}
```

Replying to [comment:49 slelievre]:
> I often wished there was `a.num_denom()`

It's called `.as_integer_ratio()` and it will be supported in Python 3.8 for all standard numeric types (`int`, `float`, `decimal.Decimal` and `fractions.Fraction`). Clearly, this is something that Sage types should also have.

This doesn't yet solve the problem that this ticket wants to solve, but it's getting closer.



---

archive/issue_comments_395640.json:
```json
{
    "body": "Okay, I opened #28348 for that.",
    "created_at": "2019-08-13T10:48:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395640",
    "user": "slelievre"
}
```

Okay, I opened #28348 for that.



---

archive/issue_comments_395641.json:
```json
{
    "body": "I opened #28347 for that, needs review.",
    "created_at": "2019-08-13T12:28:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395641",
    "user": "jdemeyer"
}
```

I opened #28347 for that, needs review.



---

archive/issue_comments_395642.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395642",
    "user": "embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_395643.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395643",
    "user": "mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_395644.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-08-15T22:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395644",
    "user": "mkoeppe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_395645.json:
```json
{
    "body": "merge conflict",
    "created_at": "2020-08-15T22:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395645",
    "user": "mkoeppe"
}
```

merge conflict



---

archive/issue_comments_395646.json:
```json
{
    "body": "Any interest in continuing to work on this?  I've just been bitten by this issue in my own code.",
    "created_at": "2021-01-21T13:54:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395646",
    "user": "embray"
}
```

Any interest in continuing to work on this?  I've just been bitten by this issue in my own code.



---

archive/issue_comments_395647.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395647",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_395648.json:
```json
{
    "body": "This issue was already reported\nin [#10928, comment 14](https://trac.sagemath.org/ticket/10928#comment:14) (a ticket about getitem of numpy matrix using Sage integers).\n\nHopefully with #28347 in, things are easier than back at Sage Days 100?",
    "created_at": "2021-03-25T01:10:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395648",
    "user": "slelievre"
}
```

This issue was already reported
in [#10928, comment 14](https://trac.sagemath.org/ticket/10928#comment:14) (a ticket about getitem of numpy matrix using Sage integers).

Hopefully with #28347 in, things are easier than back at Sage Days 100?



---

archive/issue_comments_395649.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395649",
    "user": "mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_comments_395650.json:
```json
{
    "body": "This issue also shows up when trying to use the `statistics` module with Sage integers or rationals, see #29662.\n\nAlthough the `as_integer_ratio` mechanism has been added to Python, [statistics._exact_ratio](https://github.com/python/cpython/blob/main/Lib/statistics.py#L246) does not use `as_integer_ratio` because it sees the Sage numbers' `numerator` and `denominator` methods and tries to use them as properties.",
    "created_at": "2021-08-27T01:47:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395650",
    "user": "mkoeppe"
}
```

This issue also shows up when trying to use the `statistics` module with Sage integers or rationals, see #29662.

Although the `as_integer_ratio` mechanism has been added to Python, [statistics._exact_ratio](https://github.com/python/cpython/blob/main/Lib/statistics.py#L246) does not use `as_integer_ratio` because it sees the Sage numbers' `numerator` and `denominator` methods and tries to use them as properties.



---

archive/issue_comments_395651.json:
```json
{
    "body": "Replying to [comment:26 jdemeyer]:\n> Replying to [comment:19 mcbell]:\n> >   2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`\n> \n> This is independent of the issue at hand and should be done in a separate ticket.\n\nDone in #33451.",
    "created_at": "2022-03-02T18:58:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27997",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27997#issuecomment-395651",
    "user": "jhpalmieri"
}
```

Replying to [comment:26 jdemeyer]:
> Replying to [comment:19 mcbell]:
> >   2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`
> 
> This is independent of the issue at hand and should be done in a separate ticket.

Done in #33451.
