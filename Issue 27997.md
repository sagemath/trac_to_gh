# Issue 27997: Sage Integers are incompatible with Python Fractions

Issue created by migration from https://trac.sagemath.org/ticket/28234

Original creator: mcbell

Original creation time: 2019-07-23 08:39:12

CC:  jdemeyer mcbell slelievre vdelecroix simonking @posita tscrim

Keywords: days100

In Sage 8.8 the code:

```
sage: from fractions import Fraction
sage: Fraction(1, 1)
```


raises the following error:

```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-0c4690dff1ca> in <module>()
----> 1 Fraction(Integer(1), Integer(1))

/Applications/SageMath-8.6.app/Contents/Resources/sage/local/lib/python2.7/fractions.pyc in __new__(cls, numerator, denominator)
    152             isinstance(denominator, Rational)):
    153             numerator, denominator = (
--> 154                 numerator.numerator * denominator.denominator,
    155                 denominator.numerator * numerator.denominator
    156                 )

TypeError: unsupported operand type(s) for *: 'builtin_function_or_method' and 'builtin_function_or_method'
```


This appears to be because of the fact that Sage marks its integers as a numbers.rational and so Fraction expects these to provide Fraction.numerator and Fraction.denominator properties. However for Sage integers these are methods.

Note, turning off the pre-parser or doing:

```
sage: Fraction(int(1), int(1))
Fraction(1, 1)
```

works.


---

Comment by mcbell created at 2019-07-23 12:13:50

This issue also appears to affect Sage rationals where

```
sage: from fractions import Fraction
sage: Fraction(3/4)
Fraction(<built-in method numerator of sage.rings.rational.Rational object at 0x17d185ad0>, <built-in method denominator of sage.rings.rational.Rational object at 0x17d185ad0>)
```


since 3/4 is a sage Rational, which is a numbers.Rational and so during initialisation this block is triggered:


```
101         if denominator is None:
102             if isinstance(numerator, Rational):
103                 self._numerator = numerator.numerator
104                 self._denominator = numerator.denominator
105                 return self
```


which sets the numerator and denominator of the fraction to be the numerator and denominator _methods_ of 3/4.


---

Comment by slelievre created at 2019-07-23 12:24:43

Note: this or a similar issue was previously reported at:

- [Sage Trac ticket 20861: numbers.Rational, numbers.Integer, etc. interfaces not implemented correctly](https://trac.sagemath.org/ticket/20861)

- [Ask Sage question 39717: Python's Fraction Incompatibility](https://ask.sagemath.org/question/39717)


---

Comment by mcbell created at 2019-07-23 15:39:02

Note that the https://docs.python.org/3/library/numbers.html says that these should be properties:


```
class numbers.Rational
Subtypes Real and adds numerator and denominator properties, which should be in lowest terms. With these, it provides a default for float().

numerator
Abstract.

denominator
Abstract.
```


Similar is true for numbers.Integral


---

Comment by slelievre created at 2019-07-23 15:46:46

Indeed, when Sage number classes were registered into Python numbers abstract base classes (#19571),
it was overlooked that the Python numbers abc specifies rationals should have a numerator property
and denominator property, while in Sage they are methods that one needs to call.

Some solutions discussed at Sage Days 100:

- do nothing: then users must do different things for Sage numbers or Python numbers
- change Sage, with a deprecation period and temporary fix where calling a Sage integer with no arguments returns this integer, with a warning
- change Python


---

Comment by mcbell created at 2019-07-23 19:01:11

I have attached a potential patch for discussion which:
  1. Marks the numerator and denominator methods of Integer and Rational as properties using the property decorator
  2. Creates full numer and denom methods of Rational which return these properties
  3. Makes integers callable but:
    a. Raises a TypeError (as before) if they are called with anything
    b. Generates a sage.misc.superseded.deprecation warning referring to this ticket and returns self if they are called without any arguments.

This means that if `x = 7` then doing `x.numerator` returns `7` while doing `x.numerator()` is evaluated via `7()` which, thanks to case 3b, generates a deprecation and then returns `7`. A similar process happens if `x = 7/3`, although in this case no deprecation warning is raised when using the `x.denom()` which is provided as an alias.


---

Attachment

Patch to make numerator and denominator properties


---

Comment by vdelecroix created at 2019-07-23 19:49:18

New commits:


---

Comment by vdelecroix created at 2019-07-23 20:46:18

a good point:
- It indeed solves the problem and remains backward compatible

Some problems:
- It affects a *lot* of files inside the Sage source code (at least 142 present doctest error) - this is easily solvable by patching the said files. But this kind of patch bomb might overlap with ongoing work of other people.
- There are several other objects with a `numerator/denominator` method in Sage. Having integers and rationals behaving differently than the rest of Sage would be really weird. A solution would be: just do the same for other objects. But then the patch bomb becomes even bigger...


---

Comment by mcbell created at 2019-07-24 05:21:44

Replying to [comment:9 vdelecroix]:

> Some problems:
> - It affects a *lot* of files inside the Sage source code (at least 142 present doctest error) - this is easily solvable by patching the said files. But this kind of patch bomb might overlap with ongoing work of other people.

Regarding this, these appear to come in two flavours:
  1. The testing framework is not happy with deprecation warnings, 
  2. This now makes the Sage Integer class callable and it appears that there are doctest that determine whether an object is an integer or not by testing whether it is callable!

While 1 could be solved by just removing the warning, 2 will involve making changes to hundreds of tests.


---

Comment by mcbell created at 2019-07-24 12:00:08

For an explicit example of the previous behaviour see: https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523


---

Comment by SimonKing created at 2019-07-24 15:15:58

Replying to [comment:11 mcbell]:
> For an explicit example of the previous behaviour see: https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523

Cool. I didn't recall that I had used callability at some point...


---

Comment by jdemeyer created at 2019-07-24 20:17:46

I'm not sure that such a hack is worth it. We could at least ask Python upstream. One could argue that Python should use special methods for this like `__numerator__`.


---

Comment by vdelecroix created at 2019-07-24 20:23:06

Replying to [comment:14 jdemeyer]:
> I'm not sure that such a hack is worth it. We could at least ask Python upstream. One could argue that Python should use special methods for this like `__numerator__`.

It makes sense. Would you make such a proposal? Note that it affects Python but also `numpy`.


---

Comment by mcbell created at 2019-07-24 21:18:48

Another suggestion that could be considered, is to make numerator and denominator properties throughout Sage. Obviously such a change would not be backward compatible. Therefore it may have a major impact on external code that others have written - which must be taken into consideration. 

However, within /src/sage/:
  1. There are only only 22 instances of "def numerator(" and 36 instances of "def denominator("
  2. In both cases, one is a function and the remainder are methods of classes. Of the latter, all-bar-two are properties (that is, their only argument is self)
  3. There are 482 uses of .numerator() and 650 uses of .denominator()
  4. Of these 31 and 31 are calls of the non-properties methods.

This suggest that 52 of these methods could have the `@`property decorators added relatively simply, and 4 exception methods will require some thought / care*. Similarly 1070 uses of these methods could be replaced via a direct substitution and 62 uses will require some care. So it appears that the effort required to implement within the Sage source, while large, would be relatively low as the majority of the work could be done with a find-and-replace.

*The exceptional methods are:

```
./src/sage/rings/continued_fraction.py:    def denominator(self, n):
./src/sage/symbolic/expression.pyx:    def denominator(self, bint normalize=True):
```

While the exceptional function that does not need to be changed is:

```
./src/sage/misc/functional.py:def denominator(x):
```



---

Comment by mcbell created at 2019-07-25 11:59:42

So having attempted the solution I proposed in comment 16 (via a small sed script) I do not think that this option will work. This is due to some of the .numerator() calls being calls on non-sage classes. For example, in rings/number_field/number_field_ideal.py the line

```
        return ZZ(q.numerator())
```

cannot be substitute since here q is a pari object and does not have a numer method.


---

Comment by git created at 2019-07-26 07:54:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mcbell created at 2019-07-26 07:59:41

The above commits deals with the issues raised in comment 9. It does this by 
  1. removing the deprecation warning - this could be added in in a later ticket and updating the relevant doctests to reflect this.
  2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`
  3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`

This now means that the doctests pass and that doing 

```
sage: from fractions import Fraction
sage: Fraction(3, 7)
Fraction(3, 7)
sage: Fraction(3/7)
Fraction(3, 7)
```

works.


---

Comment by mcbell created at 2019-07-26 08:12:10

Changing status from new to needs_review.


---

Comment by git created at 2019-07-26 10:35:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-07-26 11:45:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2019-07-27 14:12:15

See https://discuss.python.org/t/pep-3141-numerator-instead-of-numerator/2037/4


---

Comment by mcbell created at 2019-07-27 16:51:54

Discussion on Sage-devel here: https://groups.google.com/forum/#!topic/sage-devel/3qgud0cdh-U


---

Comment by jdemeyer created at 2019-08-02 17:01:01

To the OP: why do you care about Python fractions? It's a serious question since Guido van Rossum seems quite negative about them (see the link at [comment:23]).


---

Comment by jdemeyer created at 2019-08-02 17:02:10

Replying to [comment:19 mcbell]:
>   2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`

This is independent of the issue at hand and should be done in a separate ticket.


---

Comment by jdemeyer created at 2019-08-02 17:03:21

Replying to [comment:15 vdelecroix]:
> Note that it affects Python but also `numpy`.

Please elaborate. Does numpy have fractions? I couldn't find anything like that.


---

Comment by vdelecroix created at 2019-08-02 18:48:40

Replying to [comment:27 jdemeyer]:
> Replying to [comment:15 vdelecroix]:
> > Note that it affects Python but also `numpy`.
> 
> Please elaborate. Does numpy have fractions? I couldn't find anything like that.

I meant that they are complient with the numbers abc protocol

```
>>> import numpy as np
>>> np.int16(123).numerator
123
>>> np.int16(123).denominator
1
```



---

Comment by jdemeyer created at 2019-08-02 20:04:32

Replying to [comment:19 mcbell]:
>   3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`

I really don't like this change because it's an ugly hack and it may be bad for performance (since `numbers.Integral` is an abstract base class that arbitrary classes can register for, this is quite slow). Are those changes really needed?


---

Comment by jdemeyer created at 2019-08-02 20:09:12

This is silly:

```
    def __call__(self, *args, **kwargs):
        if args or kwargs:
            raise TypeError("'{}.{}' object is not callable".format(self.__class__.__module__, self.__class__.__name__))
```

If you don't want to support `*args` or `**kwargs`, just write

```
    def __call__(self):
        return self
```

which is more efficient.

I also disagree with

```
        # If in the future we decide to deprecate this functionality then we can add:
        #   deprecation(28234, 'callable integers are only intended as a tempory patch until .numerator and .denominator properties are used everywhere')
        # This will require updating a large number of doctests to reflect this warning so we leave this for a future ticket.
```

I would rather keep the method as normal usage instead of deprecating it.


---

Comment by jdemeyer created at 2019-08-02 20:12:19

For the record, I'm not saying yet that I agree with this ticket. I'm just giving comments in case that we decide to go with this approach.

I certainly want to wait a bit to see where the Python discussion goes. It would help to have a convincing use case, instead of "I want to use `fractions.Fraction` in Sage just because".


---

Comment by mcbell created at 2019-08-02 22:42:14

Replying to [comment:29 jdemeyer]:
> Replying to [comment:19 mcbell]:
> >   3. Then replacing all uses of `callable(x)` with `callable(x) and not isinstance(x, numbers.Integral)`
> 
> I really don't like this change because it's an ugly hack and it may be bad for performance (since `numbers.Integral` is an abstract base class that arbitrary classes can register for, this is quite slow). Are those changes really needed?

I agree that this is ugly and that it may impact performance. However it is necessary in at least some (in fact I believe a large percentage) of the `callable(x)` cases (for example, see ​https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/infinite_polynomial_element.py#L1523). Without these the route through the code changes and so if they are omitted then the code raises an error. The tricky thing here is that (like in the above example) the error is often raised far away from where the callable(x) occurred, making these hard to track down.

It may be possible to remove some of these uses when you explicitly know that `x` is never a Sage Integer. However I would be extremely worried about these cases since if you are wrong then it is possible that the code does not raise an error but may compute a incorrect result. Now hopefully there would be doctests that would run all of these different possibilities but this may be a situation that people aren't expecting and so I'm not sure that we can rely on the doctests to save us.

Therefore I would strongly argue that these changes are needed everywhere. In fact, even in the few cases where it is completely obvious that `x` cannot be a Sage Integer, it may be better to keep these purely for consistency.


---

Comment by mcbell created at 2019-08-02 22:44:06

Replying to [comment:30 jdemeyer]:
> If you don't want to support `*args` or `**kwargs`, just write
> {{{
>     def __call__(self):
>         return self
> }}}
> which is more efficient.

I agree that this is a better way to go initially. Thank you for pointing this out.


---

Comment by jdemeyer created at 2019-08-03 21:11:25

The fact that making Sage integers callable breaks stuff is bad. So we should consider the pros and cons of this approach. I'm not sufficiently convinced about the pros (as Guido van Rossum said: what real world problems would this solve?). Note that the submitter at #20861 admitted to not really caring about fractions, so for the moment my feeling goes towards rejecting this fix.


---

Comment by embray created at 2019-08-07 11:28:38

I do find it a shame, in general, that there are so many methods on classes in Sage that should really be properties.  I understand the reason ("what if you _do_ want to add some optional arguments to that property later?").  But in that case I think there should be a separate method from the argument-less property.

It's also an unfortunate shortcoming in Python that there's know way to easily know ahead of time that when an attribute is looked up on an object, it will be subsequently _called_ as in method call syntax.  So there is no opportunity to return a different type for attribute access when doing something like `a.property` versus `a.property()`.  It's fundamentally baked into Python's design that these cases can't be distinguished in some way.

I've thought in the past of working around this limitation by coming up with a generic way of proxying arbitrary types in such a way as to make them callable.  So rather than making Integer callable as this ticket proposes, something like `Rational.numerator` would instead return an Integer instance wrapped in a proxy, which when called does something special with that instance, likely with reference to the original Rational that returned it (in this case the call method on the proxy would be trivial--it would just return the Integer itself).

Unfortunately that's a whole other can of worms itself, especially when you want to add a callable-proxy to types that are already callable in the first place.


---

Comment by embray created at 2019-08-07 11:38:25

Though I did just see Jeroen's point [here](https://discuss.python.org/t/pep-3141-ratio-instead-of-numerator-denominator/2037/7) that technically one could implement specialized method call syntax.  But it's still really confusing.  For example you'd have `a.foo()` do something different from `x = a.foo; x()`.  And yes, it would be very CPython specific--but maybe that's okay, for special cases in Sage, to take advantage of?

Another super hacky workaround I've considered in the past for this (which would only work in CPython with pure Python code) would be to have a special kind of descriptor that actually looks ahead in the bytecode to see if (within some reasonable localization) the object returned by the descriptor will be called, and thus allow different behavior in that case.  Again, a hugely problematic hack, but possibly "good enough" for some common cases?


---

Comment by jdemeyer created at 2019-08-07 12:33:16

Replying to [comment:36 embray]:
> Though I did just see Jeroen's point [here](https://discuss.python.org/t/pep-3141-ratio-instead-of-numerator-denominator/2037/7) that technically one could implement specialized method call syntax.  But it's still really confusing.  For example you'd have `a.foo()` do something different from `x = a.foo; x()`.

To expand on this, this is part of the work on [PEP 590](https://www.python.org/dev/peps/pep-0590/). Note the different bytecode generated:

```
>>> from dis import dis
>>> def f(obj):
...     return obj.meth()
>>> def g(obj):
...     x = obj.meth
...     return x()
>>> dis(f)
  2           0 LOAD_FAST                0 (obj)
              2 LOAD_METHOD              0 (meth)
              4 CALL_METHOD              0
              6 RETURN_VALUE                                                                                                                                            
>>> dis(g)                                                                                                                                                             
  2           0 LOAD_FAST                0 (obj)                                                                                                                        
              2 LOAD_ATTR                0 (meth)                                                                                                                       
              4 STORE_FAST               1 (x)

  3           6 LOAD_FAST                1 (x)
              8 CALL_FUNCTION            0
             10 RETURN_VALUE
```

`LOAD_METHOD` and `CALL_METHOD` are an optimization to avoid creating a temporary bound method object when executing `obj.meth()`. It basically turns the call into a call of the _unbound_ method. This optimization used to be enabled only for two specific method classes (one for Python methods and one for C methods). But PEP 590 allows this optimization for arbitrary classes. In theory, it should just be an optimization not affecting the actual behaviour. But it does allow doing arbitrary hacky stuff when `LOAD_METHOD`/`CALL_METHOD` is used.

> And yes, it would be very CPython specific--but maybe that's okay, for special cases in Sage, to take advantage of?

We need to make sure that Cython supports it too. Since PEP 590 is so new, it's not in the current stable release. But the big upcoming Cython 3.0 should at least partially support it.


---

Comment by jdemeyer created at 2019-08-07 12:35:35

I forgot to mention that PEP 590 needs Python 3.8, for which there is no stable release yet.


---

Comment by embray created at 2019-08-07 13:38:27

How does it know to generate special bytecode in this case?  Is it just hacked into the parser somehow?

Part of me really does think there should be a way to exploit direct method calls as a special case, even though it would be a slightly confusing inconsistency.


---

Comment by slelievre created at 2019-08-08 02:41:11

Replying to [comment:34 jdemeyer]:
> as Guido van Rossum said: what real world problems would this solve?

Some mathematical packages for dynamics, geometry and topology of
surfaces and 3-manifolds, such as Curver, Flipper, SnapPy, Twister,
Veerer, can be run either with pure Python, or with Sage. Some of
them use the `Fraction` constructor from Python's `fractions` module,
which works with Python ints or rationals and fails with Sage
integers or rationals. That's the real-world problem.


---

Comment by jdemeyer created at 2019-08-08 08:46:27

Replying to [comment:39 embray]:
> Is it just hacked into the parser somehow?

Yes. When the parser sees something of the form `obj.attr()`, it uses those special bytecodes. Further details in https://bugs.python.org/issue26110


---

Comment by jdemeyer created at 2019-08-08 09:36:09

Replying to [comment:40 slelievre]:
> Some mathematical packages for dynamics, geometry and topology of
> surfaces and 3-manifolds, such as Curver, Flipper, SnapPy, Twister,
> Veerer, can be run either with pure Python, or with Sage. Some of
> them use the `Fraction` constructor from Python's `fractions` module

OK, I quickly looked at these packages. First of all, I couldn't find a package called "Veerer".

Two don't use fractions:

- [flipper](https://github.com/MarkCBell/flipper)
- [twister](https://bitbucket.org/Mark_Bell/twister/src/default/)

Two do use fractions:

- [curver](https://github.com/MarkCBell/curver)
- [snappy](https://pypi.org/project/snappy/2.7)

However, it's not obvious to me how Sage integers or rationals could end up as an argument to `Fraction` in these packages. curver doesn't use Sage at all. snappy does use Sage (for example, for Gröbner basis computations), but it seems that output from Sage is converted to snappy data structures, so it doesn't really do computations with Sage data types.


---

Comment by vdelecroix created at 2019-08-08 09:44:17

`flipper` does indirectly uses `Fraction` through [realalg](https://github.com/MarkCBell/realalg). And it is easy to break

```
sage: import realalg
sage: realalg.RealNumberField([1,0,-2])
Traceback (most recent call last):
...
TypeError: invalid input: <built-in method numerator of sage.rings.integer.Integer object at 0x7fca4682fd20>
```


I thought about providing support for sage `Rational` in `realalg`... but it is a can of worms.


---

Comment by jdemeyer created at 2019-08-08 10:07:08

Replying to [comment:43 vdelecroix]:
> but it is a can of worms.

A can of worms is precisely what we're looking for here. Guido claims that there is no problem, so we some data to prove him wrong.


---

Comment by vdelecroix created at 2019-08-08 10:21:23

Replying to [comment:44 jdemeyer]:
> Replying to [comment:43 vdelecroix]:
> > but it is a can of worms.
> 
> A can of worms is precisely what we're looking for here. Guido claims that there is no problem, so we some data to prove him wrong.

Agreed.

As we make the PEP idea better, we should also think about making `Rational` an easy drop-in replacement for `Fraction`. In other words, the following kind of thing should work

```
try:
    from sage.rings.rational import Rational as Fraction
except ImportError:
    try:
        from gmpy2 import mpq as Fraction
    except ImportError:
        from fractions import Fraction
```

I see a serious obstruction for now: the constructors are not compatible.

```
sage: from fractions import Fraction
sage: from gmpy2 import mpq
sage: Fraction(2r, 3r)
Fraction(2, 3)
sage: mpq(2,3)
mpq(2,3)
sage: Rational(2,3)   # second argument is "base"
2
```



---

Comment by mcbell created at 2019-08-10 09:00:45

Replying to [comment:42 jdemeyer]:
> Two do use fractions:
> 
> - [curver](https://github.com/MarkCBell/curver)
> - [snappy](https://pypi.org/project/snappy/2.7)
> 
> However, it's not obvious to me how Sage integers or rationals could end up as an argument to `Fraction` in these packages. curver doesn't use Sage at all.

Sage Integers can end up in Fractions whenever a user uses these packages interactively or from within a sage script / notebook. For example:


```
sage: import curver
sage: curver.load(2, 1).triangulation([0, 99, 99, 1, 100, 0, 0, 0, 0])
```


crashes since the values that are passed to the functions within curver are sage Integers. This happens even though curver has scattered throughout it lines (equivalent to):

```
    assert isinstance(n, numbers.Integral)
```

but since Sage Integers have been registered as Integral these catches do not work.

Of course, doing

```
sage: curver.load(2, 1).triangulation([0r, 99r, 99r, 1r, 100r, 0r, 0r, 0r, 0r])
```

works without an issue.


---

Comment by mcbell created at 2019-08-10 09:26:55

Personally, I am more worried about code that does incorrect / dangerous things when it encounters. For example, I could imagine something like:


```
def prod_numerator_denominator(x):
    ''' Since x = p / q (where q is possibly 1), return p * q. '''
    try:
        # If x is Rational then this will work.
        return x.numerator * x.denominator
    except:
        # x was not a Rational, so we can take q == 1 and just return x
        return x

assert prod_numerator_denominator(Fraction(3r, 2r)) == 6
assert prod_numerator_denominator(3) == 3
assert prod_numerator_denominator(3 / 2) == 6  # Fails since prod_numerator_denominator(3 / 2) returns 3
 }}}

Or even

{{{
def f(x):
    if not isinstance(x, numbers.Rational):
        return NotImplemented

    # So now I know x is a Rational and so implements .numerator and .denominator properties
    try:
        return x.numerator + x.denominator
    except:
        # I know the code here can never be run so I can it should be safe to put something bad here
        import os
        os.remove('/')
}}}


---

Comment by embray created at 2019-08-12 08:59:04

To me an obvious answer here is for Sage `Rational`s and `Integer`s to just get some kind of `.as_pyfraction()` method to convert them to a `Fraction`.

It's not ideal of course. One would really prefer to see it just work, transparently. But when interfaces collide the only recourse, if you can't easily change the interfaces, is to make some kind of adapter.

I liked Jeroen's `__ratio__` proposal and thought it made a lot of sense. But it seems it wasn't too popular. And even if it did happen one day we'd have to wait for the change in Python (or monkey-patch the `fractions` module which I suppose is another possibility...)


---

Comment by slelievre created at 2019-08-13 10:32:19

I often wished there was `a.num_denom()` to get
`a.numerator()` and `a.denominator()` at once,
the same way `a.quo_rem(b)` gives the quotient
`a // b` and the remainder `a % b` at once.


---

Comment by jdemeyer created at 2019-08-13 10:40:59

Replying to [comment:49 slelievre]:
> I often wished there was `a.num_denom()`

It's called `.as_integer_ratio()` and it will be supported in Python 3.8 for all standard numeric types (`int`, `float`, `decimal.Decimal` and `fractions.Fraction`). Clearly, this is something that Sage types should also have.

This doesn't yet solve the problem that this ticket wants to solve, but it's getting closer.


---

Comment by slelievre created at 2019-08-13 10:48:03

Okay, I opened #28348 for that.


---

Comment by jdemeyer created at 2019-08-13 12:28:52

I opened #28347 for that, needs review.


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2020-08-15 22:06:32

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2020-08-15 22:06:32

merge conflict


---

Comment by embray created at 2021-01-21 13:54:27

Any interest in continuing to work on this?  I've just been bitten by this issue in my own code.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by slelievre created at 2021-03-25 01:10:48

This issue was already reported
in [#10928, comment 14](https://trac.sagemath.org/ticket/10928#comment:14) (a ticket about getitem of numpy matrix using Sage integers).

Hopefully with #28347 in, things are easier than back at Sage Days 100?


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2021-08-27 01:47:37

This issue also shows up when trying to use the `statistics` module with Sage integers or rationals, see #29662.

Although the `as_integer_ratio` mechanism has been added to Python, [statistics._exact_ratio](https://github.com/python/cpython/blob/main/Lib/statistics.py#L246) does not use `as_integer_ratio` because it sees the Sage numbers' `numerator` and `denominator` methods and tries to use them as properties.


---

Comment by jhpalmieri created at 2022-03-02 18:58:27

Replying to [comment:26 jdemeyer]:
> Replying to [comment:19 mcbell]:
> >   2. Replacing all uses of `hasattr(x, '__call__')` with `callable(x)`
> 
> This is independent of the issue at hand and should be done in a separate ticket.

Done in #33451.
