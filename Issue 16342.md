# Issue 16342: Tides interface

Issue created by migration from https://trac.sagemath.org/ticket/16579

Original creator: mmarco

Original creation time: 2014-06-28 05:06:04

This implements the generators of the needed .c files to run with tides. See #16578


---

Comment by mmarco created at 2014-06-28 05:18:35

Changing status from new to needs_review.


---

Comment by mmarco created at 2014-06-28 05:18:35

New commits:


---

Comment by git created at 2014-06-28 07:00:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2014-06-28 07:40:23

Changing keywords from "" to "sd59".


---

Comment by vdelecroix created at 2014-06-28 18:17:15

First quick pass

- What is an IVP?
- Please be more careful with the doc:
  - symbollic -> symbolic
  - desored -> desired
  - paramters -> parameters
- why did you lazy import `NN`?
- as trigonometric functions are only used in `subexpressions_list` it would be better to import them only inside the function.
- Are you sure that `subexpressions_list` must belong to this module?
- In the function `subexpressions_parameters` the extra argument `parameters` is never tested.
- You should *never* use an empty list in the definition of a function
  {{{
  sage: def f(a=[]): return a
  sage: a = f()
  sage: a.append(18)
  sage: f()
  [18]
  }}}
- why do you use `fast_callable`? There is no introspection directly from the expression?

Vincent


---

Comment by vdelecroix created at 2014-06-28 18:17:15

Changing status from needs_review to needs_info.


---

Comment by git created at 2014-06-28 18:33:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2014-06-28 18:56:42

- What is an IVP?
An inital value problem. Clarified in the documentation now.

- Please be more careful with the doc:
checked.

- why did you lazy import NN?
sorry about that, at some point this code was in desolvers, that was automatically loaded and produced a circular dependency error at startup

- as trigonometric functions are only used in subexpressions_list it would be better to import them only inside the function.
Thanks, changed.

- Are you sure that subexpressions_list must belong to this module?
I wrote it for this specific purpose (in fact it was originally inside the code of the generator_.. functions), but i am open to suggestions. Where would it fit better?

- In the function subexpressions_parameters the extra argument parameters is never tested.
Added a doctest for that.

- You should never use an empty list in the definition of a function
ups, you are right, took care of that.

- why do you use fast_callable? There is no introspection directly from the expression?
fast_callable does the job of deciding the correct order for the operations to be properly executed. Doing that directly from the expression tree is possible (and maybe not hard), but also not trivial.


---

Comment by git created at 2014-06-28 18:57:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2014-06-28 19:51:17

Changing status from needs_info to needs_review.


---

Comment by git created at 2014-06-29 18:38:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-07-01 18:39:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-07-08 18:51:53

Resolution: fixed


---

Comment by jdemeyer created at 2014-10-16 18:21:05

In `genfiles_mpfr()`, what's the point of all these

```
N(parameter_values[i],digits=dig)
```

why not simply

```
parameter_values[i]
```

I'm making this change at #16025.


---

Comment by mmarco created at 2014-10-16 20:48:37

IIRC we decided to force the number of digits of the output because mpfr_set_str requires a string with all the digits.

That is, if we are working with 10 digits of precision, we need to write 0.5 as 0.5000000000.


---

Comment by jdemeyer created at 2014-10-16 20:54:34

Replying to [comment:17 mmarco]:
> `mpfr_set_str` requires a string with all the digits.
I'm pretty sure that this is not true. `mpfr_set_str()` is what Sage uses to create `RealNumber`s from strings and that works with any number of digits.


---

Comment by mmarco created at 2014-10-16 21:25:30

MPFR documentation states that "Contrary to mpfr_strtofr, mpfr_set_str requires the whole string to represent a valid floating-point number"

Anyways i will ask the tides developpers about this. Maybe there are some reasons that i am missing.


---

Comment by jdemeyer created at 2014-10-17 05:45:20

Replying to [comment:19 mmarco]:
> MPFR documentation states that "Contrary to mpfr_strtofr, mpfr_set_str requires the whole string to represent a valid floating-point number"
Sure, but `"1"` or `"1.0"` are valid floating point numbers just like `"1.00000000000000000000"`.


---

Comment by mmarco created at 2014-10-17 08:09:36

Maybe i am understanding it in the wrong way, but as i get it, the sentence states that "1.0" will create a floating point number with less precission than "1.0000000".

In any case, we could check it using desolve_tides_mpfr (#16581) and compare the results with and without the change. A doctest should be added there in any case.


---

Comment by jdemeyer created at 2014-10-17 08:18:30

Replying to [comment:21 mmarco]:
> Maybe i am understanding it in the wrong way, but as i get it, the sentence states that "1.0" will create a floating point number with less precission than "1.0000000".
That's not what it says. The precision in MPFR is a property of the number, the input doesn't matter.


---

Comment by iMark created at 2014-10-17 18:28:26

Hello jdemeyer. I'm also a developer of sagetides, as well as a tides developer.
You are right with mpfr. From the very beginning we preset the number of digits (binary or decimal) and all the floating point variables of the code stores numbers of the same binary size.


We wrote 'N(parameter, digits = dig)' because, otherwise sage writes to text either the algebraic representation of the number (eg pi) or an insufficient floating point approximation.

However, using string representation, it is the same computational effort parsing 0.10 0.100 or 0.1000000000, cause they have no exact representation. I personally prefer long strings because it is more clear for me to read so. I use sage as preprocessor to obtain C code to work with and edit it outside sage environmet.

I hope this can clarify a bit the ticket.


---

Comment by jdemeyer created at 2014-10-17 18:31:37

Replying to [comment:23 iMark]:
> We wrote 'N(parameter, digits = dig)' because, otherwise sage writes to text either the algebraic representation of the number
If that is the reason, this should be
1) documented
2) tested in a doctest


---

Comment by mmarco created at 2014-10-17 19:39:14

Ok, i will open a ticket for that.


---

Comment by mmarco created at 2014-10-19 21:18:03

This is now #17179
