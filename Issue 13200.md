# Issue 13200: add functionality for duals of algebras, coalgebras, hopf algebras, etc.

archive/issues_013200.json:
```json
{
    "body": "Assignee: @aghitza\n\nCC:  combinat @tscrim\n\nKeywords: duality, categories, algebras\n\nIn this [discussion](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion), we came up with a rough draft of an interface for the method returning the dual of an object. Here is a summary by way of docstrings for the methods:\n\n```\ndef dual(self, category=None):\n    r\"\"\"\n    The dual of ``self``.\n\n    By default, the dual is computed in the category\n    ``self.category()``. If the user specifies a category, the dual will\n    be computed in that category.\n\n    INPUT:\n\n    - ``category`` -- category (default: the category of ``self``).\n\n    OUTPUT:\n\n    - The dual of ``self``.\n\n    EXAMPLES:\n\n    The Hopf algebra of symmetric functions is a self-dual Hopf\n    algebra::\n\n        sage: Sym = SymmetricFunctions(QQ); Sym\n        Symmetric Functions over Rational Field\n        sage: Sym.dual()\n        Symmetric Functions over Rational Field\n        sage: Sym.dual() is Sym\n        True\n\n    If we view ``Sym`` as an algebra, then its dual is a co-algebra::\n\n        sage: C = Sym.dual(category=Algebras(QQ)).category()\n        Category of duals of algebras over Rational Field\n        sage: C.super_categories()\n        [Category of coalgebras over Rational Field,\n         Category of duals of vector spaces over Rational Field]\n\n    The Schur basis for symmetric functions is self-dual and the\n    homogeneous symmetric functions are dual to the monomial\n    symmetric functions::\n\n        sage: s = Sym.schur()\n        sage: s.dual() is s\n        True\n        sage: h = Sym.homogeneous()\n        sage: m = Sym.monomial()\n        sage: h.dual() is m\n        True\n\n    Note that in the above, ``s`` (as well as ``h`` and ``m``) are Hopf\n    algebras with basis. Hence, their duals are also Hopf algebras with\n    basis.\n\n    The Hopf algebra of quasi-symmetric functions is dual, as a Hopf\n    algebra, to the Hopf algebra of non-commutative symmetric\n    functions::\n\n        sage: NCSF = NonCommutativeSymmetricFunctions(QQ)\n        sage: NCSF.dual()\n        Quasisymmetric functions over the Rational Field\n\n    ::\n        sage: QSym = QuasiSymmetricFunctions(QQ)\n        sage: QSym.dual()\n        Non-Commutative Symmetric Functions over the Rational Field\n\n    \"\"\"\n    return NotImplemented\n\ndef duality_pairing(self, x, y):\n    r\"\"\"\n    The duality pairing between elements of NSym and elements of QSym.\n\n    INPUT:\n\n    - ``x`` -- an element of ``self``\n    - ``y`` -- an element in the dual basis of ``self``\n\n    OUTPUT:\n\n    - The result of pairing the element ``x`` of ``self`` with the\n      element ``y`` of the dual of ``self``.\n\n    EXAMPLES:\n\n    The Schur basis of symmetric functions is self-dual::\n\n        sage: Sym = SymmetricFunctions(QQ)\n        sage: s = Sym(QQ).schur()\n        sage: s.dual() is s\n        True\n        sage: s.duality_pairing(s[2,1,1], s[2,1,1])\n        1\n        sage: s.duality_pairing(s[2,1], s[3])\n        0\n\n    The fundamental basis of quasi-symmetric functions is dual to the\n    ribbon basis of non-commutative symmetric functions::\n\n        sage: R = NonCommutativeSymmetricFunctions(QQ).Ribbon()\n        sage: F = QuasiSymmetricFunctions(QQ).Fundamental()\n        sage: R.duality_pairing(R[1,1,2], F[1,1,2])\n        1\n        sage: R.duality_pairing(R[1,2,1], F[1,1,2])\n        0\n        sage: F.duality_pairing(F[1,2,1], R[1,1,2])\n        0\n\n    \"\"\"\n    return NotImplemented\n```\n\nA rudimentary implementation for `duality_matrix` can be found at #8899, but see also the scalar product code for symmetric functions.\n\nI think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html)\n\nIssue created by migration from https://trac.sagemath.org/ticket/13372\n\n",
    "created_at": "2012-08-15T14:57:10Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "add functionality for duals of algebras, coalgebras, hopf algebras, etc.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13200",
    "user": "https://github.com/saliola"
}
```
Assignee: @aghitza

CC:  combinat @tscrim

Keywords: duality, categories, algebras

In this [discussion](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion), we came up with a rough draft of an interface for the method returning the dual of an object. Here is a summary by way of docstrings for the methods:

```
def dual(self, category=None):
    r"""
    The dual of ``self``.

    By default, the dual is computed in the category
    ``self.category()``. If the user specifies a category, the dual will
    be computed in that category.

    INPUT:

    - ``category`` -- category (default: the category of ``self``).

    OUTPUT:

    - The dual of ``self``.

    EXAMPLES:

    The Hopf algebra of symmetric functions is a self-dual Hopf
    algebra::

        sage: Sym = SymmetricFunctions(QQ); Sym
        Symmetric Functions over Rational Field
        sage: Sym.dual()
        Symmetric Functions over Rational Field
        sage: Sym.dual() is Sym
        True

    If we view ``Sym`` as an algebra, then its dual is a co-algebra::

        sage: C = Sym.dual(category=Algebras(QQ)).category()
        Category of duals of algebras over Rational Field
        sage: C.super_categories()
        [Category of coalgebras over Rational Field,
         Category of duals of vector spaces over Rational Field]

    The Schur basis for symmetric functions is self-dual and the
    homogeneous symmetric functions are dual to the monomial
    symmetric functions::

        sage: s = Sym.schur()
        sage: s.dual() is s
        True
        sage: h = Sym.homogeneous()
        sage: m = Sym.monomial()
        sage: h.dual() is m
        True

    Note that in the above, ``s`` (as well as ``h`` and ``m``) are Hopf
    algebras with basis. Hence, their duals are also Hopf algebras with
    basis.

    The Hopf algebra of quasi-symmetric functions is dual, as a Hopf
    algebra, to the Hopf algebra of non-commutative symmetric
    functions::

        sage: NCSF = NonCommutativeSymmetricFunctions(QQ)
        sage: NCSF.dual()
        Quasisymmetric functions over the Rational Field

    ::
        sage: QSym = QuasiSymmetricFunctions(QQ)
        sage: QSym.dual()
        Non-Commutative Symmetric Functions over the Rational Field

    """
    return NotImplemented

def duality_pairing(self, x, y):
    r"""
    The duality pairing between elements of NSym and elements of QSym.

    INPUT:

    - ``x`` -- an element of ``self``
    - ``y`` -- an element in the dual basis of ``self``

    OUTPUT:

    - The result of pairing the element ``x`` of ``self`` with the
      element ``y`` of the dual of ``self``.

    EXAMPLES:

    The Schur basis of symmetric functions is self-dual::

        sage: Sym = SymmetricFunctions(QQ)
        sage: s = Sym(QQ).schur()
        sage: s.dual() is s
        True
        sage: s.duality_pairing(s[2,1,1], s[2,1,1])
        1
        sage: s.duality_pairing(s[2,1], s[3])
        0

    The fundamental basis of quasi-symmetric functions is dual to the
    ribbon basis of non-commutative symmetric functions::

        sage: R = NonCommutativeSymmetricFunctions(QQ).Ribbon()
        sage: F = QuasiSymmetricFunctions(QQ).Fundamental()
        sage: R.duality_pairing(R[1,1,2], F[1,1,2])
        1
        sage: R.duality_pairing(R[1,2,1], F[1,1,2])
        0
        sage: F.duality_pairing(F[1,2,1], R[1,1,2])
        0

    """
    return NotImplemented
```

A rudimentary implementation for `duality_matrix` can be found at #8899, but see also the scalar product code for symmetric functions.

I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html)

Issue created by migration from https://trac.sagemath.org/ticket/13372





---

archive/issue_comments_161107.json:
```json
{
    "body": "Simon raised the following question in the [thread](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion):\n\n> Start with an object O in some category C1, take its dual D in C1, and\n> apply the forgetful functor to map it to a sub-category C2; one would\n> not always get the same result as if one first applies the forgetful\n> functor to O and then dualise the result in C2, right?\n>\n> And hence VectorSpaces(QQ)(H.dual()) might (perhaps not here, but in\n> other situations) be different from (VectorSpaces(QQ)(H)).dual().\n> Would that be a problem?",
    "created_at": "2012-08-15T15:00:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13200",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13200#issuecomment-161107",
    "user": "https://github.com/saliola"
}
```

Simon raised the following question in the [thread](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion):

> Start with an object O in some category C1, take its dual D in C1, and
> apply the forgetful functor to map it to a sub-category C2; one would
> not always get the same result as if one first applies the forgetful
> functor to O and then dualise the result in C2, right?
>
> And hence VectorSpaces(QQ)(H.dual()) might (perhaps not here, but in
> other situations) be different from (VectorSpaces(QQ)(H)).dual().
> Would that be a problem?



---

archive/issue_comments_161108.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13200",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13200#issuecomment-161108",
    "user": "https://github.com/mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
