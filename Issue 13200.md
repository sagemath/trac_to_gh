# Issue 13200: add functionality for duals of algebras, coalgebras, hopf algebras, etc.

Issue created by migration from Trac.

Original creator: saliola

Original creation time: 2012-08-15 14:57:10

Assignee: AlexGhitza

CC:  combinat tscrim

Keywords: duality, categories, algebras

In this [discussion](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion), we came up with a rough draft of an interface for the method returning the dual of an object. Here is a summary by way of docstrings for the methods:

```
def dual(self, category=None):
    r"""
    The dual of ``self``.

    By default, the dual is computed in the category
    ``self.category()``. If the user specifies a category, the dual will
    be computed in that category.

    INPUT:

    - ``category`` -- category (default: the category of ``self``).

    OUTPUT:

    - The dual of ``self``.

    EXAMPLES:

    The Hopf algebra of symmetric functions is a self-dual Hopf
    algebra::

        sage: Sym = SymmetricFunctions(QQ); Sym
        Symmetric Functions over Rational Field
        sage: Sym.dual()
        Symmetric Functions over Rational Field
        sage: Sym.dual() is Sym
        True

    If we view ``Sym`` as an algebra, then its dual is a co-algebra::

        sage: C = Sym.dual(category=Algebras(QQ)).category()
        Category of duals of algebras over Rational Field
        sage: C.super_categories()
        [Category of coalgebras over Rational Field,
         Category of duals of vector spaces over Rational Field]

    The Schur basis for symmetric functions is self-dual and the
    homogeneous symmetric functions are dual to the monomial
    symmetric functions::

        sage: s = Sym.schur()
        sage: s.dual() is s
        True
        sage: h = Sym.homogeneous()
        sage: m = Sym.monomial()
        sage: h.dual() is m
        True

    Note that in the above, ``s`` (as well as ``h`` and ``m``) are Hopf
    algebras with basis. Hence, their duals are also Hopf algebras with
    basis.

    The Hopf algebra of quasi-symmetric functions is dual, as a Hopf
    algebra, to the Hopf algebra of non-commutative symmetric
    functions::

        sage: NCSF = NonCommutativeSymmetricFunctions(QQ)
        sage: NCSF.dual()
        Quasisymmetric functions over the Rational Field

    ::
        sage: QSym = QuasiSymmetricFunctions(QQ)
        sage: QSym.dual()
        Non-Commutative Symmetric Functions over the Rational Field

    """
    return NotImplemented

def duality_pairing(self, x, y):
    r"""
    The duality pairing between elements of NSym and elements of QSym.

    INPUT:

    - ``x`` -- an element of ``self``
    - ``y`` -- an element in the dual basis of ``self``

    OUTPUT:

    - The result of pairing the element ``x`` of ``self`` with the
      element ``y`` of the dual of ``self``.

    EXAMPLES:

    The Schur basis of symmetric functions is self-dual::

        sage: Sym = SymmetricFunctions(QQ)
        sage: s = Sym(QQ).schur()
        sage: s.dual() is s
        True
        sage: s.duality_pairing(s[2,1,1], s[2,1,1])
        1
        sage: s.duality_pairing(s[2,1], s[3])
        0

    The fundamental basis of quasi-symmetric functions is dual to the
    ribbon basis of non-commutative symmetric functions::

        sage: R = NonCommutativeSymmetricFunctions(QQ).Ribbon()
        sage: F = QuasiSymmetricFunctions(QQ).Fundamental()
        sage: R.duality_pairing(R[1,1,2], F[1,1,2])
        1
        sage: R.duality_pairing(R[1,2,1], F[1,1,2])
        0
        sage: F.duality_pairing(F[1,2,1], R[1,1,2])
        0

    """
    return NotImplemented
```

A rudimentary implementation for `duality_matrix` can be found at #8899, but see also the scalar product code for symmetric functions.

I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html)


---

Comment by saliola created at 2012-08-15 15:00:17

Simon raised the following question in the [thread](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion):

> Start with an object O in some category C1, take its dual D in C1, and
> apply the forgetful functor to map it to a sub-category C2; one would
> not always get the same result as if one first applies the forgetful
> functor to O and then dualise the result in C2, right?
>
> And hence VectorSpaces(QQ)(H.dual()) might (perhaps not here, but in
> other situations) be different from (VectorSpaces(QQ)(H)).dual().
> Would that be a problem?


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
