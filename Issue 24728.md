# Issue 24728: Slowness of polygen(ZZ).change_ring(SR)

Issue created by migration from https://trac.sagemath.org/ticket/24965

Original creator: rws

Original creation time: 2018-03-13 15:31:58

This branch shows that the generic polynomial code is not aware of the symbolic zero problem. On Sage develop, the operation

```
sage: p = polygen(ZZ)^2 + 1
sage: %timeit p.change_ring(SR)
1000 loops, best of 3: 322 µs per loop
sage: %timeit p.change_ring(RR)
100000 loops, best of 3: 12.9 µs per loop
```

takes much longer with SR because `Expression.__nonzero__` is ultimately called. For the problems with this, see https://trac.sagemath.org/wiki/symbolics/nonzero

The branch adds 5 print statements before the calls to `__nonzero__` are made. The output is:

```
sage: p = polygen(ZZ)^2 + 1
sage: p.change_ring(SR)
0 Symbolic Ring
1 1 [0, 1]
2 1 Symbolic Ring
3 x^2 + 1 <type 'sage.symbolic.expression.Expression'>
2 x^2 + 1 Symbolic Ring
4 x^2 + 1 <type 'sage.symbolic.expression.Expression'>
2 x^2 + 1 Symbolic Ring
x^2 + 1
```

One can see
 - SR is tested for zero once;
 - the coefficients are tested once;
 - twice `x^2 + 1` is tested for zero
 - three times `__nonzero__` calls itself at point 2.

Inserting `return False` at the top of `__nonzero__` reduces the time to 70us. The culprit is the testing of `x^2 + 1`.

One easy solution that does not require the interface change outlined in https://trac.sagemath.org/wiki/symbolics/nonzero would be implementing #21201.

This branch should then be replaced with an improvement in the places marked.


---

Comment by rws created at 2018-03-13 15:34:38

Changing status from new to needs_info.


---

Comment by rws created at 2018-03-13 15:34:38

New commits:


---

Comment by vdelecroix created at 2018-03-13 15:56:48

The code should *never* test whether `x^2 + 1` is zero as a symbolic expression. I don't understand the trace that you obtain.


---

Comment by vdelecroix created at 2018-03-13 15:57:38

I mean `3 x^2 + 1 <type 'sage.symbolic.expression.Expression'>` and `4 x^2 + 1 <type 'sage.symbolic.expression.Expression'>` should not be there.


---

Comment by vdelecroix created at 2018-03-13 15:59:43

In other words

```
sage: p = SR['x'](polygen(ZZ, 'x'))
sage: p.degree()
0
```

should be

```
sage: p = SR['x'](polygen(ZZ, 'x'))
sage: p.degree()
1
```

Nobody cares whether it is slow or not. It is just *wrong*.


---

Comment by rws created at 2018-03-13 16:09:21

Changing component from performance to commutative algebra.


---

Comment by rws created at 2018-03-13 16:09:21

Changing type from task to defect.


---

Comment by rws created at 2018-03-13 16:09:21

Replying to [comment:6 vdelecroix]:
> Nobody cares whether it is slow or not. It is just *wrong*.

So I thought earlier in #24942#comment:12, and now it turns out it's the reason for slowness. Changing the description.


---

Comment by vdelecroix created at 2018-03-13 16:12:04

And note that I already explicitely said what needs to be done to fix this in #24942#comment:13


---

Comment by rws created at 2018-03-13 16:34:50

Fact is that `PolynomialRing_general._element_constructor` is not called at all here.


---

Comment by vdelecroix created at 2018-03-13 19:49:25

This is completely broken because of

```
sage: SR.has_coerce_map_from(ZZ['x'])
True
```

As a consequence of the above, the conversion `ZZ[x] -> SR['x']` goes through the base ring `SR` of the codomain.


---

Comment by vdelecroix created at 2018-03-13 20:00:20

The code of `SR._coerce_map_from_` is so nice

```
elif is_PolynomialRing(R) or is_MPolynomialRing(R) or \
     is_FractionField(R) or is_LaurentPolynomialRing(R):
    base = R.base_ring()
    return base is not self and self.has_coerce_map_from(base)
```



---

Comment by vdelecroix created at 2018-03-13 20:13:01

Here you have to choose:
- make the proposal in the ticket description happen and break two minor backward compatibilities (that I would judge as half broken anyway
- live with `SR['x'](polygen(ZZ)` being degree zero and use `SR['x'](list(p))` when you need the proper conversion


---

Comment by rws created at 2018-03-13 20:32:05

The first sounds correct. But the fix is over my head, I have no idea about how to fix this.


---

Comment by nbruin created at 2018-03-14 01:32:53

It looks like the degree 0 result is consistent with how name ambiguities are resolved elsewhere:

```
sage: f=QQ['x']['x'](QQ['x'].0)
sage: f.degree()
0
```

There is an `x` in `SR`, `SR` is supposed to be a ring, so `ZZ` coerces into it. As a result, `ZZ['x']` coerces into it as well. Furthermore, that means that `ZZ['x']` coerces as constants into `SR['x']`.


---

Comment by vdelecroix created at 2018-03-14 04:35:53

Then you are free to clarify the description and set to "won't fix".


---

Comment by vdelecroix created at 2018-03-14 05:38:10

Or better: to document and test this feature in the `SR` documentation!
