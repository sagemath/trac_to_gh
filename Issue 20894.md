# Issue 20894: Interpolation, Minimal Vanishing Polynomial and Multi Point Evaluation of Skew Polynomials

archive/issues_020894.json:
```json
{
    "body": "CC:  @tscrim @xcaruso @johanrosenkilde dlucas\n\nSupport for computing:\n1. Interpolation Polynomial\n2. Minimal Vanishing Polynomial\n3. Multi Point Evaluation\n\nin Skew Polynomial Rings.\n\nIssue created by migration from https://trac.sagemath.org/ticket/21131\n\n",
    "created_at": "2016-07-29T22:50:09Z",
    "labels": [
        "component: coding theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.6",
    "title": "Interpolation, Minimal Vanishing Polynomial and Multi Point Evaluation of Skew Polynomials",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20894",
    "user": "https://github.com/arpitdm"
}
```
CC:  @tscrim @xcaruso @johanrosenkilde dlucas

Support for computing:
1. Interpolation Polynomial
2. Minimal Vanishing Polynomial
3. Multi Point Evaluation

in Skew Polynomial Rings.

Issue created by migration from https://trac.sagemath.org/ticket/21131





---

archive/issue_comments_288601.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-29T23:53:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288601",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288602.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-30T00:36:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288602",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288603.json:
```json
{
    "body": "I've added methods for `minimal_vanishing_polynomial` and `multi_point_evaluation`. These work on skew polynomials over finite fields, both with sigma being the Frobenius or a power of Frobenius. MVP evaluates to 0 on all its `eval_pts` and for MPE, evaluations match the individual calls. However, there is no improvement in running time of MPE as compared to the individual calls. \n\nI've added `interpolation_polynomial`. But its not correct yet. For instance, for any finite field, if I give 3 or more eval_pts and values, it fails. \n\nAlso, I am not sure that these same algorithms are valid for skew polynomials over general rings. I ran some examples and found that the MVP does not evaluate to zero, MPE does not match individual calls.",
    "created_at": "2016-07-30T00:38:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288603",
    "user": "https://github.com/arpitdm"
}
```

I've added methods for `minimal_vanishing_polynomial` and `multi_point_evaluation`. These work on skew polynomials over finite fields, both with sigma being the Frobenius or a power of Frobenius. MVP evaluates to 0 on all its `eval_pts` and for MPE, evaluations match the individual calls. However, there is no improvement in running time of MPE as compared to the individual calls. 

I've added `interpolation_polynomial`. But its not correct yet. For instance, for any finite field, if I give 3 or more eval_pts and values, it fails. 

Also, I am not sure that these same algorithms are valid for skew polynomials over general rings. I ran some examples and found that the MVP does not evaluate to zero, MPE does not match individual calls.



---

archive/issue_comments_288604.json:
```json
{
    "body": "You could be more helpful by explaining *which* examples you ran, and tried to make them small and easy to debug. As it stands, I'm confused about what examples you did run, because MVP just threw an exception when I tried the \"usual\" non-finite field example `ZZ[t][x; t -> t+1]` (see below).\n\n\n- `minimal_vanishing_polynomial` generally outputs something in the skew polynomial over the fraction field of the base ring. I.e. if `S = R[x; sigma]` for some ring `R`, then the minimal vanishing polynomial is defined over `Q[x; sigma]` where `Q` is the fraction field of `R`. This is clear from the line `x - (sigma(eval_pts[0]) / eval_pts[0])`, where the constant coefficient is clearly in the fraction field of the base ring.\n\n  I hadn't thought of that before. Add a check at the beginning of the call. If `R` is not a field, then construct the skew polynomial ring over the fraction field and return the result of the call from there. Do the same with the two other methods.\n\n- In `multi_point_evaluation` you were doing something really strange in the case of one element. Just do the one evaluation (I already fixed it).\n\n- In `interpolation_polynomial` for the 1-point case you were doing quo-rem where you should just do the actual fraction. If the division doesn't go well, there is no way just taking the floored quotient will work! The result simply lives in the skew polynomial ring over the fraction field.\n\n- Add in the description of the three methods that the evaluation points must be linearly independent over the fixed field of the twist map. Your current description of `eval_pts` is incorrect (the evaluation points are all in the base ring of self, and are therefore (almost) *never* linearly independent over that same ring).\n\n- Add a doctest for a non-finite field skew polynomials. Because of the above restriction, use e.g. a skew polynomial over the fraction field of ZZ[t] instead of ZZ[t].\n\n- Add a doctest for `minimal_vanishing_polynomial` that throws the linear-independence error. Do the same for `multi_point_evaluation` and `interpolation`.\n\n- I removed a check from `interpolation_polynomial`. That check did not make any sense in most cases (the characteristic of `ZZ[t]` is 0 for instance).\n\n- In `interpolation_polynomial` you've now added a check to see if the evaluations match. Two comments: 1) why are you now using multi-point evaluation for this? 2) the check is currently being done in every recursive call of `interpolation_polynomial` which is completely wasteful. Make the check only at the top level by creating a new inner function which is the actual recursive function. This top level can also be in charge of all the checks on the input lengths etc.\n\n\nThat's it for now, I think.\n\nBest,\nJohan",
    "created_at": "2016-07-30T16:20:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288604",
    "user": "https://github.com/johanrosenkilde"
}
```

You could be more helpful by explaining *which* examples you ran, and tried to make them small and easy to debug. As it stands, I'm confused about what examples you did run, because MVP just threw an exception when I tried the "usual" non-finite field example `ZZ[t][x; t -> t+1]` (see below).


- `minimal_vanishing_polynomial` generally outputs something in the skew polynomial over the fraction field of the base ring. I.e. if `S = R[x; sigma]` for some ring `R`, then the minimal vanishing polynomial is defined over `Q[x; sigma]` where `Q` is the fraction field of `R`. This is clear from the line `x - (sigma(eval_pts[0]) / eval_pts[0])`, where the constant coefficient is clearly in the fraction field of the base ring.

  I hadn't thought of that before. Add a check at the beginning of the call. If `R` is not a field, then construct the skew polynomial ring over the fraction field and return the result of the call from there. Do the same with the two other methods.

- In `multi_point_evaluation` you were doing something really strange in the case of one element. Just do the one evaluation (I already fixed it).

- In `interpolation_polynomial` for the 1-point case you were doing quo-rem where you should just do the actual fraction. If the division doesn't go well, there is no way just taking the floored quotient will work! The result simply lives in the skew polynomial ring over the fraction field.

- Add in the description of the three methods that the evaluation points must be linearly independent over the fixed field of the twist map. Your current description of `eval_pts` is incorrect (the evaluation points are all in the base ring of self, and are therefore (almost) *never* linearly independent over that same ring).

- Add a doctest for a non-finite field skew polynomials. Because of the above restriction, use e.g. a skew polynomial over the fraction field of ZZ[t] instead of ZZ[t].

- Add a doctest for `minimal_vanishing_polynomial` that throws the linear-independence error. Do the same for `multi_point_evaluation` and `interpolation`.

- I removed a check from `interpolation_polynomial`. That check did not make any sense in most cases (the characteristic of `ZZ[t]` is 0 for instance).

- In `interpolation_polynomial` you've now added a check to see if the evaluations match. Two comments: 1) why are you now using multi-point evaluation for this? 2) the check is currently being done in every recursive call of `interpolation_polynomial` which is completely wasteful. Make the check only at the top level by creating a new inner function which is the actual recursive function. This top level can also be in charge of all the checks on the input lengths etc.


That's it for now, I think.

Best,
Johan



---

archive/issue_comments_288605.json:
```json
{
    "body": "Replying to [comment:4 arpitdm]:\nHowever, there is no improvement in running time of MPE as compared to the individual calls. \n\nWhat examples did you try? Which sizes of input? Which number of evaluation points? Which base fields? Which skew rings? There's many parameters here, and the speed profiles might be completely different over different choices. Please post your test code so your tests can be replicated.\n\nIf we can't find a single set of parameters for which the new multi-point evaluation is fastest, then we should just replace the method with the one-liner `return [ p(e) for e in eval_pts ]`. We could still keep the code for posterity, since e.g. after the Karatsuba implementation, a strategy such as this *should* give an improvement for large enough skew polynomials (over finite fields).\n\nBest,\nJohan",
    "created_at": "2016-07-30T16:24:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288605",
    "user": "https://github.com/johanrosenkilde"
}
```

Replying to [comment:4 arpitdm]:
However, there is no improvement in running time of MPE as compared to the individual calls. 

What examples did you try? Which sizes of input? Which number of evaluation points? Which base fields? Which skew rings? There's many parameters here, and the speed profiles might be completely different over different choices. Please post your test code so your tests can be replicated.

If we can't find a single set of parameters for which the new multi-point evaluation is fastest, then we should just replace the method with the one-liner `return [ p(e) for e in eval_pts ]`. We could still keep the code for posterity, since e.g. after the Karatsuba implementation, a strategy such as this *should* give an improvement for large enough skew polynomials (over finite fields).

Best,
Johan



---

archive/issue_comments_288606.json:
```json
{
    "body": "forgot to push my changes.\n----\nNew commits:",
    "created_at": "2016-07-30T17:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288606",
    "user": "https://github.com/johanrosenkilde"
}
```

forgot to push my changes.
----
New commits:



---

archive/issue_comments_288607.json:
```json
{
    "body": "Here are some mathematical comments:\n- I would say (but I'm not sure) that the benefit of using a divide-and-conquer method for multi-point evaluation only appears if you are using fast multication algorithms\n- the problem of \"minimum subspace polynomial\" reduces to the computation of some lcm: the minimum subspace polynomial of a family (a_1, ..., a_n) (with a_i nonzero for all i) is the left lcm of the degree 1 skew polynomials (X - sigma(a_i)/a_i). Again I think that computing it using a divide-and-conquer method is only interesting when fast multiplication and half-gcd are available (but these should be hidden at some point in Wachter-Zeh algorithm)\n- the interpolation problem is just a noncommutative CRT: finding P such that P(a_i)=b_i is equivalent to finding a skew polynomial P which is congruent to b_i modulo (X - sigma(a_i)/a_i). I think that it would be interesting in any case to implement a method CRT (and then possibly let interpolation call it, but of course it is not mandatory).",
    "created_at": "2016-08-01T23:24:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288607",
    "user": "https://github.com/xcaruso"
}
```

Here are some mathematical comments:
- I would say (but I'm not sure) that the benefit of using a divide-and-conquer method for multi-point evaluation only appears if you are using fast multication algorithms
- the problem of "minimum subspace polynomial" reduces to the computation of some lcm: the minimum subspace polynomial of a family (a_1, ..., a_n) (with a_i nonzero for all i) is the left lcm of the degree 1 skew polynomials (X - sigma(a_i)/a_i). Again I think that computing it using a divide-and-conquer method is only interesting when fast multiplication and half-gcd are available (but these should be hidden at some point in Wachter-Zeh algorithm)
- the interpolation problem is just a noncommutative CRT: finding P such that P(a_i)=b_i is equivalent to finding a skew polynomial P which is congruent to b_i modulo (X - sigma(a_i)/a_i). I think that it would be interesting in any case to implement a method CRT (and then possibly let interpolation call it, but of course it is not mandatory).



---

archive/issue_comments_288608.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-02T09:48:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288608",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288609.json:
```json
{
    "body": "Merged the newest 13215 into this branch.",
    "created_at": "2016-08-02T09:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288609",
    "user": "https://github.com/johanrosenkilde"
}
```

Merged the newest 13215 into this branch.



---

archive/issue_comments_288610.json:
```json
{
    "body": "Hi Xavier,\n\nGreat to see that you're listening in :-)\n\nReplying to [comment:9 caruso]:\n> Here are some mathematical comments:\n> - I would say (but I'm not sure) that the benefit of using a divide-and-conquer method for multi-point evaluation only appears if you are using fast multication algorithms\n\nI believe you're right, but I only thought about it after Arpit had already implemented it. So now I think we might as well look at its running time rather than guessing.\n\n> - the problem of \"minimum subspace polynomial\" reduces to the computation of some lcm: the minimum subspace polynomial of a family (a_1, ..., a_n) (with a_i nonzero for all i) is the left lcm of the degree 1 skew polynomials (X - sigma(a_i)/a_i). Again I think that computing it using a divide-and-conquer method is only interesting when fast multiplication and half-gcd are available (but these should be hidden at some point in Wachter-Zeh algorithm)\n\nHmm, yes, I hadn't thought about that. However, I don't see why doing successive `left_lcm` wouldn't be cubic complexity? It is easy to do a divide & conquer-version of the successive lcm (see below) which should be quadratic however:\n\n\n```\ndef mvp_lcm(S, pts):\n    x = S.gen()\n    p = S.one()\n    for a in pts:\n        q = x - sigma(a)/a\n        p = p.left_lcm(q)\n    return p\n\ndef mvp_lcm_dc(S, pts):\n    x = S.gen()\n    def rec(pts):\n        if len(pts) > 1:\n            t = len(pts)//2\n            left  = mvp_lcm_dc(S, pts[:t])\n            right = mvp_lcm_dc(S, pts[t:])\n            return left.left_lcm(right)\n        else:\n            return x - sigma(pts[0])/pts[0]\n    return rec(pts)\n```\n\n\nI did some experiments. Over finite fields, the D&C lcm wins:\n\n\n```\nm = 400\nk.<a> = GF(2^m,'a')\nsigma = k.frobenius_endomorphism()\nS.<x> = k['x', sigma]\n\npts = [ k.random_element() for i in range(m//2) ]\nassert not(0 in set(pts)) , \"zero not allowed in the set (try again)\"\nassert len(set(pts)) == len(pts) , \"the set contains duplicates (try again)\"\n\n%timeit S.minimal_vanishing_polynomial(pts)\n1 loop, best of 3: 756 ms per loop\n\n%timeit mvp_lcm(S, pts)\n1 loop, best of 3: 773 ms per loop\n\n%timeit mvp_lcm_dc(S, pts)\n1 loop, best of 3: 369 ms per loop\n```\n\n\nHowever, over a field with coefficient-growth, the implemented version wins:\n\n\n```\nm = 10\nR.<t> = QQ[]\nQR = R.fraction_field()\nt = QR(t)\nsigma = QR.hom([t+1])\nS.<x> = QR['x', sigma]\n\npts = [ QR.random_element(degree=3) for i in range(m//2) ]\nassert not(0 in set(pts)) , \"zero not allowed in the set (try again)\"\nassert len(set(pts)) == len(pts) , \"the set contains duplicates (try again)\"\n\n\n%timeit S.minimal_vanishing_polynomial(pts)\n10 loops, best of 3: 108 ms per loop\n\n%timeit mvp_lcm(S, pts)\n1 loop, best of 3: 386 ms per loop\n\n%timeit mvp_lcm_dc(S, pts)\n1 loop, best of 3: 835 ms per loop\n```\n\n\nThe above timings vary a lot with the size of the fractions that were randomly drawn, but the relative ranking between the methods seems to stay put.\n\n\n> - the interpolation problem is just a noncommutative CRT: finding P such that P(a_i)=b_i is equivalent to finding a skew polynomial P which is congruent to b_i modulo (X - sigma(a_i)/a_i). I think that it would be interesting in any case to implement a method CRT (and then possibly let interpolation call it, but of course it is not mandatory).\n\nThat's a good idea. Feel free to do that. We are on a pretty tight schedule with Arpit's Google Summer of Code, so that won't be a priority for us now.\n\nBest,\nJohan",
    "created_at": "2016-08-02T10:28:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288610",
    "user": "https://github.com/johanrosenkilde"
}
```

Hi Xavier,

Great to see that you're listening in :-)

Replying to [comment:9 caruso]:
> Here are some mathematical comments:
> - I would say (but I'm not sure) that the benefit of using a divide-and-conquer method for multi-point evaluation only appears if you are using fast multication algorithms

I believe you're right, but I only thought about it after Arpit had already implemented it. So now I think we might as well look at its running time rather than guessing.

> - the problem of "minimum subspace polynomial" reduces to the computation of some lcm: the minimum subspace polynomial of a family (a_1, ..., a_n) (with a_i nonzero for all i) is the left lcm of the degree 1 skew polynomials (X - sigma(a_i)/a_i). Again I think that computing it using a divide-and-conquer method is only interesting when fast multiplication and half-gcd are available (but these should be hidden at some point in Wachter-Zeh algorithm)

Hmm, yes, I hadn't thought about that. However, I don't see why doing successive `left_lcm` wouldn't be cubic complexity? It is easy to do a divide & conquer-version of the successive lcm (see below) which should be quadratic however:


```
def mvp_lcm(S, pts):
    x = S.gen()
    p = S.one()
    for a in pts:
        q = x - sigma(a)/a
        p = p.left_lcm(q)
    return p

def mvp_lcm_dc(S, pts):
    x = S.gen()
    def rec(pts):
        if len(pts) > 1:
            t = len(pts)//2
            left  = mvp_lcm_dc(S, pts[:t])
            right = mvp_lcm_dc(S, pts[t:])
            return left.left_lcm(right)
        else:
            return x - sigma(pts[0])/pts[0]
    return rec(pts)
```


I did some experiments. Over finite fields, the D&C lcm wins:


```
m = 400
k.<a> = GF(2^m,'a')
sigma = k.frobenius_endomorphism()
S.<x> = k['x', sigma]

pts = [ k.random_element() for i in range(m//2) ]
assert not(0 in set(pts)) , "zero not allowed in the set (try again)"
assert len(set(pts)) == len(pts) , "the set contains duplicates (try again)"

%timeit S.minimal_vanishing_polynomial(pts)
1 loop, best of 3: 756 ms per loop

%timeit mvp_lcm(S, pts)
1 loop, best of 3: 773 ms per loop

%timeit mvp_lcm_dc(S, pts)
1 loop, best of 3: 369 ms per loop
```


However, over a field with coefficient-growth, the implemented version wins:


```
m = 10
R.<t> = QQ[]
QR = R.fraction_field()
t = QR(t)
sigma = QR.hom([t+1])
S.<x> = QR['x', sigma]

pts = [ QR.random_element(degree=3) for i in range(m//2) ]
assert not(0 in set(pts)) , "zero not allowed in the set (try again)"
assert len(set(pts)) == len(pts) , "the set contains duplicates (try again)"


%timeit S.minimal_vanishing_polynomial(pts)
10 loops, best of 3: 108 ms per loop

%timeit mvp_lcm(S, pts)
1 loop, best of 3: 386 ms per loop

%timeit mvp_lcm_dc(S, pts)
1 loop, best of 3: 835 ms per loop
```


The above timings vary a lot with the size of the fractions that were randomly drawn, but the relative ranking between the methods seems to stay put.


> - the interpolation problem is just a noncommutative CRT: finding P such that P(a_i)=b_i is equivalent to finding a skew polynomial P which is congruent to b_i modulo (X - sigma(a_i)/a_i). I think that it would be interesting in any case to implement a method CRT (and then possibly let interpolation call it, but of course it is not mandatory).

That's a good idea. Feel free to do that. We are on a pretty tight schedule with Arpit's Google Summer of Code, so that won't be a priority for us now.

Best,
Johan



---

archive/issue_comments_288611.json:
```json
{
    "body": "I just made some more experiments: changing `multi_point_evaluation` into the trivial `return [ p(e) for e in eval_pts ]` then `minimal_vanishing_polynomial` is much faster. It beats the other two alternatives in both domains.\n\nI think for now, `multi_point_evaluation` should be changed to just that simple function. As an orthogonal concern, I think that method should be a method on skew polynomials, not on the ring.",
    "created_at": "2016-08-02T11:11:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288611",
    "user": "https://github.com/johanrosenkilde"
}
```

I just made some more experiments: changing `multi_point_evaluation` into the trivial `return [ p(e) for e in eval_pts ]` then `minimal_vanishing_polynomial` is much faster. It beats the other two alternatives in both domains.

I think for now, `multi_point_evaluation` should be changed to just that simple function. As an orthogonal concern, I think that method should be a method on skew polynomials, not on the ring.



---

archive/issue_comments_288612.json:
```json
{
    "body": "Replying to [comment:13 jsrn]:\n> I just made some more experiments: changing `multi_point_evaluation` into the trivial `return [ p(e) for e in eval_pts ]` then `minimal_vanishing_polynomial` is much faster. It beats the other two alternatives in both domains.\n> \nBut maybe the fast multiplication and related methods once available, will improve the speed. I am not sure it makes sense to have a method to simply call the evaluate method `n` times. Users can do that themselves. I think we should keep the D&C implementation and use the trivial calling wherever we are using it right now, with a note that says call MPE once that is fast.\n> I think for now, `multi_point_evaluation` should be changed to just that simple function. As an orthogonal concern, I think that method should be a method on skew polynomials, not on the ring.\nAgreed. It is a method every skew polynomial should have if it is fast.",
    "created_at": "2016-08-02T11:25:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288612",
    "user": "https://github.com/arpitdm"
}
```

Replying to [comment:13 jsrn]:
> I just made some more experiments: changing `multi_point_evaluation` into the trivial `return [ p(e) for e in eval_pts ]` then `minimal_vanishing_polynomial` is much faster. It beats the other two alternatives in both domains.
> 
But maybe the fast multiplication and related methods once available, will improve the speed. I am not sure it makes sense to have a method to simply call the evaluate method `n` times. Users can do that themselves. I think we should keep the D&C implementation and use the trivial calling wherever we are using it right now, with a note that says call MPE once that is fast.
> I think for now, `multi_point_evaluation` should be changed to just that simple function. As an orthogonal concern, I think that method should be a method on skew polynomials, not on the ring.
Agreed. It is a method every skew polynomial should have if it is fast.



---

archive/issue_comments_288613.json:
```json
{
    "body": "Replying to [comment:14 arpitdm]:\n> But maybe the fast multiplication and related methods once available, will improve the speed. I am not sure it makes sense to have a method to simply call the evaluate method `n` times. Users can do that themselves. I think we should keep the D&C implementation and use the trivial calling wherever we are using it right now, with a note that says call MPE once that is fast.\n\nI disagree: if the method is there, it should in all cases be at least as fast\nas what a user could simply do himself. It would be nice if we could find a skew polynomial ring for which the current implementation is fastest, but it probably doesn't exist. Therefore, we have, IMHO, two options: 1) not having the method at all; or 2) having the method with the trivial implementation. I vote for the latter because of three things: A) a fast implementation will come at one point (hopefully; B) `minimal_vanishing_polynomial` wouldn't have to change once a fast implementation of multi-point evaluation is there; and C) it is good to advertise multi-point evaluation to users, so that their code uses that, and will therefore automatically be fast with fast implementations.\n\n> > I think for now, `multi_point_evaluation` should be changed to just that simple function. As an orthogonal concern, I think that method should be a method on skew polynomials, not on the ring.\n> Agreed. It is a method every skew polynomial should have if it is fast.\n\nOK\n\nBest, Johan",
    "created_at": "2016-08-02T11:38:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288613",
    "user": "https://github.com/johanrosenkilde"
}
```

Replying to [comment:14 arpitdm]:
> But maybe the fast multiplication and related methods once available, will improve the speed. I am not sure it makes sense to have a method to simply call the evaluate method `n` times. Users can do that themselves. I think we should keep the D&C implementation and use the trivial calling wherever we are using it right now, with a note that says call MPE once that is fast.

I disagree: if the method is there, it should in all cases be at least as fast
as what a user could simply do himself. It would be nice if we could find a skew polynomial ring for which the current implementation is fastest, but it probably doesn't exist. Therefore, we have, IMHO, two options: 1) not having the method at all; or 2) having the method with the trivial implementation. I vote for the latter because of three things: A) a fast implementation will come at one point (hopefully; B) `minimal_vanishing_polynomial` wouldn't have to change once a fast implementation of multi-point evaluation is there; and C) it is good to advertise multi-point evaluation to users, so that their code uses that, and will therefore automatically be fast with fast implementations.

> > I think for now, `multi_point_evaluation` should be changed to just that simple function. As an orthogonal concern, I think that method should be a method on skew polynomials, not on the ring.
> Agreed. It is a method every skew polynomial should have if it is fast.

OK

Best, Johan



---

archive/issue_comments_288614.json:
```json
{
    "body": "Replying to [comment:5 jsrn]:\n>   I hadn't thought of that before. Add a check at the beginning of the call. If `R` is not a field, then construct the skew polynomial ring over the fraction field and return the result of the call from there. Do the same with the two other methods.\n\n\n```\nif not isinstance(R, Field):\n   Q = R.fraction_field()\n   t = Q(R.gen())\n   S = Q[self.variable_name(), sigma]\n```\n\nFor example if we have some twist map of the original skew polynomial ring based on R `sigma`, what's the proper way of converting to the equivalent twist map over the fraction field of R?",
    "created_at": "2016-08-03T01:54:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288614",
    "user": "https://github.com/arpitdm"
}
```

Replying to [comment:5 jsrn]:
>   I hadn't thought of that before. Add a check at the beginning of the call. If `R` is not a field, then construct the skew polynomial ring over the fraction field and return the result of the call from there. Do the same with the two other methods.


```
if not isinstance(R, Field):
   Q = R.fraction_field()
   t = Q(R.gen())
   S = Q[self.variable_name(), sigma]
```

For example if we have some twist map of the original skew polynomial ring based on R `sigma`, what's the proper way of converting to the equivalent twist map over the fraction field of R?



---

archive/issue_comments_288615.json:
```json
{
    "body": "Replying to [comment:16 arpitdm]:\n> Replying to [comment:5 jsrn]:\n> {{{\n> if not isinstance(R, Field):\n>    Q = R.fraction_field()\n>    t = Q(R.gen())\n>    S = Q[self.variable_name(), sigma]\n> }}}\n> For example if we have some twist map of the original skew polynomial ring based on R `sigma`, what's the proper way of converting to the equivalent twist map over the fraction field of R? \n\nThat's a good question. Off the top of my hat, I don't immediately see how to do that in a bullet-proof fashion. However, the following should work for all finitely generated rings: construct a `sigma_frac` from `sigma` as the homomorphism whose image on the the generators is as `sigma`. Something like (untested):\n\n\n```\n    Q = R.fraction_field()\n    gens = R.gens()\n    sigma_frac = Q.hom([ Q(sigma(g)) for g in gens ])\n```\n\n\nYou'd better wrap that in a try-except and throw a `ValueError: Unable to lift the twist map to a twist map over <insert Q here>` or something.\n\nBest,\nJohan",
    "created_at": "2016-08-03T07:16:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288615",
    "user": "https://github.com/johanrosenkilde"
}
```

Replying to [comment:16 arpitdm]:
> Replying to [comment:5 jsrn]:
> {{{
> if not isinstance(R, Field):
>    Q = R.fraction_field()
>    t = Q(R.gen())
>    S = Q[self.variable_name(), sigma]
> }}}
> For example if we have some twist map of the original skew polynomial ring based on R `sigma`, what's the proper way of converting to the equivalent twist map over the fraction field of R? 

That's a good question. Off the top of my hat, I don't immediately see how to do that in a bullet-proof fashion. However, the following should work for all finitely generated rings: construct a `sigma_frac` from `sigma` as the homomorphism whose image on the the generators is as `sigma`. Something like (untested):


```
    Q = R.fraction_field()
    gens = R.gens()
    sigma_frac = Q.hom([ Q(sigma(g)) for g in gens ])
```


You'd better wrap that in a try-except and throw a `ValueError: Unable to lift the twist map to a twist map over <insert Q here>` or something.

Best,
Johan



---

archive/issue_comments_288616.json:
```json
{
    "body": "I've made the following changes based on discussions above:\n1. created twist map over the fraction field. fixed methods to accommodate fraction fields.\n2. refactored mvp and interpolation to have inner functions that are called recursively so that the checks on the arguments are made only at the top level.\n3. changed method `MPE` to the trivial repeated calling of the evaluate method and moved this to `class Skew_Polynomial`.\n\nI'm opening the ticket for review now.\n\nBest,\nArpit.\n----\nLast 10 new commits:",
    "created_at": "2016-08-08T00:17:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288616",
    "user": "https://github.com/arpitdm"
}
```

I've made the following changes based on discussions above:
1. created twist map over the fraction field. fixed methods to accommodate fraction fields.
2. refactored mvp and interpolation to have inner functions that are called recursively so that the checks on the arguments are made only at the top level.
3. changed method `MPE` to the trivial repeated calling of the evaluate method and moved this to `class Skew_Polynomial`.

I'm opening the ticket for review now.

Best,
Arpit.
----
Last 10 new commits:



---

archive/issue_comments_288617.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-08-08T00:17:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288617",
    "user": "https://github.com/arpitdm"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_288618.json:
```json
{
    "body": "The three methods are mutually recursive, so you're still for instance re-creating the same polynomial ring over and over again in the recursive calls. You should make three top-level private functions, without the checks, and all the mutually recursive calls will call those top-level private functions, taking the correct target ring as an input.\n\nThe creation of the fraction-field skew-poly-ring should be a helper function since it's duplicated code. But make it a private function.\n\nBest,\nJohan",
    "created_at": "2016-08-09T18:05:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288618",
    "user": "https://github.com/johanrosenkilde"
}
```

The three methods are mutually recursive, so you're still for instance re-creating the same polynomial ring over and over again in the recursive calls. You should make three top-level private functions, without the checks, and all the mutually recursive calls will call those top-level private functions, taking the correct target ring as an input.

The creation of the fraction-field skew-poly-ring should be a helper function since it's duplicated code. But make it a private function.

Best,
Johan



---

archive/issue_comments_288619.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-08-09T18:05:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288619",
    "user": "https://github.com/johanrosenkilde"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_288620.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-10T13:24:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288620",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288621.json:
```json
{
    "body": "I created three new private functions namely `_gen_one_sigma`, `_create_mvp` and `_interpolate`. Are these names alright? \n\nBest,\nArpit.",
    "created_at": "2016-08-10T13:31:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288621",
    "user": "https://github.com/arpitdm"
}
```

I created three new private functions namely `_gen_one_sigma`, `_create_mvp` and `_interpolate`. Are these names alright? 

Best,
Arpit.



---

archive/issue_comments_288622.json:
```json
{
    "body": "Replying to [comment:23 arpitdm]:\n> I created three new private functions namely `_gen_one_sigma`, `_create_mvp` and `_interpolate`. Are these names alright? \n\n`_gen_one_sigma` is a pretty terrible name. I previously suggested `_base_ring_to_fraction_field`, but perhaps that mail was accidentally only \"Reply\" to David instead of \"Reply all\".\n\n`_create_mvp` is suggest `_minimal_vanishing_polynomial`, i.e. exactly the same name as the main function, but with an underscore.\n\nBest,\nJohan",
    "created_at": "2016-08-10T22:58:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288622",
    "user": "https://github.com/johanrosenkilde"
}
```

Replying to [comment:23 arpitdm]:
> I created three new private functions namely `_gen_one_sigma`, `_create_mvp` and `_interpolate`. Are these names alright? 

`_gen_one_sigma` is a pretty terrible name. I previously suggested `_base_ring_to_fraction_field`, but perhaps that mail was accidentally only "Reply" to David instead of "Reply all".

`_create_mvp` is suggest `_minimal_vanishing_polynomial`, i.e. exactly the same name as the main function, but with an underscore.

Best,
Johan



---

archive/issue_comments_288623.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-11T16:56:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288623",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288624.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-08-11T17:01:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288624",
    "user": "https://github.com/arpitdm"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_288625.json:
```json
{
    "body": "Hello,\n\nI just have a few comments:\n\n`interpolation_polynomial`:\n\n- It does not respect the docstring format: there should be a line break after\n  \"Return the interpolation polynomial\"\n\n- It's not much, but I think it would be a bit better if the description of \n  `eval_pts` was the same in the documentation of `_interpolation`` and\n  `interpolation_polynomial`\n\n`minimal_vanishing_polynomial`:\n\n- Same remark as above regarding the docstring format...\n\n- And regarding \"consistency\" between description of input arguments.\n\nBest,\n\nDavid",
    "created_at": "2016-08-12T11:26:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288625",
    "user": "https://trac.sagemath.org/admin/accounts/users/dlucas"
}
```

Hello,

I just have a few comments:

`interpolation_polynomial`:

- It does not respect the docstring format: there should be a line break after
  "Return the interpolation polynomial"

- It's not much, but I think it would be a bit better if the description of 
  `eval_pts` was the same in the documentation of `_interpolation`` and
  `interpolation_polynomial`

`minimal_vanishing_polynomial`:

- Same remark as above regarding the docstring format...

- And regarding "consistency" between description of input arguments.

Best,

David



---

archive/issue_comments_288626.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-12T13:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288626",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288627.json:
```json
{
    "body": "Hi David,\n\nI've made the changes you proposed. Opening it for review again.\n\nBest,\nArpit.",
    "created_at": "2016-08-12T13:34:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288627",
    "user": "https://github.com/arpitdm"
}
```

Hi David,

I've made the changes you proposed. Opening it for review again.

Best,
Arpit.



---

archive/issue_comments_288628.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-08-16T16:34:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288628",
    "user": "https://github.com/johanrosenkilde"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_288629.json:
```json
{
    "body": "I made a number of modifications: \n\n- Renamed `interpolation` to `lagrange_polynomial` to match `PolynomialRing`.\n  Also changed the calling convention for this.\n\n- Simplified `_base_ring_to_fraction_field`: it is much simpler and nicer to\n  just return the constructed ring.\n\n- Moved the helper functions outside the class.\n\n- Allow MVP to get input which is linearly dependent over the fixed field of the twist map. In this case, the degree will simply be lower. Removed the `check` argument.\n\n- Removed the `check` argument from `lagrange_polynomial` and simply detect the\n  linear dependence (an evaluation point will become 0 during a recursive call).\n\n- General improvements to docstrings and tests\n\nI tried for a while to make `lagrange_polynomial` accept linearly dependent evaluation points, and then only fail if the values were not similarly dependent (recall that if e.g. the last evaluation point is linearly dependent on the rest, then the value that *any* skew polynomial takes on that last evaluation point is the corresponding linear combination of the value it takes on the previous evaluation points). But the algorithm doesn't seem to be able to detect *what* the linear dependence is in a convenient way, so I gave up and decided to simply throw an exception.\n\nPlease check the compiled doc. I have no more time today.\n\nBest,\nJohan\n----\nNew commits:",
    "created_at": "2016-08-16T16:34:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288629",
    "user": "https://github.com/johanrosenkilde"
}
```

I made a number of modifications: 

- Renamed `interpolation` to `lagrange_polynomial` to match `PolynomialRing`.
  Also changed the calling convention for this.

- Simplified `_base_ring_to_fraction_field`: it is much simpler and nicer to
  just return the constructed ring.

- Moved the helper functions outside the class.

- Allow MVP to get input which is linearly dependent over the fixed field of the twist map. In this case, the degree will simply be lower. Removed the `check` argument.

- Removed the `check` argument from `lagrange_polynomial` and simply detect the
  linear dependence (an evaluation point will become 0 during a recursive call).

- General improvements to docstrings and tests

I tried for a while to make `lagrange_polynomial` accept linearly dependent evaluation points, and then only fail if the values were not similarly dependent (recall that if e.g. the last evaluation point is linearly dependent on the rest, then the value that *any* skew polynomial takes on that last evaluation point is the corresponding linear combination of the value it takes on the previous evaluation points). But the algorithm doesn't seem to be able to detect *what* the linear dependence is in a convenient way, so I gave up and decided to simply throw an exception.

Please check the compiled doc. I have no more time today.

Best,
Johan
----
New commits:



---

archive/issue_comments_288630.json:
```json
{
    "body": "Changing keywords from \"\" to \"sd75\".",
    "created_at": "2016-08-24T15:21:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288630",
    "user": "https://github.com/johanrosenkilde"
}
```

Changing keywords from "" to "sd75".



---

archive/issue_comments_288631.json:
```json
{
    "body": "Based on discussions, we are putting the SkewPolynomial_finite_field class on hold. The `multi_point_evaluation` method is in the `skew_polynomial_element.pyx` file and the `interpolation` and `minimum_vanishing_polynomial` methods are in the `skew_polynomial_ring.py` file. This ticket does not depend on the finite fields ticket and the last discussion (during SD75) was that the history would have to be rewritten. I just want to confirm that that's still the direction to take and then I will push the changes.",
    "created_at": "2016-10-08T05:57:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288631",
    "user": "https://github.com/arpitdm"
}
```

Based on discussions, we are putting the SkewPolynomial_finite_field class on hold. The `multi_point_evaluation` method is in the `skew_polynomial_element.pyx` file and the `interpolation` and `minimum_vanishing_polynomial` methods are in the `skew_polynomial_ring.py` file. This ticket does not depend on the finite fields ticket and the last discussion (during SD75) was that the history would have to be rewritten. I just want to confirm that that's still the direction to take and then I will push the changes.



---

archive/issue_comments_288632.json:
```json
{
    "body": "Agreed, let's go ahead with it!",
    "created_at": "2016-10-08T09:50:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288632",
    "user": "https://github.com/johanrosenkilde"
}
```

Agreed, let's go ahead with it!



---

archive/issue_comments_288633.json:
```json
{
    "body": "I've removed the dependency on the finite field class. Multi-point evaluation, minimum vanishing polynomial and Lagrange interpolation are now available in the original files from #13215. \n----\nNew commits:",
    "created_at": "2016-10-09T20:00:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288633",
    "user": "https://github.com/arpitdm"
}
```

I've removed the dependency on the finite field class. Multi-point evaluation, minimum vanishing polynomial and Lagrange interpolation are now available in the original files from #13215. 
----
New commits:



---

archive/issue_comments_288634.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-10-11T15:09:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288634",
    "user": "https://github.com/arpitdm"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_288635.json:
```json
{
    "body": "Coming back to it now, I feel sort of silly finalising the review myself, since the latest version was written by me. I feel that the last step is that someone should review my modifications.\n\nI've tried to understand what you did in commit 0572e85, but it's not clear to me. All the finite field stuff is still showing up in the log, and have just been removed again -- did you just remove them in the merge commit 0572e85?\n\nBest,\nJohan",
    "created_at": "2016-10-18T13:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288635",
    "user": "https://github.com/johanrosenkilde"
}
```

Coming back to it now, I feel sort of silly finalising the review myself, since the latest version was written by me. I feel that the last step is that someone should review my modifications.

I've tried to understand what you did in commit 0572e85, but it's not clear to me. All the finite field stuff is still showing up in the log, and have just been removed again -- did you just remove them in the merge commit 0572e85?

Best,
Johan



---

archive/issue_comments_288636.json:
```json
{
    "body": "I fixed some small doc markup issues. Otherwise the code looks good to me.\n----\nNew commits:",
    "created_at": "2016-10-18T14:18:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288636",
    "user": "https://github.com/johanrosenkilde"
}
```

I fixed some small doc markup issues. Otherwise the code looks good to me.
----
New commits:



---

archive/issue_comments_288637.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-02-07T12:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288637",
    "user": "https://github.com/arpitdm"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_288638.json:
```json
{
    "body": "Thanks",
    "created_at": "2017-02-07T14:48:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288638",
    "user": "https://github.com/johanrosenkilde"
}
```

Thanks



---

archive/issue_comments_288639.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-02-11T10:24:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20894#issuecomment-288639",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_019818.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2017-02-11T10:24:08Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/20894",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/20894#event-19818"
}
```
