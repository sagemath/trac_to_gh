# Issue 29879: Replace __eq__ by _richcmp_ for scalar and tensor fields

Issue created by migration from https://trac.sagemath.org/ticket/30116

Original creator: @mjungmath

Original creation time: 2020-07-11 22:55:28

CC:  egourgoulhon tscrim mkoeppe

Keywords: manifolds, coercion

Within the coercion frameworks, two objects are usually compared by using `_richcmp_`. Using this, both objects are coerced into an element of a common parent before the comparison is performed. The current implementation uses `__eq__` instead and involves no prior coercion.

In this ticket, the method `__eq__` is replaced by `_richcmp_` as intended by the coercion framework.


---

Comment by @mjungmath created at 2020-07-11 22:59:22

New commits:


---

Comment by git created at 2020-07-11 23:05:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-07-11 23:09:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-11 23:09:24

Changing status from new to needs_review.


---

Comment by @mjungmath created at 2020-07-11 23:24:57

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-07-11 23:42:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-11 23:47:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-11 23:48:32

Changing status from needs_work to needs_info.


---

Comment by git created at 2020-07-12 07:25:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-12 07:27:56

Changing status from needs_info to needs_review.


---

Comment by @mjungmath created at 2020-07-12 11:01:22

I am sorry. I am too impatient. Anyway, I get the following error during the doctest:


```
File "src/sage/manifolds/section.py", line 2401, in sage.manifolds.section.TrivialSection.restrict
Failed example:
    s_D[[1]] == s[[1]]
Expected:
    False
Got:
    True
```


Here is the complete related doctest:


```
sage: M = Manifold(2, 'R^2')
sage: c_cart.<x,y> = M.chart() # Cartesian coordinates on R^2
sage: E = M.vector_bundle(2, 'E')
sage: e = E.local_frame('e') # makes E trivial
sage: s = E.section(x+y, -1+x^2, name='s')
sage: D = M.open_subset('D') # the unit open disc
sage: e_D = e.restrict(D)
sage: c_cart_D = c_cart.restrict(D, x^2+y^2<1)
sage: s_D = s.restrict(D) ; s_D
Section s on the Open subset D of the 2-dimensional differentiable
 manifold R^2 with values in the real vector bundle E of rank 2

...

sage: s_D[[1]] == s[[1]]
False
```



With respect to the coercion model, the output is perfectly fine: the section `s` can be restricted to `D`. Thus there exists a coercion from sections on `M` to sections on `D`. The equality check then takes places on the sections on `D`.

Should I simply rewrite this doctest, or what is the best procedure here?

For consistency, the same should then hold for chart functions, too. Meaning the following command right above should then return `True` as well:


```
sage: s_D[1] == s[1]
```



---

Comment by @mjungmath created at 2020-07-12 11:01:22

Changing status from needs_review to needs_info.


---

Comment by git created at 2020-07-12 11:05:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-12 12:16:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-14 17:07:20

Changing component from geometry to manifolds.


---

Comment by egourgoulhon created at 2020-07-15 15:07:24

Replying to [comment:14 gh-mjungmath]:
> 
> 
> With respect to the coercion model, the output is perfectly fine: the section `s` can be restricted to `D`. Thus there exists a coercion from sections on `M` to sections on `D`. The equality check then takes places on the sections on `D`.
> 
> Should I simply rewrite this doctest, or what is the best procedure here?
> 
> For consistency, the same should then hold for chart functions, too. Meaning the following command right above should then return `True` as well:
> 
> {{{
> sage: s_D[1] == s[1]
> }}}
> 
I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`.


---

Comment by @mjungmath created at 2020-07-15 21:20:43

Replying to [comment:25 egourgoulhon]:
> I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`. 

For matrices, things are even more distracting than in our particular case:


```
sage: MatrixSpace(QQ, 3, 3)(2)
[2 0 0]
[0 2 0]
[0 0 2]
sage: MatrixSpace(QQ, 3, 3)(2) == 2
True 
```


Digging in the documentation, I've found: 

_The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets._

From this perspective, the matrix code example above makes somewhat sense, and so it would in our case.


---

Comment by git created at 2020-07-15 22:22:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-07-16 09:34:28

Replying to [comment:26 gh-mjungmath]:
> Replying to [comment:25 egourgoulhon]:
> > I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`. 
> 
> For matrices, things are even more distracting than in our particular case:
> 
> {{{
> sage: MatrixSpace(QQ, 3, 3)(2)
> [2 0 0]
> [0 2 0]
> [0 0 2]
> sage: MatrixSpace(QQ, 3, 3)(2) == 2
> True 
> }}}
> 
> Digging in the documentation, I've found: 
> 
> _The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets._
> 
> From this perspective, the matrix code example above makes somewhat sense, and so it would in our case.

Allow me to give another example:



```
sage: GF(5)(7) == 2
True
```


We cannot recover `7` from the finite field again. Furthermore the representative of `7` in `GF(5)` and the number `2` are certainly two distinct mathematical objects. Sure, this equality must be seen in terms of congruences. Now, I think we can see the equality of restricted functions somehow similarly. (Forget about the sheafs, that was nonsense.)


---

Comment by egourgoulhon created at 2020-07-16 14:37:52

Replying to [comment:29 gh-mjungmath]:
> > 
> > For matrices, things are even more distracting than in our particular case:
> > 
> > {{{
> > sage: MatrixSpace(QQ, 3, 3)(2) == 2
> > True 
> > }}}
> > 
> 
> Allow me to give another example:
> 
> 
> {{{
> sage: GF(5)(7) == 2
> True
> }}}
> 
Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...


---

Comment by @mjungmath created at 2020-07-16 14:58:33

Replying to [comment:30 egourgoulhon]:
> Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...

Mh, okay. I see your point. Nevertheles, we allow addition and multiplication between a scalar field and a restricted scalar field, which comes with the very same problem, doesn't it?

Imho, there should be no coercion for restrictions when we do not allow a comparison for them. Simply because they don't fit into the coercion model then.

I am curious about their opinion, too. :)


---

Comment by egourgoulhon created at 2020-07-16 15:16:48

Replying to [comment:31 gh-mjungmath]:
> Replying to [comment:30 egourgoulhon]:
> > Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...
> 
> Mh, okay. I see your point. Nevertheles, we allow addition and multiplication between a scalar field and a restricted scalar field, 

indeed.

>which comes with the very same problem, doesn't it?

Maybe it is a matter of taste but `a*b` resulting in a scalar field on the common subdomain of `a` and `b` seems less error prone to me than `a == b` returning `True`. 
> 
> Imho, there should be no coercion for restrictions when we do not allow a comparison for them. Simply because they don't fit into the coercion model then.

I agree that to fully fit with the coercion model, we should allow comparison as proposed in this ticket. 

> However, one can still allow some kind of conversions right?
> 
> I am curious about their opinion, too. :)

In particular, are there other structures in Sage that implement the coercion model but for comparison?


---

Comment by @mjungmath created at 2020-07-16 19:03:24

Okay, I thought about it once again, and I tend to agree. If we would apply the changes I propose, the following code would return `True`:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U')
sage: f = M.scalar_field('f')
sage: A_U = U.scalar_field_algebra()
sage: f in A_U
True
```


And as you, Eric, already pointed out, that is definitely not what we want.

If I understand this correctly, and two coercible elements **must** always be comparable, I vote for keeping the _conversion_:


```
sage: A_U(f) in A_U
True
```


but removing the _coercion_ from the populated list, i.e.


```diff
-        elif isinstance(other, ScalarFieldAlgebra):
-            return self._domain.is_subset(other._domain)
```


in `_coerce_map_from_` of the file `scalarfield_algebra.py`.

I know, this is inconvenient when it comes to addition and multiplication of restricted elements. On the other hand, it would be consistent with Sage's coercion model then. It is therefore mandatory to investigate if coercible elements must always be comparable or not.

**Addendum:** see https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#equality-and-element-containment for details.

As pointed out in this article, one could also simply overwrite `__contains__` and still keep the equality test...


---

Comment by tscrim created at 2020-07-17 05:12:06

Replying to [comment:32 egourgoulhon]:
> Maybe it is a matter of taste but `a*b` resulting in a scalar field on the common subdomain of `a` and `b` seems less error prone to me than `a == b` returning `True`. 

If you want the multiplication (by coercion), then you have to also allow the equality check unless you explicitly disallow comparisons under coercion.

The equality test in both ways makes sense, it just depends on whether you want to consider them as completely different functions (with incompatible domains) or you want to do an actual comparison of the functions on the same common domain. The issue is `==` inherently does not ask you to specify the type of equality, which we generally assume from context (usually by adding prose when saying two functions are equal). We leave the choice of the semantics of `==` up to the developer of a particular block of code. Yet, the existence of the coercion means the two objects should inherently be (naturally) relatable.

If you still want the multiplication and do not want the equality, then you can implement the multiplication as an action (with the `M` scalar field acting on the `U` one).

My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.

TL;DR It depends on what you think is the most natural semantic, and it is your choice.


---

Comment by egourgoulhon created at 2020-07-17 13:22:44

Replying to [comment:34 tscrim]: 
> My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.
> 
> TL;DR It depends on what you think is the most natural semantic, and it is your choice.


Thanks for your explanations and advice. 
Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.


---

Comment by egourgoulhon created at 2020-07-17 13:23:53

Replying to [comment:33 gh-mjungmath]:
> 
> As pointed out in this article, one could also simply overwrite `__contains__` and still keep the equality test...

Indeed!


---

Comment by @mjungmath created at 2020-07-17 16:14:40

Replying to [comment:35 egourgoulhon]:
> Replying to [comment:34 tscrim]: 
> > My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.
> > 
> > TL;DR It depends on what you think is the most natural semantic, and it is your choice.
> 
> 
> Thanks for your explanations and advice. 
> Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.  
> 

In that case, I would overwrite `__contains__` and add this exception since `M.scalar_field() in U.scalar_field_algebra()` returning `True` is certainly unwanted. Agreed? Should I proceed similarly for the coercion implemented in #30112? This coercion is also convenient, but the containment check should return `False`, too.


---

Comment by egourgoulhon created at 2020-07-18 14:40:49

Replying to [comment:37 gh-mjungmath]:
> Replying to [comment:35 egourgoulhon]:

> > Thanks for your explanations and advice. 
> > Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.  
> > 
> 
> In that case, I would overwrite `__contains__` and add this exception since `M.scalar_field() in U.scalar_field_algebra()` returning `True` is certainly unwanted. Agreed?
Yes.
> Should I proceed similarly for the coercion implemented in #30112? This coercion is also convenient, but the containment check should return `False`, too.

Indeed.


---

Comment by @mjungmath created at 2020-07-18 21:02:49

While trying to write a `__contains__` method, I have encountered other things I am worried about. Namely, in the current state, we have:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U')
sage: X.<x,y> = U.chart()
sage: x in M.scalar_field_algebra()
True
sage: X.function_ring()(x) in M.scalar_field_algebra()
True
```


The latter containment check will return `False` after this change. The former, however, will still return `True`. This comes from the coercion:


```
sage: A = M.scalar_field_algebra()
sage: A.has_coerce_map_from(SR)
True
```


This is not unproblematic: the symbolic variable `x` will be coerced into the scalar field which is defined as `x` on `U`. But this is no coercion via restriction and therefore, due to our previous discussion, not even a coercion at all!

Suggestions? Opinions?


---

Comment by tscrim created at 2020-07-18 23:33:19

It seems like you are conflating two things: the generic-ness of the SR variable `x`, which is considered here as an element of the base ring of the `scalar_field_algebra()` (which is not a map, a priori, but is identified with elements/maps in the algebra) and the map on the function ring of the chart `X` of `U`. Since you want containment to include the domain (which I think is natural), then the latter should return false. So I don't see the problem.


---

Comment by @mjungmath created at 2020-07-19 07:36:30

Replying to [comment:40 tscrim]:
> It seems like you are conflating two things: the generic-ness of the SR variable `x`, which is considered here as an element of the base ring of the `scalar_field_algebra()` (which is not a map, a priori, but is identified with elements/maps in the algebra) and the map on the function ring of the chart `X` of `U`. Since you want containment to include the domain (which I think is natural), then the latter should return false. So I don't see the problem.

I think that is not entirely correct. The symbolic variable `x` cannot be considered as an element of the scalar field algebra on `M`, at least not uniquely. Namely, it is not (well-)defined on `M \ U`. Constants are fine. But as soon as a symbolic variable corresponds to a chart label, this setting gets messed up. For example:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U'); V = M.open_subset('V')
sage: XU.<x,y> = U.chart(); XV.<z,t> = V.chart()
sage: M.declare_union(U, V)
sage: f = M.scalar_field_algebra()(x+z)
sage: f.display()
M --> R
sage: f._expres
{}
```


In the last point of my post, I was more referring to the coercion itself. Let us take a similar example to the one above:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U'); V = M.open_subset('V')
sage: XU.<x,y> = U.chart(); XV.<z,t> = V.chart()
sage: M.declare_union(U, V)
sage: f = U.scalar_field_algebra()(z)
sage: f.display()
U --> R
on V: (z, t) |--> z
sage: g = M.scalar_field_algebra()(z)
sage: g.display()
M --> R
on V: (z, t) |--> z
sage: g_U = U.scalar_field_algebra()(g)
sage: g_U.display()
U --> R
```


Coercions have to follow strict axioms (see https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#the-four-axioms-requested-for-coercions). This is a violation of axiom 3, i.e. `g_U` must yield `f`. That the base ring is `SR` makes it even worse in this case.

This issue is rather critical. However, I have no idea how we can solve this except for changing the entire base ring or removing the coercion given by restrictions.


---

Comment by @mjungmath created at 2020-07-26 11:56:33

Regarding [comment:24](https://trac.sagemath.org/ticket/30191?replyto=35#comment:24) at #30191, we even have that `GF(5).zero() in ZZ` yields `True`. Is that an evidence that we should keep `M.scalar_field() in U.scalar_field_algebra()` as being `True`?

I think, the issue noticed in comment:41 should be discussed in another ticket so that we can close this ticket soon.


---

Comment by egourgoulhon created at 2020-07-26 13:09:29

Replying to [comment:42 gh-mjungmath]:
> 
> I think, the issue noticed in comment:41 should be discussed in another ticket so that we can close this ticket soon.

Indeed.


---

Comment by @mjungmath created at 2020-08-01 14:45:57

I would suggest we keep the `M.scalar_field() in U.scalar_field_algebra()` yielding `True` behavior for now and discuss that in a subsequent ticket. Do you agree?


---

Comment by git created at 2020-08-01 22:09:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-01 22:44:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-08-01 22:45:18

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2020-08-02 05:57:28

Yes, I think we can push that to another ticket since I would consider it a different issue.


---

Comment by @mjungmath created at 2020-08-02 07:10:59

Okay, then this ticket is ready for review. Patchbot is green btw.


---

Comment by egourgoulhon created at 2020-08-02 13:21:37

Changing status from needs_review to positive_review.


---

Comment by egourgoulhon created at 2020-08-02 13:21:37

LGTM. Thanks! Travis, do you agree?

FWIW, I've run some benchmarks for some of the notebooks of the [examples page](https://sagemanifolds.obspm.fr/examples.html). Here are the results in seconds on a Core i7-6700HQ + 16 GB RAM computer:

```
                     len(M.atlas()) Sage 9.2.beta6  this ticket
SM_sphere_S2                7           231 s          224 s 
SM_sphere_S3_Hopf          18           379 s          380 s
SM_anti_de_Sitter          10           416 s          421 s
SM_Schwarzschild           11           253 s          253 s
SM_Kerr                     1           494 s          485 s
```

So we don't observe any significant performance regression; it's even slightly better for some notebooks.


---

Comment by @mjungmath created at 2020-08-02 13:59:31

Replying to [comment:52 egourgoulhon]:
> LGTM. Thanks! Travis, do you agree?
> 
> FWIW, I've run some benchmarks for some of the notebooks of the [examples page](https://sagemanifolds.obspm.fr/examples.html). Here are the results in seconds on a Core i7-6700HQ + 16 GB RAM computer:
> {{{
>                      len(M.atlas()) Sage 9.2.beta6  this ticket
> SM_sphere_S2                7           231 s          224 s 
> SM_sphere_S3_Hopf          18           379 s          380 s
> SM_anti_de_Sitter          10           416 s          421 s
> SM_Schwarzschild           11           253 s          253 s
> SM_Kerr                     1           494 s          485 s
> }}}
> So we don't observe any significant performance regression; it's even slightly better for some notebooks. 

Thank you for the positive review and the benchmarks. What would probably be more interesting is a benchmarking of #30191, I guess.


---

Comment by git created at 2020-08-02 21:39:08

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2020-08-02 21:39:08

Changing status from positive_review to needs_review.


---

Comment by @mjungmath created at 2020-08-02 21:42:13

There was a merge conflict with the new beta. The cause was #30108. Can I switch back to positive review when the bot turns green?


---

Comment by tscrim created at 2020-08-03 05:12:09

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2020-08-03 05:12:09

Morally green patchbot.

comment:52 response: I have no objections.


---

Comment by @mjungmath created at 2020-08-04 16:24:05

Matthias mentioned a very important point. The equality via restriction doesn't satisfy the transitivity condition. That is because the scalar fields are not necessarily analytic. That's really bad.

Is there a compromise, namely keeping `_richcmp_` _and_ the coercion but separate this particular case? I don't know of any.


---

Comment by @mjungmath created at 2020-08-04 16:24:05

Changing status from positive_review to needs_info.


---

Comment by mkoeppe created at 2020-08-04 17:01:33

As I mentioned in #30266, I don't think you should feel obligated to use the coercion framework for comparisons just because you use it for arithmetic.

I would suggest to compile a set of examples that really illustrate what elements you want to compare equal, to make sure that this is an equivalence relation, and then to figure out if coercion is the right tool to implement this.

Perhaps the question should be asked in a broader context of coercion within the category of partial maps.


---

Comment by tscrim created at 2020-08-07 22:44:28

Replying to [comment:57 gh-mjungmath]:
> Matthias mentioned a very important point. The equality via restriction doesn't satisfy the transitivity condition. That is because the scalar fields are not necessarily analytic. That's really bad.

That sounds like an issue with the coercions. However, if you want them to also compare as equals without the coercion, then you will need to simply implement an `__eq__` that separately checks this as a fallback provided the first attempt via the coercion framework doesn't work.


---

Comment by @mjungmath created at 2021-01-06 14:13:47

Okay, just to summarize for me: what is the punchline of our discussion and where should this ticket go?


---

Comment by tscrim created at 2021-01-18 09:34:33

I would say Matthias's comment:58 is what should be done: provide some examples of things you want and do not want to inform you of the policy you want to set.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by @mjungmath created at 2021-04-21 16:08:03

Possibly related: #31703


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
