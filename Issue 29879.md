# Issue 29879: Replace __eq__ by _richcmp_ for scalar and tensor fields

archive/issues_029879.json:
```json
{
    "body": "CC:  egourgoulhon tscrim mkoeppe\n\nKeywords: manifolds, coercion\n\nWithin the coercion frameworks, two objects are usually compared by using `_richcmp_`. Using this, both objects are coerced into an element of a common parent before the comparison is performed. The current implementation uses `__eq__` instead and involves no prior coercion.\n\nIn this ticket, the method `__eq__` is replaced by `_richcmp_` as intended by the coercion framework.\n\nIssue created by migration from https://trac.sagemath.org/ticket/30116\n\n",
    "created_at": "2020-07-11T22:55:28Z",
    "labels": [
        "geometry",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Replace __eq__ by _richcmp_ for scalar and tensor fields",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29879",
    "user": "@mjungmath"
}
```
CC:  egourgoulhon tscrim mkoeppe

Keywords: manifolds, coercion

Within the coercion frameworks, two objects are usually compared by using `_richcmp_`. Using this, both objects are coerced into an element of a common parent before the comparison is performed. The current implementation uses `__eq__` instead and involves no prior coercion.

In this ticket, the method `__eq__` is replaced by `_richcmp_` as intended by the coercion framework.

Issue created by migration from https://trac.sagemath.org/ticket/30116





---

archive/issue_comments_424386.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-07-11T22:59:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424386",
    "user": "@mjungmath"
}
```

New commits:



---

archive/issue_comments_424387.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-07-11T23:05:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424387",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_424388.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-11T23:09:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424388",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424389.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-07-11T23:09:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424389",
    "user": "@mjungmath"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_424390.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-07-11T23:24:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424390",
    "user": "@mjungmath"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_424391.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-11T23:42:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424391",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424392.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-11T23:47:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424392",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424393.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2020-07-11T23:48:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424393",
    "user": "@mjungmath"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_424394.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-12T07:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424394",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424395.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2020-07-12T07:27:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424395",
    "user": "@mjungmath"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_424396.json:
```json
{
    "body": "I am sorry. I am too impatient. Anyway, I get the following error during the doctest:\n\n\n```\nFile \"src/sage/manifolds/section.py\", line 2401, in sage.manifolds.section.TrivialSection.restrict\nFailed example:\n    s_D[[1]] == s[[1]]\nExpected:\n    False\nGot:\n    True\n```\n\n\nHere is the complete related doctest:\n\n\n```\nsage: M = Manifold(2, 'R^2')\nsage: c_cart.<x,y> = M.chart() # Cartesian coordinates on R^2\nsage: E = M.vector_bundle(2, 'E')\nsage: e = E.local_frame('e') # makes E trivial\nsage: s = E.section(x+y, -1+x^2, name='s')\nsage: D = M.open_subset('D') # the unit open disc\nsage: e_D = e.restrict(D)\nsage: c_cart_D = c_cart.restrict(D, x^2+y^2<1)\nsage: s_D = s.restrict(D) ; s_D\nSection s on the Open subset D of the 2-dimensional differentiable\n manifold R^2 with values in the real vector bundle E of rank 2\n\n...\n\nsage: s_D[[1]] == s[[1]]\nFalse\n```\n\n\n\nWith respect to the coercion model, the output is perfectly fine: the section `s` can be restricted to `D`. Thus there exists a coercion from sections on `M` to sections on `D`. The equality check then takes places on the sections on `D`.\n\nShould I simply rewrite this doctest, or what is the best procedure here?\n\nFor consistency, the same should then hold for chart functions, too. Meaning the following command right above should then return `True` as well:\n\n\n```\nsage: s_D[1] == s[1]\n```\n",
    "created_at": "2020-07-12T11:01:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424396",
    "user": "@mjungmath"
}
```

I am sorry. I am too impatient. Anyway, I get the following error during the doctest:


```
File "src/sage/manifolds/section.py", line 2401, in sage.manifolds.section.TrivialSection.restrict
Failed example:
    s_D[[1]] == s[[1]]
Expected:
    False
Got:
    True
```


Here is the complete related doctest:


```
sage: M = Manifold(2, 'R^2')
sage: c_cart.<x,y> = M.chart() # Cartesian coordinates on R^2
sage: E = M.vector_bundle(2, 'E')
sage: e = E.local_frame('e') # makes E trivial
sage: s = E.section(x+y, -1+x^2, name='s')
sage: D = M.open_subset('D') # the unit open disc
sage: e_D = e.restrict(D)
sage: c_cart_D = c_cart.restrict(D, x^2+y^2<1)
sage: s_D = s.restrict(D) ; s_D
Section s on the Open subset D of the 2-dimensional differentiable
 manifold R^2 with values in the real vector bundle E of rank 2

...

sage: s_D[[1]] == s[[1]]
False
```



With respect to the coercion model, the output is perfectly fine: the section `s` can be restricted to `D`. Thus there exists a coercion from sections on `M` to sections on `D`. The equality check then takes places on the sections on `D`.

Should I simply rewrite this doctest, or what is the best procedure here?

For consistency, the same should then hold for chart functions, too. Meaning the following command right above should then return `True` as well:


```
sage: s_D[1] == s[1]
```




---

archive/issue_comments_424397.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2020-07-12T11:01:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424397",
    "user": "@mjungmath"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_424398.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-12T11:05:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424398",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424399.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-12T12:16:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424399",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424400.json:
```json
{
    "body": "Changing component from geometry to manifolds.",
    "created_at": "2020-07-14T17:07:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424400",
    "user": "@mjungmath"
}
```

Changing component from geometry to manifolds.



---

archive/issue_comments_424401.json:
```json
{
    "body": "Replying to [comment:14 gh-mjungmath]:\n> \n> \n> With respect to the coercion model, the output is perfectly fine: the section `s` can be restricted to `D`. Thus there exists a coercion from sections on `M` to sections on `D`. The equality check then takes places on the sections on `D`.\n> \n> Should I simply rewrite this doctest, or what is the best procedure here?\n> \n> For consistency, the same should then hold for chart functions, too. Meaning the following command right above should then return `True` as well:\n> \n> {{{\n> sage: s_D[1] == s[1]\n> }}}\n> \nI am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`.",
    "created_at": "2020-07-15T15:07:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424401",
    "user": "egourgoulhon"
}
```

Replying to [comment:14 gh-mjungmath]:
> 
> 
> With respect to the coercion model, the output is perfectly fine: the section `s` can be restricted to `D`. Thus there exists a coercion from sections on `M` to sections on `D`. The equality check then takes places on the sections on `D`.
> 
> Should I simply rewrite this doctest, or what is the best procedure here?
> 
> For consistency, the same should then hold for chart functions, too. Meaning the following command right above should then return `True` as well:
> 
> {{{
> sage: s_D[1] == s[1]
> }}}
> 
I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`.



---

archive/issue_comments_424402.json:
```json
{
    "body": "Replying to [comment:25 egourgoulhon]:\n> I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`. \n\nFor matrices, things are even more distracting than in our particular case:\n\n\n```\nsage: MatrixSpace(QQ, 3, 3)(2)\n[2 0 0]\n[0 2 0]\n[0 0 2]\nsage: MatrixSpace(QQ, 3, 3)(2) == 2\nTrue \n```\n\n\nDigging in the documentation, I've found: \n\n*The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets.*\n\nFrom this perspective, the matrix code example above makes somewhat sense, and so it would in our case.",
    "created_at": "2020-07-15T21:20:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424402",
    "user": "@mjungmath"
}
```

Replying to [comment:25 egourgoulhon]:
> I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`. 

For matrices, things are even more distracting than in our particular case:


```
sage: MatrixSpace(QQ, 3, 3)(2)
[2 0 0]
[0 2 0]
[0 0 2]
sage: MatrixSpace(QQ, 3, 3)(2) == 2
True 
```


Digging in the documentation, I've found: 

*The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets.*

From this perspective, the matrix code example above makes somewhat sense, and so it would in our case.



---

archive/issue_comments_424403.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-15T22:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424403",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424404.json:
```json
{
    "body": "Replying to [comment:26 gh-mjungmath]:\n> Replying to [comment:25 egourgoulhon]:\n> > I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`. \n> \n> For matrices, things are even more distracting than in our particular case:\n> \n> {{{\n> sage: MatrixSpace(QQ, 3, 3)(2)\n> [2 0 0]\n> [0 2 0]\n> [0 0 2]\n> sage: MatrixSpace(QQ, 3, 3)(2) == 2\n> True \n> }}}\n> \n> Digging in the documentation, I've found: \n> \n> *The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets.*\n> \n> From this perspective, the matrix code example above makes somewhat sense, and so it would in our case.\n\nAllow me to give another example:\n\n\n\n```\nsage: GF(5)(7) == 2\nTrue\n```\n\n\nWe cannot recover `7` from the finite field again. Furthermore the representative of `7` in `GF(5)` and the number `2` are certainly two distinct mathematical objects. Sure, this equality must be seen in terms of congruences. Now, I think we can see the equality of restricted functions somehow similarly. (Forget about the sheafs, that was nonsense.)",
    "created_at": "2020-07-16T09:34:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424404",
    "user": "@mjungmath"
}
```

Replying to [comment:26 gh-mjungmath]:
> Replying to [comment:25 egourgoulhon]:
> > I am a little bit worried about this: `s_D[1]` and `s[1]` are mathematically distinct objects (they don't have the same domain), so the comparison output should be `False`, despite `s[1]` can be coerced (by restriction) to a function with the same domain as `s_D[1]` and the coercion outcome is equal to `s_D[1]`. 
> 
> For matrices, things are even more distracting than in our particular case:
> 
> {{{
> sage: MatrixSpace(QQ, 3, 3)(2)
> [2 0 0]
> [0 2 0]
> [0 0 2]
> sage: MatrixSpace(QQ, 3, 3)(2) == 2
> True 
> }}}
> 
> Digging in the documentation, I've found: 
> 
> *The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets.*
> 
> From this perspective, the matrix code example above makes somewhat sense, and so it would in our case.

Allow me to give another example:



```
sage: GF(5)(7) == 2
True
```


We cannot recover `7` from the finite field again. Furthermore the representative of `7` in `GF(5)` and the number `2` are certainly two distinct mathematical objects. Sure, this equality must be seen in terms of congruences. Now, I think we can see the equality of restricted functions somehow similarly. (Forget about the sheafs, that was nonsense.)



---

archive/issue_comments_424405.json:
```json
{
    "body": "Replying to [comment:29 gh-mjungmath]:\n> > \n> > For matrices, things are even more distracting than in our particular case:\n> > \n> > {{{\n> > sage: MatrixSpace(QQ, 3, 3)(2) == 2\n> > True \n> > }}}\n> > \n> \n> Allow me to give another example:\n> \n> \n> {{{\n> sage: GF(5)(7) == 2\n> True\n> }}}\n> \nThanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...",
    "created_at": "2020-07-16T14:37:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424405",
    "user": "egourgoulhon"
}
```

Replying to [comment:29 gh-mjungmath]:
> > 
> > For matrices, things are even more distracting than in our particular case:
> > 
> > {{{
> > sage: MatrixSpace(QQ, 3, 3)(2) == 2
> > True 
> > }}}
> > 
> 
> Allow me to give another example:
> 
> 
> {{{
> sage: GF(5)(7) == 2
> True
> }}}
> 
Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...



---

archive/issue_comments_424406.json:
```json
{
    "body": "Replying to [comment:30 egourgoulhon]:\n> Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...\n\nMh, okay. I see your point. Nevertheles, we allow addition and multiplication between a scalar field and a restricted scalar field, which comes with the very same problem, doesn't it?\n\nImho, there should be no coercion for restrictions when we do not allow a comparison for them. Simply because they don't fit into the coercion model then.\n\nI am curious about their opinion, too. :)",
    "created_at": "2020-07-16T14:58:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424406",
    "user": "@mjungmath"
}
```

Replying to [comment:30 egourgoulhon]:
> Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...

Mh, okay. I see your point. Nevertheles, we allow addition and multiplication between a scalar field and a restricted scalar field, which comes with the very same problem, doesn't it?

Imho, there should be no coercion for restrictions when we do not allow a comparison for them. Simply because they don't fit into the coercion model then.

I am curious about their opinion, too. :)



---

archive/issue_comments_424407.json:
```json
{
    "body": "Replying to [comment:31 gh-mjungmath]:\n> Replying to [comment:30 egourgoulhon]:\n> > Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...\n> \n> Mh, okay. I see your point. Nevertheles, we allow addition and multiplication between a scalar field and a restricted scalar field, \n\nindeed.\n\n>which comes with the very same problem, doesn't it?\n\nMaybe it is a matter of taste but `a*b` resulting in a scalar field on the common subdomain of `a` and `b` seems less error prone to me than `a == b` returning `True`. \n> \n> Imho, there should be no coercion for restrictions when we do not allow a comparison for them. Simply because they don't fit into the coercion model then.\n\nI agree that to fully fit with the coercion model, we should allow comparison as proposed in this ticket. \n\n> However, one can still allow some kind of conversions right?\n> \n> I am curious about their opinion, too. :)\n\nIn particular, are there other structures in Sage that implement the coercion model but for comparison?",
    "created_at": "2020-07-16T15:16:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424407",
    "user": "egourgoulhon"
}
```

Replying to [comment:31 gh-mjungmath]:
> Replying to [comment:30 egourgoulhon]:
> > Thanks for providing these examples. I feel slightly more comfortable with comparison with the integers, since it's obvious that we are dealing with distinct mathematical entities and the equality results from some canonical identification. For tensor fields with the coercions based on restrictions, we are dealing with the same type of entities, so it seems to me that having `a == b` yielding `True` when `a` and `b` are two tensor fields defined on distinct domains is more dangerous than having e.g. `a == 0` return `True`. I would be curious to have the opinion of Travis and Matthias on that...
> 
> Mh, okay. I see your point. Nevertheles, we allow addition and multiplication between a scalar field and a restricted scalar field, 

indeed.

>which comes with the very same problem, doesn't it?

Maybe it is a matter of taste but `a*b` resulting in a scalar field on the common subdomain of `a` and `b` seems less error prone to me than `a == b` returning `True`. 
> 
> Imho, there should be no coercion for restrictions when we do not allow a comparison for them. Simply because they don't fit into the coercion model then.

I agree that to fully fit with the coercion model, we should allow comparison as proposed in this ticket. 

> However, one can still allow some kind of conversions right?
> 
> I am curious about their opinion, too. :)

In particular, are there other structures in Sage that implement the coercion model but for comparison?



---

archive/issue_comments_424408.json:
```json
{
    "body": "Okay, I thought about it once again, and I tend to agree. If we would apply the changes I propose, the following code would return `True`:\n\n\n```\nsage: M = Manifold(2, 'M')\nsage: U = M.open_subset('U')\nsage: f = M.scalar_field('f')\nsage: A_U = U.scalar_field_algebra()\nsage: f in A_U\nTrue\n```\n\n\nAnd as you, Eric, already pointed out, that is definitely not what we want.\n\nIf I understand this correctly, and two coercible elements **must** always be comparable, I vote for keeping the *conversion*:\n\n\n```\nsage: A_U(f) in A_U\nTrue\n```\n\n\nbut removing the *coercion* from the populated list, i.e.\n\n\n```diff\n-        elif isinstance(other, ScalarFieldAlgebra):\n-            return self._domain.is_subset(other._domain)\n```\n\n\nin `_coerce_map_from_` of the file `scalarfield_algebra.py`.\n\nI know, this is inconvenient when it comes to addition and multiplication of restricted elements. On the other hand, it would be consistent with Sage's coercion model then. It is therefore mandatory to investigate if coercible elements must always be comparable or not.\n\n**Addendum:** see https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#equality-and-element-containment for details.\n\nAs pointed out in this article, one could also simply overwrite `__contains__` and still keep the equality test...",
    "created_at": "2020-07-16T19:03:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424408",
    "user": "@mjungmath"
}
```

Okay, I thought about it once again, and I tend to agree. If we would apply the changes I propose, the following code would return `True`:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U')
sage: f = M.scalar_field('f')
sage: A_U = U.scalar_field_algebra()
sage: f in A_U
True
```


And as you, Eric, already pointed out, that is definitely not what we want.

If I understand this correctly, and two coercible elements **must** always be comparable, I vote for keeping the *conversion*:


```
sage: A_U(f) in A_U
True
```


but removing the *coercion* from the populated list, i.e.


```diff
-        elif isinstance(other, ScalarFieldAlgebra):
-            return self._domain.is_subset(other._domain)
```


in `_coerce_map_from_` of the file `scalarfield_algebra.py`.

I know, this is inconvenient when it comes to addition and multiplication of restricted elements. On the other hand, it would be consistent with Sage's coercion model then. It is therefore mandatory to investigate if coercible elements must always be comparable or not.

**Addendum:** see https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#equality-and-element-containment for details.

As pointed out in this article, one could also simply overwrite `__contains__` and still keep the equality test...



---

archive/issue_comments_424409.json:
```json
{
    "body": "Replying to [comment:32 egourgoulhon]:\n> Maybe it is a matter of taste but `a*b` resulting in a scalar field on the common subdomain of `a` and `b` seems less error prone to me than `a == b` returning `True`. \n\nIf you want the multiplication (by coercion), then you have to also allow the equality check unless you explicitly disallow comparisons under coercion.\n\nThe equality test in both ways makes sense, it just depends on whether you want to consider them as completely different functions (with incompatible domains) or you want to do an actual comparison of the functions on the same common domain. The issue is `==` inherently does not ask you to specify the type of equality, which we generally assume from context (usually by adding prose when saying two functions are equal). We leave the choice of the semantics of `==` up to the developer of a particular block of code. Yet, the existence of the coercion means the two objects should inherently be (naturally) relatable.\n\nIf you still want the multiplication and do not want the equality, then you can implement the multiplication as an action (with the `M` scalar field acting on the `U` one).\n\nMy opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.\n\nTL;DR It depends on what you think is the most natural semantic, and it is your choice.",
    "created_at": "2020-07-17T05:12:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424409",
    "user": "tscrim"
}
```

Replying to [comment:32 egourgoulhon]:
> Maybe it is a matter of taste but `a*b` resulting in a scalar field on the common subdomain of `a` and `b` seems less error prone to me than `a == b` returning `True`. 

If you want the multiplication (by coercion), then you have to also allow the equality check unless you explicitly disallow comparisons under coercion.

The equality test in both ways makes sense, it just depends on whether you want to consider them as completely different functions (with incompatible domains) or you want to do an actual comparison of the functions on the same common domain. The issue is `==` inherently does not ask you to specify the type of equality, which we generally assume from context (usually by adding prose when saying two functions are equal). We leave the choice of the semantics of `==` up to the developer of a particular block of code. Yet, the existence of the coercion means the two objects should inherently be (naturally) relatable.

If you still want the multiplication and do not want the equality, then you can implement the multiplication as an action (with the `M` scalar field acting on the `U` one).

My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.

TL;DR It depends on what you think is the most natural semantic, and it is your choice.



---

archive/issue_comments_424410.json:
```json
{
    "body": "Replying to [comment:34 tscrim]: \n> My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.\n> \n> TL;DR It depends on what you think is the most natural semantic, and it is your choice.\n\n\nThanks for your explanations and advice. \nSince the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.",
    "created_at": "2020-07-17T13:22:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424410",
    "user": "egourgoulhon"
}
```

Replying to [comment:34 tscrim]: 
> My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.
> 
> TL;DR It depends on what you think is the most natural semantic, and it is your choice.


Thanks for your explanations and advice. 
Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.



---

archive/issue_comments_424411.json:
```json
{
    "body": "Replying to [comment:33 gh-mjungmath]:\n> \n> As pointed out in this article, one could also simply overwrite `__contains__` and still keep the equality test...\n\nIndeed!",
    "created_at": "2020-07-17T13:23:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424411",
    "user": "egourgoulhon"
}
```

Replying to [comment:33 gh-mjungmath]:
> 
> As pointed out in this article, one could also simply overwrite `__contains__` and still keep the equality test...

Indeed!



---

archive/issue_comments_424412.json:
```json
{
    "body": "Replying to [comment:35 egourgoulhon]:\n> Replying to [comment:34 tscrim]: \n> > My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.\n> > \n> > TL;DR It depends on what you think is the most natural semantic, and it is your choice.\n> \n> \n> Thanks for your explanations and advice. \n> Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.  \n> \n\nIn that case, I would overwrite `__contains__` and add this exception since `M.scalar_field() in U.scalar_field_algebra()` returning `True` is certainly unwanted. Agreed? Should I proceed similarly for the coercion implemented in #30112? This coercion is also convenient, but the containment check should return `False`, too.",
    "created_at": "2020-07-17T16:14:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424412",
    "user": "@mjungmath"
}
```

Replying to [comment:35 egourgoulhon]:
> Replying to [comment:34 tscrim]: 
> > My opinion is to use the `_richcmp_` and just make a note that when comparing maps (e.g., a scalar field) in a manifold, it restricts to the common domain and does the comparison there. If a user wants to explicit check that the maps have different domains, then they will have to add an extra check of the `domain()`s.
> > 
> > TL;DR It depends on what you think is the most natural semantic, and it is your choice.
> 
> 
> Thanks for your explanations and advice. 
> Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.  
> 

In that case, I would overwrite `__contains__` and add this exception since `M.scalar_field() in U.scalar_field_algebra()` returning `True` is certainly unwanted. Agreed? Should I proceed similarly for the coercion implemented in #30112? This coercion is also convenient, but the containment check should return `False`, too.



---

archive/issue_comments_424413.json:
```json
{
    "body": "Replying to [comment:37 gh-mjungmath]:\n> Replying to [comment:35 egourgoulhon]:\n\n> > Thanks for your explanations and advice. \n> > Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.  \n> > \n> \n> In that case, I would overwrite `__contains__` and add this exception since `M.scalar_field() in U.scalar_field_algebra()` returning `True` is certainly unwanted. Agreed?\nYes.\n> Should I proceed similarly for the coercion implemented in #30112? This coercion is also convenient, but the containment check should return `False`, too.\n\nIndeed.",
    "created_at": "2020-07-18T14:40:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424413",
    "user": "egourgoulhon"
}
```

Replying to [comment:37 gh-mjungmath]:
> Replying to [comment:35 egourgoulhon]:

> > Thanks for your explanations and advice. 
> > Since the coercion of tensor fields is very handy, not only for multiplication (in which case we could use an action as you pointed out) by also for addition/subtraction and multilinear form operations like `g(u,v)` with `u` and `v` vector fields defined on subsets of the domain of metric `g`, I would suggest to keep the coercion and use `_richcmp_` as proposed in this ticket, with some doctests warning about the behaviour of the equality operator.  
> > 
> 
> In that case, I would overwrite `__contains__` and add this exception since `M.scalar_field() in U.scalar_field_algebra()` returning `True` is certainly unwanted. Agreed?
Yes.
> Should I proceed similarly for the coercion implemented in #30112? This coercion is also convenient, but the containment check should return `False`, too.

Indeed.



---

archive/issue_comments_424414.json:
```json
{
    "body": "While trying to write a `__contains__` method, I have encountered other things I am worried about. Namely, in the current state, we have:\n\n\n```\nsage: M = Manifold(2, 'M')\nsage: U = M.open_subset('U')\nsage: X.<x,y> = U.chart()\nsage: x in M.scalar_field_algebra()\nTrue\nsage: X.function_ring()(x) in M.scalar_field_algebra()\nTrue\n```\n\n\nThe latter containment check will return `False` after this change. The former, however, will still return `True`. This comes from the coercion:\n\n\n```\nsage: A = M.scalar_field_algebra()\nsage: A.has_coerce_map_from(SR)\nTrue\n```\n\n\nThis is not unproblematic: the symbolic variable `x` will be coerced into the scalar field which is defined as `x` on `U`. But this is no coercion via restriction and therefore, due to our previous discussion, not even a coercion at all!\n\nSuggestions? Opinions?",
    "created_at": "2020-07-18T21:02:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424414",
    "user": "@mjungmath"
}
```

While trying to write a `__contains__` method, I have encountered other things I am worried about. Namely, in the current state, we have:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U')
sage: X.<x,y> = U.chart()
sage: x in M.scalar_field_algebra()
True
sage: X.function_ring()(x) in M.scalar_field_algebra()
True
```


The latter containment check will return `False` after this change. The former, however, will still return `True`. This comes from the coercion:


```
sage: A = M.scalar_field_algebra()
sage: A.has_coerce_map_from(SR)
True
```


This is not unproblematic: the symbolic variable `x` will be coerced into the scalar field which is defined as `x` on `U`. But this is no coercion via restriction and therefore, due to our previous discussion, not even a coercion at all!

Suggestions? Opinions?



---

archive/issue_comments_424415.json:
```json
{
    "body": "It seems like you are conflating two things: the generic-ness of the SR variable `x`, which is considered here as an element of the base ring of the `scalar_field_algebra()` (which is not a map, a priori, but is identified with elements/maps in the algebra) and the map on the function ring of the chart `X` of `U`. Since you want containment to include the domain (which I think is natural), then the latter should return false. So I don't see the problem.",
    "created_at": "2020-07-18T23:33:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424415",
    "user": "tscrim"
}
```

It seems like you are conflating two things: the generic-ness of the SR variable `x`, which is considered here as an element of the base ring of the `scalar_field_algebra()` (which is not a map, a priori, but is identified with elements/maps in the algebra) and the map on the function ring of the chart `X` of `U`. Since you want containment to include the domain (which I think is natural), then the latter should return false. So I don't see the problem.



---

archive/issue_comments_424416.json:
```json
{
    "body": "Replying to [comment:40 tscrim]:\n> It seems like you are conflating two things: the generic-ness of the SR variable `x`, which is considered here as an element of the base ring of the `scalar_field_algebra()` (which is not a map, a priori, but is identified with elements/maps in the algebra) and the map on the function ring of the chart `X` of `U`. Since you want containment to include the domain (which I think is natural), then the latter should return false. So I don't see the problem.\n\nI think that is not entirely correct. The symbolic variable `x` cannot be considered as an element of the scalar field algebra on `M`, at least not uniquely. Namely, it is not (well-)defined on `M \\ U`. Constants are fine. But as soon as a symbolic variable corresponds to a chart label, this setting gets messed up. For example:\n\n\n```\nsage: M = Manifold(2, 'M')\nsage: U = M.open_subset('U'); V = M.open_subset('V')\nsage: XU.<x,y> = U.chart(); XV.<z,t> = V.chart()\nsage: M.declare_union(U, V)\nsage: f = M.scalar_field_algebra()(x+z)\nsage: f.display()\nM --> R\nsage: f._expres\n{}\n```\n\n\nIn the last point of my post, I was more referring to the coercion itself. Let us take a similar example to the one above:\n\n\n```\nsage: M = Manifold(2, 'M')\nsage: U = M.open_subset('U'); V = M.open_subset('V')\nsage: XU.<x,y> = U.chart(); XV.<z,t> = V.chart()\nsage: M.declare_union(U, V)\nsage: f = U.scalar_field_algebra()(z)\nsage: f.display()\nU --> R\non V: (z, t) |--> z\nsage: g = M.scalar_field_algebra()(z)\nsage: g.display()\nM --> R\non V: (z, t) |--> z\nsage: g_U = U.scalar_field_algebra()(g)\nsage: g_U.display()\nU --> R\n```\n\n\nCoercions have to follow strict axioms (see https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#the-four-axioms-requested-for-coercions). This is a violation of axiom 3, i.e. `g_U` must yield `f`. That the base ring is `SR` makes it even worse in this case.\n\nThis issue is rather critical. However, I have no idea how we can solve this except for changing the entire base ring or removing the coercion given by restrictions.",
    "created_at": "2020-07-19T07:36:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424416",
    "user": "@mjungmath"
}
```

Replying to [comment:40 tscrim]:
> It seems like you are conflating two things: the generic-ness of the SR variable `x`, which is considered here as an element of the base ring of the `scalar_field_algebra()` (which is not a map, a priori, but is identified with elements/maps in the algebra) and the map on the function ring of the chart `X` of `U`. Since you want containment to include the domain (which I think is natural), then the latter should return false. So I don't see the problem.

I think that is not entirely correct. The symbolic variable `x` cannot be considered as an element of the scalar field algebra on `M`, at least not uniquely. Namely, it is not (well-)defined on `M \ U`. Constants are fine. But as soon as a symbolic variable corresponds to a chart label, this setting gets messed up. For example:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U'); V = M.open_subset('V')
sage: XU.<x,y> = U.chart(); XV.<z,t> = V.chart()
sage: M.declare_union(U, V)
sage: f = M.scalar_field_algebra()(x+z)
sage: f.display()
M --> R
sage: f._expres
{}
```


In the last point of my post, I was more referring to the coercion itself. Let us take a similar example to the one above:


```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U'); V = M.open_subset('V')
sage: XU.<x,y> = U.chart(); XV.<z,t> = V.chart()
sage: M.declare_union(U, V)
sage: f = U.scalar_field_algebra()(z)
sage: f.display()
U --> R
on V: (z, t) |--> z
sage: g = M.scalar_field_algebra()(z)
sage: g.display()
M --> R
on V: (z, t) |--> z
sage: g_U = U.scalar_field_algebra()(g)
sage: g_U.display()
U --> R
```


Coercions have to follow strict axioms (see https://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html#the-four-axioms-requested-for-coercions). This is a violation of axiom 3, i.e. `g_U` must yield `f`. That the base ring is `SR` makes it even worse in this case.

This issue is rather critical. However, I have no idea how we can solve this except for changing the entire base ring or removing the coercion given by restrictions.



---

archive/issue_comments_424417.json:
```json
{
    "body": "Regarding [comment:24](https://trac.sagemath.org/ticket/30191?replyto=35#comment:24) at #30191, we even have that `GF(5).zero() in ZZ` yields `True`. Is that an evidence that we should keep `M.scalar_field() in U.scalar_field_algebra()` as being `True`?\n\nI think, the issue noticed in comment:41 should be discussed in another ticket so that we can close this ticket soon.",
    "created_at": "2020-07-26T11:56:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424417",
    "user": "@mjungmath"
}
```

Regarding [comment:24](https://trac.sagemath.org/ticket/30191?replyto=35#comment:24) at #30191, we even have that `GF(5).zero() in ZZ` yields `True`. Is that an evidence that we should keep `M.scalar_field() in U.scalar_field_algebra()` as being `True`?

I think, the issue noticed in comment:41 should be discussed in another ticket so that we can close this ticket soon.



---

archive/issue_comments_424418.json:
```json
{
    "body": "Replying to [comment:42 gh-mjungmath]:\n> \n> I think, the issue noticed in comment:41 should be discussed in another ticket so that we can close this ticket soon.\n\nIndeed.",
    "created_at": "2020-07-26T13:09:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424418",
    "user": "egourgoulhon"
}
```

Replying to [comment:42 gh-mjungmath]:
> 
> I think, the issue noticed in comment:41 should be discussed in another ticket so that we can close this ticket soon.

Indeed.



---

archive/issue_comments_424419.json:
```json
{
    "body": "I would suggest we keep the `M.scalar_field() in U.scalar_field_algebra()` yielding `True` behavior for now and discuss that in a subsequent ticket. Do you agree?",
    "created_at": "2020-08-01T14:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424419",
    "user": "@mjungmath"
}
```

I would suggest we keep the `M.scalar_field() in U.scalar_field_algebra()` yielding `True` behavior for now and discuss that in a subsequent ticket. Do you agree?



---

archive/issue_comments_424420.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-01T22:09:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424420",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424421.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-01T22:44:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424421",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_424422.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2020-08-01T22:45:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424422",
    "user": "@mjungmath"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_424423.json:
```json
{
    "body": "Yes, I think we can push that to another ticket since I would consider it a different issue.",
    "created_at": "2020-08-02T05:57:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424423",
    "user": "tscrim"
}
```

Yes, I think we can push that to another ticket since I would consider it a different issue.



---

archive/issue_comments_424424.json:
```json
{
    "body": "Okay, then this ticket is ready for review. Patchbot is green btw.",
    "created_at": "2020-08-02T07:10:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424424",
    "user": "@mjungmath"
}
```

Okay, then this ticket is ready for review. Patchbot is green btw.



---

archive/issue_comments_424425.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-08-02T13:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424425",
    "user": "egourgoulhon"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_424426.json:
```json
{
    "body": "LGTM. Thanks! Travis, do you agree?\n\nFWIW, I've run some benchmarks for some of the notebooks of the [examples page](https://sagemanifolds.obspm.fr/examples.html). Here are the results in seconds on a Core i7-6700HQ + 16 GB RAM computer:\n\n```\n                     len(M.atlas()) Sage 9.2.beta6  this ticket\nSM_sphere_S2                7           231 s          224 s \nSM_sphere_S3_Hopf          18           379 s          380 s\nSM_anti_de_Sitter          10           416 s          421 s\nSM_Schwarzschild           11           253 s          253 s\nSM_Kerr                     1           494 s          485 s\n```\n\nSo we don't observe any significant performance regression; it's even slightly better for some notebooks.",
    "created_at": "2020-08-02T13:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424426",
    "user": "egourgoulhon"
}
```

LGTM. Thanks! Travis, do you agree?

FWIW, I've run some benchmarks for some of the notebooks of the [examples page](https://sagemanifolds.obspm.fr/examples.html). Here are the results in seconds on a Core i7-6700HQ + 16 GB RAM computer:

```
                     len(M.atlas()) Sage 9.2.beta6  this ticket
SM_sphere_S2                7           231 s          224 s 
SM_sphere_S3_Hopf          18           379 s          380 s
SM_anti_de_Sitter          10           416 s          421 s
SM_Schwarzschild           11           253 s          253 s
SM_Kerr                     1           494 s          485 s
```

So we don't observe any significant performance regression; it's even slightly better for some notebooks.



---

archive/issue_comments_424427.json:
```json
{
    "body": "Replying to [comment:52 egourgoulhon]:\n> LGTM. Thanks! Travis, do you agree?\n> \n> FWIW, I've run some benchmarks for some of the notebooks of the [examples page](https://sagemanifolds.obspm.fr/examples.html). Here are the results in seconds on a Core i7-6700HQ + 16 GB RAM computer:\n> {{{\n>                      len(M.atlas()) Sage 9.2.beta6  this ticket\n> SM_sphere_S2                7           231 s          224 s \n> SM_sphere_S3_Hopf          18           379 s          380 s\n> SM_anti_de_Sitter          10           416 s          421 s\n> SM_Schwarzschild           11           253 s          253 s\n> SM_Kerr                     1           494 s          485 s\n> }}}\n> So we don't observe any significant performance regression; it's even slightly better for some notebooks. \n\nThank you for the positive review and the benchmarks. What would probably be more interesting is a benchmarking of #30191, I guess.",
    "created_at": "2020-08-02T13:59:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424427",
    "user": "@mjungmath"
}
```

Replying to [comment:52 egourgoulhon]:
> LGTM. Thanks! Travis, do you agree?
> 
> FWIW, I've run some benchmarks for some of the notebooks of the [examples page](https://sagemanifolds.obspm.fr/examples.html). Here are the results in seconds on a Core i7-6700HQ + 16 GB RAM computer:
> {{{
>                      len(M.atlas()) Sage 9.2.beta6  this ticket
> SM_sphere_S2                7           231 s          224 s 
> SM_sphere_S3_Hopf          18           379 s          380 s
> SM_anti_de_Sitter          10           416 s          421 s
> SM_Schwarzschild           11           253 s          253 s
> SM_Kerr                     1           494 s          485 s
> }}}
> So we don't observe any significant performance regression; it's even slightly better for some notebooks. 

Thank you for the positive review and the benchmarks. What would probably be more interesting is a benchmarking of #30191, I guess.



---

archive/issue_comments_424428.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2020-08-02T21:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424428",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_424429.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2020-08-02T21:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424429",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_424430.json:
```json
{
    "body": "There was a merge conflict with the new beta. The cause was #30108. Can I switch back to positive review when the bot turns green?",
    "created_at": "2020-08-02T21:42:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424430",
    "user": "@mjungmath"
}
```

There was a merge conflict with the new beta. The cause was #30108. Can I switch back to positive review when the bot turns green?



---

archive/issue_comments_424431.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-08-03T05:12:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424431",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_424432.json:
```json
{
    "body": "Morally green patchbot.\n\ncomment:52 response: I have no objections.",
    "created_at": "2020-08-03T05:12:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424432",
    "user": "tscrim"
}
```

Morally green patchbot.

comment:52 response: I have no objections.



---

archive/issue_comments_424433.json:
```json
{
    "body": "Matthias mentioned a very important point. The equality via restriction doesn't satisfy the transitivity condition. That is because the scalar fields are not necessarily analytic. That's really bad.\n\nIs there a compromise, namely keeping `_richcmp_` *and* the coercion but separate this particular case? I don't know of any.",
    "created_at": "2020-08-04T16:24:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424433",
    "user": "@mjungmath"
}
```

Matthias mentioned a very important point. The equality via restriction doesn't satisfy the transitivity condition. That is because the scalar fields are not necessarily analytic. That's really bad.

Is there a compromise, namely keeping `_richcmp_` *and* the coercion but separate this particular case? I don't know of any.



---

archive/issue_comments_424434.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2020-08-04T16:24:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424434",
    "user": "@mjungmath"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_424435.json:
```json
{
    "body": "As I mentioned in #30266, I don't think you should feel obligated to use the coercion framework for comparisons just because you use it for arithmetic.\n\nI would suggest to compile a set of examples that really illustrate what elements you want to compare equal, to make sure that this is an equivalence relation, and then to figure out if coercion is the right tool to implement this.\n\nPerhaps the question should be asked in a broader context of coercion within the category of partial maps.",
    "created_at": "2020-08-04T17:01:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424435",
    "user": "mkoeppe"
}
```

As I mentioned in #30266, I don't think you should feel obligated to use the coercion framework for comparisons just because you use it for arithmetic.

I would suggest to compile a set of examples that really illustrate what elements you want to compare equal, to make sure that this is an equivalence relation, and then to figure out if coercion is the right tool to implement this.

Perhaps the question should be asked in a broader context of coercion within the category of partial maps.



---

archive/issue_comments_424436.json:
```json
{
    "body": "Replying to [comment:57 gh-mjungmath]:\n> Matthias mentioned a very important point. The equality via restriction doesn't satisfy the transitivity condition. That is because the scalar fields are not necessarily analytic. That's really bad.\n\nThat sounds like an issue with the coercions. However, if you want them to also compare as equals without the coercion, then you will need to simply implement an `__eq__` that separately checks this as a fallback provided the first attempt via the coercion framework doesn't work.",
    "created_at": "2020-08-07T22:44:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424436",
    "user": "tscrim"
}
```

Replying to [comment:57 gh-mjungmath]:
> Matthias mentioned a very important point. The equality via restriction doesn't satisfy the transitivity condition. That is because the scalar fields are not necessarily analytic. That's really bad.

That sounds like an issue with the coercions. However, if you want them to also compare as equals without the coercion, then you will need to simply implement an `__eq__` that separately checks this as a fallback provided the first attempt via the coercion framework doesn't work.



---

archive/issue_comments_424437.json:
```json
{
    "body": "Okay, just to summarize for me: what is the punchline of our discussion and where should this ticket go?",
    "created_at": "2021-01-06T14:13:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424437",
    "user": "@mjungmath"
}
```

Okay, just to summarize for me: what is the punchline of our discussion and where should this ticket go?



---

archive/issue_comments_424438.json:
```json
{
    "body": "I would say Matthias's comment:58 is what should be done: provide some examples of things you want and do not want to inform you of the policy you want to set.",
    "created_at": "2021-01-18T09:34:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424438",
    "user": "tscrim"
}
```

I would say Matthias's comment:58 is what should be done: provide some examples of things you want and do not want to inform you of the policy you want to set.



---

archive/issue_comments_424439.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-15T22:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424439",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_424440.json:
```json
{
    "body": "Possibly related: #31703",
    "created_at": "2021-04-21T16:08:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424440",
    "user": "@mjungmath"
}
```

Possibly related: #31703



---

archive/issue_comments_424441.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424441",
    "user": "mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_comments_424442.json:
```json
{
    "body": "Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.",
    "created_at": "2021-12-18T19:53:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29879",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29879#issuecomment-424442",
    "user": "mkoeppe"
}
```

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
