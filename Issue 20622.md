# Issue 20622: Simplify the logic handling the EvaluationMethods mixin class for Expression

archive/issues_020622.json:
```json
{
    "body": "CC:  nthiery tscrim\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/20859\n\n",
    "created_at": "2016-06-21T08:22:11Z",
    "labels": [
        "symbolics",
        "major",
        "enhancement"
    ],
    "title": "Simplify the logic handling the EvaluationMethods mixin class for Expression",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20622",
    "user": "jdemeyer"
}
```
CC:  nthiery tscrim



Issue created by migration from https://trac.sagemath.org/ticket/20859





---

archive/issue_comments_284653.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-06-21T08:26:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284653",
    "user": "jdemeyer"
}
```

New commits:



---

archive/issue_comments_284654.json:
```json
{
    "body": "You really should use new-style classes. Old-style classes exist only for backwards compatibility and will be gone in Python 3.",
    "created_at": "2016-06-21T08:27:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284654",
    "user": "jdemeyer"
}
```

You really should use new-style classes. Old-style classes exist only for backwards compatibility and will be gone in Python 3.



---

archive/issue_comments_284655.json:
```json
{
    "body": "I just moved your branch from #20686 here. Feel free to rewrite history to make it depend only on #20825.",
    "created_at": "2016-06-21T08:39:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284655",
    "user": "jdemeyer"
}
```

I just moved your branch from #20686 here. Feel free to rewrite history to make it depend only on #20825.



---

archive/issue_comments_284656.json:
```json
{
    "body": "The use of `cls.__dict__` seems to preclude the use of inheritance since `cls.__dict__` does not do MRO lookup while `dir(cls)` does.",
    "created_at": "2016-06-21T08:41:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284656",
    "user": "jdemeyer"
}
```

The use of `cls.__dict__` seems to preclude the use of inheritance since `cls.__dict__` does not do MRO lookup while `dir(cls)` does.



---

archive/issue_comments_284657.json:
```json
{
    "body": "Thanks for creating the ticket and splitting of the commit! I am fine with this depending on #20686.",
    "created_at": "2016-06-22T10:23:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284657",
    "user": "nthiery"
}
```

Thanks for creating the ticket and splitting of the commit! I am fine with this depending on #20686.



---

archive/issue_comments_284658.json:
```json
{
    "body": "Replying to [comment:3 jdemeyer]:\n> You really should use new-style classes. Old-style classes exist only for backwards compatibility and will be gone in Python 3.\n\nFun: from the same premises, we arrive at opposite conclusions :-)\n\nHere is my logical chain:\n\nIn Python 3 we won't make the inheritance from object explicit: it would be\nredundant to write:\n\n```\n        class XXXMethods(object):\n```\n\n\nFurthermore, for our XXXMethods classes, it does not matter whether\nthey are old style or new style classes (they just are bags of\nmethods). Thus it feels natural to use right away the Python 3\nidiom. That's what we have been doing in all the categories.",
    "created_at": "2016-06-22T10:25:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284658",
    "user": "nthiery"
}
```

Replying to [comment:3 jdemeyer]:
> You really should use new-style classes. Old-style classes exist only for backwards compatibility and will be gone in Python 3.

Fun: from the same premises, we arrive at opposite conclusions :-)

Here is my logical chain:

In Python 3 we won't make the inheritance from object explicit: it would be
redundant to write:

```
        class XXXMethods(object):
```


Furthermore, for our XXXMethods classes, it does not matter whether
they are old style or new style classes (they just are bags of
methods). Thus it feels natural to use right away the Python 3
idiom. That's what we have been doing in all the categories.



---

archive/issue_comments_284659.json:
```json
{
    "body": "Replying to [comment:5 jdemeyer]:\n> The use of `cls.__dict__` seems to preclude the use of inheritance since `cls.__dict__` does not do MRO lookup while `dir(cls)` does.\n\nThat's on purpose, for consistency with what we do in categories: the `XXXMethods` are meant to be pure mixins / bags of methods; they are not supposed to inherit from anything.",
    "created_at": "2016-06-22T10:27:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284659",
    "user": "nthiery"
}
```

Replying to [comment:5 jdemeyer]:
> The use of `cls.__dict__` seems to preclude the use of inheritance since `cls.__dict__` does not do MRO lookup while `dir(cls)` does.

That's on purpose, for consistency with what we do in categories: the `XXXMethods` are meant to be pure mixins / bags of methods; they are not supposed to inherit from anything.



---

archive/issue_comments_284660.json:
```json
{
    "body": "Replying to [comment:8 nthiery]:\n> `XXXMethods` are meant to be pure mixins / bags of methods;\n\nGiven that it's a `class`, I would expect it to behave like a `class`. If you insist that it should not behave like a `class`, then at least make it explicit and invent a new metaclass `BagOfMethods` which disallows inheritance for example.\n\n> they are not supposed to inherit from anything.\n\nHow is a random Sage developer supposed to know that? That's one thing that I really don't like about the category framework in general: it makes several assumptions which work fine most of the time, but can bite you badly (the automatic binding is another such one). It almost feels like a slightly different programming language (that `class` is not *really* a Python class, it's just a dict).",
    "created_at": "2016-06-22T12:19:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284660",
    "user": "jdemeyer"
}
```

Replying to [comment:8 nthiery]:
> `XXXMethods` are meant to be pure mixins / bags of methods;

Given that it's a `class`, I would expect it to behave like a `class`. If you insist that it should not behave like a `class`, then at least make it explicit and invent a new metaclass `BagOfMethods` which disallows inheritance for example.

> they are not supposed to inherit from anything.

How is a random Sage developer supposed to know that? That's one thing that I really don't like about the category framework in general: it makes several assumptions which work fine most of the time, but can bite you badly (the automatic binding is another such one). It almost feels like a slightly different programming language (that `class` is not *really* a Python class, it's just a dict).



---

archive/issue_comments_284661.json:
```json
{
    "body": "Replying to [comment:7 nthiery]:\n> Furthermore, for our XXXMethods classes, it does not matter whether\n> they are old style or new style classes\n\nIt might matter in more places than you think. There will be some porting effort needed to transition from old-style classes to new-style classes (some issues came up in #20686). It would be better to do this now to avoid unexpected issues with Python 3.\n\nFor this reason, I am very against this change:\n\n```diff\n-    class EvaluationMethods(object):\n+    class EvaluationMethods:\n```\n",
    "created_at": "2016-06-22T12:25:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284661",
    "user": "jdemeyer"
}
```

Replying to [comment:7 nthiery]:
> Furthermore, for our XXXMethods classes, it does not matter whether
> they are old style or new style classes

It might matter in more places than you think. There will be some porting effort needed to transition from old-style classes to new-style classes (some issues came up in #20686). It would be better to do this now to avoid unexpected issues with Python 3.

For this reason, I am very against this change:

```diff
-    class EvaluationMethods(object):
+    class EvaluationMethods:
```




---

archive/issue_comments_284662.json:
```json
{
    "body": "Replying to [comment:10 jdemeyer]:\n> Replying to [comment:7 nthiery]:\n> > Furthermore, for our XXXMethods classes, it does not matter whether\n> > they are old style or new style classes\n> \n> It might matter in more places than you think. There will be some porting effort needed to transition from old-style classes to new-style classes (some issues came up in #20686). It would be better to do this now to avoid unexpected issues with Python 3.\n> \n> For this reason, I am very against this change:\n> {{{\n> #!diff\n> -    class EvaluationMethods(object):\n> +    class EvaluationMethods:\n> }}}\n\nI already did tests with inheriting from object in some XXXMethods,\nand the category framework kept working the exact same way. I am\ntherefore convinced there won't be anything to change for that\nspecific aspect for Python 3.\n\nFurthermore, the more consistent things will be across the library,\nthe easier the porting will be.\n\nCheers,\n                            Nicolas",
    "created_at": "2016-06-22T14:16:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284662",
    "user": "nthiery"
}
```

Replying to [comment:10 jdemeyer]:
> Replying to [comment:7 nthiery]:
> > Furthermore, for our XXXMethods classes, it does not matter whether
> > they are old style or new style classes
> 
> It might matter in more places than you think. There will be some porting effort needed to transition from old-style classes to new-style classes (some issues came up in #20686). It would be better to do this now to avoid unexpected issues with Python 3.
> 
> For this reason, I am very against this change:
> {{{
> #!diff
> -    class EvaluationMethods(object):
> +    class EvaluationMethods:
> }}}

I already did tests with inheriting from object in some XXXMethods,
and the category framework kept working the exact same way. I am
therefore convinced there won't be anything to change for that
specific aspect for Python 3.

Furthermore, the more consistent things will be across the library,
the easier the porting will be.

Cheers,
                            Nicolas



---

archive/issue_comments_284663.json:
```json
{
    "body": "Replying to [comment:11 nthiery]:\n> I already did tests with inheriting from object in some XXXMethods,\n> and the category framework kept working the exact same way.\n\nSo you did some limited testing now and it worked. That's a good thing, but it doesn't guarantee that it will work in all cases now and in the future. As a general principle, we should try to move Sage as close to Python 3 as possible. Python 3 has only new-style classes, so we should use new-style classes.\n\n> Furthermore, the more consistent things will be across the library, the easier the porting will be.\n\nTrue, but besides the point.\n\nAnd of course, this just means that we should use new-style classes everywhere in Sage.",
    "created_at": "2016-06-22T15:17:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284663",
    "user": "jdemeyer"
}
```

Replying to [comment:11 nthiery]:
> I already did tests with inheriting from object in some XXXMethods,
> and the category framework kept working the exact same way.

So you did some limited testing now and it worked. That's a good thing, but it doesn't guarantee that it will work in all cases now and in the future. As a general principle, we should try to move Sage as close to Python 3 as possible. Python 3 has only new-style classes, so we should use new-style classes.

> Furthermore, the more consistent things will be across the library, the easier the porting will be.

True, but besides the point.

And of course, this just means that we should use new-style classes everywhere in Sage.



---

archive/issue_comments_284664.json:
```json
{
    "body": "Replying to [comment:9 jdemeyer]:\n> Given that it's a `class`, I would expect it to behave like a\n> `class`. If you insist that it should not behave like a `class`,\n> then at least make it explicit and invent a new metaclass\n> `BagOfMethods` which disallows inheritance for example.\n\nUsing a metaclass would mean one more piece of purely technical\nsyntax, which is one more chance for the programmer to forget\nsomething. Still you have a good point here: the infrastructure should\ncheck that XXXMethods inherits from nothing, and raise an explanatory\nerror message if not.\n\n> How is a random Sage developer supposed to know that? That's one\n> thing that I really don't like about the category framework in\n> general: it makes several assumptions which work fine most of the\n> time, but can bite you badly (the automatic binding is another such\n> one). It almost feels like a slightly different programming language\n> (that `class` is not *really* a Python class, it's just a dict).\n\nThat's the problem with every framework: a Django programmer needs to\nlearn some about Django, etc, either from example by looking at\nexisting code, or by reading the documentation.\n\nNow does Sage really need such a framework? I am convinced enough\nabout it to have invested altogether one solid year of work into\nit. Which does not mean I am not completely wrong :-)\n\nI also believe in concise syntax with minimal boilerplate. Of course\nthe price is additional complexity for those developers like you that\nnot only use, but also work on the infrastructure itself.\n\nCheers,\n                             Nicolas",
    "created_at": "2016-06-22T23:43:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284664",
    "user": "nthiery"
}
```

Replying to [comment:9 jdemeyer]:
> Given that it's a `class`, I would expect it to behave like a
> `class`. If you insist that it should not behave like a `class`,
> then at least make it explicit and invent a new metaclass
> `BagOfMethods` which disallows inheritance for example.

Using a metaclass would mean one more piece of purely technical
syntax, which is one more chance for the programmer to forget
something. Still you have a good point here: the infrastructure should
check that XXXMethods inherits from nothing, and raise an explanatory
error message if not.

> How is a random Sage developer supposed to know that? That's one
> thing that I really don't like about the category framework in
> general: it makes several assumptions which work fine most of the
> time, but can bite you badly (the automatic binding is another such
> one). It almost feels like a slightly different programming language
> (that `class` is not *really* a Python class, it's just a dict).

That's the problem with every framework: a Django programmer needs to
learn some about Django, etc, either from example by looking at
existing code, or by reading the documentation.

Now does Sage really need such a framework? I am convinced enough
about it to have invested altogether one solid year of work into
it. Which does not mean I am not completely wrong :-)

I also believe in concise syntax with minimal boilerplate. Of course
the price is additional complexity for those developers like you that
not only use, but also work on the infrastructure itself.

Cheers,
                             Nicolas



---

archive/issue_comments_284665.json:
```json
{
    "body": "Replying to [comment:12 jdemeyer]:\n> And of course, this just means that we should use new-style classes everywhere in Sage.\n\nEverywhere, unless we have a good reason to be convinced this does not make a difference.\n\nWould we really gain something worth the trouble by adding an explicit inheritance from object in all 292 XXXMethods classes in Sage, and then removing them after the switch to Python3, with all the risks of induced syntactical conflicts, when we know that they are treated uniformly?\n\nThere are real issues in the switch to Python 3, and I believe this is not one.\n\nCheers,",
    "created_at": "2016-06-23T00:03:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284665",
    "user": "nthiery"
}
```

Replying to [comment:12 jdemeyer]:
> And of course, this just means that we should use new-style classes everywhere in Sage.

Everywhere, unless we have a good reason to be convinced this does not make a difference.

Would we really gain something worth the trouble by adding an explicit inheritance from object in all 292 XXXMethods classes in Sage, and then removing them after the switch to Python3, with all the risks of induced syntactical conflicts, when we know that they are treated uniformly?

There are real issues in the switch to Python 3, and I believe this is not one.

Cheers,



---

archive/issue_comments_284666.json:
```json
{
    "body": "Replying to [comment:13 nthiery]:\n> Using a metaclass would mean one more piece of purely technical\n> syntax, which is one more chance for the programmer to forget\n> something. Still you have a good point here: the infrastructure should\n> check that XXXMethods inherits from nothing, and raise an explanatory\n> error message if not.\n\nI'm not saying a metaclass is the right solution, it was just some proposal. That being said, you could think if there are other ways in which your \"bag-of-methods\" classes differ from \"real\" classes. Such differences might be handled cleanly by such metaclass. For example, you could use the metaclass to disable automatic binding of methods or to disallow instantiation of the class.",
    "created_at": "2016-06-23T06:24:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284666",
    "user": "jdemeyer"
}
```

Replying to [comment:13 nthiery]:
> Using a metaclass would mean one more piece of purely technical
> syntax, which is one more chance for the programmer to forget
> something. Still you have a good point here: the infrastructure should
> check that XXXMethods inherits from nothing, and raise an explanatory
> error message if not.

I'm not saying a metaclass is the right solution, it was just some proposal. That being said, you could think if there are other ways in which your "bag-of-methods" classes differ from "real" classes. Such differences might be handled cleanly by such metaclass. For example, you could use the metaclass to disable automatic binding of methods or to disallow instantiation of the class.



---

archive/issue_comments_284667.json:
```json
{
    "body": "Replying to [comment:13 nthiery]:\n> I also believe in concise syntax with minimal boilerplate.\n\nI know :-) but sometimes that concise syntax just hides all kinds of stuff which is better made explicit. Like I said before: if I see a `class`, I expect it to behave like a `class`.",
    "created_at": "2016-06-23T06:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284667",
    "user": "jdemeyer"
}
```

Replying to [comment:13 nthiery]:
> I also believe in concise syntax with minimal boilerplate.

I know :-) but sometimes that concise syntax just hides all kinds of stuff which is better made explicit. Like I said before: if I see a `class`, I expect it to behave like a `class`.



---

archive/issue_comments_284668.json:
```json
{
    "body": "The hypothetical metaclass would also serve as entry point to documentation. If I see\n\n```\nclass ElementMethods(BagOfStuff):\n    ....\n```\n\nsomewhere and want to understand what it does, I could do\n\n```\nsage: BagOfStuff?\n```\n\nwhich will hopefully explain that this class isn't really a class, but just some syntax to define a dict.\n\nI don't know those `XXXMethods` classes well enough to say whether it's the right solution, but it's certainly something you should consider.\n\nAnd this `BagOfStuff` would of course be a new-style class, rendering the other discussion obsolete :-)",
    "created_at": "2016-06-23T08:06:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284668",
    "user": "jdemeyer"
}
```

The hypothetical metaclass would also serve as entry point to documentation. If I see

```
class ElementMethods(BagOfStuff):
    ....
```

somewhere and want to understand what it does, I could do

```
sage: BagOfStuff?
```

which will hopefully explain that this class isn't really a class, but just some syntax to define a dict.

I don't know those `XXXMethods` classes well enough to say whether it's the right solution, but it's certainly something you should consider.

And this `BagOfStuff` would of course be a new-style class, rendering the other discussion obsolete :-)



---

archive/issue_comments_284669.json:
```json
{
    "body": "I know I am repeating myself, but just to clear, I think there are two possible ways:\n\n1. Either you use a plain `class XXXMethods` but then it should behave like a class.\n\n2. Or it's something else, say `class XXXMethods(BagOfStuff)` and then you can have all kinds of strange behaviour that you document in `BagOfStuff?`.",
    "created_at": "2016-06-23T08:45:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20622",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20622#issuecomment-284669",
    "user": "jdemeyer"
}
```

I know I am repeating myself, but just to clear, I think there are two possible ways:

1. Either you use a plain `class XXXMethods` but then it should behave like a class.

2. Or it's something else, say `class XXXMethods(BagOfStuff)` and then you can have all kinds of strange behaviour that you document in `BagOfStuff?`.
