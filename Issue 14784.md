# Issue 14784: Return unevaluated derivative from BuiltinFunction

archive/issues_014784.json:
```json
{
    "body": "CC:  @burcin\n\nThere should be a way to return an unevaluated derivative from within the `_derivative_` or `_tderivative_` method of a `BuiltinFunction`. Perhaps by returning `None`, like `_eval_` does for remaining unevaluated. As of now returning `None` causes a segmentation fault.\n\nThis is important because for multivariate functions often only the derivative with respect to one variable may be known, so we want to return the unevaluated derivative if it's taken with respect to a variable in which we don't know the derivative. Right now it seems the only way to not return an evaluated derivative is to raise an exception.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15021\n\n",
    "created_at": "2013-08-07T19:24:42Z",
    "labels": [
        "component: symbolics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Return unevaluated derivative from BuiltinFunction",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14784",
    "user": "https://github.com/eviatarbach"
}
```
CC:  @burcin

There should be a way to return an unevaluated derivative from within the `_derivative_` or `_tderivative_` method of a `BuiltinFunction`. Perhaps by returning `None`, like `_eval_` does for remaining unevaluated. As of now returning `None` causes a segmentation fault.

This is important because for multivariate functions often only the derivative with respect to one variable may be known, so we want to return the unevaluated derivative if it's taken with respect to a variable in which we don't know the derivative. Right now it seems the only way to not return an evaluated derivative is to raise an exception.

Issue created by migration from https://trac.sagemath.org/ticket/15021





---

archive/issue_events_043169.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14784",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14784#event-43169"
}
```



---

archive/issue_events_043170.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14784",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14784#event-43170"
}
```



---

archive/issue_events_043171.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14784",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14784#event-43171"
}
```



---

archive/issue_events_043172.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14784",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14784#event-43172"
}
```



---

archive/issue_events_043173.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14784",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14784#event-43173"
}
```



---

archive/issue_comments_188260.json:
```json
{
    "body": "This issue was discussed before. We have the functionality in `FDerivativeOperator`, it's just not available on top level or as a method on BuiltinFunction instances:\n\n[http://permalink.gmane.org/gmane.comp.mathematics.sage.devel/58041](http://permalink.gmane.org/gmane.comp.mathematics.sage.devel/58041)\n\nI thought this stuff was on trac somewhere already, but I cannot find it presently. For archival purposes:\n\n```\nfrom sage.symbolic.operators import FDerivativeOperator\nclass Doperator:\n    def __init__(self,vars=None):\n        self.vars= [] if vars is None else vars\n\n    def __call__(self,f):\n        return FDerivativeOperator(f,self.vars)\n\n    def __getitem__(self,i):\n        if isinstance(i,tuple):\n            newvars=self.vars+list(i)\n        else:\n            newvars=self.vars+[i]\n        return Doperator(newvars)\n\nD=Doperator()\n```\n\nWith that code one can input the form that sage prints:\n\n```\nsage: var('x,y')\nsage: D[0](f)(x, y)/x + D[0, 1](f)(x, y)\nD[0](f)(x, y)/x + D[0, 1](f)(x, y)\n```\n\nInput will never be in Leibnitz notation, since unevaluated functions do not have names for their parameters, just position numbers for them.",
    "created_at": "2015-01-31T17:02:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14784",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14784#issuecomment-188260",
    "user": "https://github.com/nbruin"
}
```

This issue was discussed before. We have the functionality in `FDerivativeOperator`, it's just not available on top level or as a method on BuiltinFunction instances:

[http://permalink.gmane.org/gmane.comp.mathematics.sage.devel/58041](http://permalink.gmane.org/gmane.comp.mathematics.sage.devel/58041)

I thought this stuff was on trac somewhere already, but I cannot find it presently. For archival purposes:

```
from sage.symbolic.operators import FDerivativeOperator
class Doperator:
    def __init__(self,vars=None):
        self.vars= [] if vars is None else vars

    def __call__(self,f):
        return FDerivativeOperator(f,self.vars)

    def __getitem__(self,i):
        if isinstance(i,tuple):
            newvars=self.vars+list(i)
        else:
            newvars=self.vars+[i]
        return Doperator(newvars)

D=Doperator()
```

With that code one can input the form that sage prints:

```
sage: var('x,y')
sage: D[0](f)(x, y)/x + D[0, 1](f)(x, y)
D[0](f)(x, y)/x + D[0, 1](f)(x, y)
```

Input will never be in Leibnitz notation, since unevaluated functions do not have names for their parameters, just position numbers for them.
