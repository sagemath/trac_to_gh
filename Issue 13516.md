# Issue 13516: Scale legendre_P to [a,b]

Issue created by migration from https://trac.sagemath.org/ticket/13720

Original creator: mjo

Original creation time: 2012-11-18 01:27:47

Assignee: burcin

The Legendre polynomials, returned by `legendre_P()`, of the first kind are orthogonal over [-1,1] and are normalized to have value +-1 at the endpoints.

When solving least-squares problems, it's convenient to be able to construct them over an arbitrary interval [a,b].


---

Comment by mjo created at 2012-11-19 04:04:32

Changing status from new to needs_review.


---

Comment by fwclarke created at 2012-11-25 18:54:17

* The code seems over-complicated to me.  Replacing the last few lines with 

```
    R = PolynomialRing(ZZ, 't')
    f = R([(-1)^(n - k)*binomial(n, k)*binomial(n + k, k) for k in range(n + 1)])
    return f((x - a)/(b - a))
```

  is much simpler and is significantly faster.  Moreover, this makes expressions such as

```
legendre_P(4, Zmod(5), 3, 6)
```

   evaluate correctly; at it stands the patch yields an

```
ArithmeticError: 0^0 is undefined.
```


* I don't see why `a` and `b` need to be real numbers.  Actually they could be polynomial variables, giving:

```
sage: R.<r,s,t> = QQ[]
sage: legendre_P(2, t, r, s)
6*((r - t)/(r - s) - 1)*(r - t)/(r - s) + 1
```


* I don't see the need to use `bool` in doctests such as

```
bool(legendre_P(0, x, 0, 1) == p0)
```


* It's not clear to me why back-quotes are used in some of the error strings:

```
        raise TypeError('`n` must be a natural number')
```

   but

```
        raise ValueError('n must be nonnegative')
```



---

Comment by fwclarke created at 2012-11-25 18:54:17

Changing status from needs_review to needs_work.


---

Comment by mjo created at 2012-11-26 06:13:16

Replying to [comment:2 fwclarke]:
> * The code seems over-complicated to me.  Replacing the last few lines with 
> {{{
>     R = PolynomialRing(ZZ, 't')
>     f = R([(-1)^(n - k)*binomial(n, k)*binomial(n + k, k) for k in range(n + 1)])
>     return f((x - a)/(b - a))
> }}}
>   is much simpler and is significantly faster.  Moreover, this makes expressions such as
> {{{
> legendre_P(4, Zmod(5), 3, 6)
> }}}
>    evaluate correctly; at it stands the patch yields an
> {{{
> ArithmeticError: 0^0 is undefined.
> }}}
> 



I tried this, but it's producing the wrong results. For example,


```
sage: legendre_P(1, x)
-1/2*x - 5/2
```


That said, there are two reasons it might seem over-complicated.

The first is that I was very careful not to break any existing doctests, even though they're doing some crazy things. I tried to comment each of these hurdles.

The second is that I wanted to be clear about what was happening. The `c(m)` and `g(m)` functions are as defined in A&S. So the final `return` statement is exactly the form given in the reference. The use of the affine transform `phi()` allows me to retain that form, and also provides some rationale for the result. I think this makes it (more) clear that we're composing the standard `P()` over [-1,1] with an affine transform, which will intuitively preserve orthogonality.



> * I don't see why `a` and `b` need to be real numbers.  Actually they could be polynomial variables, giving:
> {{{
> sage: R.<r,s,t> = QQ[]
> sage: legendre_P(2, t, r, s)
> 6*((r - t)/(r - s) - 1)*(r - t)/(r - s) + 1
> }}}
> 



I'm happy to change this if it can be done without breaking the existing doctests. I'll wait to see what you say about the first thing.



> * I don't see the need to use `bool` in doctests such as
> {{{
> bool(legendre_P(0, x, 0, 1) == p0)
> }}}



Often, the `==` operator will return a symbolic equality rather than True/False. This is true even in this simple case:


```
sage: p0 = 1
sage: legendre_P(0, x, 0, 1) == p0
1 == 1
```


If you cast the symbolic equality to `bool`, you get,

* True, if Sage can convince itself that equality holds.
* False, if Sage can "prove" inequality.
* False, if it's not sure.

So it should be safe to test for `True`.



> * It's not clear to me why back-quotes are used in some of the error strings:
> {{{
>         raise TypeError('`n` must be a natural number')
> }}}
>    but
> {{{
>         raise ValueError('n must be nonnegative')
> }}}



I was just careless with that one, I'll fix it. I think backticks or single quotes are needed around 'a' and 'b', otherwise it reads weird. But 'n' at the beginning is fine without it.


---

Comment by mjo created at 2012-11-29 04:18:55

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2012-11-29 04:18:55

I've fixed the variable quoting in the new patch, and allowed the endpoints a,b to be symbolic. There's also a new test to make sure that the symbolic endpoints work as expected.

I haven't heard back, so maybe you bought my reasoning for the affine transform =)

The `bool()` casts do have to stay, otherwise the tests just don't work.

Thanks for taking a look.


---

Comment by fwclarke created at 2012-11-29 10:30:14

Replying to [comment:4 mjo]:
> I've fixed the variable quoting in the new patch, and allowed the endpoints a,b to be symbolic. There's also a new test to make sure that the symbolic endpoints work as expected.

Why force them to be symbolic?  Better, surely, to allow anything that will evaluate and let coercion handle it. 

> I haven't heard back, so maybe you bought my reasoning for the affine transform =)

No, just busy with other things.  There is an affine transform in what I wrote, but it's a transform of the interval [a, b] onto [0, 1] rather than [-1, 1].  This is simpler, and the Legendre polynomials on the interval [0, 1] have a simple form.

>  I tried this, but it's producing the wrong results. For example,
> {{{
> sage: legendre_P(1, x)
> -1/2*x - 5/2
> }}}
This is what results from using `^` rather than `**` in python.  I'm sorry my proposed code had only been testing in Sage, and therefore was being prepared.  This dealt with, my version does pass all the doctests, is faster when if the variable is a polynomial generator, and the error

```
sage: legendre_P(4, Zmod(5)(1), 3, 6)
...
ArithmeticError: 0^0 is undefined.
```

is eliminated.  Apologies for mistyping this before.

> The `bool()` casts do have to stay, otherwise the tests just don't work.

Another way of doing this is to introduce a polynomial variable.  Thus

```
sage: R.<x> = QQ[]
sage: legendre_P(1, x) == x
True
```

I know very little about the symbolic side of Sage, but I do find things like

```
sage: SR(1) == SR(1)
1 == 1
```

very strange, and confusing when compared with

```
sage: 1 == 1
True
```



---

Comment by fwclarke created at 2012-11-29 10:30:14

Changing status from needs_review to needs_work.


---

Comment by mjo created at 2012-12-01 04:30:25

Replying to [comment:5 fwclarke]:
> Why force them to be symbolic?  Better, surely, to allow anything that will evaluate and let coercion handle it. 



I removed the RR check, so you can actually pass in anything you want now. I'm not convinced this isn't a foot-gun, but it's still a clear improvement over what we have now so I'm happy with it.



> This is what results from using `^` rather than `**` in python.



Ah, yes, I should have caught that, sorry.




> I'm sorry my proposed code had only been testing in Sage, and therefore was being prepared.  This dealt with, my version does pass all the doctests, is faster when if the variable is a polynomial generator, and the error
> {{{
> sage: legendre_P(4, Zmod(5)(1), 3, 6)
> ...
> ArithmeticError: 0^0 is undefined.
> }}}
> is eliminated.  Apologies for mistyping this before.
> 


I believe this is another bug, elsewhere. I've set out to fix it and am trapped in a rabbit hole at the moment, about four bugs from here. Once that's sorted out, I'll do some experiments.




> > The `bool()` casts do have to stay, otherwise the tests just don't work.
> 
> Another way of doing this is to introduce a polynomial variable.  Thus
> {{{
> sage: R.<x> = QQ[]
> sage: legendre_P(1, x) == x
> True
> }}}
> I know very little about the symbolic side of Sage, but I do find things like
> {{{
> sage: SR(1) == SR(1)
> 1 == 1
> }}}
> very strange, and confusing when compared with
> {{{
> sage: 1 == 1
> True
> }}}



You'll get no argument from me there. I do prefer to test with the default symbol `x` though just because that's what most people will use.


---

Comment by kcrisman created at 2013-04-21 03:29:14

I think that people on this ticket may find #9706 interesting, though I imagine it has bitrotted somewhat and Burcin had a very long list of comments for it.


---

Comment by mjo created at 2013-04-23 15:54:00

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2013-04-23 15:54:00

Replying to [comment:7 kcrisman]:
> I think that people on this ticket may find #9706 interesting, though I imagine it has bitrotted somewhat and Burcin had a very long list of comments for it.

That's too big to ever get merged... I would break out the functions into individual tickets where possible.

Anyway, I was waiting here on #13786 which fixes the `ArithmeticError: 0^0 is undefined` mentioned above. Unfortunately, both implementations now fail due to some other error on `legendre_P(4, Zmod(5)(1), 3, 6)`, but what can you do.

Now the only difference between my implementation and the one in comment 2 is speed: mine is slightly faster unscaled, and that one is slightly faster on a nonstandard interval. But both deltas are negligible, and I have an aesthetic preference for the algorithm that's described in the reference.

This still passes all the tests and is a big improvement over what we have so I'm going to put it up for review again.


---

Comment by kcrisman created at 2013-06-18 21:31:10

Brief questions:
 * When special-casing `n=0`, you have 

```
return 1
```

  Will this be a Python int?
 * What if `n` is a Python int?

```
We can accept Python integers for ``x`` as well::
```

 * How's speed?  I can imagine the sum thing getting slow.
 * Am I misreading this?  Should it be beta = 1?

```
# From Abramowitz & Stegun, (22.3.2) with alpha = beta = 0. 
```

  Oh, I see.  [It's actually (22.3.1)](http://people.math.sfu.ca/~cbm/aands/page_775.htm) and maybe this should be in the code with a reference section.


---

Attachment

When n=0, I try to return unity from the same ring as the variable:


```
if n == 0:
    # Easy base case, save time. Attempt to return a value in the
    # same field/ring as x.
    try:
        return x.parent()(1)
    except AttributeError:
        # In case something without a parent was given for x.
        return 1
```


The exceptional case is just there as a failsafe, and it would probably give a python int. I guess ZZ(1) is better, so I've changed it.

If `n` is a python int, we're happy. Early in the function we check that `n` can be coerced into `ZZ`. Then later,


```
# Ensure that (2**n) is an element of ZZ. This is used later --
# we can divide finite field elements by integers but we can't
# multiply them by rationals at the moment.
n = ZZ(n)
```



For speed, the current implementation has,


```
sage: timeit('legendre_P(100,x)')
5 loops, best of 3: 57.1 ms per loop
```


The posted patch has,


```
sage: timeit('legendre_P(100,x)')
5 loops, best of 3: 47.3 ms per loop
```


So, even for the unscaled version it's an improvement. There's a slowdown for the scaled version, of course:


```
sage: timeit('legendre_P(100,x,-5,10)')
5 loops, best of 3: 70.4 ms per loop
```


But it's still very fast.

You're right about the reference, I must have typo'd it. It's fixed, and I've added a REFERENCES section to the docs.

The new patch is up, I forgot to check the box, so use the one with the "2" at the end.


---

Comment by kcrisman created at 2013-06-20 00:05:05

Changing status from needs_review to needs_work.


---

Comment by kcrisman created at 2013-06-20 00:05:05

Thanks.  I'm glad I asked, because before

```
sage: legendre_P(0,float(1))
1
sage: type(_)
<type 'int'>
```

but now

```
sage: legendre_P(0,float(1))
1
sage: type(_)
<type 'sage.rings.integer.Integer'>
```


Work:
 * So to my surprise, plotting these things works great.  It would be nice to add one or two examples.
 * I wouldn't ask for this on this ticket, but it probably should have one or two examples of the errors actually catching silly input.  I find it worthwhile to test those branches.
Is that okay?  Otherwise I think this is nice.


---

Comment by kcrisman created at 2013-06-20 00:06:27

Oh, I should ask the dumb question of whether this scaling is standard in terminology, or whether we need any other disclaimers.


---

Comment by mjo created at 2013-06-24 01:53:03

Ok, I added a plotting example, and three tests for nonsense input. They're at the end of their respective sections.

What might not be standard terminology? "Scaling"? In any case I don't think I'm qualified to say, but it made sense to me at the time.


---

Comment by mjo created at 2013-06-24 01:53:03

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2013-06-24 01:58:32

Use tmp_filename() instead of SAGE_TMP


---

Attachment

Quick update to use tmp_filename() per Jeroen's comment on #12852.


---

Comment by chapoton created at 2013-08-21 08:24:09

apply only sage-trac_13720.patch


---

Comment by fwclarke created at 2013-11-01 10:07:32

Changing status from needs_review to needs_work.


---

Attachment

I really don't understand why `a` and `b` get converted into symbolic expressions.  This has some very strange consequences, e.g.,

```
sage: legendre_P(3, 7, -1/2, 1/2).parent()
Symbolic Ring
```

It is my understanding that coercion should arrange that the parent of an expression is as close as possible to the parents of the constituant parts.  It is thus wrong to force (almost) everything into the Symbolic Ring.

But anyway, I'm afraid I still prefer my version of the code: (1) for its simplicity (having 3 local functions, two of them only used once, seems far too over-elaborate); (2) my code is significantly faster.

If you don't like that then something like

```
    if a == -1 and b == 1:
        _init()
        return sage_eval(maxima.eval('legendre_p(%s,x)'%ZZ(n)), locals={'x':x})
    else:
        return legendre_P(n, (2*x - a - b)/(b - a), -1, 1)
```

would be a very simple change to the existing code which avoids 'reinventing the wheel'.  This would also have the advantage that an almost identical change would provide scaled versions for the the Legendre functions `legendre_Q` of the second kind.  However the maxima code is very slow.

Incidentally, in all cases there needs to be a check to see if `a == b`.


---

Comment by mjo created at 2013-12-11 17:17:16

Replying to [comment:18 fwclarke]:
> I really don't understand why `a` and `b` get converted into symbolic expressions.  This has some very strange consequences, e.g.,
> {{{
> sage: legendre_P(3, 7, -1/2, 1/2).parent()
> Symbolic Ring
> }}}
> It is my understanding that coercion should arrange that the parent of an expression is as close as possible to the parents of the constituant parts.  It is thus wrong to force (almost) everything into the Symbolic Ring.

I had a comment in the code about this, but I've forgotten the details. In any case -- whatever the issue was -- it seems to be fixed. I removed the manual coercions of n,a,b and all of the tests still pass.

So this is fixed:


```
sage: legendre_P(3, 7, -1/2, 1/2).parent()
Rational Field
```



> Incidentally, in all cases there needs to be a check to see if `a == b`.  

This will throw a divide-by-zero. What's the alternative?


---

Comment by mjo created at 2013-12-11 17:22:16

> This will throw a divide-by-zero. What's the alternative? 

Nevermind, stupid question =)


---

Comment by mjo created at 2013-12-11 17:34:36

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2013-12-11 17:34:36

This should address the `a==b` issue and avoid the coercions.
----
New commits:


---

Comment by mjo created at 2013-12-11 17:37:38

Adding an author, as I merged the reviewer patch.


---

Comment by chapoton created at 2014-04-09 20:59:46

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2014-04-09 20:59:46

This needs to be rebased.


---

Comment by git created at 2014-04-23 04:51:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2014-04-23 04:53:52

I had to change the `_init()` doctest to use the laguerre polynomials instead, since the implementation of `legendre_P()` no longer uses maxima.


---

Comment by mjo created at 2014-04-23 04:53:52

Changing status from needs_work to needs_review.


---

Comment by kcrisman created at 2014-04-23 14:27:41

I'm not sure if they're related, but the Maxima

```
assoc_legendre_p[v,u] (z)      Legendre function of degree v and order u 
assoc_legendre_q[v,u] (z)      Legendre function, 2nd kind
```

from [the symbolic wiki on Trac](http://trac.sagemath.org/wiki/symbolics/functions) could be relevant here.  If so, we should have conversions - if not, sorry for the noise.


---

Comment by mjo created at 2014-04-23 14:40:55

Replying to [comment:27 kcrisman]:
> I'm not sure if they're related, ...

Those two functions are different than our `legendre_{P,Q}`. Maxima has matching `legendre_p(n,x)` and `legendre_q(n,x)` which we're currently using for our implementations.

I updated the note on the wiki page.


---

Comment by kcrisman created at 2014-04-23 15:11:17

> > I'm not sure if they're related, ...
> 
> Those two functions are different than our `legendre_{P,Q}`. Maxima has matching `legendre_p(n,x)` and `legendre_q(n,x)` which we're currently using for our implementations.
> 
> I updated the note on the wiki page.
Thanks, and I updated based on that update, very helpful.


---

Comment by rws created at 2014-05-09 09:01:59

patchbot:

```
sage -t --long src/sage/functions/orthogonal_polys.py  # 33 doctests failed
```



---

Comment by rws created at 2014-05-09 09:01:59

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2014-05-09 20:00:26

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2014-05-09 20:00:26

I have corrected the problem (and also make a little cleanup). Back to needs review.
----
New commits:


---

Comment by git created at 2014-12-09 21:18:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2014-12-09 22:11:17

Thanks for cleaning that up, I had forgotten about it.


---

Comment by rws created at 2015-03-11 17:27:59

Conflicts with #16813. We might want to merge efforts.


---

Comment by kdilks created at 2015-10-11 20:11:45

New commits:


---

Comment by rws created at 2015-10-12 05:52:13

Changing status from needs_review to needs_work.


---

Comment by rws created at 2015-10-12 05:52:13

You introduced merge conflict markers in your branch. Better always eyeball your diff before committing.


---

Comment by kdilks created at 2015-10-12 06:00:10

Yeesh, yeah, thought it was just the one thing, but a lot more needs to be cleaned up. I'll take care of that tomorrow.


---

Comment by kdilks created at 2015-10-12 15:30:46

I'll just change it back and let Frédéric deal with rebasing.


---

Comment by mjo created at 2021-02-23 02:42:36

Let's just kill this. I'm not going to rewrite the whole function from scratch, as would be necessary at this point.


---

Comment by mjo created at 2021-02-23 02:42:36

Changing status from needs_work to positive_review.


---

Comment by kcrisman created at 2021-02-23 03:34:51

Changing status from positive_review to needs_work.


---

Comment by kcrisman created at 2021-02-23 03:34:51

Can't someone else start from scratch, though?  It seems like a worthwhile ticket to have open.


---

Comment by mjo created at 2021-02-23 03:56:38

Replying to [comment:45 kcrisman]:
> Can't someone else start from scratch, though?  It seems like a worthwhile ticket to have open.

It would be tricky since `legendre_P` is now implemented as a `BuiltinFunction`. You would need a different symbolic function for each interval `[a,b]` because, for example, its symbolic derivative changes when the interval does. But it's probably doable somehow.

I was the original reporter and also the author. If I remember correctly, I needed it to simplify  some finite element example problem, and these days I have no need for it. But naturally I wouldn't object to someone else making an attempt.
