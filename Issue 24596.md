# Issue 24596: parent should only depend on input parent

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2018-02-26 08:00:08

CC:  rws

The aim of this ticket is to apply the following principle of least surprise

  _The ouptut parent should only depend on the input parent._

Many Sage numerical functions contradict the above principle:
- on integers

```
sage: parent(ZZ(4).sqrt())
Integer Ring
sage: parent(ZZ(2).sqrt())
Symbolic Ring
```

- on real mpfr floating point

```
sage: parent(RR(1.0).log())
Real Field with 53 bits of precision
sage: parent(RR(-1.0).log())
Complex Field with 53 bits of precision
```

- on double precision floating point

```
sage: parent(RDF(1.0).log())
Real Double Field
sage: parent(RDF(-1.0).log())
Complex Double Field
```


The parallel can be done with mathematical functions that have a well defined domain and codomain. In the above examples, the member functions try to be two things at the same time: a partial function of the initial domain (ie `log` from the positive reals to the reals) or as a domain restriction of a more general one (ie `log` on complexes minus the negative real line).

There are basically two ways to sort this out (see also [this sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/4GwCuJ_-TaQ))
- change the output domain to wider by default (i.e. `RR(1.0).log()` would be the `0` in `CC`)
- raise a `ValueError` when the domain is not appropriate

The above just stands for the _default_ behavior. It would still be possible to switch behaviors with one of
- an extra keyword parameter like `extend=True` or `codomain=CC`
- distinct member functions `log_real` and `log_complex`

For an element of comparison, in the Python standard library, `math` is dealing with real floating point (both input/output). A `ValueError` is raised when the input is not in the domain

```
sage: import math
sage: math.log(-1.0r)
Traceback (most recent call last):
...
ValueError: math domain error
```

While `cmath` is dealing with complexes (input/output)

```
sage: import cmath
sage: cmath.log(-1.0r)
3.141592653589793j
sage: cmath.log(2.0r)
(0.6931471805599453+0j)
```

The `mpmath` library is also silently converting `mpf` to `mpc` depending on the domain

```
sage: import mpmath
sage: x = mpmath.mpf('2.0')
sage: mpmath.log(x)
mpf('0.69314718055994529')
sage: x = mpmath.mpf('-1.0')
sage: mpmath.log(x)
mpc(real='0.0', imag='3.1415926535897931')
```



---

Comment by jdemeyer created at 2018-02-26 08:41:23

I think we might also make a difference between _methods_ and _functions_. The methods really act on a specific parent, so there it makes more sense to be strict. But I think that global functions like `sqrt()` can be less strict and violate the principle of "output parent should depend only on input parent".


---

Comment by vdelecroix created at 2018-02-26 08:59:14

Ticket description update: I only want to deal with member functions for now.


---

Comment by rws created at 2018-02-26 09:00:47

Replying to [comment:1 jdemeyer]:
> I think we might also make a difference between _methods_ and _functions_. The methods really act on a specific parent, so there it makes more sense to be strict. But I think that global functions like `sqrt()` can be less strict and violate the principle of "output parent should depend only on input parent".

Exactly, and since most global functions are symbolic, and users of calculus do not expect that they need special arguments or functions to get extended behaviour that behaviour should be default for global functions.


---

Comment by vdelecroix created at 2018-02-26 09:08:25

`@`rws: why did you erase my modifications on the ticket description!?


---

Comment by rws created at 2018-02-26 09:52:09

Replying to [comment:5 vdelecroix]:
> `@`rws: why did you erase my modifications on the ticket description!?

I did? Ah, I didn't reload before adding my comment. Sorry.
