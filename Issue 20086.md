# Issue 20086: Common TestSuite for MIP backends

Issue created by migration from https://trac.sagemath.org/ticket/20323

Original creator: mkoeppe

Original creation time: 2016-03-30 16:35:03

CC:  dimpase ncohen vdelecroix vbraun nthiery

Keywords: lp

I think the backends should be tested using a common `TestSuite`. Right now each backend uses its own doctests, which have slightly diverged from each other, so there is nothing (other than the fact that they were the result of copy-paste from each other) that ensures consistency. (#20296 fixes several wrong doctests in `GenericBackend`, from which I tried to copy-paste, for example.)

Pointers on how to do this would be welcome.


---

Comment by dimpase created at 2016-03-31 16:47:14

within the existing framework it's easy to create a separate module, say, lp_backend_tests, and do such tests there.
Not sure how to minimize the bloat, though, as each function should have doctests...

Note that total consistency is hard to get, as each backend has its own ideas on how, say, to number and order constraints. E.g., IIRC, gurobi does automatic conversions of some particular kinds of constraints.


---

Comment by mkoeppe created at 2016-04-02 07:31:00

Not ready for review yet, but I'm hoping that perhaps someone familiar with the `TestSuite` mechanism could tell me whether I'm on the right track with this initial patch on this ticket.
----
New commits:


---

Comment by tscrim created at 2016-04-02 14:07:21

It looks like you are. Any method that starts with `_test` gets run by `TestSuite`. Although I am not really in favor of any test mutating the object in question.

Also, is there a reason why `GenericBackend` needs to inherit from `SageObject` (as opposed to just the Python `object`)? I am pretty sure this is strictly needed...


---

Comment by mkoeppe created at 2016-04-06 03:55:44

Thanks for taking a look, Travis.

Replying to [comment:4 tscrim]:
> Also, is there a reason why `GenericBackend` needs to inherit from `SageObject` (as opposed to just the Python `object`)?

`SageObject` provides some of the basic testing infrastructure, such as `._test_not_implemented_methods`.
Well, there's also `sage.misc.sage_unittest.PythonObjectWithTests`, but I can't seem to `cimport` it to make it a base class of `GenericBackend`. So I guess I'll stick with `SageObject`.


---

Comment by git created at 2016-04-06 06:47:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-06 07:07:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mkoeppe created at 2016-04-06 07:08:52

Branch is on top of various closed/reviewed LP tickets from #20302. Will rebase on top of next 'develop' later.


---

Comment by git created at 2016-04-06 07:42:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nthiery created at 2016-04-06 15:40:43

Hi Matthias!

Just had a brief look at your TestSuite usage. This sounds very sensible indeed.

Inheriting from PythonObjectWithTests would indeed make sense; however since it's currently a plain Python class, one can't inherit from it in a Cython class. This could be fixed though.

Cheers,
                                       Nicolas


---

Comment by git created at 2016-04-08 17:11:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2016-04-08 17:17:36

There are two types of `_test_...` methods, which are illustrated by the following examples:


```
    ## This test method is written as an instance method that works
    ## even if variables and constraints have already been added to the backend.
    ## The test makes changes to the backend.
    def _test_add_linear_constraints(self, **options):
        """
        Run tests on the method :meth:`.add_linear_constraints`.

        TESTS:

        Test, with an actual working backend, that the test works even if the problem
        is not empty at the beginning::

            sage: from sage.numerical.backends.generic_backend import get_solver
            sage: p = get_solver(solver='GLPK')
            sage: p.add_variables(2)
            1
            sage: p.add_linear_constraint([[0, 17], [1, 89]], None, 42)
            sage: p._test_add_linear_constraints()
        """
        tester = self._tester(**options)
        nrows_before = self.nrows()
        nrows_added = 5
        self.add_linear_constraints(nrows_added, None, 2)
        nrows_after = self.nrows()
        # Test correct number of rows
        tester.assertEqual(nrows_after, nrows_before+nrows_added, "Added the wrong number of rows")
        # Test contents of the new rows are correct (sparse zero)
        for i in range(nrows_before, nrows_after):
            tester.assertEqual(self.row(i), ([], []))
            tester.assertEqual(self.row_bounds(i), (None, 2.0))

    ## Any test methods involving calls to 'solve' are set up as class methods,
    ## which make a fresh instance of the backend.
    @classmethod
    def _test_solve(cls, tester=None, **options):
        """
        Trivial test for the solve method.

        TEST::

            sage: from sage.numerical.backends.generic_backend import GenericBackend
            sage: p = GenericBackend()
            sage: p._test_solve()
            Traceback (most recent call last):
            ...
            NotImplementedError: ...
        """
        p = cls()                         # fresh instance of the backend
        if tester is None:
            tester = p._tester(**options)
        # From doctest of GenericBackend.solve:
        tester.assertIsNone(p.add_linear_constraints(5, 0, None))
        tester.assertIsNone(p.add_col(range(5), range(5)))
        tester.assertEqual(p.solve(), 0)
        tester.assertIsNone(p.objective_coefficient(0,1))
        from sage.numerical.mip import MIPSolverException
        #with tester.assertRaisesRegexp(MIPSolverException, "unbounded") as cm:  ## --- too specific
        with tester.assertRaises(MIPSolverException) as cm:   # unbounded
            p.solve()
```


I've translated these from existing doctests (either from `GenericBackend` or some real backend) by hand. `_test_solve` already reveals another bug in the CVXOPT backend. 
The plan is to use #20376 to semi-automatically add new `_test` methods.


---

Comment by mkoeppe created at 2016-04-08 17:17:36

Changing status from new to needs_review.


---

Comment by git created at 2016-04-08 17:25:52

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2016-04-08 17:26:48

Rebased on top of 7.2.beta3 + #20326.


---

Comment by mkoeppe created at 2016-04-08 17:44:15

Needs review, especially regarding my use or abuse of the testing framework...


---

Comment by vdelecroix created at 2016-04-08 20:12:50

You should not implement `_test_*` method that modifies the object. I am not sure there is any control in which order things are executed. It would be better in this case to not use the test suite. I would rather have a file tests.py that is only made of doctests.

Moreover, it would make sense to also have comparison between different implementations. You can start with

```
sage: milps = []
sage: milps.append(MixedIntegerLinearProgram(solver='cplex')  # optional - cplex
sage: milps.append(MixedIntegerLinearProgram(solver='coin')    # optional - cbc
```

and then loop over the elements in milps.


---

Comment by mkoeppe created at 2016-04-08 21:23:45

Replying to [comment:17 vdelecroix]:
> You should not implement `_test_*` method that modifies the object. I am not sure there is any control in which order things are executed. 

As I pointed out in the comment above `_test_add_linear_constraints` in comment 13, these instance methods are written in a way that the order does not matter.

The second example uses a class method and runs its tests on fresh instances, so it does not make modifications.

If it is policy that `_test` methods cannot modify the object, then I can rewrite all tests as class methods like in the second example.

I would rather like to avoid using doctests (in fact I'm trying to replace the superficial, copy-paste-driven testing that is there now); and `TestSuite` seems like exactly the right thing to enforce the API of concrete implementations of an abstract class.


---

Comment by tscrim created at 2016-04-09 07:01:02

From taking a quick look at what you are testing, it looks more like you should have a separate file with test functions that takes a backend, creates an instance of it, and runs the basic tests, and then have a "master" function which takes the backend and feeds it to each of those functions (or some small variant of this). IMO, this is a better way to do the things that you want, and it means for each (new) backend, you only have to add a test to pass it to the "master" function. It also has a bit of a fringe benefit of consolidating the testing of the backends.

It is possible the user will want to run `TestSuite` on a particular instance, and will be quite surprised if the object has mutated. Another valid option would be to make a copy of the instance and do the mutations to that.


---

Comment by nthiery created at 2016-04-09 20:46:58

Or maybe putting the _test_* methods on the backends, with each _test_method starting by creating a new instance.

Cheers,
                                Nicolas


---

Comment by git created at 2016-04-09 22:20:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2016-04-09 22:38:19

Replying to [comment:20 nthiery]:
> Or maybe putting the _test_* methods on the backends, with each _test_method starting by creating a new instance.

Thanks Nicolas, Vincent, and Travis for your comments. 

I agree, making changes to the object may be surprising to users who are in the habit of running the testsuite on objects.

I have now converted the `_test_*` methods that were previously making changes into methods that create a new instance. 
(This is in line with what Nicolas suggests.)

All `_test_*` methods are now actually marked as classmethods, so these methods don't even get access to the instance, so they can't modify it. Here's an example.

```
    @classmethod
    def _test_add_linear_constraints(cls, tester=None, **options):
        """
        Run tests on the method :meth:`.add_linear_constraints`.

        TEST::

            sage: from sage.numerical.backends.generic_backend import GenericBackend
            sage: p = GenericBackend()
            sage: p._test_add_linear_constraints()
            Traceback (most recent call last):
            ...
            NotImplementedError
        """
        p = cls()                         # fresh instance of the backend
        if tester is None:
            tester = p._tester(**options)
        nrows_before = p.nrows()
        nrows_added = 5
        p.add_linear_constraints(nrows_added, None, 2)
        nrows_after = p.nrows()
        # Test correct number of rows
        tester.assertEqual(nrows_after, nrows_before+nrows_added, "Added the wrong number of rows")
        # Test contents of the new rows are correct (sparse zero)
        for i in range(nrows_before, nrows_after):
            tester.assertEqual(p.row(i), ([], []))
            tester.assertEqual(p.row_bounds(i), (None, 2.0))
```


Some of you suggested that the tests should be in a different file; but I don't see how that would help. I would rather like to keep them as close as possible to the definitions of the methods in `GenericBackend`; after all the point of the new tests is to tighten the definition of the API of the backends. 

The nice thing about having these `_test_*` methods automatically inherited by all concrete backends is that they cannot just "forget" running the tests for them when it would be "convenient" to do so.


---

Comment by vdelecroix created at 2016-04-09 22:43:22

Some remarks before looking once more at the code:

- It would actually be interesting for the tests to have access to the objects. They are non trivially initialized (maximization vs minimization, constraints, etc). Using them as a base (with copy) each test suite would actually run different tests.

- This approach does not allow to cross check the backends (?).


---

Comment by git created at 2016-04-09 23:02:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2016-04-09 23:04:03

Replying to [comment:23 vdelecroix]:
> Some remarks before looking once more at the code:
> 
> - It would actually be interesting for the tests to have access to the objects. They are non trivially initialized (maximization vs minimization, constraints, etc). Using them as a base (with copy) each test suite would actually run different tests.

If one wants to write such a test, one can just remove the `@`classmethod decorator. This makes indeed sense for the various getter methods.  As an example, I have just added the following test method:

```
    def _test_ncols_nonnegative(self, **options):
        tester = self._tester(**options)
        p = self
        tester.assertGreaterEqual(self.ncols(), 0)
```


> - This approach does not allow to cross check the backends (?).

The idea is that all backends are checked against the same set of tests. (In contrast to the current doctests, in which each backend decides by copy-paste what is convenient to be tested.)
I plan to distill a good set of tests by means of #20376 from the existing doctests of the various backends.


---

Comment by mkoeppe created at 2016-04-09 23:10:17

I forgot to remark, I wouldn't want to rely on `copy` so much at the moment, because the nontrivial copy methods of the backends are essentially untested (doctests there to please the patchbot), just like the rest of the API.


---

Comment by git created at 2016-04-10 00:54:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2016-04-10 01:02:55

Replying to [comment:23 vdelecroix]:
> - It would actually be interesting for the tests to have access to the objects. They are non trivially initialized (maximization vs minimization, constraints, etc). Using them as a base (with copy) each test suite would actually run different tests.

I think now I understand better what you meant. 
Indeed, at least some instance `_test` methods -- such as the `_test` methods for `copy` that I just wrote -- would benefit from being invoked for various examples.


---

Comment by git created at 2016-04-10 01:39:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-10 07:37:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2016-04-11 09:12:37

I recall asking how one deals with different backends producing different, albeit equivalent, outputs. E.g. some of them would even introduce extra variables for some constraints (see e.g. [here](http://trac.sagemath.org/ticket/13148#comment:2)). Some backends assign names to constraints automatically.


---

Comment by tmonteil created at 2016-04-11 14:51:40

Changing status from needs_review to needs_work.


---

Comment by tmonteil created at 2016-04-11 14:51:40

Note that currently the tests do not pass when `cbc` is installed, see the logs at http://patchbot.sagemath.org/log/20323/debian/8.3/i686/3.16.0-4-586/tmonteil-debian-jessie-32/2016-04-11%2008:33:06


---

Comment by dimpase created at 2016-04-11 15:19:48

this would also show errors just fine:
http://patchbot.sagemath.org/log/20323/debian/8.3/i686/3.16.0-4-586/tmonteil-debian-jessie-32/2016-04-11%2008:33:06?short

anyhow, it looks as if there are also errors not related to cbc. Wrong git branch?


---

Comment by tmonteil created at 2016-04-11 15:36:00

Replying to [comment:34 dimpase]:
> Wrong git branch?

Apparently not, the indicated commit is f40980646e129eeb501a51fd06e99eb98d83a4f3


---

Comment by mkoeppe created at 2016-04-11 15:45:06

Yes, lots of tests fail!
And I haven't even really started adding tests.

It's the whole point of writing this test suite.


---

Comment by mkoeppe created at 2016-04-11 15:46:00

Replying to [comment:32 dimpase]:
> I recall asking how one deals with different backends producing different, albeit equivalent, outputs. E.g. some of them would even introduce extra variables for some constraints (see e.g. [here](http://trac.sagemath.org/ticket/13148#comment:2)). Some backends assign names to constraints automatically.

Thanks for the pointer to that ticket. Yes, the tests need to be written in a way that they accommodate the solvers.


---

Comment by git created at 2016-04-11 19:03:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2016-04-11 19:09:30

I've split this ticket. Now the branch has only tests that pass; other tests will appear on #20424.
Ready for review.


---

Comment by mkoeppe created at 2016-04-11 19:09:30

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2016-04-13 19:45:03

please rebase over the latest beta. there is a small merge conflict:

```
diff --cc src/sage/numerical/backends/generic_backend.pyx
index aef0cb0,d554470..0000000
--- a/src/sage/numerical/backends/generic_backend.pyx
+++ b/src/sage/numerical/backends/generic_backend.pyx
@@@ -1330,9 -1408,7 +1414,13 @@@ cpdef GenericBackend get_solver(constra
          sage: p.base_ring()
          Real Double Field
          sage: p = get_solver(base_ring=QQ); p
++<<<<<<< HEAD
 +        <sage.numerical.backends.ppl_backend.PPLBackend object at ...>
 +        sage: p = get_solver(base_ring=ZZ); p
 +        <sage.numerical.backends.ppl_backend.PPLBackend object at ...>
++=======
+         <...sage.numerical.backends.ppl_backend.PPLBackend...>
++>>>>>>> 22511250dd688bba5d98672fb89b0f779fd28e97
          sage: p.base_ring()
          Rational Field
          sage: p = get_solver(base_ring=AA); p
```



---

Comment by dimpase created at 2016-04-13 19:45:39

**


---

Comment by dimpase created at 2016-04-13 19:45:39

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-04-13 22:52:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mkoeppe created at 2016-04-13 22:54:17

rebased on 7.2.beta4


---

Comment by mkoeppe created at 2016-04-13 22:54:17

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2016-04-14 06:12:03

OK, good.


---

Comment by dimpase created at 2016-04-14 06:12:40

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-04-15 07:15:47

Resolution: fixed
