# Issue 26884: Global function fields: divisors

Issue created by migration from https://trac.sagemath.org/ticket/27121

Original creator: klee

Original creation time: 2019-01-25 10:45:09

This is part of the meta-ticket #22982.

The goal of the present ticket is to add code for computing with divisors of global function fields.


---

Comment by git created at 2019-02-12 09:08:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2019-02-12 09:09:30

Changing status from new to needs_review.


---

Comment by tscrim created at 2019-02-13 16:25:05

Here are my comments.

The `__radd__` should not be necessary as the coercion framework should take care of that (which you are using with `_add_`), unless you are trying to explicitly avoid the coercion framework (as the coercions you would need are not (or should not) be there).

Is there a way to minimize the duplication of `divisor`, `divisor_of_zeros`, and `divisor_of_poles` in the two files (say, by putting them in a common base class for the respective files)? It all looks like basically the same code.

`self.divisor_group()(0)` -> `self.divisor_group().zero()` (the latter is cached).

Similarly, I am not sure I like having the `zero_divisor` method. If anything, it should do `DivisorGroup(field).zero()` and not be used to construct the `0` of the divisor group. I am slightly in favor of removing it for the explicitness of the code (as it is a one-liner), but I can somewhat see how it might be a more natural operation.

I don't see the point in the `valuation_ring` method as it does not involve `self`. This was something I missed on a previous review, but I noticed here because of the diff.

The `keys` here is unnecessary: `sorted(self._data.keys())`.

It is faster to use `while s and o:` instead of `while len(s) > 0 and len(o) > 0:`.


---

Comment by klee created at 2019-02-14 04:21:44

Replying to [comment:4 tscrim]:
> The `__radd__` should not be necessary as the coercion framework should take care of that (which you are using with `_add_`), unless you are trying to explicitly avoid the coercion framework (as the coercions you would need are not (or should not) be there).

How could I achieve the following without `__radd__`?  An integer (in particular zero) is not supposed to be coerced to a place. Then how the coercion framework could enable the example below.  Would you give me hints?

```
        This is only to support the ``sum`` function, that adds
        the argument to initial (int) zero.

        EXAMPLES::

            sage: k.<a>=GF(2)
            sage: K.<x>=FunctionField(k)
            sage: sum(K.places_finite())
            Place (x) + Place (x + 1)

        .. NOTE:

        This does not work though::

            sage: 0 + K.place_infinite()
            Traceback (most recent call last):
            ...
            TypeError: unsupported operand parent(s) for +: ...

        The reason is that the ``0`` is a Sage integer, for which
        the coercion system applies. 
```



---

Comment by git created at 2019-02-14 04:22:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2019-02-14 04:23:29

Replying to [comment:4 tscrim]:

> Is there a way to minimize the duplication of `divisor`, `divisor_of_zeros`, and `divisor_of_poles` in the two files (say, by putting them in a common base class for the respective files)? It all looks like basically the same code.

Right. Done.

> 
> `self.divisor_group()(0)` -> `self.divisor_group().zero()` (the latter is cached).
> 

Done.

> Similarly, I am not sure I like having the `zero_divisor` method. If anything, it should do `DivisorGroup(field).zero()` and not be used to construct the `0` of the divisor group. I am slightly in favor of removing it for the explicitness of the code (as it is a one-liner), but I can somewhat see how it might be a more natural operation.

Done.

> 
> I don't see the point in the `valuation_ring` method as it does not involve `self`. This was something I missed on a previous review, but I noticed here because of the diff.

Removed.

> 
> The `keys` here is unnecessary: `sorted(self._data.keys())`.
> 

Done.

> It is faster to use `while s and o:` instead of `while len(s) > 0 and len(o) > 0:`.

Done.


---

Comment by tscrim created at 2019-02-14 05:41:56

Replying to [comment:5 klee]:
> Replying to [comment:4 tscrim]:
> > The `__radd__` should not be necessary as the coercion framework should take care of that (which you are using with `_add_`), unless you are trying to explicitly avoid the coercion framework (as the coercions you would need are not (or should not) be there).
> 
> How could I achieve the following without `__radd__`?  An integer (in particular zero) is not supposed to be coerced to a place. Then how the coercion framework could enable the example below.  Would you give me hints?

To get this to work, you would need to allow `0` to convert into the parent (which is a special case within the coercion framework). So that is why this works:

```
sage: 0 + vector([1,2,1])
(1, 2, 1)
sage: coercion_model.canonical_coercion(0, v)
((0, 0, 0), (1, 2, 1))
```

So if you want it to work, you can hack something together to have `0` be some sort of allowed conversion to a dummy element.


---

Comment by tscrim created at 2019-02-14 05:46:43

Also, the `.. NOTE::` block should have two colons and the following text should be indented, but this might be moot.


---

Comment by klee created at 2019-02-14 07:24:28

Replying to [comment:8 tscrim]:
> Replying to [comment:5 klee]:
> > Replying to [comment:4 tscrim]:
> > > The `__radd__` should not be necessary as the coercion framework should take care of that (which you are using with `_add_`), unless you are trying to explicitly avoid the coercion framework (as the coercions you would need are not (or should not) be there).
> > 
> > How could I achieve the following without `__radd__`?  An integer (in particular zero) is not supposed to be coerced to a place. Then how the coercion framework could enable the example below.  Would you give me hints?
> 
> To get this to work, you would need to allow `0` to convert into the parent (which is a special case within the coercion framework). So that is why this works:
> {{{
> sage: 0 + vector([1,2,1])
> (1, 2, 1)
> sage: coercion_model.canonical_coercion(0, v)
> ((0, 0, 0), (1, 2, 1))
> }}}
> So if you want it to work, you can hack something together to have `0` be some sort of allowed conversion to a dummy element.

For vectors, `0` is naturally understood as zero vector, and the coercion system implements this. But as I said above, I don't want `0` to be coerced as some place (there is nothing like **zero place**). All I want is to make `sum(a bunch of places)` work.


---

Comment by git created at 2019-02-14 08:13:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2019-02-14 16:57:43

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2019-02-14 16:57:43

Okay, if it does what you want, then positive review.


---

Comment by klee created at 2019-02-14 23:18:55

Replying to [comment:12 tscrim]:
> Okay, if it does what you want, then positive review.

I admit that the `__radd__` thing is ugly. What I want is to allow `0 + p` for a place `p` to result in the **divisor** `p` (=`1*p`; divisors are just formal sums of places).  I wish that I could //fix// this later when I have a solution example of similar situation. 

Thank you!


---

Comment by vbraun created at 2019-02-15 13:02:15

Resolution: fixed
