# Issue 20647: line buffering in sage-logger causes "hang" due to invisible prompt when installing experimental packages

Issue created by migration from Trac.

Original creator: mkoeppe

Original creation time: 2016-06-26 22:19:41

CC:  jdemeyer embray vbraun kcrisman dimpase vdelecroix novoselt

(Observed on Mac OS X.)

As I reported in http://trac.sagemath.org/ticket/20708#comment:8:

When installing an "experimental" package, Sage warns a lot and then prompts the user. 
Because of line buffering, one does not see the prompt, but Sage just waits indefinitely.

```
sage -f latte_int
...
[latte_int-1.7.3] =========================== WARNING ===========================
[latte_int-1.7.3] You are about to download and install an experimental package.
[latte_int-1.7.3] This probably won't work at all for you! There is no guarantee
[latte_int-1.7.3] that it will build correctly, or behave as expected.
[latte_int-1.7.3] Use at your own risk!
[latte_int-1.7.3] ===============================================================
```

<--- This is where it asks "[latte_int-1.7.3] Are you sure you want to continue [Y/n]?" but this is line-buffered and not visible to the user.


---

Comment by vbraun created at 2016-06-26 23:36:26

IMHO we just shouldn't ask questions here, a (potentially) parallel make session is just not an interactive process. Either do it or bail out and require a command line switch `--experimental` to opt-in.


---

Comment by mkoeppe created at 2016-06-26 23:37:54

I think so too.


---

Comment by embray created at 2016-06-27 08:56:46

+1, just keep the message.


---

Comment by kcrisman created at 2016-06-28 14:18:53

I also think it's fine for _experimental_ packages to just run and fail.  As long as there isn't any potential to mess up the rest of Sage (like with messed up runs of `make`).


---

Comment by embray created at 2016-06-28 14:29:09

Here's a patch to remove the prompt entirely.

Might be good to find a fix to the underlying problem, since in principle there could be some other prompt somewhere that would be hidden in the same way.  I'm not sure how best to fix this though--would have to disable line-buffering on such prompts somehow.
----
New commits:


---

Comment by embray created at 2016-06-28 14:29:09

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2016-06-28 17:07:09

This would be fine with me. But it could be argued that this warning is too easy to overlook (and comes too late) and so the point of distinguishing between optional and experimental packages is lost.


---

Comment by dimpase created at 2016-06-29 07:24:47

I don't think simply removing this dialog is the right thing to do.


---

Comment by dimpase created at 2016-06-29 07:38:29

Changing status from needs_review to needs_work.


---

Comment by embray created at 2016-06-29 08:23:35

> This would be fine with me. But it could be argued that this warning is too easy to overlook (and comes too late) and so the point of distinguishing between optional and experimental packages is lost.

I'm not sure what you suggest differently, other than moving the warning a little earlier?

But if someone doesn't read their build output it will be lost on them anyways.  That's okay, because it's "merely" a warning.


---

Comment by embray created at 2016-06-29 08:42:05

Dima has a point that removing the prompt outright is potentially disruptive.  

What if we moved the warning so that there's no prompt if running `make <packagename>` directly, as a package developer might do.  But running `./sage -i` for an experimental package both displays the warning and the prompt (before ever even running `make`, much less `sage-logger`).


---

Comment by mkoeppe created at 2016-06-29 16:16:42

Replying to [comment:13 embray]:
> Dima has a point that removing the prompt outright is potentially disruptive.  
> 
> What if we moved the warning so that there's no prompt if running `make <packagename>` directly, as a package developer might do.  But running `./sage -i` for an experimental package both displays the warning and the prompt (before ever even running `make`, much less `sage-logger`).

I think `./sage -i PACKAGENAMES...` should display the warning and the prompt before at the very beginning, before installing any package.

As per Volker's initial suggestion, a command-line switch `--experimental` should override the prompt. This would be useful in a script. I didn't know that `make PACKAGENAME` works; but in any case it would be better to be able to use "sage -i" also from a script.


---

Comment by embray created at 2016-06-30 08:37:24

`make <packagename>` is how all packages are built.  `sage -i` is just a thin front-end over that.

It appears the warning/prompt comes from the `sage-spkg` (which is the program responsible for unpacking the package, running `spkg-install`, etc) which is in turn called by make.  

I tried reworking this yesterday in a way that didn't change `sage-spkg`, but to make that prompt happen _right_ away it would have to moved either into the makefile itself, or into the `sage` command, though I think it's good to have the warning when running `sage-spkg` too.  So I'd hate to have duplicate copies of the warning.

In other words it's not exactly clear where the best place would be for it.  Jeroen might have some ideas but he's on holiday right now so we won't bug him about it.


---

Comment by git created at 2016-06-30 12:38:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2016-06-30 12:39:19

Welp, this is definitely more complicated than it was before, but I think it's pretty good.


---

Comment by embray created at 2016-06-30 12:39:29

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-06-30 12:44:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2016-06-30 13:03:26

looks good to me


---

Comment by dimpase created at 2016-06-30 13:03:26

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-06-30 19:18:54

On OSX:

```
config.status: creating directory /Users/buildslave-sage/slave/sage_git/build/local/lib
config.status: creating directory /Users/buildslave-sage/slave/sage_git/build/local/share
config.status: creating directory /Users/buildslave-sage/slave/sage_git/build/local/var/lib/sage/installed
build/bin/sage-logger \
		"cd build/make && ./install 'start'" logs/install.log
build/bin/sage-logger: line 48: read: -N: invalid option
read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]
make: *** [start] Error 141
program finished with exit code 2
```



---

Comment by vbraun created at 2016-06-30 19:18:54

Changing status from positive_review to needs_work.


---

Comment by dimpase created at 2016-06-30 19:54:47

oops... perhaps one can just replace `-N` with `-n` ?


---

Comment by dimpase created at 2016-07-01 07:47:05

With `IFS` unset, at least, `-n` appears to be equivalent to `-N`.


---

Comment by embray created at 2016-07-01 11:03:29

And here I thought by relying entirely on bash features this would be portable.  Leave it to OSX to "think different"!

Mysteriously, on my bash `-n` is not quite the same as `-N` even with `IFS` unset.  I think the key is that for `-N` it reads "Delimiter characters  encountered  in  the input are not treated specially and do not cause `read` to return until `nchars` are read".  So in other words, hitting "Enter" with `-N 1` will cause read to return a newline literal.  Whereas for `-n` the delimiter is still treated specially and is *not* returned.  Hitting Enter causes `read` to return with no characters read.  It should be made clear that here "delimiter" is referring to the delimiter that `read` should read up to, not the delimiter(s) used to split a line, which is what `IFS` is.

The solution is to use `-n`, but treat an empty string has having received a newline.


---

Comment by git created at 2016-07-01 11:33:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2016-07-01 14:40:50

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2016-07-03 06:03:42

the last commit did not make it into the branch! Never seen such a strange thing before...


---

Comment by dimpase created at 2016-07-03 06:07:00

Changing status from needs_review to needs_work.


---

Comment by dimpase created at 2016-07-03 06:07:00

sorry, in fact there is still -N left in sage-logger, and I get on OSX

`build/bin/sage-logger: line 48: read: -N: invalid option`


---

Comment by embray created at 2016-07-04 13:05:49

Ah, right.


---

Comment by git created at 2016-07-04 13:24:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2016-07-04 13:24:45

Changing status from needs_work to needs_review.


---

Comment by embray created at 2016-07-04 13:24:45

Fixed `sage-logger` to not use `read -N 1` as well.
----
New commits:


---

Comment by dimpase created at 2016-07-04 14:58:24

OK, this works on OSX.


---

Comment by dimpase created at 2016-07-04 14:58:24

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2016-07-04 17:33:46

Follow up: #20937


---

Comment by vbraun created at 2016-07-04 21:27:35

I'm getting this failure

```
sage -t --long src/sage/tests/cmdline.py
**********************************************************************
File "src/sage/tests/cmdline.py", line 219, in sage.tests.cmdline.test_executable
Failed example:
    print(out)
Expected:
    Found local metadata for sqlite-...
    = SQLite =
    ...
    SQLite is a software library that implements a self-contained,
    serverless, zero-configuration, transactional SQL database engine.
    ...
Got:
    Found local metadata for sqliteautoconf3130000
    = SQLite =
    <BLANKLINE>
    == Description ==
    <BLANKLINE>
    SQLite is a software library that implements a selfcontained,
    serverless, zeroconfiguration, transactional SQL database engine.
    <BLANKLINE>
    == License ==
    <BLANKLINE>
    Public Domain
    <BLANKLINE>
    == Upstream contact ==
    <BLANKLINE>
     * http://www.sqlite.org
    <BLANKLINE>
    == Dependencies ==
    <BLANKLINE>
    * readline
    <BLANKLINE>
    == Special Update/Build Instructions ==
    <BLANKLINE>
    * Use the autoconf version of sqlite.
    <BLANKLINE>
**********************************************************************
1 item had failures:
   1 of 239 in sage.tests.cmdline.test_executable
    [238 tests, 1 failure, 142.30 s]
```



---

Comment by vbraun created at 2016-07-04 21:27:35

Changing status from positive_review to needs_work.


---

Comment by dimpase created at 2016-07-04 22:13:58

looks like a monster is eating up all `-` in there: in `sqlite-autoconf3130000`, in `self-contained`, in `zero-configuration`. So there is something wrong in the update of `build/bin/sage-logger`. (The problem is reproducible on Linux as well as on OSX).


---

Comment by mkoeppe created at 2016-07-04 22:33:07

Perhaps it's best to use a simple solution that doesn't try to be interactive...


---

Comment by dimpase created at 2016-07-05 09:11:35

indeed, `-` does not get echoed:

```
$ cat blah
oh-oh

$ while IFS= read -d'' -s -n 1 char; do echo -n "$char"; done <blah
ohoh

```



---

Comment by embray created at 2016-07-05 09:18:59

Fantastic.  I'm this close to just rewriting this script in Python....


---

Comment by embray created at 2016-07-05 09:21:38

Incidentally, `read -N 1` (as it was before) does _not_ inexplicably eat `-`.


---

Comment by embray created at 2016-07-05 09:41:04

This is so effing bizarre I had to ask about it on Stack Overflow: http://stackoverflow.com/questions/38199974/bash-read-mystery-read-d-s-n-1-eats-hyphens

I think it's a bug in bash, personally, or at least  very ill-documented behavior.  In the meantime I do have a work-around.


---

Comment by git created at 2016-07-05 09:49:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2016-07-05 09:50:16

Changing status from needs_work to needs_review.


---

Comment by embray created at 2016-07-05 09:50:16

Fixed the issue with `sage-logger` eating hyphens.


---

Comment by dimpase created at 2016-07-05 11:20:54

Replying to [comment:40 embray]:
> This is so effing bizarre I had to ask about it on Stack Overflow: http://stackoverflow.com/questions/38199974/bash-read-mystery-read-d-s-n-1-eats-hyphens
> 
> I think it's a bug in bash, personally, or at least  very ill-documented behavior.  In the meantime I do have a work-around.

The internet has solved your problem - you must have a space between `-d` and `''` !
(so this must also be fixed in the other place where you use `-d_` instead of `-d _`)


---

Comment by dimpase created at 2016-07-05 11:20:54

Changing status from needs_review to needs_work.


---

Comment by embray created at 2016-07-05 12:03:01

Wow, I feel silly.  But not too silly either--bash's behavior here is really quite silly IMO.  But very nice.

I actually didn't use `-d_` anywhere else--at least in the current version of this patch the `-d` flag is not used at all.  But I'll still update the patch once more time to use this, since it will simplify things _slightly''.


---

Comment by git created at 2016-07-05 12:12:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2016-07-05 12:20:44

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-07-05 12:23:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2016-07-05 12:38:49

OK, good.


---

Comment by dimpase created at 2016-07-05 12:38:49

Changing status from needs_review to positive_review.


---

Comment by leif created at 2016-07-05 21:54:54

Replying to [comment:44 embray]:
> Wow, I feel silly.  But not too silly either--bash's behavior here is really quite silly IMO.  But very nice.

It's not silly, it's as documented.  `read -d'' -s ...` is equivalent to `read -d '-s' ...` (where only the first character of the string argument `'-s'` is taken as the delimiter, as documented).


---

Comment by leif created at 2016-07-05 23:13:05

That's clearly the wrong solution to the problem.

Did anyone even _think_ of performance when replacing `sed` by a character-by-character _shell loop_ (in addition with two conditionals in it)?

One should probably try this on a single-, maybe dual-core machine.

----

How about simply changing the scripts to output a newline when prompting the user for something, at least when the sage-logger is used?


---

Comment by leif created at 2016-07-05 23:13:05

Changing status from positive_review to needs_work.


---

Comment by leif created at 2016-07-05 23:29:23

I didn't want to wait for the latter to finish, but now it did:

```sh
$ time ./sage-logger-7.3.beta6 -p "cat logs/install.log" test-current.log >/dev/null

real	0m0.311s
user	0m0.170s
sys	0m0.160s
$ time ./sage-logger-20884 -p "cat logs/install.log" test-new.log >/dev/null

real	25m12.620s
user	24m20.680s
sys	0m51.900s
```


(Note that the comparison isn't even exactly fair, since `sed` had to output a longer prefix, and the second time, `install.log` was already in the filesystem cache. ;-) )


---

Comment by vbraun created at 2016-07-06 07:28:16

Resolution: fixed


---

Comment by embray created at 2016-07-06 10:00:54

> How about simply changing the scripts to output a newline when prompting the user for something, at least when the sage-logger is used?

Those scripts don't necessarily have any way to know that `sage-logger` is being used, nor should they.

I think the test of just `cat`ting is not quite fair either.  In a real build the overhead of the commands being run far outweighs the overhead of the logger.  For example running `make patch` on current `develop` I got:


```
real    2m14.225s
user    0m29.614s
sys     1m2.397s
```


while on my branch:


```
real    2m18.844s
user    0m38.751s
sys     1m4.341s
```


So maybe possibly a little slower but hard to say from a single data point.

There's no need to emphasize _shell loop_ since it's using only shell built-ins, or should be, so that shouldn't be a significant source of overhead.  Ultimately `sed` is looping over one character at a time too.  One thing that might speed this up a bit is to not `printf` for every character, but at least buffer that.

Still, point partly taken.  I might prefer to go with my earlier instinct and just rewrite it in Python.  I think using `sed` just to prepend to a line also feels like a blunt instrument.


---

Comment by embray created at 2016-07-06 10:10:04

> It's not silly, it's as documented. read -d'' -s ... is equivalent to read -d '-s' ... (where only the first character of the string argument '-s' is taken as the delimiter, as documented).

Just because it's as documented (which I see now, on very careful read, that the syntax must be `-d<space><delimiter>`).  That's not *unreasonable*, just different from how other commands (specifically `cut`, which is why I was mentally comparing to) take their arguments.  You can't well argue that the syntax of shell commands is always logical or consistent.


---

Comment by embray created at 2016-07-06 14:51:15

FWIW, I also tried running `make patch` with a version that doesn't add the prefix at all and the result from `time` was roughly the same there too.  The point is that the overhead of adding the prefix, regardless how it's done, pales in comparison to the time to run most commands that produce output during the build.


---

Comment by jhpalmieri created at 2016-07-06 14:54:09

Volker, I don't understand why you merged this when it was labeled as "needs_work". At one point, yes, it was marked as "positive_review", but when you merged it, it had gone back to "needs_work" and had been that way for 12 hours.


---

Comment by jhpalmieri created at 2016-07-06 18:53:52

I can confirm Leif's timings. On an OS X machine:

- `make build` from a fresh tarball: 73 minutes. Within that build, it took 19m53s to build `gcc`.
- `make build` from a fresh tarball + this branch: 93 minutes. Within that build, it took 29m57s to build `gcc`.

Following that:
- `./sage -f gcc` took 20m39s without this branch.
- `./sage -f gcc` took 29m15s with this branch.

So the timing difference can be significant. It will be more significant for larger log files, which is why it doesn't make that much difference when building `patch`.


---

Comment by dimpase created at 2016-07-06 19:22:41

Perhaps Erik can explain the need to patch `build/bin/sage-logger` - this is the part that causes the slowdown.


---

Comment by vbraun created at 2016-07-06 19:55:29

Changing status from closed to new.


---

Comment by vbraun created at 2016-07-06 19:55:29

Resolution changed from fixed to 


---

Comment by embray created at 2016-07-07 07:50:05

Okay, thanks for the full `make build` comparison.  That's definitely more convincing.  I'll see what I can do to tinker.

> Perhaps Erik can explain the need to patch build/bin/sage-logger - this is the part that causes the slowdown.

I could--there are good reasons.  But regardless as this stands now it's adding more overhead than any explanation I have justifies, so back to the drawing board.


---

Comment by leif created at 2016-07-08 16:16:14

Replying to [comment:53 embray]:
> > How about simply changing the scripts to output a newline when prompting the user for something, at least when the sage-logger is used?
> 
> Those scripts don't necessarily have any way to know that `sage-logger` is being used, nor should they.

While you could set some env var in "non-interactive" mode (or when the sage-logger is used), what's the problem with having a newline after `"... [Y/n]?"`?

\\

> I think the test of just `cat`ting is not quite fair either.  In a real build the overhead of the commands being run far outweighs the overhead of the logger.

The timings I listed are (the lower bound of) _consumed CPU time you get in addition_ with every build from scratch (not taking into account a GCC build btw.); on a single-core that's what adds to the wall time (plus presumably the overhead of more context switches), and regardless of whether you build any experimental package (or any other question is asked). 

\\

> There's no need to emphasize _shell loop_ since it's using only shell built-ins, or should be,

You were not using bash's built-in test (`[This is the Trac macro *... * that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#... -macro)`), but the speed-up with the latter isn't huge either:


```sh
$ time ./sage-logger-20884-bt -p "cat logs/install.log" test-nw2.log >/dev/null

real	21m51.249s
user	21m15.210s
sys	0m36.170s
```

(i.e., ~22 minutes vs. previously ~25 minutes, saving about 3.5 minutes, and all tests were performed on the same, a _relatively fast_ machine; note that `sys` though dropped by nearly one third.)

\\

> so that shouldn't be a significant source of overhead.  Ultimately `sed` is looping over one character at a time too.

But it's not an interpreter, it compiles the regular expressions instead of rereading and interpreting them over and over, and btw. operates on lines of input -- you've seen the difference (orders of magnitude).

\\

> [...] I might prefer to go with my earlier instinct and just rewrite it in Python.  I think using `sed` just to prepend to a line also feels like a blunt instrument.

Please don't, `sed` is IMHO pretty adequate in lack of other portable tools for this trivial task (prepending something to each line); regarding that we meanwhile have separate log files for each package it's a bit superfluous though, even for parallel builds.  But _as is_ (with `sed`), it doesn't hurt much.

(If at all, I'd personally rewrite the whole sage-logger in C.)


---

Comment by leif created at 2016-07-08 16:26:38

Replying to [comment:54 embray]:
> > It's not silly, it's as documented. read -d'' -s ... is equivalent to read -d '-s' ... (where only the first character of the string argument '-s' is taken as the delimiter, as documented).
> 
> Just because it's as documented (which I see now, on very careful read, that the syntax must be `-d<space><delimiter>`).  That's not *unreasonable*, just different from how other commands (specifically `cut`, which is why I was mentally comparing to) take their arguments.  You can't well argue that the syntax of shell commands is always logical or consistent.

You were also passing an *empty* string, which _there_ gets removed altogether in shell preparsing (`-d_` => `-d`).  (You could likely have written `re_ad ...` for example... 8-) )


---

Comment by dimpase created at 2016-07-09 15:01:23

Anyhow, perhaps we should keep `sage-logger` as it is, and proceed with the rest of the patch.


---

Comment by embray created at 2016-07-11 11:23:47

I have rewritten `sage-logger` in Python.  I'm still doing some performance tests (i.e. on a full build) but all indication so far is that performance is the same or slightly better than the current version.


---

Comment by embray created at 2016-07-11 11:26:56

> You were not using bash's built-in test `[This is the Trac macro * * that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros# -macro)`

No, I was using bash's built-in test `[ ]`.  This is still a bash built-in--it does not run as a separate process.  The only difference between `[ ]` and `[This is the Trac macro * * that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros# -macro)` is that the latter is bash-specific and less portable.  But when run explicitly in bash, as opposed to an arbitrary shell, `test` is still a shell built-in.


---

Comment by embray created at 2016-07-11 11:29:28

> (If at all, I'd personally rewrite the whole sage-logger in C.)

I considered that too.  In fact it might be good to take the Python version I wrote as a prototype for a faster C version.  That said, having a Python version is easier for bootstrapping purposes, and the Python version I wrote is just as fast as the current version, by all indications.


---

Comment by embray created at 2016-07-11 11:36:07

Replying to [comment:61 leif]:
> (If at all, I'd personally rewrite the whole sage-logger in C.)

I considered that too.  In fact it might be good to take the Python version I wrote as a prototype for a faster C version.  That said, having a Python version is easier for bootstrapping purposes, and the Python version I wrote is just as fast as the current version, by all indications (and can certainly be sped up more than the current naive version).


---

Comment by leif created at 2016-07-11 13:16:18

Replying to [comment:65 embray]:
> > You were not using bash's built-in test `[This is the Trac macro * * that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros# -macro)`
> 
> No, I was using bash's built-in test `[ ]`.  This is still a bash built-in--it does not run as a separate process.  The only difference between `[ ]` and `[This is the Trac macro * * that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros# -macro)` is that the latter is bash-specific and less portable.  But when run explicitly in bash, as opposed to an arbitrary shell, `test` is still a shell built-in.

Oh, that's new (to me m) and presumably to bash versions that aren't ages old)...

Still, `[[` is reproducibly faster for me (bash 4.1.5) -- just retested ten times each (with just 0.5 MB input).


---

Comment by chapoton created at 2016-07-12 09:50:32

re-introduced branch name
----
New commits:


---

Comment by leif created at 2016-07-12 14:04:05

IMHO we cannot solve this other than by either

 * disabling prompting the user, or
 * simply printing a newline after the prompt.

(I think the latter solution to users is the less surprising, as it doesn't change the behaviour.)

\\

If the sage-logger _did_ print incomplete lines (such as a prompt from `read`), this would just mess up other output where `echo -n` is used, especially from `configure`.  We'd (again) end up with (now _wrongly_ prefixed!) lines like for example


```
...
[ foo ] checking whether make supports nested variables... /bin/grep
[ bar ] checking build system type... yes
[ baz ] checking for C/C++ restrict keyword... x86_64-unknown-linux-gnu
...
```

where a prefix usually correctly refers to the package from which _the first part of a line_ originated, but the result (at the end of the line) comes from another, so doesn't belong to the first part.  (When building in parallel that is, on the terminal, and in `install.log`.)

In fact, even the left part of a line wouldn't necessarily belong to the package the prefix tells.


---

Comment by vbraun created at 2016-07-12 20:32:31

IMHO we should never have y/n prompts in parallel output. Its pretty much by definition not interactive. The way to pass options to non-interactive processes is via command line options.


---

Comment by mkoeppe created at 2016-07-12 22:37:34

+1


---

Comment by leif created at 2016-07-12 23:37:59

`@`vbraun, `@`mkoeppe:  It's still not clear to me what you propose.

Disable/remove any prompting?  Disable it depending on how `sage-spkg` got invoked?

(Shouldn't `sage -f ...` -- as given in the example -- proceed anyway, since `-f` means _force_? ;-)


---

Comment by embray created at 2016-07-13 08:52:38

Replying to [comment:71 vbraun]:
> IMHO we should never have y/n prompts in parallel output. Its pretty much by definition not interactive. The way to pass options to non-interactive processes is via command line options.

I had this discussion with Dima and we agreed that there should be no prompts when running `make` directly, and that there should only be such a prompt when using the high level interface of `./sage -i`.  So that's a large part of what this patch does, before getting mired in all the issues with the prompt itself.

Maybe I should just refactor things further so that `sage-spkg` itself never prompts (and hence the prompt is never raised during `make`, which calls `sage-spkg`), and instead the prompt is `only` issued by the `sage` script itself before any calls to `make`.


---

Comment by embray created at 2016-07-13 09:55:07

Replying to [comment:70 leif]:
> If the sage-logger _did_ print incomplete lines (such as a prompt from `read`), this would just mess up other output where `echo -n` is used, especially from `configure`.  We'd (again) end up with (now _wrongly_ prefixed!) lines like for example

Point taken on this--I didn't believe this would happen as I did't think `make` would interleave the output of individual commands but it definitely can if it's waiting for output for some command, as is wont to happen with `configure`.  Though if you `make` is new enough (>=4.0) you can enable this behavior with `-Oline`. 

That said, this isn't just an issue with sage-logger.  This can happen even without it, and also happened with the previous version of the logger before I added the prefixing (and the line-buffering that came with it).

I do agree with Volker and others though that there's no reason for user input prompts in make.  So I'll go with my proposed solution above and move the prompt entirely to the top-level user interface, and that will simplify this whole matter greatly.

I would still propose keeping my Python implementation of sage-logger because why not?  I can change it to be line-based instead of character-based and that should actually make it faster than the current version by a bit, I think.


---

Comment by vbraun created at 2016-07-13 10:08:27

+1 for python implementation instead of some untestable bash noise.


---

Comment by leif created at 2016-07-13 13:52:40

Replying to [comment:76 vbraun]:
> +1 for python implementation instead of some untestable bash noise.

The only change I'd perhaps make to the sage-logger (which works and is sufficiently short and simple enough) is to replace `$SED "s/^/$prefix/"` by `cat` if the prefix is empty (i.e., no `-p` given), in order to win a _useless use of cat_ award.  (More precisely, also move the argument to `sed` into `SED`, and let `SED=cat` if the prefix is empty.  Otherwise we'd have to nearly duplicate a line in case the prefix is empty.)

Also, it's fast enough with `sed` (see figures above), so reimplementing it in Python would IMHO be just yet another case of _needless use of Python_ -- in a script that would be executed by _both_ the system's Python and (later) Sage's.

----

I'd be happy with the current branch if Erik just removed the changes to sage-logger from it.


---

Comment by mkoeppe created at 2016-07-16 12:24:56

Changing priority from critical to blocker.


---

Comment by leif created at 2016-07-16 12:40:24

Replying to [comment:78 mkoeppe]:
> ** Priority* changed from critical to blocker

Could we then postpone beautifying the sage-logger to another ticket?

Or do we want to wait with the next release until Erik had a _"quiet, rainy day"_? ;-)


---

Comment by mkoeppe created at 2016-07-16 12:51:53

I have not followed the details of this implementation.
But in any case breaking the installation of all experimental packages is a blocker, IMO.


---

Comment by leif created at 2016-07-16 13:46:42

It isn't really broken, you just have to hit return when installation stops with the warning, or do e.g.

```sh
  echo yes | ./sage -i latte_int
```



---

Comment by mkoeppe created at 2016-07-16 18:37:35

Instead of fixing this, could as well revert #20640, #20708, which caused this problem.


---

Comment by embray created at 2016-07-18 09:10:44

I'm leaving tomorrow on vacation (originally today but my travel plans were diverted from the events in Turkey).

If someone else wants to fix this a very easy workaround (in fact, I would say a solution) without even touching sage-logger is to move the code that prompts the user out of `build/bin/sage-spkg` and into the `sage` script itself which is the "user interface" and the only script that should be prompting anything.


---

Comment by embray created at 2016-07-18 09:12:30

> so reimplementing it in Python would IMHO be just yet another case of needless use of Python -- in a script that would be executed by both the system's Python and (later) Sage's.

It's already been done.  And this is a moot point because Python is a requirement now for bootstrapping the build system, so while it may be "needless" the more we get rid of piles of bash noise the better.  I agree with Volker here.


---

Comment by embray created at 2016-07-18 10:20:21

Even easier is to modify `sage-spkg` so it still handles the prompting (otherwise a lot of package parsing stuff needs to be duplicated), but for `./sage -i` first have it run `sage-spkg -d` (download-only) which is the only context in which those prompts are displayed, then run `make` (which in turn calls `sage-spkg`) but with the package already downloaded, it won't prompt.  I might add some options to `sage-spkg` to make extra sure it doesn't prompt.


---

Comment by embray created at 2016-07-18 12:48:32

Changing status from new to needs_review.


---

Comment by embray created at 2016-07-18 12:48:32

Okay, give this a look.  I've pushed a new branch with a different approach.

The one downside I see to this approach is that if you run `./sage -i <pkg>` for an experimental package, while it _will_ display the warning prompt for that package, if `<pkg>` has any dependencies that are also experimental packages it will not display the prompt for those packages as well (it will still display a warning message).

I think this is acceptable--if the user is accepting to install one experimental package that can include everything that comes along with it.

(Sorry for the noise below--I made a few mistakes in rebasing that I had to fix)
----
New commits:


---

Comment by embray created at 2016-07-18 12:50:14

I still want to add my Python implementation of `sage-logger` but that can be kept back for later.


---

Comment by git created at 2016-07-18 12:51:36

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2016-07-18 12:55:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2016-07-18 17:39:50

I just tried `sage -f latte_int` and I observe the following three things (this is with `MAKE='make -j12'` in case that matters:
 - Sage banner in color, interleaved with environment variables in color due to competing output
 - a visible prompt "Are you sure you want to continue [Y/n]? "
 - building the dependency 4ti2
 - another warning about experimental packages, but no visible prompt.
 - "hang" as before


---

Comment by mkoeppe created at 2016-07-18 17:40:09

Changing status from needs_review to needs_work.


---

Comment by leif created at 2016-07-18 18:10:48

You can avoid `SED=cat` if you put the pipe into the/a variable (`POSTPROCESS`, say), leaving it empty if no prefix was given, i.e.

```sh
    POSTPROCESS="| $SED 's/^/$prefix/'"
    ...
    ( trap '' SIGINT; eval tee -a "$logfile" $POSTPROCESS )
    ...
```


(I _think_.)


---

Comment by leif created at 2016-07-18 18:55:42

You don't have to install packages in a loop; you can download them one-by-one, and afterwards run `make` on all of them.

In any case, the following is wrong:

```sh
        sage-logger "sage-spkg $INSTALL_OPTIONS -d '$PKG'" logs/install.log

        # Then make / install the package with no prompts
        $MAKE SAGE_SPKG="sage-spkg $INSTALL_OPTIONS -y" "$OPT"
```

(`"$OPT"` should be `"$PKG"`.)

----

Unrelated to this ticket:


```sh
# First of all, make sure that the toolchain is up-to-date
# (which is a dependency of every package)
./sage --location
$MAKE all-toolchain
```


is pretty stupid before we know the package(s) at all exist(s), can be downloaded if needed, whatever.  (And IIRC one gets `*** ALL ENVIRONMENT VARIABLES BEFORE BUILD: ***` etc. twice for no reason, the first time _before_ any relevant processing happens.)


---

Comment by jdemeyer created at 2016-07-19 11:53:23

Replying to [comment:93 leif]:
> You don't have to install packages in a loop; you can download them one-by-one, and afterwards run `make` on all of them.

+1


---

Comment by mkoeppe created at 2016-07-20 21:34:03

I've implemented a "good enough for next release" solution.
Making it prettier can be on a follow-up ticket.
Needs review.
----
New commits:


---

Comment by mkoeppe created at 2016-07-20 21:34:03

Changing status from needs_work to needs_review.


---

Comment by leif created at 2016-07-20 22:22:10

Replying to [comment:96 mkoeppe]:
> I've implemented a "good enough for next release" solution.
> Making it prettier can be on a follow-up ticket.
> Needs review.
> ----
> New commits:
> ||[0b1acc2](https://git.sagemath.org/sage.git/commit?id=0b1acc2e58162075755f52e941bcb537d8f33d30)||`Simple (not pretty) solution for #20884`||

Ok for me, modulo indentation... (tabs instead of spaces perhaps?)


---

Comment by leif created at 2016-07-20 22:27:13

(At least in theory, we'd have to make sure the prompting message doesn't vanish due to other output when building in parallel though.  But I think in practice this is very unlikely.)


---

Comment by mkoeppe created at 2016-07-21 07:45:19

Replying to [comment:98 leif]:
> (At least in theory, we'd have to make sure the prompting message doesn't vanish due to other output when building in parallel though.  But I think in practice this is very unlikely.)

Yes, I hope that a follow-up ticket will do a proper solution, which prompts early (or just bails out and requires an extra flag), rather than prompting in the middle of a parallel build.

My simple solution just restores (except for cosmetics) the status quo before #20640, #20708 broke the prompting.


---

Comment by git created at 2016-07-21 07:48:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2016-07-22 23:22:11

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-07-23 18:38:27

Resolution: fixed


---

Comment by mkoeppe created at 2016-07-24 13:45:44

Follow-up ticket - #21082. This is where work on the patch by Erik Bray can continue.
