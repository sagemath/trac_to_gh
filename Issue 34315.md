# Issue 34315: more testsuites for lazy series rings

Issue created by migration from https://trac.sagemath.org/ticket/34552

Original creator: mantepse

Original creation time: 2022-09-18 10:57:28

CC:  tscrim




---

Comment by mantepse created at 2022-09-18 11:01:43

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2022-09-18 11:01:43

Last 10 new commits:


---

Comment by mantepse created at 2022-09-18 11:01:43

Changing keywords from "" to "LazyPowerSeries".


---

Comment by mantepse created at 2022-09-18 11:01:43

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by git created at 2022-09-18 11:34:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-18 12:21:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-18 15:53:35

Apparently, reversion of symmetric functions with linear coefficient different from `1` is completely broken:

```
sage: g = L(2*s[1]+s[2])
sage: g
2*p[1] + (1/2*p[1,1]+1/2*p[2])
sage: g.revert()(g)
p[1] + (-1/4*p[1,1]-1/4*p[2]) + (1/4*p[1,1,1]+1/4*p[2,1]) + (-9/32*p[1,1,1,1]-5/16*p[2,1,1]+3/32*p[2,2]+1/8*p[4]) + (11/32*p[1,1,1,1,1]+7/16*p[2,1,1,1]-1/32*p[2,2,1]-1/8*p[4,1]) + (-57/128*p[1,1,1,1,1,1]-83/128*p[2,1,1,1,1]-7/128*p[2,2,1,1]-13/128*p[2,2,2]+5/32*p[4,1,1]-3/32*p[4,2]) + (77/128*p[1,1,1,1,1,1,1]+127/128*p[2,1,1,1,1,1]+27/128*p[2,2,1,1,1]+9/128*p[2,2,2,1]-7/32*p[4,1,1,1]+1/32*p[4,2,1]) + O^8
```



---

Comment by mantepse created at 2022-09-18 16:16:15

Obviously, there was a parenthesis missing.  I thought I changed that already once.


---

Comment by git created at 2022-09-18 16:31:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-18 23:37:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-18 23:38:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-18 23:46:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-19 10:45:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-19 13:06:16

The following should work, but doesn't, because reversion is not lazy enough:

```
sage: L.<t> = LazyPowerSeriesRing(QQ)
sage: f = L.undefined()
sage: f.define(1+(t*f).revert())
```

In this case, `f` should have the coefficients of https://oeis.org/A067145.


---

Comment by tscrim created at 2022-09-20 05:53:47

Replying to [comment:13 Martin Rubey]:
> The following should work, but doesn't, because reversion is not lazy enough:
> {{{
> sage: L.<t> = LazyPowerSeriesRing(QQ)
> sage: f = L.undefined()
> sage: f.define(1+(t*f).revert())
> }}}
> In this case, `f` should have the coefficients of https://oeis.org/A067145.

This one is harder because of the nature of the tests being done. Nothing can be promised about the coefficients of the undefined series. It comes down to how much we want to promise that the code will not break on bad input. I am thinking we can change

```diff
-        if not coeff_stream[1]:
+        if coeff_stream._approximate_order > 1:
             raise ValueError("compositional inverse does not exist")
-
-        if coeff_stream[0]:
-            raise ValueError("cannot determine whether the compositional inverse exists")
```

Then we run into an issue with computing the exact order in `Stream_cauchy_invert`. So we are doing too many things not lazily enough. (For the invert, we can make `_ainv` a ``@`lazy_attribute` to fix this easily.)


---

Comment by mantepse created at 2022-09-20 13:09:45

In principle, I think it is more important that `define` works reliably when the input is valid than having helpful error messages.  However, silently wrong output is probably equally bad as failures on good input.

For the issue at hand, I think we can rewrite

```diff
-        # TODO: shift instead of (self / z) should be more efficient
-        g.define(z / ((self / z)(g)))
+        # the following is mathematically equivalent to
+        # z / ((self / z)(g))
+        # but more efficient and more lazy
+        g.define((~self.shift(-1)(g)).shift(1))
```


Here is my thinking:

* in `__invert__`, and `shift(-1)` it is correct to fail on `LazyPowerSeries` with positive valuation (in contrast to `_div_`).  In particular, `f * ~ z` is actually bad input for `LazyPowerSeries`

* I don't see how we can (without great effor) avoid the order computation in `Stream_cauchy_invert.__init__`, when we have no upper bound on the valuation of the input, because it's negative is passed to `super().__init__`.  In our Aldor implementation, Ralf and I created a new domain which allowed computation with "unknowns".  I am not sure whether we want this.


---

Comment by tscrim created at 2022-09-20 15:34:48

I think we can make it so that we only check the order for invert (and division) when we actually try to get a coefficient. As such, we should not be returning silently wrong answers (on invalid input). I am not sure for `revert()` if weakening the check will allow this to happen.

I can implement this tomorrow as I have a rough plan if you don't do it beforehand.


---

Comment by mantepse created at 2022-09-20 15:51:01

What time zone are you in right now? :-)    

Great!

Please do, I don't see how!  (Other than also delaying the `_approximate_order` computations in all the other `Stream_XXX.__init__` methods, which looks a bit scary.  But maybe it isn't, actually.)


---

Comment by mantepse created at 2022-09-20 20:00:34

I just added a naive `_test_div`, and found the following gem:

```
sage: s = SymmetricFunctions(ZZ).s()
sage: S = LazySymmetricFunctions(s)
sage: x = S.some_elements()[1]; x
s[]
sage: x / x * x == x
False
sage: y = S(s[0])
sage: x == y
True
sage: y / y * y == y
True
```


(there are many other failures, related to missing fraction field, so I am not pushing yet)


---

Comment by tscrim created at 2022-09-21 01:20:29

I am in the Japanese timezone of got-writing-late-and-wanted-to-respond-to-Martin. `^^;;`

That is an interesting bug. I will have to explore it further. My guess is we are not being careful enough with something.


---

Comment by mantepse created at 2022-09-21 04:27:51

Hi Travis! Shall we have a video call maybe? I am extremely interested in your idea to solve the approximate order problem. I'd be available starting from about 15:30 Japan time.


---

Comment by git created at 2022-09-21 06:31:44

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by tscrim created at 2022-09-21 06:32:16

This now works:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: f = L.undefined(valuation=0)
sage: f.define(1+(z*f).revert())
sage: f
1 + z - z^2 + 3*z^3 - 13*z^4 + 69*z^5 - 419*z^6 + O(z^7)
```



---

Comment by git created at 2022-09-21 20:18:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-21 20:20:09

I think that, to make

```
        X = R(Partition([1]))
        b = coeff_stream[1][Partition([1])]
        b_inv = R.base_ring()(~b)
        g = P.undefined(valuation=1)
        g.define(b_inv * (X - (self - b * X)(g)))
```

lazy, we have to move it into a new class `Stream_revert`.  I was too lazy to do this today.


---

Comment by git created at 2022-09-21 20:22:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-23 11:27:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-23 15:21:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-23 16:21:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-23 21:03:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-23 21:46:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-23 23:05:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-23 23:19:52

This is now almost done.  What I need next is a proof or a counterexample that I can or cannot do

```diff
diff --git a/src/sage/rings/lazy_series.py b/src/sage/rings/lazy_series.py
index e332f8cf033..b902b223237 100644
--- a/src/sage/rings/lazy_series.py
+++ b/src/sage/rings/lazy_series.py
@@ -3776,8 +3776,8 @@ class LazyLaurentSeries(LazyCauchyProductSeries):
         #if not coeff_stream[1]:
         #    raise ValueError("compositional inverse does not exist")
 
-        #if coeff_stream[0]:
-        #    raise ValueError("cannot determine whether the compositional inverse exists")
+        if coeff_stream[0]:
+            raise ValueError("cannot determine whether the compositional inverse exists")
 
         z = P.gen()
         g = P.undefined(valuation=1)
```

I am too tired for this right now.

It might be OK, because we cannot compute the reversion of `a + b z + O(z^2)` anyway.  But could it be that we trigger a computation we should not trigger when asking for `coeff_stream[0]`?


---

Comment by mantepse created at 2022-09-23 23:41:24

In fact, I don't even have proof that we are allowed to check `_approximate_order` in `revert`, `invert`, etc. - unless the stream is 'exact', of course.


---

Comment by git created at 2022-09-23 23:41:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-23 23:43:33

I "forced" the doctests to pass, but the challenge remains:

* find an implicit definition (possibly involving several unknowns) that fails even though it shouldn't, or

* prove that our code works.


---

Comment by git created at 2022-09-24 09:43:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-24 09:43:41

That challenge was easy.


---

Comment by git created at 2022-09-24 10:17:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-24 10:26:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-24 10:27:42

Changing status from new to needs_review.


---

Comment by mantepse created at 2022-09-24 10:30:03

I think that this is now ready for review.  In principle, I know how things should work now, and if we find any further failing examples, it should be straightforward to fix them.

I would prefer to leave better error handling for a different ticket, so that this branch (which fixes **several** evil bugs) is in the development branch soon.


---

Comment by mantepse created at 2022-09-25 21:07:08

In general, it does not work to access `_approximate_order` in `lazy_series`.  For example, in `LazyLaurentSeries.revert` in line 3790, we had (now commented out)

```
        if coeff_stream._approximate_order > 1:
            raise ValueError("compositional inverse does not exist")
```

This does not work, for example, for

```
sage: L.<t> = LazyLaurentSeriesRing(QQ)
sage: f = L.undefined(valuation=0)
sage: f.define(1+(t*~f).revert())
```

More precisely: the above mentioned access to `_approximate_order` eventually triggers the computation of `(~f)._approximate_order`.  Since `f` is a lazy Laurent series, this triggers the computation of `f.order()`, which fails at this point.

There are two occurrences, in `LazyCauchyProductSeries.__invert__`, `LazyCauchyProductSeries._div_` which I cannot exploit for a failing example, yet.

This is at the beginning of `__invert__`, line 2826-2829:

```
        P = self.parent()
        coeff_stream = self._coeff_stream
        if P._minimal_valuation is not None and coeff_stream._approximate_order > 0:
            raise ZeroDivisionError("cannot divide by a series of positive valuation")
```

and when checking whether to construct a fraction field in `_div_`, line 2988-2994::

```
        if (P._minimal_valuation is not None
            and left._true_order
            and left._approximate_order < right._approximate_order):
            F = P.fraction_field()
            num = F.element_class(F, left)
            den = F.element_class(F, right)
            return num / den
```


I can imagine that both of these are actually OK, but I'd like to see a stringent argument.


---

Comment by mantepse created at 2022-09-25 21:42:29

It is not entirely clear to me, why we have a failure here:

```
sage: P.<x> = LazyPowerSeriesRing(QQ)
sage: f = P.undefined(); f.define(1 - ~f*x); f
1 - x - x^2 - 2*x^3 - 5*x^4 - 14*x^5 - 42*x^6 + O(x^7)
sage: f = P.undefined(); f.define(1 - x * ~f); f
1 - x - x^2 - 2*x^3 - 5*x^4 - 14*x^5 - 42*x^6 + O(x^7)
sage: f = P.undefined(); f.define(1 - x / f); f
<repr(<sage.rings.lazy_series_ring.LazyPowerSeriesRing_with_category.element_class at 0x7f319f4b2000>) failed: RecursionError: maximum recursion depth exceeded>
```



---

Comment by mantepse created at 2022-09-25 21:58:49

The last one was easy (we have merge failures all over the place currently, so I am not pushing this)

```diff
diff --git a/src/sage/rings/lazy_series.py b/src/sage/rings/lazy_series.py
index 5a21dbe7425..4ef8c42e03b 100644
--- a/src/sage/rings/lazy_series.py
+++ b/src/sage/rings/lazy_series.py
@@ -962,7 +962,8 @@ class LazyModuleElement(Element):
         return any(self[i] for i in range(v, v + prec))
 
     def define(self, s):
-        r"""Define an equation by ``self = s``.
+        r"""
+        Define an equation by ``self = s``.
 
         INPUT:
 
@@ -1136,6 +1137,13 @@ class LazyModuleElement(Element):
             sage: f
             1 - x - x^2 - 2*x^3 - 5*x^4 - 14*x^5 - 42*x^6 + O(x^7)
 
+        Check that this also works using division::
+
+            sage: f = P.undefined()
+            sage: f.define(1 - x / f)
+            sage: f
+            1 - x - x^2 - 2*x^3 - 5*x^4 - 14*x^5 - 42*x^6 + O(x^7)
+
             sage: D = LazyDirichletSeriesRing(QQ, "s")
             sage: g = D([0, 1])
             sage: f = D.undefined()
@@ -3057,9 +3065,8 @@ class LazyCauchyProductSeries(LazyModuleElement):
 
         # if P._minimal_valuation == 0, then this is the true order
         # of coeff_stream, otherwise P._minimal_valuation is None
-        # right_inverse = Stream_cauchy_invert(right,
-        #                                     approximate_order=P._minimal_valuation)
-        right_inverse = Stream_cauchy_invert(right)
+        right_inverse = Stream_cauchy_invert(right,
+                                             approximate_order_upper_bound=P._minimal_valuation)
         return P.element_class(P, Stream_cauchy_mul(left, right_inverse))

```



---

Comment by git created at 2022-09-25 22:43:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-25 22:45:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-25 23:06:26

Changing status from needs_review to needs_work.


---

Comment by mantepse created at 2022-09-25 23:06:26

something broke, there are many failing tests now.


---

Comment by mantepse created at 2022-09-25 23:17:52

Oh, the commit in comment:48 is bad!


```
        right_inverse = Stream_cauchy_invert(right,
                                             approximate_order_upper_bound=P._minimal_valuation)
```


does not work, when `left` and `right` are both divisible by the generator.


---

Comment by git created at 2022-09-26 09:13:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-26 11:24:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-26 11:30:17

Changing status from needs_work to needs_review.


---

Comment by mantepse created at 2022-09-26 11:30:17

I am catching the recursion error now where it first occurs (in `Stream_cauchy_invert`).

This is certainly not optimal, because it will only be triggered when accessing the degree 1 part:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: s = L(lambda n: 2 if n == 0 else 3 if n == 1 else 0, valuation=0); s
2 + 3*z + O(z^7)
sage: f = s.revert()
sage: f[0]
0
```

However, I don't see how to make this much better.


---

Comment by git created at 2022-09-26 13:03:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-26 13:49:51

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2022-09-26 16:59:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-26 17:31:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-27 08:46:07

Essentially green bot.

The pyflakes warnings `local variable 'res' is assigned to but never used` are from #34345.  Should I fix them here or elsewhere?


---

Comment by mantepse created at 2022-09-27 08:56:47

The codestylecheck warnings are as follows:

```
sage/rings/lazy_series.py:843:21: E711 comparison to None should be 'if cond is None:'
sage/rings/lazy_series.py:961:17: E711 comparison to None should be 'if cond is None:'
sage/rings/lazy_series.py:5452:9: E306 expected 1 blank line before a nested definition, found 0
```

The first two wouldn't work with `is`, because an option only compares equal to `None`:

```
            prec = self.parent().options.halting_precision
            if prec == None:
                raise ValueError("undecidable")
```

The `E306` I disagree with, I am setting the "local" variables for the local function definition.  (`X` is used later, but looks best at this spot) 

```
        la = Partition([1])
        X = R(la)
        def coefficient(n):
            if n:
                return 0
            c = coeff_stream[1][la]
            if c.is_unit():
                return ~c
            raise ValueError("compositional inverse does not exist")
```



---

Comment by mantepse created at 2022-09-27 08:57:49

It is interesting that the github bots will not detect the unused variables.


---

Comment by chapoton created at 2022-09-29 10:09:19

Sorry, but the linter must pass, no choice. Even if E306 is in some sense a matter of taste, it is currently required. Your def without empty line before would be the only one in the whole sage code base.

About the comparison to None, this is very strange. Could you use "if not prec" instead ? or some isinstance ? What is the type of "prec" that is equal but not `None` ?


---

Comment by mantepse created at 2022-09-29 10:21:45

Hi Frédéric!

Concerning the second question:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: L.options.halting_precision
None
sage: type(L.options.halting_precision)
<class 'sage.structure.global_options.Option'>
sage: L.options.halting_precision == None
True
sage: L.options.halting_precision is None
False
```



---

Comment by mantepse created at 2022-09-29 10:24:01

I'll add the missing line.

Could you please also respond to comment:58?

(these pyflakes warnings were missed in a completely unrelated ticket)


---

Comment by chapoton created at 2022-09-29 11:56:40

the pyflakes warning are not your responsability, but you can fix them if you want


For the comparison to None, maybe this could fixed using the complicated syntax

```
sage: op = L.options.constant_length
sage: op._options[op._name]
3
sage: type(_)
<class 'int'>
```

or by adding in general a way to extract the bare value of an option somehow.


---

Comment by chapoton created at 2022-09-29 12:02:55

simpler:

```
sage: Q=L.options
sage: type(Q['constant_length'])
<class 'int'>
```



---

Comment by git created at 2022-09-29 13:13:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-29 13:14:27

Cool, thank you!


---

Comment by git created at 2022-10-05 15:34:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-10-11 00:03:04

I am assuming Frédéric is now happy. LGTM. We can do more on further tickets.


---

Comment by tscrim created at 2022-10-11 00:03:04

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-10-16 22:15:51

Resolution: fixed
