# Issue 14381: Make lazy_format and lazy_string faster and use it internally in coercion

Issue created by migration from Trac.

Original creator: SimonKing

Original creation time: 2013-05-15 09:38:38

Assignee: robertwb

CC:  nbruin vdelecroix

At [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/Gnw389Bd-0k), Nils suggests to use some kind of lazy object for the error messages of errors that are deeply buried in the coercion model.

This approach is similar to what we already do with `sage.structure.misc.AttributeErrorMassage`. However, this is specifically restricted to error messages of attribute errors. In the more general case, it makes sense to use either `sage.misc.lazy_format.LazyFormat` or `sage.misc.lazy_string.lazy_string`. The latter seems to be faster, according to these timings that are according to Nils' example:

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda op,A,B:"unsupported operand parent(s) for '%s': '%s' and '%s'"%(op,A,B)
sage: R = GF(5)
sage: S = GF(3)
sage: %timeit Exception(lazy_string(f, '+', R, S))
1000000 loops, best of 3: 1.47 us per loop
sage: lazy_string(f, '+', R, S)
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception("unsupported operand parent(s) for '%s': '%s' and '%s'"%('+', R, S))
100000 loops, best of 3: 5.04 us per loop
sage: from sage.misc.lazy_format import LazyFormat
sage: ErrMess = LazyFormat("unsupported operand parent(s) for '%s': '%s' and '%s'")
sage: %timeit Exception(ErrMess%('+', R, S))
10000 loops, best of 3: 23.1 us per loop
sage: ErrMess%('+', R, S)
unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'
```


So, it would already make sense to replace all error messages using string formatting by a call to `lazy_string`, while `LazyFormat` seems to be quite sluggish.

Two tasks:
1. Make `lazy_string` and `LazyFormat` a lot faster (perhaps by using Cython)
2. Use it for errors raised when trying to find coercions. The problem is particularly urgent if the string representation of an object is difficult to compute.

Apart from making coercion faster, there is the following problem that we would fix as well. Consider creation of a parent. It may happen that relatively early during initialisation, a coercion is needed, but only later, the string representation of the parent will become available. Hence, if there is an error raised (and caught) inside of the coercion system that relies on the string representation of the parent, then we are in trouble.


---

Comment by SimonKing created at 2013-05-15 09:40:58

PS: It might make sense to put both `lazy_string` and `LazyFormat` into one file.


---

Comment by SimonKing created at 2013-05-15 10:08:53

Here is a first patch, that cythons lazy_string. Result:

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda op,A,B:"unsupported operand parent(s) for '%s': '%s' and '%s'"%(op,A,B)
sage: R = GF(5)
sage: S = GF(3)
sage: lazy_string(f, '+', R, S)
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception(lazy_string(f, '+', R, S))
1000000 loops, best of 3: 595 ns per loop
```

So, the time for raising the exception drops by more than 50% compared with the old Python lazy_string.

Next will be lazy_format.


---

Comment by SimonKing created at 2013-05-15 10:10:45

Avoiding the function call:

```
sage: from sage.misc.lazy_string import _LazyString
sage: _LazyString(f, ('+', R, S), {})
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception(_LazyString(f, ('+', R, S), {}))
1000000 loops, best of 3: 545 ns per loop
```

Goes down by another 10%.


---

Comment by SimonKing created at 2013-05-15 10:22:25

Perhaps we could use a dummy string (similar to what I did in `sage.structure.misc.AttributeErrorMessage`)? The additional code would be

```
cdef _LazyString _DummyLazyString = _LazyString(None, (), {})

def lazy_string_dummy(f, *args, **kwds):
    _DummyLazyString._func = f
    _DummyLazyString._args = args
    _DummyLazyString._kwargs = kwds
    return _DummyLazyString
```


And then, then one can raise errors even quicker:

```
sage: from sage.misc.lazy_string import lazy_string_dummy
sage: f = lambda op,A,B:"unsupported operand parent(s) for '%s': '%s' and '%s'"%(op,A,B)
sage: R = GF(5)
sage: S = GF(3)
sage: lazy_string_dummy(f, ('+', R, S), {})
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception(lazy_string_dummy(f, ('+', R, S), {}))
1000000 loops, best of 3: 480 ns per loop
```


Do you think this would be feasible to have a unique message object for the errors raised and caught internally?


---

Comment by SimonKing created at 2013-05-15 10:39:16

FWIW, I have attached a second patch, which uses a lazy string dummy. I am not sure if an in-place change of an error message is a good thing. But it did work in the case of `AttributeError`, so, I would not drop the idea too soon.


---

Comment by SimonKing created at 2013-05-15 14:40:33

Hmm. To make it more scalable, it would be better to rename `lazy_string_dummy` into `update_lazy_string` and give it an existing lazy string, that is merely updated.


---

Comment by SimonKing created at 2013-05-15 14:52:31

Does the reviewer think that an in-place change of a lazy string dummy makes sense?


---

Attachment

OK, I have updated the second patch accordingly. There is now not just a single lazy dummy, but an arbitrary existing lazy string (with fixed underlying function) can be updated by providing new arguments to the underlying function.


---

Comment by nbruin created at 2013-05-15 15:13:03

Replying to [comment:3 SimonKing]:

> sage: %timeit Exception(_LazyString(f, ('+', R, S), {}))
  - do we need the `{}` for kwargs?
  - does ditching it provide a worthwhile speedup?
  - how do we do if we instead have a `*kwargs` collect the arguments in a tuple rather than pass them as a tuple preformed?

Note that `LazyFormat` would be completely analogous. In fact, internally they could be the same code, with just a flag that says "interpolate f with args" rather than "call f with args".

The latter has the advantage that it's a little easier: You don't have to prewrap a string in a lambda to get decent performance.


---

Comment by nbruin created at 2013-05-15 15:18:55

Replying to [comment:7 SimonKing]:
> OK, I have updated the second patch accordingly. There is now not just a single lazy dummy, but an arbitrary existing lazy string (with fixed underlying function) can be updated by providing new arguments to the underlying function.

Hm ... are these strings hashable (and hence immutable)? Then this would be bad. In fact, if they're hashable they NEED to be caching, which goes counter to existing use of lazy_string, where it's used as a window on an environment variable.

I'd say at least underscore this method to make it clear it's bad. And only use it in our code if you can show that in real-world examples it makes a considerable difference (which I doubt: producing exceptions is only going to be a small percentage of total processing time, so possible gain is limited)


---

Comment by SimonKing created at 2013-05-15 15:29:37

Replying to [comment:9 nbruin]:
> Hm ... are these strings hashable (and hence immutable)?

No, it is not hashable.

> I'd say at least underscore this method to make it clear it's bad.

Or: cimport `_LazyString` in the coercion code and modify the arguments directly.

> And only use it in our code if you can show that in real-world examples it makes a considerable difference (which I doubt: producing exceptions is only going to be a small percentage of total processing time, so possible gain is limited)

So I thought, before I worked on #14100. But there, the speed-up has been quite noticeable.

OK, #14100 was about attribute errors, and I think accessing attributes is a more common operation than raising an error. So, it could be that you are right, and that it only contributes to a minor slowness. But a striking example should be: Test coercion of many different parents (which is typical for elliptic curve computations, it seems) into a parent that has an expensive string representation.

Anyway, I think _improving_ lazy_string should be separated from _using_ lazy_string---the latter should be done on #14592.


---

Comment by nbruin created at 2013-05-16 03:33:27

Replying to [comment:8 nbruin]:
> Note that `LazyFormat` would be completely analogous. In fact, internally they could be the same code, with just a flag that says "interpolate f with args" rather than "call f with args".

In fact, perhaps just allow `LazyString` to be initialized with a string or a callable and interpolate with arguments rather than call with arguments if it's a string. That should be a very cheap test when the value gets requested.

The only difference with (present) `LazyFormat` would be that `LazyFormat` caches its value after first interpolation, but that's likely not an important trait (certainly not for our applications). Then you can basically just do away with `LazyFormat`.

I did a quick experiment. For reference, I first tried the patch as given here:

```
sage: E=Exception(_LazyString(f, ('+', R, S)))
sage: %timeit repr(E)
100000 loops, best of 3: 6.76 us per loop
```


Then I tried it with

```
    `@`property
    def value(self):
        cdef object f=self._func
        if PyString_Check(f):
           return f%self._args
        return f(*self._args)
```


which resulted in

```
sage: s="unsupported operand parent(s) for '%s': '%s' and '%s'"
sage: E=Exception(_LazyString(s, ('+', R, S)))
sage: %timeit repr(E)
100000 loops, best of 3: 6.48 us per loop
sage: E=Exception(_LazyString(f, ('+', R, S)))
sage: %timeit repr(E)
100000 loops, best of 3: 6.54 us per loop
```

from which I don't dare to conclude that the code is MORE efficient with the branching, so I'll settle for not slower. (it seems putting or not putting a kwargs in there hardly makes a measurable difference, so we might as well).

You really do want to do a `PyString_Check` there. Doing an `isinstance` is noticeably slower.


---

Comment by SimonKing created at 2013-05-16 08:15:58

Replying to [comment:11 nbruin]:
> I did a quick experiment. For reference, I first tried the patch as given here:
> {{{
> sage: E=Exception(_LazyString(f, ('+', R, S)))
> sage: %timeit repr(E)
> 100000 loops, best of 3: 6.76 us per loop
> }}}
> 
> Then I tried it with
> {{{
>     `@`property
>     def value(self):
>         cdef object f=self._func
>         if PyString_Check(f):
>            return f%self._args
>         return f(*self._args)
> }}}
> 
> which resulted in
> {{{
> sage: s="unsupported operand parent(s) for '%s': '%s' and '%s'"
> sage: E=Exception(_LazyString(s, ('+', R, S)))
> sage: %timeit repr(E)
> 100000 loops, best of 3: 6.48 us per loop
> sage: E=Exception(_LazyString(f, ('+', R, S)))
> sage: %timeit repr(E)
> 100000 loops, best of 3: 6.54 us per loop
> }}}
> from which I don't dare to conclude that the code is MORE efficient with the branching, so I'll settle for not slower. (it seems putting or not putting a kwargs in there hardly makes a measurable difference, so we might as well).
> 
> You really do want to do a `PyString_Check` there. Doing an `isinstance` is noticeably slower.

OK, I'll change the patch accordingly, also deprecating `LazyFormat`, and creating a pxd file for lazy_string, so that it will later become possible to change a lazy string in-place without calling a function (but instead by cimporting it and then directly inserting stuff into the cdef attributes).


---

Comment by SimonKing created at 2013-05-16 09:04:33

With the updated patch,

- `_LazyString` accepts both functions and format strings as arguments
- It has a cpdef method allowing to change it in-place. I think that's better than a function modifying a global object.
- I don't know how to deprecate `LazyFormat`. It has no `__init__` method (only the one inherited from str), and hence I don't know where to put a deprecation warning. But I added a comment in the documentation.
- I added more tests.

Apply trac14585-cythoned_lazy_string.patch


---

Comment by SimonKing created at 2013-05-16 09:04:33

Changing status from new to needs_review.


---

Comment by nbruin created at 2013-05-16 15:42:26

Replying to [comment:13 SimonKing]:
> With the updated patch,
> 
> - `_LazyString` accepts both functions and format strings as arguments
> - It has a cpdef method allowing to change it in-place. I think that's better than a function modifying a global object.
> - I don't know how to deprecate `LazyFormat`. It has no `__init__` method (only the one inherited from str), and hence I don't know where to put a deprecation warning. But I added a comment in the documentation.
> - I added more tests.
> 
> Apply trac14585-cythoned_lazy_string.patch

How about just changing `LazyFormat` to a factory function for `_LazyString` objects? Then we at least get the benefit (provided chaching behaviour is not required for it. Otherwise `LazyString` might grow a `cache_result` flag, if that doesn't affect performance.

Also, I think `_LazyString` has an easy enough interface to be called `LazyString` and be used directly (and then just leave `lazy_string` around for compatibility reasons).


---

Comment by nbruin created at 2013-05-16 15:56:48

Changed ticket title to reflect that this ticket is about improving the routines themselves. Simon says that #14592 is for applying them more widely to error messages (if that turns out to be worthwhile)


---

Comment by nbruin created at 2013-05-16 16:13:27

I also realized that the following spelling leads to more efficient code in cython:

```
    property value:
        def __get__(self):
            cdef object f=self._func
            if PyString_Check(f):
               return f%self._args
            return f(*self._args)
```

With the old code:

```
sage: from sage.misc.lazy_string import lazy_string, _LazyString
sage: f=lambda :"hi"
sage: s=_LazyString(f,())
sage: %timeit str(s)
1000000 loops, best of 3: 425 ns per loop
```

and with cython property spelling:

```
sage: %timeit str(s)
1000000 loops, best of 3: 282 ns per loop
```

Finally:

```
sage: f=lambda n:"hi%s"%n
sage: s=_LazyString(f,('ho',))
sage: %timeit str(s)
1000000 loops, best of 3: 428 ns per loop
sage: %timeit str(s)
1000000 loops, best of 3: 423 ns per loop
sage: f="hi%s"
sage: s=_LazyString(f,('ho',))
sage: %timeit str(s)
1000000 loops, best of 3: 319 ns per loop
sage: %timeit str(s)
1000000 loops, best of 3: 316 ns per loop
```

so special casing string values to directly interpolate seems to be a measurable saving (on something that doesn't seem to contribute much to total running time anyway)


---

Comment by SimonKing created at 2013-05-16 16:22:14

Replying to [comment:17 nbruin]:
> I also realized that the following spelling leads to more efficient code in cython:
> {{{
>     property value:
>         def __get__(self):
>             cdef object f=self._func
>             if PyString_Check(f):
>                return f%self._args
>             return f(*self._args)
> }}}

Is this the Cython spelling of "`@`property"? Why can't Cython automatically transform Python's `@`property accordingly?


---

Comment by SimonKing created at 2013-05-16 16:25:43

Could the failures observed by the patchbot be due to this patch? How can it be amended?

If unpickling of `_LazyString` is the problem, then your suggestion to rename it into `LazyString` has another benefit: One could use the old `_LazyString` to convert old lazy strings to new lazy strings. I just don't know how (I guess pickling is by class and `__dict__`).


---

Comment by nbruin created at 2013-05-16 17:32:12

Replying to [comment:18 SimonKing]:
> Is this the Cython spelling of "`@`property"? Why can't Cython automatically transform Python's `@`property accordingly?

Well ... ``@`property` is valid in in cython as well, but has a different meaning and effect. I'm not sure if it's doable and desirable for cython to transcribe it to `property:` because most of the time that's what the author intends. We'll see: [cython-users thread](http://groups.google.com/group/cython-users/browse_thread/thread/1a3a6defe99c6fd0)

It's just that on C-API level some lower level hooks are available that `property:` can hook into.


---

Comment by nbruin created at 2013-05-16 22:19:18

Replying to [comment:17 nbruin]:
>             return f(*self._args)
and here you can shave a few nanoseconds off by using

```
return PyObject_CallObject(f,self._args)
```

or

```
return PyObject_Call(f,self._args,self._kwargs)
```

Cython still generates some code to ensure that the resulting bit from * is a tuple and not a general iterable, but we've already forced it to be a tuple.


---

Comment by SimonKing created at 2013-05-17 05:11:03

Replying to [comment:21 nbruin]:
> Replying to [comment:17 nbruin]:
> >             return f(*self._args)
> and here you can shave a few nanoseconds off by using
> {{{
> return PyObject_CallObject(f,self._args)
> }}}
> or
> {{{
> return PyObject_Call(f,self._args,self._kwargs)
> }}}
> Cython still generates some code to ensure that the resulting bit from * is a tuple and not a general iterable, but we've already forced it to be a tuple.

Are the two versions giving essentially the same C-code?


---

Comment by nbruin created at 2013-05-17 06:12:27

Replying to [comment:22 SimonKing]:
> > return PyObject_CallObject(f,self._args)
> > return PyObject_Call(f,self._args,self._kwargs)
 
> Are the two versions giving essentially the same C-code?

I'm not entirely sure what you're asking, so I'll try to just generally clarify. If you write `f(*args)` then cython will produce code to package the contents of `args` into a tuple (since `args` could be any iterable). We don't need to do that.

The difference between `Call` and `CallObject` is whether there's a `kwargs` there. Not having that saves a couple of nanoseconds too.

These `PyObject_Call*` routines seem to be the official API for calling things, so Cython generates this too.


---

Comment by SimonKing created at 2013-05-17 07:40:24

Replying to [comment:23 nbruin]:
> The difference between `Call` and `CallObject` is whether there's a `kwargs` there. Not having that saves a couple of nanoseconds too.

OK. I don't know if named arguments are really used, but the possibility to use them is currently provided. So, I think `PyObject_Call(f, args, kwargs)` should be the right thing to do.

Can you confirm the unpickling errors reported by the patchbot?


---

Comment by SimonKing created at 2013-08-11 13:39:45

I think we should resume working on this patch. Currently, it fails to build with this error:

```
Cython.Compiler.Errors.InternalError: Internal compiler error: '../ext/python_string.pxi' not found
Error installing modified sage library code.
```

Has this file been moved? Renamed even? I can not find it under SAGE_ROOT/devel/sage/.


---

Comment by SimonKing created at 2013-08-11 13:39:45

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2013-08-11 13:48:06

Replying to [comment:25 SimonKing]:
> I think we should resume working on this patch. Currently, it fails to build with this error:
> {{{
> Cython.Compiler.Errors.InternalError: Internal compiler error: '../ext/python_string.pxi' not found
> Error installing modified sage library code.
> }}}
> Has this file been moved? Renamed even? I can not find it under SAGE_ROOT/devel/sage/.

It has been #6223.


---

Comment by SimonKing created at 2013-08-11 13:54:49

Only apply this patch


---

Comment by SimonKing created at 2013-08-11 13:55:52

Changing status from needs_work to needs_review.


---

Attachment

I have updated the patch so that it correctly builds. Note that I did not add the improvements suggested by Nils, yet.

Apply trac14585-cythoned_lazy_string.patch


---

Comment by nbruin created at 2013-08-22 22:31:08

Don't forget:

```
    property value:
        def __get__(self):
            cdef object f=self._func
            if PyString_Check(f):
               return f%self._args
            return f(*self._args)
```

instead of the ``@`property` decorator leads to much better (and faster) cython code.


---

Comment by rws created at 2014-03-31 07:45:32

Changing status from needs_review to needs_work.


---

Comment by nbruin created at 2015-04-28 07:08:22

Part of why `LazyFormat` seems so sluggish presently is the strategy how it copies itself when asked to rebind. It will usually be cheaper to make a fresh `LazyFormat` object (in other words, we should make the rebinding just do that). The problem presently is that the use of `copy` leads to the desperate act of using `__reduce__` (!) to do the copying. Much better already:

```
sage: class A(str): pass
sage: a=A("a")
sage: %timeit copy(a)
100000 loops, best of 3: 13 µs per loop
sage: %timeit A(str.__repr__(a))
1000000 loops, best of 3: 558 ns per loop
sage: %timeit A("a")
10000000 loops, best of 3: 258 ns per loop
```

so at the very least we should use the latter incantation in `LazyFormat.__mod__`, and it would be even nicer be able to get the string value of a in a cheaper way.


---

Comment by vdelecroix created at 2015-04-28 08:58:27

cc'ing me... it would be cool to have a follow up ticket for cleaning most error messages and also advertise lazy strings in the developer manual.

Vincent


---

Comment by SimonKing created at 2015-07-23 10:09:02

I have converted the patch to a branch. Note that comment:27 still applies: I did not add the improvements suggested by Nils, yet.
----
New commits:


---

Comment by SimonKing created at 2015-07-23 10:24:21

With the current branch, I get

```
sage: from sage.misc.lazy_string import lazy_string, _LazyString
sage: f=lambda :"hi"
sage: s=_LazyString(f,(), {})
sage: %timeit str(s)
The slowest run took 21.90 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 827 ns per loop
```

With the change that Nils suggested in comment:29, I get

```
sage: from sage.misc.lazy_string import lazy_string, _LazyString
sage: f=lambda :"hi"
sage: s=_LazyString(f,(), {})
sage: %timeit str(s)
The slowest run took 11.15 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 535 ns per loop
```

Pushing the change...


---

Comment by SimonKing created at 2015-07-23 10:25:19

Upps. I noticed that the previous branch was invalid anyway.


---

Comment by git created at 2015-07-23 10:26:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-23 10:33:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-23 10:41:08

Without the CallObject, we get

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda x: "laziness" + repr(x)
sage: s = lazy_string(f, 5)
sage: %timeit str(s)
The slowest run took 13.06 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.53 µs per loop
sage: s = lazy_string("This is %s", ZZ)
sage: %timeit str(s)
The slowest run took 8.76 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 2.29 µs per loop
```


With the CallObject, we get

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda x: "laziness" + repr(x)
sage: s = lazy_string(f, 5)
sage: %timeit str(s)
The slowest run took 15.19 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.59 µs per loop
sage: s = lazy_string("This is %s", ZZ)
sage: %timeit str(s)
The slowest run took 10.33 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 2.42 µs per loop
```


So, in contrast to what is claimed in comment:21, I don't see an improvement. Should we revert it? Or can you provide an example where the change really matters?
----
New commits:


---

Comment by jdemeyer created at 2015-07-23 10:44:10

If you never _use_ the fact that `_args` is a tuple and `_kwds` is a dict, there is no point in doing

```
cdef tuple _args
cdef dict _kwargs
```


You can simplify this (and also drop the ugly underscores) to

```
cdef args
cdef kwargs
```

(which is actually an epsilon faster since there are no checks needed)


---

Comment by jdemeyer created at 2015-07-23 10:48:20

For `__richcmp__`, you can just use

```
return PyObject_RichCompare(self.value, other, v)
```



---

Comment by SimonKing created at 2015-07-23 10:50:40

Next, I wish to address the slowness of `LazyFormat`. We have

```
sage: from sage.misc.lazy_format import LazyFormat
sage: form = LazyFormat("<%s>")
sage: cform = LazyFormat(""+form)
sage: cform
unbound LazyFormat("<%s>")
sage: %timeit copy(form)
The slowest run took 9.12 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 16.3 µs per loop
sage: %timeit LazyFormat(""+form)
The slowest run took 12.69 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 395 ns per loop
```

So, this is what we could use in `__mod__` for speed-up


---

Comment by git created at 2015-07-23 10:53:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-23 10:54:56

The improvement is clear:

Old version:

```
sage: from sage.misc.lazy_format import LazyFormat
sage: form = LazyFormat("<%s>")
sage: %timeit form%"hi"
10000 loops, best of 3: 22 µs per loop
```


New version:

```
sage: from sage.misc.lazy_format import LazyFormat
sage: form = LazyFormat("<%s>")
sage: form%"hi"
<hi>
sage: %timeit form%"hi"
The slowest run took 6.91 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.28 µs per loop
```



---

Comment by SimonKing created at 2015-07-23 10:55:48

Replying to [comment:44 jdemeyer]:
> If you never _use_ the fact that `_args` is a tuple and `_kwds` is a dict, there is no point in doing
> {{{
> cdef tuple _args
> cdef dict _kwargs
> }}}
> 
> You can simplify this (and also drop the ugly underscores) to
> {{{
> cdef args
> cdef kwargs
> }}}
> (which is actually an epsilon faster since there are no checks needed)

Don't we use it being tuple/dict when we use `CallObject`?


---

Comment by jdemeyer created at 2015-07-23 11:01:17

Replying to [comment:49 SimonKing]:
> Don't we use it being tuple/dict when we use `CallObject`?
No, Cython declares it as

```
object PyObject_CallObject(object callable_object, object args)
```



---

Comment by SimonKing created at 2015-07-23 11:01:46

Replying to [comment:45 jdemeyer]:
> For `__richcmp__`, you can just use
> {{{
> return PyObject_RichCompare(self.value, other, v)
> }}}

I tried it, and to my surprise it seems slightly slower:

Current code

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda: "laziness"
sage: s = lazy_string(f)
sage: %timeit s < 'laziness'
The slowest run took 17.05 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 294 ns per loop
sage: %timeit s <= 'aziness'
The slowest run took 19.35 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 308 ns per loop
sage: %timeit s == 'laziness'
The slowest run took 20.48 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 291 ns per loop
sage: %timeit s != 'aziness'
The slowest run took 40.70 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 293 ns per loop
```


With `PyObject_RichCompare`:

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda: "laziness"
sage: s = lazy_string(f)
sage: %timeit s < 'laziness'
The slowest run took 17.50 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 341 ns per loop
sage: %timeit s <= 'aziness'
The slowest run took 20.08 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 344 ns per loop
sage: %timeit s == 'laziness'
The slowest run took 20.68 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 334 ns per loop
sage: %timeit s != 'aziness'
The slowest run took 21.79 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 328 ns per loop
```


So, we shouldn't do that.


---

Comment by jdemeyer created at 2015-07-23 11:03:49

I am currently unable to check out this branch:

```
fatal: unable to connect to trac.sagemath.org:
trac.sagemath.org[0: 128.208.160.253]: errno=Connection timed out
```

but you should check whether it makes sense to define a `cdef value(self)` function and use that everywhere in the private interface.


---

Comment by git created at 2015-07-23 11:07:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-23 11:09:54

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2015-07-23 11:09:54

Replying to [comment:50 jdemeyer]:
> Replying to [comment:49 SimonKing]:
> > Don't we use it being tuple/dict when we use `CallObject`?
> No, Cython declares it as
> {{{
> object PyObject_CallObject(object callable_object, object args)
> }}}

OK, I have removed the underscore, and I have made it objects rather than tuple/dict. However, in the two methods that set/change the attributes (that's `__init__` and `update_lazy_string`), I am still checking the types. I think now it can be reviewed.


---

Comment by jdemeyer created at 2015-07-23 11:26:01

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2015-07-23 11:26:01

Instead of

```
def __init__(self, f, tuple args, dict kwargs):
```

better use

```
def __init__(self, f, args, kwargs):
```


If you really want to check the types, you can do that by

```
self.args = <tuple?>args
self.kwds = <dict?>kwds
```

(this also disallows `None` for `args` and `kwds`)


---

Comment by jdemeyer created at 2015-07-23 11:27:22

The old-style doctest continuation

```
sage:
...
```

should also be fixed.

Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).


---

Comment by SimonKing created at 2015-07-23 11:37:47

Replying to [comment:56 jdemeyer]:
> Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).

I wonder, too.


---

Comment by jdemeyer created at 2015-07-23 11:44:11

[comment:52] gives an important optimization which really should be applied. I can do it if you give me some time.


---

Comment by SimonKing created at 2015-07-23 11:46:21

Replying to [comment:57 SimonKing]:
> Replying to [comment:56 jdemeyer]:
> > Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).
> 
> I wonder, too.

Strangely, after repeating the test, I get the opposite behaviour: A slight improvement. Perhaps I had confused the two test results?

Anyway, pushing new commits shortly.


---

Comment by git created at 2015-07-23 11:49:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-07-23 11:57:20

`__rmod__` should be removed and be folded into `__mod__`.


---

Comment by jdemeyer created at 2015-07-23 12:05:28

If you think that comparing two lazy strings (as opposed to comparing a lazy string and an ordinary string) is common enough, you can do something like

```
        self = self.value  # Assuming that self is indeed a _LazyString
        if isinstance(other, _LazyString):
            other = other.value
        return PyObject_RichCompare(self, other, op)
```



---

Comment by jdemeyer created at 2015-07-23 12:06:08

I have code ready for [comment:52]

If you want me to push it, just tell me.


---

Comment by jdemeyer created at 2015-07-23 13:42:56

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2015-07-23 13:42:56

New commits:


---

Comment by SimonKing created at 2015-07-23 14:05:52

Jeroen, your changes look good to me.

So, Cython allows to have a cdef function and a property of the same name?

Anyway, the new tests pass, so, I can positively review your changes.


---

Comment by jdemeyer created at 2015-07-23 15:47:28

Replying to [comment:66 SimonKing]:
> Jeroen, your changes look good to me.
> 
> So, Cython allows to have a cdef function and a property of the same name?
> 
> Anyway, the new tests pass, so, I can positively review your changes.


---

Comment by jdemeyer created at 2015-07-23 15:47:41

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2015-07-23 17:10:41

Idea for a follow-up ticket: make `__mod__` return a `LazyString` itself such that the `%` is lazily evaluated. Then we can completely merge the functionality of `LazyString` and `LazyFormat`.


---

Comment by vbraun created at 2015-07-27 15:16:00

Resolution: fixed
