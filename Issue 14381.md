# Issue 14381: Make lazy_format and lazy_string faster and use it internally in coercion

archive/issues_014381.json:
```json
{
    "body": "Assignee: @robertwb\n\nCC:  @nbruin @videlec\n\nAt [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/Gnw389Bd-0k), Nils suggests to use some kind of lazy object for the error messages of errors that are deeply buried in the coercion model.\n\nThis approach is similar to what we already do with `sage.structure.misc.AttributeErrorMassage`. However, this is specifically restricted to error messages of attribute errors. In the more general case, it makes sense to use either `sage.misc.lazy_format.LazyFormat` or `sage.misc.lazy_string.lazy_string`. The latter seems to be faster, according to these timings that are according to Nils' example:\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: f = lambda op,A,B:\"unsupported operand parent(s) for '%s': '%s' and '%s'\"%(op,A,B)\nsage: R = GF(5)\nsage: S = GF(3)\nsage: %timeit Exception(lazy_string(f, '+', R, S))\n1000000 loops, best of 3: 1.47 us per loop\nsage: lazy_string(f, '+', R, S)\nl\"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'\"\nsage: %timeit Exception(\"unsupported operand parent(s) for '%s': '%s' and '%s'\"%('+', R, S))\n100000 loops, best of 3: 5.04 us per loop\nsage: from sage.misc.lazy_format import LazyFormat\nsage: ErrMess = LazyFormat(\"unsupported operand parent(s) for '%s': '%s' and '%s'\")\nsage: %timeit Exception(ErrMess%('+', R, S))\n10000 loops, best of 3: 23.1 us per loop\nsage: ErrMess%('+', R, S)\nunsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'\n```\n\nSo, it would already make sense to replace all error messages using string formatting by a call to `lazy_string`, while `LazyFormat` seems to be quite sluggish.\n\nTwo tasks:\n1. Make `lazy_string` and `LazyFormat` a lot faster (perhaps by using Cython)\n2. Use it for errors raised when trying to find coercions. The problem is particularly urgent if the string representation of an object is difficult to compute.\n\nApart from making coercion faster, there is the following problem that we would fix as well. Consider creation of a parent. It may happen that relatively early during initialisation, a coercion is needed, but only later, the string representation of the parent will become available. Hence, if there is an error raised (and caught) inside of the coercion system that relies on the string representation of the parent, then we are in trouble.\n\nIssue created by migration from https://trac.sagemath.org/ticket/14585\n\n",
    "created_at": "2013-05-15T09:38:38Z",
    "labels": [
        "component: coercion",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Make lazy_format and lazy_string faster and use it internally in coercion",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14381",
    "user": "https://github.com/simon-king-jena"
}
```
Assignee: @robertwb

CC:  @nbruin @videlec

At [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/Gnw389Bd-0k), Nils suggests to use some kind of lazy object for the error messages of errors that are deeply buried in the coercion model.

This approach is similar to what we already do with `sage.structure.misc.AttributeErrorMassage`. However, this is specifically restricted to error messages of attribute errors. In the more general case, it makes sense to use either `sage.misc.lazy_format.LazyFormat` or `sage.misc.lazy_string.lazy_string`. The latter seems to be faster, according to these timings that are according to Nils' example:

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda op,A,B:"unsupported operand parent(s) for '%s': '%s' and '%s'"%(op,A,B)
sage: R = GF(5)
sage: S = GF(3)
sage: %timeit Exception(lazy_string(f, '+', R, S))
1000000 loops, best of 3: 1.47 us per loop
sage: lazy_string(f, '+', R, S)
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception("unsupported operand parent(s) for '%s': '%s' and '%s'"%('+', R, S))
100000 loops, best of 3: 5.04 us per loop
sage: from sage.misc.lazy_format import LazyFormat
sage: ErrMess = LazyFormat("unsupported operand parent(s) for '%s': '%s' and '%s'")
sage: %timeit Exception(ErrMess%('+', R, S))
10000 loops, best of 3: 23.1 us per loop
sage: ErrMess%('+', R, S)
unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'
```

So, it would already make sense to replace all error messages using string formatting by a call to `lazy_string`, while `LazyFormat` seems to be quite sluggish.

Two tasks:
1. Make `lazy_string` and `LazyFormat` a lot faster (perhaps by using Cython)
2. Use it for errors raised when trying to find coercions. The problem is particularly urgent if the string representation of an object is difficult to compute.

Apart from making coercion faster, there is the following problem that we would fix as well. Consider creation of a parent. It may happen that relatively early during initialisation, a coercion is needed, but only later, the string representation of the parent will become available. Hence, if there is an error raised (and caught) inside of the coercion system that relies on the string representation of the parent, then we are in trouble.

Issue created by migration from https://trac.sagemath.org/ticket/14585





---

archive/issue_comments_181421.json:
```json
{
    "body": "PS: It might make sense to put both `lazy_string` and `LazyFormat` into one file.",
    "created_at": "2013-05-15T09:40:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181421",
    "user": "https://github.com/simon-king-jena"
}
```

PS: It might make sense to put both `lazy_string` and `LazyFormat` into one file.



---

archive/issue_comments_181422.json:
```json
{
    "body": "Here is a first patch, that cythons lazy_string. Result:\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: f = lambda op,A,B:\"unsupported operand parent(s) for '%s': '%s' and '%s'\"%(op,A,B)\nsage: R = GF(5)\nsage: S = GF(3)\nsage: lazy_string(f, '+', R, S)\nl\"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'\"\nsage: %timeit Exception(lazy_string(f, '+', R, S))\n1000000 loops, best of 3: 595 ns per loop\n```\nSo, the time for raising the exception drops by more than 50% compared with the old Python lazy_string.\n\nNext will be lazy_format.",
    "created_at": "2013-05-15T10:08:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181422",
    "user": "https://github.com/simon-king-jena"
}
```

Here is a first patch, that cythons lazy_string. Result:

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda op,A,B:"unsupported operand parent(s) for '%s': '%s' and '%s'"%(op,A,B)
sage: R = GF(5)
sage: S = GF(3)
sage: lazy_string(f, '+', R, S)
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception(lazy_string(f, '+', R, S))
1000000 loops, best of 3: 595 ns per loop
```
So, the time for raising the exception drops by more than 50% compared with the old Python lazy_string.

Next will be lazy_format.



---

archive/issue_comments_181423.json:
```json
{
    "body": "Avoiding the function call:\n\n```\nsage: from sage.misc.lazy_string import _LazyString\nsage: _LazyString(f, ('+', R, S), {})\nl\"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'\"\nsage: %timeit Exception(_LazyString(f, ('+', R, S), {}))\n1000000 loops, best of 3: 545 ns per loop\n```\nGoes down by another 10%.",
    "created_at": "2013-05-15T10:10:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181423",
    "user": "https://github.com/simon-king-jena"
}
```

Avoiding the function call:

```
sage: from sage.misc.lazy_string import _LazyString
sage: _LazyString(f, ('+', R, S), {})
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception(_LazyString(f, ('+', R, S), {}))
1000000 loops, best of 3: 545 ns per loop
```
Goes down by another 10%.



---

archive/issue_comments_181424.json:
```json
{
    "body": "Perhaps we could use a dummy string (similar to what I did in `sage.structure.misc.AttributeErrorMessage`)? The additional code would be\n\n```\ncdef _LazyString _DummyLazyString = _LazyString(None, (), {})\n\ndef lazy_string_dummy(f, *args, **kwds):\n    _DummyLazyString._func = f\n    _DummyLazyString._args = args\n    _DummyLazyString._kwargs = kwds\n    return _DummyLazyString\n```\n\nAnd then, then one can raise errors even quicker:\n\n```\nsage: from sage.misc.lazy_string import lazy_string_dummy\nsage: f = lambda op,A,B:\"unsupported operand parent(s) for '%s': '%s' and '%s'\"%(op,A,B)\nsage: R = GF(5)\nsage: S = GF(3)\nsage: lazy_string_dummy(f, ('+', R, S), {})\nl\"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'\"\nsage: %timeit Exception(lazy_string_dummy(f, ('+', R, S), {}))\n1000000 loops, best of 3: 480 ns per loop\n```\n\nDo you think this would be feasible to have a unique message object for the errors raised and caught internally?",
    "created_at": "2013-05-15T10:22:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181424",
    "user": "https://github.com/simon-king-jena"
}
```

Perhaps we could use a dummy string (similar to what I did in `sage.structure.misc.AttributeErrorMessage`)? The additional code would be

```
cdef _LazyString _DummyLazyString = _LazyString(None, (), {})

def lazy_string_dummy(f, *args, **kwds):
    _DummyLazyString._func = f
    _DummyLazyString._args = args
    _DummyLazyString._kwargs = kwds
    return _DummyLazyString
```

And then, then one can raise errors even quicker:

```
sage: from sage.misc.lazy_string import lazy_string_dummy
sage: f = lambda op,A,B:"unsupported operand parent(s) for '%s': '%s' and '%s'"%(op,A,B)
sage: R = GF(5)
sage: S = GF(3)
sage: lazy_string_dummy(f, ('+', R, S), {})
l"unsupported operand parent(s) for '+': 'Finite Field of size 5' and 'Finite Field of size 3'"
sage: %timeit Exception(lazy_string_dummy(f, ('+', R, S), {}))
1000000 loops, best of 3: 480 ns per loop
```

Do you think this would be feasible to have a unique message object for the errors raised and caught internally?



---

archive/issue_comments_181425.json:
```json
{
    "body": "FWIW, I have attached a second patch, which uses a lazy string dummy. I am not sure if an in-place change of an error message is a good thing. But it did work in the case of `AttributeError`, so, I would not drop the idea too soon.",
    "created_at": "2013-05-15T10:39:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181425",
    "user": "https://github.com/simon-king-jena"
}
```

FWIW, I have attached a second patch, which uses a lazy string dummy. I am not sure if an in-place change of an error message is a good thing. But it did work in the case of `AttributeError`, so, I would not drop the idea too soon.



---

archive/issue_comments_181426.json:
```json
{
    "body": "Hmm. To make it more scalable, it would be better to rename `lazy_string_dummy` into `update_lazy_string` and give it an existing lazy string, that is merely updated.",
    "created_at": "2013-05-15T14:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181426",
    "user": "https://github.com/simon-king-jena"
}
```

Hmm. To make it more scalable, it would be better to rename `lazy_string_dummy` into `update_lazy_string` and give it an existing lazy string, that is merely updated.



---

archive/issue_comments_181427.json:
```json
{
    "body": "Does the reviewer think that an in-place change of a lazy string dummy makes sense?",
    "created_at": "2013-05-15T14:52:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181427",
    "user": "https://github.com/simon-king-jena"
}
```

Does the reviewer think that an in-place change of a lazy string dummy makes sense?



---

archive/issue_comments_181428.json:
```json
{
    "body": "Attachment [trac14585_dummy_lazy_string.patch](tarball://root/attachments/some-uuid/ticket14585/trac14585_dummy_lazy_string.patch) by @simon-king-jena created at 2013-05-15 14:53:45\n\nOK, I have updated the second patch accordingly. There is now not just a single lazy dummy, but an arbitrary existing lazy string (with fixed underlying function) can be updated by providing new arguments to the underlying function.",
    "created_at": "2013-05-15T14:53:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181428",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac14585_dummy_lazy_string.patch](tarball://root/attachments/some-uuid/ticket14585/trac14585_dummy_lazy_string.patch) by @simon-king-jena created at 2013-05-15 14:53:45

OK, I have updated the second patch accordingly. There is now not just a single lazy dummy, but an arbitrary existing lazy string (with fixed underlying function) can be updated by providing new arguments to the underlying function.



---

archive/issue_comments_181429.json:
```json
{
    "body": "Replying to [comment:3 SimonKing]:\n\n> sage: %timeit Exception(_LazyString(f, ('+', R, S), {}))\n- do we need the `{}` for kwargs?\n- does ditching it provide a worthwhile speedup?\n- how do we do if we instead have a `*kwargs` collect the arguments in a tuple rather than pass them as a tuple preformed?\n\nNote that `LazyFormat` would be completely analogous. In fact, internally they could be the same code, with just a flag that says \"interpolate f with args\" rather than \"call f with args\".\n\nThe latter has the advantage that it's a little easier: You don't have to prewrap a string in a lambda to get decent performance.",
    "created_at": "2013-05-15T15:13:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181429",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:3 SimonKing]:

> sage: %timeit Exception(_LazyString(f, ('+', R, S), {}))
- do we need the `{}` for kwargs?
- does ditching it provide a worthwhile speedup?
- how do we do if we instead have a `*kwargs` collect the arguments in a tuple rather than pass them as a tuple preformed?

Note that `LazyFormat` would be completely analogous. In fact, internally they could be the same code, with just a flag that says "interpolate f with args" rather than "call f with args".

The latter has the advantage that it's a little easier: You don't have to prewrap a string in a lambda to get decent performance.



---

archive/issue_comments_181430.json:
```json
{
    "body": "Replying to [comment:7 SimonKing]:\n> OK, I have updated the second patch accordingly. There is now not just a single lazy dummy, but an arbitrary existing lazy string (with fixed underlying function) can be updated by providing new arguments to the underlying function.\n\n\nHm ... are these strings hashable (and hence immutable)? Then this would be bad. In fact, if they're hashable they NEED to be caching, which goes counter to existing use of lazy_string, where it's used as a window on an environment variable.\n\nI'd say at least underscore this method to make it clear it's bad. And only use it in our code if you can show that in real-world examples it makes a considerable difference (which I doubt: producing exceptions is only going to be a small percentage of total processing time, so possible gain is limited)",
    "created_at": "2013-05-15T15:18:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181430",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:7 SimonKing]:
> OK, I have updated the second patch accordingly. There is now not just a single lazy dummy, but an arbitrary existing lazy string (with fixed underlying function) can be updated by providing new arguments to the underlying function.


Hm ... are these strings hashable (and hence immutable)? Then this would be bad. In fact, if they're hashable they NEED to be caching, which goes counter to existing use of lazy_string, where it's used as a window on an environment variable.

I'd say at least underscore this method to make it clear it's bad. And only use it in our code if you can show that in real-world examples it makes a considerable difference (which I doubt: producing exceptions is only going to be a small percentage of total processing time, so possible gain is limited)



---

archive/issue_comments_181431.json:
```json
{
    "body": "Replying to [comment:9 nbruin]:\n> Hm ... are these strings hashable (and hence immutable)?\n\n\nNo, it is not hashable.\n\n> I'd say at least underscore this method to make it clear it's bad.\n\n\nOr: cimport `_LazyString` in the coercion code and modify the arguments directly.\n\n> And only use it in our code if you can show that in real-world examples it makes a considerable difference (which I doubt: producing exceptions is only going to be a small percentage of total processing time, so possible gain is limited)\n\n\nSo I thought, before I worked on #14100. But there, the speed-up has been quite noticeable.\n\nOK, #14100 was about attribute errors, and I think accessing attributes is a more common operation than raising an error. So, it could be that you are right, and that it only contributes to a minor slowness. But a striking example should be: Test coercion of many different parents (which is typical for elliptic curve computations, it seems) into a parent that has an expensive string representation.\n\nAnyway, I think *improving* lazy_string should be separated from *using* lazy_string---the latter should be done on #14592.",
    "created_at": "2013-05-15T15:29:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181431",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:9 nbruin]:
> Hm ... are these strings hashable (and hence immutable)?


No, it is not hashable.

> I'd say at least underscore this method to make it clear it's bad.


Or: cimport `_LazyString` in the coercion code and modify the arguments directly.

> And only use it in our code if you can show that in real-world examples it makes a considerable difference (which I doubt: producing exceptions is only going to be a small percentage of total processing time, so possible gain is limited)


So I thought, before I worked on #14100. But there, the speed-up has been quite noticeable.

OK, #14100 was about attribute errors, and I think accessing attributes is a more common operation than raising an error. So, it could be that you are right, and that it only contributes to a minor slowness. But a striking example should be: Test coercion of many different parents (which is typical for elliptic curve computations, it seems) into a parent that has an expensive string representation.

Anyway, I think *improving* lazy_string should be separated from *using* lazy_string---the latter should be done on #14592.



---

archive/issue_comments_181432.json:
```json
{
    "body": "Replying to [comment:8 nbruin]:\n> Note that `LazyFormat` would be completely analogous. In fact, internally they could be the same code, with just a flag that says \"interpolate f with args\" rather than \"call f with args\".\n\n\nIn fact, perhaps just allow `LazyString` to be initialized with a string or a callable and interpolate with arguments rather than call with arguments if it's a string. That should be a very cheap test when the value gets requested.\n\nThe only difference with (present) `LazyFormat` would be that `LazyFormat` caches its value after first interpolation, but that's likely not an important trait (certainly not for our applications). Then you can basically just do away with `LazyFormat`.\n\nI did a quick experiment. For reference, I first tried the patch as given here:\n\n```\nsage: E=Exception(_LazyString(f, ('+', R, S)))\nsage: %timeit repr(E)\n100000 loops, best of 3: 6.76 us per loop\n```\n\nThen I tried it with\n\n```\n    @property\n    def value(self):\n        cdef object f=self._func\n        if PyString_Check(f):\n           return f%self._args\n        return f(*self._args)\n```\n\nwhich resulted in\n\n```\nsage: s=\"unsupported operand parent(s) for '%s': '%s' and '%s'\"\nsage: E=Exception(_LazyString(s, ('+', R, S)))\nsage: %timeit repr(E)\n100000 loops, best of 3: 6.48 us per loop\nsage: E=Exception(_LazyString(f, ('+', R, S)))\nsage: %timeit repr(E)\n100000 loops, best of 3: 6.54 us per loop\n```\nfrom which I don't dare to conclude that the code is MORE efficient with the branching, so I'll settle for not slower. (it seems putting or not putting a kwargs in there hardly makes a measurable difference, so we might as well).\n\nYou really do want to do a `PyString_Check` there. Doing an `isinstance` is noticeably slower.",
    "created_at": "2013-05-16T03:33:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181432",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:8 nbruin]:
> Note that `LazyFormat` would be completely analogous. In fact, internally they could be the same code, with just a flag that says "interpolate f with args" rather than "call f with args".


In fact, perhaps just allow `LazyString` to be initialized with a string or a callable and interpolate with arguments rather than call with arguments if it's a string. That should be a very cheap test when the value gets requested.

The only difference with (present) `LazyFormat` would be that `LazyFormat` caches its value after first interpolation, but that's likely not an important trait (certainly not for our applications). Then you can basically just do away with `LazyFormat`.

I did a quick experiment. For reference, I first tried the patch as given here:

```
sage: E=Exception(_LazyString(f, ('+', R, S)))
sage: %timeit repr(E)
100000 loops, best of 3: 6.76 us per loop
```

Then I tried it with

```
    @property
    def value(self):
        cdef object f=self._func
        if PyString_Check(f):
           return f%self._args
        return f(*self._args)
```

which resulted in

```
sage: s="unsupported operand parent(s) for '%s': '%s' and '%s'"
sage: E=Exception(_LazyString(s, ('+', R, S)))
sage: %timeit repr(E)
100000 loops, best of 3: 6.48 us per loop
sage: E=Exception(_LazyString(f, ('+', R, S)))
sage: %timeit repr(E)
100000 loops, best of 3: 6.54 us per loop
```
from which I don't dare to conclude that the code is MORE efficient with the branching, so I'll settle for not slower. (it seems putting or not putting a kwargs in there hardly makes a measurable difference, so we might as well).

You really do want to do a `PyString_Check` there. Doing an `isinstance` is noticeably slower.



---

archive/issue_comments_181433.json:
```json
{
    "body": "Replying to [comment:11 nbruin]:\n> I did a quick experiment. For reference, I first tried the patch as given here:\n> \n> ```\n> sage: E=Exception(_LazyString(f, ('+', R, S)))\n> sage: %timeit repr(E)\n> 100000 loops, best of 3: 6.76 us per loop\n> ```\n> \n> Then I tried it with\n> \n> ```\n>     @property\n>     def value(self):\n>         cdef object f=self._func\n>         if PyString_Check(f):\n>            return f%self._args\n>         return f(*self._args)\n> ```\n> \n> which resulted in\n> \n> ```\n> sage: s=\"unsupported operand parent(s) for '%s': '%s' and '%s'\"\n> sage: E=Exception(_LazyString(s, ('+', R, S)))\n> sage: %timeit repr(E)\n> 100000 loops, best of 3: 6.48 us per loop\n> sage: E=Exception(_LazyString(f, ('+', R, S)))\n> sage: %timeit repr(E)\n> 100000 loops, best of 3: 6.54 us per loop\n> ```\n> from which I don't dare to conclude that the code is MORE efficient with the branching, so I'll settle for not slower. (it seems putting or not putting a kwargs in there hardly makes a measurable difference, so we might as well).\n> \n> You really do want to do a `PyString_Check` there. Doing an `isinstance` is noticeably slower.\n\n\nOK, I'll change the patch accordingly, also deprecating `LazyFormat`, and creating a pxd file for lazy_string, so that it will later become possible to change a lazy string in-place without calling a function (but instead by cimporting it and then directly inserting stuff into the cdef attributes).",
    "created_at": "2013-05-16T08:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181433",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:11 nbruin]:
> I did a quick experiment. For reference, I first tried the patch as given here:
> 
> ```
> sage: E=Exception(_LazyString(f, ('+', R, S)))
> sage: %timeit repr(E)
> 100000 loops, best of 3: 6.76 us per loop
> ```
> 
> Then I tried it with
> 
> ```
>     @property
>     def value(self):
>         cdef object f=self._func
>         if PyString_Check(f):
>            return f%self._args
>         return f(*self._args)
> ```
> 
> which resulted in
> 
> ```
> sage: s="unsupported operand parent(s) for '%s': '%s' and '%s'"
> sage: E=Exception(_LazyString(s, ('+', R, S)))
> sage: %timeit repr(E)
> 100000 loops, best of 3: 6.48 us per loop
> sage: E=Exception(_LazyString(f, ('+', R, S)))
> sage: %timeit repr(E)
> 100000 loops, best of 3: 6.54 us per loop
> ```
> from which I don't dare to conclude that the code is MORE efficient with the branching, so I'll settle for not slower. (it seems putting or not putting a kwargs in there hardly makes a measurable difference, so we might as well).
> 
> You really do want to do a `PyString_Check` there. Doing an `isinstance` is noticeably slower.


OK, I'll change the patch accordingly, also deprecating `LazyFormat`, and creating a pxd file for lazy_string, so that it will later become possible to change a lazy string in-place without calling a function (but instead by cimporting it and then directly inserting stuff into the cdef attributes).



---

archive/issue_comments_181434.json:
```json
{
    "body": "With the updated patch,\n\n- `_LazyString` accepts both functions and format strings as arguments\n- It has a cpdef method allowing to change it in-place. I think that's better than a function modifying a global object.\n- I don't know how to deprecate `LazyFormat`. It has no `__init__` method (only the one inherited from str), and hence I don't know where to put a deprecation warning. But I added a comment in the documentation.\n- I added more tests.\n\nApply trac14585-cythoned_lazy_string.patch",
    "created_at": "2013-05-16T09:04:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181434",
    "user": "https://github.com/simon-king-jena"
}
```

With the updated patch,

- `_LazyString` accepts both functions and format strings as arguments
- It has a cpdef method allowing to change it in-place. I think that's better than a function modifying a global object.
- I don't know how to deprecate `LazyFormat`. It has no `__init__` method (only the one inherited from str), and hence I don't know where to put a deprecation warning. But I added a comment in the documentation.
- I added more tests.

Apply trac14585-cythoned_lazy_string.patch



---

archive/issue_comments_181435.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-05-16T09:04:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181435",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_181436.json:
```json
{
    "body": "Replying to [comment:13 SimonKing]:\n> With the updated patch,\n> \n> - `_LazyString` accepts both functions and format strings as arguments\n> - It has a cpdef method allowing to change it in-place. I think that's better than a function modifying a global object.\n> - I don't know how to deprecate `LazyFormat`. It has no `__init__` method (only the one inherited from str), and hence I don't know where to put a deprecation warning. But I added a comment in the documentation.\n> - I added more tests.\n> \n> Apply trac14585-cythoned_lazy_string.patch\n\n\nHow about just changing `LazyFormat` to a factory function for `_LazyString` objects? Then we at least get the benefit (provided chaching behaviour is not required for it. Otherwise `LazyString` might grow a `cache_result` flag, if that doesn't affect performance.\n\nAlso, I think `_LazyString` has an easy enough interface to be called `LazyString` and be used directly (and then just leave `lazy_string` around for compatibility reasons).",
    "created_at": "2013-05-16T15:42:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181436",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:13 SimonKing]:
> With the updated patch,
> 
> - `_LazyString` accepts both functions and format strings as arguments
> - It has a cpdef method allowing to change it in-place. I think that's better than a function modifying a global object.
> - I don't know how to deprecate `LazyFormat`. It has no `__init__` method (only the one inherited from str), and hence I don't know where to put a deprecation warning. But I added a comment in the documentation.
> - I added more tests.
> 
> Apply trac14585-cythoned_lazy_string.patch


How about just changing `LazyFormat` to a factory function for `_LazyString` objects? Then we at least get the benefit (provided chaching behaviour is not required for it. Otherwise `LazyString` might grow a `cache_result` flag, if that doesn't affect performance.

Also, I think `_LazyString` has an easy enough interface to be called `LazyString` and be used directly (and then just leave `lazy_string` around for compatibility reasons).



---

archive/issue_comments_181437.json:
```json
{
    "body": "Changed ticket title to reflect that this ticket is about improving the routines themselves. Simon says that #14592 is for applying them more widely to error messages (if that turns out to be worthwhile)",
    "created_at": "2013-05-16T15:56:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181437",
    "user": "https://github.com/nbruin"
}
```

Changed ticket title to reflect that this ticket is about improving the routines themselves. Simon says that #14592 is for applying them more widely to error messages (if that turns out to be worthwhile)



---

archive/issue_comments_181438.json:
```json
{
    "body": "I also realized that the following spelling leads to more efficient code in cython:\n\n```\n    property value:\n        def __get__(self):\n            cdef object f=self._func\n            if PyString_Check(f):\n               return f%self._args\n            return f(*self._args)\n```\nWith the old code:\n\n```\nsage: from sage.misc.lazy_string import lazy_string, _LazyString\nsage: f=lambda :\"hi\"\nsage: s=_LazyString(f,())\nsage: %timeit str(s)\n1000000 loops, best of 3: 425 ns per loop\n```\nand with cython property spelling:\n\n```\nsage: %timeit str(s)\n1000000 loops, best of 3: 282 ns per loop\n```\nFinally:\n\n```\nsage: f=lambda n:\"hi%s\"%n\nsage: s=_LazyString(f,('ho',))\nsage: %timeit str(s)\n1000000 loops, best of 3: 428 ns per loop\nsage: %timeit str(s)\n1000000 loops, best of 3: 423 ns per loop\nsage: f=\"hi%s\"\nsage: s=_LazyString(f,('ho',))\nsage: %timeit str(s)\n1000000 loops, best of 3: 319 ns per loop\nsage: %timeit str(s)\n1000000 loops, best of 3: 316 ns per loop\n```\nso special casing string values to directly interpolate seems to be a measurable saving (on something that doesn't seem to contribute much to total running time anyway)",
    "created_at": "2013-05-16T16:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181438",
    "user": "https://github.com/nbruin"
}
```

I also realized that the following spelling leads to more efficient code in cython:

```
    property value:
        def __get__(self):
            cdef object f=self._func
            if PyString_Check(f):
               return f%self._args
            return f(*self._args)
```
With the old code:

```
sage: from sage.misc.lazy_string import lazy_string, _LazyString
sage: f=lambda :"hi"
sage: s=_LazyString(f,())
sage: %timeit str(s)
1000000 loops, best of 3: 425 ns per loop
```
and with cython property spelling:

```
sage: %timeit str(s)
1000000 loops, best of 3: 282 ns per loop
```
Finally:

```
sage: f=lambda n:"hi%s"%n
sage: s=_LazyString(f,('ho',))
sage: %timeit str(s)
1000000 loops, best of 3: 428 ns per loop
sage: %timeit str(s)
1000000 loops, best of 3: 423 ns per loop
sage: f="hi%s"
sage: s=_LazyString(f,('ho',))
sage: %timeit str(s)
1000000 loops, best of 3: 319 ns per loop
sage: %timeit str(s)
1000000 loops, best of 3: 316 ns per loop
```
so special casing string values to directly interpolate seems to be a measurable saving (on something that doesn't seem to contribute much to total running time anyway)



---

archive/issue_comments_181439.json:
```json
{
    "body": "Replying to [comment:17 nbruin]:\n> I also realized that the following spelling leads to more efficient code in cython:\n> \n> ```\n>     property value:\n>         def __get__(self):\n>             cdef object f=self._func\n>             if PyString_Check(f):\n>                return f%self._args\n>             return f(*self._args)\n> ```\n\n\nIs this the Cython spelling of \"`@`property\"? Why can't Cython automatically transform Python's `@`property accordingly?",
    "created_at": "2013-05-16T16:22:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181439",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:17 nbruin]:
> I also realized that the following spelling leads to more efficient code in cython:
> 
> ```
>     property value:
>         def __get__(self):
>             cdef object f=self._func
>             if PyString_Check(f):
>                return f%self._args
>             return f(*self._args)
> ```


Is this the Cython spelling of "`@`property"? Why can't Cython automatically transform Python's `@`property accordingly?



---

archive/issue_comments_181440.json:
```json
{
    "body": "Could the failures observed by the patchbot be due to this patch? How can it be amended?\n\nIf unpickling of `_LazyString` is the problem, then your suggestion to rename it into `LazyString` has another benefit: One could use the old `_LazyString` to convert old lazy strings to new lazy strings. I just don't know how (I guess pickling is by class and `__dict__`).",
    "created_at": "2013-05-16T16:25:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181440",
    "user": "https://github.com/simon-king-jena"
}
```

Could the failures observed by the patchbot be due to this patch? How can it be amended?

If unpickling of `_LazyString` is the problem, then your suggestion to rename it into `LazyString` has another benefit: One could use the old `_LazyString` to convert old lazy strings to new lazy strings. I just don't know how (I guess pickling is by class and `__dict__`).



---

archive/issue_comments_181441.json:
```json
{
    "body": "Replying to [comment:18 SimonKing]:\n> Is this the Cython spelling of \"`@`property\"? Why can't Cython automatically transform Python's `@`property accordingly?\n\n\nWell ... ``@`property` is valid in in cython as well, but has a different meaning and effect. I'm not sure if it's doable and desirable for cython to transcribe it to `property:` because most of the time that's what the author intends. We'll see: [cython-users thread](http://groups.google.com/group/cython-users/browse_thread/thread/1a3a6defe99c6fd0)\n\nIt's just that on C-API level some lower level hooks are available that `property:` can hook into.",
    "created_at": "2013-05-16T17:32:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181441",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:18 SimonKing]:
> Is this the Cython spelling of "`@`property"? Why can't Cython automatically transform Python's `@`property accordingly?


Well ... ``@`property` is valid in in cython as well, but has a different meaning and effect. I'm not sure if it's doable and desirable for cython to transcribe it to `property:` because most of the time that's what the author intends. We'll see: [cython-users thread](http://groups.google.com/group/cython-users/browse_thread/thread/1a3a6defe99c6fd0)

It's just that on C-API level some lower level hooks are available that `property:` can hook into.



---

archive/issue_comments_181442.json:
```json
{
    "body": "Replying to [comment:17 nbruin]:\n>             return f(*self._args)\n\nand here you can shave a few nanoseconds off by using\n\n```\nreturn PyObject_CallObject(f,self._args)\n```\nor\n\n```\nreturn PyObject_Call(f,self._args,self._kwargs)\n```\nCython still generates some code to ensure that the resulting bit from * is a tuple and not a general iterable, but we've already forced it to be a tuple.",
    "created_at": "2013-05-16T22:19:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181442",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:17 nbruin]:
>             return f(*self._args)

and here you can shave a few nanoseconds off by using

```
return PyObject_CallObject(f,self._args)
```
or

```
return PyObject_Call(f,self._args,self._kwargs)
```
Cython still generates some code to ensure that the resulting bit from * is a tuple and not a general iterable, but we've already forced it to be a tuple.



---

archive/issue_comments_181443.json:
```json
{
    "body": "Replying to [comment:21 nbruin]:\n> Replying to [comment:17 nbruin]:\n> >             return f(*self._args)\n\n> and here you can shave a few nanoseconds off by using\n> {{{\n> return PyObject_CallObject(f,self._args)\n> }}}\n> or\n> \n> ```\n> return PyObject_Call(f,self._args,self._kwargs)\n> ```\n> Cython still generates some code to ensure that the resulting bit from * is a tuple and not a general iterable, but we've already forced it to be a tuple.\n\n\nAre the two versions giving essentially the same C-code?",
    "created_at": "2013-05-17T05:11:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181443",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:21 nbruin]:
> Replying to [comment:17 nbruin]:
> >             return f(*self._args)

> and here you can shave a few nanoseconds off by using
> {{{
> return PyObject_CallObject(f,self._args)
> }}}
> or
> 
> ```
> return PyObject_Call(f,self._args,self._kwargs)
> ```
> Cython still generates some code to ensure that the resulting bit from * is a tuple and not a general iterable, but we've already forced it to be a tuple.


Are the two versions giving essentially the same C-code?



---

archive/issue_comments_181444.json:
```json
{
    "body": "Replying to [comment:22 SimonKing]:\n> > return PyObject_CallObject(f,self._args)\n> > return PyObject_Call(f,self._args,self._kwargs)\n\n \n> Are the two versions giving essentially the same C-code?\n\n\nI'm not entirely sure what you're asking, so I'll try to just generally clarify. If you write `f(*args)` then cython will produce code to package the contents of `args` into a tuple (since `args` could be any iterable). We don't need to do that.\n\nThe difference between `Call` and `CallObject` is whether there's a `kwargs` there. Not having that saves a couple of nanoseconds too.\n\nThese `PyObject_Call*` routines seem to be the official API for calling things, so Cython generates this too.",
    "created_at": "2013-05-17T06:12:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181444",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:22 SimonKing]:
> > return PyObject_CallObject(f,self._args)
> > return PyObject_Call(f,self._args,self._kwargs)

 
> Are the two versions giving essentially the same C-code?


I'm not entirely sure what you're asking, so I'll try to just generally clarify. If you write `f(*args)` then cython will produce code to package the contents of `args` into a tuple (since `args` could be any iterable). We don't need to do that.

The difference between `Call` and `CallObject` is whether there's a `kwargs` there. Not having that saves a couple of nanoseconds too.

These `PyObject_Call*` routines seem to be the official API for calling things, so Cython generates this too.



---

archive/issue_comments_181445.json:
```json
{
    "body": "Replying to [comment:23 nbruin]:\n> The difference between `Call` and `CallObject` is whether there's a `kwargs` there. Not having that saves a couple of nanoseconds too.\n\n\nOK. I don't know if named arguments are really used, but the possibility to use them is currently provided. So, I think `PyObject_Call(f, args, kwargs)` should be the right thing to do.\n\nCan you confirm the unpickling errors reported by the patchbot?",
    "created_at": "2013-05-17T07:40:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181445",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:23 nbruin]:
> The difference between `Call` and `CallObject` is whether there's a `kwargs` there. Not having that saves a couple of nanoseconds too.


OK. I don't know if named arguments are really used, but the possibility to use them is currently provided. So, I think `PyObject_Call(f, args, kwargs)` should be the right thing to do.

Can you confirm the unpickling errors reported by the patchbot?



---

archive/issue_comments_181446.json:
```json
{
    "body": "I think we should resume working on this patch. Currently, it fails to build with this error:\n\n```\nCython.Compiler.Errors.InternalError: Internal compiler error: '../ext/python_string.pxi' not found\nError installing modified sage library code.\n```\nHas this file been moved? Renamed even? I can not find it under SAGE_ROOT/devel/sage/.",
    "created_at": "2013-08-11T13:39:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181446",
    "user": "https://github.com/simon-king-jena"
}
```

I think we should resume working on this patch. Currently, it fails to build with this error:

```
Cython.Compiler.Errors.InternalError: Internal compiler error: '../ext/python_string.pxi' not found
Error installing modified sage library code.
```
Has this file been moved? Renamed even? I can not find it under SAGE_ROOT/devel/sage/.



---

archive/issue_comments_181447.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-08-11T13:39:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181447",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_181448.json:
```json
{
    "body": "Replying to [comment:25 SimonKing]:\n> I think we should resume working on this patch. Currently, it fails to build with this error:\n> \n> ```\n> Cython.Compiler.Errors.InternalError: Internal compiler error: '../ext/python_string.pxi' not found\n> Error installing modified sage library code.\n> ```\n> Has this file been moved? Renamed even? I can not find it under SAGE_ROOT/devel/sage/.\n\n\nIt has been #6223.",
    "created_at": "2013-08-11T13:48:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181448",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:25 SimonKing]:
> I think we should resume working on this patch. Currently, it fails to build with this error:
> 
> ```
> Cython.Compiler.Errors.InternalError: Internal compiler error: '../ext/python_string.pxi' not found
> Error installing modified sage library code.
> ```
> Has this file been moved? Renamed even? I can not find it under SAGE_ROOT/devel/sage/.


It has been #6223.



---

archive/issue_comments_181449.json:
```json
{
    "body": "Only apply this patch",
    "created_at": "2013-08-11T13:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181449",
    "user": "https://github.com/simon-king-jena"
}
```

Only apply this patch



---

archive/issue_comments_181450.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-08-11T13:55:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181450",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_181451.json:
```json
{
    "body": "Attachment [trac14585-cythoned_lazy_string.patch](tarball://root/attachments/some-uuid/ticket14585/trac14585-cythoned_lazy_string.patch) by @simon-king-jena created at 2013-08-11 13:55:52\n\nI have updated the patch so that it correctly builds. Note that I did not add the improvements suggested by Nils, yet.\n\nApply trac14585-cythoned_lazy_string.patch",
    "created_at": "2013-08-11T13:55:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181451",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac14585-cythoned_lazy_string.patch](tarball://root/attachments/some-uuid/ticket14585/trac14585-cythoned_lazy_string.patch) by @simon-king-jena created at 2013-08-11 13:55:52

I have updated the patch so that it correctly builds. Note that I did not add the improvements suggested by Nils, yet.

Apply trac14585-cythoned_lazy_string.patch



---

archive/issue_events_041531.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41531"
}
```



---

archive/issue_comments_181452.json:
```json
{
    "body": "Don't forget:\n\n```\n    property value:\n        def __get__(self):\n            cdef object f=self._func\n            if PyString_Check(f):\n               return f%self._args\n            return f(*self._args)\n```\ninstead of the ``@`property` decorator leads to much better (and faster) cython code.",
    "created_at": "2013-08-22T22:31:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181452",
    "user": "https://github.com/nbruin"
}
```

Don't forget:

```
    property value:
        def __get__(self):
            cdef object f=self._func
            if PyString_Check(f):
               return f%self._args
            return f(*self._args)
```
instead of the ``@`property` decorator leads to much better (and faster) cython code.



---

archive/issue_events_041532.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41532"
}
```



---

archive/issue_events_041533.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41533"
}
```



---

archive/issue_comments_181453.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-03-31T07:45:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181453",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_events_041534.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41534"
}
```



---

archive/issue_events_041535.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41535"
}
```



---

archive/issue_events_041536.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41536"
}
```



---

archive/issue_events_041537.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41537"
}
```



---

archive/issue_comments_181454.json:
```json
{
    "body": "Part of why `LazyFormat` seems so sluggish presently is the strategy how it copies itself when asked to rebind. It will usually be cheaper to make a fresh `LazyFormat` object (in other words, we should make the rebinding just do that). The problem presently is that the use of `copy` leads to the desperate act of using `__reduce__` (!) to do the copying. Much better already:\n\n```\nsage: class A(str): pass\nsage: a=A(\"a\")\nsage: %timeit copy(a)\n100000 loops, best of 3: 13 \u00b5s per loop\nsage: %timeit A(str.__repr__(a))\n1000000 loops, best of 3: 558 ns per loop\nsage: %timeit A(\"a\")\n10000000 loops, best of 3: 258 ns per loop\n```\nso at the very least we should use the latter incantation in `LazyFormat.__mod__`, and it would be even nicer be able to get the string value of a in a cheaper way.",
    "created_at": "2015-04-28T07:08:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181454",
    "user": "https://github.com/nbruin"
}
```

Part of why `LazyFormat` seems so sluggish presently is the strategy how it copies itself when asked to rebind. It will usually be cheaper to make a fresh `LazyFormat` object (in other words, we should make the rebinding just do that). The problem presently is that the use of `copy` leads to the desperate act of using `__reduce__` (!) to do the copying. Much better already:

```
sage: class A(str): pass
sage: a=A("a")
sage: %timeit copy(a)
100000 loops, best of 3: 13 s per loop
sage: %timeit A(str.__repr__(a))
1000000 loops, best of 3: 558 ns per loop
sage: %timeit A("a")
10000000 loops, best of 3: 258 ns per loop
```
so at the very least we should use the latter incantation in `LazyFormat.__mod__`, and it would be even nicer be able to get the string value of a in a cheaper way.



---

archive/issue_comments_181455.json:
```json
{
    "body": "cc'ing me... it would be cool to have a follow up ticket for cleaning most error messages and also advertise lazy strings in the developer manual.\n\nVincent",
    "created_at": "2015-04-28T08:58:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181455",
    "user": "https://github.com/videlec"
}
```

cc'ing me... it would be cool to have a follow up ticket for cleaning most error messages and also advertise lazy strings in the developer manual.

Vincent



---

archive/issue_comments_181456.json:
```json
{
    "body": "I have converted the patch to a branch. Note that comment:27 still applies: I did not add the improvements suggested by Nils, yet.\n\n---\nNew commits:",
    "created_at": "2015-07-23T10:09:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181456",
    "user": "https://github.com/simon-king-jena"
}
```

I have converted the patch to a branch. Note that comment:27 still applies: I did not add the improvements suggested by Nils, yet.

---
New commits:



---

archive/issue_comments_181457.json:
```json
{
    "body": "With the current branch, I get\n\n```\nsage: from sage.misc.lazy_string import lazy_string, _LazyString\nsage: f=lambda :\"hi\"\nsage: s=_LazyString(f,(), {})\nsage: %timeit str(s)\nThe slowest run took 21.90 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 827 ns per loop\n```\nWith the change that Nils suggested in comment:29, I get\n\n```\nsage: from sage.misc.lazy_string import lazy_string, _LazyString\nsage: f=lambda :\"hi\"\nsage: s=_LazyString(f,(), {})\nsage: %timeit str(s)\nThe slowest run took 11.15 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 535 ns per loop\n```\nPushing the change...",
    "created_at": "2015-07-23T10:24:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181457",
    "user": "https://github.com/simon-king-jena"
}
```

With the current branch, I get

```
sage: from sage.misc.lazy_string import lazy_string, _LazyString
sage: f=lambda :"hi"
sage: s=_LazyString(f,(), {})
sage: %timeit str(s)
The slowest run took 21.90 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 827 ns per loop
```
With the change that Nils suggested in comment:29, I get

```
sage: from sage.misc.lazy_string import lazy_string, _LazyString
sage: f=lambda :"hi"
sage: s=_LazyString(f,(), {})
sage: %timeit str(s)
The slowest run took 11.15 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 535 ns per loop
```
Pushing the change...



---

archive/issue_comments_181458.json:
```json
{
    "body": "Upps. I noticed that the previous branch was invalid anyway.",
    "created_at": "2015-07-23T10:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181458",
    "user": "https://github.com/simon-king-jena"
}
```

Upps. I noticed that the previous branch was invalid anyway.



---

archive/issue_comments_181459.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-23T10:26:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181459",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_181460.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-23T10:33:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181460",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_181461.json:
```json
{
    "body": "Without the CallObject, we get\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: f = lambda x: \"laziness\" + repr(x)\nsage: s = lazy_string(f, 5)\nsage: %timeit str(s)\nThe slowest run took 13.06 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.53 \u00b5s per loop\nsage: s = lazy_string(\"This is %s\", ZZ)\nsage: %timeit str(s)\nThe slowest run took 8.76 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 2.29 \u00b5s per loop\n```\n\nWith the CallObject, we get\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: f = lambda x: \"laziness\" + repr(x)\nsage: s = lazy_string(f, 5)\nsage: %timeit str(s)\nThe slowest run took 15.19 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.59 \u00b5s per loop\nsage: s = lazy_string(\"This is %s\", ZZ)\nsage: %timeit str(s)\nThe slowest run took 10.33 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 2.42 \u00b5s per loop\n```\n\nSo, in contrast to what is claimed in comment:21, I don't see an improvement. Should we revert it? Or can you provide an example where the change really matters?\n\n---\nNew commits:",
    "created_at": "2015-07-23T10:41:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181461",
    "user": "https://github.com/simon-king-jena"
}
```

Without the CallObject, we get

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda x: "laziness" + repr(x)
sage: s = lazy_string(f, 5)
sage: %timeit str(s)
The slowest run took 13.06 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.53 s per loop
sage: s = lazy_string("This is %s", ZZ)
sage: %timeit str(s)
The slowest run took 8.76 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 2.29 s per loop
```

With the CallObject, we get

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda x: "laziness" + repr(x)
sage: s = lazy_string(f, 5)
sage: %timeit str(s)
The slowest run took 15.19 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.59 s per loop
sage: s = lazy_string("This is %s", ZZ)
sage: %timeit str(s)
The slowest run took 10.33 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 2.42 s per loop
```

So, in contrast to what is claimed in comment:21, I don't see an improvement. Should we revert it? Or can you provide an example where the change really matters?

---
New commits:



---

archive/issue_comments_181462.json:
```json
{
    "body": "If you never *use* the fact that `_args` is a tuple and `_kwds` is a dict, there is no point in doing\n\n```\ncdef tuple _args\ncdef dict _kwargs\n```\n\nYou can simplify this (and also drop the ugly underscores) to\n\n```\ncdef args\ncdef kwargs\n```\n(which is actually an epsilon faster since there are no checks needed)",
    "created_at": "2015-07-23T10:44:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181462",
    "user": "https://github.com/jdemeyer"
}
```

If you never *use* the fact that `_args` is a tuple and `_kwds` is a dict, there is no point in doing

```
cdef tuple _args
cdef dict _kwargs
```

You can simplify this (and also drop the ugly underscores) to

```
cdef args
cdef kwargs
```
(which is actually an epsilon faster since there are no checks needed)



---

archive/issue_comments_181463.json:
```json
{
    "body": "For `__richcmp__`, you can just use\n\n```\nreturn PyObject_RichCompare(self.value, other, v)\n```",
    "created_at": "2015-07-23T10:48:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181463",
    "user": "https://github.com/jdemeyer"
}
```

For `__richcmp__`, you can just use

```
return PyObject_RichCompare(self.value, other, v)
```



---

archive/issue_comments_181464.json:
```json
{
    "body": "Next, I wish to address the slowness of `LazyFormat`. We have\n\n```\nsage: from sage.misc.lazy_format import LazyFormat\nsage: form = LazyFormat(\"<%s>\")\nsage: cform = LazyFormat(\"\"+form)\nsage: cform\nunbound LazyFormat(\"<%s>\")\nsage: %timeit copy(form)\nThe slowest run took 9.12 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 16.3 \u00b5s per loop\nsage: %timeit LazyFormat(\"\"+form)\nThe slowest run took 12.69 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 395 ns per loop\n```\nSo, this is what we could use in `__mod__` for speed-up",
    "created_at": "2015-07-23T10:50:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181464",
    "user": "https://github.com/simon-king-jena"
}
```

Next, I wish to address the slowness of `LazyFormat`. We have

```
sage: from sage.misc.lazy_format import LazyFormat
sage: form = LazyFormat("<%s>")
sage: cform = LazyFormat(""+form)
sage: cform
unbound LazyFormat("<%s>")
sage: %timeit copy(form)
The slowest run took 9.12 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 16.3 s per loop
sage: %timeit LazyFormat(""+form)
The slowest run took 12.69 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 395 ns per loop
```
So, this is what we could use in `__mod__` for speed-up



---

archive/issue_comments_181465.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-23T10:53:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181465",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_181466.json:
```json
{
    "body": "The improvement is clear:\n\nOld version:\n\n```\nsage: from sage.misc.lazy_format import LazyFormat\nsage: form = LazyFormat(\"<%s>\")\nsage: %timeit form%\"hi\"\n10000 loops, best of 3: 22 \u00b5s per loop\n```\n\nNew version:\n\n```\nsage: from sage.misc.lazy_format import LazyFormat\nsage: form = LazyFormat(\"<%s>\")\nsage: form%\"hi\"\n<hi>\nsage: %timeit form%\"hi\"\nThe slowest run took 6.91 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.28 \u00b5s per loop\n```",
    "created_at": "2015-07-23T10:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181466",
    "user": "https://github.com/simon-king-jena"
}
```

The improvement is clear:

Old version:

```
sage: from sage.misc.lazy_format import LazyFormat
sage: form = LazyFormat("<%s>")
sage: %timeit form%"hi"
10000 loops, best of 3: 22 s per loop
```

New version:

```
sage: from sage.misc.lazy_format import LazyFormat
sage: form = LazyFormat("<%s>")
sage: form%"hi"
<hi>
sage: %timeit form%"hi"
The slowest run took 6.91 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.28 s per loop
```



---

archive/issue_comments_181467.json:
```json
{
    "body": "Replying to [comment:44 jdemeyer]:\n> If you never *use* the fact that `_args` is a tuple and `_kwds` is a dict, there is no point in doing\n> \n> ```\n> cdef tuple _args\n> cdef dict _kwargs\n> ```\n> \n> You can simplify this (and also drop the ugly underscores) to\n> \n> ```\n> cdef args\n> cdef kwargs\n> ```\n> (which is actually an epsilon faster since there are no checks needed)\n\n\nDon't we use it being tuple/dict when we use `CallObject`?",
    "created_at": "2015-07-23T10:55:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181467",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:44 jdemeyer]:
> If you never *use* the fact that `_args` is a tuple and `_kwds` is a dict, there is no point in doing
> 
> ```
> cdef tuple _args
> cdef dict _kwargs
> ```
> 
> You can simplify this (and also drop the ugly underscores) to
> 
> ```
> cdef args
> cdef kwargs
> ```
> (which is actually an epsilon faster since there are no checks needed)


Don't we use it being tuple/dict when we use `CallObject`?



---

archive/issue_comments_181468.json:
```json
{
    "body": "Replying to [comment:49 SimonKing]:\n> Don't we use it being tuple/dict when we use `CallObject`?\n\nNo, Cython declares it as\n\n```\nobject PyObject_CallObject(object callable_object, object args)\n```",
    "created_at": "2015-07-23T11:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181468",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:49 SimonKing]:
> Don't we use it being tuple/dict when we use `CallObject`?

No, Cython declares it as

```
object PyObject_CallObject(object callable_object, object args)
```



---

archive/issue_comments_181469.json:
```json
{
    "body": "Replying to [comment:45 jdemeyer]:\n> For `__richcmp__`, you can just use\n> \n> ```\n> return PyObject_RichCompare(self.value, other, v)\n> ```\n\n\nI tried it, and to my surprise it seems slightly slower:\n\nCurrent code\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: f = lambda: \"laziness\"\nsage: s = lazy_string(f)\nsage: %timeit s < 'laziness'\nThe slowest run took 17.05 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 294 ns per loop\nsage: %timeit s <= 'aziness'\nThe slowest run took 19.35 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 308 ns per loop\nsage: %timeit s == 'laziness'\nThe slowest run took 20.48 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 291 ns per loop\nsage: %timeit s != 'aziness'\nThe slowest run took 40.70 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 293 ns per loop\n```\n\nWith `PyObject_RichCompare`:\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: f = lambda: \"laziness\"\nsage: s = lazy_string(f)\nsage: %timeit s < 'laziness'\nThe slowest run took 17.50 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 341 ns per loop\nsage: %timeit s <= 'aziness'\nThe slowest run took 20.08 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 344 ns per loop\nsage: %timeit s == 'laziness'\nThe slowest run took 20.68 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 334 ns per loop\nsage: %timeit s != 'aziness'\nThe slowest run took 21.79 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 328 ns per loop\n```\n\nSo, we shouldn't do that.",
    "created_at": "2015-07-23T11:01:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181469",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:45 jdemeyer]:
> For `__richcmp__`, you can just use
> 
> ```
> return PyObject_RichCompare(self.value, other, v)
> ```


I tried it, and to my surprise it seems slightly slower:

Current code

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda: "laziness"
sage: s = lazy_string(f)
sage: %timeit s < 'laziness'
The slowest run took 17.05 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 294 ns per loop
sage: %timeit s <= 'aziness'
The slowest run took 19.35 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 308 ns per loop
sage: %timeit s == 'laziness'
The slowest run took 20.48 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 291 ns per loop
sage: %timeit s != 'aziness'
The slowest run took 40.70 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 293 ns per loop
```

With `PyObject_RichCompare`:

```
sage: from sage.misc.lazy_string import lazy_string
sage: f = lambda: "laziness"
sage: s = lazy_string(f)
sage: %timeit s < 'laziness'
The slowest run took 17.50 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 341 ns per loop
sage: %timeit s <= 'aziness'
The slowest run took 20.08 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 344 ns per loop
sage: %timeit s == 'laziness'
The slowest run took 20.68 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 334 ns per loop
sage: %timeit s != 'aziness'
The slowest run took 21.79 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 328 ns per loop
```

So, we shouldn't do that.



---

archive/issue_comments_181470.json:
```json
{
    "body": "I am currently unable to check out this branch:\n\n```\nfatal: unable to connect to trac.sagemath.org:\ntrac.sagemath.org[0: 128.208.160.253]: errno=Connection timed out\n```\nbut you should check whether it makes sense to define a `cdef value(self)` function and use that everywhere in the private interface.",
    "created_at": "2015-07-23T11:03:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181470",
    "user": "https://github.com/jdemeyer"
}
```

I am currently unable to check out this branch:

```
fatal: unable to connect to trac.sagemath.org:
trac.sagemath.org[0: 128.208.160.253]: errno=Connection timed out
```
but you should check whether it makes sense to define a `cdef value(self)` function and use that everywhere in the private interface.



---

archive/issue_comments_181471.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-23T11:07:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181471",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_181472.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-07-23T11:09:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181472",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_181473.json:
```json
{
    "body": "Replying to [comment:50 jdemeyer]:\n> Replying to [comment:49 SimonKing]:\n> > Don't we use it being tuple/dict when we use `CallObject`?\n\n> No, Cython declares it as\n> {{{\n> object PyObject_CallObject(object callable_object, object args)\n> }}}\n\n\nOK, I have removed the underscore, and I have made it objects rather than tuple/dict. However, in the two methods that set/change the attributes (that's `__init__` and `update_lazy_string`), I am still checking the types. I think now it can be reviewed.",
    "created_at": "2015-07-23T11:09:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181473",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:50 jdemeyer]:
> Replying to [comment:49 SimonKing]:
> > Don't we use it being tuple/dict when we use `CallObject`?

> No, Cython declares it as
> {{{
> object PyObject_CallObject(object callable_object, object args)
> }}}


OK, I have removed the underscore, and I have made it objects rather than tuple/dict. However, in the two methods that set/change the attributes (that's `__init__` and `update_lazy_string`), I am still checking the types. I think now it can be reviewed.



---

archive/issue_comments_181474.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-07-23T11:26:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181474",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_181475.json:
```json
{
    "body": "Instead of\n\n```\ndef __init__(self, f, tuple args, dict kwargs):\n```\nbetter use\n\n```\ndef __init__(self, f, args, kwargs):\n```\n\nIf you really want to check the types, you can do that by\n\n```\nself.args = <tuple?>args\nself.kwds = <dict?>kwds\n```\n(this also disallows `None` for `args` and `kwds`)",
    "created_at": "2015-07-23T11:26:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181475",
    "user": "https://github.com/jdemeyer"
}
```

Instead of

```
def __init__(self, f, tuple args, dict kwargs):
```
better use

```
def __init__(self, f, args, kwargs):
```

If you really want to check the types, you can do that by

```
self.args = <tuple?>args
self.kwds = <dict?>kwds
```
(this also disallows `None` for `args` and `kwds`)



---

archive/issue_comments_181476.json:
```json
{
    "body": "The old-style doctest continuation\n\n```\nsage:\n...\n```\nshould also be fixed.\n\nAlso, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).",
    "created_at": "2015-07-23T11:27:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181476",
    "user": "https://github.com/jdemeyer"
}
```

The old-style doctest continuation

```
sage:
...
```
should also be fixed.

Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).



---

archive/issue_comments_181477.json:
```json
{
    "body": "Replying to [comment:56 jdemeyer]:\n> Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).\n\n\nI wonder, too.",
    "created_at": "2015-07-23T11:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181477",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:56 jdemeyer]:
> Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).


I wonder, too.



---

archive/issue_comments_181478.json:
```json
{
    "body": "[comment:52] gives an important optimization which really should be applied. I can do it if you give me some time.",
    "created_at": "2015-07-23T11:44:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181478",
    "user": "https://github.com/jdemeyer"
}
```

[comment:52] gives an important optimization which really should be applied. I can do it if you give me some time.



---

archive/issue_comments_181479.json:
```json
{
    "body": "Replying to [comment:57 SimonKing]:\n> Replying to [comment:56 jdemeyer]:\n> > Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).\n\n> \n> I wonder, too.\n\n\nStrangely, after repeating the test, I get the opposite behaviour: A slight improvement. Perhaps I had confused the two test results?\n\nAnyway, pushing new commits shortly.",
    "created_at": "2015-07-23T11:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181479",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:57 SimonKing]:
> Replying to [comment:56 jdemeyer]:
> > Also, in `__richcmp__`, do not use magic values like `v == 2`, but use the symbolic constants `Py_EQ` and so on (but personally I would like to know why `PyObject_RichCompare` is slower).

> 
> I wonder, too.


Strangely, after repeating the test, I get the opposite behaviour: A slight improvement. Perhaps I had confused the two test results?

Anyway, pushing new commits shortly.



---

archive/issue_comments_181480.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-23T11:49:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181480",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_181481.json:
```json
{
    "body": "`__rmod__` should be removed and be folded into `__mod__`.",
    "created_at": "2015-07-23T11:57:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181481",
    "user": "https://github.com/jdemeyer"
}
```

`__rmod__` should be removed and be folded into `__mod__`.



---

archive/issue_comments_181482.json:
```json
{
    "body": "If you think that comparing two lazy strings (as opposed to comparing a lazy string and an ordinary string) is common enough, you can do something like\n\n```\n        self = self.value  # Assuming that self is indeed a _LazyString\n        if isinstance(other, _LazyString):\n            other = other.value\n        return PyObject_RichCompare(self, other, op)\n```",
    "created_at": "2015-07-23T12:05:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181482",
    "user": "https://github.com/jdemeyer"
}
```

If you think that comparing two lazy strings (as opposed to comparing a lazy string and an ordinary string) is common enough, you can do something like

```
        self = self.value  # Assuming that self is indeed a _LazyString
        if isinstance(other, _LazyString):
            other = other.value
        return PyObject_RichCompare(self, other, op)
```



---

archive/issue_comments_181483.json:
```json
{
    "body": "I have code ready for [comment:52]\n\nIf you want me to push it, just tell me.",
    "created_at": "2015-07-23T12:06:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181483",
    "user": "https://github.com/jdemeyer"
}
```

I have code ready for [comment:52]

If you want me to push it, just tell me.



---

archive/issue_comments_181484.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-07-23T13:42:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181484",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_181485.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-07-23T13:42:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181485",
    "user": "https://github.com/jdemeyer"
}
```

New commits:



---

archive/issue_comments_181486.json:
```json
{
    "body": "Jeroen, your changes look good to me.\n\nSo, Cython allows to have a cdef function and a property of the same name?\n\nAnyway, the new tests pass, so, I can positively review your changes.",
    "created_at": "2015-07-23T14:05:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181486",
    "user": "https://github.com/simon-king-jena"
}
```

Jeroen, your changes look good to me.

So, Cython allows to have a cdef function and a property of the same name?

Anyway, the new tests pass, so, I can positively review your changes.



---

archive/issue_comments_181487.json:
```json
{
    "body": "Replying to [comment:66 SimonKing]:\n> Jeroen, your changes look good to me.\n> \n> So, Cython allows to have a cdef function and a property of the same name?\n> \n> Anyway, the new tests pass, so, I can positively review your changes.",
    "created_at": "2015-07-23T15:47:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181487",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:66 SimonKing]:
> Jeroen, your changes look good to me.
> 
> So, Cython allows to have a cdef function and a property of the same name?
> 
> Anyway, the new tests pass, so, I can positively review your changes.



---

archive/issue_comments_181488.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-07-23T15:47:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181488",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_181489.json:
```json
{
    "body": "Idea for a follow-up ticket: make `__mod__` return a `LazyString` itself such that the `%` is lazily evaluated. Then we can completely merge the functionality of `LazyString` and `LazyFormat`.",
    "created_at": "2015-07-23T17:10:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181489",
    "user": "https://github.com/jdemeyer"
}
```

Idea for a follow-up ticket: make `__mod__` return a `LazyString` itself such that the `%` is lazily evaluated. Then we can completely merge the functionality of `LazyString` and `LazyFormat`.



---

archive/issue_comments_181490.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-07-27T15:16:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14381#issuecomment-181490",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_041538.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-07-27T15:16:00Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14381",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14381#event-41538"
}
```
