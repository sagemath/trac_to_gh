# Issue 18498: MixedIntegerLinearProgram: Reconstruct exact rational basic solution

Issue created by migration from https://trac.sagemath.org/ticket/18735

Original creator: mkoeppe

Original creation time: 2015-06-19 03:41:42

CC:  yzh ncohen dimpase

Keywords: lp

Sometimes one can use a fast numerical LP solver to solve a problem to "optimality", 
then reconstruct the primal and dual solution in rational arithmetic (or over whatever base_ring was used...) and in this way prove that this basis is indeed optimal. 
MixedIntegerLinearProgram should support this mode of operation.

#18685 provides the necessary basis-status functions (for the GLPK backend).
#18688 provides a solver-independent interface to these functions.


---

Comment by dimpase created at 2015-06-20 06:33:32

Is `ppl` (`ppl`LP backend, which works with exact arithmetic) too slow for you?


---

Comment by dimpase created at 2015-06-20 06:42:15

On the other hand, a solver-independent way to get an optimal dual solution is very much welcome, as this is lacking currently, and often needed.


---

Comment by mkoeppe created at 2015-06-22 21:46:52

Replying to [comment:2 dimpase]:
> Is `ppl` (`ppl`LP backend, which works with exact arithmetic) too slow for you?

Dima, ppl's implementation of the double description method is very good, but its LP solver is not suitable for problems of even moderate sizes.


---

Comment by dimpase created at 2015-06-23 08:19:41

Replying to [comment:5 mkoeppe]:
> Replying to [comment:2 dimpase]:
> > Is `ppl` (`ppl`LP backend, which works with exact arithmetic) too slow for you?
> 
> Dima, ppl's implementation of the double description method is very good, but its LP solver is not suitable for problems of even moderate sizes.

Would you mind providing an example of PPL choking on an LP doable in exact arithmetic by another solver? We use PPL's LP solver in  `codesize_upper_bound(...,algorithm="LP")` and never saw a problem... (Although perhaps the difficulty from entry sizes dominate the the one from the dimension in this case).


---

Comment by mkoeppe created at 2015-06-26 21:41:17

Replying to [comment:6 dimpase]:
> Would you mind providing an example of PPL choking on an LP doable in exact arithmetic by another solver? We use PPL's LP solver in  `codesize_upper_bound(...,algorithm="LP")` and never saw a problem... (Although perhaps the difficulty from entry sizes dominate the the one from the dimension in this case).

In our experiments here, we don't actually have numerical difficulties with floating-point based solvers; we just want to be sure that we have an exact optimal solution. With #18764 (glp_exact; please review) we have now run some tests to compare performance:


```
                                glp_simplex                glp_simplex+glp_exact
   glp_simplex    glp_exact     +glp_exact    ppl          + reconstruction in Sage
10  4.20            51.92             7.78    207.07          289.00
11  5.08            58.49             9.43    3451.42         574.72
12  7.55           101.72            11.32    1252.91         808.73
13  7.21           279.08            13.57    1424.28        1019.95
14  8.41           562.97            15.91    7343.37        1628.54
15 13.10           550.46            18.48    3667.93        2550.94
```


As you can see, PPL is much slower than pure glp_exact, and orders of magnitudes slower than glp_simplex followed by glp_exact.

However, currently when we try to reconstruct the solution from the combinatorial basis information, Sage's super slow matrix functions over the rationals get us back to roughly the same order of magnitude as PPL.

It would be interesting to know how the solvers perform on the kind of LPs that you have in mind.


---

Comment by dimpase created at 2015-06-29 10:39:48

Replying to [comment:7 mkoeppe]:

> It would be interesting to know how the solvers perform on the kind of LPs that you have in mind.

LPs I get would be not possible to even enter into a solver without long integers/rationals.
That's e.g. behind this function call:

```
sage:  codesize_upper_bound(70,8,2,algorithm="LP")
9695943911863423
```

more explicitly, you can do

```
sage: v,p,r=delsarte_bound_hamming_space(70,8,2,return_data=True)
sage: p
Mixed Integer Program  ( maximization, 71 variables, 148 constraints )
```

constrains of `p` have entries as big as  112186277816662845432.


---

Comment by mkoeppe created at 2016-04-06 03:23:49

Last 10 new commits:


---

Comment by git created at 2016-08-10 18:58:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2021-01-30 01:25:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-30 01:46:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-31 09:03:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-31 12:42:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-03 05:01:33

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by yzh created at 2021-02-03 05:02:26

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2021-02-03 05:30:01

I don't like the changes to `src/sage/numerical/interactive_simplex_method.py` too much. 

Instead of extending `InteractiveLPProblemStandardForm.run_revised_simplex_method`, I think it's better to use the "run_simplex_method" method of the current_dictionary (a revised dictionary) directly.

Same amount of code, but would avoid making `interactive_simplex_method` more complicated.


---

Comment by git created at 2021-02-03 06:19:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2021-02-03 06:20:07

Replying to [comment:25 mkoeppe]:
> I don't like the changes to `src/sage/numerical/interactive_simplex_method.py` too much. 
> 
> Instead of extending `InteractiveLPProblemStandardForm.run_revised_simplex_method`, I think it's better to use the "run_simplex_method" method of the current_dictionary (a revised dictionary) directly.
> 
> Same amount of code, but would avoid making `interactive_simplex_method` more complicated. 

Good idea. Done.


---

Comment by mkoeppe created at 2021-02-04 03:31:39

Also, I think it would be better to avoid changing the `solve` interface:

```
-    cpdef int solve(self) except -1:
+    cpdef int solve(self,  basic_variables=[]) except -1:
```

Setting an initial basis could be done in a new method perhaps called `warmstart(basic_variables)` or `set_basis(basic_variables)`


---

Comment by mkoeppe created at 2021-02-04 03:37:02

And note that generic backend already defines getter methods for the basis status `is_variable_basic`, `is_variable_nonbasic_at_lower_bound`, `is_slack_variable_basic`, `is_slack_variable_nonbasic_at_lower_bound` - all of which use variable/row indices.

So this interface:

```
+            ``basic_variables`` can be one of the following:
+
+            - a list of indices. The indices (starting at 1) correspond to that of the vector formed by `self.interactive_lp_problem().decision_variables()` and `self.interactive_lp_problem().slack_variables()`. Remark that `self.interactive_lp_problem()` can have more variables and constraints than that of `self` if `self` has free variables or `==` constraints.
+
+            - a list of the names of the variables in `self.interactive_lp_problem()`.
```

looks a bit out of place.


---

Comment by yzh created at 2021-02-04 20:56:38

What would be a better input form? Remove the second option and take only a list of indices? 

It is tricky because the indices here correspond to the variables in the `interactive_lp_problem().standard_form()`, and they not necessarily the same as the indices for `is_variable_basic` etc. which correspond to `interactive_lp_problem()`. See the following example.

```
from sage.numerical.backends.generic_backend import get_solver
h = get_solver(solver = ("InteractiveLP"))
h.add_variables(1, lower_bound=None, upper_bound=None);
h.add_variables(1, lower_bound=0, upper_bound=None);
h.add_linear_constraint([(0,2),(1,-1)],-1,None)
h.add_linear_constraint([(0,1),(1,-1)],None, 1)
h.add_linear_constraint([(0,1),(1,1)],2,2)
h.set_objective([0,-1])
lp = h.interactive_lp_problem(); view(lp)
st = lp.standard_form(); view(st)
R = st.coordinate_ring(); R
```

Replying to [comment:29 mkoeppe]:
> And note that generic backend already defines getter methods for the basis status `is_variable_basic`, `is_variable_nonbasic_at_lower_bound`, `is_slack_variable_basic`, `is_slack_variable_nonbasic_at_lower_bound` - all of which use variable/row indices.
> 
> So this interface:
> {{{
> +            ``basic_variables`` can be one of the following:
> +
> +            - a list of indices. The indices (starting at 1) correspond to that of the vector formed by `self.interactive_lp_problem().decision_variables()` and `self.interactive_lp_problem().slack_variables()`. Remark that `self.interactive_lp_problem()` can have more variables and constraints than that of `self` if `self` has free variables or `==` constraints.
> +
> +            - a list of the names of the variables in `self.interactive_lp_problem()`.
> }}}
> looks a bit out of place.


---

Comment by mkoeppe created at 2021-02-05 21:35:26

Changing status from needs_review to needs_work.


---

Comment by git created at 2021-02-08 03:16:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2021-02-08 03:26:13

Changing status from needs_work to needs_review.


---

Comment by yzh created at 2021-02-08 03:26:13

Replying to [comment:28 mkoeppe]:
> Also, I think it would be better to avoid changing the `solve` interface:
> {{{
> -    cpdef int solve(self) except -1:
> +    cpdef int solve(self,  basic_variables=[]) except -1:
> }}}
> Setting an initial basis could be done in a new method perhaps called `warmstart(basic_variables)` or `set_basis(basic_variables)`
> 
> 

InteractiveLPBackend now has a new method `set_dictionary` and a new attribute `current_dictionary`. I didn't name it `set_basis`, to avoid confusion between the basic variables in a dictionary and those of the generic backend.


---

Comment by mkoeppe created at 2021-02-08 04:39:27

I still have concerns about the new interface as well. The problem now is that `set_basis` is not defined for any backend other than `InteractiveLPBackend` (and also its interface refers to internal details of that).

But more importantly, there should be at least one example that illustrates that this new backend does something useful.


---

Comment by yzh created at 2021-02-08 05:27:41

Replying to [comment:34 mkoeppe]:
> I still have concerns about the new interface as well. The problem now is that `set_basis` is not defined for any backend other than `InteractiveLPBackend` (and also its interface refers to internal details of that).

Do you mean `set_dictionary`? It has a different interface than `set_basis` (in #18688 to be written) since the `interactive_simplex_method` is indeed very special in running the simplex method on the standard form where more auxiliary variables are introduced. I couldn't think of a way to unify `InteractiveLPBackend.set_dictionary` with other backends' set basis methods.

> But more importantly, there should be at least one example that illustrates that this new backend does something useful.

True. The current implementation enables what the first paragraph of this ticket states, by using `solver = ("GLPK", "InteractiveLP")` as in the examples in `solve`. However, it is hard to argue with doctests that this new hybrid backend is useful. Shall we close the ticket with the tag "wontfix" as in #18804?


---

Comment by mkoeppe created at 2021-02-08 05:28:37

Replying to [comment:35 yzh]:
> Replying to [comment:34 mkoeppe]:
> > I still have concerns about the new interface as well. The problem now is that `set_basis` is not defined for any backend other than `InteractiveLPBackend` (and also its interface refers to internal details of that).
> 
> Do you mean `set_dictionary`?

Yes, that's what I meant.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by git created at 2021-03-28 18:10:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by dimpase created at 2021-12-04 17:23:11

please rebase


---

Comment by dimpase created at 2021-12-04 17:23:38

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-04-11 05:19:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-04-11 06:18:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-04-11 07:29:32

Branch pushed to git repo; I updated commit sha1. New commits:
