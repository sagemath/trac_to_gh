# Issue 25744: SafeSortable wrapper for ordering heterogeneous types on Python 3

archive/issues_025744.json:
```json
{
    "body": "CC:  jdemeyer chapoton\n\nThere are several problems on Python 3 involving ordering elements of heterogeneous collections, particularly in objects such as sets and graphs.\n\nThis issue has already come up several times in the Python 3 port usually with some ad-hoc fix.  For sorting, sometimes it's straightforward to come up with a reasonable sort key.  Other times it's not obvious, or leads to ugly code (lots of try/excepts, etc.)\n\nOne possibility I've brought up before is inspired by the `pprint` implementation on Python 3:  `pprint` by default orders the output of collections such as dicts and sets.  On Python 3 they had to deal with this issue of arbitrary types no longer being ordered, so `pprint` has an internal helper called `_safe_key` on which this `SafeSortable` class is inspired, which serves as a wrapper around objects giving them Python 2-style sorting semantics.\n\nThis is just a proof-of-concept, and I think there are various issues to work out:\n\n1. Performance comparison, especially on Python 2.  Adding `key=SafeSortable` to sorts is unnecessary on Python 2 and probably only needlessly slows things down, though I'm not sure by how much.  This could also be avoided by building a Python 2 exception into the `SafeSortable.sort` helper method, and/or possibly making `type(SafeSortable).__call__` effectively a no-op.\n\n2. Performance improvements on Python 3.  Even on Python 3 we can probably speed this up a lot, in particular by pooling `SafeSortable` instances similarly to what we do for `Integer`s.\n\n3. Do we want to make the interface more flexible?  For example, do we always want Python 2 sorting semantics?  Would it also be useful to provide an optional custom fallback for two types that can't be compared naturally?\n\n4. What about comparing compound objects, specifically tuples?  Do we want an API for applying `SafeSortable` recursively to the elements of tuples?  And what about other comparing other heterogeneous collections such as lists?  I think this would *probably* be useful (e.g. sorting key/value pairs from a dict), but I haven't settled on the API for that.\n\nIssue created by migration from https://trac.sagemath.org/ticket/25981\n\n",
    "created_at": "2018-07-31T13:33:21Z",
    "labels": [
        "python3",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "SafeSortable wrapper for ordering heterogeneous types on Python 3",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25744",
    "user": "embray"
}
```
CC:  jdemeyer chapoton

There are several problems on Python 3 involving ordering elements of heterogeneous collections, particularly in objects such as sets and graphs.

This issue has already come up several times in the Python 3 port usually with some ad-hoc fix.  For sorting, sometimes it's straightforward to come up with a reasonable sort key.  Other times it's not obvious, or leads to ugly code (lots of try/excepts, etc.)

One possibility I've brought up before is inspired by the `pprint` implementation on Python 3:  `pprint` by default orders the output of collections such as dicts and sets.  On Python 3 they had to deal with this issue of arbitrary types no longer being ordered, so `pprint` has an internal helper called `_safe_key` on which this `SafeSortable` class is inspired, which serves as a wrapper around objects giving them Python 2-style sorting semantics.

This is just a proof-of-concept, and I think there are various issues to work out:

1. Performance comparison, especially on Python 2.  Adding `key=SafeSortable` to sorts is unnecessary on Python 2 and probably only needlessly slows things down, though I'm not sure by how much.  This could also be avoided by building a Python 2 exception into the `SafeSortable.sort` helper method, and/or possibly making `type(SafeSortable).__call__` effectively a no-op.

2. Performance improvements on Python 3.  Even on Python 3 we can probably speed this up a lot, in particular by pooling `SafeSortable` instances similarly to what we do for `Integer`s.

3. Do we want to make the interface more flexible?  For example, do we always want Python 2 sorting semantics?  Would it also be useful to provide an optional custom fallback for two types that can't be compared naturally?

4. What about comparing compound objects, specifically tuples?  Do we want an API for applying `SafeSortable` recursively to the elements of tuples?  And what about other comparing other heterogeneous collections such as lists?  I think this would *probably* be useful (e.g. sorting key/value pairs from a dict), but I haven't settled on the API for that.

Issue created by migration from https://trac.sagemath.org/ticket/25981





---

archive/issue_comments_363234.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-09-07T12:22:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363234",
    "user": "embray"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_363235.json:
```json
{
    "body": "On sage-devel the idea was raise of sorting  otherwise unordered objects also based on their hash (as opposed to their id).  This might be a nice semantic to add, where possible, since it will lead to a more deterministic (at within a given platform) sort.",
    "created_at": "2018-09-07T12:24:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363235",
    "user": "embray"
}
```

On sage-devel the idea was raise of sorting  otherwise unordered objects also based on their hash (as opposed to their id).  This might be a nice semantic to add, where possible, since it will lead to a more deterministic (at within a given platform) sort.



---

archive/issue_comments_363236.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-12-13T17:17:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363236",
    "user": "zerline"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_363237.json:
```json
{
    "body": "This obviously is a useful change.\n\nPython2 compatibility is a wise behavior.\n\nI only deplore that we need to import a new module, even a small one ..",
    "created_at": "2018-12-13T17:17:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363237",
    "user": "zerline"
}
```

This obviously is a useful change.

Python2 compatibility is a wise behavior.

I only deplore that we need to import a new module, even a small one ..



---

archive/issue_comments_363238.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2018-12-14T00:16:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363238",
    "user": "jhpalmieri"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_363239.json:
```json
{
    "body": "Documentation doesn't build. I don't have time to prepare a proper branch, but I think this will fix it:\n\n```diff\ndiff --git a/src/sage/structure/misc.pyx b/src/sage/structure/misc.pyx\nindex c7e9808279..459dd4f244 100644\n--- a/src/sage/structure/misc.pyx\n+++ b/src/sage/structure/misc.pyx\n@@ -8,13 +8,14 @@ cdef class SafeSortable:\n     Wrapper for arbitrary objects allowing them to always be ordered in the\n     manner of Python 2.x objects.\n \n-    When comparing a `SafeSortable` to another `SafeSortable`, it first\n+    When comparing a ``SafeSortable`` to another ``SafeSortable``, it first\n     attempts comparing their wrapped objects using the standard ``__lt__``\n     comparison.  If that fails, it falls back to comparing them by their type\n     name, then by their id, which is consistent with what Python 2.x does with\n     a pair of otherwise unorderable types.\n \n-    `SafeSortable`s may only be compared with other `SafeSortable`s.\n+    ``SafeSortable`` objects may only be compared with other\n+    ``SafeSortable`` objects.\n \n     EXAMPLES::\n \n```\n",
    "created_at": "2018-12-14T00:16:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363239",
    "user": "jhpalmieri"
}
```

Documentation doesn't build. I don't have time to prepare a proper branch, but I think this will fix it:

```diff
diff --git a/src/sage/structure/misc.pyx b/src/sage/structure/misc.pyx
index c7e9808279..459dd4f244 100644
--- a/src/sage/structure/misc.pyx
+++ b/src/sage/structure/misc.pyx
@@ -8,13 +8,14 @@ cdef class SafeSortable:
     Wrapper for arbitrary objects allowing them to always be ordered in the
     manner of Python 2.x objects.
 
-    When comparing a `SafeSortable` to another `SafeSortable`, it first
+    When comparing a ``SafeSortable`` to another ``SafeSortable``, it first
     attempts comparing their wrapped objects using the standard ``__lt__``
     comparison.  If that fails, it falls back to comparing them by their type
     name, then by their id, which is consistent with what Python 2.x does with
     a pair of otherwise unorderable types.
 
-    `SafeSortable`s may only be compared with other `SafeSortable`s.
+    ``SafeSortable`` objects may only be compared with other
+    ``SafeSortable`` objects.
 
     EXAMPLES::
 
```




---

archive/issue_comments_363240.json:
```json
{
    "body": "Replying to [comment:5 zerline]:\n> I only deplore that we need to import a new module, even a small one .. \n\nThat isn't really a problem though...  I'm not sure why you think it is.  Are you saying it's a problem for the module to be imported *at all* (because `sage.structure.misc` is already used in `sage.structure.parent` for some utilities)?  Or just the fact that it means adding an import statement to places where it's used?  I'm not sure how else you expect to use utilities defined in other modules.  The only alternative is shoving them into globals and that's not how Sage (or any large Python package) is developed internally.  It's only for the REPL interface that we import a bunch of stuff into the global namespace for the convenience of *user*-level code.",
    "created_at": "2018-12-14T11:15:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363240",
    "user": "embray"
}
```

Replying to [comment:5 zerline]:
> I only deplore that we need to import a new module, even a small one .. 

That isn't really a problem though...  I'm not sure why you think it is.  Are you saying it's a problem for the module to be imported *at all* (because `sage.structure.misc` is already used in `sage.structure.parent` for some utilities)?  Or just the fact that it means adding an import statement to places where it's used?  I'm not sure how else you expect to use utilities defined in other modules.  The only alternative is shoving them into globals and that's not how Sage (or any large Python package) is developed internally.  It's only for the REPL interface that we import a bunch of stuff into the global namespace for the convenience of *user*-level code.



---

archive/issue_comments_363241.json:
```json
{
    "body": "Replying to [comment:6 jhpalmieri]:\n> Documentation doesn't build. I don't have time to prepare a proper branch, but I think this will fix it:\n\nI'm not sure why just ``SafeSortable`` wouldn't work.  Normally Sphinx is good about generating links to objects defined in the module being documented without, for example, writing out the fully-qualified name like `:class:`~sage.structure.misc.SafeSortable``.  Is there a known problem with that in Cython modules?",
    "created_at": "2018-12-14T11:17:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363241",
    "user": "embray"
}
```

Replying to [comment:6 jhpalmieri]:
> Documentation doesn't build. I don't have time to prepare a proper branch, but I think this will fix it:

I'm not sure why just ``SafeSortable`` wouldn't work.  Normally Sphinx is good about generating links to objects defined in the module being documented without, for example, writing out the fully-qualified name like `:class:`~sage.structure.misc.SafeSortable``.  Is there a known problem with that in Cython modules?



---

archive/issue_comments_363242.json:
```json
{
    "body": "I see--for some reason I never quite got it through my head that the default role throughout Sage's documentation is `:math:`, and not the normal default in Sphinx for Python projects which is `:py:obj:`.  I suppose that makes a certain sense.  So at the very least `:class:`SafeSortable`` is needed to make a proper cross-reference.",
    "created_at": "2018-12-14T11:23:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363242",
    "user": "embray"
}
```

I see--for some reason I never quite got it through my head that the default role throughout Sage's documentation is `:math:`, and not the normal default in Sphinx for Python projects which is `:py:obj:`.  I suppose that makes a certain sense.  So at the very least `:class:`SafeSortable`` is needed to make a proper cross-reference.



---

archive/issue_comments_363243.json:
```json
{
    "body": "``SafeSortable`` doesn't cause failures to build, just typesetting in math mode as you note, so that proposed change is cosmetic. The failures come from ```SafeSortable``s`: the second ```` is not recognized by Sphinx as ending a literal block: I'm guessing that Sphinx wants ```` to either be preceded by or followed by a space.\n\nBy the way, I also see a doctest failure:\n\n```\nRunning doctests with ID 2018-12-14-08-47-08-3b058240.\nGit branch: t/25981/misc/safe-sortable\nUsing --optional=dochtml,mpir,python2,sage\nDoctesting 1 file.\nsage -t --warn-long 51.0 src/sage/structure/misc.pyx\n**********************************************************************\nFile \"src/sage/structure/misc.pyx\", line 74, in sage.structure.misc.SafeSortable.lt\nFailed example:\n    SafeSortable.lt(1, 'a')\nExpected:\n    True\nGot:\n    False\n**********************************************************************\n1 item had failures:\n   1 of   3 in sage.structure.misc.SafeSortable.lt\n    [17 tests, 1 failure, 0.01 s]\n----------------------------------------------------------------------\nsage -t --warn-long 51.0 src/sage/structure/misc.pyx  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.0 seconds\n    cpu time: 0.0 seconds\n```\n",
    "created_at": "2018-12-14T16:51:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363243",
    "user": "jhpalmieri"
}
```

``SafeSortable`` doesn't cause failures to build, just typesetting in math mode as you note, so that proposed change is cosmetic. The failures come from ```SafeSortable``s`: the second ```` is not recognized by Sphinx as ending a literal block: I'm guessing that Sphinx wants ```` to either be preceded by or followed by a space.

By the way, I also see a doctest failure:

```
Running doctests with ID 2018-12-14-08-47-08-3b058240.
Git branch: t/25981/misc/safe-sortable
Using --optional=dochtml,mpir,python2,sage
Doctesting 1 file.
sage -t --warn-long 51.0 src/sage/structure/misc.pyx
**********************************************************************
File "src/sage/structure/misc.pyx", line 74, in sage.structure.misc.SafeSortable.lt
Failed example:
    SafeSortable.lt(1, 'a')
Expected:
    True
Got:
    False
**********************************************************************
1 item had failures:
   1 of   3 in sage.structure.misc.SafeSortable.lt
    [17 tests, 1 failure, 0.01 s]
----------------------------------------------------------------------
sage -t --warn-long 51.0 src/sage/structure/misc.pyx  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.0 seconds
    cpu time: 0.0 seconds
```




---

archive/issue_comments_363244.json:
```json
{
    "body": "If you want to create the cross-references, you can use this change instead of my previous suggestion:\n\n```diff\ndiff --git a/src/sage/structure/misc.pyx b/src/sage/structure/misc.pyx\nindex c7e9808279..8217005fa6 100644\n--- a/src/sage/structure/misc.pyx\n+++ b/src/sage/structure/misc.pyx\n@@ -8,13 +8,14 @@ cdef class SafeSortable:\n     Wrapper for arbitrary objects allowing them to always be ordered in the\n     manner of Python 2.x objects.\n \n-    When comparing a `SafeSortable` to another `SafeSortable`, it first\n+    When comparing a :class:`SafeSortable` to another :class:`SafeSortable`, it first\n     attempts comparing their wrapped objects using the standard ``__lt__``\n     comparison.  If that fails, it falls back to comparing them by their type\n     name, then by their id, which is consistent with what Python 2.x does with\n     a pair of otherwise unorderable types.\n \n-    `SafeSortable`s may only be compared with other `SafeSortable`s.\n+    :class:`SafeSortable` objects may only be compared with other\n+    :class:`SafeSortable` objects.\n \n     EXAMPLES::\n \n```\n",
    "created_at": "2018-12-14T17:00:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363244",
    "user": "jhpalmieri"
}
```

If you want to create the cross-references, you can use this change instead of my previous suggestion:

```diff
diff --git a/src/sage/structure/misc.pyx b/src/sage/structure/misc.pyx
index c7e9808279..8217005fa6 100644
--- a/src/sage/structure/misc.pyx
+++ b/src/sage/structure/misc.pyx
@@ -8,13 +8,14 @@ cdef class SafeSortable:
     Wrapper for arbitrary objects allowing them to always be ordered in the
     manner of Python 2.x objects.
 
-    When comparing a `SafeSortable` to another `SafeSortable`, it first
+    When comparing a :class:`SafeSortable` to another :class:`SafeSortable`, it first
     attempts comparing their wrapped objects using the standard ``__lt__``
     comparison.  If that fails, it falls back to comparing them by their type
     name, then by their id, which is consistent with what Python 2.x does with
     a pair of otherwise unorderable types.
 
-    `SafeSortable`s may only be compared with other `SafeSortable`s.
+    :class:`SafeSortable` objects may only be compared with other
+    :class:`SafeSortable` objects.
 
     EXAMPLES::
 
```




---

archive/issue_comments_363245.json:
```json
{
    "body": "Regarding the doctest failure, I get\n\n```\nsage: 1 < 'a'\nFalse\nsage: int(1) < 'a'\nTrue\n```\n\nDid you mean to use `int(1)` instead of 1?",
    "created_at": "2018-12-14T17:04:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363245",
    "user": "jhpalmieri"
}
```

Regarding the doctest failure, I get

```
sage: 1 < 'a'
False
sage: int(1) < 'a'
True
```

Did you mean to use `int(1)` instead of 1?



---

archive/issue_comments_363246.json:
```json
{
    "body": "`@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?",
    "created_at": "2018-12-14T17:06:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363246",
    "user": "jhpalmieri"
}
```

`@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?



---

archive/issue_comments_363247.json:
```json
{
    "body": "It's not really clear to me what the use case of this `SafeSortable` would be. It seems to me that we should just avoid to compare uncomparable objects instead of making uncomparable objects comparable anyway.",
    "created_at": "2018-12-19T15:17:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363247",
    "user": "jdemeyer"
}
```

It's not really clear to me what the use case of this `SafeSortable` would be. It seems to me that we should just avoid to compare uncomparable objects instead of making uncomparable objects comparable anyway.



---

archive/issue_comments_363248.json:
```json
{
    "body": "Replying to [comment:13 jhpalmieri]:\n> `@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?\n\nThey gave it a positive review based on its merits, which most people do, without necessarily catching every minute issue (this is what we have patchbots for, supposedly).  They aren't as familiar as you are with these nitpicks and it's not a big deal.",
    "created_at": "2018-12-20T08:40:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363248",
    "user": "embray"
}
```

Replying to [comment:13 jhpalmieri]:
> `@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?

They gave it a positive review based on its merits, which most people do, without necessarily catching every minute issue (this is what we have patchbots for, supposedly).  They aren't as familiar as you are with these nitpicks and it's not a big deal.



---

archive/issue_comments_363249.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> It's not really clear to me what the use case of this `SafeSortable` would be. It seems to me that we should just avoid to compare uncomparable objects instead of making uncomparable objects comparable anyway.\n\nMy python3 branch is replete with examples of its use.  I can add more if you don't believe me.  It fixes a good many issues where lists of mixed-type objects are being sorted, and there are plenty of cases like that which are valid.  One of the common examples is ordering lists of edge labels which can be strings or ints, but there are plenty of other examples.  \n\nThere are dozens of bugs that I've delayed fixing for months on end due to not having a utility like this.  I'm just going to fix the fussy documentation issue and set this back to positive review.",
    "created_at": "2018-12-20T08:42:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363249",
    "user": "embray"
}
```

Replying to [comment:14 jdemeyer]:
> It's not really clear to me what the use case of this `SafeSortable` would be. It seems to me that we should just avoid to compare uncomparable objects instead of making uncomparable objects comparable anyway.

My python3 branch is replete with examples of its use.  I can add more if you don't believe me.  It fixes a good many issues where lists of mixed-type objects are being sorted, and there are plenty of cases like that which are valid.  One of the common examples is ordering lists of edge labels which can be strings or ints, but there are plenty of other examples.  

There are dozens of bugs that I've delayed fixing for months on end due to not having a utility like this.  I'm just going to fix the fussy documentation issue and set this back to positive review.



---

archive/issue_comments_363250.json:
```json
{
    "body": "Replying to [comment:12 jhpalmieri]:\n> Regarding the doctest failure, I get\n> {{{\n> sage: 1 < 'a'\n> False\n> sage: int(1) < 'a'\n> True\n> }}}\n> Did you mean to use `int(1)` instead of 1?\n\nI get\n\n\n```\nsage: 1 < 'a'\nTrue\n```\n\n\nInitially I wasn't sure why you would get False here, since the default Python 2 comparison actually sorts instances of numeric types (which I believe Sage's `Integer` is for this purpose), so both `Integer(1)` and `int(1)` should come before `'a'` and I'm not sure how you'd get any other result.  However, it turns out that `Integer.__richcmp__` given a RHS that is not obviously comparable to an int will fall back on the coercion model, which itself in this case has a default [richcmp implementation](https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage/structure/coerce.pyx?id=0e992df0fc4641339f9eb465252486ef88a56ebb#n1895) that as a last resort compares the two elements just by their ids, and that's what's happening in the case of comparing an `Integer` to a `str`.  This default comparison is rather unfortunate since it's rather non-deterministic.\n\nI'm not sure what the best thing would be to do about this.  I'm tempted to take the Python 3 approach and remove this fallback nonsense comparison in favor of raising a `TypeError` if two objects don't have a sensible comparison implemented.",
    "created_at": "2018-12-20T10:21:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363250",
    "user": "embray"
}
```

Replying to [comment:12 jhpalmieri]:
> Regarding the doctest failure, I get
> {{{
> sage: 1 < 'a'
> False
> sage: int(1) < 'a'
> True
> }}}
> Did you mean to use `int(1)` instead of 1?

I get


```
sage: 1 < 'a'
True
```


Initially I wasn't sure why you would get False here, since the default Python 2 comparison actually sorts instances of numeric types (which I believe Sage's `Integer` is for this purpose), so both `Integer(1)` and `int(1)` should come before `'a'` and I'm not sure how you'd get any other result.  However, it turns out that `Integer.__richcmp__` given a RHS that is not obviously comparable to an int will fall back on the coercion model, which itself in this case has a default [richcmp implementation](https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage/structure/coerce.pyx?id=0e992df0fc4641339f9eb465252486ef88a56ebb#n1895) that as a last resort compares the two elements just by their ids, and that's what's happening in the case of comparing an `Integer` to a `str`.  This default comparison is rather unfortunate since it's rather non-deterministic.

I'm not sure what the best thing would be to do about this.  I'm tempted to take the Python 3 approach and remove this fallback nonsense comparison in favor of raising a `TypeError` if two objects don't have a sensible comparison implemented.



---

archive/issue_comments_363251.json:
```json
{
    "body": "One other thing no one has pointed out though is that the \"Python 2 style comparison\" implemented here isn't actually quite correct.  I took the implementation from Python's [pprint](https://github.com/python/cpython/blob/1fb312ce1f147ea84ecb6f5993a20d1a85c53dc3/Lib/pprint.py#L72) module which implements a similar utility, but in pure Python, and not public API (as I explained in the ticket description).  However, it turns out the actual default comparison is a little more complex: https://github.com/python/cpython/blob/3752bc96c0ea1ecf28903cc34cdcd75c658e92ce/Objects/object.c#L767\n\nI think I may update this to something a bit closer to that.  It has the advantage of being deterministic, whereas the current implementation still relies on instance ids which is not ideal.",
    "created_at": "2018-12-20T10:23:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363251",
    "user": "embray"
}
```

One other thing no one has pointed out though is that the "Python 2 style comparison" implemented here isn't actually quite correct.  I took the implementation from Python's [pprint](https://github.com/python/cpython/blob/1fb312ce1f147ea84ecb6f5993a20d1a85c53dc3/Lib/pprint.py#L72) module which implements a similar utility, but in pure Python, and not public API (as I explained in the ticket description).  However, it turns out the actual default comparison is a little more complex: https://github.com/python/cpython/blob/3752bc96c0ea1ecf28903cc34cdcd75c658e92ce/Objects/object.c#L767

I think I may update this to something a bit closer to that.  It has the advantage of being deterministic, whereas the current implementation still relies on instance ids which is not ideal.



---

archive/issue_comments_363252.json:
```json
{
    "body": "Replying to [comment:15 embray]:\n> Replying to [comment:13 jhpalmieri]:\n> > `@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?\n> \n> They gave it a positive review based on its merits, which most people do, without necessarily catching every minute issue (this is what we have patchbots for, supposedly).  They aren't as familiar as you are with these nitpicks and it's not a big deal.\n\nThere is (at least) one thing the patchbots won't do: look at the built documentation to make sure it looks okay, doesn't use ``code`` instead of ```code``` or other reST errors which won't stop the build but will make the output look bad. This should actually be on [the reviewer's checklist](http://doc.sagemath.org/html/en/developer/reviewer_checklist.html#chapter-review): look at the documentation. If reviewers don't look at the built documentation, it is likely that the quality of the documentation will decrease over time because these errors won't get caught. I'd prefer that this did not happen.\n\nThe doctest may be system dependent. In unpatched Sage running Python 2, `1 < 'a'` returns `False` on several OS X machines.",
    "created_at": "2018-12-20T16:03:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363252",
    "user": "jhpalmieri"
}
```

Replying to [comment:15 embray]:
> Replying to [comment:13 jhpalmieri]:
> > `@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?
> 
> They gave it a positive review based on its merits, which most people do, without necessarily catching every minute issue (this is what we have patchbots for, supposedly).  They aren't as familiar as you are with these nitpicks and it's not a big deal.

There is (at least) one thing the patchbots won't do: look at the built documentation to make sure it looks okay, doesn't use ``code`` instead of ```code``` or other reST errors which won't stop the build but will make the output look bad. This should actually be on [the reviewer's checklist](http://doc.sagemath.org/html/en/developer/reviewer_checklist.html#chapter-review): look at the documentation. If reviewers don't look at the built documentation, it is likely that the quality of the documentation will decrease over time because these errors won't get caught. I'd prefer that this did not happen.

The doctest may be system dependent. In unpatched Sage running Python 2, `1 < 'a'` returns `False` on several OS X machines.



---

archive/issue_comments_363253.json:
```json
{
    "body": "Replying to [comment:19 jhpalmieri]:\n> This should actually be on [the reviewer's checklist](http://doc.sagemath.org/html/en/developer/reviewer_checklist.html#chapter-review): look at the documentation.\n\nSee #26926.",
    "created_at": "2018-12-20T16:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363253",
    "user": "jhpalmieri"
}
```

Replying to [comment:19 jhpalmieri]:
> This should actually be on [the reviewer's checklist](http://doc.sagemath.org/html/en/developer/reviewer_checklist.html#chapter-review): look at the documentation.

See #26926.



---

archive/issue_comments_363254.json:
```json
{
    "body": "First a minor comment about the code: in comparison methods, you don't need to check the type of the first argument: it's `self` (and should be called `self` by PEP 8) and you know that it has the right class. Cython knows it too, so you don't need a `<SafeSortable>` cast.",
    "created_at": "2018-12-23T15:05:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363254",
    "user": "jdemeyer"
}
```

First a minor comment about the code: in comparison methods, you don't need to check the type of the first argument: it's `self` (and should be called `self` by PEP 8) and you know that it has the right class. Cython knows it too, so you don't need a `<SafeSortable>` cast.



---

archive/issue_comments_363255.json:
```json
{
    "body": "Now about using `SafeSortable`: I'm not convinced that it actually makes sense. If you just want to sort something for the user's convenience and nothing really depends on it, then it's fine: in the best case, it helps and in the worst case, you won't break anything.\n\nBut I wouldn't use `SafeSortable` for anything where the order really matters for an algorithm: the `try`/`except` style means that it's non-transitive (in that sense, it's worse than simply using `str` as sorting key).\n\nFalling back on things like `type()` and `id()` is also trying to force Python 2 sorting semantics in Python 3. I'm not sure that this is the right thing to do.",
    "created_at": "2018-12-23T15:13:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363255",
    "user": "jdemeyer"
}
```

Now about using `SafeSortable`: I'm not convinced that it actually makes sense. If you just want to sort something for the user's convenience and nothing really depends on it, then it's fine: in the best case, it helps and in the worst case, you won't break anything.

But I wouldn't use `SafeSortable` for anything where the order really matters for an algorithm: the `try`/`except` style means that it's non-transitive (in that sense, it's worse than simply using `str` as sorting key).

Falling back on things like `type()` and `id()` is also trying to force Python 2 sorting semantics in Python 3. I'm not sure that this is the right thing to do.



---

archive/issue_comments_363256.json:
```json
{
    "body": "Retargeting some of my tickets (somewhat optimistically for now).",
    "created_at": "2018-12-28T14:10:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363256",
    "user": "embray"
}
```

Retargeting some of my tickets (somewhat optimistically for now).



---

archive/issue_comments_363257.json:
```json
{
    "body": "Replying to [comment:19 jhpalmieri]:\n> The doctest may be system dependent. In unpatched Sage running Python 2, `1 < 'a'` returns `False` on several OS X machines.\n\nI already explained that it is, as well as the exact reason.",
    "created_at": "2018-12-31T12:57:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363257",
    "user": "embray"
}
```

Replying to [comment:19 jhpalmieri]:
> The doctest may be system dependent. In unpatched Sage running Python 2, `1 < 'a'` returns `False` on several OS X machines.

I already explained that it is, as well as the exact reason.



---

archive/issue_comments_363258.json:
```json
{
    "body": "Replying to [comment:17 embray]:\n> I'm tempted to take the Python 3 approach and remove this fallback nonsense comparison in favor of raising a `TypeError` if two objects don't have a sensible comparison implemented.\n\nThis is exactly what #22029 does.",
    "created_at": "2019-01-08T15:55:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363258",
    "user": "jdemeyer"
}
```

Replying to [comment:17 embray]:
> I'm tempted to take the Python 3 approach and remove this fallback nonsense comparison in favor of raising a `TypeError` if two objects don't have a sensible comparison implemented.

This is exactly what #22029 does.



---

archive/issue_comments_363259.json:
```json
{
    "body": "Moving all my in-progress tickets to 8.8 milestone.",
    "created_at": "2019-03-25T10:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363259",
    "user": "embray"
}
```

Moving all my in-progress tickets to 8.8 milestone.



---

archive/issue_comments_363260.json:
```json
{
    "body": "Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).",
    "created_at": "2019-06-14T14:50:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363260",
    "user": "embray"
}
```

Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).



---

archive/issue_comments_363261.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363261",
    "user": "embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_363262.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363262",
    "user": "mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_363263.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363263",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_363264.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25744",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25744#issuecomment-363264",
    "user": "mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.
