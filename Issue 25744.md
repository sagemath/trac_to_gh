# Issue 25744: SafeSortable wrapper for ordering heterogeneous types on Python 3

Issue created by migration from Trac.

Original creator: embray

Original creation time: 2018-07-31 13:33:21

CC:  jdemeyer chapoton

There are several problems on Python 3 involving ordering elements of heterogeneous collections, particularly in objects such as sets and graphs.

This issue has already come up several times in the Python 3 port usually with some ad-hoc fix.  For sorting, sometimes it's straightforward to come up with a reasonable sort key.  Other times it's not obvious, or leads to ugly code (lots of try/excepts, etc.)

One possibility I've brought up before is inspired by the `pprint` implementation on Python 3:  `pprint` by default orders the output of collections such as dicts and sets.  On Python 3 they had to deal with this issue of arbitrary types no longer being ordered, so `pprint` has an internal helper called `_safe_key` on which this `SafeSortable` class is inspired, which serves as a wrapper around objects giving them Python 2-style sorting semantics.

This is just a proof-of-concept, and I think there are various issues to work out:

1. Performance comparison, especially on Python 2.  Adding `key=SafeSortable` to sorts is unnecessary on Python 2 and probably only needlessly slows things down, though I'm not sure by how much.  This could also be avoided by building a Python 2 exception into the `SafeSortable.sort` helper method, and/or possibly making `type(SafeSortable).__call__` effectively a no-op.

2. Performance improvements on Python 3.  Even on Python 3 we can probably speed this up a lot, in particular by pooling `SafeSortable` instances similarly to what we do for `Integer`s.

3. Do we want to make the interface more flexible?  For example, do we always want Python 2 sorting semantics?  Would it also be useful to provide an optional custom fallback for two types that can't be compared naturally?

4. What about comparing compound objects, specifically tuples?  Do we want an API for applying `SafeSortable` recursively to the elements of tuples?  And what about other comparing other heterogeneous collections such as lists?  I think this would _probably_ be useful (e.g. sorting key/value pairs from a dict), but I haven't settled on the API for that.


---

Comment by embray created at 2018-09-07 12:22:04

Changing status from new to needs_review.


---

Comment by embray created at 2018-09-07 12:24:52

On sage-devel the idea was raise of sorting  otherwise unordered objects also based on their hash (as opposed to their id).  This might be a nice semantic to add, where possible, since it will lead to a more deterministic (at within a given platform) sort.


---

Comment by zerline created at 2018-12-13 17:17:34

Changing status from needs_review to positive_review.


---

Comment by zerline created at 2018-12-13 17:17:34

This obviously is a useful change.

Python2 compatibility is a wise behavior.

I only deplore that we need to import a new module, even a small one ..


---

Comment by jhpalmieri created at 2018-12-14 00:16:34

Changing status from positive_review to needs_work.


---

Comment by jhpalmieri created at 2018-12-14 00:16:34

Documentation doesn't build. I don't have time to prepare a proper branch, but I think this will fix it:

```diff
diff --git a/src/sage/structure/misc.pyx b/src/sage/structure/misc.pyx
index c7e9808279..459dd4f244 100644
--- a/src/sage/structure/misc.pyx
+++ b/src/sage/structure/misc.pyx
`@``@` -8,13 +8,14 `@``@` cdef class SafeSortable:
     Wrapper for arbitrary objects allowing them to always be ordered in the
     manner of Python 2.x objects.
 
-    When comparing a `SafeSortable` to another `SafeSortable`, it first
+    When comparing a ``SafeSortable`` to another ``SafeSortable``, it first
     attempts comparing their wrapped objects using the standard ``__lt__``
     comparison.  If that fails, it falls back to comparing them by their type
     name, then by their id, which is consistent with what Python 2.x does with
     a pair of otherwise unorderable types.
 
-    `SafeSortable`s may only be compared with other `SafeSortable`s.
+    ``SafeSortable`` objects may only be compared with other
+    ``SafeSortable`` objects.
 
     EXAMPLES::
 
```



---

Comment by embray created at 2018-12-14 11:15:51

Replying to [comment:5 zerline]:
> I only deplore that we need to import a new module, even a small one .. 

That isn't really a problem though...  I'm not sure why you think it is.  Are you saying it's a problem for the module to be imported _at all_ (because `sage.structure.misc` is already used in `sage.structure.parent` for some utilities)?  Or just the fact that it means adding an import statement to places where it's used?  I'm not sure how else you expect to use utilities defined in other modules.  The only alternative is shoving them into globals and that's not how Sage (or any large Python package) is developed internally.  It's only for the REPL interface that we import a bunch of stuff into the global namespace for the convenience of _user_-level code.


---

Comment by embray created at 2018-12-14 11:17:59

Replying to [comment:6 jhpalmieri]:
> Documentation doesn't build. I don't have time to prepare a proper branch, but I think this will fix it:

I'm not sure why just ``SafeSortable`` wouldn't work.  Normally Sphinx is good about generating links to objects defined in the module being documented without, for example, writing out the fully-qualified name like `:class:`~sage.structure.misc.SafeSortable``.  Is there a known problem with that in Cython modules?


---

Comment by embray created at 2018-12-14 11:23:40

I see--for some reason I never quite got it through my head that the default role throughout Sage's documentation is `:math:`, and not the normal default in Sphinx for Python projects which is `:py:obj:`.  I suppose that makes a certain sense.  So at the very least `:class:`SafeSortable`` is needed to make a proper cross-reference.


---

Comment by jhpalmieri created at 2018-12-14 16:51:28

``SafeSortable`` doesn't cause failures to build, just typesetting in math mode as you note, so that proposed change is cosmetic. The failures come from ```SafeSortable``s`: the second ```` is not recognized by Sphinx as ending a literal block: I'm guessing that Sphinx wants ```` to either be preceded by or followed by a space.

By the way, I also see a doctest failure:

```
Running doctests with ID 2018-12-14-08-47-08-3b058240.
Git branch: t/25981/misc/safe-sortable
Using --optional=dochtml,mpir,python2,sage
Doctesting 1 file.
sage -t --warn-long 51.0 src/sage/structure/misc.pyx
**********************************************************************
File "src/sage/structure/misc.pyx", line 74, in sage.structure.misc.SafeSortable.lt
Failed example:
    SafeSortable.lt(1, 'a')
Expected:
    True
Got:
    False
**********************************************************************
1 item had failures:
   1 of   3 in sage.structure.misc.SafeSortable.lt
    [17 tests, 1 failure, 0.01 s]
----------------------------------------------------------------------
sage -t --warn-long 51.0 src/sage/structure/misc.pyx  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.0 seconds
    cpu time: 0.0 seconds
```



---

Comment by jhpalmieri created at 2018-12-14 17:00:36

If you want to create the cross-references, you can use this change instead of my previous suggestion:

```diff
diff --git a/src/sage/structure/misc.pyx b/src/sage/structure/misc.pyx
index c7e9808279..8217005fa6 100644
--- a/src/sage/structure/misc.pyx
+++ b/src/sage/structure/misc.pyx
`@``@` -8,13 +8,14 `@``@` cdef class SafeSortable:
     Wrapper for arbitrary objects allowing them to always be ordered in the
     manner of Python 2.x objects.
 
-    When comparing a `SafeSortable` to another `SafeSortable`, it first
+    When comparing a :class:`SafeSortable` to another :class:`SafeSortable`, it first
     attempts comparing their wrapped objects using the standard ``__lt__``
     comparison.  If that fails, it falls back to comparing them by their type
     name, then by their id, which is consistent with what Python 2.x does with
     a pair of otherwise unorderable types.
 
-    `SafeSortable`s may only be compared with other `SafeSortable`s.
+    :class:`SafeSortable` objects may only be compared with other
+    :class:`SafeSortable` objects.
 
     EXAMPLES::
 
```



---

Comment by jhpalmieri created at 2018-12-14 17:04:23

Regarding the doctest failure, I get

```
sage: 1 < 'a'
False
sage: int(1) < 'a'
True
```

Did you mean to use `int(1)` instead of 1?


---

Comment by jhpalmieri created at 2018-12-14 17:06:20

`@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?


---

Comment by jdemeyer created at 2018-12-19 15:17:34

It's not really clear to me what the use case of this `SafeSortable` would be. It seems to me that we should just avoid to compare uncomparable objects instead of making uncomparable objects comparable anyway.


---

Comment by embray created at 2018-12-20 08:40:13

Replying to [comment:13 jhpalmieri]:
> `@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?

They gave it a positive review based on its merits, which most people do, without necessarily catching every minute issue (this is what we have patchbots for, supposedly).  They aren't as familiar as you are with these nitpicks and it's not a big deal.


---

Comment by embray created at 2018-12-20 08:42:34

Replying to [comment:14 jdemeyer]:
> It's not really clear to me what the use case of this `SafeSortable` would be. It seems to me that we should just avoid to compare uncomparable objects instead of making uncomparable objects comparable anyway.

My python3 branch is replete with examples of its use.  I can add more if you don't believe me.  It fixes a good many issues where lists of mixed-type objects are being sorted, and there are plenty of cases like that which are valid.  One of the common examples is ordering lists of edge labels which can be strings or ints, but there are plenty of other examples.  

There are dozens of bugs that I've delayed fixing for months on end due to not having a utility like this.  I'm just going to fix the fussy documentation issue and set this back to positive review.


---

Comment by embray created at 2018-12-20 10:21:58

Replying to [comment:12 jhpalmieri]:
> Regarding the doctest failure, I get
> {{{
> sage: 1 < 'a'
> False
> sage: int(1) < 'a'
> True
> }}}
> Did you mean to use `int(1)` instead of 1?

I get


```
sage: 1 < 'a'
True
```


Initially I wasn't sure why you would get False here, since the default Python 2 comparison actually sorts instances of numeric types (which I believe Sage's `Integer` is for this purpose), so both `Integer(1)` and `int(1)` should come before `'a'` and I'm not sure how you'd get any other result.  However, it turns out that `Integer.__richcmp__` given a RHS that is not obviously comparable to an int will fall back on the coercion model, which itself in this case has a default [richcmp implementation](https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage/structure/coerce.pyx?id=0e992df0fc4641339f9eb465252486ef88a56ebb#n1895) that as a last resort compares the two elements just by their ids, and that's what's happening in the case of comparing an `Integer` to a `str`.  This default comparison is rather unfortunate since it's rather non-deterministic.

I'm not sure what the best thing would be to do about this.  I'm tempted to take the Python 3 approach and remove this fallback nonsense comparison in favor of raising a `TypeError` if two objects don't have a sensible comparison implemented.


---

Comment by embray created at 2018-12-20 10:23:17

One other thing no one has pointed out though is that the "Python 2 style comparison" implemented here isn't actually quite correct.  I took the implementation from Python's [pprint](https://github.com/python/cpython/blob/1fb312ce1f147ea84ecb6f5993a20d1a85c53dc3/Lib/pprint.py#L72) module which implements a similar utility, but in pure Python, and not public API (as I explained in the ticket description).  However, it turns out the actual default comparison is a little more complex: https://github.com/python/cpython/blob/3752bc96c0ea1ecf28903cc34cdcd75c658e92ce/Objects/object.c#L767

I think I may update this to something a bit closer to that.  It has the advantage of being deterministic, whereas the current implementation still relies on instance ids which is not ideal.


---

Comment by jhpalmieri created at 2018-12-20 16:03:29

Replying to [comment:15 embray]:
> Replying to [comment:13 jhpalmieri]:
> > `@`zerline: could you clarify why you gave this a positive review if the docs don't build and tests don't pass?
> 
> They gave it a positive review based on its merits, which most people do, without necessarily catching every minute issue (this is what we have patchbots for, supposedly).  They aren't as familiar as you are with these nitpicks and it's not a big deal.

There is (at least) one thing the patchbots won't do: look at the built documentation to make sure it looks okay, doesn't use ``code`` instead of ```code``` or other reST errors which won't stop the build but will make the output look bad. This should actually be on [the reviewer's checklist](http://doc.sagemath.org/html/en/developer/reviewer_checklist.html#chapter-review): look at the documentation. If reviewers don't look at the built documentation, it is likely that the quality of the documentation will decrease over time because these errors won't get caught. I'd prefer that this did not happen.

The doctest may be system dependent. In unpatched Sage running Python 2, `1 < 'a'` returns `False` on several OS X machines.


---

Comment by jhpalmieri created at 2018-12-20 16:13:55

Replying to [comment:19 jhpalmieri]:
> This should actually be on [the reviewer's checklist](http://doc.sagemath.org/html/en/developer/reviewer_checklist.html#chapter-review): look at the documentation.

See #26926.


---

Comment by jdemeyer created at 2018-12-23 15:05:57

First a minor comment about the code: in comparison methods, you don't need to check the type of the first argument: it's `self` (and should be called `self` by PEP 8) and you know that it has the right class. Cython knows it too, so you don't need a `<SafeSortable>` cast.


---

Comment by jdemeyer created at 2018-12-23 15:13:48

Now about using `SafeSortable`: I'm not convinced that it actually makes sense. If you just want to sort something for the user's convenience and nothing really depends on it, then it's fine: in the best case, it helps and in the worst case, you won't break anything.

But I wouldn't use `SafeSortable` for anything where the order really matters for an algorithm: the `try`/`except` style means that it's non-transitive (in that sense, it's worse than simply using `str` as sorting key).

Falling back on things like `type()` and `id()` is also trying to force Python 2 sorting semantics in Python 3. I'm not sure that this is the right thing to do.


---

Comment by embray created at 2018-12-28 14:10:15

Retargeting some of my tickets (somewhat optimistically for now).


---

Comment by embray created at 2018-12-31 12:57:49

Replying to [comment:19 jhpalmieri]:
> The doctest may be system dependent. In unpatched Sage running Python 2, `1 < 'a'` returns `False` on several OS X machines.

I already explained that it is, as well as the exact reason.


---

Comment by jdemeyer created at 2019-01-08 15:55:33

Replying to [comment:17 embray]:
> I'm tempted to take the Python 3 approach and remove this fallback nonsense comparison in favor of raising a `TypeError` if two objects don't have a sensible comparison implemented.

This is exactly what #22029 does.


---

Comment by embray created at 2019-03-25 10:43:18

Moving all my in-progress tickets to 8.8 milestone.


---

Comment by embray created at 2019-06-14 14:50:27

Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.
