# Issue 12349: evaluate log gamma for complex input

Issue created by migration from Trac.

Original creator: kcrisman

Original creation time: 2012-02-16 17:02:27

Assignee: AlexGhitza

CC:  burcin ktkohl fstan zimmerma benjaminfjones eviatarbach paulmasson

Keywords: lgamma log_gamma

Currently, we use MPFR or Ginac to evaluate `log_gamma`, but this returns `NaN` for negative input with even ceiling.

```
sage: log_gamma(-2.1)
NaN
sage: log_gamma(-3.1)
0.400311696703985
sage: log_gamma(-4.1)
NaN
sage: log_gamma(-5.1)
-2.63991581673655
sage: log_gamma(-21/10).n()
NaN
sage: get_systems('log_gamma(-21/10).n()')
['ginac']
sage: log_gamma(CC(-2.1))
1.53171380819509 + 3.14159265358979*I
```

We can use mpmath or something other trick to get this to work, now that #10075 has a  nice symbolic function available.  See #10072 for where we originally got better numerical evaluation.

```
sage: mpmath.loggamma(-2.1)
mpc(real='1.5317138081950856', imag='-9.4247779607693793')
```

Putting as defect because there is a log gamma for negative numbers, though we should talk about branches...


---

Comment by zimmerma created at 2012-02-17 09:41:06

I cannot reproduce some examples from the description with Sage 4.8:

```
sage: from sage.misc.citation import get_systems
sage: get_systems('log_gamma(-21/10).n()')      
['MPFR']
sage: log_gamma(CC(-2.1))
NaN
```

Do you use a different version? Did you apply some patches?

Paul


---

Comment by kcrisman created at 2012-02-17 13:50:44

> Do you use a different version? Did you apply some patches?
Yes, I guess this is after #10075.  There is the same problem before that patch, but the systems and outputs will be different.   In particular, inheriting from the parent of the input (which most generic `Function` classes do) if it has a method of the same name (which `CC` does) makes this change.

There is no patch, so this doesn't depend on #10075 in that sense, but I will put it anyway so that it's clear.  Thanks!


---

Comment by kcrisman created at 2012-07-07 02:56:39

Removing dependency so as not to confuse anyone, now that that is in a long-since released version of Sage.


---

Comment by zimmerma created at 2012-07-09 13:05:53

by the way, MPFR provides two functions: `mpfr_lngamma` indeed returns `NaN` between
`-2k-1` and `-2k` for `k` a non-negative integer.

However there is another function `mpfr_lgamma` which returns `log(abs(gamma(x)))`,
and separately the sign of `gamma(x)`. It suffices to add `pi*I` when the sign is
negative.

This would solve the problem at least for real input.

Paul


---

Comment by eviatarbach created at 2013-01-21 01:06:36

There is a related issue with the beta function:


```
sage: beta(-1.3,-0.4)
NaN
sage: (gamma(-1.3) * gamma(-0.4)) / gamma(-1.3 - 0.4) # expected functionality
-4.92909641669610
```


This is presumably because GiNaC uses `exp(log_gamma(-1.3)+log_gamma(-0.4)-log_gamma(-1.3-0.4))` to evaluate, and `gamma(-0.4)` is negative. I'm confused as to why it works fine in the GiNaC interactive shell though.


---

Comment by eviatarbach created at 2013-06-19 17:24:19

Changing priority from major to critical.


---

Comment by eviatarbach created at 2013-06-19 17:24:19

Our current implementation is wrong. For the principal branch, `log_gamma(z)` should not be equal to `log(gamma(z))` in general. See https://cs.uwaterloo.ca/research/tr/1994/23/CS-94-23.pdf:

`ln_gamma(x) = ln(gamma(x)) + 2*pi*i*ceil(x/2 - 1)`

Changing to critical because the documentation claims that it's the principal branch, which is mathematically wrong.


---

Comment by kcrisman created at 2013-06-19 20:06:44

I'd like to have another reference for this (perhaps NIST or A&S) but this sounds plausible.  So what is the relation between this and the mpfr versions?


---

Comment by eviatarbach created at 2013-06-19 21:59:59

Paul, could you please comment on this code for `sage/rings/real_mpfr.pyx`?



```
    def log_gamma(self):
        cdef RealNumber x = self._new()
        cdef int sign
        parent = (<RealField_class>self._parent)
        if parent.__prec > SIG_PREC_THRESHOLD: sig_on()
        mpfr_lgamma(x.value, &sign, self.value, parent.rnd)
        if parent.__prec > SIG_PREC_THRESHOLD: sig_off()
        if not mpfr_sgn(self.value) < 0:
            return x
        cdef RealNumber v = self._new()
        mpfr_div_si((<RealNumber>v).value, self.value, 2, parent.rnd)
        return parent.complex_field()(x, parent.pi() *
                                      (2 * (v - 1).ceil() + 1))
```


This correctly computes the principal branch. However, I'm concerned about precision; the result of `lgamma` is presumably guaranteed to be correct up to the precision of the input, but after doing some arithmetic it might not be. Is there any way to fix this?


---

Comment by zimmerma created at 2013-06-20 05:48:13

Dear Eviatar,

I see no argument to tell the precision of the output in this function, thus I guess the result should be computed to the precision of the input.

Then the real part seems fine to me.

For the imaginary part, you create the variable `v` with the same precision than the input I guess.
In `v-1` you might have a problem if `v` is very large, then `v-1` rounded will equal `v`,
and `(v-1).ceil()` will equal `v` too. Thus the result will be too large by `2pi`.

Paul


---

Comment by zimmerma created at 2013-06-20 08:45:25

Replying to [comment:9 kcrisman]:
> I'd like to have another reference for this (perhaps NIST or A&S) but this sounds plausible.  So what is the relation between this and the mpfr versions?

there are some references on http://mathworld.wolfram.com/LogGammaFunction.html

Paul


---

Comment by eviatarbach created at 2013-06-20 16:58:07

Thank you. I suspected there might be a problem like this. I think maybe using MPFR for positive reals (since it's faster) and mpmath for negative reals might be best.


---

Attachment


---

Comment by eviatarbach created at 2013-06-25 09:38:26

Changing status from new to needs_review.


---

Comment by eviatarbach created at 2013-06-25 09:38:26

Patch uploaded. It uses mpmath to evaluate `log_gamma` in certain circumstances, while the MPFR implementation is left intact for positive reals. It also removes the `lgamma` and `lngamma` functions which were deprecated four years ago with #6992.

Patchbot apply trac_12521.2.patch


---

Attachment

The patchbot complains about old style doctest continuation.

Since you need to edit the patch anyway... In the `py_lgamma` function from `pynac.pyx`, you don't need to import `call` from `mpmath` or `parent` from `sage.structure.coerce`. These are already available as `mpmath_utils.call` and `parent_c`.

Thanks for the patch! Great work noticing that we don't actually compute the principal branch.


---

Comment by burcin created at 2013-06-27 16:55:20

Changing status from needs_review to needs_work.


---

Comment by eviatarbach created at 2013-06-27 20:33:52

Changing status from needs_work to needs_review.


---

Comment by eviatarbach created at 2013-06-27 20:33:52

Thanks!

I had already fixed the doctest continuation and overwrote the previous patch, but the patchbot didn't test it again.

I fixed the import issue. I also noticed that the results for Python `float` and `complex` were inconsistent, so I fixed that and added some tests.

Patchbot apply trac_12521_3.patch


---

Attachment

Why is the patchbot trying to apply the last two patches instead of just trac_12521_3.patch?


---

Comment by eviatarbach created at 2013-07-16 05:40:52

Let's try again:

Patchbot apply trac_12521_3.patch


---

Comment by jdemeyer created at 2013-10-29 08:08:18

I am against removing the `lngamma()` method and against the deprecation from #6992 for PARI. Inside PARI/GP, the name is `lngamma()` and that name should be available to Sage too.


---

Comment by jdemeyer created at 2013-10-29 08:31:30

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2013-10-29 08:31:30

Also, it seems the algorithm for complex numbers is much faster than for real numbers, so we should probably use the complex algorithm for all inputs:

```
sage: a=RealField(53)(2.5); timeit('log_gamma(a)')
625 loops, best of 3: 118 µs per loop
sage: a=ComplexField(53)(2.5); timeit('log_gamma(a)')
625 loops, best of 3: 112 µs per loop
```


```
sage: a=RealField(10**4)(2.5); timeit('log_gamma(a)')
5 loops, best of 3: 506 ms per loop
sage: a=ComplexField(10**4)(2.5); timeit('log_gamma(a)')
625 loops, best of 3: 782 µs per loop
```



---

Comment by jdemeyer created at 2014-02-09 16:27:52

I am reverting the deprecation of `lngamma()` for PARI in #15767 (see comment [comment:20])


---

Comment by rws created at 2014-08-11 07:26:22

Tests are good in `functions`, `rings`, `symbolic`. The speed issue in comment:21 still remains.
----
New commits:


---

Comment by git created at 2014-09-03 08:11:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kcrisman created at 2014-09-03 12:25:43

Has anyone checked the _mathematics_ of this recently?  Eviatar usually does a very good job on this stuff, but unfortunately Burcin didn't make it clear whether the rest was approved of other than the different imports.


---

Comment by git created at 2016-06-15 07:29:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-06-15 07:30:57

Changing status from needs_work to needs_review.


---

Comment by paulmasson created at 2016-06-22 19:37:51

With these changes the beta() function is still producing small imaginary parts around poles and not returning the appropriate signed Infinity at the poles. Presumably that should be on another ticket.

Otherwise looks fine to me.


---

Comment by paulmasson created at 2016-06-22 19:38:14

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-06-24 07:26:13

Resolution: fixed
