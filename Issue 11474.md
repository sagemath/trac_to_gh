# Issue 11474: Significance arithmetic

archive/issues_011474.json:
```json
{
    "body": "Assignee: @aghitza\n\nI am working on implementing significance arithmetic in Sage (i.e., maintaining significant digits under arithmetic operations). This can be accomplished through a special structure which, upon instantiation, determines the amount of sig. figs and coerces into a RealField.\n\nFor example,\n\n\n```\nsage: SF('787') * SF('3.0')\n2400.\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/11646\n\n",
    "created_at": "2011-08-04T06:18:57Z",
    "labels": [
        "basic arithmetic",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-feature",
    "title": "Significance arithmetic",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11474",
    "user": "@eviatarbach"
}
```
Assignee: @aghitza

I am working on implementing significance arithmetic in Sage (i.e., maintaining significant digits under arithmetic operations). This can be accomplished through a special structure which, upon instantiation, determines the amount of sig. figs and coerces into a RealField.

For example,


```
sage: SF('787') * SF('3.0')
2400.
```


Issue created by migration from https://trac.sagemath.org/ticket/11646





---

archive/issue_comments_128201.json:
```json
{
    "body": "Shouldn't the result display as something like `2.4 * 10^3` (`2.4e3`) or `24 * 10^2` (`24e2`)?",
    "created_at": "2011-08-04T14:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11474",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11474#issuecomment-128201",
    "user": "@nexttime"
}
```

Shouldn't the result display as something like `2.4 * 10^3` (`2.4e3`) or `24 * 10^2` (`24e2`)?



---

archive/issue_comments_128202.json:
```json
{
    "body": "Yes, that's correct. I will fix it.",
    "created_at": "2011-08-04T18:48:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11474",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11474#issuecomment-128202",
    "user": "@eviatarbach"
}
```

Yes, that's correct. I will fix it.



---

archive/issue_comments_128203.json:
```json
{
    "body": "Check out python's `decimal` module. It might already provide what you are looking for.",
    "created_at": "2011-08-04T23:11:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11474",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11474#issuecomment-128203",
    "user": "@nbruin"
}
```

Check out python's `decimal` module. It might already provide what you are looking for.



---

archive/issue_comments_128204.json:
```json
{
    "body": "Not quite. It does not preserve significant figures in multiplication; 1.30 * 1.20 gives 1.5600.",
    "created_at": "2011-08-05T18:34:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11474",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11474#issuecomment-128204",
    "user": "@eviatarbach"
}
```

Not quite. It does not preserve significant figures in multiplication; 1.30 * 1.20 gives 1.5600.



---

archive/issue_comments_128205.json:
```json
{
    "body": "That is a surprising implementation choice. It looks like the precision is again just part of the context, not of a particular number. But apparently they do allow a number to be \"underspecified\" (have fewer digits than the precision of the context in force). Indeed, if you want the precision to be an attribute of each individual number, this module does not do what you want. You could build on top of it (or hack it) if you want to faithfully mimic pen-and-paper float arithmetic.\n\nIf you are mainly interested in keeping track of how inaccuracies propagate through a computation, you should look at the interval arithmetic already in place in Sage, though. It should track loss of precision more accurately than keeping track of the number of \"significant digits\".\n\n```\nsage: RIF((786.5,787.5))\n787.?\nsage: RIF((2.95,3.05))\n3.0?\nsage:  RIF((786.5,787.5))*RIF((2.95,3.05))\n2.4?e3 \n```\n",
    "created_at": "2011-08-05T21:04:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11474",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11474#issuecomment-128205",
    "user": "@nbruin"
}
```

That is a surprising implementation choice. It looks like the precision is again just part of the context, not of a particular number. But apparently they do allow a number to be "underspecified" (have fewer digits than the precision of the context in force). Indeed, if you want the precision to be an attribute of each individual number, this module does not do what you want. You could build on top of it (or hack it) if you want to faithfully mimic pen-and-paper float arithmetic.

If you are mainly interested in keeping track of how inaccuracies propagate through a computation, you should look at the interval arithmetic already in place in Sage, though. It should track loss of precision more accurately than keeping track of the number of "significant digits".

```
sage: RIF((786.5,787.5))
787.?
sage: RIF((2.95,3.05))
3.0?
sage:  RIF((786.5,787.5))*RIF((2.95,3.05))
2.4?e3 
```

