# Issue 20652: truncated power for polynomials

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2016-06-27 09:43:08

CC:  bruno defeo mmezzarobba

Implement generic truncated power (method `_pow_trunc_`) for polynomials.


---

Comment by vdelecroix created at 2016-06-27 09:44:23

New commits:


---

Comment by vdelecroix created at 2016-06-27 09:44:23

Changing status from new to needs_review.


---

Comment by git created at 2016-06-27 10:28:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-06-27 11:44:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2016-06-29 13:55:19

* How much does it gain to statically type the arguments of the method? One drawback is that you cannot do the following (though the computation would be fast):

    {{{#!python
    sage: p = 7
    sage: R.<x> = GF(p)[]
    sage: f = x^2 + x + 1
    sage: f.power_trunc(2^100, 1000)
    Traceback (most recent call last):
    ...
    OverflowError: long int too large to convert
    }}}

* On a related note, do you think it may be useful to allow for a negative power? The code could be as follows:

    {{{#!python
    if n < 0:
        return self.inverse_series_trunc(prec).power_trunc(-n, prec)
    }}}

* The first line of documentation is pretty terse...


---

Comment by bruno created at 2016-06-29 13:55:19

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2016-06-29 14:05:49

Replying to [comment:5 bruno]:
> * How much does it gain to statically type the arguments of the method? One drawback is that you cannot do the following (though the computation would be fast):
> 
>     {{{#!python
>     sage: p = 7
>     sage: R.<x> = GF(p)[]
>     sage: f = x^2 + x + 1
>     sage: f.power_trunc(2^100, 1000)
>     Traceback (most recent call last):
>     ...
>     OverflowError: long int too large to convert
>     }}}

The reason is that I want to use library calls when available. Some of them does not support arbitrary precision exponent. I used the type from flint.

> * On a related note, do you think it may be useful to allow for a negative power? The code could be as follows:
> 
>     {{{#!python
>     if n < 0:
>         return self.inverse_series_trunc(prec).power_trunc(-n, prec)
>     }}}

I don't know. I do not think of `power_trunc` as a convenience function. I want to use it in algorithms (like `nth_root`). We might propose `_power_trunc_` (or `_power_trunc` or any other names) with restricted types. And on the other hand `power_trunc` with arbitrary precision and possibly negative input... Library calls would just override the specialized function `_power_trunc_`. What do you think?

> * The first line of documentation is pretty terse...

I will change it.


---

Comment by bruno created at 2016-06-30 09:48:12

Replying to [comment:6 vdelecroix]:
> I don't know. I do not think of `power_trunc` as a convenience function. I want to use it in algorithms (like `nth_root`). We might propose `_power_trunc_` (or `_power_trunc` or any other names) with restricted types. And on the other hand `power_trunc` with arbitrary precision and possibly negative input... Library calls would just override the specialized function `_power_trunc_`. What do you think?

There are two things: About negative powers, I mostly don't care though it may be handy to have the possibility. About large powers, I think that public methods with integer inputs should be able to handle any element of `ZZ`. So there are two solutions that I prefer against the current situation: Either remove the static types, or manually catch the exception for large powers. I suspect that the second solution cannot be implemented while keeping the static types...

I find your solution of having both `power_mod` as public interface and `_power_mod` is a good trade-off.


---

Comment by git created at 2016-06-30 22:26:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-06-30 22:28:42

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-06-30 22:28:42

It is a bit of duplication but now the code handles any integer size for the power `n`. The specialized code is only used when it fits into an unsigned long.


---

Comment by bruno created at 2016-07-01 16:37:20

I am mostly happy with this ticket, though I wonder whether code duplication is really useful: Is it necessary to have the generic method `_power_trunc`? My brief tests do not show significant speedup when using this generic implementation instead of `power_trunc`. The speedup is notable when one uses the _specialized_ implementations (using Flint) of course.

I would simply remove `_power_trunc` in `src/sage/rings/polynomial/polynomial_element.pyx`, and add a test to know whether `_power_trunc` exists. I guess you are much more experienced than me in Cython, so I may be saying something stupid.


---

Comment by git created at 2016-07-02 09:38:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-07-02 11:44:07

Done! (the git-trac plugin did not sent me an e-mail)


---

Comment by bruno created at 2016-07-04 12:48:28

I am sorry if I am becoming painful... 

* I would allow more general integers in `generic_power_trunc` to allow computations as follows:


```python
sage: R.<x> = PolynomialRing(ZZ, sparse=True)
sage: p = x^2^100 + 1
sage: p.power_trunc(100, 2^100+1)
100*x^1267650600228229401496703205376 + 1
```



* A curiosity question: Why did you write `generic_power_trunc` outside from any class?


---

Comment by vdelecroix created at 2016-07-04 16:52:56

Replying to [comment:13 bruno]:
> I am sorry if I am becoming painful... 

I wish I had every review like this one!
 
> * I would allow more general integers in `generic_power_trunc` to allow computations as follows:
> 
> {{{#!python
> sage: R.<x> = PolynomialRing(ZZ, sparse=True)
> sage: p = x<sup>2</sup>100 + 1
> sage: p.power_trunc(100, 2^100+1)
> 100*x^1267650600228229401496703205376 + 1
> }}}

I see. You mean for `prec`. As in your example, this would only be interesting for sparse polynomials. Note that it will not work at all for dense polynomials because `truncate` is defined as `cpdef Polynomial truncate(self, long prec)`. I don't mind changing the generic method to handle this case.

> * A curiosity question: Why did you write `generic_power_trunc` outside from any class?

I did not have any other option. As you said we could have checked whether the method `_power_trunc` is implemented in subclasses but this is not as simple as it seems with `cpdef` methods.


---

Comment by vdelecroix created at 2016-07-04 17:04:43

I can not change `long -> Integer` for `prec`. The reason is that `truncate` (for both dense and sparse polynomials) is declared as `cpdef truncate(self, long n)`.


---

Comment by bruno created at 2016-07-05 12:30:05

Changing status from needs_review to positive_review.


---

Comment by bruno created at 2016-07-05 12:30:05

Replying to [comment:14 vdelecroix] & [comment:15 vdelecroix]:
> I see. You mean for `prec`. As in your example, this would only be interesting for sparse polynomials. Note that it will not work at all for dense polynomials because `truncate` is defined as `cpdef Polynomial truncate(self, long prec)`. I don't mind changing the generic method to handle this case.

>  I can not change `long -> Integer` for `prec`. The reason is that `truncate` (for both dense and sparse polynomials) is declared as `cpdef truncate(self, long n)`.

For dense polynomials, this makes sense because of the size of the representation. For sparse polynomials, I think this is a problem and I encountered it several times: For sparse polynomials to have an interest, one should not bound their degree. But anyway, this is not the purpose of this ticket.


---

Comment by vbraun created at 2016-07-05 21:43:16

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2016-07-05 21:43:16

Documentation doesn't build

There are more test failures, see patchbot report.


---

Comment by git created at 2016-07-06 13:41:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-07-06 13:44:53

Corrected the doc. Waiting for patchbot report...


---

Comment by vdelecroix created at 2016-07-06 13:44:53

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-07-06 19:27:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2016-07-07 09:22:19

As far as I can tell, this now passes all the tests and the documentation correctly builds. I am not sure to be able to interpret patchbot messages, so I let somebody else setting the ticket to  `positive review` if everything's OK. (Vincent, you can do it yourself on my behalf.)


---

Comment by vdelecroix created at 2016-07-07 13:52:56

It is indeed strange...


---

Comment by vdelecroix created at 2016-07-07 13:52:56

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-07-08 07:09:54

Resolution: fixed
