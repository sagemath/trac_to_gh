# Issue 33981: Implement longest_increasing_subsequence_number

Issue created by migration from https://trac.sagemath.org/ticket/34218

Original creator: vdelecroix

Original creation time: 2022-07-25 07:16:10

CC:  nadialafreniere dcoudert

Using the digraph built in #31451, it is straightforward to implement a method that would count the number of increasing subsequences without listing them all.


---

Comment by nadialafreniere created at 2022-07-25 20:20:18

I tried implementing it, but I'm not convinced by the result. The method with the adjacency matrix of the digraph seems to be slower. Mainly, I think that a lot of the problem comes from taking the exponential of the adjacency matrix of the digraph (an (n+2)-by-(n+2) matrix raised to a power that is in θ(√n) in average), and this seems to slow the process down much more than listing the longest increasing subsequences.

After coding it, I got the following times:

```
sage: %timeit len(Permutations(100).random_element().longest_increasing_subsequences())  # Naive 
2.8 ms ± 284 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit Permutations(100).random_element().longest_increasing_subsequences_number()  # new code
4.42 ms ± 42 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```


Even though I'm uploading my code to the trac, I think we might want to give up on the project. Or, if you know of a way to make it efficient, I would love to see it.
----
Last 10 new commits:


---

Comment by vdelecroix created at 2022-07-25 21:22:02

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2022-07-25 21:22:02

Indeed, matrix powering is not clever enough. Though one can avoid the creation of the digraph which is time consuming.
----
New commits:


---

Comment by git created at 2022-07-25 21:23:36

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2022-07-25 21:24:25

At commit `a98a60f` I got

```
sage: %time sum(len(p.longest_increasing_subsequences()) for p in Permutations(8))
CPU times: user 1.76 s, sys: 2.97 ms, total: 1.76 s
Wall time: 1.77 s
120770
sage: %time sum(p.longest_increasing_subsequences_number() for p in Permutations(8))
CPU times: user 328 ms, sys: 0 ns, total: 328 ms
Wall time: 328 ms
120770
```



---

Comment by vdelecroix created at 2022-07-25 21:26:59

And same test as your [This is the Trac macro *comment:2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:2-macro) gives on my machine

```
sage: %timeit len(Permutations(100).random_element().longest_increasing_subsequences())  # Naive 
1.55 ms ± 69.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit Permutations(100).random_element().longest_increasing_subsequences_number()  # new code
122 µs ± 2.38 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
```



---

Comment by vdelecroix created at 2022-07-25 21:29:05

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by dcoudert created at 2022-07-25 21:37:31

I was about to explain how to count the number of paths on a DAG when all arcs go from level `i` to level `i+1` in time `O(|V| + |E|)`, but your solution avoids the creation of the DAG. This is smart.

You could add a little explanation of the algorithm, at least for Nadia.

For the documentation, you could use `:meth:~.longest_increasing_subsequences`, or something like that.

Otherwise, LGTM.


---

Comment by dcoudert created at 2022-07-25 21:48:59

For Nadia: roughly, in the DAG, the number of paths to reach vertex `x` of column `i+1` is the sum over the predecessors of `x` (all in column `i`) of the number of paths from to source to each of these predecessors. For initialization, there is a single path to go from the source to a vertex in column 0 (a successor of the source). then, you iterate over the columns and you add the count of `x` in the current column to each of its successors.

The method of Vincent do the same computation but avoids to build the DAG.


---

Comment by git created at 2022-07-26 07:04:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2022-07-26 08:50:26

LGTM.


---

Comment by dcoudert created at 2022-07-26 08:50:26

Changing status from needs_review to positive_review.


---

Comment by nadialafreniere created at 2022-07-26 10:43:43

Replying to [comment:10 dcoudert]:
> For Nadia: roughly, in the DAG, the number of paths to reach vertex `x` of column `i+1` is the sum over the predecessors of `x` (all in column `i`) of the number of paths from to source to each of these predecessors. For initialization, there is a single path to go from the source to a vertex in column 0 (a successor of the source). then, you iterate over the columns and you add the count of `x` in the current column to each of its successors.
> 
> The method of Vincent do the same computation but avoids to build the DAG.
Nice job! This looks very good!


---

Comment by vbraun created at 2022-08-01 20:22:48

Resolution: fixed
