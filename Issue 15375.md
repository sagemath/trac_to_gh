# Issue 15375: We need unordered trees

archive/issues_015375.json:
```json
{
    "body": "CC:  sage-combinat nthiery hivert elixyre chapoton\n\nKeywords: trees\n\nOf course, the actual implementation will have to wait for #14498 being reviewed (hint, hint), but I guess it won't hurt to bring up the matter now.\n\nI'd really like to see unordered (=non-planar) trees of various varieties (binary/arbitrary, labelled/unlabelled) being implemented in Sage. (\"Unordered\" means that the children of a vertex form a multiset, not a list.) I'm wondering if it is possible to implement the labelled kind as a finite set with a Maybe-endomorphism (i. e., a partial map from the set to itself), because I guess this will be a lot faster than following the recursive paradigm we currently have.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15612\n\n",
    "created_at": "2013-12-31T19:10:16Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "We need unordered trees",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15375",
    "user": "darij"
}
```
CC:  sage-combinat nthiery hivert elixyre chapoton

Keywords: trees

Of course, the actual implementation will have to wait for #14498 being reviewed (hint, hint), but I guess it won't hurt to bring up the matter now.

I'd really like to see unordered (=non-planar) trees of various varieties (binary/arbitrary, labelled/unlabelled) being implemented in Sage. ("Unordered" means that the children of a vertex form a multiset, not a list.) I'm wondering if it is possible to implement the labelled kind as a finite set with a Maybe-endomorphism (i. e., a partial map from the set to itself), because I guess this will be a lot faster than following the recursive paradigm we currently have.

Issue created by migration from https://trac.sagemath.org/ticket/15612





---

archive/issue_comments_198313.json:
```json
{
    "body": "The way is long and not easy:\n\nFirst #10963 then #10194 then #11529\n\nIt may be possible to bypass #10963 though. As far as I remember, #10194 does not really depend on it, and commuting should be easy.",
    "created_at": "2013-12-31T19:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15375",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15375#issuecomment-198313",
    "user": "chapoton"
}
```

The way is long and not easy:

First #10963 then #10194 then #11529

It may be possible to bypass #10963 though. As far as I remember, #10194 does not really depend on it, and commuting should be easy.



---

archive/issue_comments_198314.json:
```json
{
    "body": "Oh, I didn't know of #11529. Looks like things are on a good way forward then, at least once the latest memory leak from #10963 is plugged.",
    "created_at": "2013-12-31T20:40:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15375",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15375#issuecomment-198314",
    "user": "darij"
}
```

Oh, I didn't know of #11529. Looks like things are on a good way forward then, at least once the latest memory leak from #10963 is plugged.



---

archive/issue_comments_198315.json:
```json
{
    "body": "or should it be duplicate ?",
    "created_at": "2015-06-22T18:18:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15375",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15375#issuecomment-198315",
    "user": "chapoton"
}
```

or should it be duplicate ?



---

archive/issue_comments_198316.json:
```json
{
    "body": "There is something that I'm still kind-of missing: The labelled rooted trees on {1, 2, ..., n}. We don't have them, do we? They can be implemented as lists (g(1), g(2), ..., g(n)), where g(i) is the father of i if such a father exists and 0 else. They are a basis for a Hopf algebra, and I still have some ancient code that defines this Hopf algebra (although I'm not sure about the quality of that code). What could be tricky: Can we make them inherit from `LabelledRootedTree`, or only convert to such?",
    "created_at": "2015-06-23T01:01:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15375",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15375#issuecomment-198316",
    "user": "darij"
}
```

There is something that I'm still kind-of missing: The labelled rooted trees on {1, 2, ..., n}. We don't have them, do we? They can be implemented as lists (g(1), g(2), ..., g(n)), where g(i) is the father of i if such a father exists and 0 else. They are a basis for a Hopf algebra, and I still have some ancient code that defines this Hopf algebra (although I'm not sure about the quality of that code). What could be tricky: Can we make them inherit from `LabelledRootedTree`, or only convert to such?
