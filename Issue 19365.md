# Issue 19365: Fix dependencies on MPIR

Issue created by migration from https://trac.sagemath.org/ticket/19602

Original creator: jdemeyer

Original creation time: 2015-11-19 15:02:59

CC:  vbraun




---

Comment by jdemeyer created at 2015-11-19 17:00:02

New commits:


---

Comment by jdemeyer created at 2015-11-19 17:02:05

Changing component from cython to build.


---

Comment by jdemeyer created at 2015-11-19 17:02:05

Changing status from new to needs_review.


---

Comment by vbraun created at 2015-11-19 17:06:36

how about putting wrap_create_extension_list into sage_setup?


---

Comment by jdemeyer created at 2015-11-19 19:49:37

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2015-11-19 19:49:37

There seems to be a problem with distutils...


---

Comment by jdemeyer created at 2015-11-20 06:51:48

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-11-20 06:51:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by leif created at 2015-11-20 09:54:40

Wow, getting more and more inefficient (memory footprint, number of system calls/filesystem accesses).  (W.r.t. reinventing the wheel, we should probably consider dynamically creating Makefiles to build the Sage library... ;-) )

You could at least cache the mapping of library names to their (existing, probably single) pathnames (and reuse them instead of creating hundreds of copies); if there's a shared library, you don't have to record another potential static one of the same library -- on *nix at least.  Not sure whether hardcoding the library folders (`SAGE_LOCAL/lib*/`) there makes sense, or is appropriate.

After all, not relying on (say) timestamps of headers but recompiling and relinking on every change of a shared library is pretty much against one of their purposes.




`libFOO.dll` is not the convention used on Windows AFAIK; we may specialize according to the platform, also avoiding unnecessary calls of `glob()`.




Do you want to keep the verbose listing of (lengthy!) dependencies by default?




You've renamed the parameter `library_order` to `library_sort_key`, the docstring of `wrap_create_extension_list()` doesn't yet reflect that change.


---

Comment by jdemeyer created at 2015-11-20 10:45:04

Replying to [comment:10 leif]:
> Wow, getting more and more inefficient (memory footprint, number of system calls/filesystem accesses).  (W.r.t. reinventing the wheel, we should probably consider dynamically creating Makefiles to build the Sage library... ;-) )
I'd love to, but I think neither upstream Cython nor upstream distutils will want to support that.

> You could at least cache the mapping of library names to their (existing, probably single) pathnames
Right.

> if there's a shared library, you don't have to record another potential static one of the same library -- on *nix at least.
Well, it doesn't really hurt either. It's just to be safe.

> After all, not relying on (say) timestamps of headers but recompiling and relinking on every change of a shared library is pretty much against one of their purposes.
Again, you are right but I don't see an easy way to express this in the build system.

> Do you want to keep the verbose listing of (lengthy!) dependencies by default?
Which "verbose listing of (lengthy!) dependencies"?


---

Comment by git created at 2015-11-20 11:00:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-11-20 11:02:37

Replying to [comment:10 leif]:
> After all, not relying on (say) timestamps of headers but recompiling and relinking on every change of a shared library is pretty much against one of their purposes.

I must say that I find some truth in this. Volker, do you agree that it's simply a bad idea to rely on timestamps of library files?


---

Comment by leif created at 2015-11-20 11:20:03

Replying to [comment:13 jdemeyer]:
> Replying to [comment:10 leif]:
> > After all, not relying on (say) timestamps of headers but recompiling and relinking on every change of a shared library is pretty much against one of their purposes.
> 
> I must say that I find some truth in this.

IMHO rather a matter of enforcing [people to comply with] such convention.  Just like our "manual" spkg dependencies.  (As before, there could be more than one file per library reflecting a significant change that triggers a rebuild.  In fact, for [ELF] shared libraries, the `soname` -- containing the "major" version number -- matters, nothing else [should].)


---

Comment by git created at 2015-11-20 14:08:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2015-11-21 00:39:48

Relying no the timestamp of the header sounds good to me.

It assumes that we don't overlink, but thats obviously to be avoided anyways.


---

Comment by jdemeyer created at 2015-11-21 08:21:08

Changing status from needs_review to positive_review.


---

Comment by leif created at 2015-11-21 15:38:48

So are we confident that

 * this is currently true for all libraries, i.e., an update (or just reinstallation) of each of them causes some of their header(s) to have newer timestamps,
 * all modules linking to them explicitly depend on those,
 * it's sufficiently documented, both for spkg maintainers creating or updating spkgs as well as for reviewers such that they check this still holds?

(I recall in the past occasionally some updates only incidentally worked, but I'm not aware of current trouble besides what Jeroen discovered regarding "overlinking" either.  No idea of how well-documented or -known the potential problems are.)


---

Comment by leif created at 2015-11-21 15:56:21

P.S.:  People adding (or significantly changing) extension modules, or changing `module_list.py` should also know the potential pitfalls.

There should probably be some document / file reflecting which header(s) to use (i.e., to add to a module's `depends`) when linking to some library.  In Sage's `setup.py` we intentionally only add a few `depends` automagically (namely in case a module links to one of the most prominent libraries such as GMP/MPIR).


---

Comment by jdemeyer created at 2015-11-22 10:02:55

Replying to [comment:19 leif]:
> So are we confident that
> 
>  * this is currently true for all libraries, i.e., an update (or just reinstallation) of each of them causes some of their header(s) to have newer timestamps,

I just checked

```
find local/ -type f |xargs ls -l --sort=time
```


and the only old files were from `numpy`. So everything except numpy seems to install everything with recent timestamps.


---

Comment by jdemeyer created at 2015-11-22 10:09:02

Let me also add that using

```
# distutils: ...
```

declarations, the dependency checking is actually easier than the old `src/module_list.py` system. You just need to add the right declarations to the library `.pxd` files.


---

Comment by jdemeyer created at 2015-11-22 10:48:02

Replying to [comment:20 leif]:
> i.e., to add to a module's `depends`

Explicitly using `depends` should only be done in exceptional cases where the normal dependency checking doesn't work. #19610 is such an exceptional case (because the dependency is through a `.c` or `.h` file).


---

Comment by leif created at 2015-11-22 12:01:10

Replying to [comment:22 jdemeyer]:
> Let me also add that using
> {{{
> # distutils: ...
> }}}
> declarations, the dependency checking is actually easier than the old `src/module_list.py` system. You just need to add the right declarations to the library `.pxd` files.

As we have seen, you can easily add `distutils: libraries = foo bar` *without* making the modules _depend_ (in distutils' sense) on the libraries (i.e., their proper headers).  This was more transparent or obvious in our older `module_list.py` (where we by the way could also use things like `uname_specific()`).


---

Comment by vbraun created at 2015-11-22 20:57:46

Resolution: invalid


---

Comment by jdemeyer created at 2015-11-23 07:00:55

Replying to [comment:24 leif]:
> As we have seen, you can easily add `distutils: libraries = foo bar` *without* making the modules _depend_ (in distutils' sense) on the libraries (i.e., their proper headers).

Right, *and this was the reason I created this ticket*.


---

Comment by jdemeyer created at 2015-11-23 07:04:40

Replying to [comment:24 leif]:
> This was more transparent or obvious in our older `module_list.py` (where we by the way could also use things like `uname_specific()`).

I completely disagree with this statement though. Listing libraries in `module_list.py` is much more prone to errors because you manually need to keep track of all libraries that a module uses. Using `module_list.py`, if some module uses PARI functions, I need to change `module_list.py`. With the `# distutils: libraries` declarations, I don't need special effort: I just `cimport sage.libs.pari.foo` and the library gets added automatically.

So I would say that using `# distutils` makes it easier to get it right (but it's still possible to make mistakes of course).


---

Comment by vbraun created at 2015-11-23 07:29:12

Some testing would be nice, e.g. use gcc include dependency output and compare with linked libraries.
