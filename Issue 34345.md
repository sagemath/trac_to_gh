# Issue 34345: Commutative graded algebras: remove sorting restriction

Issue created by migration from https://trac.sagemath.org/ticket/34582

Original creator: jhpalmieri

Original creation time: 2022-09-24 18:53:31

A command like `A.<x,y,z> = GradedCommutativeAlgebra(QQ, degrees=(3,1,2))` raises `ValueError: the generators should be ordered in increasing degree`. I think this is artificial, and if it's important for the code to have sorted generators, the code should handle it, not the user.

There is also a bug that perhaps can be handled in this ticket:

```
sage: A = GradedCommutativeAlgebra(GF(3), names=('h10', 'h11', 'b10', 'h20', 'b11', 'b20'), degrees=((1, 4), (1, 12), (2, 12), (1, 16), (2, 36), (2, 48)))
sage: A.inject_variables()
Defining h10, h11, b10, h20, b11, b20
sage: B = A.cdg_algebra({h20: h10*h11})
sage: B.cohomology_algebra(49)  #  works fine
Commutative Differential Graded Algebra with generators ('x0', 'x1', 'x2', 'x3', 'x4', 'x5') in degrees (5, 13, 14, 22, 30, 38) with relations [x0*x1, x0*x3, x0*x1*x2, x1*x3 + x0*x4, x0*x1*x3, x0*x2*x3, x1*x4, x3^2, x0*x1*x2^2, x0*x1*x4, x1*x2*x3 + x0*x2*x4, x0*x3^2] over Finite Field of size 3 with differential:
   x0 --> 0
   x1 --> 0
   x2 --> 0
   x3 --> 0
   x4 --> 0
   x5 --> 0
sage: B.cohomology_algebra(50)  #  doesn't work
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [79], in <cell line: 1>()
----> 1 B.cohomology_algebra(Integer(50))

...

TypeError: x must be a list of the right length
```

This doesn't happen in the corresponding singly graded case, where each degree is replaced by the total degree: `A = GradedCommutativeAlgebra(GF(3), names=('h10', 'h11', 'b10', 'h20', 'b11', 'b20'), degrees=(5, 13, 14, 17, 38, 50))`. `B.cohomology_generators(n)` also works for values of `n` well past 50. There is an algebra generator and a cohomology generator in total degree 50, by the way.


---

Comment by jhpalmieri created at 2022-09-24 18:58:28

If for some reason we can't change the restriction on ordering, then it must be documented.


---

Comment by jhpalmieri created at 2022-09-24 19:54:51

Another bug?

```
sage: A = GradedCommutativeAlgebra(GF(3), names=('h10', 'h11', 'b10', 'h20', 'b11', 'b20'), degrees=(5, 13, 14, 17, 38, 50))
sage: A.inject_variables()
Defining h10, h11, b10, h20, b11, b20
sage: B = A.cdg_algebra({h20: h10*h11})
sage: C = B.cohomology_algebra(100)
sage: C.inject_variables()
Defining x0, x1, x2, x3, x4, x5, x6
sage: C.differential({x6: x1*x5})
Differential of Commutative Differential Graded Algebra with generators ('x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6') in degrees (5, 13, 14, 22, 30, 38, 50) with relations [x0*x1, x0*x3, x0*x1*x2, x1*x3 + x0*x4, x0*x1*x3, x0*x2*x3, x1*x4, x3^2, x0*x1*x2^2, x0*x1*x4, x1*x2*x3 + x0*x2*x4, x0*x3^2, x3*x4, x0*x1*x2*x3, x0*x2^2*x3, x0*x1*x5, x1*x3^2, x1*x2*x4, x0*x3*x4, x2*x3^2, x0*x1*x2^3, x4^2, x0*x1*x3^2, x0*x1*x2*x4, x1*x2^2*x3 + x0*x2^2*x4, x0*x2*x3^2, x1*x3*x4, x0*x4^2, x0*x3*x5, x3^3, x2*x3*x4, x0*x1*x2^2*x3, x0*x1*x6, x0*x2^3*x3, x0*x1*x3*x4, x0*x1*x2*x5, x1*x2*x3^2, x0*x3^3, x1*x2^2*x4, x0*x2*x3*x4, x2^2*x3^2, x1*x4^2, x1*x3*x5 + x0*x4*x5, x0*x1*x2^4, x3^2*x4, x2*x4^2, x0*x1*x2*x3^2, x0*x1*x2^2*x4, x1*x2^3*x3 + x0*x2^3*x4, x0*x2^2*x3^2, x0*x3*x6, x0*x1*x4^2, x0*x1*x3*x5, x1*x3^3, x1*x2*x3*x4, x0*x3^2*x4, x0*x2*x4^2, x0*x2*x3*x5, x2*x3^3, x2^2*x3*x4, x1*x4*x5, x0*x1*x2^3*x3, x3*x4^2, x3^2*x5, x0*x1*x2*x6, x0*x2^4*x3, x0*x1*x3^3, x0*x1*x2*x3*x4, x0*x1*x2^2*x5, x1*x2^2*x3^2, x0*x2*x3^3, x1*x2^3*x4, x0*x2^2*x3*x4, x1*x3*x6 + x0*x4*x6, x2^3*x3^2, x0*x1*x4*x5, x1*x3^2*x4, x1*x2*x4^2, x0*x3*x4^2, x1*x2*x3*x5 + x0*x2*x4*x5, x0*x3^2*x5, x0*x1*x2^5, x3^4, x2*x3^2*x4, x2^2*x4^2, x0*x1*x2^2*x3^2, x0*x1*x2^3*x4, x4^3, x3*x4*x5, x0*x1*x3*x6, x1*x2^4*x3 + x0*x2^4*x4, x0*x2^3*x3^2, x0*x2*x3*x6, x0*x1*x3^2*x4, x0*x1*x2*x4^2, x0*x1*x2*x3*x5, x1*x2*x3^3, x0*x3^4, x1*x2^2*x3*x4, x0*x2*x3^2*x4, x0*x2^2*x4^2, x0*x2^2*x3*x5, x1*x4*x6, x2^2*x3^3, x2^3*x3*x4, x0*x1*x5^2, x3^2*x6, x1*x3*x4^2, x0*x4^3, x1*x3^2*x5, x1*x2*x4*x5, x0*x3*x4*x5, x0*x1*x2^4*x3, x3^3*x4, x2*x3*x4^2, x2*x3^2*x5, x0*x1*x2^2*x6, x0*x2^5*x3, x0*x1*x2*x3^3, x0*x1*x2^2*x3*x4, x0*x1*x2^3*x5, x4^2*x5, x0*x1*x4*x6, x1*x2^3*x3^2, x0*x2^2*x3^3, x1*x2^4*x4, x0*x2^3*x3*x4, x1*x2*x3*x6 + x0*x2*x4*x6, x0*x3^2*x6, x2^4*x3^2, x0*x1*x3*x4^2, x0*x1*x3^2*x5, x0*x1*x2*x4*x5] over Finite Field of size 3
  Defn: x0 --> 0
        x1 --> 0
        x2 --> 0
        x3 --> 0
        x4 --> 0
        x5 --> 0
        x6 --> 0
sage: x1*x5
x1*x5
sage: x1*x5 == 0
False
sage: x1*x5 != 0
True
```

Why is the differential ending up as zero? It should send `x6` to `x1*x5`.


---

Comment by tscrim created at 2022-09-25 00:20:20

Actually, there is another reason why we should absolutely support arbitrary ordering: The ordering on the variables can change the efficiency of the GrÃ¶bner basis computation. So the CGA itself should allow arbitrary orders and any methods that require the degrees to be sorted to handle that. This would also make it consistent with polynomial rings IIRC.


---

Comment by mmarco created at 2022-09-27 19:51:54

`C` being a cohomology algebra, is created with a zero differential:



```
sage: C
Commutative Differential Graded Algebra with generators ('x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6') in degrees (5, 13, 14, 22, 30, 38, 50) with relations [x0*x1, x0*x3, x0*x1*x2, x1*x3 + x0*x4, x0*x1*x3, x0*x2*x3, x1*x4, x3^2, x0*x1*x2^2, x0*x1*x4, x1*x2*x3 + x0*x2*x4, x0*x3^2, x3*x4, x0*x1*x2*x3, x0*x2^2*x3, x0*x1*x5, x1*x3^2, x1*x2*x4, x0*x3*x4, x2*x3^2, x0*x1*x2^3, x4^2, x0*x1*x3^2, x0*x1*x2*x4, x1*x2^2*x3 + x0*x2^2*x4, x0*x2*x3^2, x1*x3*x4, x0*x4^2, x0*x3*x5, x3^3, x2*x3*x4, x0*x1*x2^2*x3, x0*x1*x6, x0*x2^3*x3, x0*x1*x3*x4, x0*x1*x2*x5, x1*x2*x3^2, x0*x3^3, x1*x2^2*x4, x0*x2*x3*x4, x2^2*x3^2, x1*x4^2, x1*x3*x5 + x0*x4*x5, x0*x1*x2^4, x3^2*x4, x2*x4^2, x0*x1*x2*x3^2, x0*x1*x2^2*x4, x1*x2^3*x3 + x0*x2^3*x4, x0*x2^2*x3^2, x0*x3*x6, x0*x1*x4^2, x0*x1*x3*x5, x1*x3^3, x1*x2*x3*x4, x0*x3^2*x4, x0*x2*x4^2, x0*x2*x3*x5, x2*x3^3, x2^2*x3*x4, x1*x4*x5, x0*x1*x2^3*x3, x3*x4^2, x3^2*x5, x0*x1*x2*x6, x0*x2^4*x3, x0*x1*x3^3, x0*x1*x2*x3*x4, x0*x1*x2^2*x5, x1*x2^2*x3^2, x0*x2*x3^3, x1*x2^3*x4, x0*x2^2*x3*x4, x1*x3*x6 + x0*x4*x6, x2^3*x3^2, x0*x1*x4*x5, x1*x3^2*x4, x1*x2*x4^2, x0*x3*x4^2, x1*x2*x3*x5 + x0*x2*x4*x5, x0*x3^2*x5, x0*x1*x2^5, x3^4, x2*x3^2*x4, x2^2*x4^2, x0*x1*x2^2*x3^2, x0*x1*x2^3*x4, x4^3, x3*x4*x5, x0*x1*x3*x6, x1*x2^4*x3 + x0*x2^4*x4, x0*x2^3*x3^2, x0*x2*x3*x6, x0*x1*x3^2*x4, x0*x1*x2*x4^2, x0*x1*x2*x3*x5, x1*x2*x3^3, x0*x3^4, x1*x2^2*x3*x4, x0*x2*x3^2*x4, x0*x2^2*x4^2, x0*x2^2*x3*x5, x1*x4*x6, x2^2*x3^3, x2^3*x3*x4, x0*x1*x5^2, x3^2*x6, x1*x3*x4^2, x0*x4^3, x1*x3^2*x5, x1*x2*x4*x5, x0*x3*x4*x5, x0*x1*x2^4*x3, x3^3*x4, x2*x3*x4^2, x2*x3^2*x5, x0*x1*x2^2*x6, x0*x2^5*x3, x0*x1*x2*x3^3, x0*x1*x2^2*x3*x4, x0*x1*x2^3*x5, x4^2*x5, x0*x1*x4*x6, x1*x2^3*x3^2, x0*x2^2*x3^3, x1*x2^4*x4, x0*x2^3*x3*x4, x1*x2*x3*x6 + x0*x2*x4*x6, x0*x3^2*x6, x2^4*x3^2, x0*x1*x3*x4^2, x0*x1*x3^2*x5, x0*x1*x2*x4*x5] over Finite Field of size 3 with differential:
   x0 --> 0
   x1 --> 0
   x2 --> 0
   x3 --> 0
   x4 --> 0
   x5 --> 0
   x6 --> 0
```


So when you call its `differential `method, it just returns that already existing map.

I think what you mean to do is this:


```
sage: C1 = C.graded_commutative_algebra()
sage: C1.inject_variables()
Defining x0, x1, x2, x3, x4, x5, x6
sage: C1.differential({x6:x1*x5})
Differential of Graded Commutative Algebra with generators ('x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6') in degrees (5, 13, 14, 22, 30, 38, 50) with relations [x0*x1, x0*x3, x0*x1*x2, x1*x3 + x0*x4, x0*x1*x3, x0*x2*x3, x1*x4, x3^2, x0*x1*x2^2, x0*x1*x4, x1*x2*x3 + x0*x2*x4, x0*x3^2, x3*x4, x0*x1*x2*x3, x0*x2^2*x3, x0*x1*x5, x1*x3^2, x1*x2*x4, x0*x3*x4, x2*x3^2, x0*x1*x2^3, x4^2, x0*x1*x3^2, x0*x1*x2*x4, x1*x2^2*x3 + x0*x2^2*x4, x0*x2*x3^2, x1*x3*x4, x0*x4^2, x0*x3*x5, x3^3, x2*x3*x4, x0*x1*x2^2*x3, x0*x1*x6, x0*x2^3*x3, x0*x1*x3*x4, x0*x1*x2*x5, x1*x2*x3^2, x0*x3^3, x1*x2^2*x4, x0*x2*x3*x4, x2^2*x3^2, x1*x4^2, x1*x3*x5 + x0*x4*x5, x0*x1*x2^4, x3^2*x4, x2*x4^2, x0*x1*x2*x3^2, x0*x1*x2^2*x4, x1*x2^3*x3 + x0*x2^3*x4, x0*x2^2*x3^2, x0*x3*x6, x0*x1*x4^2, x0*x1*x3*x5, x1*x3^3, x1*x2*x3*x4, x0*x3^2*x4, x0*x2*x4^2, x0*x2*x3*x5, x2*x3^3, x2^2*x3*x4, x1*x4*x5, x0*x1*x2^3*x3, x3*x4^2, x3^2*x5, x0*x1*x2*x6, x0*x2^4*x3, x0*x1*x3^3, x0*x1*x2*x3*x4, x0*x1*x2^2*x5, x1*x2^2*x3^2, x0*x2*x3^3, x1*x2^3*x4, x0*x2^2*x3*x4, x1*x3*x6 + x0*x4*x6, x2^3*x3^2, x0*x1*x4*x5, x1*x3^2*x4, x1*x2*x4^2, x0*x3*x4^2, x1*x2*x3*x5 + x0*x2*x4*x5, x0*x3^2*x5, x0*x1*x2^5, x3^4, x2*x3^2*x4, x2^2*x4^2, x0*x1*x2^2*x3^2, x0*x1*x2^3*x4, x4^3, x3*x4*x5, x0*x1*x3*x6, x1*x2^4*x3 + x0*x2^4*x4, x0*x2^3*x3^2, x0*x2*x3*x6, x0*x1*x3^2*x4, x0*x1*x2*x4^2, x0*x1*x2*x3*x5, x1*x2*x3^3, x0*x3^4, x1*x2^2*x3*x4, x0*x2*x3^2*x4, x0*x2^2*x4^2, x0*x2^2*x3*x5, x1*x4*x6, x2^2*x3^3, x2^3*x3*x4, x0*x1*x5^2, x3^2*x6, x1*x3*x4^2, x0*x4^3, x1*x3^2*x5, x1*x2*x4*x5, x0*x3*x4*x5, x0*x1*x2^4*x3, x3^3*x4, x2*x3*x4^2, x2*x3^2*x5, x0*x1*x2^2*x6, x0*x2^5*x3, x0*x1*x2*x3^3, x0*x1*x2^2*x3*x4, x0*x1*x2^3*x5, x4^2*x5, x0*x1*x4*x6, x1*x2^3*x3^2, x0*x2^2*x3^3, x1*x2^4*x4, x0*x2^3*x3*x4, x1*x2*x3*x6 + x0*x2*x4*x6, x0*x3^2*x6, x2^4*x3^2, x0*x1*x3*x4^2, x0*x1*x3^2*x5, x0*x1*x2*x4*x5] over Finite Field of size 3
  Defn: x0 --> 0
        x1 --> 0
        x2 --> 0
        x3 --> 0
        x4 --> 0
        x5 --> 0
        x6 --> x1*x5
```



About the ordering, i think you are right: it would be preferable to be able to give arbitrary orderings, and let sage handle it internally. However, the current code relies on this assumption in several places, so i will need to look at it carefully. Will do it in the following days (or weeks, if life/work gets in the way).


---

Comment by jhpalmieri created at 2022-09-27 19:53:28

Replying to [comment:4 Miguel Marco]:
> About the ordering, i think you are right: it would be preferable to be able to give arbitrary orderings, and let sage handle it internally. However, the current code relies on this assumption in several places, so i will need to look at it carefully. Will do it in the following days (or weeks, if life/work gets in the way).

That would be great, thank you.


---

Comment by jhpalmieri created at 2022-09-27 20:11:23

Replying to [comment:4 Miguel Marco]:
> `C` being a cohomology algebra, is created with a zero differential:
> 
> 
> {{{
> sage: C
> Commutative Differential Graded Algebra with generators ('x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6') in degrees (5, 13, 14, 22, 30, 38, 50) with relations [x0*x1, x0*x3, x0*x1*x2, x1*x3 + x0*x4, x0*x1*x3, x0*x2*x3, x1*x4, x3^2, x0*x1*x2^2, x0*x1*x4, x1*x2*x3 + x0*x2*x4, x0*x3^2, x3*x4, x0*x1*x2*x3, x0*x2^2*x3, x0*x1*x5, x1*x3^2, x1*x2*x4, x0*x3*x4, x2*x3^2, x0*x1*x2^3, x4^2, x0*x1*x3^2, x0*x1*x2*x4, x1*x2^2*x3 + x0*x2^2*x4, x0*x2*x3^2, x1*x3*x4, x0*x4^2, x0*x3*x5, x3^3, x2*x3*x4, x0*x1*x2^2*x3, x0*x1*x6, x0*x2^3*x3, x0*x1*x3*x4, x0*x1*x2*x5, x1*x2*x3^2, x0*x3^3, x1*x2^2*x4, x0*x2*x3*x4, x2<sup>2*x3</sup>2, x1*x4^2, x1*x3*x5 + x0*x4*x5, x0*x1*x2^4, x3^2*x4, x2*x4^2, x0*x1*x2*x3^2, x0*x1*x2^2*x4, x1*x2^3*x3 + x0*x2^3*x4, x0*x2<sup>2*x3</sup>2, x0*x3*x6, x0*x1*x4^2, x0*x1*x3*x5, x1*x3^3, x1*x2*x3*x4, x0*x3^2*x4, x0*x2*x4^2, x0*x2*x3*x5, x2*x3^3, x2^2*x3*x4, x1*x4*x5, x0*x1*x2^3*x3, x3*x4^2, x3^2*x5, x0*x1*x2*x6, x0*x2^4*x3, x0*x1*x3^3, x0*x1*x2*x3*x4, x0*x1*x2^2*x5, x1*x2<sup>2*x3</sup>2, x0*x2*x3^3, x1*x2^3*x4, x0*x2^2*x3*x4, x1*x3*x6 + x0*x4*x6, x2<sup>3*x3</sup>2, x0*x1*x4*x5, x1*x3^2*x4, x1*x2*x4^2, x0*x3*x4^2, x1*x2*x3*x5 + x0*x2*x4*x5, x0*x3^2*x5, x0*x1*x2^5, x3^4, x2*x3^2*x4, x2<sup>2*x4</sup>2, x0*x1*x2<sup>2*x3</sup>2, x0*x1*x2^3*x4, x4^3, x3*x4*x5, x0*x1*x3*x6, x1*x2^4*x3 + x0*x2^4*x4, x0*x2<sup>3*x3</sup>2, x0*x2*x3*x6, x0*x1*x3^2*x4, x0*x1*x2*x4^2, x0*x1*x2*x3*x5, x1*x2*x3^3, x0*x3^4, x1*x2^2*x3*x4, x0*x2*x3^2*x4, x0*x2<sup>2*x4</sup>2, x0*x2^2*x3*x5, x1*x4*x6, x2<sup>2*x3</sup>3, x2^3*x3*x4, x0*x1*x5^2, x3^2*x6, x1*x3*x4^2, x0*x4^3, x1*x3^2*x5, x1*x2*x4*x5, x0*x3*x4*x5, x0*x1*x2^4*x3, x3^3*x4, x2*x3*x4^2, x2*x3^2*x5, x0*x1*x2^2*x6, x0*x2^5*x3, x0*x1*x2*x3^3, x0*x1*x2^2*x3*x4, x0*x1*x2^3*x5, x4^2*x5, x0*x1*x4*x6, x1*x2<sup>3*x3</sup>2, x0*x2<sup>2*x3</sup>3, x1*x2^4*x4, x0*x2^3*x3*x4, x1*x2*x3*x6 + x0*x2*x4*x6, x0*x3^2*x6, x2<sup>4*x3</sup>2, x0*x1*x3*x4^2, x0*x1*x3^2*x5, x0*x1*x2*x4*x5] over Finite Field of size 3 with differential:
>    x0 --> 0
>    x1 --> 0
>    x2 --> 0
>    x3 --> 0
>    x4 --> 0
>    x5 --> 0
>    x6 --> 0
> }}}
> 
> So when you call its `differential `method, it just returns that already existing map.
> 
> I think what you mean to do is this:
> 
> {{{
> sage: C1 = C.graded_commutative_algebra()
> sage: C1.inject_variables()
> Defining x0, x1, x2, x3, x4, x5, x6
> sage: C1.differential({x6:x1*x5})
> Differential of Graded Commutative Algebra with generators ('x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6') in degrees (5, 13, 14, 22, 30, 38, 50) with relations [x0*x1, x0*x3, x0*x1*x2, x1*x3 + x0*x4, x0*x1*x3, x0*x2*x3, x1*x4, x3^2, x0*x1*x2^2, x0*x1*x4, x1*x2*x3 + x0*x2*x4, x0*x3^2, x3*x4, x0*x1*x2*x3, x0*x2^2*x3, x0*x1*x5, x1*x3^2, x1*x2*x4, x0*x3*x4, x2*x3^2, x0*x1*x2^3, x4^2, x0*x1*x3^2, x0*x1*x2*x4, x1*x2^2*x3 + x0*x2^2*x4, x0*x2*x3^2, x1*x3*x4, x0*x4^2, x0*x3*x5, x3^3, x2*x3*x4, x0*x1*x2^2*x3, x0*x1*x6, x0*x2^3*x3, x0*x1*x3*x4, x0*x1*x2*x5, x1*x2*x3^2, x0*x3^3, x1*x2^2*x4, x0*x2*x3*x4, x2<sup>2*x3</sup>2, x1*x4^2, x1*x3*x5 + x0*x4*x5, x0*x1*x2^4, x3^2*x4, x2*x4^2, x0*x1*x2*x3^2, x0*x1*x2^2*x4, x1*x2^3*x3 + x0*x2^3*x4, x0*x2<sup>2*x3</sup>2, x0*x3*x6, x0*x1*x4^2, x0*x1*x3*x5, x1*x3^3, x1*x2*x3*x4, x0*x3^2*x4, x0*x2*x4^2, x0*x2*x3*x5, x2*x3^3, x2^2*x3*x4, x1*x4*x5, x0*x1*x2^3*x3, x3*x4^2, x3^2*x5, x0*x1*x2*x6, x0*x2^4*x3, x0*x1*x3^3, x0*x1*x2*x3*x4, x0*x1*x2^2*x5, x1*x2<sup>2*x3</sup>2, x0*x2*x3^3, x1*x2^3*x4, x0*x2^2*x3*x4, x1*x3*x6 + x0*x4*x6, x2<sup>3*x3</sup>2, x0*x1*x4*x5, x1*x3^2*x4, x1*x2*x4^2, x0*x3*x4^2, x1*x2*x3*x5 + x0*x2*x4*x5, x0*x3^2*x5, x0*x1*x2^5, x3^4, x2*x3^2*x4, x2<sup>2*x4</sup>2, x0*x1*x2<sup>2*x3</sup>2, x0*x1*x2^3*x4, x4^3, x3*x4*x5, x0*x1*x3*x6, x1*x2^4*x3 + x0*x2^4*x4, x0*x2<sup>3*x3</sup>2, x0*x2*x3*x6, x0*x1*x3^2*x4, x0*x1*x2*x4^2, x0*x1*x2*x3*x5, x1*x2*x3^3, x0*x3^4, x1*x2^2*x3*x4, x0*x2*x3^2*x4, x0*x2<sup>2*x4</sup>2, x0*x2^2*x3*x5, x1*x4*x6, x2<sup>2*x3</sup>3, x2^3*x3*x4, x0*x1*x5^2, x3^2*x6, x1*x3*x4^2, x0*x4^3, x1*x3^2*x5, x1*x2*x4*x5, x0*x3*x4*x5, x0*x1*x2^4*x3, x3^3*x4, x2*x3*x4^2, x2*x3^2*x5, x0*x1*x2^2*x6, x0*x2^5*x3, x0*x1*x2*x3^3, x0*x1*x2^2*x3*x4, x0*x1*x2^3*x5, x4^2*x5, x0*x1*x4*x6, x1*x2<sup>3*x3</sup>2, x0*x2<sup>2*x3</sup>3, x1*x2^4*x4, x0*x2^3*x3*x4, x1*x2*x3*x6 + x0*x2*x4*x6, x0*x3^2*x6, x2<sup>4*x3</sup>2, x0*x1*x3*x4^2, x0*x1*x3^2*x5, x0*x1*x2*x4*x5] over Finite Field of size 3
>   Defn: x0 --> 0
>         x1 --> 0
>         x2 --> 0
>         x3 --> 0
>         x4 --> 0
>         x5 --> 0
>         x6 --> x1*x5
> }}}

That makes sense. It bothers me that this doesn't work (with definitions as above):

```
C.cdg_algebra({x6:x1*x5})
Commutative Differential Graded Algebra with generators ... over Finite Field of size 3 with differential:
   x0 --> 0
   x1 --> 0
   x2 --> 0
   x3 --> 0
   x4 --> 0
   x5 --> 0
   x6 --> 0
```

In particular, the documentation for `cdg_algebra` says

```
Construct a differential graded commutative algebra from "self" by
specifying a differential.
```

It seems like this method cannot be used for an algebra which believes it already has a differential, and similarly `differential` can't be used to define a new differential. It looks like `differential` is documented this way, but `cdg_algebra` is just inherited from `GCAlgebra`. I'm thinking that we could instead have a base class like `GCAlgebra` but which does not include `cdg_algebra`, and then `GCAlgebra` would inherit from it and define `cdg_algebra`, while `DifferentialGCAlgebra` would inherit from it without defining `cdg_algebra`.

Maybe also `cohomology_algebra` should return a `GCAlgebra` rather than a `DifferentialGCAlgebra`, or at least provide this as an option.

I was trying to model the first few terms of a particular spectral sequence, so I was trying to define a differential on a cohomology algebra. This feels like a natural thing to try to do.


---

Comment by tscrim created at 2022-09-28 01:06:18

I would say (and I think agree with you) that is a bug. Is there some reason why a GDCA cannot be used as the base for a GDCA by specifying another differential? I wonder if we have just created a technical limitation that could be easily overcome by being more careful with our construction hooks.


---

Comment by jhpalmieri created at 2022-09-30 00:25:56

Another bug, from the example in the ticket description: the algebra `B` has generators in degrees (1, 4), (1, 12), etc., but its cohomology algebra has generators in degrees 5, 13, etc.: we've combined the two gradings. I think that the cohomology algebra should inherit the grading from the CDGA. (Either we check that the differential respects degrees appropriately, or we just assume this.)


---

Comment by mmarco created at 2022-09-30 10:12:04

I have reverted the check for the generators to be given in increasing degree order. I haven't found anything that breaks with  this, but I am afraid something might subtly rely on this assumption, so please review and check thoroughly.

I also implemented a specific `cdg_algebra` method for `DifferentialGCAlgebra` which allows to create a new one by giving a differential.


Again, please test.

Replying to [comment:6 John Palmieri]:
> I was trying to model the first few terms of a particular spectral sequence, so I was trying to define a differential on a cohomology algebra. This feels like a natural thing to try to do.

I would be interested in that. In the Kenzo interface we implemented a spectral sequence class to wrap kenzo's ones. But it could make sense to have a native sage class for that.


---

Comment by jhpalmieri created at 2022-10-01 18:41:41

Replying to [comment:9 Miguel Marco]:
> I have reverted the check for the generators to be given in increasing degree order. I haven't found anything that breaks with  this, but I am afraid something might subtly rely on this assumption, so please review and check thoroughly.
> 
> I also implemented a specific `cdg_algebra` method for `DifferentialGCAlgebra` which allows to create a new one by giving a differential.
> 
> 
> Again, please test.
> 
> Replying to [comment:6 John Palmieri]:
> > I was trying to model the first few terms of a particular spectral sequence, so I was trying to define a differential on a cohomology algebra. This feels like a natural thing to try to do.
> 
> I would be interested in that. In the Kenzo interface we implemented a spectral sequence class to wrap kenzo's ones. But it could make sense to have a native sage class for that.

What I'm doing is very explicit and concrete: a spectral sequence of algebras in which I know the first few differentials, and I was trying to understand whether a particular class survives, so I was trying to see what other classes might be able to hit it.
----
New commits:


---

Comment by jhpalmieri created at 2022-10-01 21:55:21

Replying to [comment:11 John Palmieri]:
> What I'm doing is very explicit and concrete: a spectral sequence of algebras in which I know the first few differentials, and I was trying to understand whether a particular class survives, so I was trying to see what other classes might be able to hit it.

Here is a slightly simpler example than the one I was trying:

```python
p = 2
TOP = 20

names = ['h10', 'h11', 'h20']
degrees = [(1,0,1), (1,0,2), (0, 1, 3)]
total_degs = [sum(x) for x in degrees]

# e1_graded = GradedCommutativeAlgebra(GF(p), names=names, degrees=degrees)
# cohomology_algebra doesn't work with multigrading, so use total degrees instead:
e1_fake = GradedCommutativeAlgebra(GF(p), names=names, degrees=total_degs)
(h10, h11, h20) = e1_fake.gens()
e1 = e1_fake.cdg_algebra({h20: h10*h11})

# would be ideal to have e2 be the cohomology algebra of e1, but
# it doesn't work that well, so recreate it by hand.
# e2_graded = e1.cohomology_algebra(TOP)
# e2_graded_base = GradedCommutativeAlgebra(GF(p), names=('h10, h11, b20'), degrees=((1,0,1), (1,0,2), (0,2,6)))
e2_graded_fake = GradedCommutativeAlgebra(GF(p), names=('h10, h11, b20'), degrees=(2, 3, 8))
(h10, h11, b20) = e2_graded_fake.gens()
e2_graded = e2_graded_fake.quotient(e2_graded_fake.ideal(h10*h11))
e2 = e2_graded.cdg_algebra({b20: h11**3})

# e3_graded = e2.cohomology_algebra(TOP)
# e3_graded_base = GradedCommutativeAlgebra(GF(p), names=('h10, h11, h10b20, b20b20'), degrees=((1,0,1), (1,0,2), (1,2,7), (0,4,12)))
e3_graded_fake = GradedCommutativeAlgebra(GF(p), names=('h10, h11, h10b20, b20b20'), degrees=(2, 3, 10, 16))
(h10, h11, h10b20, b20b20) = e3_graded_fake.gens()
e3_graded = e3_graded_fake.quotient(e3_graded_fake.ideal(h10*h11, h10b20**2 + h10**2 * b20b20, h11*h10b20))
```



---

Comment by jhpalmieri created at 2022-10-01 21:57:52

I should write something that searches for possible differentials in the spectral sequence, but I haven't done that yet.


---

Comment by tscrim created at 2022-10-16 04:49:50

Is this ready to be at needs review? I don't see anything that breaks.


---

Comment by mmarco created at 2022-10-17 14:07:16

If you agree with the current user interface, I think the issues presented in the ticket have been addressed. 

There are other improvements that could be made, but maybe it would be better to handle them in separate tickets.


---

Comment by jhpalmieri created at 2022-10-18 23:20:24

I think we should move ahead with just this. There are other issues (the second issue in the ticket description, which is some weird issue with cohomology generators in the multigraded case, and the issue in comment:8, which is that the cohomology of a multigraded algebra should inherit the multigrading rather than impose a total grading, or at least this should be an option). Those can go on another ticket for improving the situation for multigraded DGAs.


---

Comment by jhpalmieri created at 2022-12-03 22:05:02

Ready for review?


---

Comment by mmarco created at 2022-12-03 22:35:52

I think so, yes.


---

Comment by mmarco created at 2022-12-03 22:35:52

Changing status from new to needs_review.


---

Comment by jhpalmieri created at 2022-12-07 23:08:02

Looks good to me.


---

Comment by tscrim created at 2022-12-09 02:40:02

Likewise modulo the pyflakes saying remove the `multigrade` variable.


---

Comment by jhpalmieri created at 2022-12-09 19:53:50

Replying to [comment:20 Travis Scrimshaw]:
> Likewise modulo the pyflakes saying remove the `multigrade` variable.
Done.
----
New commits:


---

Comment by tscrim created at 2022-12-10 03:27:18

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-12-14 22:12:23

Resolution: fixed
