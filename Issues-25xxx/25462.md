# Issue 25462: make SetPartition much faster

archive/issues_025225.json:
```json
{
    "body": "`SetPartition` uses, as internal representation, a `CloneableArray` with each element being a `Set`. The latter makes the creation and manipulation of set partitions very slow.\n\nMoreover, the current iterator over set partitions is much slower than necessary.\n\nFor example, to generate a list containing the set partitions of a 7 element set, I currently use about 3.3 seconds.  Replacing the iterator with a straightforward algorithm from Ruskey's book I can achieve 470 ms.  Removing the call to Set, this goes down to 16 ms.\n\n\nCC:  @alauve @tscrim @zabrocki\n\nBranch/Commit: ba6a115f30e3b7db0b972c0ec2bf3f511457dad3\n\nReviewer: Mike Zabrocki, Travis Scrimshaw\n\nAuthor: Martin Rubey, Travis Scrimshaw\n\nDependencies: #25497\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/25462\n\n",
    "closed_at": "2018-08-17T21:14:20Z",
    "created_at": "2018-05-30T05:36:12Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.4",
    "title": "make SetPartition much faster",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25462",
    "user": "https://github.com/mantepse"
}
```
`SetPartition` uses, as internal representation, a `CloneableArray` with each element being a `Set`. The latter makes the creation and manipulation of set partitions very slow.

Moreover, the current iterator over set partitions is much slower than necessary.

For example, to generate a list containing the set partitions of a 7 element set, I currently use about 3.3 seconds.  Replacing the iterator with a straightforward algorithm from Ruskey's book I can achieve 470 ms.  Removing the call to Set, this goes down to 16 ms.


CC:  @alauve @tscrim @zabrocki

Branch/Commit: ba6a115f30e3b7db0b972c0ec2bf3f511457dad3

Reviewer: Mike Zabrocki, Travis Scrimshaw

Author: Martin Rubey, Travis Scrimshaw

Dependencies: #25497

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/25462





---

archive/issue_comments_378156.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2018-05-30T05:55:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378156",
    "user": "https://github.com/mantepse"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_378157.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,8 @@\n+`SetPartition` uses, as internal representation, a `CloneableArray` with each element being a `Set`. The latter makes the creation and manipulation of set partitions very slow.\n+\n+Moreover, the current iterator over set partitions is much slower than necessary.\n+\n+For example, to generate a list containing the set partitions of a 7 element set, I currently use about 3.3 seconds.  Replacing the iterator with a straightforward algorithm from Ruskey's book I can achieve 470 ms.  Removing the call to Set, this goes down to 16 ms.\n \n \n Component: PLEASE CHANGE\n```\n",
    "created_at": "2018-05-30T05:55:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378157",
    "user": "https://github.com/mantepse"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,8 @@
+`SetPartition` uses, as internal representation, a `CloneableArray` with each element being a `Set`. The latter makes the creation and manipulation of set partitions very slow.
+
+Moreover, the current iterator over set partitions is much slower than necessary.
+
+For example, to generate a list containing the set partitions of a 7 element set, I currently use about 3.3 seconds.  Replacing the iterator with a straightforward algorithm from Ruskey's book I can achieve 470 ms.  Removing the call to Set, this goes down to 16 ms.
 
 
 Component: PLEASE CHANGE
```




---

archive/issue_comments_378158.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2018-05-30T05:55:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378158",
    "user": "https://github.com/mantepse"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_378159.json:
```json
{
    "body": "<a id='comment:2'></a>The first question is about the internal representation.  Options are:\n\n* a `ClonableArray` of `frozenset`s.  This gives reasonable performance, with hardly any changes in library code.\n\n* a `ClonableArray` of sorted `tuple`s.  This should give much better performance, and is more natural in many situations.  However, it may be surprising to users.\n\n* a totally ordered base set, together with a restricted growth function.",
    "created_at": "2018-05-30T06:13:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378159",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:2'></a>The first question is about the internal representation.  Options are:

* a `ClonableArray` of `frozenset`s.  This gives reasonable performance, with hardly any changes in library code.

* a `ClonableArray` of sorted `tuple`s.  This should give much better performance, and is more natural in many situations.  However, it may be surprising to users.

* a totally ordered base set, together with a restricted growth function.



---

archive/issue_comments_378160.json:
```json
{
    "body": "<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-30T10:10:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378160",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378161.json:
```json
{
    "body": "<a id='comment:5'></a>I would expect that sorted tuples give much worse performance generically when things get large because of the sorting. I have no problem with set partitions being `tuple`s that represent sets, but I would think the code would be more natural/intuitive/readable by using `frozensets`.\n\nQuick comments:\n\n```\n-len(z.intersection(p)) != 0\n+z.intersection(p)\n```\nis a faster test for non-emptiness.\n\nI don't like going to a recursive algorithm; Python's recursion check limit gets in the way of computing large examples. Also, why is this iterator faster? Is it because it does not create so much transient (Sage) objects? I think it would be better to explicit implement a backtracking version instead of the recursion (you will also get fewer transient objects and could do this in Cython for speed).\n\nYour `from_word`, you could create `set`s, which is more efficient to convert to a `frozenset`:\n\n```\nsage: X = set([1,2,3])\nsage: L = [1,2,3]\nsage: %timeit frozenset(X)\n10000000 loops, best of 3: 128 ns per loop\nsage: %timeit frozenset(L)\n1000000 loops, best of 3: 193 ns per loop\n\nsage: X = set(range(12))\nsage: L = list(range(12))\nsage: %timeit frozenset(X)\n1000000 loops, best of 3: 269 ns per loop\nsage: %timeit frozenset(L)\n1000000 loops, best of 3: 399 ns per loop\n```",
    "created_at": "2018-05-31T05:11:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378161",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:5'></a>I would expect that sorted tuples give much worse performance generically when things get large because of the sorting. I have no problem with set partitions being `tuple`s that represent sets, but I would think the code would be more natural/intuitive/readable by using `frozensets`.

Quick comments:

```
-len(z.intersection(p)) != 0
+z.intersection(p)
```
is a faster test for non-emptiness.

I don't like going to a recursive algorithm; Python's recursion check limit gets in the way of computing large examples. Also, why is this iterator faster? Is it because it does not create so much transient (Sage) objects? I think it would be better to explicit implement a backtracking version instead of the recursion (you will also get fewer transient objects and could do this in Cython for speed).

Your `from_word`, you could create `set`s, which is more efficient to convert to a `frozenset`:

```
sage: X = set([1,2,3])
sage: L = [1,2,3]
sage: %timeit frozenset(X)
10000000 loops, best of 3: 128 ns per loop
sage: %timeit frozenset(L)
1000000 loops, best of 3: 193 ns per loop

sage: X = set(range(12))
sage: L = list(range(12))
sage: %timeit frozenset(X)
1000000 loops, best of 3: 269 ns per loop
sage: %timeit frozenset(L)
1000000 loops, best of 3: 399 ns per loop
```



---

archive/issue_comments_378162.json:
```json
{
    "body": "<a id='comment:6'></a>Also, likely only you would be able to work with a set partition if it was internally given by a restricted growth function. So that is a non-starter for me.",
    "created_at": "2018-05-31T05:13:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378162",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>Also, likely only you would be able to work with a set partition if it was internally given by a restricted growth function. So that is a non-starter for me.



---

archive/issue_comments_378163.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-01T07:56:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378163",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378164.json:
```json
{
    "body": "<a id='comment:8'></a>Dear Travis! Thank you very much for your comments!\n\nI have now included an alternative iterator, due to Knuth.  It is a small bit faster and non-recursive.  However, I find it quite a bit more difficult to understand.\n\nPlease let me know whether you prefer it.\n\n> Your `from_word`, you could create `set`s, which is more efficient to convert to a `frozenset`\n\n\nin principle this is true, however, I have to `add` elements (which I know to be distinct, but I cannot take advantage of this) to each of the blocks all the time.  It turns out that appending to lists and then converting to a `frozenset` is (marginally) faster.\n\n> I don't like going to a recursive algorithm; Python's recursion check limit gets in the way of computing large examples. Also, why is this iterator faster? Is it because it does not create so much transient (Sage) objects? I think it would be better to explicit implement a backtracking version instead of the recursion (you will also get fewer transient objects and could do this in Cython for speed).\n\n\nI think that one reason - apart from using `OrderedSetPartitions`, is that the original iterator does something much more complicated: you can prescribe the sizes of the blocks, too.  I can have a short look whether we gain much by changing the internal representation of `OrderedSetPartition`.  I must admit that I have not yet understood the iterator.\n\nI have also implemented (but not yet committed) a (recursive) iterator for generating set partitions into a given number of blocks.  I'm afraid I do not have a non-recursive version of that one.\n\nIf possible, could you give a use case for iterating over set partitions (into k blocks) where we hit the recursion limit?  When the number of blocks is unrestricted, I am hitting it for set partitions of a 983-element set.",
    "created_at": "2018-06-01T08:14:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378164",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:8'></a>Dear Travis! Thank you very much for your comments!

I have now included an alternative iterator, due to Knuth.  It is a small bit faster and non-recursive.  However, I find it quite a bit more difficult to understand.

Please let me know whether you prefer it.

> Your `from_word`, you could create `set`s, which is more efficient to convert to a `frozenset`


in principle this is true, however, I have to `add` elements (which I know to be distinct, but I cannot take advantage of this) to each of the blocks all the time.  It turns out that appending to lists and then converting to a `frozenset` is (marginally) faster.

> I don't like going to a recursive algorithm; Python's recursion check limit gets in the way of computing large examples. Also, why is this iterator faster? Is it because it does not create so much transient (Sage) objects? I think it would be better to explicit implement a backtracking version instead of the recursion (you will also get fewer transient objects and could do this in Cython for speed).


I think that one reason - apart from using `OrderedSetPartitions`, is that the original iterator does something much more complicated: you can prescribe the sizes of the blocks, too.  I can have a short look whether we gain much by changing the internal representation of `OrderedSetPartition`.  I must admit that I have not yet understood the iterator.

I have also implemented (but not yet committed) a (recursive) iterator for generating set partitions into a given number of blocks.  I'm afraid I do not have a non-recursive version of that one.

If possible, could you give a use case for iterating over set partitions (into k blocks) where we hit the recursion limit?  When the number of blocks is unrestricted, I am hitting it for set partitions of a 983-element set.



---

archive/issue_comments_378165.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:8 mantepse]:\n> I have now included an alternative iterator, due to Knuth.  It is a small bit faster and non-recursive.  However, I find it quite a bit more difficult to understand.\n> \n> Please let me know whether you prefer it.\n\n\nYes, I do. Thank you.\n\n> > I don't like going to a recursive algorithm; Python's recursion check limit gets in the way of computing large examples. Also, why is this iterator faster? Is it because it does not create so much transient (Sage) objects? I think it would be better to explicit implement a backtracking version instead of the recursion (you will also get fewer transient objects and could do this in Cython for speed).\n\n> \n> I think that one reason - apart from using `OrderedSetPartitions`, is that the original iterator does something much more complicated: you can prescribe the sizes of the blocks, too.  I can have a short look whether we gain much by changing the internal representation of `OrderedSetPartition`.  I must admit that I have not yet understood the iterator.\n> \n> I have also implemented (but not yet committed) a (recursive) iterator for generating set partitions into a given number of blocks.  I'm afraid I do not have a non-recursive version of that one.\n\n\nI don't think that would be any worse than the current version. From a quick test, I get a recursion depth error for this:\n\n```\nsage: SP = SetPartitions(5000, Partition([5]*1000))\nsage: it = iter(SP)\nsage: it.next()\n```\n\nAt one point I understood how `OrderedSetPartitions` iterator worked, but I have forgotten.\n\n> If possible, could you give a use case for iterating over set partitions (into k blocks) where we hit the recursion limit?  When the number of blocks is unrestricted, I am hitting it for set partitions of a 983-element set.\n\n\nWith combinatorial objects, we can sometimes test conjectures on very large objects. Say you want to test the first million of set partitions of 5000 with 1000 parts. Basically it becomes an artificial  limitation; plus, recursion is relatively slow.",
    "created_at": "2018-06-01T09:07:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378165",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>Replying to [comment:8 mantepse]:
> I have now included an alternative iterator, due to Knuth.  It is a small bit faster and non-recursive.  However, I find it quite a bit more difficult to understand.
> 
> Please let me know whether you prefer it.


Yes, I do. Thank you.

> > I don't like going to a recursive algorithm; Python's recursion check limit gets in the way of computing large examples. Also, why is this iterator faster? Is it because it does not create so much transient (Sage) objects? I think it would be better to explicit implement a backtracking version instead of the recursion (you will also get fewer transient objects and could do this in Cython for speed).

> 
> I think that one reason - apart from using `OrderedSetPartitions`, is that the original iterator does something much more complicated: you can prescribe the sizes of the blocks, too.  I can have a short look whether we gain much by changing the internal representation of `OrderedSetPartition`.  I must admit that I have not yet understood the iterator.
> 
> I have also implemented (but not yet committed) a (recursive) iterator for generating set partitions into a given number of blocks.  I'm afraid I do not have a non-recursive version of that one.


I don't think that would be any worse than the current version. From a quick test, I get a recursion depth error for this:

```
sage: SP = SetPartitions(5000, Partition([5]*1000))
sage: it = iter(SP)
sage: it.next()
```

At one point I understood how `OrderedSetPartitions` iterator worked, but I have forgotten.

> If possible, could you give a use case for iterating over set partitions (into k blocks) where we hit the recursion limit?  When the number of blocks is unrestricted, I am hitting it for set partitions of a 983-element set.


With combinatorial objects, we can sometimes test conjectures on very large objects. Say you want to test the first million of set partitions of 5000 with 1000 parts. Basically it becomes an artificial  limitation; plus, recursion is relatively slow.



---

archive/issue_comments_378166.json:
```json
{
    "body": "<a id='comment:10'></a>Great!\n\n> With combinatorial objects, we can sometimes test conjectures on very large objects. Say you want to test the first million of set partitions of 5000 with 1000 parts. Basically it becomes an artificial limitation; plus, recursion is relatively slow. \n\n\nOK, but for that purpose I have already implemented random generation :-) - hm, not for set partitions with given block sizes though :-(",
    "created_at": "2018-06-01T10:40:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378166",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:10'></a>Great!

> With combinatorial objects, we can sometimes test conjectures on very large objects. Say you want to test the first million of set partitions of 5000 with 1000 parts. Basically it becomes an artificial limitation; plus, recursion is relatively slow. 


OK, but for that purpose I have already implemented random generation :-) - hm, not for set partitions with given block sizes though :-(



---

archive/issue_comments_378167.json:
```json
{
    "body": "<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-01T10:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378167",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378168.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-01T14:30:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378168",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378169.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-06-01T14:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378169",
    "user": "https://github.com/mantepse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_378170.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-01T19:52:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378170",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378171.json:
```json
{
    "body": "<a id='comment:15'></a>I am not sure about\n\n```\nsage: Set([1]) == frozenset([1])\nFalse\nsage: Set([1]) == set([1])\nFalse\nsage: set([1]) == frozenset([1])\nTrue\n```\nshouldn't that be true always?",
    "created_at": "2018-06-01T19:57:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378171",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:15'></a>I am not sure about

```
sage: Set([1]) == frozenset([1])
False
sage: Set([1]) == set([1])
False
sage: set([1]) == frozenset([1])
True
```
shouldn't that be true always?



---

archive/issue_comments_378172.json:
```json
{
    "body": "<a id='comment:16'></a>I am inclined to say yes and that is a bug in `Set`.",
    "created_at": "2018-06-02T05:11:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378172",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>I am inclined to say yes and that is a bug in `Set`.



---

archive/issue_comments_378173.json:
```json
{
    "body": "<a id='comment:17'></a>See #25497",
    "created_at": "2018-06-02T09:53:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378173",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:17'></a>See #25497



---

archive/issue_comments_378174.json:
```json
{
    "body": "<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-02T18:34:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378174",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378175.json:
```json
{
    "body": "<a id='comment:21'></a>It turns out that I have another question:\n\nCurrently, for two set partitions `s` and `t` we have `s < t` if turning them into lists (sorting each block into increasing order, then the set of blocks by minimal element) makes `s` come before `t` in lexicographic order.\n\nThis leads to strange results, for example:\n\n```\nsage: it = SetPartitions().__iter__()\nsage: sorted(next(it) for x in range(10))\n[{},\n {{1}},\n {{1}, {2}},\n {{1}, {2}, {3}},\n {{1}, {2, 3}},\n {{1, 2}},\n {{1, 2}, {3}},\n {{1, 2, 3}},\n {{1, 2, 3, 4}},\n {{1, 3}, {2}}]\n```\nNote that `{{1},{2,3}}` comes before `{{1,2}}`.\n\nI would rather first sort by size, then by the number of blocks, and finally lexicographically.\n\nShould I do this?",
    "created_at": "2018-06-02T18:55:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378175",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:21'></a>It turns out that I have another question:

Currently, for two set partitions `s` and `t` we have `s < t` if turning them into lists (sorting each block into increasing order, then the set of blocks by minimal element) makes `s` come before `t` in lexicographic order.

This leads to strange results, for example:

```
sage: it = SetPartitions().__iter__()
sage: sorted(next(it) for x in range(10))
[{},
 {{1}},
 {{1}, {2}},
 {{1}, {2}, {3}},
 {{1}, {2, 3}},
 {{1, 2}},
 {{1, 2}, {3}},
 {{1, 2, 3}},
 {{1, 2, 3, 4}},
 {{1, 3}, {2}}]
```
Note that `{{1},{2,3}}` comes before `{{1,2}}`.

I would rather first sort by size, then by the number of blocks, and finally lexicographically.

Should I do this?



---

archive/issue_comments_378176.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-06-02T18:56:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378176",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_378177.json:
```json
{
    "body": "<a id='comment:23'></a>Replying to [comment:21 mantepse]:\n> It turns out that I have another question:\n> \n> Currently, for two set partitions `s` and `t` we have `s < t` if turning them into lists (sorting each block into increasing order, then the set of blocks by minimal element) makes `s` come before `t` in lexicographic order.\n> \n> This leads to strange results, for example:\n> \n> ```\n> sage: it = SetPartitions().__iter__()\n> sage: sorted(next(it) for x in range(10))\n> [{},\n>  {{1}},\n>  {{1}, {2}},\n>  {{1}, {2}, {3}},\n>  {{1}, {2, 3}},\n>  {{1, 2}},\n>  {{1, 2}, {3}},\n>  {{1, 2, 3}},\n>  {{1, 2, 3, 4}},\n>  {{1, 3}, {2}}]\n> ```\n> Note that `{{1},{2,3}}` comes before `{{1,2}}`.\n> \n> I would rather first sort by size, then by the number of blocks, and finally lexicographically.\n> \n> Should I do this?\n\n\nI think the current behavior is fine, but your choice is natural too. Irregardless that should be a separate ticket.",
    "created_at": "2018-06-04T00:31:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378177",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:23'></a>Replying to [comment:21 mantepse]:
> It turns out that I have another question:
> 
> Currently, for two set partitions `s` and `t` we have `s < t` if turning them into lists (sorting each block into increasing order, then the set of blocks by minimal element) makes `s` come before `t` in lexicographic order.
> 
> This leads to strange results, for example:
> 
> ```
> sage: it = SetPartitions().__iter__()
> sage: sorted(next(it) for x in range(10))
> [{},
>  {{1}},
>  {{1}, {2}},
>  {{1}, {2}, {3}},
>  {{1}, {2, 3}},
>  {{1, 2}},
>  {{1, 2}, {3}},
>  {{1, 2, 3}},
>  {{1, 2, 3, 4}},
>  {{1, 3}, {2}}]
> ```
> Note that `{{1},{2,3}}` comes before `{{1,2}}`.
> 
> I would rather first sort by size, then by the number of blocks, and finally lexicographically.
> 
> Should I do this?


I think the current behavior is fine, but your choice is natural too. Irregardless that should be a separate ticket.



---

archive/issue_comments_378178.json:
```json
{
    "body": "<a id='comment:24'></a>The problem is that the new iterator produces the set partitions in different order, which makes something like 30 doctests fail in `diagram_algebras.py`. I thought of replacing doctests like\n\n```\nP.basis().list()\n```\nwith\n\n```\nset(P.basis())\n```\nand\nto make them more robust, but then the sorting order is weird.",
    "created_at": "2018-06-04T08:33:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378178",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:24'></a>The problem is that the new iterator produces the set partitions in different order, which makes something like 30 doctests fail in `diagram_algebras.py`. I thought of replacing doctests like

```
P.basis().list()
```
with

```
set(P.basis())
```
and
to make them more robust, but then the sorting order is weird.



---

archive/issue_comments_378179.json:
```json
{
    "body": "<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-22T22:12:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378179",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378180.json:
```json
{
    "body": "<a id='comment:26'></a>I finally decided to simply adapt the doctests to the new iterator.",
    "created_at": "2018-06-22T22:18:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378180",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:26'></a>I finally decided to simply adapt the doctests to the new iterator.



---

archive/issue_comments_378181.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-06-22T22:18:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378181",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_378182.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-23T07:36:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378182",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378183.json:
```json
{
    "body": "<a id='comment:29'></a>Dear Aaron and Mike!\n\nsince my original motivation was to do some computations with the orbit basis, and this ticket makes these computations a bit faster, maybe you could have a look?\n\nFor example (on 8.3.beta6):\n\n```\nsage: P5 = PartitionAlgebra(5, 2, ZZ); O5 = P5.orbit_basis(); O5\nOrbit basis of Partition Algebra of rank 5 with parameter 2 over Integer Ring\nsage: o1 = O5([[1,2,3,-1,-2,-3], [4,-4],[5,-5]])\nsage: o2 = P5([[1,-1],[2],[3],[-2],[-3], [4],[-4],[5,-5]])\nsage: o3 = O5([[1,2,-2,-1],[3,-3],[4,-4],[-5,-5]])\nsage: %timeit o1*o2*o3\n1 loop, best of 3: 24.9 s per loop\nsage: \n```\nwith this ticket:\n\n```\nsage: %timeit o1*o2*o3\n1 loop, best of 3: 1.07 s per loop\n```",
    "created_at": "2018-06-23T09:27:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378183",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:29'></a>Dear Aaron and Mike!

since my original motivation was to do some computations with the orbit basis, and this ticket makes these computations a bit faster, maybe you could have a look?

For example (on 8.3.beta6):

```
sage: P5 = PartitionAlgebra(5, 2, ZZ); O5 = P5.orbit_basis(); O5
Orbit basis of Partition Algebra of rank 5 with parameter 2 over Integer Ring
sage: o1 = O5([[1,2,3,-1,-2,-3], [4,-4],[5,-5]])
sage: o2 = P5([[1,-1],[2],[3],[-2],[-3], [4],[-4],[5,-5]])
sage: o3 = O5([[1,2,-2,-1],[3,-3],[4,-4],[-5,-5]])
sage: %timeit o1*o2*o3
1 loop, best of 3: 24.9 s per loop
sage: 
```
with this ticket:

```
sage: %timeit o1*o2*o3
1 loop, best of 3: 1.07 s per loop
```



---

archive/issue_comments_378184.json:
```json
{
    "body": "<a id='comment:30'></a>I had some programs that checked an identity in the orbit basis that I used as an additional test.  The speedup is really good (3m50s vs. 9m4s) and the computation is correct.",
    "created_at": "2018-06-24T11:14:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378184",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:30'></a>I had some programs that checked an identity in the orbit basis that I used as an additional test.  The speedup is really good (3m50s vs. 9m4s) and the computation is correct.



---

archive/issue_comments_378185.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-06-24T11:14:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378185",
    "user": "https://github.com/zabrocki"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_378186.json:
```json
{
    "body": "<a id='comment:31'></a>So there are a few things that warrant a second look:\n\n- Changing `self.n` to `self._k`. While this is the correct thing to do, this is a backwards incompatible change and requires deprecation (it is public). I think you should have `n` as a lazy attribute that raises the deprecation warning saying that it will become a method (there needs to be a public way to get this information).\n- `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.\n- What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?\n- You have changed the behavior of `partition_diagrams` (at least on Python2) as `map` returns a list. I think it would be better to keep it as an explicit iterator.",
    "created_at": "2018-06-24T12:40:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378186",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:31'></a>So there are a few things that warrant a second look:

- Changing `self.n` to `self._k`. While this is the correct thing to do, this is a backwards incompatible change and requires deprecation (it is public). I think you should have `n` as a lazy attribute that raises the deprecation warning saying that it will become a method (there needs to be a public way to get this information).
- `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.
- What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?
- You have changed the behavior of `partition_diagrams` (at least on Python2) as `map` returns a list. I think it would be better to keep it as an explicit iterator.



---

archive/issue_comments_378187.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2018-06-24T12:40:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378187",
    "user": "https://github.com/tscrim"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_378188.json:
```json
{
    "body": "<a id='comment:32'></a>Replying to [comment:31 tscrim]:\n> So there are a few things that warrant a second look:\n> \n> - Changing `self.n` to `self._k`. While this is the correct thing to do, this is a backwards incompatible change and requires deprecation (it is public). I think you should have `n` as a lazy attribute that raises the deprecation warning saying that it will become a method (there needs to be a public way to get this information).\n\n\nCould you please provide a code snippet?  I do not know what a lazy attribute is, sorry.\n\n> - `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.\n\n\nRight.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.\n\n> - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?\n\n\nI have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.\n\n> - You have changed the behavior of `partition_diagrams` (at least on Python2) as `map` returns a list. I think it would be better to keep it as an explicit iterator.\n\n\nOh, I didn't know that.  Thanks, will do!",
    "created_at": "2018-06-24T20:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378188",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:32'></a>Replying to [comment:31 tscrim]:
> So there are a few things that warrant a second look:
> 
> - Changing `self.n` to `self._k`. While this is the correct thing to do, this is a backwards incompatible change and requires deprecation (it is public). I think you should have `n` as a lazy attribute that raises the deprecation warning saying that it will become a method (there needs to be a public way to get this information).


Could you please provide a code snippet?  I do not know what a lazy attribute is, sorry.

> - `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.


Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.

> - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?


I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.

> - You have changed the behavior of `partition_diagrams` (at least on Python2) as `map` returns a list. I think it would be better to keep it as an explicit iterator.


Oh, I didn't know that.  Thanks, will do!



---

archive/issue_comments_378189.json:
```json
{
    "body": "<a id='comment:33'></a>Hi Travis,\n\njust found http://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_attribute.html, so I'm all set!",
    "created_at": "2018-06-24T20:24:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378189",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:33'></a>Hi Travis,

just found http://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_attribute.html, so I'm all set!



---

archive/issue_comments_378190.json:
```json
{
    "body": "<a id='comment:34'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-24T21:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378190",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:34'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378191.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-06-24T21:48:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378191",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_378192.json:
```json
{
    "body": "<a id='comment:36'></a>I don't care for `itertools.imap`. It looks kind of ugly, and I am not certain it is Python3 compatible. IMO, it is better to write a loop with a `yield`.",
    "created_at": "2018-06-25T06:15:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378192",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:36'></a>I don't care for `itertools.imap`. It looks kind of ugly, and I am not certain it is Python3 compatible. IMO, it is better to write a loop with a `yield`.



---

archive/issue_comments_378193.json:
```json
{
    "body": "<a id='comment:37'></a>Also, `this class` to either ```self``` or something like `these set partitions` (I prefer the former).",
    "created_at": "2018-06-25T06:16:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378193",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:37'></a>Also, `this class` to either ```self``` or something like `these set partitions` (I prefer the former).



---

archive/issue_comments_378194.json:
```json
{
    "body": "<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-25T08:13:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378194",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378195.json:
```json
{
    "body": "<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-25T08:50:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378195",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378196.json:
```json
{
    "body": "<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-25T09:00:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378196",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378197.json:
```json
{
    "body": "<a id='comment:41'></a>Replying to [comment:32 mantepse]:\n> Replying to [comment:31 tscrim]:\n> > - `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.\n \n> \n> Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.\n\n\nReally? That smells like a bug. Either that or the original code had a bug and you need to add a doctest showing it is fixed.\n\n> > - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?\n \n> \n> I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.\n\n\nYour iterator creates an actual element of the parent, which has overhead. I don't see why you are not rewriting `_iterator_part` with the new algorithm and using that.\n\nAlso please force-push this branch back to the earlier commit to remove 09bd542.",
    "created_at": "2018-06-26T07:13:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378197",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:41'></a>Replying to [comment:32 mantepse]:
> Replying to [comment:31 tscrim]:
> > - `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.
 
> 
> Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.


Really? That smells like a bug. Either that or the original code had a bug and you need to add a doctest showing it is fixed.

> > - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?
 
> 
> I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.


Your iterator creates an actual element of the parent, which has overhead. I don't see why you are not rewriting `_iterator_part` with the new algorithm and using that.

Also please force-push this branch back to the earlier commit to remove 09bd542.



---

archive/issue_comments_378198.json:
```json
{
    "body": "<a id='comment:42'></a>Replying to [comment:41 tscrim]:\n> Replying to [comment:32 mantepse]:\n> > Replying to [comment:31 tscrim]:\n> > > - `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.\n \n> > \n> > Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.\n  \n> \n> Really? That smells like a bug. Either that or the original code had a bug and you need to add a doctest showing it is fixed.\n\n\nNo, the original code took the first and the second element of the `Set` `a`, I take, for simplicity the smallest and the largest.\n\n> > > - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?\n \n> > \n> > I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.\n\n> \n> Your iterator creates an actual element of the parent, which has overhead. I don't see why you are not rewriting `_iterator_part` with the new algorithm and using that.\n\n\nI do not understand.  `SetPartitions._iterator_part` is **very** slow, and I have no new algorithm for it, and it is not completely trivial to improve it.\n \n> Also please force-push this branch back to the earlier commit to remove 09bd542.\n\n\nHow do I do this?",
    "created_at": "2018-06-26T07:30:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378198",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:42'></a>Replying to [comment:41 tscrim]:
> Replying to [comment:32 mantepse]:
> > Replying to [comment:31 tscrim]:
> > > - `x, y = min(a), max(a)` is better as `x, y = sorted(a)` as the latter forces `a` to have length 2.
 
> > 
> > Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.
  
> 
> Really? That smells like a bug. Either that or the original code had a bug and you need to add a doctest showing it is fixed.


No, the original code took the first and the second element of the `Set` `a`, I take, for simplicity the smallest and the largest.

> > > - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?
 
> > 
> > I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.

> 
> Your iterator creates an actual element of the parent, which has overhead. I don't see why you are not rewriting `_iterator_part` with the new algorithm and using that.


I do not understand.  `SetPartitions._iterator_part` is **very** slow, and I have no new algorithm for it, and it is not completely trivial to improve it.
 
> Also please force-push this branch back to the earlier commit to remove 09bd542.


How do I do this?



---

archive/issue_comments_378199.json:
```json
{
    "body": "<a id='comment:43'></a>> > > Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.\n  \nMost of the time the `atoms_of_congruence_lattice` have parts of size greater than 2 (in fact, just testing a number of lattices they are often just one block) and this algorithm returns two elements from those blocks.  You might be able to speed this up in some cases by turning `a` into a list and taking the first and second elements, but this doesn't seem like it would be more efficient in general.\n\n> > > > - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?\n \n> > > \n> > > I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.\n\n> > \n> > Your iterator creates an actual element of the parent, which has overhead. I don't see why you are not rewriting `_iterator_part` with the new algorithm and using that.\n\nI checked and `_iterator_part` is returning a set of sets.  What do you suggest it should return?\n\n```\nsage: SetPartitions(6)._iterator_part(Partition([3,2,1])).next().parent()\n<class 'sage.sets.set.Set_object_enumerated_with_category'>\n```\n\n> > Also please force-push this branch back to the earlier commit to remove 09bd542.\n\n> \n> How do I do this?\n\nReading here: https://stackoverflow.com/questions/34519665/how-to-move-head-back-to-a-previous-location-detached-head/34519716#34519716\n\n```\ngit reset --hard \u200bca293e3\n```",
    "created_at": "2018-06-27T12:46:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378199",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:43'></a>> > > Right.  In fact, I do not know what would be correct.  It did not work with `x, y = sorted(a)`, if I remember correctly - sometimes `a` has length greater than 2.
  
Most of the time the `atoms_of_congruence_lattice` have parts of size greater than 2 (in fact, just testing a number of lattices they are often just one block) and this algorithm returns two elements from those blocks.  You might be able to speed this up in some cases by turning `a` into a list and taking the first and second elements, but this doesn't seem like it would be more efficient in general.

> > > > - What about using `_iterator_part` for returning objects that are not elements of set partition, which do have some overhead?
 
> > > 
> > > I have no idea what you mean, please expand.  I wouldn't mind speeding up `_iterator_part`, too, but this looks far more difficult to do.

> > 
> > Your iterator creates an actual element of the parent, which has overhead. I don't see why you are not rewriting `_iterator_part` with the new algorithm and using that.

I checked and `_iterator_part` is returning a set of sets.  What do you suggest it should return?

```
sage: SetPartitions(6)._iterator_part(Partition([3,2,1])).next().parent()
<class 'sage.sets.set.Set_object_enumerated_with_category'>
```

> > Also please force-push this branch back to the earlier commit to remove 09bd542.

> 
> How do I do this?

Reading here: https://stackoverflow.com/questions/34519665/how-to-move-head-back-to-a-previous-location-detached-head/34519716#34519716

```
git reset --hard ​ca293e3
```



---

archive/issue_comments_378200.json:
```json
{
    "body": "<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-06-27T13:11:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378200",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_378201.json:
```json
{
    "body": "<a id='comment:45'></a>The patchbot produces a different `an_example` than my machine :-(",
    "created_at": "2018-07-02T11:45:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378201",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:45'></a>The patchbot produces a different `an_example` than my machine :-(



---

archive/issue_comments_378202.json:
```json
{
    "body": "<a id='comment:46'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-05T09:28:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378202",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:46'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378203.json:
```json
{
    "body": "<a id='comment:47'></a>I hope this is better now...",
    "created_at": "2018-07-05T09:29:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378203",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:47'></a>I hope this is better now...



---

archive/issue_comments_378204.json:
```json
{
    "body": "<a id='comment:48'></a>The patchbots now only report errors unrelated to this ticket.  Please review!",
    "created_at": "2018-07-05T11:23:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378204",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:48'></a>The patchbots now only report errors unrelated to this ticket.  Please review!



---

archive/issue_comments_378205.json:
```json
{
    "body": "<a id='comment:49'></a>I agree that the `an_element` doctests seemed to be machine dependent, but I restored some of the doctests which were not linear combinations with coefficient 1.\n\n---\nLast 10 new commits:",
    "created_at": "2018-07-06T12:36:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378205",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:49'></a>I agree that the `an_element` doctests seemed to be machine dependent, but I restored some of the doctests which were not linear combinations with coefficient 1.

---
Last 10 new commits:



---

archive/issue_comments_378206.json:
```json
{
    "body": "<a id='comment:50'></a>Thank you!  Looks OK to me, except that I am slightly sceptical about the `S.an_element` :-)",
    "created_at": "2018-07-06T13:49:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378206",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:50'></a>Thank you!  Looks OK to me, except that I am slightly sceptical about the `S.an_element` :-)



---

archive/issue_comments_378207.json:
```json
{
    "body": "<a id='comment:51'></a>Tests pass on my machine.",
    "created_at": "2018-07-09T19:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378207",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:51'></a>Tests pass on my machine.



---

archive/issue_comments_378208.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-07-09T19:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378208",
    "user": "https://github.com/zabrocki"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_378209.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2018-07-09T20:08:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378209",
    "user": "https://github.com/tscrim"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_378210.json:
```json
{
    "body": "<a id='comment:52'></a>I still have some comments, but I have not yet found the time to give them. I will try to do that by tomorrow.",
    "created_at": "2018-07-09T20:08:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378210",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:52'></a>I still have some comments, but I have not yet found the time to give them. I will try to do that by tomorrow.



---

archive/issue_comments_378211.json:
```json
{
    "body": "<a id='comment:53'></a>Oh, I see, the iterator is for all set partitions, not with a fixed set size. However, I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`. I also think `_iterator_parts` should be consistent and return lists of frozensets. Would it also be possible to modify the Knuth algorithm for `_iterator_parts`?\n\nThis is horrible code:\n\n```sage\n            try:\n                tst = frozenset(e for B in self._base_diagram for e in B)\n                if tst != self.parent()._set:\n                    raise TypeError\n            except TypeError:\n```\nYou should not dictate program flow by raising an error. Just let the fact that `B` is non-iterable propagate up; you do not need to have the \"perfect\" error message.\n\nThis change\n\n```diff\ndiff --git a/src/sage/groups/perm_gps/symgp_conjugacy_class.py b/src/sage/groups/perm_gps/symgp_conjugacy_class.py\nindex 3b55bcf..5e28f8d 100644\n--- a/src/sage/groups/perm_gps/symgp_conjugacy_class.py\n+++ b/src/sage/groups/perm_gps/symgp_conjugacy_class.py\n@@ -360,8 +360,9 @@ def conjugacy_class_iterator(part, S=None):\n \n     m = len(part)\n     for s in SetPartitions(S, part):\n-        firsts = [t[0] for t in s]\n-        rests = [t[1:] for t in s]\n+        blocks = map(Set, s)\n+        firsts = [t[0] for t in blocks]\n+        rests = [t[1:] for t in blocks]\n         iterator = tuple(itertools.permutations(r) for r in rests)\n         for r in itertools.product(*iterator):\n             yield [(firsts[i],) + r[i] for i in range(m)]\n```\nIt seems like it would be better doing:\n\n```python\nits = [iter(t) for t in s]\nfirsts = [next(i) for i in its]\nrests = [list(i) for i in its]\n```\n\nTry to keep things at 80 chars/line, specifically here:\n\n```\n        There is a natural embedding into partition algebras on more elements, by adding identity strands::\n```\n\nWhy are you not using `an_element()`?\n\nWhy this change:\n\n```diff\ndiff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py\nindex d5f24b8..c00e508 100644\n--- a/src/sage/combinat/tableau.py\n+++ b/src/sage/combinat/tableau.py\n@@ -7413,8 +7413,8 @@ class StandardTableaux_size(StandardTableaux, DisjointUnionEnumeratedSets):\n \n         EXAMPLES::\n \n-            sage: StandardTableaux(5).random_element() # random\n-            [[1, 4, 5], [2], [3]]\n+            sage: StandardTableaux(10).random_element() # random\n+            [[1, 3, 6], [2, 5, 7], [4, 8], [9], [10]]\n             sage: StandardTableaux(0).random_element()\n             []\n             sage: StandardTableaux(1).random_element()\n```\n\nWhy are you needlessly unrolling this:\n\n```diff\n@@ -544,7 +546,9 @@ class SetPartition(AbstractSetPartition):\n             {}\n         \"\"\"\n         self._latex_options = {}\n-        ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)\n+        sets = map(frozenset, s)\n+        blocks = sorted(sets, key=min)\n+        ClonableArray.__init__(self, parent, blocks, check=check)\n \n     def check(self):\n         \"\"\"\n```\nThis makes it seem less like one logical unit.\n\nMore towards bikeshedding, but I would appreciate if you could regroup some of the output so the result is shorter output in terms of number of lines.",
    "created_at": "2018-07-10T17:56:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378211",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:53'></a>Oh, I see, the iterator is for all set partitions, not with a fixed set size. However, I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`. I also think `_iterator_parts` should be consistent and return lists of frozensets. Would it also be possible to modify the Knuth algorithm for `_iterator_parts`?

This is horrible code:

```sage
            try:
                tst = frozenset(e for B in self._base_diagram for e in B)
                if tst != self.parent()._set:
                    raise TypeError
            except TypeError:
```
You should not dictate program flow by raising an error. Just let the fact that `B` is non-iterable propagate up; you do not need to have the "perfect" error message.

This change

```diff
diff --git a/src/sage/groups/perm_gps/symgp_conjugacy_class.py b/src/sage/groups/perm_gps/symgp_conjugacy_class.py
index 3b55bcf..5e28f8d 100644
--- a/src/sage/groups/perm_gps/symgp_conjugacy_class.py
+++ b/src/sage/groups/perm_gps/symgp_conjugacy_class.py
@@ -360,8 +360,9 @@ def conjugacy_class_iterator(part, S=None):
 
     m = len(part)
     for s in SetPartitions(S, part):
-        firsts = [t[0] for t in s]
-        rests = [t[1:] for t in s]
+        blocks = map(Set, s)
+        firsts = [t[0] for t in blocks]
+        rests = [t[1:] for t in blocks]
         iterator = tuple(itertools.permutations(r) for r in rests)
         for r in itertools.product(*iterator):
             yield [(firsts[i],) + r[i] for i in range(m)]
```
It seems like it would be better doing:

```python
its = [iter(t) for t in s]
firsts = [next(i) for i in its]
rests = [list(i) for i in its]
```

Try to keep things at 80 chars/line, specifically here:

```
        There is a natural embedding into partition algebras on more elements, by adding identity strands::
```

Why are you not using `an_element()`?

Why this change:

```diff
diff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py
index d5f24b8..c00e508 100644
--- a/src/sage/combinat/tableau.py
+++ b/src/sage/combinat/tableau.py
@@ -7413,8 +7413,8 @@ class StandardTableaux_size(StandardTableaux, DisjointUnionEnumeratedSets):
 
         EXAMPLES::
 
-            sage: StandardTableaux(5).random_element() # random
-            [[1, 4, 5], [2], [3]]
+            sage: StandardTableaux(10).random_element() # random
+            [[1, 3, 6], [2, 5, 7], [4, 8], [9], [10]]
             sage: StandardTableaux(0).random_element()
             []
             sage: StandardTableaux(1).random_element()
```

Why are you needlessly unrolling this:

```diff
@@ -544,7 +546,9 @@ class SetPartition(AbstractSetPartition):
             {}
         """
         self._latex_options = {}
-        ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)
+        sets = map(frozenset, s)
+        blocks = sorted(sets, key=min)
+        ClonableArray.__init__(self, parent, blocks, check=check)
 
     def check(self):
         """
```
This makes it seem less like one logical unit.

More towards bikeshedding, but I would appreciate if you could regroup some of the output so the result is shorter output in terms of number of lines.



---

archive/issue_comments_378212.json:
```json
{
    "body": "<a id='comment:54'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-11T08:59:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378212",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:54'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378213.json:
```json
{
    "body": "<a id='comment:55'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-11T09:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378213",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:55'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378214.json:
```json
{
    "body": "<a id='comment:56'></a>Replying to [comment:53 tscrim]:\n> I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`.\n\n\nProvided such a method, but not used.  It looks a bit like premature optimization to me right now.\n\n> I also think `_iterator_parts` should be consistent and return lists of frozensets. Would it also be possible to modify the Knuth algorithm for `_iterator_parts`?\n\n\nThis is on my todo list, but on a separate ticket.  Currently, I would be transforming `Set` (from `OrderedSetPartition`) into `frozenset`, which is a bit backwards.\n\n> Why are you not using `an_element()`?\n\n\nBecause it turned out to be machine dependent.\n\n> Why this change:\n> \n> ```diff\n> diff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py\n> index d5f24b8..c00e508 100644\n> --- a/src/sage/combinat/tableau.py\n> +++ b/src/sage/combinat/tableau.py\n> @@ -7413,8 +7413,8 @@ class StandardTableaux_size(StandardTableaux, DisjointUnionEnumeratedSets):\n>  \n>          EXAMPLES::\n>  \n> -            sage: StandardTableaux(5).random_element() # random\n> -            [[1, 4, 5], [2], [3]]\n> +            sage: StandardTableaux(10).random_element() # random\n> +            [[1, 3, 6], [2, 5, 7], [4, 8], [9], [10]]\n>              sage: StandardTableaux(0).random_element()\n>              []\n>              sage: StandardTableaux(1).random_element()\n> ```\n\n\nBecause the bug turned up only for tableaux of size 10.\n\n> Why are you needlessly unrolling this:\n> \n> ```diff\n> @@ -544,7 +546,9 @@ class SetPartition(AbstractSetPartition):\n>              {}\n>          \"\"\"\n>          self._latex_options = {}\n> -        ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)\n> +        sets = map(frozenset, s)\n> +        blocks = sorted(sets, key=min)\n> +        ClonableArray.__init__(self, parent, blocks, check=check)\n>  \n>      def check(self):\n>          \"\"\"\n> ```\n\n\nbecause it is much better to trace through, and at least for me, easier to understand.  If you insist, I'll change it.\n\n> More towards bikeshedding, but I would appreciate if you could regroup some of the output so the result is shorter output in terms of number of lines.\n\n\nThere is a reason to have some of the output as it is: it is quite possible that the order the set partitions appear changes again.  Then the diff will be much easier to check.\n\nThanks for your careful look! I modified all other things as you suggested.",
    "created_at": "2018-07-11T10:00:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378214",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:56'></a>Replying to [comment:53 tscrim]:
> I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`.


Provided such a method, but not used.  It looks a bit like premature optimization to me right now.

> I also think `_iterator_parts` should be consistent and return lists of frozensets. Would it also be possible to modify the Knuth algorithm for `_iterator_parts`?


This is on my todo list, but on a separate ticket.  Currently, I would be transforming `Set` (from `OrderedSetPartition`) into `frozenset`, which is a bit backwards.

> Why are you not using `an_element()`?


Because it turned out to be machine dependent.

> Why this change:
> 
> ```diff
> diff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py
> index d5f24b8..c00e508 100644
> --- a/src/sage/combinat/tableau.py
> +++ b/src/sage/combinat/tableau.py
> @@ -7413,8 +7413,8 @@ class StandardTableaux_size(StandardTableaux, DisjointUnionEnumeratedSets):
>  
>          EXAMPLES::
>  
> -            sage: StandardTableaux(5).random_element() # random
> -            [[1, 4, 5], [2], [3]]
> +            sage: StandardTableaux(10).random_element() # random
> +            [[1, 3, 6], [2, 5, 7], [4, 8], [9], [10]]
>              sage: StandardTableaux(0).random_element()
>              []
>              sage: StandardTableaux(1).random_element()
> ```


Because the bug turned up only for tableaux of size 10.

> Why are you needlessly unrolling this:
> 
> ```diff
> @@ -544,7 +546,9 @@ class SetPartition(AbstractSetPartition):
>              {}
>          """
>          self._latex_options = {}
> -        ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)
> +        sets = map(frozenset, s)
> +        blocks = sorted(sets, key=min)
> +        ClonableArray.__init__(self, parent, blocks, check=check)
>  
>      def check(self):
>          """
> ```


because it is much better to trace through, and at least for me, easier to understand.  If you insist, I'll change it.

> More towards bikeshedding, but I would appreciate if you could regroup some of the output so the result is shorter output in terms of number of lines.


There is a reason to have some of the output as it is: it is quite possible that the order the set partitions appear changes again.  Then the diff will be much easier to check.

Thanks for your careful look! I modified all other things as you suggested.



---

archive/issue_comments_378215.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2018-07-11T10:31:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378215",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_378216.json:
```json
{
    "body": "<a id='comment:58'></a>Replying to [comment:56 mantepse]:\n> Replying to [comment:53 tscrim]:\n> > I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`.\n\n> \n> Provided such a method, but not used.  It looks a bit like premature optimization to me right now.\n\n\nThat is a bit unfair as it is something that could easily be used in places where ordering over all set partitions but that is not the actual returned object.\n\n> > I also think `_iterator_parts` should be consistent and return lists of frozensets. Would it also be possible to modify the Knuth algorithm for `_iterator_parts`?\n\n> \n> This is on my todo list, but on a separate ticket.\n\n\nThat is fine.\n\n>  Currently, I would be transforming `Set` (from `OrderedSetPartition`) into `frozenset`, which is a bit backwards.\n\n\nHuh? Isn't that what we are doing here?\n\n> > Why are you not using `an_element()`?\n\n> \n> Because it turned out to be machine dependent.\n\n\nReally? That makes me very worried that the general iterator order is machine dependent, which seems very strange to me as it looks like there shouldn't be anything machine dependent in the implementation. `CFM._an_element_` just iterates over the first few elements.\n\n> > Why this change:\n> > \n> > ```diff\n> > diff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py\n> > index d5f24b8..c00e508 100644\n> > --- a/src/sage/combinat/tableau.py\n> > +++ b/src/sage/combinat/tableau.py\n> > @@ -7413,8 +7413,8 @@ class StandardTableaux_size(StandardTableaux, DisjointUnionEnumeratedSets):\n> >  \n> >          EXAMPLES::\n> >  \n> > -            sage: StandardTableaux(5).random_element() # random\n> > -            [[1, 4, 5], [2], [3]]\n> > +            sage: StandardTableaux(10).random_element() # random\n> > +            [[1, 3, 6], [2, 5, 7], [4, 8], [9], [10]]\n> >              sage: StandardTableaux(0).random_element()\n> >              []\n> >              sage: StandardTableaux(1).random_element()\n> > ```\n\n> \n> Because the bug turned up only for tableaux of size 10.\n\n\nWhat bug? You never mentioned a bug. I cannot tell if this was the correct test or not without knowing what the problem was.\n\n> > Why are you needlessly unrolling this:\n> > \n> > ```diff\n> > @@ -544,7 +546,9 @@ class SetPartition(AbstractSetPartition):\n> >              {}\n> >          \"\"\"\n> >          self._latex_options = {}\n> > -        ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)\n> > +        sets = map(frozenset, s)\n> > +        blocks = sorted(sets, key=min)\n> > +        ClonableArray.__init__(self, parent, blocks, check=check)\n> >  \n> >      def check(self):\n> >          \"\"\"\n> > ```\n\n> \n> because it is much better to trace through, and at least for me, easier to understand.  If you insist, I'll change it.\n\n\nPlease do.\n\n> > More towards bikeshedding, but I would appreciate if you could regroup some of the output so the result is shorter output in terms of number of lines.\n\n> \n> There is a reason to have some of the output as it is: it is quite possible that the order the set partitions appear changes again.  Then the diff will be much easier to check.\n\n\nI don't really find that argument convincing. So should every list have an item on every line? I generally think it is better to have a more compact output. However, this is bikeshedding, so it is not something I would hold up this ticket for.\n\n> Thanks for your careful look! I modified all other things as you suggested.\n\n\nThank you.",
    "created_at": "2018-07-12T00:34:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378216",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:58'></a>Replying to [comment:56 mantepse]:
> Replying to [comment:53 tscrim]:
> > I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`.

> 
> Provided such a method, but not used.  It looks a bit like premature optimization to me right now.


That is a bit unfair as it is something that could easily be used in places where ordering over all set partitions but that is not the actual returned object.

> > I also think `_iterator_parts` should be consistent and return lists of frozensets. Would it also be possible to modify the Knuth algorithm for `_iterator_parts`?

> 
> This is on my todo list, but on a separate ticket.


That is fine.

>  Currently, I would be transforming `Set` (from `OrderedSetPartition`) into `frozenset`, which is a bit backwards.


Huh? Isn't that what we are doing here?

> > Why are you not using `an_element()`?

> 
> Because it turned out to be machine dependent.


Really? That makes me very worried that the general iterator order is machine dependent, which seems very strange to me as it looks like there shouldn't be anything machine dependent in the implementation. `CFM._an_element_` just iterates over the first few elements.

> > Why this change:
> > 
> > ```diff
> > diff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py
> > index d5f24b8..c00e508 100644
> > --- a/src/sage/combinat/tableau.py
> > +++ b/src/sage/combinat/tableau.py
> > @@ -7413,8 +7413,8 @@ class StandardTableaux_size(StandardTableaux, DisjointUnionEnumeratedSets):
> >  
> >          EXAMPLES::
> >  
> > -            sage: StandardTableaux(5).random_element() # random
> > -            [[1, 4, 5], [2], [3]]
> > +            sage: StandardTableaux(10).random_element() # random
> > +            [[1, 3, 6], [2, 5, 7], [4, 8], [9], [10]]
> >              sage: StandardTableaux(0).random_element()
> >              []
> >              sage: StandardTableaux(1).random_element()
> > ```

> 
> Because the bug turned up only for tableaux of size 10.


What bug? You never mentioned a bug. I cannot tell if this was the correct test or not without knowing what the problem was.

> > Why are you needlessly unrolling this:
> > 
> > ```diff
> > @@ -544,7 +546,9 @@ class SetPartition(AbstractSetPartition):
> >              {}
> >          """
> >          self._latex_options = {}
> > -        ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)
> > +        sets = map(frozenset, s)
> > +        blocks = sorted(sets, key=min)
> > +        ClonableArray.__init__(self, parent, blocks, check=check)
> >  
> >      def check(self):
> >          """
> > ```

> 
> because it is much better to trace through, and at least for me, easier to understand.  If you insist, I'll change it.


Please do.

> > More towards bikeshedding, but I would appreciate if you could regroup some of the output so the result is shorter output in terms of number of lines.

> 
> There is a reason to have some of the output as it is: it is quite possible that the order the set partitions appear changes again.  Then the diff will be much easier to check.


I don't really find that argument convincing. So should every list have an item on every line? I generally think it is better to have a more compact output. However, this is bikeshedding, so it is not something I would hold up this ticket for.

> Thanks for your careful look! I modified all other things as you suggested.


Thank you.



---

archive/issue_comments_378217.json:
```json
{
    "body": "<a id='comment:59'></a>Replying to [comment:58 tscrim]:\n> Replying to [comment:56 mantepse]:\n> > Replying to [comment:53 tscrim]:\n> > > I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`.\n\n> > \n> > Provided such a method, but not used.  It looks a bit like premature optimization to me right now.\n\n> \n> That is a bit unfair as it is something that could easily be used in places where ordering over all set partitions but that is not the actual returned object.\n\n\nOK, please suggest a name - is there any convention?  In any case, I think that in the case of diagram algebras one might want to consider to use `SetPartitions(x).list()` instead, because this caches the result.  That's why I said it might be premature.\n\n> > > I also think `_iterator_parts` should be consistent and return lists of frozensets.\n\n\n> >  Currently, I would be transforming `Set` (from `OrderedSetPartition`) into `frozenset`, which is a bit backwards.\n\n> \n> Huh? Isn't that what we are doing here?\n\n\nNo, in the new `__iter__` methods we generate restricted growth words (as lists), which are turned into `frozenset`s.  On the other hand `_iterator_parts` obtains its stuff first from `OrderedSetPartition`, which yields `Set`s.  I want to change that, but in a separate ticket.\n\n> > > Why are you not using `an_element()`?\n\n> > \n> > Because it turned out to be machine dependent.\n\n> \n> Really? That makes me very worried that the general iterator order is machine dependent, which seems very strange to me as it looks like there shouldn't be anything machine dependent in the implementation. `CFM._an_element_` just iterates over the first few elements.\n\n\nI only saw this because a patchbot failed (see [comment:45 mantepse]).  The relevant snippet from https://patchbot.sagemath.org/log/25462/Ubuntu/14.04/i686/3.13.0-95-generic/arando/2018-07-02%2008:29:55 is\n\n```\nFile \"src/sage/combinat/diagram_algebras.py\", line 2332, in sage.combinat.diagram_algebras.PartitionAlgebra._element_constructor_\nFailed example:\n    O.an_element()\nExpected:\n    3*O{{-3}, {-2, -1, 1, 2, 3}} + 2*O{{-3, -2, -1, 1, 2, 3}} + 2*O{{-3, -1, 1, 2, 3}, {-2}}\nGot:\n    3*O{{-3}, {-2, -1, 1, 2, 3}} + 2*O{{-3, -2, -1, 1, 2, 3}} + 2*O{{-3, -2, 1, 2, 3}, {-1}}\n```\n\nI have no idea how to debug this.\n\n> > > Why this change: [...]\n\n> > Because the bug turned up only for tableaux of size 10.\n> What bug? You never mentioned a bug. I cannot tell if this was the correct test or not without knowing what the problem was.\n\n\nSorry, I do not recall the details anymore precisely.  Roughly, I had to modify the code (because `frozenset`s do not support indexing), and the first version had a bug, which I only discovered by luck, because it didn't happen for very small tableaux.  I don't think that I ever commited the wrong code...\n\n> > There is a reason to have some of the output as it is: it is quite possible that the order the set partitions appear changes again.  Then the diff will be much easier to check.\n\n\n> I don't really find that argument convincing. So should every list have an item on every line?\n\n\nOf course not - only if the order of the items in the lists is very likely to change again.",
    "created_at": "2018-07-12T10:58:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378217",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:59'></a>Replying to [comment:58 tscrim]:
> Replying to [comment:56 mantepse]:
> > Replying to [comment:53 tscrim]:
> > > I think it would be better to have a separate iterator that returns the lists of frozensets for those things that do not need a real `SetPartition`.

> > 
> > Provided such a method, but not used.  It looks a bit like premature optimization to me right now.

> 
> That is a bit unfair as it is something that could easily be used in places where ordering over all set partitions but that is not the actual returned object.


OK, please suggest a name - is there any convention?  In any case, I think that in the case of diagram algebras one might want to consider to use `SetPartitions(x).list()` instead, because this caches the result.  That's why I said it might be premature.

> > > I also think `_iterator_parts` should be consistent and return lists of frozensets.


> >  Currently, I would be transforming `Set` (from `OrderedSetPartition`) into `frozenset`, which is a bit backwards.

> 
> Huh? Isn't that what we are doing here?


No, in the new `__iter__` methods we generate restricted growth words (as lists), which are turned into `frozenset`s.  On the other hand `_iterator_parts` obtains its stuff first from `OrderedSetPartition`, which yields `Set`s.  I want to change that, but in a separate ticket.

> > > Why are you not using `an_element()`?

> > 
> > Because it turned out to be machine dependent.

> 
> Really? That makes me very worried that the general iterator order is machine dependent, which seems very strange to me as it looks like there shouldn't be anything machine dependent in the implementation. `CFM._an_element_` just iterates over the first few elements.


I only saw this because a patchbot failed (see [comment:45 mantepse]).  The relevant snippet from https://patchbot.sagemath.org/log/25462/Ubuntu/14.04/i686/3.13.0-95-generic/arando/2018-07-02%2008:29:55 is

```
File "src/sage/combinat/diagram_algebras.py", line 2332, in sage.combinat.diagram_algebras.PartitionAlgebra._element_constructor_
Failed example:
    O.an_element()
Expected:
    3*O{{-3}, {-2, -1, 1, 2, 3}} + 2*O{{-3, -2, -1, 1, 2, 3}} + 2*O{{-3, -1, 1, 2, 3}, {-2}}
Got:
    3*O{{-3}, {-2, -1, 1, 2, 3}} + 2*O{{-3, -2, -1, 1, 2, 3}} + 2*O{{-3, -2, 1, 2, 3}, {-1}}
```

I have no idea how to debug this.

> > > Why this change: [...]

> > Because the bug turned up only for tableaux of size 10.
> What bug? You never mentioned a bug. I cannot tell if this was the correct test or not without knowing what the problem was.


Sorry, I do not recall the details anymore precisely.  Roughly, I had to modify the code (because `frozenset`s do not support indexing), and the first version had a bug, which I only discovered by luck, because it didn't happen for very small tableaux.  I don't think that I ever commited the wrong code...

> > There is a reason to have some of the output as it is: it is quite possible that the order the set partitions appear changes again.  Then the diff will be much easier to check.


> I don't really find that argument convincing. So should every list have an item on every line?


Of course not - only if the order of the items in the lists is very likely to change again.



---

archive/issue_comments_378218.json:
```json
{
    "body": "<a id='comment:60'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-12T10:59:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378218",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:60'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378219.json:
```json
{
    "body": "<a id='comment:61'></a>`@`Travis: as an aside, after #25659, the (slow) `_iterator_part` will not be used anymore in library code...",
    "created_at": "2018-07-16T10:20:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378219",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:61'></a>`@`Travis: as an aside, after #25659, the (slow) `_iterator_part` will not be used anymore in library code...



---

archive/issue_comments_378220.json:
```json
{
    "body": "<a id='comment:62'></a>I just created ticket #25865 for a fast iterator for set partitions with given block sizes.",
    "created_at": "2018-07-17T07:47:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378220",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:62'></a>I just created ticket #25865 for a fast iterator for set partitions with given block sizes.



---

archive/issue_comments_378221.json:
```json
{
    "body": "<a id='comment:63'></a>ping?",
    "created_at": "2018-08-01T07:12:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378221",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:63'></a>ping?



---

archive/issue_comments_378222.json:
```json
{
    "body": "<a id='comment:64'></a>I recompiled and ran all doctests (passed).  I think that you addressed all of Travis' comments.\n\nJust to clarify: The bug you mention in comment:56 was one that arose in implementing this algorithm.  So then its better to just add a new test rather than modify an old one and I would suggest adding one that is not #random .  I'm ok with this and I'm willing to put positive review.  Travis?",
    "created_at": "2018-08-01T16:26:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378222",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:64'></a>I recompiled and ran all doctests (passed).  I think that you addressed all of Travis' comments.

Just to clarify: The bug you mention in comment:56 was one that arose in implementing this algorithm.  So then its better to just add a new test rather than modify an old one and I would suggest adding one that is not #random .  I'm ok with this and I'm willing to put positive review.  Travis?



---

archive/issue_comments_378223.json:
```json
{
    "body": "<a id='comment:65'></a>Replying to [comment:64 zabrocki]:\n\n> Just to clarify: The bug you mention in comment:56 was one that arose in implementing this algorithm.  So then its better to just add a new test rather than modify an old one and I would suggest adding one that is not #random .\n\n\nI am really sorry, but I cannot remember what I did exactly.  However, since there are really very few standard Young tableaux on 5 elements, it is quite unlikely to hit a bug by producing such a small tableau.\n\nAlso, I must admit that I don't know how to produce a non-random test of `.random_element()`.  Can one fix the seed, across all architectures?",
    "created_at": "2018-08-01T16:37:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378223",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:65'></a>Replying to [comment:64 zabrocki]:

> Just to clarify: The bug you mention in comment:56 was one that arose in implementing this algorithm.  So then its better to just add a new test rather than modify an old one and I would suggest adding one that is not #random .


I am really sorry, but I cannot remember what I did exactly.  However, since there are really very few standard Young tableaux on 5 elements, it is quite unlikely to hit a bug by producing such a small tableau.

Also, I must admit that I don't know how to produce a non-random test of `.random_element()`.  Can one fix the seed, across all architectures?



---

archive/issue_comments_378224.json:
```json
{
    "body": "<a id='comment:66'></a>I still do not see how `an_element` is machine dependent without the iterator being machine dependent, which is a bigger problem. The precise code for the `_an_element_` (and hence, `an_element`) for the orbit basis is:\n\n```sage\n        x = self.zero()\n        I = self.basis().keys()\n        R = self.base_ring()\n        try:\n            x = x + self.monomial(I.an_element())\n        except Exception:\n            pass\n        try:\n            g = iter(self.basis().keys())\n            for c in range(1,4):\n                x = x + self.term(next(g), R(c))\n        except Exception:\n            pass\n        return x\n```\nNow the doctests themselves may need to be updated because the iteration order of the set partitions has changed, but I do not see the need of moving away from `an_element`. I am okay with constructing an explicit element, but I want to be certain that there is no machine dependency here, as that would mean the iterator is machine dependent.",
    "created_at": "2018-08-02T21:23:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378224",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:66'></a>I still do not see how `an_element` is machine dependent without the iterator being machine dependent, which is a bigger problem. The precise code for the `_an_element_` (and hence, `an_element`) for the orbit basis is:

```sage
        x = self.zero()
        I = self.basis().keys()
        R = self.base_ring()
        try:
            x = x + self.monomial(I.an_element())
        except Exception:
            pass
        try:
            g = iter(self.basis().keys())
            for c in range(1,4):
                x = x + self.term(next(g), R(c))
        except Exception:
            pass
        return x
```
Now the doctests themselves may need to be updated because the iteration order of the set partitions has changed, but I do not see the need of moving away from `an_element`. I am okay with constructing an explicit element, but I want to be certain that there is no machine dependency here, as that would mean the iterator is machine dependent.



---

archive/issue_comments_378225.json:
```json
{
    "body": "<a id='comment:67'></a>OK, so do you want me to revert (all?) doctests that used `an_element` (and only adapt the output)?",
    "created_at": "2018-08-03T12:24:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378225",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:67'></a>OK, so do you want me to revert (all?) doctests that used `an_element` (and only adapt the output)?



---

archive/issue_comments_378226.json:
```json
{
    "body": "<a id='comment:68'></a>Not necessarily, but you did say that `an_element` was machine dependent in comment:56. So I want to make sure that (well, really the iterator, but that is what it uses) is not machine dependent. If the iterator is, then it is a bug by being in `EnumeratedSets` (by my interpretation) or at the very least could mean brittle doctests.",
    "created_at": "2018-08-03T22:33:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378226",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:68'></a>Not necessarily, but you did say that `an_element` was machine dependent in comment:56. So I want to make sure that (well, really the iterator, but that is what it uses) is not machine dependent. If the iterator is, then it is a bug by being in `EnumeratedSets` (by my interpretation) or at the very least could mean brittle doctests.



---

archive/issue_comments_378227.json:
```json
{
    "body": "<a id='comment:69'></a>Replying to [comment:68 tscrim]:\n> Not necessarily, but you did say that `an_element` was machine dependent in comment:56.\n\n\nI think you meant to write comment:45\n\nIs there an easy way to restore to the state of affairs we had back than - possibly\nand rerun the patchbots - especially the one that produced the strange result?",
    "created_at": "2018-08-04T17:28:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378227",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:69'></a>Replying to [comment:68 tscrim]:
> Not necessarily, but you did say that `an_element` was machine dependent in comment:56.


I think you meant to write comment:45

Is there an easy way to restore to the state of affairs we had back than - possibly
and rerun the patchbots - especially the one that produced the strange result?



---

archive/issue_comments_378228.json:
```json
{
    "body": "<a id='comment:70'></a>I think you mean to say it was said in both, albeit much more explicitly in comment:56.\n\nYou can go back to that commit but ontop of develop by doing\n\n```\n$ git checkout -b new_branch_name develop\n$ git merge 823769c\n```\nHowever, if we wanted to properly test it, then we need to add a test that iterates over the corresponding set partitions. I think it would be better to also change the relevant `an_element` calls back on the same commit and do that on top of the current branch. It will be better in the long run if it is not a problem (as we will want to keep the iteration test).",
    "created_at": "2018-08-04T22:17:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378228",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:70'></a>I think you mean to say it was said in both, albeit much more explicitly in comment:56.

You can go back to that commit but ontop of develop by doing

```
$ git checkout -b new_branch_name develop
$ git merge 823769c
```
However, if we wanted to properly test it, then we need to add a test that iterates over the corresponding set partitions. I think it would be better to also change the relevant `an_element` calls back on the same commit and do that on top of the current branch. It will be better in the long run if it is not a problem (as we will want to keep the iteration test).



---

archive/issue_events_063892.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2018-08-04T22:17:54Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "milestone": "sage-8.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25462#event-63892"
}
```



---

archive/issue_comments_378229.json:
```json
{
    "body": "<a id='comment:72'></a>Replying to [comment:70 tscrim]:\n> I think you mean to say it was said in both, albeit much more explicitly in comment:56.\n\n\nOh, yes, apologies!\n\n> You can go back to that commit but ontop of develop by doing\n> \n> ```\n> $ git checkout -b new_branch_name develop\n> $ git merge 823769c\n> ```\n\n\nOK, I am currently rebuilding.\n\n> However, if we wanted to properly test it, then we need to add a test that iterates over the corresponding set partitions. I think it would be better to also change the relevant `an_element` calls back on the same commit and do that on top of the current branch. It will be better in the long run if it is not a problem (as we will want to keep the iteration test).\n\n\nI am not sure what you mean with \"on the same commit\".  For the moment, I think I'll simply go back to that commit 823769c on top of develop, and switch the branch, so that the patchbots test it again.",
    "created_at": "2018-08-05T11:49:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378229",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:72'></a>Replying to [comment:70 tscrim]:
> I think you mean to say it was said in both, albeit much more explicitly in comment:56.


Oh, yes, apologies!

> You can go back to that commit but ontop of develop by doing
> 
> ```
> $ git checkout -b new_branch_name develop
> $ git merge 823769c
> ```


OK, I am currently rebuilding.

> However, if we wanted to properly test it, then we need to add a test that iterates over the corresponding set partitions. I think it would be better to also change the relevant `an_element` calls back on the same commit and do that on top of the current branch. It will be better in the long run if it is not a problem (as we will want to keep the iteration test).


I am not sure what you mean with "on the same commit".  For the moment, I think I'll simply go back to that commit 823769c on top of develop, and switch the branch, so that the patchbots test it again.



---

archive/issue_comments_378230.json:
```json
{
    "body": "<a id='comment:74'></a>Travis, I cannot reproduce the error.  Is there a way to make arando test the currently attached branch?\n\n---\nNew commits:",
    "created_at": "2018-08-08T11:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378230",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:74'></a>Travis, I cannot reproduce the error.  Is there a way to make arando test the currently attached branch?

---
New commits:



---

archive/issue_comments_378231.json:
```json
{
    "body": "<a id='comment:75'></a>??? where are these commits coming from ???",
    "created_at": "2018-08-08T11:01:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378231",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:75'></a>??? where are these commits coming from ???



---

archive/issue_comments_378232.json:
```json
{
    "body": "<a id='comment:76'></a>Unless you specifically get the arando patchbot manager to call it, no. Patchbots are there trying to help everyone equally. :)\n\nThese commits are really coming from comment:73.",
    "created_at": "2018-08-08T11:07:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378232",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:76'></a>Unless you specifically get the arando patchbot manager to call it, no. Patchbots are there trying to help everyone equally. :)

These commits are really coming from comment:73.



---

archive/issue_comments_378233.json:
```json
{
    "body": "<a id='comment:77'></a>Replying to [comment:76 tscrim]:\n> Unless you specifically get the arando patchbot manager to call it, no. Patchbots are there trying to help everyone equally. :)\n\n\nCould you help me to get this ticket done? I am clueless about how to proceed :-(",
    "created_at": "2018-08-08T11:27:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378233",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:77'></a>Replying to [comment:76 tscrim]:
> Unless you specifically get the arando patchbot manager to call it, no. Patchbots are there trying to help everyone equally. :)


Could you help me to get this ticket done? I am clueless about how to proceed :-(



---

archive/issue_comments_378234.json:
```json
{
    "body": "<a id='comment:78'></a>Okay, I pushed a bunch of changes, including adding back in the `an_element()` tests. I think perhaps the non-determinism might have come from the fact you were calling `list(self.base_set())` in your iterator, which may not have a guaranteed output. I also cythonized the set partition iterators, which cut the time to ~60%.\n\nSince you claim this is much faster but have not provided timings, here are some:\n\n```\nsage: S = SetPartitions(10)\nsage: S.cardinality()\n115975\nsage: SP = SetPartitions(12,7)\nsage: SP.cardinality()\n627396\n\nsage: %time for x in S: pass\nCPU times: user 1min 19s, sys: 71.4 ms, total: 1min 19s\nWall time: 1min 19s\n\nsage: %time for x in S: pass\nLonger than 5 minutes\n```\nvs \"current\" branch:\n\n```\nsage: %time for x in S: pass\nCPU times: user 881 ms, sys: 28.1 ms, total: 909 ms\nWall time: 851 ms\nsage: %time for x in SP: pass\nCPU times: user 5.9 s, sys: 19.2 ms, total: 5.92 s\nWall time: 5.89 s\n```\nvs with my changes:\n\n```\nsage: %time for x in S: pass\nCPU times: user 602 ms, sys: 14.5 ms, total: 617 ms\nWall time: 571 ms\nsage: %time for x in SP: pass\nCPU times: user 3.84 s, sys: 19.4 ms, total: 3.86 s\nWall time: 3.82 s\n```\n\nNow if we could get a non-recursive version of the set partition iterator with fixed blocks, I could get some more speed out of those iterators. The other possibility would be to try and make that into a parallel function, but that might be tricky because `a` needs to be shared in some fashion. Well, those could be made into followup tickets.\n\nSo if tests pass for you, then we can set this to a positive review as I am fairly confident that the iteration order (and hence the `an_element()`) is not machine-dependent (since I squashed the only other place I could see where a machine dependency might creep in).\n\n---\nNew commits:",
    "created_at": "2018-08-12T01:48:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378234",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:78'></a>Okay, I pushed a bunch of changes, including adding back in the `an_element()` tests. I think perhaps the non-determinism might have come from the fact you were calling `list(self.base_set())` in your iterator, which may not have a guaranteed output. I also cythonized the set partition iterators, which cut the time to ~60%.

Since you claim this is much faster but have not provided timings, here are some:

```
sage: S = SetPartitions(10)
sage: S.cardinality()
115975
sage: SP = SetPartitions(12,7)
sage: SP.cardinality()
627396

sage: %time for x in S: pass
CPU times: user 1min 19s, sys: 71.4 ms, total: 1min 19s
Wall time: 1min 19s

sage: %time for x in S: pass
Longer than 5 minutes
```
vs "current" branch:

```
sage: %time for x in S: pass
CPU times: user 881 ms, sys: 28.1 ms, total: 909 ms
Wall time: 851 ms
sage: %time for x in SP: pass
CPU times: user 5.9 s, sys: 19.2 ms, total: 5.92 s
Wall time: 5.89 s
```
vs with my changes:

```
sage: %time for x in S: pass
CPU times: user 602 ms, sys: 14.5 ms, total: 617 ms
Wall time: 571 ms
sage: %time for x in SP: pass
CPU times: user 3.84 s, sys: 19.4 ms, total: 3.86 s
Wall time: 3.82 s
```

Now if we could get a non-recursive version of the set partition iterator with fixed blocks, I could get some more speed out of those iterators. The other possibility would be to try and make that into a parallel function, but that might be tricky because `a` needs to be shared in some fashion. Well, those could be made into followup tickets.

So if tests pass for you, then we can set this to a positive review as I am fairly confident that the iteration order (and hence the `an_element()`) is not machine-dependent (since I squashed the only other place I could see where a machine dependency might creep in).

---
New commits:



---

archive/issue_comments_378235.json:
```json
{
    "body": "<a id='comment:79'></a>Great and thanks for cythonizing!\n\nI think the speedup is quite respectable - do you have an application in mind where you need a faster version still?\n\nThe patchbot currently fails (it seems the order of the output has changed).  I am currently compiling locally.\n\nThanks again!",
    "created_at": "2018-08-12T12:01:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378235",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:79'></a>Great and thanks for cythonizing!

I think the speedup is quite respectable - do you have an application in mind where you need a faster version still?

The patchbot currently fails (it seems the order of the output has changed).  I am currently compiling locally.

Thanks again!



---

archive/issue_comments_378236.json:
```json
{
    "body": "<a id='comment:80'></a>(I was lucky and had develop already compiled)\n\nIndeed, the doctests fail also on my machine, due to different order in the output.  Is this to be expected - or do they pass on your computer?",
    "created_at": "2018-08-12T12:03:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378236",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:80'></a>(I was lucky and had develop already compiled)

Indeed, the doctests fail also on my machine, due to different order in the output.  Is this to be expected - or do they pass on your computer?



---

archive/issue_comments_378237.json:
```json
{
    "body": "<a id='comment:81'></a>Hmm...I thought I did test these files, but I guess I did not. I am getting what looks to be the same failures as the patchbot (I didn't check in detail though).\n\nThe reason I cythonized is because there are a few things (IIRC) that do iterate over set partitions and want to do so at a lower level. I was really hoping to get the iterator with a fixed number of parts down, but I couldn't figure out (at least in the 30 minutes I gave myself) how to make it non-recursive (in particular, so I could use fixed sized arrays of `Py_ssize_t`). However, it is not that important for me as it does not come up in my (current) research.",
    "created_at": "2018-08-12T12:11:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378237",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:81'></a>Hmm...I thought I did test these files, but I guess I did not. I am getting what looks to be the same failures as the patchbot (I didn't check in detail though).

The reason I cythonized is because there are a few things (IIRC) that do iterate over set partitions and want to do so at a lower level. I was really hoping to get the iterator with a fixed number of parts down, but I couldn't figure out (at least in the 30 minutes I gave myself) how to make it non-recursive (in particular, so I could use fixed sized arrays of `Py_ssize_t`). However, it is not that important for me as it does not come up in my (current) research.



---

archive/issue_comments_378238.json:
```json
{
    "body": "<a id='comment:82'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-13T03:53:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378238",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:82'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378239.json:
```json
{
    "body": "<a id='comment:83'></a>Fixed the doctests (as least on the computers I can test, they agree).",
    "created_at": "2018-08-13T03:57:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378239",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:83'></a>Fixed the doctests (as least on the computers I can test, they agree).



---

archive/issue_comments_378240.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-08-13T09:36:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378240",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_378241.json:
```json
{
    "body": "<a id='comment:84'></a>I'm setting this to positive review since the patchbot is happy essentially, it works on my computer, and everthing is wonderful.\n\nThe next steps are #25659 and #25642... (very likely, both need rebasing)",
    "created_at": "2018-08-13T09:36:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378241",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:84'></a>I'm setting this to positive review since the patchbot is happy essentially, it works on my computer, and everthing is wonderful.

The next steps are #25659 and #25642... (very likely, both need rebasing)



---

archive/issue_events_063893.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-08-17T21:14:20Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25462#event-63893"
}
```



---

archive/issue_comments_378242.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-08-17T21:14:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25462",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25462#issuecomment-378242",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
