# Issue 25181: has_custom_conversion check in UnitalAlgebras.ParentMethods is broken

archive/issues_024944.json:
```json
{
    "body": "The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy). Moreover, it doesn't work on Python 3.\n\nSince properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments to explain what is happening.\n\nThis is a pure refactoring: no functionality is changed.\n\n---\n\nOriginal ticket description kept for reference:\n\nThis code\n\n```\n            try:\n                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__\n            except AttributeError:\n                # Sometimes from_base_ring is a lazy attribute\n                has_custom_conversion = True\n```\nis trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.\n\nNow there are two ways to solve this:\n\n1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.\n\n2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:\n\n```\nsage -t src/sage/categories/with_realizations.py\n**********************************************************************\nFile \"src/sage/categories/with_realizations.py\", line 71, in sage.categories.with_realizations.WithRealizations\nFailed example:\n    A = Sets().WithRealizations().example(); A\nException raised:\n    Traceback (most recent call last):\n      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 551, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 961, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.categories.with_realizations.WithRealizations[1]>\", line 1, in <module>\n        A = Sets().WithRealizations().example(); A\n      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py\", line 2526, in example\n        return SubsetAlgebra(base_ring, set)\n      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)\n        return cls.classcall(cls, *args, **kwds)\n      File \"sage/misc/cachefunc.pyx\", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)\n        w = self.f(*args, **kwds)\n      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 1021, in __classcall__\n        instance = typecall(cls, *args, **options)\n      File \"sage/misc/classcall_metaclass.pyx\", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)\n        return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py\", line 186, in __init__\n        In_to_F   .register_as_coercion()\n      File \"sage/categories/morphism.pyx\", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)\n        self._codomain.register_coercion(self)\n      File \"sage/structure/parent.pyx\", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)\n        assert not (self._coercions_used and D in self._coerce_from_hash), \"coercion from {} to {} already registered or discovered\".format(D, self)\n    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered\n**********************************************************************\n```\n\nRegardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n\nCC:  @nthiery\n\nKeywords: sagedays@icerm python3\n\nBranch/Commit: 003b22af7bc99de29838c6c182fb4a0247f2224a\n\nReviewer: Travis Scrimshaw, Nicolas M. Thi\u00e9ry\n\nAuthor: Jeroen Demeyer\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/25181\n\n",
    "closed_at": "2018-08-05T08:42:47Z",
    "created_at": "2018-04-16T12:55:35Z",
    "labels": [
        "component: categories",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.4",
    "title": "has_custom_conversion check in UnitalAlgebras.ParentMethods is broken",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25181",
    "user": "https://github.com/jdemeyer"
}
```
The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy). Moreover, it doesn't work on Python 3.

Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments to explain what is happening.

This is a pure refactoring: no functionality is changed.

---

Original ticket description kept for reference:

This code

```
            try:
                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__
            except AttributeError:
                # Sometimes from_base_ring is a lazy attribute
                has_custom_conversion = True
```
is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.

Now there are two ways to solve this:

1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.

2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:

```
sage -t src/sage/categories/with_realizations.py
**********************************************************************
File "src/sage/categories/with_realizations.py", line 71, in sage.categories.with_realizations.WithRealizations
Failed example:
    A = Sets().WithRealizations().example(); A
Exception raised:
    Traceback (most recent call last):
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.categories.with_realizations.WithRealizations[1]>", line 1, in <module>
        A = Sets().WithRealizations().example(); A
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py", line 2526, in example
        return SubsetAlgebra(base_ring, set)
      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)
        return cls.classcall(cls, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)
        w = self.f(*args, **kwds)
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 1021, in __classcall__
        instance = typecall(cls, *args, **options)
      File "sage/misc/classcall_metaclass.pyx", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)
        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py", line 186, in __init__
        In_to_F   .register_as_coercion()
      File "sage/categories/morphism.pyx", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)
        self._codomain.register_coercion(self)
      File "sage/structure/parent.pyx", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)
        assert not (self._coercions_used and D in self._coerce_from_hash), "coercion from {} to {} already registered or discovered".format(D, self)
    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered
**********************************************************************
```

Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.

CC:  @nthiery

Keywords: sagedays@icerm python3

Branch/Commit: 003b22af7bc99de29838c6c182fb4a0247f2224a

Reviewer: Travis Scrimshaw, Nicolas M. Thi√©ry

Author: Jeroen Demeyer

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/25181





---

archive/issue_comments_480733.json:
```json
{
    "body": "Changing branch from \"\" to \"u/jdemeyer/has_custom_conversion_check_in_unitalalgebras_parentmethods_is_broken\"",
    "created_at": "2018-04-16T12:59:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480733",
    "user": "https://github.com/jdemeyer"
}
```

Changing branch from "" to "u/jdemeyer/has_custom_conversion_check_in_unitalalgebras_parentmethods_is_broken"



---

archive/issue_comments_480734.json:
```json
{
    "body": "Changing commit from \"\" to \"195e94a533efb4349da0c0eff7128160948a1a34\"",
    "created_at": "2018-04-16T13:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480734",
    "user": "https://github.com/jdemeyer"
}
```

Changing commit from "" to "195e94a533efb4349da0c0eff7128160948a1a34"



---

archive/issue_comments_480735.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2018-04-16T13:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480735",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_480736.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -7,9 +7,9 @@\n                 # Sometimes from_base_ring is a lazy attribute\n                 has_custom_conversion = True\n ```\n-is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True`.\n+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality.\n \n-Regardless of this bug, the code to do check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of this check, it can be simplified and fixed.\n+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n \n Author: Jeroen Demeyer\n \n``````\n",
    "created_at": "2018-04-16T13:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480736",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -7,9 +7,9 @@
                 # Sometimes from_base_ring is a lazy attribute
                 has_custom_conversion = True
 ```
-is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True`.
+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality.
 
-Regardless of this bug, the code to do check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of this check, it can be simplified and fixed.
+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.
 
 Author: Jeroen Demeyer
 
``````




---

archive/issue_comments_480737.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,55 @@\n+This code\n \n+```\n+            try:\n+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__\n+            except AttributeError:\n+                # Sometimes from_base_ring is a lazy attribute\n+                has_custom_conversion = True\n+```\n+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality.\n+\n+Now there are two ways to solve this:\n+\n+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.\n+\n+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:\n+\n+```\n+sage -t src/sage/categories/with_realizations.py\n+**********************************************************************\n+File \"src/sage/categories/with_realizations.py\", line 71, in sage.categories.with_realizations.WithRealizations\n+Failed example:\n+    A = Sets().WithRealizations().example(); A\n+Exception raised:\n+    Traceback (most recent call last):\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 551, in _run\n+        self.compile_and_execute(example, compiler, test.globs)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 961, in compile_and_execute\n+        exec(compiled, globs)\n+      File \"<doctest sage.categories.with_realizations.WithRealizations[1]>\", line 1, in <module>\n+        A = Sets().WithRealizations().example(); A\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py\", line 2526, in example\n+        return SubsetAlgebra(base_ring, set)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)\n+        return cls.classcall(cls, *args, **kwds)\n+      File \"sage/misc/cachefunc.pyx\", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)\n+        w = self.f(*args, **kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 1021, in __classcall__\n+        instance = typecall(cls, *args, **options)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)\n+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py\", line 186, in __init__\n+        In_to_F   .register_as_coercion()\n+      File \"sage/categories/morphism.pyx\", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)\n+        self._codomain.register_coercion(self)\n+      File \"sage/structure/parent.pyx\", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)\n+        assert not (self._coercions_used and D in self._coerce_from_hash), \"coercion from {} to {} already registered or discovered\".format(D, self)\n+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered\n+**********************************************************************\n+```\n+\n+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n \n Author: Jeroen Demeyer\n \n``````\n",
    "created_at": "2018-04-16T15:32:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480737",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,55 @@
+This code
 
+```
+            try:
+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__
+            except AttributeError:
+                # Sometimes from_base_ring is a lazy attribute
+                has_custom_conversion = True
+```
+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality.
+
+Now there are two ways to solve this:
+
+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.
+
+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:
+
+```
+sage -t src/sage/categories/with_realizations.py
+**********************************************************************
+File "src/sage/categories/with_realizations.py", line 71, in sage.categories.with_realizations.WithRealizations
+Failed example:
+    A = Sets().WithRealizations().example(); A
+Exception raised:
+    Traceback (most recent call last):
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
+        self.compile_and_execute(example, compiler, test.globs)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
+        exec(compiled, globs)
+      File "<doctest sage.categories.with_realizations.WithRealizations[1]>", line 1, in <module>
+        A = Sets().WithRealizations().example(); A
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py", line 2526, in example
+        return SubsetAlgebra(base_ring, set)
+      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)
+        return cls.classcall(cls, *args, **kwds)
+      File "sage/misc/cachefunc.pyx", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)
+        w = self.f(*args, **kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 1021, in __classcall__
+        instance = typecall(cls, *args, **options)
+      File "sage/misc/classcall_metaclass.pyx", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)
+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py", line 186, in __init__
+        In_to_F   .register_as_coercion()
+      File "sage/categories/morphism.pyx", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)
+        self._codomain.register_coercion(self)
+      File "sage/structure/parent.pyx", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)
+        assert not (self._coercions_used and D in self._coerce_from_hash), "coercion from {} to {} already registered or discovered".format(D, self)
+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered
+**********************************************************************
+```
+
+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.
 
 Author: Jeroen Demeyer
 
``````




---

archive/issue_comments_480738.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,55 @@\n+This code\n \n+```\n+            try:\n+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__\n+            except AttributeError:\n+                # Sometimes from_base_ring is a lazy attribute\n+                has_custom_conversion = True\n+```\n+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.\n+\n+Now there are two ways to solve this:\n+\n+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.\n+\n+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:\n+\n+```\n+sage -t src/sage/categories/with_realizations.py\n+**********************************************************************\n+File \"src/sage/categories/with_realizations.py\", line 71, in sage.categories.with_realizations.WithRealizations\n+Failed example:\n+    A = Sets().WithRealizations().example(); A\n+Exception raised:\n+    Traceback (most recent call last):\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 551, in _run\n+        self.compile_and_execute(example, compiler, test.globs)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 961, in compile_and_execute\n+        exec(compiled, globs)\n+      File \"<doctest sage.categories.with_realizations.WithRealizations[1]>\", line 1, in <module>\n+        A = Sets().WithRealizations().example(); A\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py\", line 2526, in example\n+        return SubsetAlgebra(base_ring, set)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)\n+        return cls.classcall(cls, *args, **kwds)\n+      File \"sage/misc/cachefunc.pyx\", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)\n+        w = self.f(*args, **kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 1021, in __classcall__\n+        instance = typecall(cls, *args, **options)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)\n+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py\", line 186, in __init__\n+        In_to_F   .register_as_coercion()\n+      File \"sage/categories/morphism.pyx\", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)\n+        self._codomain.register_coercion(self)\n+      File \"sage/structure/parent.pyx\", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)\n+        assert not (self._coercions_used and D in self._coerce_from_hash), \"coercion from {} to {} already registered or discovered\".format(D, self)\n+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered\n+**********************************************************************\n+```\n+\n+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n \n Author: Jeroen Demeyer\n \n``````\n",
    "created_at": "2018-04-16T15:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480738",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,55 @@
+This code
 
+```
+            try:
+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__
+            except AttributeError:
+                # Sometimes from_base_ring is a lazy attribute
+                has_custom_conversion = True
+```
+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.
+
+Now there are two ways to solve this:
+
+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.
+
+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:
+
+```
+sage -t src/sage/categories/with_realizations.py
+**********************************************************************
+File "src/sage/categories/with_realizations.py", line 71, in sage.categories.with_realizations.WithRealizations
+Failed example:
+    A = Sets().WithRealizations().example(); A
+Exception raised:
+    Traceback (most recent call last):
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
+        self.compile_and_execute(example, compiler, test.globs)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
+        exec(compiled, globs)
+      File "<doctest sage.categories.with_realizations.WithRealizations[1]>", line 1, in <module>
+        A = Sets().WithRealizations().example(); A
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py", line 2526, in example
+        return SubsetAlgebra(base_ring, set)
+      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)
+        return cls.classcall(cls, *args, **kwds)
+      File "sage/misc/cachefunc.pyx", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)
+        w = self.f(*args, **kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 1021, in __classcall__
+        instance = typecall(cls, *args, **options)
+      File "sage/misc/classcall_metaclass.pyx", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)
+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py", line 186, in __init__
+        In_to_F   .register_as_coercion()
+      File "sage/categories/morphism.pyx", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)
+        self._codomain.register_coercion(self)
+      File "sage/structure/parent.pyx", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)
+        assert not (self._coercions_used and D in self._coerce_from_hash), "coercion from {} to {} already registered or discovered".format(D, self)
+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered
+**********************************************************************
+```
+
+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.
 
 Author: Jeroen Demeyer
 
``````




---

archive/issue_comments_480739.json:
```json
{
    "body": "<a id='comment:4'></a>`@`nthiery: it would be great to have some advice on how to proceed...",
    "created_at": "2018-04-16T15:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480739",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>`@`nthiery: it would be great to have some advice on how to proceed...



---

archive/issue_comments_480740.json:
```json
{
    "body": "<a id='comment:5'></a>So use `six.get_unbound_function` on both sides.  The function name is a bit of a mouthful, but it's very accurate and unambiguous as to what it does...\n\nAnother way to spell it is `the_func = getattr(the_method, '__func__', the_method)` but it's a little less obvious what the intent is of that.",
    "created_at": "2018-04-18T10:06:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480740",
    "user": "https://github.com/embray"
}
```

<a id='comment:5'></a>So use `six.get_unbound_function` on both sides.  The function name is a bit of a mouthful, but it's very accurate and unambiguous as to what it does...

Another way to spell it is `the_func = getattr(the_method, '__func__', the_method)` but it's a little less obvious what the intent is of that.



---

archive/issue_comments_480741.json:
```json
{
    "body": "<a id='comment:6'></a>I meant advice on what to do with the lazy attribute situation. The comments do not agree with the code. So either we fix the comments to say what the code really does or we change the code to do what the comments say. Unfortunately, the latter breaks stuff (see ticket description).",
    "created_at": "2018-04-18T10:44:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480741",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>I meant advice on what to do with the lazy attribute situation. The comments do not agree with the code. So either we fix the comments to say what the code really does or we change the code to do what the comments say. Unfortunately, the latter breaks stuff (see ticket description).



---

archive/issue_comments_480742.json:
```json
{
    "body": "<a id='comment:7'></a>Replying to [comment:5 embray]:\n> So use `six.get_unbound_function` on both sides.\n\n\nNot both sides, because one side is a *bound* method and the other is an *unbound* method.",
    "created_at": "2018-04-18T12:02:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480742",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>Replying to [comment:5 embray]:
> So use `six.get_unbound_function` on both sides.


Not both sides, because one side is a *bound* method and the other is an *unbound* method.



---

archive/issue_comments_480743.json:
```json
{
    "body": "<a id='comment:8'></a>Nicolas: I would love to hear your opinion on this ticket.",
    "created_at": "2018-04-28T12:12:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480743",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>Nicolas: I would love to hear your opinion on this ticket.



---

archive/issue_comments_480744.json:
```json
{
    "body": "<a id='comment:9'></a>Given that this seems difficult to fix properly, I'll probably go for cleaning it up without making any functional changes and properly documenting what happens.",
    "created_at": "2018-05-17T10:10:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480744",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>Given that this seems difficult to fix properly, I'll probably go for cleaning it up without making any functional changes and properly documenting what happens.



---

archive/issue_comments_480745.json:
```json
{
    "body": "<a id='comment:10'></a>This is already \"fixed\" in #24955 but only superficially.",
    "created_at": "2018-05-17T16:12:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480745",
    "user": "https://github.com/embray"
}
```

<a id='comment:10'></a>This is already "fixed" in #24955 but only superficially.



---

archive/issue_comments_480746.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,63 @@\n+The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy).\n \n+Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments but without changing any functionality.\n+\n+---\n+\n+Original ticket description kept for reference:\n+\n+This code\n+\n+```\n+            try:\n+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__\n+            except AttributeError:\n+                # Sometimes from_base_ring is a lazy attribute\n+                has_custom_conversion = True\n+```\n+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.\n+\n+Now there are two ways to solve this:\n+\n+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.\n+\n+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:\n+\n+```\n+sage -t src/sage/categories/with_realizations.py\n+**********************************************************************\n+File \"src/sage/categories/with_realizations.py\", line 71, in sage.categories.with_realizations.WithRealizations\n+Failed example:\n+    A = Sets().WithRealizations().example(); A\n+Exception raised:\n+    Traceback (most recent call last):\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 551, in _run\n+        self.compile_and_execute(example, compiler, test.globs)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 961, in compile_and_execute\n+        exec(compiled, globs)\n+      File \"<doctest sage.categories.with_realizations.WithRealizations[1]>\", line 1, in <module>\n+        A = Sets().WithRealizations().example(); A\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py\", line 2526, in example\n+        return SubsetAlgebra(base_ring, set)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)\n+        return cls.classcall(cls, *args, **kwds)\n+      File \"sage/misc/cachefunc.pyx\", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)\n+        w = self.f(*args, **kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 1021, in __classcall__\n+        instance = typecall(cls, *args, **options)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)\n+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py\", line 186, in __init__\n+        In_to_F   .register_as_coercion()\n+      File \"sage/categories/morphism.pyx\", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)\n+        self._codomain.register_coercion(self)\n+      File \"sage/structure/parent.pyx\", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)\n+        assert not (self._coercions_used and D in self._coerce_from_hash), \"coercion from {} to {} already registered or discovered\".format(D, self)\n+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered\n+**********************************************************************\n+```\n+\n+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n \n Author: Jeroen Demeyer\n \n``````\n",
    "created_at": "2018-06-14T12:41:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480746",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,63 @@
+The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy).
 
+Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments but without changing any functionality.
+
+---
+
+Original ticket description kept for reference:
+
+This code
+
+```
+            try:
+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__
+            except AttributeError:
+                # Sometimes from_base_ring is a lazy attribute
+                has_custom_conversion = True
+```
+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.
+
+Now there are two ways to solve this:
+
+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.
+
+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:
+
+```
+sage -t src/sage/categories/with_realizations.py
+**********************************************************************
+File "src/sage/categories/with_realizations.py", line 71, in sage.categories.with_realizations.WithRealizations
+Failed example:
+    A = Sets().WithRealizations().example(); A
+Exception raised:
+    Traceback (most recent call last):
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
+        self.compile_and_execute(example, compiler, test.globs)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
+        exec(compiled, globs)
+      File "<doctest sage.categories.with_realizations.WithRealizations[1]>", line 1, in <module>
+        A = Sets().WithRealizations().example(); A
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py", line 2526, in example
+        return SubsetAlgebra(base_ring, set)
+      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)
+        return cls.classcall(cls, *args, **kwds)
+      File "sage/misc/cachefunc.pyx", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)
+        w = self.f(*args, **kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 1021, in __classcall__
+        instance = typecall(cls, *args, **options)
+      File "sage/misc/classcall_metaclass.pyx", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)
+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py", line 186, in __init__
+        In_to_F   .register_as_coercion()
+      File "sage/categories/morphism.pyx", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)
+        self._codomain.register_coercion(self)
+      File "sage/structure/parent.pyx", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)
+        assert not (self._coercions_used and D in self._coerce_from_hash), "coercion from {} to {} already registered or discovered".format(D, self)
+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered
+**********************************************************************
+```
+
+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.
 
 Author: Jeroen Demeyer
 
``````




---

archive/issue_comments_480747.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,65 @@\n+The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy).\n \n+Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments to explain what is happening.\n+\n+This is a pure refactoring: no functionality is changed.\n+\n+---\n+\n+Original ticket description kept for reference:\n+\n+This code\n+\n+```\n+            try:\n+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__\n+            except AttributeError:\n+                # Sometimes from_base_ring is a lazy attribute\n+                has_custom_conversion = True\n+```\n+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.\n+\n+Now there are two ways to solve this:\n+\n+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.\n+\n+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:\n+\n+```\n+sage -t src/sage/categories/with_realizations.py\n+**********************************************************************\n+File \"src/sage/categories/with_realizations.py\", line 71, in sage.categories.with_realizations.WithRealizations\n+Failed example:\n+    A = Sets().WithRealizations().example(); A\n+Exception raised:\n+    Traceback (most recent call last):\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 551, in _run\n+        self.compile_and_execute(example, compiler, test.globs)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 961, in compile_and_execute\n+        exec(compiled, globs)\n+      File \"<doctest sage.categories.with_realizations.WithRealizations[1]>\", line 1, in <module>\n+        A = Sets().WithRealizations().example(); A\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py\", line 2526, in example\n+        return SubsetAlgebra(base_ring, set)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)\n+        return cls.classcall(cls, *args, **kwds)\n+      File \"sage/misc/cachefunc.pyx\", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)\n+        w = self.f(*args, **kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 1021, in __classcall__\n+        instance = typecall(cls, *args, **options)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)\n+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py\", line 186, in __init__\n+        In_to_F   .register_as_coercion()\n+      File \"sage/categories/morphism.pyx\", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)\n+        self._codomain.register_coercion(self)\n+      File \"sage/structure/parent.pyx\", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)\n+        assert not (self._coercions_used and D in self._coerce_from_hash), \"coercion from {} to {} already registered or discovered\".format(D, self)\n+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered\n+**********************************************************************\n+```\n+\n+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n \n Author: Jeroen Demeyer\n \n``````\n",
    "created_at": "2018-06-14T12:46:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480747",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,65 @@
+The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy).
 
+Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments to explain what is happening.
+
+This is a pure refactoring: no functionality is changed.
+
+---
+
+Original ticket description kept for reference:
+
+This code
+
+```
+            try:
+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__
+            except AttributeError:
+                # Sometimes from_base_ring is a lazy attribute
+                has_custom_conversion = True
+```
+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.
+
+Now there are two ways to solve this:
+
+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.
+
+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:
+
+```
+sage -t src/sage/categories/with_realizations.py
+**********************************************************************
+File "src/sage/categories/with_realizations.py", line 71, in sage.categories.with_realizations.WithRealizations
+Failed example:
+    A = Sets().WithRealizations().example(); A
+Exception raised:
+    Traceback (most recent call last):
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
+        self.compile_and_execute(example, compiler, test.globs)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
+        exec(compiled, globs)
+      File "<doctest sage.categories.with_realizations.WithRealizations[1]>", line 1, in <module>
+        A = Sets().WithRealizations().example(); A
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py", line 2526, in example
+        return SubsetAlgebra(base_ring, set)
+      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)
+        return cls.classcall(cls, *args, **kwds)
+      File "sage/misc/cachefunc.pyx", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)
+        w = self.f(*args, **kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 1021, in __classcall__
+        instance = typecall(cls, *args, **options)
+      File "sage/misc/classcall_metaclass.pyx", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)
+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py", line 186, in __init__
+        In_to_F   .register_as_coercion()
+      File "sage/categories/morphism.pyx", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)
+        self._codomain.register_coercion(self)
+      File "sage/structure/parent.pyx", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)
+        assert not (self._coercions_used and D in self._coerce_from_hash), "coercion from {} to {} already registered or discovered".format(D, self)
+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered
+**********************************************************************
+```
+
+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.
 
 Author: Jeroen Demeyer
 
``````




---

archive/issue_comments_480748.json:
```json
{
    "body": "Changing commit from \"195e94a533efb4349da0c0eff7128160948a1a34\" to \"003b22af7bc99de29838c6c182fb4a0247f2224a\"",
    "created_at": "2018-06-14T13:51:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480748",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "195e94a533efb4349da0c0eff7128160948a1a34" to "003b22af7bc99de29838c6c182fb4a0247f2224a"



---

archive/issue_comments_480749.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-06-14T13:51:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480749",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_480750.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-06-14T13:52:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480750",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_480751.json:
```json
{
    "body": "<a id='comment:15'></a>Travis told me in person that he is willing to set this to positive review later this month, after discussing it with Nicolas.",
    "created_at": "2018-07-05T08:19:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480751",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:15'></a>Travis told me in person that he is willing to set this to positive review later this month, after discussing it with Nicolas.



---

archive/issue_comments_480752.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,65 @@\n+The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy). Moreover, it doesn't work on Python 3.\n \n+Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments to explain what is happening.\n+\n+This is a pure refactoring: no functionality is changed.\n+\n+---\n+\n+Original ticket description kept for reference:\n+\n+This code\n+\n+```\n+            try:\n+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__\n+            except AttributeError:\n+                # Sometimes from_base_ring is a lazy attribute\n+                has_custom_conversion = True\n+```\n+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.\n+\n+Now there are two ways to solve this:\n+\n+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.\n+\n+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:\n+\n+```\n+sage -t src/sage/categories/with_realizations.py\n+**********************************************************************\n+File \"src/sage/categories/with_realizations.py\", line 71, in sage.categories.with_realizations.WithRealizations\n+Failed example:\n+    A = Sets().WithRealizations().example(); A\n+Exception raised:\n+    Traceback (most recent call last):\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 551, in _run\n+        self.compile_and_execute(example, compiler, test.globs)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 961, in compile_and_execute\n+        exec(compiled, globs)\n+      File \"<doctest sage.categories.with_realizations.WithRealizations[1]>\", line 1, in <module>\n+        A = Sets().WithRealizations().example(); A\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py\", line 2526, in example\n+        return SubsetAlgebra(base_ring, set)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)\n+        return cls.classcall(cls, *args, **kwds)\n+      File \"sage/misc/cachefunc.pyx\", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)\n+        w = self.f(*args, **kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 1021, in __classcall__\n+        instance = typecall(cls, *args, **options)\n+      File \"sage/misc/classcall_metaclass.pyx\", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)\n+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n+      File \"/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py\", line 186, in __init__\n+        In_to_F   .register_as_coercion()\n+      File \"sage/categories/morphism.pyx\", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)\n+        self._codomain.register_coercion(self)\n+      File \"sage/structure/parent.pyx\", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)\n+        assert not (self._coercions_used and D in self._coerce_from_hash), \"coercion from {} to {} already registered or discovered\".format(D, self)\n+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered\n+**********************************************************************\n+```\n+\n+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.\n \n Author: Jeroen Demeyer\n \n``````\n",
    "created_at": "2018-07-05T08:32:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480752",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,65 @@
+The code in `UnitalAlgebras.ParentMethods.__init_extra__` to determine a coercion from the base ring to the algebra is quite obscure (and probably buggy). Moreover, it doesn't work on Python 3.
 
+Since properly cleaning this up didn't work, I instead refactor the code, adding plenty of comments to explain what is happening.
+
+This is a pure refactoring: no functionality is changed.
+
+---
+
+Original ticket description kept for reference:
+
+This code
+
+```
+            try:
+                has_custom_conversion = self.category().parent_class.from_base_ring.__func__ is not self.from_base_ring.__func__
+            except AttributeError:
+                # Sometimes from_base_ring is a lazy attribute
+                has_custom_conversion = True
+```
+is trying to determine whether `from_base_ring` comes from the category or not. However, in the case of a lazy attribute it wrongly sets `has_custom_conversion = True` without checking equality, even if the lazy attribute comes from the category.
+
+Now there are two ways to solve this:
+
+1. Keep (and document) the current behaviour, namely that the `has_custom_conversion = True` branch is always taken if `from_base_ring` is a lazy attribute.
+
+2. Fix the bug and set `has_custom_conversion = False` if `from_base_ring` is a non-custom lazy attribute. Unfortunately, this leads to further breakage:
+
+```
+sage -t src/sage/categories/with_realizations.py
+**********************************************************************
+File "src/sage/categories/with_realizations.py", line 71, in sage.categories.with_realizations.WithRealizations
+Failed example:
+    A = Sets().WithRealizations().example(); A
+Exception raised:
+    Traceback (most recent call last):
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
+        self.compile_and_execute(example, compiler, test.globs)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
+        exec(compiled, globs)
+      File "<doctest sage.categories.with_realizations.WithRealizations[1]>", line 1, in <module>
+        A = Sets().WithRealizations().example(); A
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/sets_cat.py", line 2526, in example
+        return SubsetAlgebra(base_ring, set)
+      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1647)
+        return cls.classcall(cls, *args, **kwds)
+      File "sage/misc/cachefunc.pyx", line 1059, in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6269)
+        w = self.f(*args, **kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 1021, in __classcall__
+        instance = typecall(cls, *args, **options)
+      File "sage/misc/classcall_metaclass.pyx", line 497, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2097)
+        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
+      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/categories/examples/with_realizations.py", line 186, in __init__
+        In_to_F   .register_as_coercion()
+      File "sage/categories/morphism.pyx", line 276, in sage.categories.morphism.Morphism.register_as_coercion (build/cythonized/sage/categories/morphism.c:4666)
+        self._codomain.register_coercion(self)
+      File "sage/structure/parent.pyx", line 1626, in sage.structure.parent.Parent.register_coercion (build/cythonized/sage/structure/parent.c:15031)
+        assert not (self._coercions_used and D in self._coerce_from_hash), "coercion from {} to {} already registered or discovered".format(D, self)
+    AssertionError: coercion from The subset algebra of {1, 2, 3} over Rational Field in the In basis to The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis already registered or discovered
+**********************************************************************
+```
+
+Regardless of this bug, the code to do this check can be improved. The reason why the `__func__` access is needed in the first place is because we are trying to compare an *unbound* method with a *bound* method. If we have unbound methods on both sides of the equality, it can be simplified and fixed.
 
 Author: Jeroen Demeyer
 
``````




---

archive/issue_comments_480753.json:
```json
{
    "body": "Changing keywords from \"\" to \"sagedays@icerm\".",
    "created_at": "2018-07-26T23:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480753",
    "user": "https://github.com/jdemeyer"
}
```

Changing keywords from "" to "sagedays@icerm".



---

archive/issue_comments_480754.json:
```json
{
    "body": "Changing keywords from \"sagedays@icerm\" to \"sagedays@icerm python3\".",
    "created_at": "2018-07-27T09:46:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480754",
    "user": "https://github.com/embray"
}
```

Changing keywords from "sagedays@icerm" to "sagedays@icerm python3".



---

archive/issue_events_063168.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2018-07-27T09:46:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "milestone": "sage-8.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25181#event-63168"
}
```



---

archive/issue_comments_480755.json:
```json
{
    "body": "<a id='comment:18'></a>Adding python3 keyword since this helps fix a number of bugs there as well.",
    "created_at": "2018-07-27T09:46:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480755",
    "user": "https://github.com/embray"
}
```

<a id='comment:18'></a>Adding python3 keyword since this helps fix a number of bugs there as well.



---

archive/issue_comments_480756.json:
```json
{
    "body": "<a id='comment:19'></a>Hi Jeroen!\n\nI have just been through the new version. It is now much much clearer what the current logic does; thanks a lot! The logic is still crappy and way too complicated. but it's indeed very reasonable to split the work in two stages (in this ticket: fixing the Python 3 issue + clarifying the current logic; in a later ticket:fix/improve the logic).\n\nPositive review on my side.\n\nJust one question: while rewriting the code, did you do some additional manual tests to check how things worked? Or were the current doctests sufficient? In the former case, in case you still have your manual tests under hand, could you add them to the doctests?\n\nThanks again,",
    "created_at": "2018-07-27T13:26:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480756",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:19'></a>Hi Jeroen!

I have just been through the new version. It is now much much clearer what the current logic does; thanks a lot! The logic is still crappy and way too complicated. but it's indeed very reasonable to split the work in two stages (in this ticket: fixing the Python 3 issue + clarifying the current logic; in a later ticket:fix/improve the logic).

Positive review on my side.

Just one question: while rewriting the code, did you do some additional manual tests to check how things worked? Or were the current doctests sufficient? In the former case, in case you still have your manual tests under hand, could you add them to the doctests?

Thanks again,



---

archive/issue_comments_480757.json:
```json
{
    "body": "<a id='comment:20'></a>Travis is next to me and agrees with the above comment. I let you set the positive review on our behalf after the question above.",
    "created_at": "2018-07-27T13:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480757",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:20'></a>Travis is next to me and agrees with the above comment. I let you set the positive review on our behalf after the question above.



---

archive/issue_comments_480758.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Travis Scrimshaw, Nicolas M. Thi\u00e9ry\"",
    "created_at": "2018-07-27T13:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480758",
    "user": "https://github.com/nthiery"
}
```

Changing reviewer from "" to "Travis Scrimshaw, Nicolas M. Thi√©ry"



---

archive/issue_comments_480759.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-07-27T13:39:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480759",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_480760.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:19 nthiery]:\n> Just one question: while rewriting the code, did you do some additional manual tests to check how things worked?\n\n\nI don't think so.\n\n> Or were the current doctests sufficient?\n\n\nI recall from my work in Cernay on this ticket that the code was quite brittle: any small change in functionality would induce doctest failures somewhere. Maybe there are not many explicit tests, but the code is used in many places and therefore well tested implicitly.",
    "created_at": "2018-07-27T13:39:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480760",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:22'></a>Replying to [comment:19 nthiery]:
> Just one question: while rewriting the code, did you do some additional manual tests to check how things worked?


I don't think so.

> Or were the current doctests sufficient?


I recall from my work in Cernay on this ticket that the code was quite brittle: any small change in functionality would induce doctest failures somewhere. Maybe there are not many explicit tests, but the code is used in many places and therefore well tested implicitly.



---

archive/issue_comments_480761.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-08-05T08:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480761",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_480762.json:
```json
{
    "body": "Changing branch from \"u/jdemeyer/has_custom_conversion_check_in_unitalalgebras_parentmethods_is_broken\" to \"003b22af7bc99de29838c6c182fb4a0247f2224a\"",
    "created_at": "2018-08-05T08:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25181#issuecomment-480762",
    "user": "https://github.com/vbraun"
}
```

Changing branch from "u/jdemeyer/has_custom_conversion_check_in_unitalalgebras_parentmethods_is_broken" to "003b22af7bc99de29838c6c182fb4a0247f2224a"



---

archive/issue_events_063169.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-08-05T08:42:47Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/25181",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25181#event-63169"
}
```
