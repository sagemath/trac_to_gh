# Issue 25603: Signed tensor product for graded algebras, coalgebras, etc.

archive/issues_025366.json:
```json
{
    "body": "Goal: implement a signed version of (co)product structure on tensor products of graded (or super) (co)algebras. We should be able to define  superalgebras `A` and `B` and specify that when they are tensored together, the product structure has this property\n\n```\n(x1 tensor y1) (x2 tensor y2) = (-1)^{(deg y1) (deg x2)} (x1 x2 tensor y1 y2).\n```\n(And similarly for coalgebras.) The underlying algebras need not be graded commutative themselves. The Steenrod algebra is one use case \u2013\u00a0it is noncommutative, but we definitely want this property when defining the product on its tensor square.\n\nCC:  @tscrim @nthiery @cnassau\n\nKeywords: fpsac2019\n\nReviewer: Travis Scrimshaw, John Palmieri, Darij Grinberg\n\nAuthor: John Palmieri, Travis Scrimshaw\n\nBranch: ccccd8a8aa593d7042497103e1b3e90bd259296e\n\nCommit: ccccd8a8aa593d7042497103e1b3e90bd259296e\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/25603\n\n",
    "closed_at": "2019-07-20T09:10:59Z",
    "created_at": "2018-06-18T17:51:51Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.9",
    "title": "Signed tensor product for graded algebras, coalgebras, etc.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25603",
    "user": "https://github.com/jhpalmieri"
}
```
Goal: implement a signed version of (co)product structure on tensor products of graded (or super) (co)algebras. We should be able to define  superalgebras `A` and `B` and specify that when they are tensored together, the product structure has this property

```
(x1 tensor y1) (x2 tensor y2) = (-1)^{(deg y1) (deg x2)} (x1 x2 tensor y1 y2).
```
(And similarly for coalgebras.) The underlying algebras need not be graded commutative themselves. The Steenrod algebra is one use case – it is noncommutative, but we definitely want this property when defining the product on its tensor square.

CC:  @tscrim @nthiery @cnassau

Keywords: fpsac2019

Reviewer: Travis Scrimshaw, John Palmieri, Darij Grinberg

Author: John Palmieri, Travis Scrimshaw

Branch: ccccd8a8aa593d7042497103e1b3e90bd259296e

Commit: ccccd8a8aa593d7042497103e1b3e90bd259296e

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/25603





---

archive/issue_comments_357284.json:
```json
{
    "body": "<a id='comment:1'></a>See https://groups.google.com/forum/#!topic/sage-devel/8broUYQ0p7c/discussion for one bug which could be fixed by implementing this.",
    "created_at": "2018-06-18T17:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357284",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:1'></a>See https://groups.google.com/forum/#!topic/sage-devel/8broUYQ0p7c/discussion for one bug which could be fixed by implementing this.



---

archive/issue_comments_357285.json:
```json
{
    "body": "<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-19T20:24:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357285",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357286.json:
```json
{
    "body": "<a id='comment:5'></a>Here's an attempt.",
    "created_at": "2018-06-19T20:26:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357286",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:5'></a>Here's an attempt.



---

archive/issue_comments_357287.json:
```json
{
    "body": "<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-19T20:55:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357287",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357288.json:
```json
{
    "body": "<a id='comment:7'></a>Coincidentally, Christian Nassau found a bug in the antipode formula for the Steenrod algebra. Fixing that bug led me to realize that `_test_antipode` should allow for a sign in the graded/super case.\n\nIf this ticket doesn't get done soon, I'll split off that fix into a separate ticket. This won't be as good, because it will involve disabling `_test_antipode` for the Steenrod algebra.",
    "created_at": "2018-06-19T20:58:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357288",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:7'></a>Coincidentally, Christian Nassau found a bug in the antipode formula for the Steenrod algebra. Fixing that bug led me to realize that `_test_antipode` should allow for a sign in the graded/super case.

If this ticket doesn't get done soon, I'll split off that fix into a separate ticket. This won't be as good, because it will involve disabling `_test_antipode` for the Steenrod algebra.



---

archive/issue_comments_357289.json:
```json
{
    "body": "<a id='comment:8'></a>Unfortunately I probably won't get to this for a few days (I will be on a trip across Europe: 4 cities in 5 days). It will be basically at the top of my todo list when I get to the Sage Days in Zaragoza.",
    "created_at": "2018-06-19T23:50:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357289",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>Unfortunately I probably won't get to this for a few days (I will be on a trip across Europe: 4 cities in 5 days). It will be basically at the top of my todo list when I get to the Sage Days in Zaragoza.



---

archive/issue_comments_357290.json:
```json
{
    "body": "<a id='comment:9'></a>A few days would be great. If it starts to take months, then I'll consider other options for the Steenrod algebra bug.",
    "created_at": "2018-06-20T00:01:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357290",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:9'></a>A few days would be great. If it starts to take months, then I'll consider other options for the Steenrod algebra bug.



---

archive/issue_comments_357291.json:
```json
{
    "body": "<a id='comment:10'></a>Aside from more important things (like the whole approach taken here), one question to consider is the name of the axiom, and also how it is printed. I am not particularly happy with the current version.",
    "created_at": "2018-06-20T00:02:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357291",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:10'></a>Aside from more important things (like the whole approach taken here), one question to consider is the name of the axiom, and also how it is printed. I am not particularly happy with the current version.



---

archive/issue_comments_357292.json:
```json
{
    "body": "<a id='comment:11'></a>I'm not too happy with how things look right now either. I'm not sure what the code is trying to tell me, but I am reading it like something does need to be changed in the approach here. I think you should reimplement `product_on_basis` for the new subcategory (let the MRO handle the choice). I will try to find some time to ponder about this on my upcoming flight.\n\nMy quick thoughts on naming: `SignTwistedTensor`, or a generic `TwistedTensor` with a specific implementation for signs, or `TensorTwistedWithSign`.\n\nNicolas, we would appreciate any thoughts you have on this matter. (Otherwise, I will be forced to corner you at ICERM in a month! `:P`)",
    "created_at": "2018-06-20T01:49:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357292",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>I'm not too happy with how things look right now either. I'm not sure what the code is trying to tell me, but I am reading it like something does need to be changed in the approach here. I think you should reimplement `product_on_basis` for the new subcategory (let the MRO handle the choice). I will try to find some time to ponder about this on my upcoming flight.

My quick thoughts on naming: `SignTwistedTensor`, or a generic `TwistedTensor` with a specific implementation for signs, or `TensorTwistedWithSign`.

Nicolas, we would appreciate any thoughts you have on this matter. (Otherwise, I will be forced to corner you at ICERM in a month! `:P`)



---

archive/issue_comments_357293.json:
```json
{
    "body": "<a id='comment:12'></a>`TensorGradedWithSign` should not be an axiom! It changes the behavior of certain methods; axioms lead to default inheritance, so (in theory) every method built for an algebra would have to be overloaded for a superalgebra in order not to give wrong results.\n\nThe proper way should be defining something like `SuperModule`, `SuperAlgebra`, etc. (over a non-graded base ring at first). I'm wondering if we perhaps should define the whole braided zoo right away, seeing that it's a wide field open for computation -- but I'm not quite sure how to go about doing this, seeing that a braiding isn't fully the responsibility of each of the two modules.",
    "created_at": "2018-06-20T10:18:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357293",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:12'></a>`TensorGradedWithSign` should not be an axiom! It changes the behavior of certain methods; axioms lead to default inheritance, so (in theory) every method built for an algebra would have to be overloaded for a superalgebra in order not to give wrong results.

The proper way should be defining something like `SuperModule`, `SuperAlgebra`, etc. (over a non-graded base ring at first). I'm wondering if we perhaps should define the whole braided zoo right away, seeing that it's a wide field open for computation -- but I'm not quite sure how to go about doing this, seeing that a braiding isn't fully the responsibility of each of the two modules.



---

archive/issue_comments_357294.json:
```json
{
    "body": "<a id='comment:13'></a>Replying to [comment:12 gh-darijgr]:\n> `TensorGradedWithSign` should not be an axiom! It changes the behavior of certain methods; axioms lead to default inheritance, so (in theory) every method built for an algebra would have to be overloaded for a superalgebra in order not to give wrong results.\n\n\nI don't understand what you mean, probably because I don't understand the category theory framework in Sage, which I am going to blame on the state of the documentation. What is the role of axioms vs. categories vs. Python classes? In my experience, by the way, inheritance with axioms doesn't always work the way you might want, because it doesn't override methods which are inherited from other Python classes.\n\nIn this particular situation, only methods which deal with tensor products should be affected, so I think you're overstating things when you talk about potentially having to change every method for algebras.\n \n> The proper way should be defining something like `SuperModule`, `SuperAlgebra`, etc. (over a non-graded base ring at first). I'm wondering if we perhaps should define the whole braided zoo right away, seeing that it's a wide field open for computation -- but I'm not quite sure how to go about doing this, seeing that a braiding isn't fully the responsibility of each of the two modules.\n\n\nCategories for `SuperModules` and `SuperAlgebras` already exist in Sage, so I'm not sure what you mean by the first sentence. Also, are you suggesting that for superalgebras (for example), the signed tensor product should be the default behavior? I think in the past you have argued against this being the default behavior in the graded case.\n\nImplementing some sort of braiding sounds great, but not for this ticket, and not as a prerequisite for this ticket.",
    "created_at": "2018-06-20T16:56:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357294",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:13'></a>Replying to [comment:12 gh-darijgr]:
> `TensorGradedWithSign` should not be an axiom! It changes the behavior of certain methods; axioms lead to default inheritance, so (in theory) every method built for an algebra would have to be overloaded for a superalgebra in order not to give wrong results.


I don't understand what you mean, probably because I don't understand the category theory framework in Sage, which I am going to blame on the state of the documentation. What is the role of axioms vs. categories vs. Python classes? In my experience, by the way, inheritance with axioms doesn't always work the way you might want, because it doesn't override methods which are inherited from other Python classes.

In this particular situation, only methods which deal with tensor products should be affected, so I think you're overstating things when you talk about potentially having to change every method for algebras.
 
> The proper way should be defining something like `SuperModule`, `SuperAlgebra`, etc. (over a non-graded base ring at first). I'm wondering if we perhaps should define the whole braided zoo right away, seeing that it's a wide field open for computation -- but I'm not quite sure how to go about doing this, seeing that a braiding isn't fully the responsibility of each of the two modules.


Categories for `SuperModules` and `SuperAlgebras` already exist in Sage, so I'm not sure what you mean by the first sentence. Also, are you suggesting that for superalgebras (for example), the signed tensor product should be the default behavior? I think in the past you have argued against this being the default behavior in the graded case.

Implementing some sort of braiding sounds great, but not for this ticket, and not as a prerequisite for this ticket.



---

archive/issue_comments_357295.json:
```json
{
    "body": "<a id='comment:14'></a>Yeah, that braiding suggestion was probably overkill, sorry.\n\nAnd if we have `SuperAlgebras` and `SuperModules`, then we should use them, not push another axiom on Algebras.\n\nI don't think that \"only methods which deal with tensor products should be affected\"; tensors can be multiplied back in a Hopf algebra, and various constructions in a Hopf algebra involve delta-ing out, messing with the tensors, and then multiplying back. They all slightly change if the algebra becomes super.",
    "created_at": "2018-06-20T19:37:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357295",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:14'></a>Yeah, that braiding suggestion was probably overkill, sorry.

And if we have `SuperAlgebras` and `SuperModules`, then we should use them, not push another axiom on Algebras.

I don't think that "only methods which deal with tensor products should be affected"; tensors can be multiplied back in a Hopf algebra, and various constructions in a Hopf algebra involve delta-ing out, messing with the tensors, and then multiplying back. They all slightly change if the algebra becomes super.



---

archive/issue_comments_357296.json:
```json
{
    "body": "<a id='comment:15'></a>Replying to [comment:14 gh-darijgr]:\n> Yeah, that braiding suggestion was probably overkill, sorry.\n> \n> And if we have `SuperAlgebras` and `SuperModules`, then we should use them, not push another axiom on Algebras.\n\n\nSo should `SuperAlgebras` (or at least `WithBasis`) have this sign by default when taking tensor products? Or do we need a new category?\n\nAnd I'm still interested in why a category rather than an axiom. Your first post seemed to be operating from some set of principles, but I don't know what those principles are or where they are documented. I would be happy to hear more.\n\n> I don't think that \"only methods which deal with tensor products should be affected\"; tensors can be multiplied back in a Hopf algebra, and various constructions in a Hopf algebra involve delta-ing out, messing with the tensors, and then multiplying back. They all slightly change if the algebra becomes super.\n\n\nNot in characteristic 2 :p\n\nThey also don't change unless you are (implicitly or explicitly) interchanging tensor factors. I'm curious about mathematical examples of such constructions. The only examples that I can find in the actual Sage category code are the product for tensor products of algebras and `_test_antipode` for Hopf algebras. (There should also be a coproduct for tensor products of coalgebras, but it apparently hasn't been implemented.)",
    "created_at": "2018-06-20T21:37:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357296",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:15'></a>Replying to [comment:14 gh-darijgr]:
> Yeah, that braiding suggestion was probably overkill, sorry.
> 
> And if we have `SuperAlgebras` and `SuperModules`, then we should use them, not push another axiom on Algebras.


So should `SuperAlgebras` (or at least `WithBasis`) have this sign by default when taking tensor products? Or do we need a new category?

And I'm still interested in why a category rather than an axiom. Your first post seemed to be operating from some set of principles, but I don't know what those principles are or where they are documented. I would be happy to hear more.

> I don't think that "only methods which deal with tensor products should be affected"; tensors can be multiplied back in a Hopf algebra, and various constructions in a Hopf algebra involve delta-ing out, messing with the tensors, and then multiplying back. They all slightly change if the algebra becomes super.


Not in characteristic 2 :p

They also don't change unless you are (implicitly or explicitly) interchanging tensor factors. I'm curious about mathematical examples of such constructions. The only examples that I can find in the actual Sage category code are the product for tensor products of algebras and `_test_antipode` for Hopf algebras. (There should also be a coproduct for tensor products of coalgebras, but it apparently hasn't been implemented.)



---

archive/issue_comments_357297.json:
```json
{
    "body": "<a id='comment:16'></a>On my computer, I created a branch in which I just imposed the sign for super modules/algebras/Hopf algebras with basis. I get one doctest failure for Clifford algebras (`_test_antipode` fails because `ValueError: element is not homogeneous`), which brings me back to one of my questions: should `SuperAlgebrasWithBasis` impose the Koszul sign convention?",
    "created_at": "2018-06-21T01:18:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357297",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:16'></a>On my computer, I created a branch in which I just imposed the sign for super modules/algebras/Hopf algebras with basis. I get one doctest failure for Clifford algebras (`_test_antipode` fails because `ValueError: element is not homogeneous`), which brings me back to one of my questions: should `SuperAlgebrasWithBasis` impose the Koszul sign convention?



---

archive/issue_comments_357298.json:
```json
{
    "body": "<a id='comment:17'></a>In fact, `some_elements` is broken for exterior algebras:\n\n```\nsage: E.<x,y,z> = ExteriorAlgebra(QQ)\nsage: E.some_elements()\n[x^y + 2*x + 3*y + 1]\n```\n\"`x^y`\"??? I don't know how `TestSuite(E).run()` passes in vanilla Sage. I've opened up #25630 for this.\n\nBy the way, exterior algebras provide another instance of the bug referenced in comment:1:\n\n```\nsage: E.<x,y,z> = ExteriorAlgebra(QQ)\nsage: x**2\n0\nsage: x.coproduct()\n1 # x + x # 1\nsage: (x.coproduct())**2 # should be 0\n2*x # x\n```",
    "created_at": "2018-06-21T14:58:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357298",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:17'></a>In fact, `some_elements` is broken for exterior algebras:

```
sage: E.<x,y,z> = ExteriorAlgebra(QQ)
sage: E.some_elements()
[x^y + 2*x + 3*y + 1]
```
"`x^y`"??? I don't know how `TestSuite(E).run()` passes in vanilla Sage. I've opened up #25630 for this.

By the way, exterior algebras provide another instance of the bug referenced in comment:1:

```
sage: E.<x,y,z> = ExteriorAlgebra(QQ)
sage: x**2
0
sage: x.coproduct()
1 # x + x # 1
sage: (x.coproduct())**2 # should be 0
2*x # x
```



---

archive/issue_comments_357299.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-06-21T16:47:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357299",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_357300.json:
```json
{
    "body": "<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-21T16:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357300",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357301.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-06-21T16:51:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357301",
    "user": "https://github.com/jhpalmieri"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_357302.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-21T17:00:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357302",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357303.json:
```json
{
    "body": "<a id='comment:22'></a>> So should SuperAlgebras (or at least WithBasis) have this sign by default when taking tensor products? Or do we need a new category?\n\n\nProbably `SuperAlgebras` should have this sign by default. Does anything speak against it?\n\n> And I'm still interested in why a category rather than an axiom. Your first post seemed to be operating from some set of principles, but I don't know what those principles are or where they are documented. I would be happy to hear more.\n\n\nFrom what I believe, an extra axiom spawns a subclass. Thus, if \"super\" is an axiom, then every superalgebra will be an algebra. Which would be OK if we would implement all the functionality that differs between super- and non-super-algebras as separate methods (\"super-tensor product\", \"supercommutator\", \"superbialgebra\", \"superconvolution\" and whatnot) rather than overriding standard methods. But if we override standard methods, we are creating a minefield. You are right -- the currently implemented generic Hopf-algebra methods (minus the bialgebra axiom check) mostly survive a superization (and even braiding) without changes (e.g., the recursive formula for an antipode in a connected graded bialgebra doesn't change if the word \"super\" gets added), but there is no real guarantee that it will stay so for the more complicated methods we will eventually add.",
    "created_at": "2018-06-21T17:06:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357303",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:22'></a>> So should SuperAlgebras (or at least WithBasis) have this sign by default when taking tensor products? Or do we need a new category?


Probably `SuperAlgebras` should have this sign by default. Does anything speak against it?

> And I'm still interested in why a category rather than an axiom. Your first post seemed to be operating from some set of principles, but I don't know what those principles are or where they are documented. I would be happy to hear more.


From what I believe, an extra axiom spawns a subclass. Thus, if "super" is an axiom, then every superalgebra will be an algebra. Which would be OK if we would implement all the functionality that differs between super- and non-super-algebras as separate methods ("super-tensor product", "supercommutator", "superbialgebra", "superconvolution" and whatnot) rather than overriding standard methods. But if we override standard methods, we are creating a minefield. You are right -- the currently implemented generic Hopf-algebra methods (minus the bialgebra axiom check) mostly survive a superization (and even braiding) without changes (e.g., the recursive formula for an antipode in a connected graded bialgebra doesn't change if the word "super" gets added), but there is no real guarantee that it will stay so for the more complicated methods we will eventually add.



---

archive/issue_comments_357304.json:
```json
{
    "body": "<a id='comment:23'></a>Here is a new version which just incorporates the sign into super modules/algebras/whatever (although not implemented for everything, just for the tensor product for super algebras and `_test_antipode` for super Hopf algebras).\n\nNote also that without this branch, elements of an `ExteriorAlgebra` do not have an `antipode`, so the `TestSuite` for such an algebra skips the antipode testing. With this branch, the antipode is tested (and passes).",
    "created_at": "2018-06-21T17:32:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357304",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:23'></a>Here is a new version which just incorporates the sign into super modules/algebras/whatever (although not implemented for everything, just for the tensor product for super algebras and `_test_antipode` for super Hopf algebras).

Note also that without this branch, elements of an `ExteriorAlgebra` do not have an `antipode`, so the `TestSuite` for such an algebra skips the antipode testing. With this branch, the antipode is tested (and passes).



---

archive/issue_comments_357305.json:
```json
{
    "body": "<a id='comment:24'></a>I am trying this out on #25163.  Is it normal to require that `some_elements` be implemented to return some elements of homogeneous degree?  I thought this was not clear in the documentation.\n\nThe default implement of `some_elements` returned `[self.an_element()]` and you should be able to modify this test so that `_test_antipode` verifies this identity for inhomogeneous elements.",
    "created_at": "2018-06-25T14:01:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357305",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:24'></a>I am trying this out on #25163.  Is it normal to require that `some_elements` be implemented to return some elements of homogeneous degree?  I thought this was not clear in the documentation.

The default implement of `some_elements` returned `[self.an_element()]` and you should be able to modify this test so that `_test_antipode` verifies this identity for inhomogeneous elements.



---

archive/issue_comments_357306.json:
```json
{
    "body": "<a id='comment:25'></a>If you want `_test_antipode` to work with inhomogeneous elements, it will require rewriting. Since the whole testing apparatus is internal, we can decide whether it's easiest for `some_elements` to always return homogeneous elements (in the super algebra case), or whether we want `_test_antipode` to work with arbitrary elements (which means breaking those elements into homogeneous components and testing each component separately, so the same test is happening in any case).",
    "created_at": "2018-06-25T16:22:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357306",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:25'></a>If you want `_test_antipode` to work with inhomogeneous elements, it will require rewriting. Since the whole testing apparatus is internal, we can decide whether it's easiest for `some_elements` to always return homogeneous elements (in the super algebra case), or whether we want `_test_antipode` to work with arbitrary elements (which means breaking those elements into homogeneous components and testing each component separately, so the same test is happening in any case).



---

archive/issue_comments_357307.json:
```json
{
    "body": "<a id='comment:26'></a>We could do this for `_test_antipode`:\n\n```diff\ndiff --git a/src/sage/categories/super_hopf_algebras_with_basis.py b/src/sage/categories/super_hopf_algebras_with_basis.py\nindex 59a4fc2408..af196ad85b 100644\n--- a/src/sage/categories/super_hopf_algebras_with_basis.py\n+++ b/src/sage/categories/super_hopf_algebras_with_basis.py\n@@ -74,13 +74,18 @@ class SuperHopfAlgebrasWithBasis(SuperModulesCategory):\n             SI = lambda x: self.sum(c * S(self.monomial(t1)) * self.monomial(t2)\n                                 for ((t1, t2), c) in x.coproduct())\n \n-            sign = lambda x, y: (-1)**(x.degree() * y.degree())\n-\n             for x in tester.some_elements():\n-\n-                # antipode is an anti-homomorphism\n+                x_even = x.even_component()\n+                x_odd = x.odd_component()\n                 for y in tester.some_elements():\n-                    tester.assertTrue(S(x) * S(y) == sign(x, y) * S(y * x))\n+                    y_even = y.even_component()\n+                    y_odd = y.odd_component()\n+\n+                    # The antipode is a graded anti-homomorphism.\n+                    tester.assertTrue(S(x_even) * S(y_even) == S(y_even * x_even))\n+                    tester.assertTrue(S(x_even) * S(y_odd) == S(y_odd * x_even))\n+                    tester.assertTrue(S(x_odd) * S(y_even) == S(y_even * x_odd))\n+                    tester.assertTrue(S(x_odd) * S(y_odd) == -S(y_odd * x_odd))\n \n                 # mu * (S # I) * delta == counit * unit\n                 tester.assertTrue(SI(x) == self.counit(x) * self.one())\n```\nWould that be better?",
    "created_at": "2018-06-25T17:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357307",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:26'></a>We could do this for `_test_antipode`:

```diff
diff --git a/src/sage/categories/super_hopf_algebras_with_basis.py b/src/sage/categories/super_hopf_algebras_with_basis.py
index 59a4fc2408..af196ad85b 100644
--- a/src/sage/categories/super_hopf_algebras_with_basis.py
+++ b/src/sage/categories/super_hopf_algebras_with_basis.py
@@ -74,13 +74,18 @@ class SuperHopfAlgebrasWithBasis(SuperModulesCategory):
             SI = lambda x: self.sum(c * S(self.monomial(t1)) * self.monomial(t2)
                                 for ((t1, t2), c) in x.coproduct())
 
-            sign = lambda x, y: (-1)**(x.degree() * y.degree())
-
             for x in tester.some_elements():
-
-                # antipode is an anti-homomorphism
+                x_even = x.even_component()
+                x_odd = x.odd_component()
                 for y in tester.some_elements():
-                    tester.assertTrue(S(x) * S(y) == sign(x, y) * S(y * x))
+                    y_even = y.even_component()
+                    y_odd = y.odd_component()
+
+                    # The antipode is a graded anti-homomorphism.
+                    tester.assertTrue(S(x_even) * S(y_even) == S(y_even * x_even))
+                    tester.assertTrue(S(x_even) * S(y_odd) == S(y_odd * x_even))
+                    tester.assertTrue(S(x_odd) * S(y_even) == S(y_even * x_odd))
+                    tester.assertTrue(S(x_odd) * S(y_odd) == -S(y_odd * x_odd))
 
                 # mu * (S # I) * delta == counit * unit
                 tester.assertTrue(SI(x) == self.counit(x) * self.one())
```
Would that be better?



---

archive/issue_comments_357308.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:26 jhpalmieri]:\n> Would that be better?\n+1.  This avoids having to know to implement a `some_elements` method which returns some homogeneous elements in order for `_test_antipode` to work.",
    "created_at": "2018-06-25T17:52:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357308",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:27'></a>Replying to [comment:26 jhpalmieri]:
> Would that be better?
+1.  This avoids having to know to implement a `some_elements` method which returns some homogeneous elements in order for `_test_antipode` to work.



---

archive/issue_comments_357309.json:
```json
{
    "body": "<a id='comment:28'></a>\n```\n+    class TensorProducts(TensorProductsCategory):\n+        \"\"\"\n+        The category of algebras with basis constructed by tensor product of super algebras with basis\n```\nYou mean \"The category of super...\", right?\n\n```\n+        \"\"\"\n+\n+        class ParentMethods:\n+            \"\"\"\n+            implements operations on tensor products of algebras with basis\n+            \"\"\"\n```\nAgain, super I assume.\n\nI don't get the `product_on_basis` code. What is `self._sets`? Why is the parity a sum of things?\n\nI'm not happy with this:\n\n```\n+    def extra_super_categories(self):\n+        return [self.base_category().Graded()]\n```\nDidn't we already agree that a super Hopf algebra is *not* a graded Hopf algebra?",
    "created_at": "2018-06-25T17:58:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357309",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:28'></a>
```
+    class TensorProducts(TensorProductsCategory):
+        """
+        The category of algebras with basis constructed by tensor product of super algebras with basis
```
You mean "The category of super...", right?

```
+        """
+
+        class ParentMethods:
+            """
+            implements operations on tensor products of algebras with basis
+            """
```
Again, super I assume.

I don't get the `product_on_basis` code. What is `self._sets`? Why is the parity a sum of things?

I'm not happy with this:

```
+    def extra_super_categories(self):
+        return [self.base_category().Graded()]
```
Didn't we already agree that a super Hopf algebra is *not* a graded Hopf algebra?



---

archive/issue_comments_357310.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:28 gh-darijgr]:\n> {{{\n> +    class TensorProducts(TensorProductsCategory):\n> +        \"\"\"\n> +        The category of algebras with basis constructed by tensor product of super algebras with basis\n> }}}\n> You mean \"The category of super...\", right?\n\n\nRight.\n \n> {{{\n> +        \"\"\"\n> +\n> +        class ParentMethods:\n> +            \"\"\"\n> +            implements operations on tensor products of algebras with basis\n> +            \"\"\"\n> }}}\n> Again, super I assume.\n\n\nRight.\n \n> I don't get the `product_on_basis` code. What is `self._sets`? Why is the parity a sum of things?\n\n\n`self._sets` is the list of the tensor factors of `self` \u2013 a list of super algebras. When you compute the product\n\n```\n(a_0 tensor a_1 tensor ... tensor a_{n-1}) (b_0 tensor b_1 tensor ... tensor b_{n-1})\n```\nyou have to commute `b_1` past `a_i` for `i` between 1 and `n-1`, and each such interchange multiplies by (-1) raised to the appropriate power. Multiplying the powers of (-1) for all of these interchanges corresponds to first adding all of the powers and then raising (-1) to that power.\n \n> I'm not happy with this:\n> \n> ```\n> +    def extra_super_categories(self):\n> +        return [self.base_category().Graded()]\n> ```\n> Didn't we already agree that a super Hopf algebra is *not* a graded Hopf algebra?\n\n\nThis is what turns on the `antipode` method for elements of exterior algebras, for example. I'd like to treat super Hopf algebras as graded Hopf algebras, except we can override the necessary methods in, for example, `super_hopf_algebras_with_basis.py`.\n\nWhat would you suggest instead?",
    "created_at": "2018-06-25T19:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357310",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:29'></a>Replying to [comment:28 gh-darijgr]:
> {{{
> +    class TensorProducts(TensorProductsCategory):
> +        """
> +        The category of algebras with basis constructed by tensor product of super algebras with basis
> }}}
> You mean "The category of super...", right?


Right.
 
> {{{
> +        """
> +
> +        class ParentMethods:
> +            """
> +            implements operations on tensor products of algebras with basis
> +            """
> }}}
> Again, super I assume.


Right.
 
> I don't get the `product_on_basis` code. What is `self._sets`? Why is the parity a sum of things?


`self._sets` is the list of the tensor factors of `self` – a list of super algebras. When you compute the product

```
(a_0 tensor a_1 tensor ... tensor a_{n-1}) (b_0 tensor b_1 tensor ... tensor b_{n-1})
```
you have to commute `b_1` past `a_i` for `i` between 1 and `n-1`, and each such interchange multiplies by (-1) raised to the appropriate power. Multiplying the powers of (-1) for all of these interchanges corresponds to first adding all of the powers and then raising (-1) to that power.
 
> I'm not happy with this:
> 
> ```
> +    def extra_super_categories(self):
> +        return [self.base_category().Graded()]
> ```
> Didn't we already agree that a super Hopf algebra is *not* a graded Hopf algebra?


This is what turns on the `antipode` method for elements of exterior algebras, for example. I'd like to treat super Hopf algebras as graded Hopf algebras, except we can override the necessary methods in, for example, `super_hopf_algebras_with_basis.py`.

What would you suggest instead?



---

archive/issue_comments_357311.json:
```json
{
    "body": "<a id='comment:30'></a>Oh!! I forgot that a tensor can have several factors... I still don't get the code though. Why `self._sets[0]` and `self._sets[1]`, not just `self._sets`?\n\nI don't like the \"we can override the necessary methods\" reasoning -- sure we can do it *now*, but will everyone who later implements a new Hopf-algebra method do the same? Will they even know that they're supposed to do that?",
    "created_at": "2018-06-25T19:15:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357311",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:30'></a>Oh!! I forgot that a tensor can have several factors... I still don't get the code though. Why `self._sets[0]` and `self._sets[1]`, not just `self._sets`?

I don't like the "we can override the necessary methods" reasoning -- sure we can do it *now*, but will everyone who later implements a new Hopf-algebra method do the same? Will they even know that they're supposed to do that?



---

archive/issue_comments_357312.json:
```json
{
    "body": "<a id='comment:31'></a>Replying to [comment:30 gh-darijgr]:\n> Oh!! I forgot that a tensor can have several factors... I still don't get the code though. Why `self._sets[0]` and `self._sets[1]`, not just `self._sets`?\n\n\nBecause I forgot that a tensor can have several factors? I think I was confusing `self._sets[0]` with the parent of the left factor in the product. I'll fix that.\n\n> I don't like the \"we can override the necessary methods\" reasoning -- sure we can do it *now*, but will everyone who later implements a new Hopf-algebra method do the same? Will they even know that they're supposed to do that?\n\n\nIf they implement a test for it, which then fails on exterior algebras or odd primary Steenrod algebras, they'll know.\n\nAs I asked before, what do you suggest instead? The whole category framework is frustrating, in how badly it's documented. I don't even know where to start if we are going to take a different approach.",
    "created_at": "2018-06-25T19:26:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357312",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:31'></a>Replying to [comment:30 gh-darijgr]:
> Oh!! I forgot that a tensor can have several factors... I still don't get the code though. Why `self._sets[0]` and `self._sets[1]`, not just `self._sets`?


Because I forgot that a tensor can have several factors? I think I was confusing `self._sets[0]` with the parent of the left factor in the product. I'll fix that.

> I don't like the "we can override the necessary methods" reasoning -- sure we can do it *now*, but will everyone who later implements a new Hopf-algebra method do the same? Will they even know that they're supposed to do that?


If they implement a test for it, which then fails on exterior algebras or odd primary Steenrod algebras, they'll know.

As I asked before, what do you suggest instead? The whole category framework is frustrating, in how badly it's documented. I don't even know where to start if we are going to take a different approach.



---

archive/issue_comments_357313.json:
```json
{
    "body": "<a id='comment:32'></a>I don't know what I'd do, and I have largely the same issue with the category framework. I'd copypaste whatever category (`ConnectedGradedHopfAlgebras` I guess?) is responsible for auto-computing the antipode, and copypaste it into a super version (`ConnectedGradedSuperHopfAlgebras`?).",
    "created_at": "2018-06-25T19:29:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357313",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:32'></a>I don't know what I'd do, and I have largely the same issue with the category framework. I'd copypaste whatever category (`ConnectedGradedHopfAlgebras` I guess?) is responsible for auto-computing the antipode, and copypaste it into a super version (`ConnectedGradedSuperHopfAlgebras`?).



---

archive/issue_comments_357314.json:
```json
{
    "body": "<a id='comment:33'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-25T21:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357314",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:33'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357315.json:
```json
{
    "body": "<a id='comment:34'></a>On a branch on my computer, I wrote versions of super_coalgebras.py, super_bialgebras.py, super_hopf_algebras.py, and I get behavior that I just can't understand. In super_hopf_algebras.py`, for example (omitting docstrings for brevity):\n\n```\nclass SuperHopfAlgebras(SuperModulesCategory):\n\n    def super_categories(self):\n        R = self.base_ring()\n        return [SuperBialgebras(R)]\n\n    def dual(self):\n        return self\n```\n(This was essentially copied from hopf_algebra.py.) Then within Sage:\n\n```\nsage: from sage.categories.super_hopf_algebras import SuperHopfAlgebras\nsage: H = SuperHopfAlgebras(QQ)\nsage: H\nCategory of super hopf algebras over Rational Field\nsage: H.dual()\nJoin of Category of duals of coalgebras over Rational Field and Category of duals of algebras over Rational Field\n```\nor more succinctly:\n\n```\nsage: H.dual() == H # should return True\nFalse\n```\nIf I evaluate `H.dual??`, it does not give me `return self` as the source code. Where is it inheriting from? And why? Is the `dual` method in the old hopf_algebra.py just a red herring?\n\nIf someone else wants to take this over, or wants to explain it to me clearly and in short sentences, great. Otherwise, I may be forced to leave this as is and hope it's good enough.",
    "created_at": "2018-06-25T22:31:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357315",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:34'></a>On a branch on my computer, I wrote versions of super_coalgebras.py, super_bialgebras.py, super_hopf_algebras.py, and I get behavior that I just can't understand. In super_hopf_algebras.py`, for example (omitting docstrings for brevity):

```
class SuperHopfAlgebras(SuperModulesCategory):

    def super_categories(self):
        R = self.base_ring()
        return [SuperBialgebras(R)]

    def dual(self):
        return self
```
(This was essentially copied from hopf_algebra.py.) Then within Sage:

```
sage: from sage.categories.super_hopf_algebras import SuperHopfAlgebras
sage: H = SuperHopfAlgebras(QQ)
sage: H
Category of super hopf algebras over Rational Field
sage: H.dual()
Join of Category of duals of coalgebras over Rational Field and Category of duals of algebras over Rational Field
```
or more succinctly:

```
sage: H.dual() == H # should return True
False
```
If I evaluate `H.dual??`, it does not give me `return self` as the source code. Where is it inheriting from? And why? Is the `dual` method in the old hopf_algebra.py just a red herring?

If someone else wants to take this over, or wants to explain it to me clearly and in short sentences, great. Otherwise, I may be forced to leave this as is and hope it's good enough.



---

archive/issue_comments_357316.json:
```json
{
    "body": "<a id='comment:36'></a>You have put `dual` in the category, not the `ParentMethods`. So that is why it is not working.",
    "created_at": "2018-06-26T07:22:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357316",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:36'></a>You have put `dual` in the category, not the `ParentMethods`. So that is why it is not working.



---

archive/issue_comments_357317.json:
```json
{
    "body": "<a id='comment:37'></a>I am also a little uncomfortable with super Hopf => graded Hopf at the category level to get the methods. I think the better thing to do is make aliases for things from `GradedHopfAlgebras[WithBasis]` for the methods that make sense (you may need to apply `__func__` afterwards; I think there is a better way for Python3 compatibility, but I forget what it is off the top of my head). The other option is, of course, a straight copy/paste.\n\nI am liking this implementation better. In my (very limited) experience, the super algebras should have the sign graded tensor products by default. If we happen to get some super algebras whose tensor products should not have the sign (or complaints), we can revisit this issue then.\n\nAlso, typically we don't have docstrings for the `ParentMethods` (and similar) class.",
    "created_at": "2018-06-26T07:29:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357317",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:37'></a>I am also a little uncomfortable with super Hopf => graded Hopf at the category level to get the methods. I think the better thing to do is make aliases for things from `GradedHopfAlgebras[WithBasis]` for the methods that make sense (you may need to apply `__func__` afterwards; I think there is a better way for Python3 compatibility, but I forget what it is off the top of my head). The other option is, of course, a straight copy/paste.

I am liking this implementation better. In my (very limited) experience, the super algebras should have the sign graded tensor products by default. If we happen to get some super algebras whose tensor products should not have the sign (or complaints), we can revisit this issue then.

Also, typically we don't have docstrings for the `ParentMethods` (and similar) class.



---

archive/issue_comments_357318.json:
```json
{
    "body": "<a id='comment:38'></a>I feel like I'm just trying things at random here, cutting and pasting from various files in the categories directory, and it's not enjoyable. Why does `HopfAlgebras` in `hopf_algebras.py` have a `super_categories` method, as compared to `SuperAlgebras` which has an `extra_super_categories` method? Which should I use for `SuperHopfAlgebras`? Which for `SuperHopfAlgebrasWithBasis`?\n\nMoving `def dual` to the `ParentMethods` section makes no difference, not that I understand why it would. Note also that in `hopf_algebra.py`, `def dual` is not in `ParentMethods`. So I'm still confused about this.\n\nI created a file `super_coalgebras.py`, modeling it on `super_algebras.py`:\n\n```\nclass SuperCoalgebras(SuperModulesCategory):\n\n    def extra_super_categories(self):\n        return [self.base_category().Graded()]\n```\nI also modified `coalgebras.py` by removing the `class Super(...)`. But this didn't work: I got\n\n```\n**********************************************************************\nFile \"src/sage/categories/super_coalgebras.py\", line 44, in sage.categories.super_coalgebras.SuperCoalgebras.extra_super_categories\nFailed example:\n    C.super_categories() # indirect doctest\nExpected:\n    [Category of super modules over Integer Ring,\n     Category of graded coalgebras over Integer Ring]\nGot:\n    [Category of super modules over Integer Ring,\n     Category of coalgebras over Integer Ring]\n**********************************************************************\n```\nAnd of course, if anyone manages to answer these questions, I fully expect to get stuck 5 minutes later on something else. I just don't understand enough of the category framework to do this in anything approaching an efficient way. So I really think someone else should take over, if you're not happy with the current approach. Or accept this approach for now and open a followup ticket to use a better approach \u2013\u00a0I would appreciate this if otherwise this ticket might get delayed for a significant amount of time.",
    "created_at": "2018-06-26T16:13:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357318",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:38'></a>I feel like I'm just trying things at random here, cutting and pasting from various files in the categories directory, and it's not enjoyable. Why does `HopfAlgebras` in `hopf_algebras.py` have a `super_categories` method, as compared to `SuperAlgebras` which has an `extra_super_categories` method? Which should I use for `SuperHopfAlgebras`? Which for `SuperHopfAlgebrasWithBasis`?

Moving `def dual` to the `ParentMethods` section makes no difference, not that I understand why it would. Note also that in `hopf_algebra.py`, `def dual` is not in `ParentMethods`. So I'm still confused about this.

I created a file `super_coalgebras.py`, modeling it on `super_algebras.py`:

```
class SuperCoalgebras(SuperModulesCategory):

    def extra_super_categories(self):
        return [self.base_category().Graded()]
```
I also modified `coalgebras.py` by removing the `class Super(...)`. But this didn't work: I got

```
**********************************************************************
File "src/sage/categories/super_coalgebras.py", line 44, in sage.categories.super_coalgebras.SuperCoalgebras.extra_super_categories
Failed example:
    C.super_categories() # indirect doctest
Expected:
    [Category of super modules over Integer Ring,
     Category of graded coalgebras over Integer Ring]
Got:
    [Category of super modules over Integer Ring,
     Category of coalgebras over Integer Ring]
**********************************************************************
```
And of course, if anyone manages to answer these questions, I fully expect to get stuck 5 minutes later on something else. I just don't understand enough of the category framework to do this in anything approaching an efficient way. So I really think someone else should take over, if you're not happy with the current approach. Or accept this approach for now and open a followup ticket to use a better approach – I would appreciate this if otherwise this ticket might get delayed for a significant amount of time.



---

archive/issue_comments_357319.json:
```json
{
    "body": "<a id='comment:39'></a>Replying to [comment:38 jhpalmieri]:\n> I feel like I'm just trying things at random here, cutting and pasting from various files in the categories directory, and it's not enjoyable. Why does `HopfAlgebras` in `hopf_algebras.py` have a `super_categories` method, as compared to `SuperAlgebras` which has an `extra_super_categories` method? Which should I use for `SuperHopfAlgebras`? Which for `SuperHopfAlgebrasWithBasis`?\n\n\n`HopfAlgebras` is not a functorially constructed category, as opposed to the `Super*` categories. So that is why it needs the `super_categories`.\n\n> Moving `def dual` to the `ParentMethods` section makes no difference, not that I understand why it would. Note also that in `hopf_algebra.py`, `def dual` is not in `ParentMethods`. So I'm still confused about this.\n\n\nWell, the `dual` there is the for the dual category, which is some category theoretical thing that I don't know about. Anything defined in `ParentMethods` becomes a method for any `Parent` object in that category (e.g., an exterior algebra). I misread your previous post; so yes, I agree that what you have above should be `True`.\n\n> I created a file `super_coalgebras.py`, modeling it on `super_algebras.py`:\n> \n> ```\n> class SuperCoalgebras(SuperModulesCategory):\n> \n>     def extra_super_categories(self):\n>         return [self.base_category().Graded()]\n> ```\n> I also modified `coalgebras.py` by removing the `class Super(...)`. But this didn't work: I got\n> \n> ```\n> **********************************************************************\n> File \"src/sage/categories/super_coalgebras.py\", line 44, in sage.categories.super_coalgebras.SuperCoalgebras.extra_super_categories\n> Failed example:\n>     C.super_categories() # indirect doctest\n> Expected:\n>     [Category of super modules over Integer Ring,\n>      Category of graded coalgebras over Integer Ring]\n> Got:\n>     [Category of super modules over Integer Ring,\n>      Category of coalgebras over Integer Ring]\n> **********************************************************************\n> ```\n\n\nDid you add a redirect from coalgebras to the super version? Coalgebras still needs to know what class its super version is. (See, e.g., `ModulesWithBasis`.)\n\n> And of course, if anyone manages to answer these questions, I fully expect to get stuck 5 minutes later on something else. I just don't understand enough of the category framework to do this in anything approaching an efficient way. So I really think someone else should take over, if you're not happy with the current approach. Or accept this approach for now and open a followup ticket to use a better approach \u2013\u00a0I would appreciate this if otherwise this ticket might get delayed for a significant amount of time.\n\n\nI will take over then and try to get this to a workable state.",
    "created_at": "2018-06-28T15:03:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357319",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:39'></a>Replying to [comment:38 jhpalmieri]:
> I feel like I'm just trying things at random here, cutting and pasting from various files in the categories directory, and it's not enjoyable. Why does `HopfAlgebras` in `hopf_algebras.py` have a `super_categories` method, as compared to `SuperAlgebras` which has an `extra_super_categories` method? Which should I use for `SuperHopfAlgebras`? Which for `SuperHopfAlgebrasWithBasis`?


`HopfAlgebras` is not a functorially constructed category, as opposed to the `Super*` categories. So that is why it needs the `super_categories`.

> Moving `def dual` to the `ParentMethods` section makes no difference, not that I understand why it would. Note also that in `hopf_algebra.py`, `def dual` is not in `ParentMethods`. So I'm still confused about this.


Well, the `dual` there is the for the dual category, which is some category theoretical thing that I don't know about. Anything defined in `ParentMethods` becomes a method for any `Parent` object in that category (e.g., an exterior algebra). I misread your previous post; so yes, I agree that what you have above should be `True`.

> I created a file `super_coalgebras.py`, modeling it on `super_algebras.py`:
> 
> ```
> class SuperCoalgebras(SuperModulesCategory):
> 
>     def extra_super_categories(self):
>         return [self.base_category().Graded()]
> ```
> I also modified `coalgebras.py` by removing the `class Super(...)`. But this didn't work: I got
> 
> ```
> **********************************************************************
> File "src/sage/categories/super_coalgebras.py", line 44, in sage.categories.super_coalgebras.SuperCoalgebras.extra_super_categories
> Failed example:
>     C.super_categories() # indirect doctest
> Expected:
>     [Category of super modules over Integer Ring,
>      Category of graded coalgebras over Integer Ring]
> Got:
>     [Category of super modules over Integer Ring,
>      Category of coalgebras over Integer Ring]
> **********************************************************************
> ```


Did you add a redirect from coalgebras to the super version? Coalgebras still needs to know what class its super version is. (See, e.g., `ModulesWithBasis`.)

> And of course, if anyone manages to answer these questions, I fully expect to get stuck 5 minutes later on something else. I just don't understand enough of the category framework to do this in anything approaching an efficient way. So I really think someone else should take over, if you're not happy with the current approach. Or accept this approach for now and open a followup ticket to use a better approach – I would appreciate this if otherwise this ticket might get delayed for a significant amount of time.


I will take over then and try to get this to a workable state.



---

archive/issue_comments_357320.json:
```json
{
    "body": "<a id='comment:40'></a>Replying to [comment:39 tscrim]:\n> Well, the `dual` there is the for the dual category, which is some category theoretical thing that I don't know about. Anything defined in `ParentMethods` becomes a method for any `Parent` object in that category (e.g., an exterior algebra). I misread your previous post; so yes, I agree that what you have above should be `True`.\n\n\nI don't dual categories are that useful in Sage, nor do I care about them in this particular case, so probably the easiest thing to do is to delete this part.\n\n> > I created a file `super_coalgebras.py`, modeling it on `super_algebras.py`:\n> > \n> >   [snip]\n\n> >\n> \n> Did you add a redirect from coalgebras to the super version? Coalgebras still needs to know what class its super version is. (See, e.g., `ModulesWithBasis`.)\n\n\nI put in a `Super = LazyImport(...)` line, like the one in `algebras.py`.\n\n> > And of course, if anyone manages to answer these questions, I fully expect to get stuck 5 minutes later on something else. I just don't understand enough of the category framework to do this in anything approaching an efficient way. So I really think someone else should take over, if you're not happy with the current approach. Or accept this approach for now and open a followup ticket to use a better approach \u2013\u00a0I would appreciate this if otherwise this ticket might get delayed for a significant amount of time.\n\n> \n> I will take over then and try to get this to a workable state.\n\n\nThat would be great, thanks.",
    "created_at": "2018-06-29T20:41:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357320",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:40'></a>Replying to [comment:39 tscrim]:
> Well, the `dual` there is the for the dual category, which is some category theoretical thing that I don't know about. Anything defined in `ParentMethods` becomes a method for any `Parent` object in that category (e.g., an exterior algebra). I misread your previous post; so yes, I agree that what you have above should be `True`.


I don't dual categories are that useful in Sage, nor do I care about them in this particular case, so probably the easiest thing to do is to delete this part.

> > I created a file `super_coalgebras.py`, modeling it on `super_algebras.py`:
> > 
> >   [snip]

> >
> 
> Did you add a redirect from coalgebras to the super version? Coalgebras still needs to know what class its super version is. (See, e.g., `ModulesWithBasis`.)


I put in a `Super = LazyImport(...)` line, like the one in `algebras.py`.

> > And of course, if anyone manages to answer these questions, I fully expect to get stuck 5 minutes later on something else. I just don't understand enough of the category framework to do this in anything approaching an efficient way. So I really think someone else should take over, if you're not happy with the current approach. Or accept this approach for now and open a followup ticket to use a better approach – I would appreciate this if otherwise this ticket might get delayed for a significant amount of time.

> 
> I will take over then and try to get this to a workable state.


That would be great, thanks.



---

archive/issue_comments_357321.json:
```json
{
    "body": "<a id='comment:41'></a>Nicolas and I discussed this a bit at SageDays`@`ICERM. What we concluded was that there should be a new functorial construction `SignedTensorProducts`. We should also add a new axiom `super-commutative`. Then for `SuperCommutativeAlgebras`, we should override the tensor constructor so the default was the signed version. Anytime we have methods that would be shared with two otherwise separate categories (e.g., (super) Hopf algebras), we create just an ABC, where now the \"C\" is for \"Category\"; see `ComplexReflectionOrGeneralizedCoxeterGroups` as an example.\n\nIf you do not disagree with this, I will take this over now and do all of these things.",
    "created_at": "2018-08-03T03:43:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357321",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:41'></a>Nicolas and I discussed this a bit at SageDays`@`ICERM. What we concluded was that there should be a new functorial construction `SignedTensorProducts`. We should also add a new axiom `super-commutative`. Then for `SuperCommutativeAlgebras`, we should override the tensor constructor so the default was the signed version. Anytime we have methods that would be shared with two otherwise separate categories (e.g., (super) Hopf algebras), we create just an ABC, where now the "C" is for "Category"; see `ComplexReflectionOrGeneralizedCoxeterGroups` as an example.

If you do not disagree with this, I will take this over now and do all of these things.



---

archive/issue_comments_357322.json:
```json
{
    "body": "<a id='comment:42'></a>Replying to [comment:41 tscrim]:\n> Nicolas and I discussed this a bit at SageDays`@`ICERM. What we concluded was that there should be a new functorial construction `SignedTensorProducts`. We should also add a new axiom `super-commutative`. Then for `SuperCommutativeAlgebras`, we should override the tensor constructor so the default was the signed version.\n\n\nOK, as long as these `SuperCommutativeAlgebras` inherit from `SuperAlgebras` and not from `Algebras`.\n\n> Anytime we have methods that would be shared with two otherwise separate categories (e.g., (super) Hopf algebras), we create just an ABC, where now the \"C\" is for \"Category\"; see `ComplexReflectionOrGeneralizedCoxeterGroups` as an example.\n\n\nThis sounds like the Right Thing To Do. Definitely agreeing.",
    "created_at": "2018-08-03T11:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357322",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:42'></a>Replying to [comment:41 tscrim]:
> Nicolas and I discussed this a bit at SageDays`@`ICERM. What we concluded was that there should be a new functorial construction `SignedTensorProducts`. We should also add a new axiom `super-commutative`. Then for `SuperCommutativeAlgebras`, we should override the tensor constructor so the default was the signed version.


OK, as long as these `SuperCommutativeAlgebras` inherit from `SuperAlgebras` and not from `Algebras`.

> Anytime we have methods that would be shared with two otherwise separate categories (e.g., (super) Hopf algebras), we create just an ABC, where now the "C" is for "Category"; see `ComplexReflectionOrGeneralizedCoxeterGroups` as an example.


This sounds like the Right Thing To Do. Definitely agreeing.



---

archive/issue_comments_357323.json:
```json
{
    "body": "<a id='comment:43'></a>This sounds great.  I'm glad you are taking this up because I'd like it for #25163.\n\nCan you clarify what the `super-commutative` axiom will mean (I can also be patient and see what you have in mind)?  Are you saying that an algebra is `super-commutative` if `fg = (-1)^x gf` for elements `f` and `g`?",
    "created_at": "2018-08-03T11:59:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357323",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:43'></a>This sounds great.  I'm glad you are taking this up because I'd like it for #25163.

Can you clarify what the `super-commutative` axiom will mean (I can also be patient and see what you have in mind)?  Are you saying that an algebra is `super-commutative` if `fg = (-1)^x gf` for elements `f` and `g`?



---

archive/issue_comments_357324.json:
```json
{
    "body": "<a id='comment:44'></a>This mostly sounds good to me, but some algebras which are not commutative or supercommutative (like the Steenrod algebra, or perhaps enveloping algebras for super Lie algebras) should still have the sign in the tensor product. So as long as the new functorial construction is well documented and easy to apply in these non-supercommutative cases, okay.\n\nPerhaps also implement `SuperCocommutativeCoalgebras`? It would be nice to say that the Steenrod algebra is super cocommutative, and that therefore it gets the sign on the tensor product, even though the product is not commutative.",
    "created_at": "2018-08-03T16:05:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357324",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:44'></a>This mostly sounds good to me, but some algebras which are not commutative or supercommutative (like the Steenrod algebra, or perhaps enveloping algebras for super Lie algebras) should still have the sign in the tensor product. So as long as the new functorial construction is well documented and easy to apply in these non-supercommutative cases, okay.

Perhaps also implement `SuperCocommutativeCoalgebras`? It would be nice to say that the Steenrod algebra is super cocommutative, and that therefore it gets the sign on the tensor product, even though the product is not commutative.



---

archive/issue_comments_357325.json:
```json
{
    "body": "<a id='comment:45'></a>Replying to [comment:43 zabrocki]:\n> This sounds great.  I'm glad you are taking this up because I'd like it for #25163.\n> \n> Can you clarify what the `super-commutative` axiom will mean (I can also be patient and see what you have in mind)?  Are you saying that an algebra is `super-commutative` if `fg = (-1)^x gf` for elements `f` and `g`?\n\n\nYes, that is correct. Is there some other notion of super-commutative that I/we should be worried about?",
    "created_at": "2018-08-05T22:45:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357325",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:45'></a>Replying to [comment:43 zabrocki]:
> This sounds great.  I'm glad you are taking this up because I'd like it for #25163.
> 
> Can you clarify what the `super-commutative` axiom will mean (I can also be patient and see what you have in mind)?  Are you saying that an algebra is `super-commutative` if `fg = (-1)^x gf` for elements `f` and `g`?


Yes, that is correct. Is there some other notion of super-commutative that I/we should be worried about?



---

archive/issue_comments_357326.json:
```json
{
    "body": "<a id='comment:46'></a>Replying to [comment:44 jhpalmieri]:\n> This mostly sounds good to me, but some algebras which are not commutative or supercommutative (like the Steenrod algebra, or perhaps enveloping algebras for super Lie algebras) should still have the sign in the tensor product. So as long as the new functorial construction is well documented and easy to apply in these non-supercommutative cases, okay.\n\n\nThat is the plan. It might take a few iterations (on trac) to get something that works in all the case you want, so please bear with me.\n\n> Perhaps also implement `SuperCocommutativeCoalgebras`? It would be nice to say that the Steenrod algebra is super cocommutative, and that therefore it gets the sign on the tensor product, even though the product is not commutative.\n\n\nThat should be no trouble to do as well. Actually, we currently do not even have a cocommutative axiom. It might be better to introduce these on a separate ticket.",
    "created_at": "2018-08-05T22:50:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357326",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:46'></a>Replying to [comment:44 jhpalmieri]:
> This mostly sounds good to me, but some algebras which are not commutative or supercommutative (like the Steenrod algebra, or perhaps enveloping algebras for super Lie algebras) should still have the sign in the tensor product. So as long as the new functorial construction is well documented and easy to apply in these non-supercommutative cases, okay.


That is the plan. It might take a few iterations (on trac) to get something that works in all the case you want, so please bear with me.

> Perhaps also implement `SuperCocommutativeCoalgebras`? It would be nice to say that the Steenrod algebra is super cocommutative, and that therefore it gets the sign on the tensor product, even though the product is not commutative.


That should be no trouble to do as well. Actually, we currently do not even have a cocommutative axiom. It might be better to introduce these on a separate ticket.



---

archive/issue_comments_357327.json:
```json
{
    "body": "<a id='comment:47'></a>Replying to [comment:46 tscrim]:\n> Replying to [comment:44 jhpalmieri]:\n> > This mostly sounds good to me, but some algebras which are not commutative or supercommutative (like the Steenrod algebra, or perhaps enveloping algebras for super Lie algebras) should still have the sign in the tensor product. So as long as the new functorial construction is well documented and easy to apply in these non-supercommutative cases, okay.\n\n> \n> That is the plan. It might take a few iterations (on trac) to get something that works in all the case you want, so please bear with me.\n\n\nOkay, sounds good.\n \n> > Perhaps also implement `SuperCocommutativeCoalgebras`? It would be nice to say that the Steenrod algebra is super cocommutative, and that therefore it gets the sign on the tensor product, even though the product is not commutative.\n\n> \n> That should be no trouble to do as well. Actually, we currently do not even have a cocommutative axiom. It might be better to introduce these on a separate ticket.\n\n\nSure, a separate ticket would be good.",
    "created_at": "2018-08-06T05:24:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357327",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:47'></a>Replying to [comment:46 tscrim]:
> Replying to [comment:44 jhpalmieri]:
> > This mostly sounds good to me, but some algebras which are not commutative or supercommutative (like the Steenrod algebra, or perhaps enveloping algebras for super Lie algebras) should still have the sign in the tensor product. So as long as the new functorial construction is well documented and easy to apply in these non-supercommutative cases, okay.

> 
> That is the plan. It might take a few iterations (on trac) to get something that works in all the case you want, so please bear with me.


Okay, sounds good.
 
> > Perhaps also implement `SuperCocommutativeCoalgebras`? It would be nice to say that the Steenrod algebra is super cocommutative, and that therefore it gets the sign on the tensor product, even though the product is not commutative.

> 
> That should be no trouble to do as well. Actually, we currently do not even have a cocommutative axiom. It might be better to introduce these on a separate ticket.


Sure, a separate ticket would be good.



---

archive/issue_comments_357328.json:
```json
{
    "body": "<a id='comment:48'></a>red branch",
    "created_at": "2019-06-13T11:58:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357328",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:48'></a>red branch



---

archive/issue_events_064138.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2019-06-13T11:58:27Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25603#event-64138"
}
```



---

archive/issue_comments_357329.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-06-13T11:58:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357329",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_357330.json:
```json
{
    "body": "<a id='comment:49'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-06-13T18:19:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357330",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:49'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357331.json:
```json
{
    "body": "<a id='comment:50'></a>Rebased.\n\nMeanwhile, ping! It's been 10 months. I understand that you are not delighted with my approach, but I think it is (much) better than nothing. If there is no progress on this soon, please consider merging this and then fixing it later.",
    "created_at": "2019-06-13T18:22:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357331",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:50'></a>Rebased.

Meanwhile, ping! It's been 10 months. I understand that you are not delighted with my approach, but I think it is (much) better than nothing. If there is no progress on this soon, please consider merging this and then fixing it later.



---

archive/issue_comments_357332.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-06-13T18:22:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357332",
    "user": "https://github.com/jhpalmieri"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_357333.json:
```json
{
    "body": "<a id='comment:51'></a>The branch was still very red. Here is a better merge.\n\n---\nNew commits:",
    "created_at": "2019-06-18T07:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357333",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:51'></a>The branch was still very red. Here is a better merge.

---
New commits:



---

archive/issue_comments_357334.json:
```json
{
    "body": "<a id='comment:52'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-06-18T08:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357334",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:52'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357335.json:
```json
{
    "body": "<a id='comment:53'></a>still missing one doctest, as the coverage report says:\n\n```\n+categories/super_hopf_algebras_with_basis.py: 50.0% (1 of 2)\n```",
    "created_at": "2019-06-18T11:30:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357335",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:53'></a>still missing one doctest, as the coverage report says:

```
+categories/super_hopf_algebras_with_basis.py: 50.0% (1 of 2)
```



---

archive/issue_comments_357336.json:
```json
{
    "body": "<a id='comment:54'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-06-18T15:49:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357336",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:54'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357337.json:
```json
{
    "body": "<a id='comment:55'></a>Here is a doctest.",
    "created_at": "2019-06-18T16:25:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357337",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:55'></a>Here is a doctest.



---

archive/issue_comments_357338.json:
```json
{
    "body": "<a id='comment:56'></a>Bot is now fully green, thanks. Travis, any opinion on what to do here ?",
    "created_at": "2019-06-18T18:47:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357338",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:56'></a>Bot is now fully green, thanks. Travis, any opinion on what to do here ?



---

archive/issue_comments_357339.json:
```json
{
    "body": "<a id='comment:57'></a>Sorry, I kept meaning to get to this and kept getting distracted and putting it off. I don't like putting in place a solution that is not really good as it can take a fair bit of work to get to a better state. I need to implement what Nicolas and I discussed as stated in comment:41. Can you give me another ~3 weeks to do the work at the FPSAC SageDays? (Fr\u00e9d\u00e9ric, Mike, and Darij will you be there? Perhaps we can do some work there too.) I am doing workshop after conference until then, so I cannot do it before then unfortunately.",
    "created_at": "2019-06-19T07:41:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357339",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:57'></a>Sorry, I kept meaning to get to this and kept getting distracted and putting it off. I don't like putting in place a solution that is not really good as it can take a fair bit of work to get to a better state. I need to implement what Nicolas and I discussed as stated in comment:41. Can you give me another ~3 weeks to do the work at the FPSAC SageDays? (Frédéric, Mike, and Darij will you be there? Perhaps we can do some work there too.) I am doing workshop after conference until then, so I cannot do it before then unfortunately.



---

archive/issue_comments_357340.json:
```json
{
    "body": "<a id='comment:58'></a>I'll be at Sagedays, but I am not very up to date on this. I definitely do not like that a super-Hopf algebra has \"graded Hopf algebras\" as supercategory; while Hopf defined them in that way, this goes against 90% of usage in algebraic combinatorics. (Also, does the degree method mean to return the parity or the ZZ-degree if both exist?) But as you have probably noticed, I am being overly conservative with inheritance since I have no mental model of the consequences of category hierarchies; apparently parts of sage stretch the category system quite successfully. Frankly I just don't want to be the reviewer who gets flamed for regressions...",
    "created_at": "2019-06-19T07:51:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357340",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:58'></a>I'll be at Sagedays, but I am not very up to date on this. I definitely do not like that a super-Hopf algebra has "graded Hopf algebras" as supercategory; while Hopf defined them in that way, this goes against 90% of usage in algebraic combinatorics. (Also, does the degree method mean to return the parity or the ZZ-degree if both exist?) But as you have probably noticed, I am being overly conservative with inheritance since I have no mental model of the consequences of category hierarchies; apparently parts of sage stretch the category system quite successfully. Frankly I just don't want to be the reviewer who gets flamed for regressions...



---

archive/issue_comments_357341.json:
```json
{
    "body": "<a id='comment:59'></a>I'd say \"Don't let perfect be the enemy of the good\".  I'm happy with a solution that works.  I won't be at Sage Days but we can talk about it at FPSAC if you will be there.  I can take a look next week (I've got 2 more days of Garsiafest).",
    "created_at": "2019-06-19T14:58:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357341",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:59'></a>I'd say "Don't let perfect be the enemy of the good".  I'm happy with a solution that works.  I won't be at Sage Days but we can talk about it at FPSAC if you will be there.  I can take a look next week (I've got 2 more days of Garsiafest).



---

archive/issue_comments_357342.json:
```json
{
    "body": "<a id='comment:60'></a>There can be a difference between something good and something that works. I agree this is the latter group, but I do not really think it is in the former. It can also get us into a place where detangling the two ideas becomes more work than the initial effort.\n\nJohn, I know I owe you a big apology for letting this fall off my radar and not being able to do what I promise sooner.\n\nAddendum: Mike, enjoy Garciafest. I wish I could have gone. I am now on my way to UC Davis for the workshop there.",
    "created_at": "2019-06-19T15:55:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357342",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:60'></a>There can be a difference between something good and something that works. I agree this is the latter group, but I do not really think it is in the former. It can also get us into a place where detangling the two ideas becomes more work than the initial effort.

John, I know I owe you a big apology for letting this fall off my radar and not being able to do what I promise sooner.

Addendum: Mike, enjoy Garciafest. I wish I could have gone. I am now on my way to UC Davis for the workshop there.



---

archive/issue_comments_357343.json:
```json
{
    "body": "<a id='comment:61'></a>Replying to [comment:60 tscrim]:\n> There can be a difference between something good and something that works. I agree this is the latter group, but I do not really think it is in the former. It can also get us into a place where detangling the two ideas becomes more work than the initial effort.\n\n\nThere is a cost-benefit analysis to be done. How much will we gain by putting in something that works? How much longer will it take to put in something \"good\"? What do we lose in the intervening time? This all depends on how much better the second version is, and how long it takes to implement.\n\nI ask that if there is no better solution available by the end of the summer, you seriously consider accepting my approach.\n\n> John, I know I owe you a big apology for letting this fall off my radar and not being able to do what I promise sooner.\n\n\nI appreciate that. Of course it is not just you; as several of us have discussed on this ticket, the documentation for the category stuff is not in great shape, or else I could have done some or all of this myself.",
    "created_at": "2019-06-19T17:28:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357343",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:61'></a>Replying to [comment:60 tscrim]:
> There can be a difference between something good and something that works. I agree this is the latter group, but I do not really think it is in the former. It can also get us into a place where detangling the two ideas becomes more work than the initial effort.


There is a cost-benefit analysis to be done. How much will we gain by putting in something that works? How much longer will it take to put in something "good"? What do we lose in the intervening time? This all depends on how much better the second version is, and how long it takes to implement.

I ask that if there is no better solution available by the end of the summer, you seriously consider accepting my approach.

> John, I know I owe you a big apology for letting this fall off my radar and not being able to do what I promise sooner.


I appreciate that. Of course it is not just you; as several of us have discussed on this ticket, the documentation for the category stuff is not in great shape, or else I could have done some or all of this myself.



---

archive/issue_comments_357344.json:
```json
{
    "body": "<a id='comment:62'></a>Replying to [comment:58 gh-darijgr]:\n> I definitely do not like that a super-Hopf algebra has \"graded Hopf algebras\" as supercategory; while Hopf defined them in that way, this goes against 90% of usage in algebraic combinatorics.\n\n\nWhatever we do, we need to document it very well, because I think that different people use \"graded Hopf algebra\" (for example) to mean different things. In algebraic topology, it includes the sign in the tensor product, and I am deducing that this is not the case in combinatorics, right?\n\nI would also point out that so far in Sage, \"super\" just means Z/2-graded (from what I see in a few docstrings), and therefore any \"super blah\" should also be a \"blah\" and a \"graded blah\". So maybe \"super Hopf algebra\" is not the right name in Sage for the objects which have this sign on the tensor product. Either that or we need to clarify the documentation for what \"super\" means in Sage, or at least what \"super Hopf algebra\" means, pointing out that in Sage, if this is indeed the choice we make, a \"super Hopf algebra\" need not be a Hopf algebra while a \"graded Hopf algebra\" is one.\n\nActually, given the conflict in what \"graded Hopf algebra\" means to different mathematicians, my inclination would be to avoid the phrase altogether, and instead have something like \"Hopf algebra with grading\" for the combinatorial version, and I'm not sure what for the algebraic topology version.",
    "created_at": "2019-06-19T18:17:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357344",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:62'></a>Replying to [comment:58 gh-darijgr]:
> I definitely do not like that a super-Hopf algebra has "graded Hopf algebras" as supercategory; while Hopf defined them in that way, this goes against 90% of usage in algebraic combinatorics.


Whatever we do, we need to document it very well, because I think that different people use "graded Hopf algebra" (for example) to mean different things. In algebraic topology, it includes the sign in the tensor product, and I am deducing that this is not the case in combinatorics, right?

I would also point out that so far in Sage, "super" just means Z/2-graded (from what I see in a few docstrings), and therefore any "super blah" should also be a "blah" and a "graded blah". So maybe "super Hopf algebra" is not the right name in Sage for the objects which have this sign on the tensor product. Either that or we need to clarify the documentation for what "super" means in Sage, or at least what "super Hopf algebra" means, pointing out that in Sage, if this is indeed the choice we make, a "super Hopf algebra" need not be a Hopf algebra while a "graded Hopf algebra" is one.

Actually, given the conflict in what "graded Hopf algebra" means to different mathematicians, my inclination would be to avoid the phrase altogether, and instead have something like "Hopf algebra with grading" for the combinatorial version, and I'm not sure what for the algebraic topology version.



---

archive/issue_comments_357345.json:
```json
{
    "body": "<a id='comment:63'></a>> Whatever we do, we need to document it very well, because I think that different people use \"graded Hopf algebra\" (for example) to mean different things. In algebraic topology, it includes the sign in the tensor product, and I am deducing that this is not the case in combinatorics, right?\n\n\nCorrect. The idea, I think, is that our graded Hopf algebras are understood as graded algebras with extra features. And few commutative algebraists or algebraic geometers would artificially duplicate the degrees of all polynomials just so that they can say that the polynomial ring is commutative (the exception is Eisenbud in an appendix to his book, but not in the rest of the book). To my knowledge, the only algebraic combinatorialists who include signs in their graded Hopf algebras by default are some invariant theorists around Rota.\n\nThinking of it this way, it's a nice example of a diamond inheritance failure in mathematics :)\n\n> I would also point out that so far in Sage, \"super\" just means Z/2-graded (from what I see in a few docstrings), and therefore any \"super blah\" should also be a \"blah\" and a \"graded blah\". So maybe \"super Hopf algebra\" is not the right name in Sage for the objects which have this sign on the tensor product. Either that or we need to clarify the documentation for what \"super\" means in Sage, or at least what \"super Hopf algebra\" means, pointing out that in Sage, if this is indeed the choice we make, a \"super Hopf algebra\" need not be a Hopf algebra while a \"graded Hopf algebra\" is one.\n\n\nThe problem is: you can say that a superalgebra is an algebra with extra structure, but a tensor product of superalgebras is not a tensor product of the underlying algebras with extra structure. And I don't know if this kind of nuance can survive the Sage category framework.\n\n> Actually, given the conflict in what \"graded Hopf algebra\" means to different mathematicians, my inclination would be to avoid the phrase altogether, and instead have something like \"Hopf algebra with grading\" for the combinatorial version, and I'm not sure what for the algebraic topology version.\n\n\nSuper-Hopf algebra with grading, I'd say. I would otherwise call it graded super-Hopf algebra or graded Hopf superalgebra.",
    "created_at": "2019-06-19T18:42:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357345",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:63'></a>> Whatever we do, we need to document it very well, because I think that different people use "graded Hopf algebra" (for example) to mean different things. In algebraic topology, it includes the sign in the tensor product, and I am deducing that this is not the case in combinatorics, right?


Correct. The idea, I think, is that our graded Hopf algebras are understood as graded algebras with extra features. And few commutative algebraists or algebraic geometers would artificially duplicate the degrees of all polynomials just so that they can say that the polynomial ring is commutative (the exception is Eisenbud in an appendix to his book, but not in the rest of the book). To my knowledge, the only algebraic combinatorialists who include signs in their graded Hopf algebras by default are some invariant theorists around Rota.

Thinking of it this way, it's a nice example of a diamond inheritance failure in mathematics :)

> I would also point out that so far in Sage, "super" just means Z/2-graded (from what I see in a few docstrings), and therefore any "super blah" should also be a "blah" and a "graded blah". So maybe "super Hopf algebra" is not the right name in Sage for the objects which have this sign on the tensor product. Either that or we need to clarify the documentation for what "super" means in Sage, or at least what "super Hopf algebra" means, pointing out that in Sage, if this is indeed the choice we make, a "super Hopf algebra" need not be a Hopf algebra while a "graded Hopf algebra" is one.


The problem is: you can say that a superalgebra is an algebra with extra structure, but a tensor product of superalgebras is not a tensor product of the underlying algebras with extra structure. And I don't know if this kind of nuance can survive the Sage category framework.

> Actually, given the conflict in what "graded Hopf algebra" means to different mathematicians, my inclination would be to avoid the phrase altogether, and instead have something like "Hopf algebra with grading" for the combinatorial version, and I'm not sure what for the algebraic topology version.


Super-Hopf algebra with grading, I'd say. I would otherwise call it graded super-Hopf algebra or graded Hopf superalgebra.



---

archive/issue_comments_357346.json:
```json
{
    "body": "<a id='comment:64'></a>Replying to [comment:61 jhpalmieri]:\n> Replying to [comment:60 tscrim]:\n> > There can be a difference between something good and something that works. I agree this is the latter group, but I do not really think it is in the former. It can also get us into a place where detangling the two ideas becomes more work than the initial effort.\n\n> \n> There is a cost-benefit analysis to be done. How much will we gain by putting in something that works? How much longer will it take to put in something \"good\"? What do we lose in the intervening time? This all depends on how much better the second version is, and how long it takes to implement.\n> \n> I ask that if there is no better solution available by the end of the summer, you seriously consider accepting my approach.\n\n\nIf I do not have it (nearly) done by the end of SageDays, I will set the positive review myself.",
    "created_at": "2019-06-21T07:59:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357346",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:64'></a>Replying to [comment:61 jhpalmieri]:
> Replying to [comment:60 tscrim]:
> > There can be a difference between something good and something that works. I agree this is the latter group, but I do not really think it is in the former. It can also get us into a place where detangling the two ideas becomes more work than the initial effort.

> 
> There is a cost-benefit analysis to be done. How much will we gain by putting in something that works? How much longer will it take to put in something "good"? What do we lose in the intervening time? This all depends on how much better the second version is, and how long it takes to implement.
> 
> I ask that if there is no better solution available by the end of the summer, you seriously consider accepting my approach.


If I do not have it (nearly) done by the end of SageDays, I will set the positive review myself.



---

archive/issue_comments_357347.json:
```json
{
    "body": "<a id='comment:65'></a>I am hopeful that you will make progress, so I don't plan to work on my version. If it gets to the point that we have to settle for mine, I should probably clean up some things: add some documentation (as discussed with Darij above), and I guess remove graded Hopf algebras as a supercategory for super Hopf algebras. I'll wait to do any of this, in the hope that I won't ever have to.",
    "created_at": "2019-06-21T17:47:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357347",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:65'></a>I am hopeful that you will make progress, so I don't plan to work on my version. If it gets to the point that we have to settle for mine, I should probably clean up some things: add some documentation (as discussed with Darij above), and I guess remove graded Hopf algebras as a supercategory for super Hopf algebras. I'll wait to do any of this, in the hope that I won't ever have to.



---

archive/issue_comments_357348.json:
```json
{
    "body": "<a id='comment:66'></a>Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).",
    "created_at": "2019-07-03T11:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357348",
    "user": "https://github.com/embray"
}
```

<a id='comment:66'></a>Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).



---

archive/issue_events_064139.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-07-03T11:37:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25603#event-64139"
}
```



---

archive/issue_events_064140.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-07-03T11:37:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "milestone": "sage-8.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25603#event-64140"
}
```



---

archive/issue_comments_357349.json:
```json
{
    "body": "Changing keywords from \"\" to \"fpsac2019\".",
    "created_at": "2019-07-12T09:20:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357349",
    "user": "https://github.com/tscrim"
}
```

Changing keywords from "" to "fpsac2019".



---

archive/issue_comments_357350.json:
```json
{
    "body": "<a id='comment:67'></a>Okay, here is the proposal I have worked on with a fair bit of input from Nicolas (thank you!) that was sketched out in comment:41. So functionally it works by anything with a super defaults to using the signed tensor product where this makes sense. I did this by a little trick of setting the `_functor_name` to also use the same constructor, which is then overwritten by the `SuperAlgebras` category. I also added the axioms (super)cocommutative for people to build upon and mark classes as necessary. I put the exterior algebra in the category of supercommutative algebras. Ready for review.\n\nAddendum - John, I left you on as an author since I was using a number of your changes from your branch.\n\n---\nNew commits:",
    "created_at": "2019-07-12T09:20:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357350",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:67'></a>Okay, here is the proposal I have worked on with a fair bit of input from Nicolas (thank you!) that was sketched out in comment:41. So functionally it works by anything with a super defaults to using the signed tensor product where this makes sense. I did this by a little trick of setting the `_functor_name` to also use the same constructor, which is then overwritten by the `SuperAlgebras` category. I also added the axioms (super)cocommutative for people to build upon and mark classes as necessary. I put the exterior algebra in the category of supercommutative algebras. Ready for review.

Addendum - John, I left you on as an author since I was using a number of your changes from your branch.

---
New commits:



---

archive/issue_comments_357351.json:
```json
{
    "body": "<a id='comment:68'></a>Thanks very much for working on this! I see one doctest failure with Python 2 (easy to fix):\n\n```\nFile \"src/sage/categories/with_realizations.py\", line 262, in sage.categories.with_realizations.WithRealizations\nFailed example:\n    C.super_categories()\nExpected:\n    [Join of Category of hopf algebras over Rational Field\n         and Category of graded algebras over Rational Field]\nGot:\n    [Join of Category of hopf algebras over Rational Field and Category of graded algebras over Rational Field and Category of graded coalgebras over Rational Field]\n```\nI see a few more with Python 3:\n\n```\nFile \"src/sage/categories/supercommutative_algebras.py\", line 77, in sage.categories.supercommutative_algebras.SupercommutativeAlgebras.WithBasis.ParentMethods._test_supercommutativity\nFailed example:\n    E._test_supercommutativity()\nExpected nothing\nGot:\n    doctest:warning\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/src/bin/sage-runtests\", line 179, in <module>\n        err = DC.run()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/control.py\", line 1232, in run\n        self.run_doctests()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/control.py\", line 933, in run_doctests\n        self.dispatcher.dispatch()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 2010, in dispatch\n        self.parallel_dispatch()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 1907, in parallel_dispatch\n        w.start()  # This might take some time\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 2193, in start\n        super(DocTestWorker, self).start()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/process.py\", line 112, in start\n        self._popen = self._Popen(self)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/context.py\", line 223, in _Popen\n        return _default_context.get_context().Process._Popen(process_obj)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/context.py\", line 277, in _Popen\n        return Popen(process_obj)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/popen_fork.py\", line 20, in __init__\n        self._launch(process_obj)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/popen_fork.py\", line 74, in _launch\n        code = process_obj._bootstrap()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/process.py\", line 297, in _bootstrap\n        self.run()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 2149, in run\n        task(self.options, self.outtmpfile, msgpipe, self.result_queue)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 2487, in __call__\n        doctests, extras = self._run(runner, options, results)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 2536, in _run\n        result = runner.run(test)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 879, in run\n        return self._run(test, compileflags, out)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 681, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 1105, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.categories.supercommutative_algebras.SupercommutativeAlgebras.WithBasis.ParentMethods._test_supercommutativity[1]>\", line 1, in <module>\n        E._test_supercommutativity()\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/categories/supercommutative_algebras.py\", line 97, in _test_supercommutativity\n        * (y * x))\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/unittest/case.py\", line 1337, in deprecated_func\n        DeprecationWarning, 2)\n      File \"/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/warnings.py\", line 110, in _showwarnmsg\n        msg.file, msg.line)\n    :\n    DeprecationWarning: Please use assertEqual instead.\n**********************************************************************\n1 item had failures:\n   1 of   5 in sage.categories.supercommutative_algebras.SupercommutativeAlgebras.WithBasis.ParentMethods._test_supercommutativity\n```\nand failures from the same deprecation warning in `algebras/clifford_algebra.py`.\n\n(I haven't actually run the full test suite, just tests in `algebras` and `categories`.)\n\nI'll be working my way through the code.",
    "created_at": "2019-07-12T16:52:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357351",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:68'></a>Thanks very much for working on this! I see one doctest failure with Python 2 (easy to fix):

```
File "src/sage/categories/with_realizations.py", line 262, in sage.categories.with_realizations.WithRealizations
Failed example:
    C.super_categories()
Expected:
    [Join of Category of hopf algebras over Rational Field
         and Category of graded algebras over Rational Field]
Got:
    [Join of Category of hopf algebras over Rational Field and Category of graded algebras over Rational Field and Category of graded coalgebras over Rational Field]
```
I see a few more with Python 3:

```
File "src/sage/categories/supercommutative_algebras.py", line 77, in sage.categories.supercommutative_algebras.SupercommutativeAlgebras.WithBasis.ParentMethods._test_supercommutativity
Failed example:
    E._test_supercommutativity()
Expected nothing
Got:
    doctest:warning
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/src/bin/sage-runtests", line 179, in <module>
        err = DC.run()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/control.py", line 1232, in run
        self.run_doctests()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/control.py", line 933, in run_doctests
        self.dispatcher.dispatch()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 2010, in dispatch
        self.parallel_dispatch()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1907, in parallel_dispatch
        w.start()  # This might take some time
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 2193, in start
        super(DocTestWorker, self).start()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/process.py", line 112, in start
        self._popen = self._Popen(self)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/context.py", line 223, in _Popen
        return _default_context.get_context().Process._Popen(process_obj)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/context.py", line 277, in _Popen
        return Popen(process_obj)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/popen_fork.py", line 20, in __init__
        self._launch(process_obj)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/popen_fork.py", line 74, in _launch
        code = process_obj._bootstrap()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/multiprocessing/process.py", line 297, in _bootstrap
        self.run()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 2149, in run
        task(self.options, self.outtmpfile, msgpipe, self.result_queue)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 2487, in __call__
        doctests, extras = self._run(runner, options, results)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 2536, in _run
        result = runner.run(test)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 879, in run
        return self._run(test, compileflags, out)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1105, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.categories.supercommutative_algebras.SupercommutativeAlgebras.WithBasis.ParentMethods._test_supercommutativity[1]>", line 1, in <module>
        E._test_supercommutativity()
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/site-packages/sage/categories/supercommutative_algebras.py", line 97, in _test_supercommutativity
        * (y * x))
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/unittest/case.py", line 1337, in deprecated_func
        DeprecationWarning, 2)
      File "/Users/palmieri/Desktop/Sage_stuff/sage_builds/PYTHON3/sage-8.9.beta2/local/lib/python3.7/warnings.py", line 110, in _showwarnmsg
        msg.file, msg.line)
    :
    DeprecationWarning: Please use assertEqual instead.
**********************************************************************
1 item had failures:
   1 of   5 in sage.categories.supercommutative_algebras.SupercommutativeAlgebras.WithBasis.ParentMethods._test_supercommutativity
```
and failures from the same deprecation warning in `algebras/clifford_algebra.py`.

(I haven't actually run the full test suite, just tests in `algebras` and `categories`.)

I'll be working my way through the code.



---

archive/issue_comments_357352.json:
```json
{
    "body": "<a id='comment:69'></a>The \"docstring\" for `signed_tensor` is not working the way you want. I suggest this change:\n\n```diff\ndiff --git a/src/sage/categories/signed_tensor.py b/src/sage/categories/signed_tensor.py\nindex 493df0ea90..6d2873c04b 100644\n--- a/src/sage/categories/signed_tensor.py\n+++ b/src/sage/categories/signed_tensor.py\n@@ -39,6 +39,11 @@ class SignedTensorProductFunctor(CovariantFunctorialConstruction):\n     of ``Algebras(QQ).Graded()``. This nested class is itself a subclass of\n     :class:`~sage.categories.signed_tensor.SignedTensorProductsCategory`.\n \n+    EXAMPLES::\n+\n+        sage: signed_tensor\n+        The signed tensor functorial construction\n+\n     TESTS::\n \n         sage: TestSuite(signed_tensor).run()\n@@ -60,17 +65,6 @@ class SignedTensorProductFunctor(CovariantFunctorialConstruction):\n         return \"The signed tensor functorial construction\"\n \n signed_tensor = SignedTensorProductFunctor()\n-\"\"\"\n-The signed tensor product functorial construction.\n-\n-See :class:`~sage.categories.signed_tensor.SignedTensorProductFunctor`\n-for more information.\n-\n-EXAMPLES::\n-\n-    sage: signed_tensor\n-    The signed tensor functorial construction\n-\"\"\"\n \n class SignedTensorProductsCategory(CovariantConstructionCategory):\n     r\"\"\"\n```\nDo you want to include `signed_tensor.py` and also `supercommutative_algebras.py` in the reference manual?",
    "created_at": "2019-07-12T17:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357352",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:69'></a>The "docstring" for `signed_tensor` is not working the way you want. I suggest this change:

```diff
diff --git a/src/sage/categories/signed_tensor.py b/src/sage/categories/signed_tensor.py
index 493df0ea90..6d2873c04b 100644
--- a/src/sage/categories/signed_tensor.py
+++ b/src/sage/categories/signed_tensor.py
@@ -39,6 +39,11 @@ class SignedTensorProductFunctor(CovariantFunctorialConstruction):
     of ``Algebras(QQ).Graded()``. This nested class is itself a subclass of
     :class:`~sage.categories.signed_tensor.SignedTensorProductsCategory`.
 
+    EXAMPLES::
+
+        sage: signed_tensor
+        The signed tensor functorial construction
+
     TESTS::
 
         sage: TestSuite(signed_tensor).run()
@@ -60,17 +65,6 @@ class SignedTensorProductFunctor(CovariantFunctorialConstruction):
         return "The signed tensor functorial construction"
 
 signed_tensor = SignedTensorProductFunctor()
-"""
-The signed tensor product functorial construction.
-
-See :class:`~sage.categories.signed_tensor.SignedTensorProductFunctor`
-for more information.
-
-EXAMPLES::
-
-    sage: signed_tensor
-    The signed tensor functorial construction
-"""
 
 class SignedTensorProductsCategory(CovariantConstructionCategory):
     r"""
```
Do you want to include `signed_tensor.py` and also `supercommutative_algebras.py` in the reference manual?



---

archive/issue_comments_357353.json:
```json
{
    "body": "<a id='comment:70'></a>Should `signed_tensor` be a top-level command? I don't know if that's necessary. If so, should it instead be `tensor_signed` so it can be discovered maybe more naturally using tab-completion?",
    "created_at": "2019-07-12T17:30:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357353",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:70'></a>Should `signed_tensor` be a top-level command? I don't know if that's necessary. If so, should it instead be `tensor_signed` so it can be discovered maybe more naturally using tab-completion?



---

archive/issue_comments_357354.json:
```json
{
    "body": "<a id='comment:71'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-12T17:52:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357354",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:71'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357355.json:
```json
{
    "body": "<a id='comment:72'></a>This fixes the doctest failures and makes a few other changes. No changes to `signed_tensor`, since I don't know what you think about my comments and questions.",
    "created_at": "2019-07-12T17:53:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357355",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:72'></a>This fixes the doctest failures and makes a few other changes. No changes to `signed_tensor`, since I don't know what you think about my comments and questions.



---

archive/issue_comments_357356.json:
```json
{
    "body": "<a id='comment:73'></a>Overall it looks good. Maybe on a followup ticket we can add some documentation clarifying that graded Hopf algebras are actually Hopf algebras, whereas super Hopf algebras are not (i.e., making sure that algebraic topologists know what they're getting into).",
    "created_at": "2019-07-12T17:55:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357356",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:73'></a>Overall it looks good. Maybe on a followup ticket we can add some documentation clarifying that graded Hopf algebras are actually Hopf algebras, whereas super Hopf algebras are not (i.e., making sure that algebraic topologists know what they're getting into).



---

archive/issue_comments_357357.json:
```json
{
    "body": "<a id='comment:74'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-12T21:20:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357357",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:74'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357358.json:
```json
{
    "body": "<a id='comment:75'></a>Here are more easy doctest fixes. There is one failure I don't know what to do with:\n\n```\n**********************************************************************\nFile \"src/sage/misc/c3_controlled.pyx\", line 331, in sage.misc.c3_controlled\nFailed example:\n    x.mro == x.mro_standard\nException raised:\n    Traceback (most recent call last):\n      File \"/Users/palmieri/Desktop/Sage_stuff/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 681, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/Users/palmieri/Desktop/Sage_stuff/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 1105, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.misc.c3_controlled[53]>\", line 1, in <module>\n        x.mro == x.mro_standard\n      File \"sage/misc/lazy_attribute.pyx\", line 129, in sage.misc.lazy_attribute._lazy_attribute.__get__ (build/cythonized/sage/misc/lazy_attribute.c:1940)\n        result = self.f(a)\n      File \"sage/misc/c3_controlled.pyx\", line 1234, in sage.misc.c3_controlled.HierarchyElement.mro_standard (build/cythonized/sage/misc/c3_controlled.c:6991)\n        return [self.value] + C3_merge([base.mro_standard for base in bases]+[[base.value for base in bases]])\n      File \"sage/misc/c3_controlled.pyx\", line 661, in sage.misc.c3_controlled.C3_merge (build/cythonized/sage/misc/c3_controlled.c:3495)\n        raise ValueError(\"Can not merge the items %s.\"%', '.join([repr(head) for head in heads]))\n    ValueError: Can not merge the items Category of coalgebras with basis over Rational Field, Category of filtered modules with basis over Rational Field, Category of filtered modules with basis over Rational Field.\n**********************************************************************\n1 item had failures:\n   1 of  59 in sage.misc.c3_controlled\n    [221 tests, 1 failure, 1.16 s]\n----------------------------------------------------------------------\nsage -t --long --warn-long 60.3 src/sage/misc/c3_controlled.pyx  # 1 doctest failed\n```",
    "created_at": "2019-07-12T21:28:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357358",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:75'></a>Here are more easy doctest fixes. There is one failure I don't know what to do with:

```
**********************************************************************
File "src/sage/misc/c3_controlled.pyx", line 331, in sage.misc.c3_controlled
Failed example:
    x.mro == x.mro_standard
Exception raised:
    Traceback (most recent call last):
      File "/Users/palmieri/Desktop/Sage_stuff/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/palmieri/Desktop/Sage_stuff/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1105, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.misc.c3_controlled[53]>", line 1, in <module>
        x.mro == x.mro_standard
      File "sage/misc/lazy_attribute.pyx", line 129, in sage.misc.lazy_attribute._lazy_attribute.__get__ (build/cythonized/sage/misc/lazy_attribute.c:1940)
        result = self.f(a)
      File "sage/misc/c3_controlled.pyx", line 1234, in sage.misc.c3_controlled.HierarchyElement.mro_standard (build/cythonized/sage/misc/c3_controlled.c:6991)
        return [self.value] + C3_merge([base.mro_standard for base in bases]+[[base.value for base in bases]])
      File "sage/misc/c3_controlled.pyx", line 661, in sage.misc.c3_controlled.C3_merge (build/cythonized/sage/misc/c3_controlled.c:3495)
        raise ValueError("Can not merge the items %s."%', '.join([repr(head) for head in heads]))
    ValueError: Can not merge the items Category of coalgebras with basis over Rational Field, Category of filtered modules with basis over Rational Field, Category of filtered modules with basis over Rational Field.
**********************************************************************
1 item had failures:
   1 of  59 in sage.misc.c3_controlled
    [221 tests, 1 failure, 1.16 s]
----------------------------------------------------------------------
sage -t --long --warn-long 60.3 src/sage/misc/c3_controlled.pyx  # 1 doctest failed
```



---

archive/issue_comments_357359.json:
```json
{
    "body": "<a id='comment:76'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-13T09:55:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357359",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:76'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357360.json:
```json
{
    "body": "<a id='comment:77'></a>Thank you for taking a look at this and fixing these odds and ends. I appreciate it. Sorry again for taking so long to do this (although I found I did need Nicolas's help quite a bit to get some of the technical things with the categories correct).\n\nI like the suggestion in comment:70, so I implemented that. I think it should be a top-level command as there could be someone who has a graded algebra that does want signed tensor products. I did forget to add the new categories to the reference manual; so I added them. I also fixed the C3 issue by adding a few placeholder classes (I also moved one class to its appropriate file).",
    "created_at": "2019-07-13T09:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357360",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:77'></a>Thank you for taking a look at this and fixing these odds and ends. I appreciate it. Sorry again for taking so long to do this (although I found I did need Nicolas's help quite a bit to get some of the technical things with the categories correct).

I like the suggestion in comment:70, so I implemented that. I think it should be a top-level command as there could be someone who has a graded algebra that does want signed tensor products. I did forget to add the new categories to the reference manual; so I added them. I also fixed the C3 issue by adding a few placeholder classes (I also moved one class to its appropriate file).



---

archive/issue_comments_357361.json:
```json
{
    "body": "<a id='comment:78'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-13T15:25:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357361",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:78'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357362.json:
```json
{
    "body": "<a id='comment:79'></a>New doctest failures in `clifford_algebra.py` and `super_modules_with_basis.py`, with very long tracebacks, but the punchline seems to be\n\n```\n    TypeError: Cannot create a consistent method resolution\n    order (MRO) for bases FilteredModules.subcategory_class, VectorSpaces.subcategory_class\n```",
    "created_at": "2019-07-13T15:27:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357362",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:79'></a>New doctest failures in `clifford_algebra.py` and `super_modules_with_basis.py`, with very long tracebacks, but the punchline seems to be

```
    TypeError: Cannot create a consistent method resolution
    order (MRO) for bases FilteredModules.subcategory_class, VectorSpaces.subcategory_class
```



---

archive/issue_comments_357363.json:
```json
{
    "body": "<a id='comment:80'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-13T16:40:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357363",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:80'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357364.json:
```json
{
    "body": "<a id='comment:81'></a>Sorry about that; I thought I had ran all the tests in the categories folder. Thank you for fixing the remaining stuff from my changes.\n\nI fixed the MRO issue by adding some more placeholder classes for graded/filtered vector spaces. This fixes #15475 and #20896.",
    "created_at": "2019-07-13T16:47:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357364",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:81'></a>Sorry about that; I thought I had ran all the tests in the categories folder. Thank you for fixing the remaining stuff from my changes.

I fixed the MRO issue by adding some more placeholder classes for graded/filtered vector spaces. This fixes #15475 and #20896.



---

archive/issue_comments_357365.json:
```json
{
    "body": "<a id='comment:82'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-07-13T16:48:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357365",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:82'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_357366.json:
```json
{
    "body": "<a id='comment:83'></a>I think this looks good, but I'm going to keep banging away at it for a few days.\n\nA few questions:\n- This is probably overkill, but in characteristic 2, would it make sense to automatically convert super -> graded (over Z/2), since there are no signs involved? Probably not worth it, but in characteristic 2, exterior algebras are honest Hopf algebras, as is the mod 2 Steenrod algebra.\n- Why this asymmetry?\n\n```\nsage: AlgebrasWithBasis(QQ).Super().super_categories()\n[Category of graded algebras with basis over Rational Field,\n Category of super algebras over Rational Field,\n Category of super modules with basis over Rational Field]\nsage: CoalgebrasWithBasis(QQ).Super().super_categories()\n[Category of super modules with basis over Rational Field,\n Category of coalgebras with basis over Rational Field,\n Category of super coalgebras over Rational Field]\n```\n Should \"Category of *graded* coalgebras with basis ...\" be among the super categories in the second case, rather than just \"Category of coalgebras with basis ...\"?",
    "created_at": "2019-07-14T02:01:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357366",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:83'></a>I think this looks good, but I'm going to keep banging away at it for a few days.

A few questions:
- This is probably overkill, but in characteristic 2, would it make sense to automatically convert super -> graded (over Z/2), since there are no signs involved? Probably not worth it, but in characteristic 2, exterior algebras are honest Hopf algebras, as is the mod 2 Steenrod algebra.
- Why this asymmetry?

```
sage: AlgebrasWithBasis(QQ).Super().super_categories()
[Category of graded algebras with basis over Rational Field,
 Category of super algebras over Rational Field,
 Category of super modules with basis over Rational Field]
sage: CoalgebrasWithBasis(QQ).Super().super_categories()
[Category of super modules with basis over Rational Field,
 Category of coalgebras with basis over Rational Field,
 Category of super coalgebras over Rational Field]
```
 Should "Category of *graded* coalgebras with basis ..." be among the super categories in the second case, rather than just "Category of coalgebras with basis ..."?



---

archive/issue_comments_357367.json:
```json
{
    "body": "<a id='comment:84'></a>Replying to [comment:81 tscrim]:\n> I fixed the MRO issue by adding some more placeholder classes for graded/filtered vector spaces. This fixes #15475 and #20896.\n\n\nAre those actually still problems? I tried the examples in the ticket descriptions, and they work in vanilla 8.9.beta2. [An example from one of darij's comments](https://trac.sagemath.org/ticket/15475#comment:47) is indeed fixed by this, I think.",
    "created_at": "2019-07-14T02:02:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357367",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:84'></a>Replying to [comment:81 tscrim]:
> I fixed the MRO issue by adding some more placeholder classes for graded/filtered vector spaces. This fixes #15475 and #20896.


Are those actually still problems? I tried the examples in the ticket descriptions, and they work in vanilla 8.9.beta2. [An example from one of darij's comments](https://trac.sagemath.org/ticket/15475#comment:47) is indeed fixed by this, I think.



---

archive/issue_comments_357368.json:
```json
{
    "body": "<a id='comment:85'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-14T06:56:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357368",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:85'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357369.json:
```json
{
    "body": "<a id='comment:86'></a>Replying to [comment:83 jhpalmieri]:\n> I think this looks good, but I'm going to keep banging away at it for a few days.\n\n\nThank you.\n\n> - This is probably overkill, but in characteristic 2, would it make sense to automatically convert super -> graded (over Z/2), since there are no signs involved? Probably not worth it, but in characteristic 2, exterior algebras are honest Hopf algebras, as is the mod 2 Steenrod algebra.\n\n\nPerhaps this would not be bad to add, but I am a little worried about mucking with the `extra_super_categories()` too much at this point. So I think it would be good for a followup ticket as I might have already rolled too much into here (i.e., the (super)(co)commutative axioms).\n\n> - Why this asymmetry?\n> \n> ```\n> sage: AlgebrasWithBasis(QQ).Super().super_categories()\n> [Category of graded algebras with basis over Rational Field,\n>  Category of super algebras over Rational Field,\n>  Category of super modules with basis over Rational Field]\n> sage: CoalgebrasWithBasis(QQ).Super().super_categories()\n> [Category of super modules with basis over Rational Field,\n>  Category of coalgebras with basis over Rational Field,\n>  Category of super coalgebras over Rational Field]\n> ```\n>  Should \"Category of *graded* coalgebras with basis ...\" be among the super categories in the second case, rather than just \"Category of coalgebras with basis ...\"?\n\n\nThat was a bug. Good catch. I forgot to add the `extra_super_categories` for that class.",
    "created_at": "2019-07-14T07:00:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357369",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:86'></a>Replying to [comment:83 jhpalmieri]:
> I think this looks good, but I'm going to keep banging away at it for a few days.


Thank you.

> - This is probably overkill, but in characteristic 2, would it make sense to automatically convert super -> graded (over Z/2), since there are no signs involved? Probably not worth it, but in characteristic 2, exterior algebras are honest Hopf algebras, as is the mod 2 Steenrod algebra.


Perhaps this would not be bad to add, but I am a little worried about mucking with the `extra_super_categories()` too much at this point. So I think it would be good for a followup ticket as I might have already rolled too much into here (i.e., the (super)(co)commutative axioms).

> - Why this asymmetry?
> 
> ```
> sage: AlgebrasWithBasis(QQ).Super().super_categories()
> [Category of graded algebras with basis over Rational Field,
>  Category of super algebras over Rational Field,
>  Category of super modules with basis over Rational Field]
> sage: CoalgebrasWithBasis(QQ).Super().super_categories()
> [Category of super modules with basis over Rational Field,
>  Category of coalgebras with basis over Rational Field,
>  Category of super coalgebras over Rational Field]
> ```
>  Should "Category of *graded* coalgebras with basis ..." be among the super categories in the second case, rather than just "Category of coalgebras with basis ..."?


That was a bug. Good catch. I forgot to add the `extra_super_categories` for that class.



---

archive/issue_comments_357370.json:
```json
{
    "body": "<a id='comment:87'></a>Replying to [comment:84 jhpalmieri]:\n> Replying to [comment:81 tscrim]:\n> > I fixed the MRO issue by adding some more placeholder classes for graded/filtered vector spaces. This fixes #15475 and #20896.\n\n> \n> Are those actually still problems? I tried the examples in the ticket descriptions, and they work in vanilla 8.9.beta2. [An example from one of darij's comments](https://trac.sagemath.org/ticket/15475#comment:47) is indeed fixed by this, I think.\n\n\nCuriously enough with this branch, I am actually getting back the behavior on that comment. So something very subtle is going on, but the MRO issue seems to still be resolved. The reason why I mentioned those tickets was because the MRO issue reminded me of them, but that seems to be a red herring. Curious...",
    "created_at": "2019-07-14T07:04:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357370",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:87'></a>Replying to [comment:84 jhpalmieri]:
> Replying to [comment:81 tscrim]:
> > I fixed the MRO issue by adding some more placeholder classes for graded/filtered vector spaces. This fixes #15475 and #20896.

> 
> Are those actually still problems? I tried the examples in the ticket descriptions, and they work in vanilla 8.9.beta2. [An example from one of darij's comments](https://trac.sagemath.org/ticket/15475#comment:47) is indeed fixed by this, I think.


Curiously enough with this branch, I am actually getting back the behavior on that comment. So something very subtle is going on, but the MRO issue seems to still be resolved. The reason why I mentioned those tickets was because the MRO issue reminded me of them, but that seems to be a red herring. Curious...



---

archive/issue_comments_357371.json:
```json
{
    "body": "<a id='comment:88'></a>The can of superworms has just been reopened on MathOverflow: https://mathoverflow.net/questions/335889/hopf-structure-on-the-universal-enveloping-of-a-super-hopf-algebra\n\nNote that Bugs Bunny, in his answer, does something very similar to what you guys have agreed on (I think?): use different symbols \\otimes and \\otimes^{sup} for tensors and super-tensors, even at the level of elements.",
    "created_at": "2019-07-14T08:32:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357371",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:88'></a>The can of superworms has just been reopened on MathOverflow: https://mathoverflow.net/questions/335889/hopf-structure-on-the-universal-enveloping-of-a-super-hopf-algebra

Note that Bugs Bunny, in his answer, does something very similar to what you guys have agreed on (I think?): use different symbols \otimes and \otimes^{sup} for tensors and super-tensors, even at the level of elements.



---

archive/issue_comments_357372.json:
```json
{
    "body": "<a id='comment:89'></a>\n```\n--- a/src/sage/algebras/clifford_algebra.py\n+++ b/src/sage/algebras/clifford_algebra.py\n-        cat = HopfAlgebrasWithBasis(R).Super().FiniteDimensional()\n+        cat = HopfAlgebrasWithBasis(R).FiniteDimensional().Supercommutative().Supercocommutative()\n```\nAre you sure it shouldn't be \"HopfSuperAlgebrasWithBasis(R)\"?\n\n```\n--- a/src/sage/algebras/steenrod/steenrod_algebra.py\n+++ b/src/sage/algebras/steenrod/steenrod_algebra.py\n-        from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis\n+        from sage.categories.super_hopf_algebras_with_basis import SuperHopfAlgebrasWithBasis\n```\nI see the existence of a Z-grading (as opposed to just as a Z/2-grading) is getting lost here. Is there a way to preserve it? A GradedSuperHopfAlgebrasWithBasis category perhaps? Or are we not having anything that can make use of the grading to begin with?\n\n(Eventually, gradings will be very useful, as they allow you to do linear algebra when the graded parts are finite-dimensional.)\n\n```\n--- a/src/sage/categories/coalgebras.py\n+++ b/src/sage/categories/coalgebras.py\n+    class Cocommutative(CategoryWithAxiom_over_base_ring):\n+        \"\"\"\n+        Category of cocommutative coalgebras.\n+        \"\"\"\n```\nIs this class meant to be completely empty as it currently stands?\n\n```\n+        class SubcategoryMethods:\n+            @cached_method\n+            def Supercocommutative(self):\n+                r\"\"\"\n+                Return the full subcategory of the supercocommutative\n+                objects of ``self``.\n```\nThis seems to be in the Coalgebras class. But it only makes sense for supercoalgebras. Are we trying to cause spooky action at a distance here?\n\n```\n--- a/src/sage/categories/graded_algebras_with_basis.py\n+++ b/src/sage/categories/graded_algebras_with_basis.py\n+    class SignedTensorProducts(SignedTensorProductsCategory):\n+        \"\"\"\n+        The category of algebras with basis constructed by signed tensor\n+        product of algebras with basis.\n+        \"\"\"\n```\nThe word \"super\", or at least \"graded\", should probably fall somewhere here.\n\nCan you add doctests verifying that SuperBialgebras are not a subcat of Bialgebras, supercommutative superalgebras are not commutative algebras, and same for supercoalgebras?",
    "created_at": "2019-07-16T13:13:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357372",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:89'></a>
```
--- a/src/sage/algebras/clifford_algebra.py
+++ b/src/sage/algebras/clifford_algebra.py
-        cat = HopfAlgebrasWithBasis(R).Super().FiniteDimensional()
+        cat = HopfAlgebrasWithBasis(R).FiniteDimensional().Supercommutative().Supercocommutative()
```
Are you sure it shouldn't be "HopfSuperAlgebrasWithBasis(R)"?

```
--- a/src/sage/algebras/steenrod/steenrod_algebra.py
+++ b/src/sage/algebras/steenrod/steenrod_algebra.py
-        from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis
+        from sage.categories.super_hopf_algebras_with_basis import SuperHopfAlgebrasWithBasis
```
I see the existence of a Z-grading (as opposed to just as a Z/2-grading) is getting lost here. Is there a way to preserve it? A GradedSuperHopfAlgebrasWithBasis category perhaps? Or are we not having anything that can make use of the grading to begin with?

(Eventually, gradings will be very useful, as they allow you to do linear algebra when the graded parts are finite-dimensional.)

```
--- a/src/sage/categories/coalgebras.py
+++ b/src/sage/categories/coalgebras.py
+    class Cocommutative(CategoryWithAxiom_over_base_ring):
+        """
+        Category of cocommutative coalgebras.
+        """
```
Is this class meant to be completely empty as it currently stands?

```
+        class SubcategoryMethods:
+            @cached_method
+            def Supercocommutative(self):
+                r"""
+                Return the full subcategory of the supercocommutative
+                objects of ``self``.
```
This seems to be in the Coalgebras class. But it only makes sense for supercoalgebras. Are we trying to cause spooky action at a distance here?

```
--- a/src/sage/categories/graded_algebras_with_basis.py
+++ b/src/sage/categories/graded_algebras_with_basis.py
+    class SignedTensorProducts(SignedTensorProductsCategory):
+        """
+        The category of algebras with basis constructed by signed tensor
+        product of algebras with basis.
+        """
```
The word "super", or at least "graded", should probably fall somewhere here.

Can you add doctests verifying that SuperBialgebras are not a subcat of Bialgebras, supercommutative superalgebras are not commutative algebras, and same for supercoalgebras?



---

archive/issue_comments_357373.json:
```json
{
    "body": "<a id='comment:90'></a>Replying to [comment:89 gh-darijgr]:\n\nI can't answer any of the design questions, so I hope Travis will respond, too.\n\n> {{{\n> --- a/src/sage/algebras/clifford_algebra.py\n> +++ b/src/sage/algebras/clifford_algebra.py\n> -        cat = HopfAlgebrasWithBasis(R).Super().FiniteDimensional()\n> +        cat = HopfAlgebrasWithBasis(R).FiniteDimensional().Supercommutative().Supercocommutative()\n> }}}\n> Are you sure it shouldn't be \"HopfSuperAlgebrasWithBasis(R)\"?\n\n\nThe \"Supercommutative\" and \"Supercocommutative\" axioms imply \"Super\" Hopf algebra, so is this necessary?\n\n> {{{\n> --- a/src/sage/algebras/steenrod/steenrod_algebra.py\n> +++ b/src/sage/algebras/steenrod/steenrod_algebra.py\n> -        from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis\n> +        from sage.categories.super_hopf_algebras_with_basis import SuperHopfAlgebrasWithBasis\n> }}}\n> I see the existence of a Z-grading (as opposed to just as a Z/2-grading) is getting lost here. Is there a way to preserve it? A GradedSuperHopfAlgebrasWithBasis category perhaps? Or are we not having anything that can make use of the grading to begin with?\n\n\nMaybe a graded object should have a method or attribute `grading_group` (or whatever you want to call it). I'm not sure how else you would convey this information, because `GradedSuperHopfAlgebras...` is redundant: super implies graded, and \"graded\" should make no assumptions about what the grading group is. You could have `GradedConnectedSuperHopfAlgebras...` because graded + connected implies a Z-grading (at least to me: it doesn't mean \"connected as a Hopf algebra\" + \"graded as a (super) Hopf algebra\").\n\n> (Eventually, gradings will be very useful, as they allow you to do linear algebra when the graded parts are finite-dimensional.)\n\n\nAt least with the Steenrod algebra, there is a method `homogeneous_component` which takes a degree as input and returns the finite dimensional vector space, with basis, for the component in that degree.\n \n> {{{\n> --- a/src/sage/categories/coalgebras.py\n> +++ b/src/sage/categories/coalgebras.py\n> +    class Cocommutative(CategoryWithAxiom_over_base_ring):\n> +        \"\"\"\n> +        Category of cocommutative coalgebras.\n> +        \"\"\"\n> }}}\n> Is this class meant to be completely empty as it currently stands?\n> \n> \n> ```\n> +        class SubcategoryMethods:\n> +            @cached_method\n> +            def Supercocommutative(self):\n> +                r\"\"\"\n> +                Return the full subcategory of the supercocommutative\n> +                objects of ``self``.\n> ```\n> This seems to be in the Coalgebras class. But it only makes sense for supercoalgebras. Are we trying to cause spooky action at a distance here?\n\n\nI tried deleting this and got a few doctest failures:\n\n```\n**********************************************************************\nFile \"src/sage/categories/coalgebras.py\", line 262, in sage.categories.coalgebras.Coalgebras.Super.SubcategoryMethods.Supercocommutative\nFailed example:\n    Coalgebras(ZZ).WithBasis().Super().Supercocommutative()\nExpected:\n    Category of supercocommutative super coalgebras with basis over Integer Ring\nGot:\n    Category of super coalgebras with basis over Integer Ring\n**********************************************************************\nFile \"src/sage/categories/coalgebras.py\", line 264, in sage.categories.coalgebras.Coalgebras.Super.SubcategoryMethods.Supercocommutative\nFailed example:\n    BialgebrasWithBasis(QQ).Super().Supercocommutative()\nExpected:\n    Join of Category of super algebras with basis over Rational Field\n     and Category of super bialgebras over Rational Field\n     and Category of super coalgebras with basis over Rational Field\n     and Category of supercocommutative super coalgebras over Rational Field\nGot:\n    Join of Category of super algebras with basis over Rational Field and Category of super bialgebras over Rational Field and Category of super coalgebras with basis over Rational Field\n**********************************************************************\n1 item had failures:\n   2 of   4 in sage.categories.coalgebras.Coalgebras.Super.SubcategoryMethods.Supercocommutative\n    [70 tests, 2 failures, 0.40 s]\n----------------------------------------------------------------------\nsage -t src/sage/categories/coalgebras.py  # 2 doctests failed\n----------------------------------------------------------------------\n```\nI like the output from those doctests, so I wouldn't want to just delete the class and modify the doctests.\n\n> \n> \n> ```\n> --- a/src/sage/categories/graded_algebras_with_basis.py\n> +++ b/src/sage/categories/graded_algebras_with_basis.py\n> +    class SignedTensorProducts(SignedTensorProductsCategory):\n> +        \"\"\"\n> +        The category of algebras with basis constructed by signed tensor\n> +        product of algebras with basis.\n> +        \"\"\"\n> ```\n> The word \"super\", or at least \"graded\", should probably fall somewhere here.\n> \n> Can you add doctests verifying that SuperBialgebras are not a subcat of Bialgebras, supercommutative superalgebras are not commutative algebras, and same for supercoalgebras?\n\n\nI agree that this would be a good idea.",
    "created_at": "2019-07-16T22:24:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357373",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:90'></a>Replying to [comment:89 gh-darijgr]:

I can't answer any of the design questions, so I hope Travis will respond, too.

> {{{
> --- a/src/sage/algebras/clifford_algebra.py
> +++ b/src/sage/algebras/clifford_algebra.py
> -        cat = HopfAlgebrasWithBasis(R).Super().FiniteDimensional()
> +        cat = HopfAlgebrasWithBasis(R).FiniteDimensional().Supercommutative().Supercocommutative()
> }}}
> Are you sure it shouldn't be "HopfSuperAlgebrasWithBasis(R)"?


The "Supercommutative" and "Supercocommutative" axioms imply "Super" Hopf algebra, so is this necessary?

> {{{
> --- a/src/sage/algebras/steenrod/steenrod_algebra.py
> +++ b/src/sage/algebras/steenrod/steenrod_algebra.py
> -        from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis
> +        from sage.categories.super_hopf_algebras_with_basis import SuperHopfAlgebrasWithBasis
> }}}
> I see the existence of a Z-grading (as opposed to just as a Z/2-grading) is getting lost here. Is there a way to preserve it? A GradedSuperHopfAlgebrasWithBasis category perhaps? Or are we not having anything that can make use of the grading to begin with?


Maybe a graded object should have a method or attribute `grading_group` (or whatever you want to call it). I'm not sure how else you would convey this information, because `GradedSuperHopfAlgebras...` is redundant: super implies graded, and "graded" should make no assumptions about what the grading group is. You could have `GradedConnectedSuperHopfAlgebras...` because graded + connected implies a Z-grading (at least to me: it doesn't mean "connected as a Hopf algebra" + "graded as a (super) Hopf algebra").

> (Eventually, gradings will be very useful, as they allow you to do linear algebra when the graded parts are finite-dimensional.)


At least with the Steenrod algebra, there is a method `homogeneous_component` which takes a degree as input and returns the finite dimensional vector space, with basis, for the component in that degree.
 
> {{{
> --- a/src/sage/categories/coalgebras.py
> +++ b/src/sage/categories/coalgebras.py
> +    class Cocommutative(CategoryWithAxiom_over_base_ring):
> +        """
> +        Category of cocommutative coalgebras.
> +        """
> }}}
> Is this class meant to be completely empty as it currently stands?
> 
> 
> ```
> +        class SubcategoryMethods:
> +            @cached_method
> +            def Supercocommutative(self):
> +                r"""
> +                Return the full subcategory of the supercocommutative
> +                objects of ``self``.
> ```
> This seems to be in the Coalgebras class. But it only makes sense for supercoalgebras. Are we trying to cause spooky action at a distance here?


I tried deleting this and got a few doctest failures:

```
**********************************************************************
File "src/sage/categories/coalgebras.py", line 262, in sage.categories.coalgebras.Coalgebras.Super.SubcategoryMethods.Supercocommutative
Failed example:
    Coalgebras(ZZ).WithBasis().Super().Supercocommutative()
Expected:
    Category of supercocommutative super coalgebras with basis over Integer Ring
Got:
    Category of super coalgebras with basis over Integer Ring
**********************************************************************
File "src/sage/categories/coalgebras.py", line 264, in sage.categories.coalgebras.Coalgebras.Super.SubcategoryMethods.Supercocommutative
Failed example:
    BialgebrasWithBasis(QQ).Super().Supercocommutative()
Expected:
    Join of Category of super algebras with basis over Rational Field
     and Category of super bialgebras over Rational Field
     and Category of super coalgebras with basis over Rational Field
     and Category of supercocommutative super coalgebras over Rational Field
Got:
    Join of Category of super algebras with basis over Rational Field and Category of super bialgebras over Rational Field and Category of super coalgebras with basis over Rational Field
**********************************************************************
1 item had failures:
   2 of   4 in sage.categories.coalgebras.Coalgebras.Super.SubcategoryMethods.Supercocommutative
    [70 tests, 2 failures, 0.40 s]
----------------------------------------------------------------------
sage -t src/sage/categories/coalgebras.py  # 2 doctests failed
----------------------------------------------------------------------
```
I like the output from those doctests, so I wouldn't want to just delete the class and modify the doctests.

> 
> 
> ```
> --- a/src/sage/categories/graded_algebras_with_basis.py
> +++ b/src/sage/categories/graded_algebras_with_basis.py
> +    class SignedTensorProducts(SignedTensorProductsCategory):
> +        """
> +        The category of algebras with basis constructed by signed tensor
> +        product of algebras with basis.
> +        """
> ```
> The word "super", or at least "graded", should probably fall somewhere here.
> 
> Can you add doctests verifying that SuperBialgebras are not a subcat of Bialgebras, supercommutative superalgebras are not commutative algebras, and same for supercoalgebras?


I agree that this would be a good idea.



---

archive/issue_comments_357374.json:
```json
{
    "body": "<a id='comment:91'></a>Replying to [comment:90 jhpalmieri]:\n> Replying to [comment:89 gh-darijgr]:\n> \n> I can't answer any of the design questions, so I hope Travis will respond, too.\n\n\nThank you for answering. I just forgot to do that yesterday. `^^;;`\n\n> > {{{\n> > --- a/src/sage/algebras/clifford_algebra.py\n> > +++ b/src/sage/algebras/clifford_algebra.py\n> > -        cat = HopfAlgebrasWithBasis(R).Super().FiniteDimensional()\n> > +        cat = HopfAlgebrasWithBasis(R).FiniteDimensional().Supercommutative().Supercocommutative()\n> > }}}\n> > Are you sure it shouldn't be \"HopfSuperAlgebrasWithBasis(R)\"?\n\n> \n> The \"Supercommutative\" and \"Supercocommutative\" axioms imply \"Super\" Hopf algebra, so is this necessary?\n\n\nAs John said, the implication is already there. So adding `Super` to the first category is overkill.\n\n> > {{{\n> > --- a/src/sage/algebras/steenrod/steenrod_algebra.py\n> > +++ b/src/sage/algebras/steenrod/steenrod_algebra.py\n> > -        from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis\n> > +        from sage.categories.super_hopf_algebras_with_basis import SuperHopfAlgebrasWithBasis\n> > }}}\n> > I see the existence of a Z-grading (as opposed to just as a Z/2-grading) is getting lost here. Is there a way to preserve it? A GradedSuperHopfAlgebrasWithBasis category perhaps? Or are we not having anything that can make use of the grading to begin with?\n\n> \n> Maybe a graded object should have a method or attribute `grading_group` (or whatever you want to call it). I'm not sure how else you would convey this information, because `GradedSuperHopfAlgebras...` is redundant: super implies graded, and \"graded\" should make no assumptions about what the grading group is. You could have `GradedConnectedSuperHopfAlgebras...` because graded + connected implies a Z-grading (at least to me: it doesn't mean \"connected as a Hopf algebra\" + \"graded as a (super) Hopf algebra\").\n\n\nSuper implies graded for modules/algebras/etc. (but not as Hopf algebras). The super stuff is controlled by the `is_even_odd` method that outputs something in **Z**2**Z**. You can have the normal **Z** grading, and as long as whatever grading is naturally compatible with the super grading, you should not have to do anything more.\n\n> > (Eventually, gradings will be very useful, as they allow you to do linear algebra when the graded parts are finite-dimensional.)\n\n> \n> At least with the Steenrod algebra, there is a method `homogeneous_component` which takes a degree as input and returns the finite dimensional vector space, with basis, for the component in that degree.\n>  \n> > {{{\n> > --- a/src/sage/categories/coalgebras.py\n> > +++ b/src/sage/categories/coalgebras.py\n> > +    class Cocommutative(CategoryWithAxiom_over_base_ring):\n> > +        \"\"\"\n> > +        Category of cocommutative coalgebras.\n> > +        \"\"\"\n> > }}}\n> > Is this class meant to be completely empty as it currently stands?\n\n\nYes because we cannot do anything special with them other than mark them at this point. Although we could add a test for cocommutative coalgebras with basis to check that it is cocommutative.\n\n> > {{{\n> > +        class SubcategoryMethods:\n> > +            `@`cached_method\n> > +            def Supercocommutative(self):\n> > +                r\"\"\"\n> > +                Return the full subcategory of the supercocommutative\n> > +                objects of ``self``.\n> > }}}\n> > This seems to be in the Coalgebras class. But it only makes sense for supercoalgebras. Are we trying to cause spooky action at a distance here?\n\n> \n> I tried deleting this and got a few doctest failures:\n> [snip]\n> I like the output from those doctests, so I wouldn't want to just delete the class and modify the doctests.\n\n\nSo should supercommutative only be there for algebras? In both cases, it is just a convenience method to shortcut doing `Algebras(QQ).Super().Supercommutative()` and similarly for coalgebras. -1 for removing them.\n\n> > \n> > \n> > ```\n> > --- a/src/sage/categories/graded_algebras_with_basis.py\n> > +++ b/src/sage/categories/graded_algebras_with_basis.py\n> > +    class SignedTensorProducts(SignedTensorProductsCategory):\n> > +        \"\"\"\n> > +        The category of algebras with basis constructed by signed tensor\n> > +        product of algebras with basis.\n> > +        \"\"\"\n> > ```\n> > The word \"super\", or at least \"graded\", should probably fall somewhere here.\n\n\nYes, I just forgot to change this when I moved it. Feel free to add.\n\n> > Can you add doctests verifying that SuperBialgebras are not a subcat of Bialgebras, supercommutative superalgebras are not commutative algebras, and same for supercoalgebras?\n\n> \n> I agree that this would be a good idea.\n\n\nThis already is there and was added as per your request when we first did the super stuff; see `coalgebras.py`. For the commutative, we already are explicitly forbidding commutative to be passed; see `super_modules.py`. So adding more tests of this form is redundant IMO.",
    "created_at": "2019-07-17T09:24:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357374",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:91'></a>Replying to [comment:90 jhpalmieri]:
> Replying to [comment:89 gh-darijgr]:
> 
> I can't answer any of the design questions, so I hope Travis will respond, too.


Thank you for answering. I just forgot to do that yesterday. `^^;;`

> > {{{
> > --- a/src/sage/algebras/clifford_algebra.py
> > +++ b/src/sage/algebras/clifford_algebra.py
> > -        cat = HopfAlgebrasWithBasis(R).Super().FiniteDimensional()
> > +        cat = HopfAlgebrasWithBasis(R).FiniteDimensional().Supercommutative().Supercocommutative()
> > }}}
> > Are you sure it shouldn't be "HopfSuperAlgebrasWithBasis(R)"?

> 
> The "Supercommutative" and "Supercocommutative" axioms imply "Super" Hopf algebra, so is this necessary?


As John said, the implication is already there. So adding `Super` to the first category is overkill.

> > {{{
> > --- a/src/sage/algebras/steenrod/steenrod_algebra.py
> > +++ b/src/sage/algebras/steenrod/steenrod_algebra.py
> > -        from sage.categories.graded_hopf_algebras_with_basis import GradedHopfAlgebrasWithBasis
> > +        from sage.categories.super_hopf_algebras_with_basis import SuperHopfAlgebrasWithBasis
> > }}}
> > I see the existence of a Z-grading (as opposed to just as a Z/2-grading) is getting lost here. Is there a way to preserve it? A GradedSuperHopfAlgebrasWithBasis category perhaps? Or are we not having anything that can make use of the grading to begin with?

> 
> Maybe a graded object should have a method or attribute `grading_group` (or whatever you want to call it). I'm not sure how else you would convey this information, because `GradedSuperHopfAlgebras...` is redundant: super implies graded, and "graded" should make no assumptions about what the grading group is. You could have `GradedConnectedSuperHopfAlgebras...` because graded + connected implies a Z-grading (at least to me: it doesn't mean "connected as a Hopf algebra" + "graded as a (super) Hopf algebra").


Super implies graded for modules/algebras/etc. (but not as Hopf algebras). The super stuff is controlled by the `is_even_odd` method that outputs something in **Z**2**Z**. You can have the normal **Z** grading, and as long as whatever grading is naturally compatible with the super grading, you should not have to do anything more.

> > (Eventually, gradings will be very useful, as they allow you to do linear algebra when the graded parts are finite-dimensional.)

> 
> At least with the Steenrod algebra, there is a method `homogeneous_component` which takes a degree as input and returns the finite dimensional vector space, with basis, for the component in that degree.
>  
> > {{{
> > --- a/src/sage/categories/coalgebras.py
> > +++ b/src/sage/categories/coalgebras.py
> > +    class Cocommutative(CategoryWithAxiom_over_base_ring):
> > +        """
> > +        Category of cocommutative coalgebras.
> > +        """
> > }}}
> > Is this class meant to be completely empty as it currently stands?


Yes because we cannot do anything special with them other than mark them at this point. Although we could add a test for cocommutative coalgebras with basis to check that it is cocommutative.

> > {{{
> > +        class SubcategoryMethods:
> > +            `@`cached_method
> > +            def Supercocommutative(self):
> > +                r"""
> > +                Return the full subcategory of the supercocommutative
> > +                objects of ``self``.
> > }}}
> > This seems to be in the Coalgebras class. But it only makes sense for supercoalgebras. Are we trying to cause spooky action at a distance here?

> 
> I tried deleting this and got a few doctest failures:
> [snip]
> I like the output from those doctests, so I wouldn't want to just delete the class and modify the doctests.


So should supercommutative only be there for algebras? In both cases, it is just a convenience method to shortcut doing `Algebras(QQ).Super().Supercommutative()` and similarly for coalgebras. -1 for removing them.

> > 
> > 
> > ```
> > --- a/src/sage/categories/graded_algebras_with_basis.py
> > +++ b/src/sage/categories/graded_algebras_with_basis.py
> > +    class SignedTensorProducts(SignedTensorProductsCategory):
> > +        """
> > +        The category of algebras with basis constructed by signed tensor
> > +        product of algebras with basis.
> > +        """
> > ```
> > The word "super", or at least "graded", should probably fall somewhere here.


Yes, I just forgot to change this when I moved it. Feel free to add.

> > Can you add doctests verifying that SuperBialgebras are not a subcat of Bialgebras, supercommutative superalgebras are not commutative algebras, and same for supercoalgebras?

> 
> I agree that this would be a good idea.


This already is there and was added as per your request when we first did the super stuff; see `coalgebras.py`. For the commutative, we already are explicitly forbidding commutative to be passed; see `super_modules.py`. So adding more tests of this form is redundant IMO.



---

archive/issue_comments_357375.json:
```json
{
    "body": "<a id='comment:92'></a>> The \"Supercommutative\" and \"Supercocommutative\" axioms imply \"Super\" Hopf algebra, so is this necessary?\n\n\nI don't get it. Supercommutative makes no sense as an axiom on a Hopf algebra. Super is not an axiom for Hopf algebras.\n\n> This already is there and was added as per your request when we first did the super stuff; see coalgebras.py.\n\n\nWhere?",
    "created_at": "2019-07-17T09:26:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357375",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:92'></a>> The "Supercommutative" and "Supercocommutative" axioms imply "Super" Hopf algebra, so is this necessary?


I don't get it. Supercommutative makes no sense as an axiom on a Hopf algebra. Super is not an axiom for Hopf algebras.

> This already is there and was added as per your request when we first did the super stuff; see coalgebras.py.


Where?



---

archive/issue_comments_357376.json:
```json
{
    "body": "<a id='comment:93'></a>Replying to [comment:92 gh-darijgr]:\n> > The \"Supercommutative\" and \"Supercocommutative\" axioms imply \"Super\" Hopf algebra, so is this necessary?\n\n> \n> I don't get it. Supercommutative makes no sense as an axiom on a Hopf algebra. Super is not an axiom for Hopf algebras.\n\n\nAs soon as you make something supercommutative, you make it into its super version (which, as you note, is not an axiom (but instead a functorial construction)). It is the same as soon as you create the graded `X` it also knows that it is a filtered `X`.\n\n> > This already is there and was added as per your request when we first did the super stuff; see coalgebras.py.\n\n> \n> Where?\n\n\nLine 240-249 of `coalgebras.py`.",
    "created_at": "2019-07-17T12:15:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357376",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:93'></a>Replying to [comment:92 gh-darijgr]:
> > The "Supercommutative" and "Supercocommutative" axioms imply "Super" Hopf algebra, so is this necessary?

> 
> I don't get it. Supercommutative makes no sense as an axiom on a Hopf algebra. Super is not an axiom for Hopf algebras.


As soon as you make something supercommutative, you make it into its super version (which, as you note, is not an axiom (but instead a functorial construction)). It is the same as soon as you create the graded `X` it also knows that it is a filtered `X`.

> > This already is there and was added as per your request when we first did the super stuff; see coalgebras.py.

> 
> Where?


Line 240-249 of `coalgebras.py`.



---

archive/issue_comments_357377.json:
```json
{
    "body": "<a id='comment:94'></a>> As soon as you make something supercommutative, you make it into its super version (which, as you note, is not an axiom (but instead a functorial construction)). It is the same as soon as you create the graded X it also knows that it is a filtered X.\n\n\nAh, so it's a shorthand. I see.\n\n> Line 240-249 of coalgebras.py.\n\n\nOh! I was looking for it in the diff. Thanks for reminding me!",
    "created_at": "2019-07-17T12:32:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357377",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:94'></a>> As soon as you make something supercommutative, you make it into its super version (which, as you note, is not an axiom (but instead a functorial construction)). It is the same as soon as you create the graded X it also knows that it is a filtered X.


Ah, so it's a shorthand. I see.

> Line 240-249 of coalgebras.py.


Oh! I was looking for it in the diff. Thanks for reminding me!



---

archive/issue_comments_357378.json:
```json
{
    "body": "<a id='comment:95'></a>Okay, I am ready to give this a positive review. Any objections?",
    "created_at": "2019-07-17T17:25:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357378",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:95'></a>Okay, I am ready to give this a positive review. Any objections?



---

archive/issue_comments_357379.json:
```json
{
    "body": "<a id='comment:96'></a>I don't have any. But this patch is almost 100% infrastructural, so I'm not the one to ask. Thanks to all of you for taking care of this!",
    "created_at": "2019-07-17T17:31:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357379",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:96'></a>I don't have any. But this patch is almost 100% infrastructural, so I'm not the one to ask. Thanks to all of you for taking care of this!



---

archive/issue_comments_357380.json:
```json
{
    "body": "<a id='comment:97'></a>Thank you both (and again to Nicolas for all his help).",
    "created_at": "2019-07-17T17:50:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357380",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:97'></a>Thank you both (and again to Nicolas for all his help).



---

archive/issue_comments_357381.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-07-17T17:50:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357381",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_357382.json:
```json
{
    "body": "<a id='comment:98'></a>Thank you, Travis, for implementing this in a way that makes everyone happy, too!",
    "created_at": "2019-07-17T20:32:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357382",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:98'></a>Thank you, Travis, for implementing this in a way that makes everyone happy, too!



---

archive/issue_comments_357383.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-07-20T09:10:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25603#issuecomment-357383",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_064141.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-07-20T09:10:59Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/25603",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25603#event-64141"
}
```
