# Issue 25734: Hall-Littlewood Creation Operator has incorrect behavior for partitions with last entry negative

archive/issues_025497.json:
```json
{
    "body": "I am little out of my depth mathematically here, but it seems to me that the `hl_creation_operator` method for symmetric function elements does the wrong thing when passing in a tuple with the last entry negative. According to the paper referenced in the documentation, [SZ2001], Remark 2 (4), when given a tuple `(\\nu_1, \\ldots, \\nu_k)` with `\\nu_k < 0`, one should get `H_\\nu^q 1 = 0`. However, this is not the case.\n\n```python\nsage: s = SymmetricFunctions(QQ['t']).s()\nsage: elm = s.one()\nsage: elm.hl_creation_operator([-100])\n-100*s[]\nsage: elm.hl_creation_operator([2,1,-100])\n(-100*t^2+t+2)*s[]\n```\n\nI find this behavior totally bizarre, but it happens because:\n\n```python\nsage: s = SymmetricFunctions(QQ['t']).s()\nsage: s([-100])\n-100*s[]\nsage: s([2,1,-100])\n(-100*t^2+t+2)*s[]\n```\n\nwhich is also, in my opinion, a very odd choice, but maybe justified somewhere? However, I cannot find this behavior documented anywhere in the symmetric function documentation. I would write some extra documentation myself, but I do not know where this behavior comes from. Any ideas? Thank you!\n\nReference:\n\n[SZ2001] M. Shimozono, M. Zabrocki, Hall-Littlewood vertex operators and generalized Kostka polynomials. Adv. Math. 158 (2001), no. 1, 66-85.\n\nCC:  @zabrocki @tscrim @mareoraft\n\nKeywords: symmetric functions, hall-littlewood vertex operators\n\nBranch/Commit: a11924d7c93adb75db7ba75d5bd6e238d9470929\n\nReviewer: Travis Scrimshaw\n\nAuthor: Mike Zabrocki\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/25734\n\n",
    "closed_at": "2018-08-29T22:27:35Z",
    "created_at": "2018-07-02T01:51:31Z",
    "labels": [
        "component: combinatorics",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.3",
    "title": "Hall-Littlewood Creation Operator has incorrect behavior for partitions with last entry negative",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25734",
    "user": "https://github.com/ghseeli"
}
```
I am little out of my depth mathematically here, but it seems to me that the `hl_creation_operator` method for symmetric function elements does the wrong thing when passing in a tuple with the last entry negative. According to the paper referenced in the documentation, [SZ2001], Remark 2 (4), when given a tuple `(\nu_1, \ldots, \nu_k)` with `\nu_k < 0`, one should get `H_\nu^q 1 = 0`. However, this is not the case.

```python
sage: s = SymmetricFunctions(QQ['t']).s()
sage: elm = s.one()
sage: elm.hl_creation_operator([-100])
-100*s[]
sage: elm.hl_creation_operator([2,1,-100])
(-100*t^2+t+2)*s[]
```

I find this behavior totally bizarre, but it happens because:

```python
sage: s = SymmetricFunctions(QQ['t']).s()
sage: s([-100])
-100*s[]
sage: s([2,1,-100])
(-100*t^2+t+2)*s[]
```

which is also, in my opinion, a very odd choice, but maybe justified somewhere? However, I cannot find this behavior documented anywhere in the symmetric function documentation. I would write some extra documentation myself, but I do not know where this behavior comes from. Any ideas? Thank you!

Reference:

[SZ2001] M. Shimozono, M. Zabrocki, Hall-Littlewood vertex operators and generalized Kostka polynomials. Adv. Math. 158 (2001), no. 1, 66-85.

CC:  @zabrocki @tscrim @mareoraft

Keywords: symmetric functions, hall-littlewood vertex operators

Branch/Commit: a11924d7c93adb75db7ba75d5bd6e238d9470929

Reviewer: Travis Scrimshaw

Author: Mike Zabrocki

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/25734





---

archive/issue_comments_382794.json:
```json
{
    "body": "<a id='comment:2'></a>So the behavior here:\n\n```python\nsage: s = SymmetricFunctions(QQ['t']).s()\nsage: s([-100])\n-100*s[]\nsage: s([2,1,-100])\n(-100*t^2+t+2)*s[]\n```\nis natural because `S(foo)` first tries to see if `foo` can be treated as an element of the indexing set (`[2,1,-100]` is not, so that fails) and then as an element as of the base ring (which it can because `QQ['t']([2,1,-100])` returns `-100*t^2 + t + 2`). In other words, this takes the same code path as `s(2)`.\n\nFrom the doc, it is supposing `nu` is a partition, so technically this is bad input from my perspective. However, I will let Mike comment on what the implementation assumes.",
    "created_at": "2018-07-02T06:06:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382794",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>So the behavior here:

```python
sage: s = SymmetricFunctions(QQ['t']).s()
sage: s([-100])
-100*s[]
sage: s([2,1,-100])
(-100*t^2+t+2)*s[]
```
is natural because `S(foo)` first tries to see if `foo` can be treated as an element of the indexing set (`[2,1,-100]` is not, so that fails) and then as an element as of the base ring (which it can because `QQ['t']([2,1,-100])` returns `-100*t^2 + t + 2`). In other words, this takes the same code path as `s(2)`.

From the doc, it is supposing `nu` is a partition, so technically this is bad input from my perspective. However, I will let Mike comment on what the implementation assumes.



---

archive/issue_comments_382795.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,28 +1,22 @@\n I am little out of my depth mathematically here, but it seems to me that the \\`hl_creation_operator\\` method for symmetric function elements does the wrong thing when passing in a tuple with the last entry negative. According to the paper referenced in the documentation, [SZ2001], Remark 2 (4), when given a tuple \\`(\\nu_1, \\ldots, \\nu_k)\\` with \\`\\nu_k < 0\\`, one should get \\`H_\\nu^q 1 = 0\\`. However, this is not the case.\n \n-\\`\\`\\`div style=\"font-size: 80%\"\n-Code highlighting:\n-  {{{#!python\n+\\`\\`\\`python\n sage: s = SymmetricFunctions(QQ['t']).s()\n sage: elm = s.one()\n sage: elm.hl_creation_operator([-100])\n -100*s[]\n sage: elm.hl_creation_operator([2,1,-100])\n (-100*t^2+t+2)*s[]\n-  }}}\n \\`\\`\\`\n \n I find this behavior totally bizarre, but it happens because:\n \n-\\`\\`\\`div style=\"font-size: 80%\"\n-Code highlighting:\n-  {{{#!python\n+\\`\\`\\`python\n sage: s = SymmetricFunctions(QQ['t']).s()\n sage: s([-100])\n -100*s[]\n sage: s([2,1,-100])\n (-100*t^2+t+2)*s[]\n-  }}}\n \\`\\`\\`\n \n which is also, in my opinion, a very odd choice, but maybe justified somewhere? However, I cannot find this behavior documented anywhere in the symmetric function documentation. I would write some extra documentation myself, but I do not know where this behavior comes from. Any ideas? Thank you!\n```\n",
    "created_at": "2018-07-02T06:06:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382795",
    "user": "https://github.com/tscrim"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,28 +1,22 @@
 I am little out of my depth mathematically here, but it seems to me that the \`hl_creation_operator\` method for symmetric function elements does the wrong thing when passing in a tuple with the last entry negative. According to the paper referenced in the documentation, [SZ2001], Remark 2 (4), when given a tuple \`(\nu_1, \ldots, \nu_k)\` with \`\nu_k < 0\`, one should get \`H_\nu^q 1 = 0\`. However, this is not the case.
 
-\`\`\`div style="font-size: 80%"
-Code highlighting:
-  {{{#!python
+\`\`\`python
 sage: s = SymmetricFunctions(QQ['t']).s()
 sage: elm = s.one()
 sage: elm.hl_creation_operator([-100])
 -100*s[]
 sage: elm.hl_creation_operator([2,1,-100])
 (-100*t^2+t+2)*s[]
-  }}}
 \`\`\`
 
 I find this behavior totally bizarre, but it happens because:
 
-\`\`\`div style="font-size: 80%"
-Code highlighting:
-  {{{#!python
+\`\`\`python
 sage: s = SymmetricFunctions(QQ['t']).s()
 sage: s([-100])
 -100*s[]
 sage: s([2,1,-100])
 (-100*t^2+t+2)*s[]
-  }}}
 \`\`\`
 
 which is also, in my opinion, a very odd choice, but maybe justified somewhere? However, I cannot find this behavior documented anywhere in the symmetric function documentation. I would write some extra documentation myself, but I do not know where this behavior comes from. Any ideas? Thank you!
```




---

archive/issue_comments_382796.json:
```json
{
    "body": "<a id='comment:3'></a>There is a formula which can be used in this case to compute the operator when it has negative parts, but it isn't implemented.  I think that Travis has correctly identified what is happening for this particular output.\n\nWhat is implemented here is equation (12) from [SZ2001] (arXiv version equation numbers) which has as a hypothesis that all entries are non-negative.  But the actual definition of the operator does work for `{\\mathbb Z}^k`.  We could (a) raise an error if `nu` is not a partition (b) document what happens if `nu` is not a partition (c) implement the operator for `nu` when it is not a partition.",
    "created_at": "2018-07-02T11:33:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382796",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:3'></a>There is a formula which can be used in this case to compute the operator when it has negative parts, but it isn't implemented.  I think that Travis has correctly identified what is happening for this particular output.

What is implemented here is equation (12) from [SZ2001] (arXiv version equation numbers) which has as a hypothesis that all entries are non-negative.  But the actual definition of the operator does work for `{\mathbb Z}^k`.  We could (a) raise an error if `nu` is not a partition (b) document what happens if `nu` is not a partition (c) implement the operator for `nu` when it is not a partition.



---

archive/issue_comments_382797.json:
```json
{
    "body": "<a id='comment:4'></a>My two cents:\n\nHaving `s([2, 1])` return `s[2, 1]` and `s([1, 2])` return `(2*t+1)*s[]` is inconsistent behavior and can lead to a lot of confusion.\n\nSince `[1, 2] != QQ['t']([1, 2])`, I think it is too much of a stretch to have `s([1, 2]) == s(QQ['t']([1, 2]))`.  A user should need to explicitly cast to the base ring before casting to `s`.\n\nThirdly -- and somewhat of an aside -- we may want to implement `s(g)` for any composition `g` in the future to be the schur straightening.  (https://mareoraft.github.io/k_combinat_for_sage/all.html#all.straighten)\n\nAll things considered, I think the desired behavior for `s([1, 2])` at the moment is (a).  Sage should simply raise an error complaining that it doesn't know how to convert it's input into something reasonable.",
    "created_at": "2018-07-02T15:01:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382797",
    "user": "https://github.com/MareoRaft"
}
```

<a id='comment:4'></a>My two cents:

Having `s([2, 1])` return `s[2, 1]` and `s([1, 2])` return `(2*t+1)*s[]` is inconsistent behavior and can lead to a lot of confusion.

Since `[1, 2] != QQ['t']([1, 2])`, I think it is too much of a stretch to have `s([1, 2]) == s(QQ['t']([1, 2]))`.  A user should need to explicitly cast to the base ring before casting to `s`.

Thirdly -- and somewhat of an aside -- we may want to implement `s(g)` for any composition `g` in the future to be the schur straightening.  (https://mareoraft.github.io/k_combinat_for_sage/all.html#all.straighten)

All things considered, I think the desired behavior for `s([1, 2])` at the moment is (a).  Sage should simply raise an error complaining that it doesn't know how to convert it's input into something reasonable.



---

archive/issue_comments_382798.json:
```json
{
    "body": "<a id='comment:5'></a>I agree with Matt that `s([1,2])` should throw an error, or at the very least, issue a warning. Then, it will be up to the user to decide how to deal with \"non-partition\" inputs, since there seem to be multiple conventions based on what you are trying to do. (I am thinking of the Jacobi-Trudi identity as an example where this behavior would be bad.)\n\nFor the Hall-Littlewood Vertex Operator, I would personally like to see the see option (c), but would settle for option (a) for the time being.",
    "created_at": "2018-07-02T16:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382798",
    "user": "https://github.com/ghseeli"
}
```

<a id='comment:5'></a>I agree with Matt that `s([1,2])` should throw an error, or at the very least, issue a warning. Then, it will be up to the user to decide how to deal with "non-partition" inputs, since there seem to be multiple conventions based on what you are trying to do. (I am thinking of the Jacobi-Trudi identity as an example where this behavior would be bad.)

For the Hall-Littlewood Vertex Operator, I would personally like to see the see option (c), but would settle for option (a) for the time being.



---

archive/issue_comments_382799.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:4 gh-MareoRaft]:\n> My two cents:\n> \n> Having `s([2, 1])` return `s[2, 1]` and `s([1, 2])` return `(2*t+1)*s[]` is inconsistent behavior and can lead to a lot of confusion.\n> \n> Since `[1, 2] != QQ['t']([1, 2])`, I think it is too much of a stretch to have `s([1, 2]) == s(QQ['t']([1, 2]))`.  A user should need to explicitly cast to the base ring before casting to `s`.\n\n\nThen you will have to go and change polynomial ring constructors. We want `s(2)` to work, even when the input is not coercable into the base ring but convertable.\n\n> Thirdly -- and somewhat of an aside -- we may want to implement `s(g)` for any composition `g` in the future to be the schur straightening.  (https://mareoraft.github.io/k_combinat_for_sage/all.html#all.straighten)\n\n\n+1\n\n> All things considered, I think the desired behavior for `s([1, 2])` at the moment is (a).  Sage should simply raise an error complaining that it doesn't know how to convert it's input into something reasonable.\n\n\nVery strong -1. This is completely unnatural unless you do not want conversions to the base ring, fraught with corner cases, impossible to maintain. Also -1 on putting a warning for basically the same reasons.\n\nFor instance, what if you are doing Macdonald q,t computations, but have a HL in t. Then this is no longer automatic to construct scalars in the HL basis without an explicit base ring conversion. (You need to convert from `QQ[q,t]` to `QQ[t]`; you cannot coerce.) Most likely this will break a lot of code in the wild.\n\nYou should not be constructing scalars by using lists, but it is not the job of the code to police all bad user input (garbage-in, garbage-out), especially when such checks require complicated checks and hacks.",
    "created_at": "2018-07-02T16:14:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382799",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>Replying to [comment:4 gh-MareoRaft]:
> My two cents:
> 
> Having `s([2, 1])` return `s[2, 1]` and `s([1, 2])` return `(2*t+1)*s[]` is inconsistent behavior and can lead to a lot of confusion.
> 
> Since `[1, 2] != QQ['t']([1, 2])`, I think it is too much of a stretch to have `s([1, 2]) == s(QQ['t']([1, 2]))`.  A user should need to explicitly cast to the base ring before casting to `s`.


Then you will have to go and change polynomial ring constructors. We want `s(2)` to work, even when the input is not coercable into the base ring but convertable.

> Thirdly -- and somewhat of an aside -- we may want to implement `s(g)` for any composition `g` in the future to be the schur straightening.  (https://mareoraft.github.io/k_combinat_for_sage/all.html#all.straighten)


+1

> All things considered, I think the desired behavior for `s([1, 2])` at the moment is (a).  Sage should simply raise an error complaining that it doesn't know how to convert it's input into something reasonable.


Very strong -1. This is completely unnatural unless you do not want conversions to the base ring, fraught with corner cases, impossible to maintain. Also -1 on putting a warning for basically the same reasons.

For instance, what if you are doing Macdonald q,t computations, but have a HL in t. Then this is no longer automatic to construct scalars in the HL basis without an explicit base ring conversion. (You need to convert from `QQ[q,t]` to `QQ[t]`; you cannot coerce.) Most likely this will break a lot of code in the wild.

You should not be constructing scalars by using lists, but it is not the job of the code to police all bad user input (garbage-in, garbage-out), especially when such checks require complicated checks and hacks.



---

archive/issue_comments_382800.json:
```json
{
    "body": "<a id='comment:7'></a>BTW, (a), (b), and (c) are unrelated to the `s(foo)`, which is what I was talking about above. For the options above for the `hl_creation_operator`, I also favor (a) and raising a `NotImplementedError` for now, but eventually implementing (c) when `nu` is not a partition.",
    "created_at": "2018-07-02T16:16:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382800",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>BTW, (a), (b), and (c) are unrelated to the `s(foo)`, which is what I was talking about above. For the options above for the `hl_creation_operator`, I also favor (a) and raising a `NotImplementedError` for now, but eventually implementing (c) when `nu` is not a partition.



---

archive/issue_comments_382801.json:
```json
{
    "body": "<a id='comment:8'></a>If there is intention to eventually implement (c), then I don't see why we don't do it.  Its only a change of a few lines.  Here is an implementation of `hl_creation_operator` for all sequences of integers rather than just partitions.\n\nThe problem is that it might slow down the calculation a bit because it can't take advantage of Proposition 5 from [SZ2001].  I don't know if it is significant enough to worry about, but we could add an `if nu in Partitions():` then calculate with Proposition 5, `else:` use this more general but slightly slower formula.\n\nFor the case of `basis(list_of_integers)` I added a line which raises a `NotImplementedError` when that list is not a partition.\n\n---\nNew commits:",
    "created_at": "2018-07-03T21:22:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382801",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:8'></a>If there is intention to eventually implement (c), then I don't see why we don't do it.  Its only a change of a few lines.  Here is an implementation of `hl_creation_operator` for all sequences of integers rather than just partitions.

The problem is that it might slow down the calculation a bit because it can't take advantage of Proposition 5 from [SZ2001].  I don't know if it is significant enough to worry about, but we could add an `if nu in Partitions():` then calculate with Proposition 5, `else:` use this more general but slightly slower formula.

For the case of `basis(list_of_integers)` I added a line which raises a `NotImplementedError` when that list is not a partition.

---
New commits:



---

archive/issue_comments_382802.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-05T12:09:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382802",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_382803.json:
```json
{
    "body": "<a id='comment:10'></a>The slow down in the non-partition case is significant hence I am applying two different formulae for computing `hl_creation_operator`.  One where `nu` is a partition and one where `nu` is a sequence of integers.",
    "created_at": "2018-07-05T12:12:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382803",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:10'></a>The slow down in the non-partition case is significant hence I am applying two different formulae for computing `hl_creation_operator`.  One where `nu` is a partition and one where `nu` is a sequence of integers.



---

archive/issue_comments_382804.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-07-05T12:12:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382804",
    "user": "https://github.com/zabrocki"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_382805.json:
```json
{
    "body": "<a id='comment:11'></a>Remove this change:\n\n```diff\ndiff --git a/src/sage/combinat/sf/classical.py b/src/sage/combinat/sf/classical.py\nindex 76d5f21..4809664 100644\n--- a/src/sage/combinat/sf/classical.py\n+++ b/src/sage/combinat/sf/classical.py\n@@ -297,6 +297,8 @@ class SymmetricFunctionAlgebra_classical(sfa.SymmetricFunctionAlgebra_generic):\n         # Last shot -- try calling R(x) #\n         #################################\n         else:\n+            if isinstance(x, list) and all(isinstance(a,(int, Integer)) for a in x):\n+                raise NotImplementedError\n             try:\n                 return eclass(self, {_Partitions([]): R(x)})\n             except Exception:\n```\nI do not want such a behavior change, and even still, it does not change the confusion (try `s([1,4/2])`, I bet that will work). What about tuples that can be interpreted as a partitions:\n\n```\nsage: (2,1) in Partitions()\nTrue\nsage: R.<x> = QQ[]\nsage: R((1,2))\n2*x + 1\n```\n\nThis check\n\n```\n        if not (isinstance(nu,list) and\n                all(isinstance(a,(int,Integer)) for a in nu)):\n            raise ValueError(\"nu must be a list of integers\"%(nu))\n```\nshould be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input). You should also use the global object `_Partitions` for speed reasons (although it will not be too much).\n\nTrivial, but the `\\` are not needed in the `sum` (the open parentheses tell Python to continue checking the next line).\n\nNote that this change:\n\n```diff\n-                t = QQ['t'].gen()\n+                t = self.parent().base_ring()('t')\n```\nhas the potential to break code in the wild.",
    "created_at": "2018-07-05T15:12:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382805",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>Remove this change:

```diff
diff --git a/src/sage/combinat/sf/classical.py b/src/sage/combinat/sf/classical.py
index 76d5f21..4809664 100644
--- a/src/sage/combinat/sf/classical.py
+++ b/src/sage/combinat/sf/classical.py
@@ -297,6 +297,8 @@ class SymmetricFunctionAlgebra_classical(sfa.SymmetricFunctionAlgebra_generic):
         # Last shot -- try calling R(x) #
         #################################
         else:
+            if isinstance(x, list) and all(isinstance(a,(int, Integer)) for a in x):
+                raise NotImplementedError
             try:
                 return eclass(self, {_Partitions([]): R(x)})
             except Exception:
```
I do not want such a behavior change, and even still, it does not change the confusion (try `s([1,4/2])`, I bet that will work). What about tuples that can be interpreted as a partitions:

```
sage: (2,1) in Partitions()
True
sage: R.<x> = QQ[]
sage: R((1,2))
2*x + 1
```

This check

```
        if not (isinstance(nu,list) and
                all(isinstance(a,(int,Integer)) for a in nu)):
            raise ValueError("nu must be a list of integers"%(nu))
```
should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input). You should also use the global object `_Partitions` for speed reasons (although it will not be too much).

Trivial, but the `\` are not needed in the `sum` (the open parentheses tell Python to continue checking the next line).

Note that this change:

```diff
-                t = QQ['t'].gen()
+                t = self.parent().base_ring()('t')
```
has the potential to break code in the wild.



---

archive/issue_comments_382806.json:
```json
{
    "body": "<a id='comment:12'></a>Can you clarify\n> This check\n> [snip]\n> should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input).\n\nShould I just remove those lines and force the user to check `basis(list_of_integers)` or did you mean that I should change the `else:` line to handle that check?\n\n> Note that this change:\n> \n> ```diff\n> -                t = QQ['t'].gen()\n> +                t = self.parent().base_ring()('t')\n> ```\n> has the potential to break code in the wild.\n\nI think that it was not a good idea to have it do calculations in `QQ['t']` and then have it map into the base ring.  Any time that there is not a map from `QQ['t']` to the base ring or if `QQ['t']` doesn't commute with some of the operations in the symmetric functions, you will get incorrect answers.  Former behavior:\n\n```\nsage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)\nsage: s[2].hl_creation_operator([3])\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n...\nTypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions\n```\nNew behavior is that if `t` is not in the base ring than it raises an error and says `TypeError: unable to convert 't' to a ***` and (for example, it is mostly faster to compute in `ZZ['t'].fraction_field()` than `QQ['t'].fraction_field()`):\n\n```\nsage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)\nsage: s[2].hl_creation_operator([3])\ns[3, 2] + t*s[4, 1] + t^2*s[5]\n```",
    "created_at": "2018-07-05T16:45:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382806",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:12'></a>Can you clarify
> This check
> [snip]
> should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input).

Should I just remove those lines and force the user to check `basis(list_of_integers)` or did you mean that I should change the `else:` line to handle that check?

> Note that this change:
> 
> ```diff
> -                t = QQ['t'].gen()
> +                t = self.parent().base_ring()('t')
> ```
> has the potential to break code in the wild.

I think that it was not a good idea to have it do calculations in `QQ['t']` and then have it map into the base ring.  Any time that there is not a map from `QQ['t']` to the base ring or if `QQ['t']` doesn't commute with some of the operations in the symmetric functions, you will get incorrect answers.  Former behavior:

```
sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
sage: s[2].hl_creation_operator([3])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
```
New behavior is that if `t` is not in the base ring than it raises an error and says `TypeError: unable to convert 't' to a ***` and (for example, it is mostly faster to compute in `ZZ['t'].fraction_field()` than `QQ['t'].fraction_field()`):

```
sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
sage: s[2].hl_creation_operator([3])
s[3, 2] + t*s[4, 1] + t^2*s[5]
```



---

archive/issue_comments_382807.json:
```json
{
    "body": "<a id='comment:13'></a>Replying to [comment:12 zabrocki]:\n> \n> Can you clarify\n> > This check\n> > [snip]\n> > should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input).\n\n> Should I just remove those lines and force the user to check `basis(list_of_integers)` or did you mean that I should change the `else:` line to handle that check?\n\nThe latter: change the `else:` to that check.\n\n> > Note that this change:\n> > \n> > ```diff\n> > -                t = QQ['t'].gen()\n> > +                t = self.parent().base_ring()('t')\n> > ```\n> > has the potential to break code in the wild.\n\n> I think that it was not a good idea to have it do calculations in `QQ['t']` and then have it map into the base ring.  Any time that there is not a map from `QQ['t']` to the base ring or if `QQ['t']` doesn't commute with some of the operations in the symmetric functions, you will get incorrect answers.  Former behavior:\n> {{{\n> sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)\n> sage: s[2].hl_creation_operator([3])\n> \n> ---\n> TypeError                                 Traceback (most recent call last)\n> ...\n> TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions\n> }}}\n> New behavior is that if `t` is not in the base ring than it raises an error and says `TypeError: unable to convert 't' to a ***` and (for example, it is mostly faster to compute in `ZZ['t'].fraction_field()` than `QQ['t'].fraction_field()`):\n> \n> ```\n> sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)\n> sage: s[2].hl_creation_operator([3])\n> s[3, 2] + t*s[4, 1] + t^2*s[5]\n> ```\n\n\nThat is a good point. I just wanted to note that this could cause code to break. Could you add this as a doctest?",
    "created_at": "2018-07-05T16:54:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382807",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:13'></a>Replying to [comment:12 zabrocki]:
> 
> Can you clarify
> > This check
> > [snip]
> > should be the else because `nu in Partitions()` checks it twice (IMO, getting a partition is the most likely input).

> Should I just remove those lines and force the user to check `basis(list_of_integers)` or did you mean that I should change the `else:` line to handle that check?

The latter: change the `else:` to that check.

> > Note that this change:
> > 
> > ```diff
> > -                t = QQ['t'].gen()
> > +                t = self.parent().base_ring()('t')
> > ```
> > has the potential to break code in the wild.

> I think that it was not a good idea to have it do calculations in `QQ['t']` and then have it map into the base ring.  Any time that there is not a map from `QQ['t']` to the base ring or if `QQ['t']` doesn't commute with some of the operations in the symmetric functions, you will get incorrect answers.  Former behavior:
> {{{
> sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
> sage: s[2].hl_creation_operator([3])
> 
> ---
> TypeError                                 Traceback (most recent call last)
> ...
> TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
> }}}
> New behavior is that if `t` is not in the base ring than it raises an error and says `TypeError: unable to convert 't' to a ***` and (for example, it is mostly faster to compute in `ZZ['t'].fraction_field()` than `QQ['t'].fraction_field()`):
> 
> ```
> sage: SymmetricFunctions(ZZ['t'].fraction_field()).inject_shorthands(verbose=False)
> sage: s[2].hl_creation_operator([3])
> s[3, 2] + t*s[4, 1] + t^2*s[5]
> ```


That is a good point. I just wanted to note that this could cause code to break. Could you add this as a doctest?



---

archive/issue_comments_382808.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-05T21:12:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382808",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_382809.json:
```json
{
    "body": "<a id='comment:15'></a>Thanks. Basically ready for positive review except for a bit of mostly PEP8/bikeshedding:\n\n``s(la)`` -> either ```s(la)``` or ``s_{\\lambda}``\n\n```diff\n-        r = len(nu)+len(la)\n+        r = len(nu) + len(la)\n         ga = [a-b for (a,b) in zip(nu+la.to_list(), range(-r,0))]\n-        if r==len(set(ga)) and min(ga)>0:\n-            m = sum(1 for i in range(len(ga)) for j in range(i,len(ga)) \\\n-                    if ga[i]<ga[j])\n+        if r == len(set(ga)) and min(ga) > 0:\n+            m = sum(1 for i in range(len(ga)) for j in range(i, len(ga))\n+                    if ga[i] < ga[j])\n             ga.sort(reverse=True)\n-            return (-1)**m*self([a+b for (a,b) in zip(ga, range(-r,0))])\n+            return (-1)**m * self([a+b for (a,b) in zip(ga, range(-r,0))])\n         return self.zero()\n```\n\n```diff\n         if nu in _Partitions:\n             self = s(self)\n             return P(self*s(nu) +\n                      s.sum( s.sum_of_terms( (lam,c) for lam, c in s(mu)*s(nu) if len(lam) <= len(nu) ) *\n                             self.skew_by(s(mu).plethysm((t-1)*s([1])))\n                             for d in range(self.degree())\n-                            for mu in Partitions(d+1, max_length=len(nu)) ) )\n-        elif isinstance(nu,list) and all(isinstance(a,(int,Integer)) for a in nu):\n-            return P(s.sum(t**la.size()*c*d*s(la)*\n+                            for mu in Partitions(d+1, max_length=len(nu)) ))\n+        elif isinstance(nu, list) and all(isinstance(a, (int,Integer)) for a in nu):\n+            return P(s.sum(t**la.size() * c * d * s(la) *\n                      s._repeated_bernstein_creation_operator_on_basis(ga, nu)\n                      for ((la,mu),c) in s(self).coproduct()\n-                     for (ga, d) in s(mu).plethysm((1-t)*s[1]) ) )\n+                     for (ga, d) in s(mu).plethysm((1-t)*s[1]) ))\n```\n\nI know you didn't write the test, but if you could break the one very long doctest output for `s([3,2]).hl_creation_operator([2,1,1])`, I would appreciate it.",
    "created_at": "2018-07-05T23:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382809",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:15'></a>Thanks. Basically ready for positive review except for a bit of mostly PEP8/bikeshedding:

``s(la)`` -> either ```s(la)``` or ``s_{\lambda}``

```diff
-        r = len(nu)+len(la)
+        r = len(nu) + len(la)
         ga = [a-b for (a,b) in zip(nu+la.to_list(), range(-r,0))]
-        if r==len(set(ga)) and min(ga)>0:
-            m = sum(1 for i in range(len(ga)) for j in range(i,len(ga)) \
-                    if ga[i]<ga[j])
+        if r == len(set(ga)) and min(ga) > 0:
+            m = sum(1 for i in range(len(ga)) for j in range(i, len(ga))
+                    if ga[i] < ga[j])
             ga.sort(reverse=True)
-            return (-1)**m*self([a+b for (a,b) in zip(ga, range(-r,0))])
+            return (-1)**m * self([a+b for (a,b) in zip(ga, range(-r,0))])
         return self.zero()
```

```diff
         if nu in _Partitions:
             self = s(self)
             return P(self*s(nu) +
                      s.sum( s.sum_of_terms( (lam,c) for lam, c in s(mu)*s(nu) if len(lam) <= len(nu) ) *
                             self.skew_by(s(mu).plethysm((t-1)*s([1])))
                             for d in range(self.degree())
-                            for mu in Partitions(d+1, max_length=len(nu)) ) )
-        elif isinstance(nu,list) and all(isinstance(a,(int,Integer)) for a in nu):
-            return P(s.sum(t**la.size()*c*d*s(la)*
+                            for mu in Partitions(d+1, max_length=len(nu)) ))
+        elif isinstance(nu, list) and all(isinstance(a, (int,Integer)) for a in nu):
+            return P(s.sum(t**la.size() * c * d * s(la) *
                      s._repeated_bernstein_creation_operator_on_basis(ga, nu)
                      for ((la,mu),c) in s(self).coproduct()
-                     for (ga, d) in s(mu).plethysm((1-t)*s[1]) ) )
+                     for (ga, d) in s(mu).plethysm((1-t)*s[1]) ))
```

I know you didn't write the test, but if you could break the one very long doctest output for `s([3,2]).hl_creation_operator([2,1,1])`, I would appreciate it.



---

archive/issue_comments_382810.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-05T23:30:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382810",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_382811.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-07-05T23:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382811",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_382812.json:
```json
{
    "body": "<a id='comment:17'></a>Thank you.",
    "created_at": "2018-07-05T23:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382812",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:17'></a>Thank you.



---

archive/issue_comments_382813.json:
```json
{
    "body": "<a id='comment:18'></a>Thank you for the review!",
    "created_at": "2018-07-05T23:34:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382813",
    "user": "https://github.com/zabrocki"
}
```

<a id='comment:18'></a>Thank you for the review!



---

archive/issue_comments_382814.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-08-29T22:27:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25734#issuecomment-382814",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_064376.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-08-29T22:27:35Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/25734",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25734#event-64376"
}
```
