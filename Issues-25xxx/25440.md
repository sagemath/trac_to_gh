# Issue 25440: Recursive call in FractionFieldElement._evaluate_polynomial

archive/issues_025203.json:
```json
{
    "body": "CC:  @mezzarobba @roed314 xcaruso swewers\n\nCurrently, the following fails:\n\n```\nsage: R.<x> = GF(2)[]\nsage: S.<y> = R.fraction_field()[]\nsage: (y+1)(R.one())\nRuntimeError: maximum recursion depth exceeded while calling a Python object\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/25440\n\n",
    "closed_at": "2018-05-28T07:45:30Z",
    "created_at": "2018-05-24T22:58:47Z",
    "labels": [
        "component: basic arithmetic",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.3",
    "title": "Recursive call in FractionFieldElement._evaluate_polynomial",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25440",
    "user": "https://github.com/saraedum"
}
```
CC:  @mezzarobba @roed314 xcaruso swewers

Currently, the following fails:

```
sage: R.<x> = GF(2)[]
sage: S.<y> = R.fraction_field()[]
sage: (y+1)(R.one())
RuntimeError: maximum recursion depth exceeded while calling a Python object
```

Issue created by migration from https://trac.sagemath.org/ticket/25440





---

archive/issue_comments_354612.json:
```json
{
    "body": "What happens here:\n* `R.one()` is coerced into the coefficient ring of `y+1`, i.e., `R.fraction_field()`\n* The `_evaluate_polynomial` for fraction field elements is called with `self==R.fraction_field()(R.one())` and `pol==y+1`.\n\n```\ninverse = ~self\nif inverse.denominator().is_one():\n   num = inverse.numerator()\n   return pol.reverse()(num)/num**pol.degree()\n```\n* This sets `num==R.one()` and we're back to square one.",
    "created_at": "2018-05-24T23:02:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354612",
    "user": "https://github.com/saraedum"
}
```

What happens here:
* `R.one()` is coerced into the coefficient ring of `y+1`, i.e., `R.fraction_field()`
* The `_evaluate_polynomial` for fraction field elements is called with `self==R.fraction_field()(R.one())` and `pol==y+1`.

```
inverse = ~self
if inverse.denominator().is_one():
   num = inverse.numerator()
   return pol.reverse()(num)/num**pol.degree()
```
* This sets `num==R.one()` and we're back to square one.



---

archive/issue_comments_354613.json:
```json
{
    "body": "I had run into a precision problem in the same spot several times before and had never bothered for long enough to track it down. I hope the reviewer doesn't mind that I also fix this while I am at it.\n\n---\nNew commits:",
    "created_at": "2018-05-24T23:30:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354613",
    "user": "https://github.com/saraedum"
}
```

I had run into a precision problem in the same spot several times before and had never bothered for long enough to track it down. I hope the reviewer doesn't mind that I also fix this while I am at it.

---
New commits:



---

archive/issue_comments_354614.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-05-24T23:41:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354614",
    "user": "https://github.com/saraedum"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_354615.json:
```json
{
    "body": "I have not run full doctests yet. Let's see what the patchbots think.",
    "created_at": "2018-05-24T23:41:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354615",
    "user": "https://github.com/saraedum"
}
```

I have not run full doctests yet. Let's see what the patchbots think.



---

archive/issue_comments_354616.json:
```json
{
    "body": "The first part looks good to me. (Cc:ing the original author of the code just in case.)\n\nRegarding the precision issue, while your fix doesn't hurt as far as I can see, I don't believe `foo.is_one()` should ever return `True` when `foo` is not exactly one... so IMO the real bug is in elements for which that happens.",
    "created_at": "2018-05-25T12:41:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354616",
    "user": "https://github.com/mezzarobba"
}
```

The first part looks good to me. (Cc:ing the original author of the code just in case.)

Regarding the precision issue, while your fix doesn't hurt as far as I can see, I don't believe `foo.is_one()` should ever return `True` when `foo` is not exactly one... so IMO the real bug is in elements for which that happens.



---

archive/issue_comments_354617.json:
```json
{
    "body": "mistake here:\n\n```\n+            sage: (y+1)(R.one())\n+            sage: 0\n```",
    "created_at": "2018-05-25T20:24:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354617",
    "user": "https://github.com/fchapoton"
}
```

mistake here:

```
+            sage: (y+1)(R.one())
+            sage: 0
```



---

archive/issue_comments_354618.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-26T06:07:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354618",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_354619.json:
```json
{
    "body": "Replying to [comment:5 mmezzarobba]:\n> The first part looks good to me. (Cc:ing the original author of the code just in case.)\n> \n> Regarding the precision issue, while your fix doesn't hurt as far as I can see, I don't believe `foo.is_one()` should ever return `True` when `foo` is not exactly one... so IMO the real bug is in elements for which that happens.\n\nI think that's a dilemma of inexact objects and p-adics in particular. Currently, `x == 1` and `x.is_one()` are satisfied by inexact one elements. That comes with its drawbacks, as can be seen in this example. But changing this is probably going to break things in even more places. Also, it's unclear what the alternative would be. Should `R(1) != 1`? Or should `not R(1).is_one()` hold? Or just `R(1)*p/p != 1`? Or should `R(1) == 1` raise an exception?\n\nI think there is no good answer here with the operators available in Sage/Python. Whatever you choose, some algorithms are going to break because the assumptions made by the implementation are not met.",
    "created_at": "2018-05-26T06:20:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354619",
    "user": "https://github.com/saraedum"
}
```

Replying to [comment:5 mmezzarobba]:
> The first part looks good to me. (Cc:ing the original author of the code just in case.)
> 
> Regarding the precision issue, while your fix doesn't hurt as far as I can see, I don't believe `foo.is_one()` should ever return `True` when `foo` is not exactly one... so IMO the real bug is in elements for which that happens.

I think that's a dilemma of inexact objects and p-adics in particular. Currently, `x == 1` and `x.is_one()` are satisfied by inexact one elements. That comes with its drawbacks, as can be seen in this example. But changing this is probably going to break things in even more places. Also, it's unclear what the alternative would be. Should `R(1) != 1`? Or should `not R(1).is_one()` hold? Or just `R(1)*p/p != 1`? Or should `R(1) == 1` raise an exception?

I think there is no good answer here with the operators available in Sage/Python. Whatever you choose, some algorithms are going to break because the assumptions made by the implementation are not met.



---

archive/issue_comments_354620.json:
```json
{
    "body": "Replying to [comment:8 saraedum]:\n> I think that's a dilemma of inexact objects and p-adics in particular.Currently, `x == 1` and `x.is_one()` are satisfied by inexact one elements. That comes with its drawbacks, as can be seen in this example. But changing this is probably going to break things in even more places.\n\n\nI'm not so sure: intervals have exactly the same issue, but they only declare equal elements that are, and they work reasonably well with the rest of Sage... Really, for me, the way equality of p-adics (and series) appear to work is closer to a bug than an implementation choice.\n\n> Also, it's unclear what the alternative would be. Should `R(1) != 1`?\n\n\nIdeally yes, but that's a lost battle.\n\n> Or should `not R(1).is_one()` hold?\n\n\nProbably. Though, if I understand right, (some?) p-adic rings have a maximum precision, and there is an argument for declaring elements equal when they agree to the precision of the parent, or perhaps even to that of the more precise of the two elements.",
    "created_at": "2018-05-26T07:18:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354620",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:8 saraedum]:
> I think that's a dilemma of inexact objects and p-adics in particular.Currently, `x == 1` and `x.is_one()` are satisfied by inexact one elements. That comes with its drawbacks, as can be seen in this example. But changing this is probably going to break things in even more places.


I'm not so sure: intervals have exactly the same issue, but they only declare equal elements that are, and they work reasonably well with the rest of Sage... Really, for me, the way equality of p-adics (and series) appear to work is closer to a bug than an implementation choice.

> Also, it's unclear what the alternative would be. Should `R(1) != 1`?


Ideally yes, but that's a lost battle.

> Or should `not R(1).is_one()` hold?


Probably. Though, if I understand right, (some?) p-adic rings have a maximum precision, and there is an argument for declaring elements equal when they agree to the precision of the parent, or perhaps even to that of the more precise of the two elements.



---

archive/issue_comments_354621.json:
```json
{
    "body": "Replying to [comment:9 mmezzarobba]:\n> Replying to [comment:8 saraedum]:\n> > I think that's a dilemma of inexact objects and p-adics in particular.Currently, `x == 1` and `x.is_one()` are satisfied by inexact one elements. That comes with its drawbacks, as can be seen in this example. But changing this is probably going to break things in even more places.\n\n> \n> I'm not so sure: intervals have exactly the same issue, but they only declare equal elements that are, and they work reasonably well with the rest of Sage... Really, for me, the way equality of p-adics (and series) appear to work is closer to a bug than an implementation choice.\n\n\nIt's a valid alternative. Two elements are equal if they are indistinguishable. We have thought about this and it certainly has its merits. But you also have to keep this in mind when implementing generic algorithms. No matter what you do, some assumptions that exact implementations make are going to be violated, e.g., `a + b - b == a` is not true in RIF.\n\nI am not saying that we should not change the notion of equality in p-adics. I have discussed this with several people in the past and even had a ticket about this at some point. However, it's not clear what's the right notion of equality. The one we have is unfortunate but I am not convinced anymore that there is a better one.\n\nAnyway, while things are the way they are, I'd like to fix this precision issue in Sage. If you are opposed to this, I don't mind at all to take this out of this changeset and propose it on a different ticket and continue the discussion there :)",
    "created_at": "2018-05-26T08:00:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354621",
    "user": "https://github.com/saraedum"
}
```

Replying to [comment:9 mmezzarobba]:
> Replying to [comment:8 saraedum]:
> > I think that's a dilemma of inexact objects and p-adics in particular.Currently, `x == 1` and `x.is_one()` are satisfied by inexact one elements. That comes with its drawbacks, as can be seen in this example. But changing this is probably going to break things in even more places.

> 
> I'm not so sure: intervals have exactly the same issue, but they only declare equal elements that are, and they work reasonably well with the rest of Sage... Really, for me, the way equality of p-adics (and series) appear to work is closer to a bug than an implementation choice.


It's a valid alternative. Two elements are equal if they are indistinguishable. We have thought about this and it certainly has its merits. But you also have to keep this in mind when implementing generic algorithms. No matter what you do, some assumptions that exact implementations make are going to be violated, e.g., `a + b - b == a` is not true in RIF.

I am not saying that we should not change the notion of equality in p-adics. I have discussed this with several people in the past and even had a ticket about this at some point. However, it's not clear what's the right notion of equality. The one we have is unfortunate but I am not convinced anymore that there is a better one.

Anyway, while things are the way they are, I'd like to fix this precision issue in Sage. If you are opposed to this, I don't mind at all to take this out of this changeset and propose it on a different ticket and continue the discussion there :)



---

archive/issue_comments_354622.json:
```json
{
    "body": "Replying to [comment:10 saraedum]:\n> But you also have to keep this in mind when implementing generic algorithms. No matter what you do, some assumptions that exact implementations make are going to be violated, e.g., `a + b - b == a` is not true in RIF.\n\n\nYes, of course. And I wholeheartedly agree that Sage is missing finer grained comparison operators. But I thought the (weak) consensus to deal with the situation\u2014not only in the context of intervals, but also, e.g., for method that do their best to answer undecidable questions\u2014was to stick as much as possible to the convention that positive boolean answers must be correct, while negative ones may mean \u201cI don't  know\u201d. In any case, that's the convention I try to apply when writing or reviewing generic code where the issue might arise.\n\n> Anyway, while things are the way they are, I'd like to fix this precision issue in Sage. If you are opposed to this, I don't mind at all to take this out of this changeset and propose it on a different ticket and continue the discussion there :)\n\n\nNo, I don't really care about that particular change, and I'm happy to keep it in if it can help. I just don't think it will be a sustainable model in the long run.",
    "created_at": "2018-05-26T14:05:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354622",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:10 saraedum]:
> But you also have to keep this in mind when implementing generic algorithms. No matter what you do, some assumptions that exact implementations make are going to be violated, e.g., `a + b - b == a` is not true in RIF.


Yes, of course. And I wholeheartedly agree that Sage is missing finer grained comparison operators. But I thought the (weak) consensus to deal with the situation—not only in the context of intervals, but also, e.g., for method that do their best to answer undecidable questions—was to stick as much as possible to the convention that positive boolean answers must be correct, while negative ones may mean “I don't  know”. In any case, that's the convention I try to apply when writing or reviewing generic code where the issue might arise.

> Anyway, while things are the way they are, I'd like to fix this precision issue in Sage. If you are opposed to this, I don't mind at all to take this out of this changeset and propose it on a different ticket and continue the discussion there :)


No, I don't really care about that particular change, and I'm happy to keep it in if it can help. I just don't think it will be a sustainable model in the long run.



---

archive/issue_comments_354623.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-05-26T14:05:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354623",
    "user": "https://github.com/mezzarobba"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_063848.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-05-28T07:45:30Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25440#event-63848"
}
```



---

archive/issue_comments_354624.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-05-28T07:45:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354624",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_354625.json:
```json
{
    "body": "Replying to [comment:5 mmezzarobba]:\n> Regarding the precision issue, while your fix doesn't hurt as far as I can see, I don't believe `foo.is_one()` should ever return `True` when `foo` is not exactly one... so IMO the real bug is in elements for which that happens.\n\n\nAnd, at #25318, I'm proposing to remove the doctest you added, because it breaks with the changes in that ticket, and I see no way of making things work both with p-adics and with parents that use what I consider the correct semantics for `is_one()`.",
    "created_at": "2018-06-10T13:04:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25440",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25440#issuecomment-354625",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:5 mmezzarobba]:
> Regarding the precision issue, while your fix doesn't hurt as far as I can see, I don't believe `foo.is_one()` should ever return `True` when `foo` is not exactly one... so IMO the real bug is in elements for which that happens.


And, at #25318, I'm proposing to remove the doctest you added, because it breaks with the changes in that ticket, and I see no way of making things work both with p-adics and with parents that use what I consider the correct semantics for `is_one()`.
