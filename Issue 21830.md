# Issue 21830: generating function of integer-valued polyhedra

Issue created by migration from Trac.

Original creator: dkrenn

Original creation time: 2016-12-16 08:52:25

CC:  cheuberg jipilab @braunmath slelievre

Implement this using MacMahon's Omega operator (#22066)


---

Comment by dkrenn created at 2016-12-16 08:57:02

Changing component from PLEASE CHANGE to geometry.


---

Comment by dkrenn created at 2016-12-16 08:57:02

Last 10 new commits:


---

Comment by git created at 2016-12-16 10:25:57

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2016-12-17 11:04:49

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2016-12-17 11:07:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-12-17 11:30:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-12-17 11:31:42

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2016-12-22 02:16:46


```
Return the generating function of the integer points of
+    the polyhedron's orthant with only nonnegative coordinates.
```

Why only the integer points with nonnegative coordinates?


---

Comment by git created at 2016-12-22 08:11:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-12-22 08:25:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-12-22 08:29:13

Merged in changed dependencies.


---

Comment by vdelecroix created at 2016-12-23 22:58:01

Hello,

This would be really useful.

1) The name is too generic: `generating_function` could be anything (e.g. the number of lattice points in dilates). It should be something like `non_negative_lattice_points_generating_function`.

2) What do you mean by "generating function"? Is it weighted by the sum of the vector?

3) You should at least check that the number of integer partitions is correctly computed by your function with the polyhedron

```
x1 >= x2 >= x3 >= x4 >= x5 >= 1
```

versus

```
sage: [Partitions(k, length=5).cardinality() for k in range(5,20)]
[1, 1, 2, 3, 5, 7, 10, 13, 18, 23, 30, 37, 47, 57, 70]
```



---

Comment by mkoeppe created at 2016-12-24 07:27:47

I agree with Vincent that the name is too generic. This seems to compute what, for example, LattE would call the multivariate generating function (which can be computed by `count --multivariate-generating-function` after installing package `latte_int`) -- but not of the integer points of the given polyhedron but of its intersection with the positive orthant. This "positive orthant" business, I think, is just a peculiarity of the Omega approach but I don't think it's makes sense to expose it to the user. Maybe raise a `NotImplementedError` instead if the given polytope is not contained in the positive orthant?


---

Comment by vdelecroix created at 2016-12-24 07:36:44

Replying to [comment:14 mkoeppe]:
> This "positive orthant" business, I think, is just a peculiarity of the Omega approach but I don't think it's makes sense to expose it to the user. Maybe raise a `NotImplementedError` instead if the given polytope is not contained in the positive orthant?

+1. The API would be much better (and allows extension in the future to count all points (that can already be done intersecting with the 2<sup>dim</sup> orthants and applying symmetries)).


---

Comment by git created at 2016-12-25 15:25:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-12-25 15:28:22

Replying to [comment:13 vdelecroix]:
> This would be really useful.

Good :)

Thank you for your comments. Code updated.

> 1) The name is too generic: `generating_function` could be anything (e.g. the number of lattice points in dilates). It should be something like `non_negative_lattice_points_generating_function`.

It seems that "integral points" is used in sage.geometry.polyhedron` a couple of times, thus,
changed to `generating_function_of_integral_points`.

> 2) What do you mean by "generating function"? Is it weighted by the sum of the vector?

Inserted a formula to make this precise.

> 3) You should at least check that the number of integer partitions is correctly computed by your function with the polyhedron
> {{{
> x1 >= x2 >= x3 >= x4 >= x5 >= 1
> }}}
> versus
> {{{
> sage: [Partitions(k, length=5).cardinality() for k in range(5,20)]
> [1, 1, 2, 3, 5, 7, 10, 13, 18, 23, 30, 37, 47, 57, 70]
> }}}

Indeed; example added.


---

Comment by dkrenn created at 2016-12-25 15:33:43

Replying to [comment:15 vdelecroix]:
> Replying to [comment:14 mkoeppe]:
> > This "positive orthant" business, I think, is just a peculiarity of the Omega approach but I don't think it's makes sense to expose it to the user. Maybe raise a `NotImplementedError` instead if the given polytope is not contained in the positive orthant?
> 
> +1. The API would be much better (and allows extension in the future to count all points (that can already be done intersecting with the 2<sup>dim</sup> orthants and applying symmetries)).

I agree. Changed the documentation and added a few lines to check if polyhedron is in the nonnegative orthant; otherwise raise `NotImplementedError`. (Created a follow up ticket #22099 for the extension to arbitary corrdinates.)


---

Comment by git created at 2016-12-27 10:28:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2016-12-29 02:01:45

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2016-12-29 02:01:45


```
sage: P = Polyhedron(vertices=[[1], [5]])
sage: P.generating_function_of_integral_points()
TypeError: unsupported operand type(s) for -: 'tuple' and 'tuple'
```



---

Comment by git created at 2016-12-29 08:34:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-12-29 08:34:57

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2016-12-29 08:34:57

Replying to [comment:21 mkoeppe]:
> {{{
> sage: P = Polyhedron(vertices=[[1], [5]])
> sage: P.generating_function_of_integral_points()
> TypeError: unsupported operand type(s) for -: 'tuple' and 'tuple'
> }}}

Fixed.


---

Comment by mkoeppe created at 2016-12-29 17:57:19

I think the name of the variables used in the generating function should be a user option


---

Comment by mkoeppe created at 2016-12-29 17:59:01


```
sage: P = Polyhedron(rays=[(1, sqrt(2)), (0, 1)])
sage: P.generating_function_of_integral_points()
1 * (-y0 + 1)^-1 * (-y1 + 1)^-1
```

I had hoped for an error


---

Comment by mkoeppe created at 2016-12-29 18:18:31

Also I think the method `generating_function_of_integral_points` should have an `algorithm` keyword. For polytopes, could provide a naive algorithm that just collects the monomials corresponding to `integral_points`. And another algorithm would be to just call LattE. 

Various algorithms options such as `result_as_tuple` are not sufficiently documented.

For the LattE algorithm, the best output format would be a sum of Factorizations. Is this what `result_as_tuple` can represent?


---

Comment by mkoeppe created at 2016-12-29 18:19:13

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-12-30 17:45:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-12-30 17:46:06

Replying to [comment:24 mkoeppe]:
> I think the name of the variables used in the generating function should be a user option

True; option is now available :)


---

Comment by dkrenn created at 2016-12-30 17:46:31

Replying to [comment:25 mkoeppe]:
> {{{
> sage: P = Polyhedron(rays=[(1, sqrt(2)), (0, 1)])
> sage: P.generating_function_of_integral_points()
> 1 * (-y0 + 1)^-1 * (-y1 + 1)^-1
> }}}
> I had hoped for an error

Now the base ring of the polyhedron is inspected.


---

Comment by dkrenn created at 2016-12-30 17:47:00

Replying to [comment:26 mkoeppe]:
> Various algorithms options such as `result_as_tuple` are not sufficiently documented.

Docs extended.


---

Comment by dkrenn created at 2016-12-30 17:54:35

Replying to [comment:26 mkoeppe]:
> Also I think the method `generating_function_of_integral_points` should have an `algorithm` keyword. For polytopes, could provide a naive algorithm that just collects the monomials corresponding to `integral_points`. And another algorithm would be to just call LattE. 

As this does not change the interface, only extends it, I have put this on the follow--up enhancement ticket #22111.


---

Comment by dkrenn created at 2016-12-30 17:55:16

Replying to [comment:26 mkoeppe]:
> For the LattE algorithm, the best output format would be a sum of Factorizations. Is this what `result_as_tuple` can represent?

Yes, correct. (As mentioned, I've extended the docstring of this option.)


---

Comment by dkrenn created at 2016-12-30 17:57:21

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2016-12-30 23:43:46

Replying to [comment:31 dkrenn]:
> Replying to [comment:26 mkoeppe]:
> > Various algorithms options such as `result_as_tuple` are not sufficiently documented.
> 
> Docs extended.

Wouldn't it be nicer to have a class to represent such sums, much like Factorization represents products?


---

Comment by dkrenn created at 2017-01-02 12:21:44

Replying to [comment:35 mkoeppe]:
> Replying to [comment:31 dkrenn]:
> > Replying to [comment:26 mkoeppe]:
> > > Various algorithms options such as `result_as_tuple` are not sufficiently documented.
> > 
> > Docs extended.
> 
> Wouldn't it be nicer to have a class to represent such sums, much like Factorization represents products?

Yes, indeed. I had this (a class `Summandization` in some draft, but as it is nowhere else in [SageMath](SageMath) (e.g. `partial_fraction_decomposition`), I decided to keep it simple and consistent and use a tuple.


---

Comment by git created at 2017-02-09 09:26:44

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2017-02-24 19:16:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2017-02-24 19:21:30

Replying to [comment:39 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[78c8278](https://git.sagemath.org/sage.git/commit/?id=78c82783934627a550c1189c743d361b1e86c903)||`precise description of input/output of helper functions`||

I've written a better description of the helper functions to make reviewing easier.


---

Comment by git created at 2017-02-24 19:25:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2017-03-02 11:21:54

needs rebasing


---

Comment by mkoeppe created at 2017-03-02 11:22:09

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-03-02 11:33:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2017-03-02 11:34:42

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2017-03-02 11:34:42

Replying to [comment:42 mkoeppe]:
> needs rebasing

This was because of a change in one of its dependencies. Merged in; should now work again.


---

Comment by git created at 2017-04-10 12:44:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-04-13 11:00:00

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dkrenn created at 2017-04-13 11:05:09

Changing status from needs_review to needs_work.


---

Comment by dkrenn created at 2017-04-13 11:05:09

- Merged in 7.6, as some error messages concerning polynomial rings have changed and thus doctests failed.
- Merged in #22803, which simplifies the some generating functions due to cancellations
- Fixed a small bug.
- Restructured/refactored some code to make testing the overall result easier.
- Extended the existing doctests to see the correctness of the results.

(Set it to needs work as some docstrings are not yet written.)


---

Comment by git created at 2017-04-13 11:56:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2017-04-13 11:57:33

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2017-05-04 08:39:06

2 failing doctests, see patchbot report (wrong import)


---

Comment by chapoton created at 2017-05-20 07:21:51

ping ? just 2 imports need to be changed..


---

Comment by chapoton created at 2017-05-20 07:21:51

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-05-20 09:35:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2017-05-20 09:36:00

Replying to [comment:52 chapoton]:
> ping ? just 2 imports need to be changed..

Sorry, I am currently some kind of busy. However, changed the import. Let's see what the patchbot says now ;)


---

Comment by dkrenn created at 2017-05-20 09:36:10

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2017-05-22 20:06:59

Trivial remark: some "laurent" are missing their capitals.


---

Comment by chapoton created at 2017-11-24 08:58:06

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2017-11-24 08:58:06

and one failing doctest


---

Comment by git created at 2018-08-27 13:05:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-27 13:07:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2018-08-27 13:08:09

Replying to [comment:56 chapoton]:
> Trivial remark: some "laurent" are missing their capitals.

Fixed in ​0f2d193


---

Comment by dkrenn created at 2018-08-27 13:08:37

Replying to [comment:57 chapoton]:
> and one failing doctest

Fixed.


---

Comment by dkrenn created at 2018-08-27 13:09:09

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2018-08-27 13:09:57

you can just remove the dependencies (empty this field), once closed


---

Comment by git created at 2018-08-27 13:35:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-28 11:09:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-10-10 08:06:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by chapoton created at 2019-09-25 13:01:13

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2019-09-25 13:01:13

one failing doctest.


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 06:38:06

pushing these forward to 9.2


---

Comment by mkoeppe created at 2020-08-27 04:56:14

Looks like some py3 issues need fixing


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by git created at 2021-06-28 08:57:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-28 08:58:24

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2021-06-28 08:58:24

Actually, looked at this ticket just yesterday; now merged in 9.3, fixed the py3 issues and make it pass the tests again.


---

Comment by dkrenn created at 2021-06-28 09:01:46

I've skim read all the comments here; AFAICS, 3 to 4 years ago, the review seems to have completed but it hasn't made the step to a positive review. Anything that I missed?


---

Comment by dkrenn created at 2021-06-28 09:08:45

Replying to [comment:79 dkrenn]:
> I've skim read all the comments here; AFAICS, 3 to 4 years ago, the review seems to have been completed but it hasn't made the step to a positive review. Anything that I missed?


---

Comment by mkoeppe created at 2021-06-28 15:03:15

I think `prefix_variable_name` should be replaced by handling `name` and `names` arguments, like for example the `PolynomialRing` constructor does.


---

Comment by mkoeppe created at 2021-06-28 15:06:52

Also, codespell from `./sage -tox -- src/sage/geometry/polyhedron/generating_function.py` indicates the correction

```
sage/geometry/polyhedron/generating_function.py:110: handeled ==> handled, handheld
```


In the same line where this typo appears, there is another one: polyhedon->polyhedron


---

Comment by git created at 2021-06-29 16:58:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-29 17:01:26

Thank you for your fast replies. I've addressed both ticket:22067#comment:81 and ticket:22067#comment:82, need review.


---

Comment by mkoeppe created at 2021-06-29 17:09:43

There is still a `prefix_variable_name` in a docstring


---

Comment by git created at 2021-06-29 17:18:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-29 17:19:28

Replying to [comment:85 mkoeppe]:
> There is still a `prefix_variable_name` in a docstring

Indeed, thanks, fixed.


---

Comment by mkoeppe created at 2021-06-29 17:19:38

Also this docstring needs work

```
+def compositions_mod(u, m, r=0, multidimensional=False):
+    r"""
+    Return an iterable of tuples `a` such that `a u^T \equiv r \mod m`.
```

It should make clear that the items of `a` are elements of `Zmod(m)`.
Is there are reason why you don't make the results vectors over Zmod(m)?

Also this:

```
+
+    return _compositions_mod_(u, r)
```

I think should be using `yield from`.


---

Comment by mkoeppe created at 2021-06-29 17:23:56


```
+def _compositions_mod_(u, r):
+    r"""
+    Helper function to :func:`compositions_mod`.
```

should still describe what it does and explain input and output


---

Comment by mkoeppe created at 2021-06-29 17:31:03


```
+        split = iter((ph, ph.Hrepresentation_str(**Hrepresentation_str_options))
+                     for ph in split)
```

this is a "useless use of iter" -- the generator expression is already iterable.
(similarly in several other places in the file)


---

Comment by mkoeppe created at 2021-06-29 17:34:20


```
+    v = u[0]
+    m = max(vv.order() for vv in v)
+    Z = Zmod(m)
+    for j in srange(m):
```

I don't think max is correct here, shouldn't this be lcm?


---

Comment by mkoeppe created at 2021-06-29 17:37:19

Also
{{{ 
+    def _transform_(self):
}}}
... I think standard naming for internal functions would be `_transform`


---

Comment by git created at 2021-06-29 18:19:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-29 18:21:37

Replying to [comment:89 mkoeppe]:
> {{{
> +def _compositions_mod_(u, r):
> +    r"""
> +    Helper function to :func:`compositions_mod`.
> }}}
> should still describe what it does and explain input and output

Reading this again, I think, this is not a good style, as `_composition_mod_` is basically needed/used as this function calles recursively itself. I've renamed it to `recursively_build_compositions` and moved it into the main function, so slightly refactored the code.


---

Comment by dkrenn created at 2021-06-29 18:22:23

Replying to [comment:88 mkoeppe]:
> Also this docstring needs work
> {{{
> +def compositions_mod(u, m, r=0, multidimensional=False):
> +    r"""
> +    Return an iterable of tuples `a` such that `a u^T \equiv r \mod m`.
> }}}
> It should make clear that the items of `a` are elements of `Zmod(m)`.

Docstrings extended to state precisely what the items are.


---

Comment by dkrenn created at 2021-06-29 18:25:50

Replying to [comment:88 mkoeppe]:
> Is there are reason why you don't make the results vectors over Zmod(m)?

Yes. The elements do not have all neccessarily the same modulus; documented this now as well.


---

Comment by dkrenn created at 2021-06-29 18:28:24

Replying to [comment:88 mkoeppe]:
> Also this:
> {{{
> +
> +    return _compositions_mod_(u, r)
> }}}
> I think should be using `yield from`.

This does not change anything at all as `_compositions_mod_` is already a generator expression (and FWIW no for-loop is used anyways). What is the reason for doing this? A semantic reason maybe?
(I've done the change, but it can be reverted easily if there is no reason for using `yield from`.)


---

Comment by dkrenn created at 2021-06-29 18:28:51

Replying to [comment:90 mkoeppe]:
> {{{
> +        split = iter((ph, ph.Hrepresentation_str(**Hrepresentation_str_options))
> +                     for ph in split)
> }}}
> this is a "useless use of iter" -- the generator expression is already iterable.
> (similarly in several other places in the file)

Indeed; removed (all).


---

Comment by dkrenn created at 2021-06-29 18:29:40

Replying to [comment:91 mkoeppe]:
> {{{
> +    v = u[0]
> +    m = max(vv.order() for vv in v)
> +    Z = Zmod(m)
> +    for j in srange(m):
> }}}
> I don't think max is correct here, shouldn't this be lcm?

Ouch, yes, correct, it should definitely be `lcm`. How could I miss this? :) Changed.


---

Comment by mkoeppe created at 2021-06-29 18:31:22

it would be good to add a doctest in which lcm is different from max.


---

Comment by dkrenn created at 2021-06-29 18:32:16

Replying to [comment:92 mkoeppe]:
> Also
> {{{ 
> +    def _transform_(self):
> }}}
> ... I think standard naming for internal functions would be `_transform` 

I do think both conventions are used

```
dakrenn`@`nops:/opt/sage/9.3$ ./sage -grep "def _[a-zA-Z0-9][_a-zA-Z0-9]*[a-zA-Z0-9](" | wc -l
5899
dakrenn`@`nops:/opt/sage/9.3$ ./sage -grep "def _[a-zA-Z0-9][_a-zA-Z0-9]*[a-zA-Z0-9]_(" | wc -l
5908
```

Also, `_..._` is used in methods like `_repr_`, therefore I'm in favor of keeping it.


---

Comment by dkrenn created at 2021-06-29 18:33:25

Replying to [comment:100 mkoeppe]:
> it would be good to add a doctest in which lcm is different from max.

This is already the case in the existing

```
        sage: list(compositions_mod([(1, 2), (2, 2), (3, 2)], 6,
        ....:                       multidimensional=True))
        [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 0, 3), (4, 1, 4), (5, 2, 5)]
```

(which changed after switching to `lcm`)


---

Comment by mkoeppe created at 2021-06-29 18:35:11

Replying to [comment:101 dkrenn]:
> `_..._` is used in methods like `_repr_`

Yes, but this specifically mimics the "dunder" method `__repr__` to which it is connected.


---

Comment by mkoeppe created at 2021-06-29 18:36:08

Replying to [comment:102 dkrenn]:
> Replying to [comment:100 mkoeppe]:
> > it would be good to add a doctest in which lcm is different from max.
> 
> This is already the case in the existing
> {{{
>         sage: list(compositions_mod([(1, 2), (2, 2), (3, 2)], 6,
>         ....:                       multidimensional=True))
>         [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 0, 3), (4, 1, 4), (5, 2, 5)]
> }}}
> (which changed after switching to `lcm`)
OK, thanks, I hadn't noticed that


---

Comment by mkoeppe created at 2021-06-29 18:40:48

Replying to [comment:97 dkrenn]:
> Replying to [comment:88 mkoeppe]:
> > Also this:
> > {{{
> > +
> > +    return _compositions_mod_(u, r)
> > }}}
> > I think should be using `yield from`.
> 
> This does not change anything at all as `_compositions_mod_` is already a generator expression (and FWIW no for-loop is used anyways). What is the reason for doing this? A semantic reason maybe?
> (I've done the change, but it can be reverted easily if there is no reason for using `yield from`.)

It makes of course no practical difference in this example. 
But it is the syntactic presence of `yield` in the body of a function that changes a function to a generator. Consider:

```
sage: def test():
....:     if False: yield 1
....: 
sage: test()
<generator object test at 0x105434970>
```

So it is good practice to use `yield from` to pass on another generator, instead of just returning the generator object.


---

Comment by dkrenn created at 2021-06-29 18:56:16

Replying to [comment:103 mkoeppe]:
> Replying to [comment:101 dkrenn]:
> > `_..._` is used in methods like `_repr_`
> 
> Yes, but this specifically mimics the "dunder" method `__repr__` to which it is connected.

I see, thank you for this explanation. Anyways, the function discussed was renamed and refactored.


---

Comment by dkrenn created at 2021-06-29 18:57:39

Replying to [comment:105 mkoeppe]:
> But it is the syntactic presence of `yield` in the body of a function that changes a function to a generator. Consider:
> {{{
> sage: def test():
> ....:     if False: yield 1
> ....: 
> sage: test()
> <generator object test at 0x105434970>
> }}}
> So it is good practice to use `yield from` to pass on another generator, instead of just returning the generator object.

Ok, thank you. Yes, we then should keep the `yields from`.


---

Comment by mkoeppe created at 2021-06-29 19:04:16


```
+    if split is True:
+        split = (
+            (Polyhedron(
+                ieqs=[tuple(1 if i==b else (-1 if i==a or i==0 and a > b else 0)
+                            for i in range(d+1))
+                      for a, b in zip(pi[:-1], pi[1:])]),
+             'b{}'.format(pi[0]-1) +
+             ''.join((' <= ' if a < b else ' < ') +
+                     'b{}'.format(b-1)
+                     for a, b in zip(pi[:-1], pi[1:])))
+            for pi in Permutations(d))
+
```

This part looks a bit magical, could you illustrate this with doctests somewhere?


---

Comment by mkoeppe created at 2021-06-29 19:12:27

Also, the docstring of `compositions_mod` should probably use the word "all" somewhere. Are these ALL solutions to this modular equation? Is every solution returned exactly once? etc. 

Also the examples should be revised because in the output the crucial choice of the modulus for each of the components is not visible.

Overall, I think I would be happier if this whole thing could be redone in the language of point lattices (`sage.modules.free_module_integer`) and their cosets --- but I have not looked at how you use the result.


---

Comment by git created at 2021-06-30 17:26:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-30 17:31:41

Replying to [comment:109 mkoeppe]:
> Also, the docstring of `compositions_mod` should probably use the word "all" somewhere. Are these ALL solutions to this modular equation? Is every solution returned exactly once? etc. 

Done.


> Also the examples should be revised because in the output the crucial choice of the modulus for each of the components is not visible.

Done.

> Overall, I think I would be happier if this whole thing could be redone in the language of point lattices (`sage.modules.free_module_integer`) and their cosets --- but I have not looked at how you use the result.

The helper function `compositions_mod` returns the results exactly as needed in the class `TransformMod`. I suggest to do this "upgrade" of the function on a follow-up ticket.


---

Comment by dkrenn created at 2021-06-30 17:32:42

Replying to [comment:108 mkoeppe]:
> This part looks a bit magical, could you illustrate this with doctests somewhere?

Not that easy, but I somehow managed to write a doctest showing some details of this specific part of the code.


---

Comment by mkoeppe created at 2021-06-30 18:43:25

typo: "substitited"


---

Comment by mkoeppe created at 2021-06-30 18:44:14

Replying to [comment:111 dkrenn]:
> > Overall, I think I would be happier if this whole thing could be redone in the language of point lattices (`sage.modules.free_module_integer`) and their cosets --- but I have not looked at how you use the result.
> 
> The helper function `compositions_mod` returns the results exactly as needed in the class `TransformMod`. I suggest to do this "upgrade" of the function on a follow-up ticket.

Thanks for the changes you made. I agree, this part is sufficiently clear now


---

Comment by git created at 2021-06-30 18:49:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-30 18:49:39

Replying to [comment:113 mkoeppe]:
> typo: "substitited"

Fixed.


---

Comment by mkoeppe created at 2021-06-30 18:58:28

Replying to [comment:112 dkrenn]:
> Replying to [comment:108 mkoeppe]:
> > This part looks a bit magical, could you illustrate this with doctests somewhere?
> 
> Not that easy, but I somehow managed to write a doctest showing some details of this specific part of the code.

Thanks, this is an improvement. Now I understand that the strings that are assembled in this part of the code are just used for logging. 

I think both the description of the "splitting" in the documentation and the implementation can be made more transparent.

Perhaps it should at least be said that if `split=True`, it uses the complement of the `hyperplane_arrangements.braid`.


---

Comment by mkoeppe created at 2021-06-30 19:02:10

I was hoping to have something like `TransformHrepresentation` in more generality (related to #30198), but that's of course outside of the scope of this ticket


---

Comment by mkoeppe created at 2021-06-30 19:04:55

Maybe all of the helper classes in this file should be marked as internal somehow (can we use leading underscores for class names too?) so that if this is reworked for more generality, we don't have to go through deprecation.


---

Comment by mkoeppe created at 2021-06-30 19:05:35

Likewise for `compositions_mod` - it shouldn't be a public interface


---

Comment by mkoeppe created at 2021-06-30 19:07:33


```
+                ieqs=[tuple(1 if i==b else (-1 if i==a or i==0 and a > b else 0)
+                            for i in range(d+1))
```

how about splitting out the 0th position of this tuple here to make this more transparent.


---

Comment by mkoeppe created at 2021-06-30 19:11:06

There is a nontrivial algorithm in `SplitOffSimpleInequalities._transform_`, which probably needs some explanation


---

Comment by mkoeppe created at 2021-06-30 19:36:58

Replying to [comment:87 dkrenn]:
> Replying to [comment:85 mkoeppe]:
> > There is still a `prefix_variable_name` in a docstring
> 
> Indeed, thanks, fixed.

Following up on `name`/`names`:

```
+        sage: generating_function_of_integral_points(P2[0],
+        ....:     sort_factors=True, names=('a', 'b'))
+        Traceback (most recent call last):
+        ...
+        ValueError: exactly one variable name has to be provided
```

I don't understand this restriction. Why would the user not be allowed to provide all the names for the variables?


---

Comment by dkrenn created at 2021-07-01 08:36:15

`@`mkoeppe, thank you. I brievley looked over your comments and agree that these should be incorporated. I'll be off for some time now (maybe a week) and then continue to work on this.


---

Comment by mkoeppe created at 2021-07-17 21:50:00

Changing status from needs_review to needs_work.


---

Comment by git created at 2021-07-24 11:18:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-07-24 11:21:17

Replying to [comment:117 mkoeppe]:
> Replying to [comment:112 dkrenn]:
> > Replying to [comment:108 mkoeppe]:
> > > This part looks a bit magical, could you illustrate this with doctests somewhere?
> > 
> > Not that easy, but I somehow managed to write a doctest showing some details of this specific part of the code.
> 
> Thanks, this is an improvement. Now I understand that the strings that are assembled in this part of the code are just used for logging. 
> 
> I think both the description of the "splitting" in the documentation and the implementation can be made more transparent.

Documentation rewritten and extended.

> Perhaps it should at least be said that if `split=True`, it uses the complement of the `hyperplane_arrangements.braid`.

Rephrased now anyways. (Not sure if bringing in two more concepts ("braid" and "complement of") would  makes things more clear.)


---

Comment by dkrenn created at 2021-07-24 11:22:14

Replying to [comment:119 mkoeppe]:
> Maybe all of the helper classes in this file should be marked as internal somehow (can we use leading underscores for class names too?) so that if this is reworked for more generality, we don't have to go through deprecation.

Now they are internal (IMO this should have been also without the fear of a deprecation).


---

Comment by dkrenn created at 2021-07-24 11:22:35

Replying to [comment:120 mkoeppe]:
> Likewise for `compositions_mod` - it shouldn't be a public interface

Done.


---

Comment by dkrenn created at 2021-07-24 11:23:12

Replying to [comment:121 mkoeppe]:
> {{{
> +                ieqs=[tuple(1 if i==b else (-1 if i==a or i==0 and a > b else 0)
> +                            for i in range(d+1))
> }}}
> how about splitting out the 0th position of this tuple here to make this more transparent.

Code majorly rewritten with the hope that it is clearer now.


---

Comment by dkrenn created at 2021-07-24 11:23:58

Replying to [comment:123 mkoeppe]:
> Replying to [comment:87 dkrenn]:
> > Replying to [comment:85 mkoeppe]:
> > > There is still a `prefix_variable_name` in a docstring
> > 
> > Indeed, thanks, fixed.
> 
> Following up on `name`/`names`:
> {{{
> +        sage: generating_function_of_integral_points(P2[0],
> +        ....:     sort_factors=True, names=('a', 'b'))
> +        Traceback (most recent call last):
> +        ...
> +        ValueError: exactly one variable name has to be provided
> }}}
> I don't understand this restriction. Why would the user not be allowed to provide all the names for the variables?

Can be done on a follow up ticket; it raises a `NotImplementedError` now.


---

Comment by dkrenn created at 2021-07-24 11:24:27

Replying to [comment:122 mkoeppe]:
> There is a nontrivial algorithm in `SplitOffSimpleInequalities._transform_`, which probably needs some explanation

This is still open.
