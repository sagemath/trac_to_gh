# Issue 17872: IntegerListLex better not be a parent

archive/issues_017872.json:
```json
{
    "body": "CC:  @anneschilling @jdemeyer @nthiery @nathanncohen @bgillesp\n\nThere are several useless features in `IntegerListLex` as already mentioned in [ticket #17979:comment 21](http://trac.sagemath.org/ticket/17979#comment:291):\n- it should not inherit from `Parent` and it should generate lists and not `ClonableArray`\n- `global_options` is a useless attribute\n- the `__clascall__` is here for nothing\n\nIssue created by migration from https://trac.sagemath.org/ticket/18109\n\n",
    "created_at": "2015-04-02T14:39:38Z",
    "labels": [
        "combinatorics",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.10",
    "title": "IntegerListLex better not be a parent",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17872",
    "user": "@videlec"
}
```
CC:  @anneschilling @jdemeyer @nthiery @nathanncohen @bgillesp

There are several useless features in `IntegerListLex` as already mentioned in [ticket #17979:comment 21](http://trac.sagemath.org/ticket/17979#comment:291):
- it should not inherit from `Parent` and it should generate lists and not `ClonableArray`
- `global_options` is a useless attribute
- the `__clascall__` is here for nothing

Issue created by migration from https://trac.sagemath.org/ticket/18109





---

archive/issue_comments_239691.json:
```json
{
    "body": "- I believe we should rephrase this ticket as \"extract the\n  `IntegerListsLex` *iterator* as a standalone tool that depends on\n  nothing but `Python`/`Cython`\". In fact this could go as far as making\n  it a standalone library in e.g. C++.\n\n  We want to keep the parent to model the set itself, ask questions\n  like cardinality or building the polyhedron, do constructions on top\n  of it (e.g. use it as indexing set for a vector space), etc.\n\n  #18056 would be a good occasion to handle this part.\n\n- Being able to specify an element constructor is a useful feature as\n  well. What we need to discuss here is whether we want to switch to\n  using lists (or tuples!) by default.\n\n- To remove `__classcall__` we need to wait until the end of the\n  deprecation period. To remove `global_options` we need to wait for\n  the subclasses using it to be refactored to not impose this burden\n  on `IntegerListsLex`.",
    "created_at": "2015-04-13T11:52:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239691",
    "user": "@nthiery"
}
```

- I believe we should rephrase this ticket as "extract the
  `IntegerListsLex` *iterator* as a standalone tool that depends on
  nothing but `Python`/`Cython`". In fact this could go as far as making
  it a standalone library in e.g. C++.

  We want to keep the parent to model the set itself, ask questions
  like cardinality or building the polyhedron, do constructions on top
  of it (e.g. use it as indexing set for a vector space), etc.

  #18056 would be a good occasion to handle this part.

- Being able to specify an element constructor is a useful feature as
  well. What we need to discuss here is whether we want to switch to
  using lists (or tuples!) by default.

- To remove `__classcall__` we need to wait until the end of the
  deprecation period. To remove `global_options` we need to wait for
  the subclasses using it to be refactored to not impose this burden
  on `IntegerListsLex`.



---

archive/issue_comments_239692.json:
```json
{
    "body": ">   We want to keep the parent to model the set itself, ask questions\n>   like cardinality or building the polyhedron, do constructions on top\n>   of it (e.g. use it as indexing set for a vector space), etc.\n\nThe 'Lex' there seems a bit too much for the mathematical object that you want to represent. You describe things that could be a method of an 'IntegerLists' object (or more specifically methods of 'Compositions' or 'Partitions').\n\n> - Being able to specify an element constructor is a useful feature as\n>   well. What we need to discuss here is whether we want to switch to\n>   using lists (or tuples!) by default.\n\nThere should be a way to enumerate these objects without paying this cost, however. A way to have both is to implement the iterator to return a copy of the current list, or a tuple (or even the current list itself, with big 'read only' warnings), and then implement in `IntegerListsLex` an `__iter__` that wraps every element returned by that iterator with <whatever you need>.\n\nNathann",
    "created_at": "2015-04-13T12:52:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239692",
    "user": "@nathanncohen"
}
```

>   We want to keep the parent to model the set itself, ask questions
>   like cardinality or building the polyhedron, do constructions on top
>   of it (e.g. use it as indexing set for a vector space), etc.

The 'Lex' there seems a bit too much for the mathematical object that you want to represent. You describe things that could be a method of an 'IntegerLists' object (or more specifically methods of 'Compositions' or 'Partitions').

> - Being able to specify an element constructor is a useful feature as
>   well. What we need to discuss here is whether we want to switch to
>   using lists (or tuples!) by default.

There should be a way to enumerate these objects without paying this cost, however. A way to have both is to implement the iterator to return a copy of the current list, or a tuple (or even the current list itself, with big 'read only' warnings), and then implement in `IntegerListsLex` an `__iter__` that wraps every element returned by that iterator with <whatever you need>.

Nathann



---

archive/issue_comments_239693.json:
```json
{
    "body": "Replying to [comment:2 ncohen]:\n> There should be a way to enumerate these objects without paying this cost, however. A way to have both is to implement the iterator to return a copy of the current list, or a tuple (or even the current list itself, with big 'read only' warnings), and then implement in `IntegerListsLex` an `__iter__` that wraps every element returned by that iterator with <whatever you need>.\n\nThat's also what I have in mind: a low-level class designed to be clean and fast implemented in Cython without overhead. And then a class on top of that which can implement whatever extra Python features that you want.",
    "created_at": "2015-04-13T13:06:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239693",
    "user": "@jdemeyer"
}
```

Replying to [comment:2 ncohen]:
> There should be a way to enumerate these objects without paying this cost, however. A way to have both is to implement the iterator to return a copy of the current list, or a tuple (or even the current list itself, with big 'read only' warnings), and then implement in `IntegerListsLex` an `__iter__` that wraps every element returned by that iterator with <whatever you need>.

That's also what I have in mind: a low-level class designed to be clean and fast implemented in Cython without overhead. And then a class on top of that which can implement whatever extra Python features that you want.



---

archive/issue_comments_239694.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-13T16:52:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239694",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239695.json:
```json
{
    "body": "Hi Jeroen,\n\nAs a matter of fact, if you isolate the commit that just move a file, the diff looks much nicer. I am not able to get something reasonable with the options `-B`, `-C`, `-M` or `-D`. Do you know what to do?\n\nVincent",
    "created_at": "2015-04-13T17:01:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239695",
    "user": "@videlec"
}
```

Hi Jeroen,

As a matter of fact, if you isolate the commit that just move a file, the diff looks much nicer. I am not able to get something reasonable with the options `-B`, `-C`, `-M` or `-D`. Do you know what to do?

Vincent



---

archive/issue_comments_239696.json:
```json
{
    "body": "Replying to [comment:9 vdelecroix]:\n> Hi Jeroen,\n> \n> As a matter of fact, if you isolate the commit that just move a file, the diff looks much nicer. I am not able to get something reasonable with the options `-B`, `-C`, `-M` or `-D`. Do you know what to do?\n\nSorry no. I don't know how to nicely show diffs which split up a file in two (interestingly, `hg` has better support for this!)",
    "created_at": "2015-04-13T18:05:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239696",
    "user": "@jdemeyer"
}
```

Replying to [comment:9 vdelecroix]:
> Hi Jeroen,
> 
> As a matter of fact, if you isolate the commit that just move a file, the diff looks much nicer. I am not able to get something reasonable with the options `-B`, `-C`, `-M` or `-D`. Do you know what to do?

Sorry no. I don't know how to nicely show diffs which split up a file in two (interestingly, `hg` has better support for this!)



---

archive/issue_comments_239697.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-13T18:44:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239697",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239698.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-13T21:22:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239698",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239699.json:
```json
{
    "body": "A comment on the design... Should we really support +Infinity in the iterator? I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity. Of course it makes sense for the higher classes (e.g. to give a proper answer to `.cardinality()`).",
    "created_at": "2015-04-13T22:23:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239699",
    "user": "@videlec"
}
```

A comment on the design... Should we really support +Infinity in the iterator? I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity. Of course it makes sense for the higher classes (e.g. to give a proper answer to `.cardinality()`).



---

archive/issue_comments_239700.json:
```json
{
    "body": "Replying to [comment:14 vdelecroix]:\n> A comment on the design... Should we really support +Infinity in the iterator?\nYes.\n\n> I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity.\nAnd not support `IntegerLists(10^100)`?",
    "created_at": "2015-04-14T05:51:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239700",
    "user": "@jdemeyer"
}
```

Replying to [comment:14 vdelecroix]:
> A comment on the design... Should we really support +Infinity in the iterator?
Yes.

> I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity.
And not support `IntegerLists(10^100)`?



---

archive/issue_comments_239701.json:
```json
{
    "body": "Replying to [comment:15 jdemeyer]:\n> Replying to [comment:14 vdelecroix]:\n> > A comment on the design... Should we really support +Infinity in the iterator?\n> Yes.\n> \n> > I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity.\n> And not support `IntegerLists(10^100)`?\n\nI said for the iterator. Not for the main class. I would not bother if `iter(IntegerLists(10^100))` just failed. It should be very fast for small entries. I guess that one option would be to use Nathann strategy in #18137 with fused Cython type (here `unsigned int` and `mpz_t`). But I remember that it was nearly impossible to make it work as attributes of an extension class.",
    "created_at": "2015-04-14T06:07:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239701",
    "user": "@videlec"
}
```

Replying to [comment:15 jdemeyer]:
> Replying to [comment:14 vdelecroix]:
> > A comment on the design... Should we really support +Infinity in the iterator?
> Yes.
> 
> > I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity.
> And not support `IntegerLists(10^100)`?

I said for the iterator. Not for the main class. I would not bother if `iter(IntegerLists(10^100))` just failed. It should be very fast for small entries. I guess that one option would be to use Nathann strategy in #18137 with fused Cython type (here `unsigned int` and `mpz_t`). But I remember that it was nearly impossible to make it work as attributes of an extension class.



---

archive/issue_comments_239702.json:
```json
{
    "body": "Replying to [comment:16 vdelecroix]:\n> But I remember that it was nearly impossible to make it work as attributes of an extension class.\nFor attributes of an extension class, no. I guess you could have two classes (one for some C type and one for `mpz_t`) on top of a common base class. But I have never done this.",
    "created_at": "2015-04-14T07:16:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239702",
    "user": "@jdemeyer"
}
```

Replying to [comment:16 vdelecroix]:
> But I remember that it was nearly impossible to make it work as attributes of an extension class.
For attributes of an extension class, no. I guess you could have two classes (one for some C type and one for `mpz_t`) on top of a common base class. But I have never done this.



---

archive/issue_comments_239703.json:
```json
{
    "body": "Replying to [comment:16 vdelecroix]:\n> Replying to [comment:15 jdemeyer]:\n> > Replying to [comment:14 vdelecroix]:\n> > > A comment on the design... Should we really support +Infinity in the iterator?\n> > Yes.\n> > \n> > > I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity.\n> > And not support `IntegerLists(10^100)`?\n> \n> I said for the iterator. Not for the main class. I would not bother if `iter(IntegerLists(10^100))` just failed. It should be very fast for small entries. I guess that one option would be to use Nathann strategy in #18137 with fused Cython type (here `unsigned int` and `mpz_t`).\n\nI think that we really should support `list(IntegerLists(10^100, length=1))` because in Sage, we *always* support large integers if possible.\n\nIn any case, changing this is certainly outside the scope of this ticket (it could be done in #18055 or #18056). Here, I just want to reorganize the code without changing the implementation.",
    "created_at": "2015-04-14T07:18:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239703",
    "user": "@jdemeyer"
}
```

Replying to [comment:16 vdelecroix]:
> Replying to [comment:15 jdemeyer]:
> > Replying to [comment:14 vdelecroix]:
> > > A comment on the design... Should we really support +Infinity in the iterator?
> > Yes.
> > 
> > > I would go for `unsigned int` variables and `UINT_MAX` as a synonmyous for Infinity.
> > And not support `IntegerLists(10^100)`?
> 
> I said for the iterator. Not for the main class. I would not bother if `iter(IntegerLists(10^100))` just failed. It should be very fast for small entries. I guess that one option would be to use Nathann strategy in #18137 with fused Cython type (here `unsigned int` and `mpz_t`).

I think that we really should support `list(IntegerLists(10^100, length=1))` because in Sage, we *always* support large integers if possible.

In any case, changing this is certainly outside the scope of this ticket (it could be done in #18055 or #18056). Here, I just want to reorganize the code without changing the implementation.



---

archive/issue_comments_239704.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T09:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239704",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239705.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T10:35:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239705",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239706.json:
```json
{
    "body": "Replying to [comment:18 jdemeyer]:\n> I think that we really should support `list(IntegerLists(10^100, length=1))` because in Sage, we *always* support large integers if possible.\n\nThat's part of why I am thinking of C++; then we can just have a\ntemplated iterator, and depending on the input we can choose one\ninstantiation or the other.\n\n> In any case, changing this is certainly outside the scope of this\n> ticket (it could be done in #18055 or #18056). Here, I just want to\n> reorganize the code without changing the implementation.\n\nSounds reasonable indeed.\n----\nNew commits:",
    "created_at": "2015-04-14T10:36:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239706",
    "user": "@nthiery"
}
```

Replying to [comment:18 jdemeyer]:
> I think that we really should support `list(IntegerLists(10^100, length=1))` because in Sage, we *always* support large integers if possible.

That's part of why I am thinking of C++; then we can just have a
templated iterator, and depending on the input we can choose one
instantiation or the other.

> In any case, changing this is certainly outside the scope of this
> ticket (it could be done in #18055 or #18056). Here, I just want to
> reorganize the code without changing the implementation.

Sounds reasonable indeed.
----
New commits:



---

archive/issue_comments_239707.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T11:08:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239707",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239708.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T12:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239708",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239709.json:
```json
{
    "body": "Replying to [comment:9 vdelecroix]:\n> I am not able to get something reasonable with the options `-B`, `-C`, `-M` or `-D`. Do you know what to do?\nActually, the following will show everything as copied from `integer_list.py`:\n\n```\ngit show --patience -D -B -C01\n```\n",
    "created_at": "2015-04-14T12:00:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239709",
    "user": "@jdemeyer"
}
```

Replying to [comment:9 vdelecroix]:
> I am not able to get something reasonable with the options `-B`, `-C`, `-M` or `-D`. Do you know what to do?
Actually, the following will show everything as copied from `integer_list.py`:

```
git show --patience -D -B -C01
```




---

archive/issue_comments_239710.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T13:11:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239710",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239711.json:
```json
{
    "body": "This now passes all doctests except for the pickle jar.",
    "created_at": "2015-04-14T14:44:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239711",
    "user": "@jdemeyer"
}
```

This now passes all doctests except for the pickle jar.



---

archive/issue_comments_239712.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T15:40:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239712",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239713.json:
```json
{
    "body": "Passes all doctests and documentation builds.",
    "created_at": "2015-04-14T15:41:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239713",
    "user": "@jdemeyer"
}
```

Passes all doctests and documentation builds.



---

archive/issue_comments_239714.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-14T20:32:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239714",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239715.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-04-14T20:33:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239715",
    "user": "@jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_239716.json:
```json
{
    "body": "Hi Jeroen!\n\nSince you seem to have cythonized the code already, could you add some timings compared to the old code?\n\nAnne\n\nPS: I was under the impression that it is harder to debug code in cython, which might make life a little harder for the new features in #18055.",
    "created_at": "2015-04-14T23:23:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239716",
    "user": "@anneschilling"
}
```

Hi Jeroen!

Since you seem to have cythonized the code already, could you add some timings compared to the old code?

Anne

PS: I was under the impression that it is harder to debug code in cython, which might make life a little harder for the new features in #18055.



---

archive/issue_comments_239717.json:
```json
{
    "body": "Replying to [comment:32 aschilling]:\n> Since you seem to have cythonized the code already, could you add some timings compared to the old code?\nMy goal certainly was not to gain speed, but I could check...\n\n> I was under the impression that it is harder to debug code in cython, which might make life a little harder for the new features in #18055.\nI have no idea really. A lot of the code I write for Sage is Cython and it hasn't bothered me.\n\nOn the other hand, I on purpose did not Cythonize `IntegerListsLexIter` (it's in a Cython source file, but doesn't use any Cython features). So if it makes your life easier, just move that one class to a Python file.",
    "created_at": "2015-04-15T06:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239717",
    "user": "@jdemeyer"
}
```

Replying to [comment:32 aschilling]:
> Since you seem to have cythonized the code already, could you add some timings compared to the old code?
My goal certainly was not to gain speed, but I could check...

> I was under the impression that it is harder to debug code in cython, which might make life a little harder for the new features in #18055.
I have no idea really. A lot of the code I write for Sage is Cython and it hasn't bothered me.

On the other hand, I on purpose did not Cythonize `IntegerListsLexIter` (it's in a Cython source file, but doesn't use any Cython features). So if it makes your life easier, just move that one class to a Python file.



---

archive/issue_comments_239718.json:
```json
{
    "body": "Replying to [comment:32 aschilling]:\n> you seem to have cythonized the code already\nDepends what you mean. I moved the files to a Cython source file and I created extension types instead of Python classes. But I didn't optimize the loops for example.",
    "created_at": "2015-04-15T07:18:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239718",
    "user": "@jdemeyer"
}
```

Replying to [comment:32 aschilling]:
> you seem to have cythonized the code already
Depends what you mean. I moved the files to a Cython source file and I created extension types instead of Python classes. But I didn't optimize the loops for example.



---

archive/issue_comments_239719.json:
```json
{
    "body": "There is a small but significant speed-up (again: this is without really trying to speed up the code).\n\n------\n\nBefore:\n\n```\nsage: timeit('list(IntegerListsLex(14, min_part=1))')\n5 loops, best of 3: 1.18 s per loop\n```\n\n\nAfter:\n\n```\nsage: timeit('list(IntegerListsLex(14, min_part=1))')\n5 loops, best of 3: 986 ms per loop\n```\n\n\n------\n\nBefore:\n\n```\nsage: timeit('list(IntegerListsLex(28, length=8, floor=lambda i:i, check=False))')\n5 loops, best of 3: 1.11 s per loop\n```\n\n\nAfter:\n\n```\nsage: timeit('list(IntegerListsLex(28, length=8, floor=lambda i:i, check=False))')\n5 loops, best of 3: 852 ms per loop\n```\n",
    "created_at": "2015-04-15T07:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239719",
    "user": "@jdemeyer"
}
```

There is a small but significant speed-up (again: this is without really trying to speed up the code).

------

Before:

```
sage: timeit('list(IntegerListsLex(14, min_part=1))')
5 loops, best of 3: 1.18 s per loop
```


After:

```
sage: timeit('list(IntegerListsLex(14, min_part=1))')
5 loops, best of 3: 986 ms per loop
```


------

Before:

```
sage: timeit('list(IntegerListsLex(28, length=8, floor=lambda i:i, check=False))')
5 loops, best of 3: 1.11 s per loop
```


After:

```
sage: timeit('list(IntegerListsLex(28, length=8, floor=lambda i:i, check=False))')
5 loops, best of 3: 852 ms per loop
```




---

archive/issue_comments_239720.json:
```json
{
    "body": "Nice that there is a slight speedup without even trying hard!\n\nFYI, I rebased this branch on top of sage-6.7.beta0 and everything looks clean.\n\nI noticed that in `nn.y` in `sage.combinat.integer_lists` it currently says\n\n```\n    .. WARNING:: this function is likely to disappear in :trac:`17927`.\n```\n\nBriefly looking at `17927` this seems no longer the case.",
    "created_at": "2015-04-15T16:44:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239720",
    "user": "@anneschilling"
}
```

Nice that there is a slight speedup without even trying hard!

FYI, I rebased this branch on top of sage-6.7.beta0 and everything looks clean.

I noticed that in `nn.y` in `sage.combinat.integer_lists` it currently says

```
    .. WARNING:: this function is likely to disappear in :trac:`17927`.
```

Briefly looking at `17927` this seems no longer the case.



---

archive/issue_comments_239721.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-15T19:22:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239721",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239722.json:
```json
{
    "body": "In principle this branch looks good to me; I guess it needs to be rebased to the latest development version, however.\n\nJust to check: are you planning to reuse the Envelope class also for #17920? The planned changes there involving backward smoothing etc will be ok, right?",
    "created_at": "2015-04-16T05:28:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239722",
    "user": "@anneschilling"
}
```

In principle this branch looks good to me; I guess it needs to be rebased to the latest development version, however.

Just to check: are you planning to reuse the Envelope class also for #17920? The planned changes there involving backward smoothing etc will be ok, right?



---

archive/issue_comments_239723.json:
```json
{
    "body": "Replying to [comment:38 aschilling]:\n> Just to check: are you planning to reuse the Envelope class also for #17920? The planned changes there involving backward smoothing etc will be ok, right?\nSure. The only risk is that errors in `Envelope` will make both implementations wrong.",
    "created_at": "2015-04-16T05:54:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239723",
    "user": "@jdemeyer"
}
```

Replying to [comment:38 aschilling]:
> Just to check: are you planning to reuse the Envelope class also for #17920? The planned changes there involving backward smoothing etc will be ok, right?
Sure. The only risk is that errors in `Envelope` will make both implementations wrong.



---

archive/issue_comments_239724.json:
```json
{
    "body": "Replying to [comment:38 aschilling]:\n> In principle this branch looks good to me; I guess it needs to be rebased to the latest development version, however.\nDespite the red link on Trac, it actually merges cleanly with `6.7.beta1`",
    "created_at": "2015-04-16T05:55:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239724",
    "user": "@jdemeyer"
}
```

Replying to [comment:38 aschilling]:
> In principle this branch looks good to me; I guess it needs to be rebased to the latest development version, however.
Despite the red link on Trac, it actually merges cleanly with `6.7.beta1`



---

archive/issue_comments_239725.json:
```json
{
    "body": "Hi Jeroen,\n\nCould you please rebase this patch on the latest development version, so I can do the final review? Nicolas never made a comment, so I assume he is ok with it!\n\nBest,\n\nAnne",
    "created_at": "2015-04-29T04:02:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239725",
    "user": "@anneschilling"
}
```

Hi Jeroen,

Could you please rebase this patch on the latest development version, so I can do the final review? Nicolas never made a comment, so I assume he is ok with it!

Best,

Anne



---

archive/issue_comments_239726.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-29T09:19:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239726",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239727.json:
```json
{
    "body": "I went through the code and the restructuring looks good to me. All tests pass and the documentation builds. One question I have though is about the comparison functions in `base.py` and `lists.py`. The tests look almost identical. So which one is actually used for `IntegerListsLex`?",
    "created_at": "2015-04-29T23:05:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239727",
    "user": "@anneschilling"
}
```

I went through the code and the restructuring looks good to me. All tests pass and the documentation builds. One question I have though is about the comparison functions in `base.py` and `lists.py`. The tests look almost identical. So which one is actually used for `IntegerListsLex`?



---

archive/issue_comments_239728.json:
```json
{
    "body": "Hi Jeroen,\n\nSorry, I got sidetracked reviewing other tickets. Thanks Anne for the\nreminder, and for checking the code and the documentation!\n\nI have just been through the code myself (not checking the fine\ndetails though).\n\nAltogether, I believe it's correct. Cythonizing the envelope function\nand making the iterator into a Cython class that depends on little of\nthe Sage infrastructure was in our long term plans, so that's great (I\nwould have done it after the algorithm refactorisation, but since it's\ndone, let's move forward). Generalizing a base IntegerLists class is\nuseful as well.\n\nOn the other hand, is it absolutely necessary to have this separation\nbetween frontend and backend classes? It introduces some complexity\nand in fact some duplication (e.g. in the tests). In particular, I am\nworried that it might introduce complexity in the construction of new\nspecial case classes based on `IntegerListsLex`, when the primary goal\nis to make this as trivial as possible. I'd need to actually implement\nsuch new classes to qualify this worry.\n\nIf it's just a question of avoiding calls to the element constructor,\ncould not this be done just locally in `__iter__` (returning directly\nan `IntegerListsLexIter` object, or mapping the constructor on it)?\nIf it's a question of making the iterator code independent of\n`Parent`, well, it already is: it only uses the `IntegerListsLex`\nobject as a data holder for the constraints, right? As long as we\ndon't have a specific use case (backed up by benchmarks if speed is\nthe motivation), there may not be much point in maintaining additional\ncode for this.\n\nAt the very least, there should be some entry point (typically in the\nmodule description) listing all the classes, and clarifying their\nrespective roles. Maybe slightly more systematic class names could\nhelp; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,\n`IntegerListsLexBackend`.\n\n\nSome small suggestions:\n\n- some of the cdef attributes could be declared as\n  int's. E.g. `Envelope.min_length`.\n\n- maybe we could use the occasion to rename the attribute\n  `IntegerListsLexIter.parent` especially if it's not a parent\n  anymore.\n\n- Another small complication is having to handle pickling by hand each\n  time. At least, would there be a way to implement `XXX.__reduce__`\n  to return `(XXX, *)` rather than having to implement an\n  `unpickle_XXX` function each time?\n\nCheers,\n                          Nicolas",
    "created_at": "2015-04-30T09:12:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239728",
    "user": "@nthiery"
}
```

Hi Jeroen,

Sorry, I got sidetracked reviewing other tickets. Thanks Anne for the
reminder, and for checking the code and the documentation!

I have just been through the code myself (not checking the fine
details though).

Altogether, I believe it's correct. Cythonizing the envelope function
and making the iterator into a Cython class that depends on little of
the Sage infrastructure was in our long term plans, so that's great (I
would have done it after the algorithm refactorisation, but since it's
done, let's move forward). Generalizing a base IntegerLists class is
useful as well.

On the other hand, is it absolutely necessary to have this separation
between frontend and backend classes? It introduces some complexity
and in fact some duplication (e.g. in the tests). In particular, I am
worried that it might introduce complexity in the construction of new
special case classes based on `IntegerListsLex`, when the primary goal
is to make this as trivial as possible. I'd need to actually implement
such new classes to qualify this worry.

If it's just a question of avoiding calls to the element constructor,
could not this be done just locally in `__iter__` (returning directly
an `IntegerListsLexIter` object, or mapping the constructor on it)?
If it's a question of making the iterator code independent of
`Parent`, well, it already is: it only uses the `IntegerListsLex`
object as a data holder for the constraints, right? As long as we
don't have a specific use case (backed up by benchmarks if speed is
the motivation), there may not be much point in maintaining additional
code for this.

At the very least, there should be some entry point (typically in the
module description) listing all the classes, and clarifying their
respective roles. Maybe slightly more systematic class names could
help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,
`IntegerListsLexBackend`.


Some small suggestions:

- some of the cdef attributes could be declared as
  int's. E.g. `Envelope.min_length`.

- maybe we could use the occasion to rename the attribute
  `IntegerListsLexIter.parent` especially if it's not a parent
  anymore.

- Another small complication is having to handle pickling by hand each
  time. At least, would there be a way to implement `XXX.__reduce__`
  to return `(XXX, *)` rather than having to implement an
  `unpickle_XXX` function each time?

Cheers,
                          Nicolas



---

archive/issue_comments_239729.json:
```json
{
    "body": "Replying to [comment:44 nthiery]:\n> On the other hand, is it absolutely necessary to have this separation\n> between frontend and backend classes?\n> If it's a question of making the iterator code independent of\n> `Parent`\nIt's a question of making the backend class independent of `Parent` yes. I think it's good to have a fast simple Cython backend and a proper Sage `Parent` front-end.\n\n> Some small suggestions:\n> \n> - some of the cdef attributes could be declared as\n>   int's. E.g. `Envelope.min_length`.\nI consider that out of the scope of this ticket. These are micro-optimizations which can be done after we have a clearer view of the final design.\n\n> - maybe we could use the occasion to rename the attribute\n>   `IntegerListsLexIter.parent` especially if it's not a parent\n>   anymore.\nSure, fine for me.\n\n> - Another small complication is having to handle pickling by hand each\n>   time. At least, would there be a way to implement `XXX.__reduce__`\n>   to return `(XXX, *)` rather than having to implement an\n>   `unpickle_XXX` function each time?\nIt's certainly annoying, but that's because Cython cannot automatically (un)pickle extension types. I have to check if it can be simplified.",
    "created_at": "2015-04-30T10:29:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239729",
    "user": "@jdemeyer"
}
```

Replying to [comment:44 nthiery]:
> On the other hand, is it absolutely necessary to have this separation
> between frontend and backend classes?
> If it's a question of making the iterator code independent of
> `Parent`
It's a question of making the backend class independent of `Parent` yes. I think it's good to have a fast simple Cython backend and a proper Sage `Parent` front-end.

> Some small suggestions:
> 
> - some of the cdef attributes could be declared as
>   int's. E.g. `Envelope.min_length`.
I consider that out of the scope of this ticket. These are micro-optimizations which can be done after we have a clearer view of the final design.

> - maybe we could use the occasion to rename the attribute
>   `IntegerListsLexIter.parent` especially if it's not a parent
>   anymore.
Sure, fine for me.

> - Another small complication is having to handle pickling by hand each
>   time. At least, would there be a way to implement `XXX.__reduce__`
>   to return `(XXX, *)` rather than having to implement an
>   `unpickle_XXX` function each time?
It's certainly annoying, but that's because Cython cannot automatically (un)pickle extension types. I have to check if it can be simplified.



---

archive/issue_comments_239730.json:
```json
{
    "body": "Hi Jeroen,\n\nReplying to [comment:45 jdemeyer]:\n> It's a question of making the backend class independent of `Parent` yes. I think it's good to have a fast simple Cython backend and a proper Sage `Parent` front-end.\n\nI agree its good in theory. But if it makes things more complicated,\nthen it's only good in practice if we have an actual use case.\n\nA main point being: unless we create millions of small IntegerListsLex\nobjects, I don't see why having it be a (facade) parent makes things\nslower.\n\n> I consider that out of the scope of this ticket. These are micro-optimizations which can be done after we have a clearer view of the final design.\n\nFair enough.\n\n> It's certainly annoying, but that's because Cython cannot automatically (un)pickle extension types. I have to check if it can be simplified.\n\nThanks!\n\nCheers,\n                          Nicolas\n\nPS: I forgot to word my appreciation for the hard work!",
    "created_at": "2015-04-30T11:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239730",
    "user": "@nthiery"
}
```

Hi Jeroen,

Replying to [comment:45 jdemeyer]:
> It's a question of making the backend class independent of `Parent` yes. I think it's good to have a fast simple Cython backend and a proper Sage `Parent` front-end.

I agree its good in theory. But if it makes things more complicated,
then it's only good in practice if we have an actual use case.

A main point being: unless we create millions of small IntegerListsLex
objects, I don't see why having it be a (facade) parent makes things
slower.

> I consider that out of the scope of this ticket. These are micro-optimizations which can be done after we have a clearer view of the final design.

Fair enough.

> It's certainly annoying, but that's because Cython cannot automatically (un)pickle extension types. I have to check if it can be simplified.

Thanks!

Cheers,
                          Nicolas

PS: I forgot to word my appreciation for the hard work!



---

archive/issue_comments_239731.json:
```json
{
    "body": "Replying to [comment:46 nthiery]:\n>      Hi Jeroen,\n> \n> Replying to [comment:45 jdemeyer]:\n> > It's a question of making the backend class independent of `Parent` yes. I think it's good to have a fast simple Cython backend and a proper Sage `Parent` front-end.\n> \n> I agree its good in theory. But if it makes things more complicated,\n> then it's only good in practice if we have an actual use case.\n> \n> A main point being: unless we create millions of small IntegerListsLex\n> objects, I don't see why having it be a (facade) parent makes things\n> slower.\n\nA use case is in `MatrixSpace.__iter__` and I also have others intensive usage for building so-called square tiled surfaces (if you care, look at `u/vdelecroix/flat_surfaces-6.5`). I would be grateful if the iterator could be accessible without initializing any parent.\n\nVincent",
    "created_at": "2015-04-30T11:40:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239731",
    "user": "@videlec"
}
```

Replying to [comment:46 nthiery]:
>      Hi Jeroen,
> 
> Replying to [comment:45 jdemeyer]:
> > It's a question of making the backend class independent of `Parent` yes. I think it's good to have a fast simple Cython backend and a proper Sage `Parent` front-end.
> 
> I agree its good in theory. But if it makes things more complicated,
> then it's only good in practice if we have an actual use case.
> 
> A main point being: unless we create millions of small IntegerListsLex
> objects, I don't see why having it be a (facade) parent makes things
> slower.

A use case is in `MatrixSpace.__iter__` and I also have others intensive usage for building so-called square tiled surfaces (if you care, look at `u/vdelecroix/flat_surfaces-6.5`). I would be grateful if the iterator could be accessible without initializing any parent.

Vincent



---

archive/issue_comments_239732.json:
```json
{
    "body": "> A main point being: unless we create millions of small IntegerListsLex\n> objects, I don't see why having it be a (facade) parent makes things\n> slower.\n\nWouldn't this happen if somebody wants, for all `n` between 10 and 1000, one instance of a partition of `n` satisfying <a specific set of constraints> ?\n\nThere is a (trivial) case at least which makes sense to me, i.e. for a fixed `k` find some partition of `n` into integers between `floor(n/k)` and `ceil(n/k)`. I agree that this can be done manually without this iterator, but I expect that it can happen with more complicated set of constraints too.\n\nNathann",
    "created_at": "2015-04-30T11:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239732",
    "user": "@nathanncohen"
}
```

> A main point being: unless we create millions of small IntegerListsLex
> objects, I don't see why having it be a (facade) parent makes things
> slower.

Wouldn't this happen if somebody wants, for all `n` between 10 and 1000, one instance of a partition of `n` satisfying <a specific set of constraints> ?

There is a (trivial) case at least which makes sense to me, i.e. for a fixed `k` find some partition of `n` into integers between `floor(n/k)` and `ceil(n/k)`. I agree that this can be done manually without this iterator, but I expect that it can happen with more complicated set of constraints too.

Nathann



---

archive/issue_comments_239733.json:
```json
{
    "body": "Replying to [comment:47 vdelecroix]:\n> A use case is in `MatrixSpace.__iter__` and I also have others intensive usage for building so-called square tiled surfaces (if you care, look at `u/vdelecroix/flat_surfaces-6.5`). I would be grateful if the iterator could be accessible without initializing any parent.\n\nThanks for the feedback.\n\nDo you mind running a concrete benchmark in one of those situations, comparing a facade parent `IntegerListLex` and a non-parent `IntegerListsLex` as provided by this ticket? Then we coud evaluate on solid ground what the overhead actually is, and whether it's worth the additional complexity?",
    "created_at": "2015-04-30T12:41:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239733",
    "user": "@nthiery"
}
```

Replying to [comment:47 vdelecroix]:
> A use case is in `MatrixSpace.__iter__` and I also have others intensive usage for building so-called square tiled surfaces (if you care, look at `u/vdelecroix/flat_surfaces-6.5`). I would be grateful if the iterator could be accessible without initializing any parent.

Thanks for the feedback.

Do you mind running a concrete benchmark in one of those situations, comparing a facade parent `IntegerListLex` and a non-parent `IntegerListsLex` as provided by this ticket? Then we coud evaluate on solid ground what the overhead actually is, and whether it's worth the additional complexity?



---

archive/issue_comments_239734.json:
```json
{
    "body": "\n```\nsage: class A:\n....:     pass\n....: \nsage: class B(Parent):\n....:     pass\n....: \nsage: timeit(\"A()\")\n625 loops, best of 3: 413 ns per loop\nsage: timeit(\"B()\")\n625 loops, best of 3: 13.2 \u00b5s per loop\n```\n",
    "created_at": "2015-04-30T13:29:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239734",
    "user": "@videlec"
}
```


```
sage: class A:
....:     pass
....: 
sage: class B(Parent):
....:     pass
....: 
sage: timeit("A()")
625 loops, best of 3: 413 ns per loop
sage: timeit("B()")
625 loops, best of 3: 13.2 s per loop
```




---

archive/issue_comments_239735.json:
```json
{
    "body": "That's not a fair benchmark, since that's Python, not Cython. The real benchmark is this:\n\n```\nsage: cython(\"cdef class A(object): pass\")\nsage: cython(\"from sage.structure.parent cimport Parent\\ncdef class B(Parent): pass\")\nsage: timeit(\"A()\", number=10^4, repeat=20)\n10000 loops, best of 20: 68.9 ns per loop\nsage: timeit(\"B()\", number=10^4, repeat=20)\n10000 loops, best of 20: 14.5 \u00b5s per loop\n```\n",
    "created_at": "2015-04-30T13:54:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239735",
    "user": "@jdemeyer"
}
```

That's not a fair benchmark, since that's Python, not Cython. The real benchmark is this:

```
sage: cython("cdef class A(object): pass")
sage: cython("from sage.structure.parent cimport Parent\ncdef class B(Parent): pass")
sage: timeit("A()", number=10^4, repeat=20)
10000 loops, best of 20: 68.9 ns per loop
sage: timeit("B()", number=10^4, repeat=20)
10000 loops, best of 20: 14.5 s per loop
```




---

archive/issue_comments_239736.json:
```json
{
    "body": "Replying to [comment:51 jdemeyer]:\n> That's not a fair benchmark, since that's Python, not Cython. The real benchmark is this:\n> {{{\n> sage: cython(\"cdef class A(object): pass\")\n> sage: cython(\"from sage.structure.parent cimport Parent\\ncdef class B(Parent): pass\")\n> sage: timeit(\"A()\", number=10^4, repeat=20)\n> 10000 loops, best of 20: 68.9 ns per loop\n> sage: timeit(\"B()\", number=10^4, repeat=20)\n> 10000 loops, best of 20: 14.5 \u00b5s per loop\n> }}}\n\nThanks Vincent and Jeroen. For fairness, we should also initialize the\ncategory. Here it is:\n\n```\nsage: %timeit B()\nThe slowest run took 4.13 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 13.3 \u00b5s per loop\nsage: %timeit B(category=C)\nThe slowest run took 7.14 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 21.7 \u00b5s per loop\n```\n\n\nThose benchmarks teach us that constructing a `Parent` costs 200 times\nmore than an empty object. Not quite surprising, but it's a start. Now\nwhat I really had in mind was a benchmark in a real use case, to\nestimate what's the relative overhead in a typical situation.\n\nLet's take something really trivial:\n\n```\nsage: sage: %timeit IntegerListsLex(n=1, max_length=1).an_element()\nThe slowest run took 6.67 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 113 \u00b5s per loop\n```\n\n\nNow we start to have some concrete ground to start discussions: what\nwe are speaking about is an overhead of 13% in the case of the most\ntrivial operation. There probably is some room for improvements in the\ninitialization of `IntegerListsLex` objects; but not so much either:\nthere is some unavoidable option parsing and initialization work to\ndo. Similarly, there may be room for improvement in the initialization\nof a `Parent` (I am surprised that initializing the category is\ncostly, since for a Cython parent it does nothing but set an\nattribute). Altogether, the 13% has to be taken with a grain of salt\nat this point.\n\nFor additional insight, I believe we would be need to have some\ntypical concrete use case, like the one Vincent has for matrices or\nflat surfaces. And see, then, what's the actual overhead. With that,\nwe will be able to take an informed decision; not just out of fear\nthat \"parents are slow\".\n\nVincent, could you pickup such a situation and make a benchmark?\n\nIn general I would like to follow this rule of thumb for our\nenumerated sets:\n\n- On one hand, implement super optimized standalone iterators with\n  bare bone API, whenever there is a proven need for them.\n\n- On the other hand, when modeling an enumerated set, implement it as\n  a `Parent`s with nice input parsing and a full fledged API; and\n  typically using the above iterators under the hood.\n\n- Avoid half measures with iterables that are not `Parent`.\n\nHere the situation is a bit delicate since we are in between the\nshores: the iterator needs some non trivial parsing and internal\ndata. Which calls for an intermediate class handling the parsing and\nthe data storage; is this class meant to model the enumerated set\nitself or not?\n\n\nAll that being said, just make your call. I am fine with additional\ncomplexity when there is a proven and worthwhile need for it. And when\nsomeone is willing to pay for the maintenance overhead ...\n\nCheers,\n                              Nicolas",
    "created_at": "2015-04-30T21:20:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239736",
    "user": "@nthiery"
}
```

Replying to [comment:51 jdemeyer]:
> That's not a fair benchmark, since that's Python, not Cython. The real benchmark is this:
> {{{
> sage: cython("cdef class A(object): pass")
> sage: cython("from sage.structure.parent cimport Parent\ncdef class B(Parent): pass")
> sage: timeit("A()", number=10^4, repeat=20)
> 10000 loops, best of 20: 68.9 ns per loop
> sage: timeit("B()", number=10^4, repeat=20)
> 10000 loops, best of 20: 14.5 s per loop
> }}}

Thanks Vincent and Jeroen. For fairness, we should also initialize the
category. Here it is:

```
sage: %timeit B()
The slowest run took 4.13 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 13.3 s per loop
sage: %timeit B(category=C)
The slowest run took 7.14 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 21.7 s per loop
```


Those benchmarks teach us that constructing a `Parent` costs 200 times
more than an empty object. Not quite surprising, but it's a start. Now
what I really had in mind was a benchmark in a real use case, to
estimate what's the relative overhead in a typical situation.

Let's take something really trivial:

```
sage: sage: %timeit IntegerListsLex(n=1, max_length=1).an_element()
The slowest run took 6.67 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 113 s per loop
```


Now we start to have some concrete ground to start discussions: what
we are speaking about is an overhead of 13% in the case of the most
trivial operation. There probably is some room for improvements in the
initialization of `IntegerListsLex` objects; but not so much either:
there is some unavoidable option parsing and initialization work to
do. Similarly, there may be room for improvement in the initialization
of a `Parent` (I am surprised that initializing the category is
costly, since for a Cython parent it does nothing but set an
attribute). Altogether, the 13% has to be taken with a grain of salt
at this point.

For additional insight, I believe we would be need to have some
typical concrete use case, like the one Vincent has for matrices or
flat surfaces. And see, then, what's the actual overhead. With that,
we will be able to take an informed decision; not just out of fear
that "parents are slow".

Vincent, could you pickup such a situation and make a benchmark?

In general I would like to follow this rule of thumb for our
enumerated sets:

- On one hand, implement super optimized standalone iterators with
  bare bone API, whenever there is a proven need for them.

- On the other hand, when modeling an enumerated set, implement it as
  a `Parent`s with nice input parsing and a full fledged API; and
  typically using the above iterators under the hood.

- Avoid half measures with iterables that are not `Parent`.

Here the situation is a bit delicate since we are in between the
shores: the iterator needs some non trivial parsing and internal
data. Which calls for an intermediate class handling the parsing and
the data storage; is this class meant to model the enumerated set
itself or not?


All that being said, just make your call. I am fine with additional
complexity when there is a proven and worthwhile need for it. And when
someone is willing to pay for the maintenance overhead ...

Cheers,
                              Nicolas



---

archive/issue_comments_239737.json:
```json
{
    "body": "Replying to [comment:52 nthiery]:\n> In general I would like to follow this rule of thumb for our\n> enumerated sets:\n> \n> - On one hand, implement super optimized standalone iterators with\n>   bare bone API, whenever there is a proven need for them.\n> \n> - On the other hand, when modeling an enumerated set, implement it as\n>   a `Parent`s with nice input parsing and a full fledged API; and\n>   typically using the above iterators under the hood.\n> \n> - Avoid half measures with iterables that are not `Parent`.\n\nWhy do you think that the current implementation is a \"half measure\"? I would say it fits your \"super optimized standalone iterators with bare bone API\" (except that it's currently not yet super optimized, see #18055 and #18056).",
    "created_at": "2015-04-30T22:06:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239737",
    "user": "@jdemeyer"
}
```

Replying to [comment:52 nthiery]:
> In general I would like to follow this rule of thumb for our
> enumerated sets:
> 
> - On one hand, implement super optimized standalone iterators with
>   bare bone API, whenever there is a proven need for them.
> 
> - On the other hand, when modeling an enumerated set, implement it as
>   a `Parent`s with nice input parsing and a full fledged API; and
>   typically using the above iterators under the hood.
> 
> - Avoid half measures with iterables that are not `Parent`.

Why do you think that the current implementation is a "half measure"? I would say it fits your "super optimized standalone iterators with bare bone API" (except that it's currently not yet super optimized, see #18055 and #18056).



---

archive/issue_comments_239738.json:
```json
{
    "body": "Good morning Jeroen,\n\nReplying to [comment:53 jdemeyer]:\n> Why do you think that the current implementation is a \"half\n> measure\"? I would say it fits your \"super optimized standalone\n> iterators with bare bone API\" (except that it's currently not yet\n> super optimized, see #18055 and #18056).\n\nYes, I am very happy with the Cython iterator (and its upcoming\noptimizations) and the Parent enumerated sets (`IntegerLists*`). What\nI am wondering about are the intermediate classes\n(`IntegerLists*Impl`). What's their precise role? Do we really need\nthem?\n\n- Are there situations where an iterator is not enough (we really need\n  to model the enumerated set itself), yet we can't afford the\n  overhead of having a Parent?\n\nAnd / or\n\n- Are the *Impl just utility classes that are mandatory to construct\n  the iterator?\n\n\nMaybe we should have a short video conference at some point; it would\nbe much easier to discuss!",
    "created_at": "2015-05-01T06:30:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239738",
    "user": "@nthiery"
}
```

Good morning Jeroen,

Replying to [comment:53 jdemeyer]:
> Why do you think that the current implementation is a "half
> measure"? I would say it fits your "super optimized standalone
> iterators with bare bone API" (except that it's currently not yet
> super optimized, see #18055 and #18056).

Yes, I am very happy with the Cython iterator (and its upcoming
optimizations) and the Parent enumerated sets (`IntegerLists*`). What
I am wondering about are the intermediate classes
(`IntegerLists*Impl`). What's their precise role? Do we really need
them?

- Are there situations where an iterator is not enough (we really need
  to model the enumerated set itself), yet we can't afford the
  overhead of having a Parent?

And / or

- Are the *Impl just utility classes that are mandatory to construct
  the iterator?


Maybe we should have a short video conference at some point; it would
be much easier to discuss!



---

archive/issue_comments_239739.json:
```json
{
    "body": "Replying to [comment:54 nthiery]:\n> Yes, I am very happy with the Cython iterator (and its upcoming\n> optimizations) and the Parent enumerated sets (`IntegerLists*`). What\n> I am wondering about are the intermediate classes\n> (`IntegerLists*Impl`). What's their precise role?\n\nWell, I can see two main use cases:\n1. if you need to iterate twice over the same set.\n2. to check containment.\n\nIn the future, point counting could be added as an extra algorithm in the `Impl` class, not in the iterator.",
    "created_at": "2015-05-01T07:46:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239739",
    "user": "@jdemeyer"
}
```

Replying to [comment:54 nthiery]:
> Yes, I am very happy with the Cython iterator (and its upcoming
> optimizations) and the Parent enumerated sets (`IntegerLists*`). What
> I am wondering about are the intermediate classes
> (`IntegerLists*Impl`). What's their precise role?

Well, I can see two main use cases:
1. if you need to iterate twice over the same set.
2. to check containment.

In the future, point counting could be added as an extra algorithm in the `Impl` class, not in the iterator.



---

archive/issue_comments_239740.json:
```json
{
    "body": "Replying to [comment:44 nthiery]:\n> - At least, would there be a way to implement `XXX.__reduce__`\n>   to return `(XXX, *)` rather than having to implement an\n>   `unpickle_XXX` function each time?\nThat's not quite possible because of [https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34](https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34)",
    "created_at": "2015-05-04T11:27:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239740",
    "user": "@jdemeyer"
}
```

Replying to [comment:44 nthiery]:
> - At least, would there be a way to implement `XXX.__reduce__`
>   to return `(XXX, *)` rather than having to implement an
>   `unpickle_XXX` function each time?
That's not quite possible because of [https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34](https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34)



---

archive/issue_comments_239741.json:
```json
{
    "body": "> That's not quite possible because of [https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34](https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34)\n\n... which was also solved with an 'unpickle' function `T_T`",
    "created_at": "2015-05-04T11:33:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239741",
    "user": "@nathanncohen"
}
```

> That's not quite possible because of [https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34](https://groups.google.com/forum/#!topic/sage-devel/limDRGuep34)

... which was also solved with an 'unpickle' function `T_T`



---

archive/issue_comments_239742.json:
```json
{
    "body": "Actually, pickling can be implemented better using `__getstate__` and `__setstate__`.",
    "created_at": "2015-05-04T11:42:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239742",
    "user": "@jdemeyer"
}
```

Actually, pickling can be implemented better using `__getstate__` and `__setstate__`.



---

archive/issue_comments_239743.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-04T11:45:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239743",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239744.json:
```json
{
    "body": "For `Envelope`, this is harder since `__init__` really does some non-trivial stuff like the `sign` handling.",
    "created_at": "2015-05-04T11:49:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239744",
    "user": "@jdemeyer"
}
```

For `Envelope`, this is harder since `__init__` really does some non-trivial stuff like the `sign` handling.



---

archive/issue_comments_239745.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-04T12:01:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239745",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239746.json:
```json
{
    "body": "Replying to [comment:43 aschilling]:\n> One question I have though is about the comparison functions in `base.py` and `lists.py`. The tests look almost identical.\nRight, I fixed the tests.",
    "created_at": "2015-05-04T12:02:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239746",
    "user": "@jdemeyer"
}
```

Replying to [comment:43 aschilling]:
> One question I have though is about the comparison functions in `base.py` and `lists.py`. The tests look almost identical.
Right, I fixed the tests.



---

archive/issue_comments_239747.json:
```json
{
    "body": "Replying to [comment:44 nthiery]:\n> Maybe slightly more systematic class names could\n> help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,\n> `IntegerListsLexBackend`.\n\nDo you find `...Backend` more clear than `...Impl`? If you care a lot, I can change it, but it smells like bike-shedding.",
    "created_at": "2015-05-04T12:04:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239747",
    "user": "@jdemeyer"
}
```

Replying to [comment:44 nthiery]:
> Maybe slightly more systematic class names could
> help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,
> `IntegerListsLexBackend`.

Do you find `...Backend` more clear than `...Impl`? If you care a lot, I can change it, but it smells like bike-shedding.



---

archive/issue_comments_239748.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-04T12:11:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239748",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239749.json:
```json
{
    "body": "Replying to [comment:63 jdemeyer]:\n> Replying to [comment:44 nthiery]:\n> > Maybe slightly more systematic class names could\n> > help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,\n> > `IntegerListsLexBackend`.\n> \n> Do you find `...Backend` more clear than `...Impl`? If you care a lot, I can change it, but it smells like bike-shedding.\n\nI have a preference for `Backend` since we use this vocable elsewhere in Sage (e.g. in the graph library), but don't really care otherwise; you choose. My comment was more about having a consistent naming scheme. It could be enough to e.g. rename `IntegerListsImpl_invlex` to `IntegerListsLexImpl`.\n\nThanks by the way for investigating how to better do the pickling!",
    "created_at": "2015-05-04T12:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239749",
    "user": "@nthiery"
}
```

Replying to [comment:63 jdemeyer]:
> Replying to [comment:44 nthiery]:
> > Maybe slightly more systematic class names could
> > help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,
> > `IntegerListsLexBackend`.
> 
> Do you find `...Backend` more clear than `...Impl`? If you care a lot, I can change it, but it smells like bike-shedding.

I have a preference for `Backend` since we use this vocable elsewhere in Sage (e.g. in the graph library), but don't really care otherwise; you choose. My comment was more about having a consistent naming scheme. It could be enough to e.g. rename `IntegerListsImpl_invlex` to `IntegerListsLexImpl`.

Thanks by the way for investigating how to better do the pickling!



---

archive/issue_comments_239750.json:
```json
{
    "body": "Replying to [comment:65 nthiery]:\n> Replying to [comment:63 jdemeyer]:\n> > Replying to [comment:44 nthiery]:\n> > > Maybe slightly more systematic class names could\n> > > help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,\n> > > `IntegerListsLexBackend`.\n> > \n> > Do you find `...Backend` more clear than `...Impl`? If you care a lot, I can change it, but it smells like bike-shedding.\n> \n> I have a preference for `Backend` since we use this vocable elsewhere in Sage (e.g. in the graph library), but don't really care otherwise; you choose. My comment was more about having a consistent naming scheme. It could be enough to e.g. rename `IntegerListsImpl_invlex` to `IntegerListsLexImpl`.\nWell, I actually prefer `IntegerListsImpl_invlex` over `IntegerListsLexImpl`.\n\nI *intentionally* do not want `IntegerListsImpl_invlex` to be associated too much with `IntegerListsLex`: people should not think that there must be a 1-to-1 correspondence between `IntegerLists` classes and `IntegerListsImpl` classes.",
    "created_at": "2015-05-04T12:55:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239750",
    "user": "@jdemeyer"
}
```

Replying to [comment:65 nthiery]:
> Replying to [comment:63 jdemeyer]:
> > Replying to [comment:44 nthiery]:
> > > Maybe slightly more systematic class names could
> > > help; say: `IntegerLists`, `IntegerListsLex`, `IntegerListsBackend`,
> > > `IntegerListsLexBackend`.
> > 
> > Do you find `...Backend` more clear than `...Impl`? If you care a lot, I can change it, but it smells like bike-shedding.
> 
> I have a preference for `Backend` since we use this vocable elsewhere in Sage (e.g. in the graph library), but don't really care otherwise; you choose. My comment was more about having a consistent naming scheme. It could be enough to e.g. rename `IntegerListsImpl_invlex` to `IntegerListsLexImpl`.
Well, I actually prefer `IntegerListsImpl_invlex` over `IntegerListsLexImpl`.

I *intentionally* do not want `IntegerListsImpl_invlex` to be associated too much with `IntegerListsLex`: people should not think that there must be a 1-to-1 correspondence between `IntegerLists` classes and `IntegerListsImpl` classes.



---

archive/issue_comments_239751.json:
```json
{
    "body": "After replacing `Impl` by `Backend`:\n\n```\nError compiling Cython file:\n------------------------------------------------------------\n...\n        IntegerListsBackend.__init__(self, *args, **kwds)\n\n        self.check = check\n\n        if self.min_part < 0:\n            raise NotBackendementedError(\"strictly negative min_part\")\n                                       ^\n------------------------------------------------------------\n\nsage/combinat/integer_lists/invlex.pyx:848:40: undeclared name not builtin: NotBackendementedError\n```\n",
    "created_at": "2015-05-04T12:58:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239751",
    "user": "@jdemeyer"
}
```

After replacing `Impl` by `Backend`:

```
Error compiling Cython file:
------------------------------------------------------------
...
        IntegerListsBackend.__init__(self, *args, **kwds)

        self.check = check

        if self.min_part < 0:
            raise NotBackendementedError("strictly negative min_part")
                                       ^
------------------------------------------------------------

sage/combinat/integer_lists/invlex.pyx:848:40: undeclared name not builtin: NotBackendementedError
```




---

archive/issue_comments_239752.json:
```json
{
    "body": "What is your strategy, defining `NotBackendementedError`?",
    "created_at": "2015-05-04T13:01:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239752",
    "user": "@videlec"
}
```

What is your strategy, defining `NotBackendementedError`?



---

archive/issue_comments_239753.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-04T13:13:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239753",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239754.json:
```json
{
    "body": "Replying to [comment:66 jdemeyer]:\n> Well, I actually prefer `IntegerListsImpl_invlex` over `IntegerListsLexImpl`.\n> \n> I *intentionally* do not want `IntegerListsImpl_invlex` to be associated too much with `IntegerListsLex`: people should not think that there must be a 1-to-1 correspondence between `IntegerLists` classes and `IntegerListsImpl` classes.\n\nI see your point. Still I find useful to give the reader a hint that,\nin this case, there is such a correspondence.  When reading the code,\nI had to dig around to make sure I was getting it right.\n\nSo I'd rather have a consistent naming scheme, and a note to the\ndevelopers, in the overview documentation of the module, that there\nneed not be in general such a 1-to-1 correspondence.\n\nCheers,\n                             Nicolas\n\nPS: fun error message :-)",
    "created_at": "2015-05-04T14:00:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239754",
    "user": "@nthiery"
}
```

Replying to [comment:66 jdemeyer]:
> Well, I actually prefer `IntegerListsImpl_invlex` over `IntegerListsLexImpl`.
> 
> I *intentionally* do not want `IntegerListsImpl_invlex` to be associated too much with `IntegerListsLex`: people should not think that there must be a 1-to-1 correspondence between `IntegerLists` classes and `IntegerListsImpl` classes.

I see your point. Still I find useful to give the reader a hint that,
in this case, there is such a correspondence.  When reading the code,
I had to dig around to make sure I was getting it right.

So I'd rather have a consistent naming scheme, and a note to the
developers, in the overview documentation of the module, that there
need not be in general such a 1-to-1 correspondence.

Cheers,
                             Nicolas

PS: fun error message :-)



---

archive/issue_comments_239755.json:
```json
{
    "body": "Replying to [comment:70 nthiery]:\n> I see your point. Still I find useful to give the reader a hint that,\n> in this case, there is such a correspondence.\nThere is not, even in this case. Note that `IntegerListsLex` is just `IntegerLists` with a classcall method and a default backend. I can easily create an `IntegerLists` instance with a `IntegerListsBackend_invlex` backend or an `IntegerListsLex` instance with a different backend.",
    "created_at": "2015-05-04T17:35:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239755",
    "user": "@jdemeyer"
}
```

Replying to [comment:70 nthiery]:
> I see your point. Still I find useful to give the reader a hint that,
> in this case, there is such a correspondence.
There is not, even in this case. Note that `IntegerListsLex` is just `IntegerLists` with a classcall method and a default backend. I can easily create an `IntegerLists` instance with a `IntegerListsBackend_invlex` backend or an `IntegerListsLex` instance with a different backend.



---

archive/issue_comments_239756.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-04T18:03:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239756",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239757.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-04T18:54:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239757",
    "user": "@fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_239758.json:
```json
{
    "body": "needs rebase, does not apply",
    "created_at": "2015-08-04T18:54:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239758",
    "user": "@fchapoton"
}
```

needs rebase, does not apply



---

archive/issue_comments_239759.json:
```json
{
    "body": "Do you have an intention to review the ticket once I rebase it? I'm just asking since there is no point in rebasing if it just continues to bitrot.",
    "created_at": "2015-08-09T20:43:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239759",
    "user": "@jdemeyer"
}
```

Do you have an intention to review the ticket once I rebase it? I'm just asking since there is no point in rebasing if it just continues to bitrot.



---

archive/issue_comments_239760.json:
```json
{
    "body": "Thanks for asking. The review is on my todo list for the last week of August.",
    "created_at": "2015-08-10T06:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239760",
    "user": "@nthiery"
}
```

Thanks for asking. The review is on my todo list for the last week of August.



---

archive/issue_comments_239761.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-08-27T08:33:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239761",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239762.json:
```json
{
    "body": "Rebased and squashed, testing now...",
    "created_at": "2015-08-27T08:35:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239762",
    "user": "@jdemeyer"
}
```

Rebased and squashed, testing now...



---

archive/issue_comments_239763.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-27T11:07:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239763",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239764.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-27T12:50:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239764",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239765.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-27T12:50:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239765",
    "user": "@jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_239766.json:
```json
{
    "body": "Merge conflict.",
    "created_at": "2015-10-11T19:29:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239766",
    "user": "@kevindilks"
}
```

Merge conflict.



---

archive/issue_comments_239767.json:
```json
{
    "body": "Do you actually plan to review this ticket? If you do, then I'll rebase immediately.",
    "created_at": "2015-10-11T20:04:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239767",
    "user": "@jdemeyer"
}
```

Do you actually plan to review this ticket? If you do, then I'll rebase immediately.



---

archive/issue_comments_239768.json:
```json
{
    "body": "I will review this ticket once rebased.",
    "created_at": "2015-10-11T20:07:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239768",
    "user": "@tscrim"
}
```

I will review this ticket once rebased.



---

archive/issue_comments_239769.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-11T21:17:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239769",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239770.json:
```json
{
    "body": "I made some doc tweaks while we are moving everything around. Everything works and since we aren't actually changing the functionality, I'm not looking at that closely. In short, it looks goods.\n\nIn writing this comment, I've convinced myself that having a frontend class for each backend will likely be a good thing in practice as it can be used to distinguish different iteration orders without having to look at the backend (which may not be python visible at the end of the day). It also makes it easier to define string representations and natural extensions to subclasses.\n\nIn particular, #15525, which we will probably need to tweak some of those changes to support this new framework (and at least correct the imports, which is why I listed it as a dependency).\n----\nNew commits:",
    "created_at": "2015-10-12T04:12:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239770",
    "user": "@tscrim"
}
```

I made some doc tweaks while we are moving everything around. Everything works and since we aren't actually changing the functionality, I'm not looking at that closely. In short, it looks goods.

In writing this comment, I've convinced myself that having a frontend class for each backend will likely be a good thing in practice as it can be used to distinguish different iteration orders without having to look at the backend (which may not be python visible at the end of the day). It also makes it easier to define string representations and natural extensions to subclasses.

In particular, #15525, which we will probably need to tweak some of those changes to support this new framework (and at least correct the imports, which is why I listed it as a dependency).
----
New commits:



---

archive/issue_comments_239771.json:
```json
{
    "body": "Two details:\n\n1. `an set` should be `a set`\n\n2. Why this change? I find the old version more readable.\n\n```diff\n-        good_sum = (nu >= p.min_sum and nu <= p.max_sum)\n-        good_length = (l >= p.min_length and l <= p.max_length)\n-        no_trailing_zeros = (l <= max(p.min_length,0) or mu[-1] != 0)\n-        return good_sum and good_length and no_trailing_zeros\n+        return (nu >= p.min_sum and nu <= p.max_sum # Good sum\n+                 and l >= p.min_length and l <= p.max_length # Good length\n+                 and (l <= max(p.min_length,0) or mu[-1] != 0)) # No trailing zeros\n```\n\nIf this is for performance reasons, you can instead `cdef bint` the variables `good_sum`, `good_length` and `no_trailing_zeros`.",
    "created_at": "2015-10-12T08:04:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239771",
    "user": "@jdemeyer"
}
```

Two details:

1. `an set` should be `a set`

2. Why this change? I find the old version more readable.

```diff
-        good_sum = (nu >= p.min_sum and nu <= p.max_sum)
-        good_length = (l >= p.min_length and l <= p.max_length)
-        no_trailing_zeros = (l <= max(p.min_length,0) or mu[-1] != 0)
-        return good_sum and good_length and no_trailing_zeros
+        return (nu >= p.min_sum and nu <= p.max_sum # Good sum
+                 and l >= p.min_length and l <= p.max_length # Good length
+                 and (l <= max(p.min_length,0) or mu[-1] != 0)) # No trailing zeros
```

If this is for performance reasons, you can instead `cdef bint` the variables `good_sum`, `good_length` and `no_trailing_zeros`.



---

archive/issue_comments_239772.json:
```json
{
    "body": "Replying to [comment:85 tscrim]:\n> In writing this comment, I've convinced myself that having a frontend class for each backend will likely be a good thing in practice as it can be used to distinguish different iteration orders without having to look at the backend\n\nBut why would you need to \"distinguish different iteration orders\" in the first place?\n\nIn the few cases (maybe invlex is the only one?) where the iteration algorithm really matters, I understand that you want a separate front-end. However, it should be possible for a backend to iterate in an arbitrary order.\n\nI really want to see the front-end and back-end as orthogonal: I can see use cases for different front-ends with the same back-end and use cases for different back-ends for the same front-end.",
    "created_at": "2015-10-12T08:18:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239772",
    "user": "@jdemeyer"
}
```

Replying to [comment:85 tscrim]:
> In writing this comment, I've convinced myself that having a frontend class for each backend will likely be a good thing in practice as it can be used to distinguish different iteration orders without having to look at the backend

But why would you need to "distinguish different iteration orders" in the first place?

In the few cases (maybe invlex is the only one?) where the iteration algorithm really matters, I understand that you want a separate front-end. However, it should be possible for a backend to iterate in an arbitrary order.

I really want to see the front-end and back-end as orthogonal: I can see use cases for different front-ends with the same back-end and use cases for different back-ends for the same front-end.



---

archive/issue_comments_239773.json:
```json
{
    "body": "Replying to [comment:86 jdemeyer]:\n> Two details:\n> 2. Why this change? I find the old version more readable.\n> {{{\n> #!diff\n> -        good_sum = (nu >= p.min_sum and nu <= p.max_sum)\n> -        good_length = (l >= p.min_length and l <= p.max_length)\n> -        no_trailing_zeros = (l <= max(p.min_length,0) or mu[-1] != 0)\n> -        return good_sum and good_length and no_trailing_zeros\n> +        return (nu >= p.min_sum and nu <= p.max_sum # Good sum\n> +                 and l >= p.min_length and l <= p.max_length # Good length\n> +                 and (l <= max(p.min_length,0) or mu[-1] != 0)) # No trailing zeros\n> }}}\n> If this is for performance reasons, you can instead `cdef bint` the variables `good_sum`, `good_length` and `no_trailing_zeros`.\n\nIt was for performance reasonings, but not the reason you're thinking of: short circuiting.",
    "created_at": "2015-10-12T13:09:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239773",
    "user": "@tscrim"
}
```

Replying to [comment:86 jdemeyer]:
> Two details:
> 2. Why this change? I find the old version more readable.
> {{{
> #!diff
> -        good_sum = (nu >= p.min_sum and nu <= p.max_sum)
> -        good_length = (l >= p.min_length and l <= p.max_length)
> -        no_trailing_zeros = (l <= max(p.min_length,0) or mu[-1] != 0)
> -        return good_sum and good_length and no_trailing_zeros
> +        return (nu >= p.min_sum and nu <= p.max_sum # Good sum
> +                 and l >= p.min_length and l <= p.max_length # Good length
> +                 and (l <= max(p.min_length,0) or mu[-1] != 0)) # No trailing zeros
> }}}
> If this is for performance reasons, you can instead `cdef bint` the variables `good_sum`, `good_length` and `no_trailing_zeros`.

It was for performance reasonings, but not the reason you're thinking of: short circuiting.



---

archive/issue_comments_239774.json:
```json
{
    "body": "Replying to [comment:87 jdemeyer]:\n> Replying to [comment:85 tscrim]:\n> > In writing this comment, I've convinced myself that having a frontend class for each backend will likely be a good thing in practice as it can be used to distinguish different iteration orders without having to look at the backend\n> \n> But why would you need to \"distinguish different iteration orders\" in the first place?\n> \n> In the few cases (maybe invlex is the only one?) where the iteration algorithm really matters, I understand that you want a separate front-end. However, it should be possible for a backend to iterate in an arbitrary order.\n\nI don't need this flexibility, but it comes as an added bonus. Right now we can check backends explicitly, but this allows us to separate that off into a completely separate package and still retain a differentiation.\n\n> I really want to see the front-end and back-end as orthogonal: I can see use cases for different front-ends with the same back-end and use cases for different back-ends for the same front-end.\n\nI can see both use cases as well, but chances are there will be a coupling between base classes and backend. However I don't think it is really useful to continue this discussion because we both have our reasons for liking it. We just need to take care of the additions from #15525 (and the doc tweak above). Do you want me to do that (since that was my ticket) or will you?",
    "created_at": "2015-10-12T13:21:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239774",
    "user": "@tscrim"
}
```

Replying to [comment:87 jdemeyer]:
> Replying to [comment:85 tscrim]:
> > In writing this comment, I've convinced myself that having a frontend class for each backend will likely be a good thing in practice as it can be used to distinguish different iteration orders without having to look at the backend
> 
> But why would you need to "distinguish different iteration orders" in the first place?
> 
> In the few cases (maybe invlex is the only one?) where the iteration algorithm really matters, I understand that you want a separate front-end. However, it should be possible for a backend to iterate in an arbitrary order.

I don't need this flexibility, but it comes as an added bonus. Right now we can check backends explicitly, but this allows us to separate that off into a completely separate package and still retain a differentiation.

> I really want to see the front-end and back-end as orthogonal: I can see use cases for different front-ends with the same back-end and use cases for different back-ends for the same front-end.

I can see both use cases as well, but chances are there will be a coupling between base classes and backend. However I don't think it is really useful to continue this discussion because we both have our reasons for liking it. We just need to take care of the additions from #15525 (and the doc tweak above). Do you want me to do that (since that was my ticket) or will you?



---

archive/issue_comments_239775.json:
```json
{
    "body": "Replying to [comment:89 tscrim]:\n> Do you want me to do that (since that was my ticket) or will you?\n\nGo ahead. But please don't rewrite history, just merge #15525 and add extra commits.",
    "created_at": "2015-10-12T13:44:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239775",
    "user": "@jdemeyer"
}
```

Replying to [comment:89 tscrim]:
> Do you want me to do that (since that was my ticket) or will you?

Go ahead. But please don't rewrite history, just merge #15525 and add extra commits.



---

archive/issue_comments_239776.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-12T14:53:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239776",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239777.json:
```json
{
    "body": "Replying to [comment:90 jdemeyer]:\n> Replying to [comment:89 tscrim]:\n> > Do you want me to do that (since that was my ticket) or will you?\n> \n> Go ahead. But please don't rewrite history, just merge #15525 and add extra commits.\n\nDone. So if you're okay with my changes, then we can set a positive review.",
    "created_at": "2015-10-12T15:01:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239777",
    "user": "@tscrim"
}
```

Replying to [comment:90 jdemeyer]:
> Replying to [comment:89 tscrim]:
> > Do you want me to do that (since that was my ticket) or will you?
> 
> Go ahead. But please don't rewrite history, just merge #15525 and add extra commits.

Done. So if you're okay with my changes, then we can set a positive review.



---

archive/issue_comments_239778.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-10-13T06:41:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239778",
    "user": "@jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_239779.json:
```json
{
    "body": "Doctests fail, try with the next beta",
    "created_at": "2015-10-14T09:24:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239779",
    "user": "@vbraun"
}
```

Doctests fail, try with the next beta



---

archive/issue_comments_239780.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2015-10-14T09:24:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239780",
    "user": "@vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_239781.json:
```json
{
    "body": "I'm testing this now...\n----\nNew commits:",
    "created_at": "2015-10-16T11:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239781",
    "user": "@jdemeyer"
}
```

I'm testing this now...
----
New commits:



---

archive/issue_comments_239782.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-16T13:16:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239782",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_239783.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-10-16T13:25:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239783",
    "user": "@jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_239784.json:
```json
{
    "body": "LGTM.",
    "created_at": "2015-10-16T18:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239784",
    "user": "@tscrim"
}
```

LGTM.



---

archive/issue_comments_239785.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-10-16T18:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239785",
    "user": "@tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_239786.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-10-17T08:36:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17872",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17872#issuecomment-239786",
    "user": "@vbraun"
}
```

Resolution: fixed
