# Issue 26017: No signature shown in help for cythonized built-in methods

Issue created by migration from Trac.

Original creator: klee

Original creation time: 2018-09-11 23:50:24

CC:  jdemeyer tscrim mkoeppe

In requests for help for cythonized built-in methods, the signature of the method is not shown, unlike normal python methods.  For an example,

```
sage: a=17 
sage: a.quo_rem?

Docstring:     
   Returns the quotient and the remainder of self divided by other.
   Note that the remainder returned is always either zero or of the
   same sign as other.

   INPUT:

   * "other" - the divisor

   OUTPUT:

   * "q" - the quotient of self/other

   * "r" - the remainder of self/other

   EXAMPLES:

      sage: z = Integer(231)
      sage: z.quo_rem(2)
      (115, 1)
...
```


Simon:

> There is `sage_getargspec`, which is supposed to find the signature 
> of *all* functions/methods in Sage. If it doesn't, I believe it's a bug. 
> And in the example, it does: 

```
  sage: from sage.misc.sageinspect import sage_getargspec 
  sage: a = 17 
  sage: sage_getargspec(a.quo_rem) 
  ArgSpec(args=['self', 'other'], varargs=None, keywords=None, defaults=None) 
```

>Actually I thought that `?` and `??` would use `sage.misc.sageinspect` 
>rather than Python's "`inspect`" module, and I am surprised that 
>apparently it doesn't. 

>In addition there are certain special methods (`_sage_doc_` 
>and so on) that are used in `sage_inspect`, IIRC, so that wrappers such as 
>``@`cached_method` can forward the signature of the method being wrapped. 

Erik:

>It still won't work, say, 
>for the built-in methods written in pure C, but there are few (if 
>any?) of those in Sage itself. 

Related tickets: #19100, #20860, #18192


---

Comment by klee created at 2018-10-12 08:00:52

It seems this file

https://github.com/ipython/ipython/blob/master/IPython/core/oinspect.py

is responsible for this issue. For me, it would take some time to scrutinize what this does though.


---

Comment by klee created at 2018-10-13 03:41:41

A fix is to redefine `IPython.core.oinspect.getargspec` to use `sage.misc.sageinspect.sage_getargspec`


---

Comment by klee created at 2018-10-15 04:47:12

Replying to [comment:2 klee]:
> A fix is to redefine `IPython.core.oinspect.getargspec` to use `sage.misc.sageinspect.sage_getargspec`

This is already done in `sage.repl.ipython_extension.init_inspector`.  But apparently with no effect, strangely.


---

Comment by klee created at 2018-10-15 07:13:47

It turns out that the problem is with `IPython.core.oinspect.inspector._get_def`, which calls Python's `inspect.signature` via `IPython.utils.signatures` module. 

This problem is nothing to do with `sage_getargspec`.


---

Comment by klee created at 2018-10-15 07:28:31

We may just wait for future sage based on Python 3 with `inspect.signature` supporting cython.


---

Comment by jhpalmieri created at 2019-07-22 00:44:27

I don't see the signature in a Python 3 build of Sage, either.


---

Comment by klee created at 2019-07-22 01:08:42

Replying to [comment:7 jhpalmieri]:
> I don't see the signature in a Python 3 build of Sage, either.

Right. 

I don't remember exactly what I meant in my last comment. Perhaps I expected Cython someday support the new signature module shipped with Python 3. Now I don't have any clear idea what should be done on what side.


---

Comment by klee created at 2019-07-22 08:22:06

New commits:


---

Comment by klee created at 2019-07-22 08:26:07

Based on this discussion:

https://stackoverflow.com/questions/46033277/how-to-introspect-a-function-defined-in-a-cython-c-extension-module

and  consulting:

https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiler-directives

I made the last commit. Please checkout and try.


---

Comment by klee created at 2019-07-22 08:27:38

Changing status from new to needs_info.


---

Comment by klee created at 2019-07-22 10:32:04

Changing status from needs_info to needs_review.


---

Comment by dimpase created at 2019-07-22 15:48:48

With your patch I get a bunch of doctest errors, of the kind

```
sage -t --warn-long 55.8 src/sage/graphs/strongly_regular_db.pyx
**********************************************************************
File "src/sage/graphs/strongly_regular_db.pyx", line 1156, in sage.graphs.strongly_regular_db.is_RSHCD
Failed example:
    t = is_RSHCD(64,27,10,12); t
Expected:
    [<built-in function SRG_from_RSHCD>, 64, 27, 10, 12]
Got:
    [<cyfunction SRG_from_RSHCD at 0x7f8616d09890>, 64, 27, 10, 12]
**********************************************************************
```



```
sage -t --warn-long 55.8 src/sage/misc/latex.py
**********************************************************************
File "src/sage/misc/latex.py", line 561, in sage.misc.latex.has_latex_attr
Failed example:
    T._latex_()
Expected:
    Traceback (most recent call last):
    ...
    TypeError: descriptor '_latex_' of 'sage.matrix.matrix0.Matrix' object needs an argument
Got:
    <BLANKLINE>
    Traceback (most recent call last):
      File "/home/scratch2/dimpase/sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/scratch2/dimpase/sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1105, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.misc.latex.has_latex_attr[5]>", line 1, in <module>
        T._latex_()
    TypeError: unbound method cython_function_or_method object must be called with Matrix_integer_dense instance as first argument (got nothing instead)
```


--- this is of course not a surpise, but it needs to be fixed on this ticket.

Otherwise, I like it - e.g. notice how much more informative the error messages are.


---

Comment by nbruin created at 2019-07-22 18:48:22

This comes with the penalty of producing a wrapped object every time a method is accessed on a cython object. I suspect cythonized access avoids that, so it may be that in most scenarios this doesn't come with a performance penalty, but one should check carefully that sage doesn't rely on the situations where it does.

Also, there is a reason why `cython.binding==False` by default: that's the behaviour built-in methods exhibit: `[].insert` returns a `built-in method insert of list object ...` rather than a `bound method`, and cython by default does the same. If you want more informative tracemacks, wouldn't it be better to solve it in such a way that straight-up CPython (and its C extension classes; of which cython is a special case) also benefit?


---

Comment by klee created at 2019-07-23 01:10:27

Replying to [comment:14 nbruin]:
> This comes with the penalty of producing a wrapped object every time a method is accessed on a cython object. I suspect cythonized access avoids that, so it may be that in most scenarios this doesn't come with a performance penalty, but one should check carefully that sage doesn't rely on the situations where it does.
> 
> Also, there is a reason why `cython.binding==False` by default: that's the behaviour built-in methods exhibit: `[].insert` returns a `built-in method insert of list object ...` rather than a `bound method`, and cython by default does the same. 

`[].insert?` shows correct signature. So built-in methods can behave well with respect to introspection. Then why cythonized built-in methods do not? How can we make cythonized built-in methos behave well like standard built-in methods of python?


---

Comment by klee created at 2019-07-23 05:32:03

> `[].insert?` shows correct signature. So built-in methods can behave well with respect to introspection. Then why cythonized built-in methods do not? How can we make cythonized built-in methods behave well like standard built-in methods of python?   

An answer can be found here:

https://stackoverflow.com/questions/1104823/python-c-extension-method-signatures-for-documentation/1104893

and

https://docs.python.org/3/howto/clinic.html

Now it seems to me that cython should do a better job in making cythonized built-ins more introspectable.


---

Comment by klee created at 2019-07-26 04:36:25

To summarize the current situation,  there are two options:

Option 1: We accept the current patch, which turns on cython directive "binding=True" so that all cythonized methods become bound methods that already support the inspect.signature module well. If we take this path, then there is nothing for us to do except fixing a few doctests.

Option 2: We wait for upstream cython fixes that will make all cythonized built-in methods properly support the inspect.signature module. This is the path that standard built-in methods follow. We don't know when the upstream fix would be available. 

Please give your preference and why.


---

Comment by klee created at 2019-07-26 06:08:59

Changing status from needs_review to needs_info.


---

Comment by dimpase created at 2019-07-26 07:42:32

To go with option 1, we need benchmarking results on whether it affects the performance a lot.


---

Comment by klee created at 2019-07-26 09:06:36

Replying to [comment:19 dimpase]:
> To go with option 1, we need benchmarking results on whether it affects the performance a lot.

If it affects any bit of the runtime performance in other aspect than introspection, then option 1 should be discarded. I think this should be decided not by experiments but analysis of how python and cython works.


---

Comment by dimpase created at 2019-07-26 09:09:11

We can configure this in build time, to begin with. It is helpful for debugging - I would not care about  a 5% or 15% performance hit, if error messages made more sense.


---

Comment by SimonKing created at 2019-07-28 10:08:20

Replying to [comment:21 dimpase]:
> We can configure this in build time, to begin with. It is helpful for debugging - I would not care about  a 5% or 15% performance hit, if error messages made more sense.

I would.


---

Comment by embray created at 2019-08-13 11:09:51

This is what Jeroen has been working on for like, literally the last year, perhaps longer :)

Yes, the solution is to use binding=True to enable use of cyfunctions.  However, using cyfunctions across the board can introduce a significant performance penalty in many cases, as the Python interpreter has some built-in optimizations for built-in functions that don't work for cyfunctions.

Jeroen has been fighting for a series of PEPs that would overhaul Python's function type hierarchy in such a way that the basic `function` type can be extended (e.g. as with Cython's `cyfunction`) while still keeping those optimizations working.

So while this seems like it should be an easy problem to solve, it's completely non-trivial.

Point being, let's not duplicate effort here.


---

Comment by klee created at 2019-08-13 12:00:57

Replying to [comment:23 embray]:
> Point being, let's not duplicate effort here.

Thanks for the expert advice.


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-05-01 04:28:42

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.


---

Comment by klee created at 2020-06-23 08:11:51

Replying to [comment:23 embray]:
> This is what Jeroen has been working on for like, literally the last year, perhaps longer :)

> Jeroen has been fighting for a series of PEPs that would overhaul Python's function type hierarchy in such a way that the basic `function` type can be extended (e.g. as with Cython's `cyfunction`) while still keeping those optimizations working.

I searched for these PEPs, and reached to

- PEP 590: https://www.python.org/dev/peps/pep-0590/

- PEP 579: https://www.python.org/dev/peps/pep-0579/

I am curious if and how theses PEPs would eventually solve the problem of this ticket. I only guess that after the PEPs made into CPython, Cython is updated to use the new CPython features, and then the signature issue in Sage is automatically fixed. Am I right?


---

Comment by mkoeppe created at 2020-08-07 17:42:46

It would be interesting to know whether the upcoming Cython 3 (#29863) has improvements in this direction


---

Comment by embray created at 2020-08-31 16:29:07

Replying to [comment:27 klee]:
> Replying to [comment:23 embray]:
> > This is what Jeroen has been working on for like, literally the last year, perhaps longer :)
> 
> > Jeroen has been fighting for a series of PEPs that would overhaul Python's function type hierarchy in such a way that the basic `function` type can be extended (e.g. as with Cython's `cyfunction`) while still keeping those optimizations working.
> 
> I searched for these PEPs, and reached to
> 
> - PEP 590: https://www.python.org/dev/peps/pep-0590/
> 
> - PEP 579: https://www.python.org/dev/peps/pep-0579/
> 
> I am curious if and how theses PEPs would eventually solve the problem of this ticket. I only guess that after the PEPs made into CPython, Cython is updated to use the new CPython features, and then the signature issue in Sage is automatically fixed. Am I right?

That's correct--this would allow us to use Cython's own `function` subclass, which includes support for better signature documentation among other things, without losing any performance.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2021-09-06 01:08:48

`binding=True` will be the default in Cython 3 (https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiler-directives), so eventually we will make this switch anyway; so why not now.


---

Comment by git created at 2021-09-06 01:12:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2021-09-06 01:12:38

Changing status from needs_info to needs_review.


---

Comment by mkoeppe created at 2021-09-06 01:13:00

Rebased on 9.5.beta0


---

Comment by mkoeppe created at 2021-09-06 01:16:11

I have set it to "needs review" so that the patchbot runs on it.


---

Comment by mkoeppe created at 2021-09-07 09:04:57

The old ticket #22747 attempted to use `binding` as well


---

Comment by jhpalmieri created at 2021-09-07 15:53:04

Are there performance penalties for doing this, perhaps that Cython 3 is going to address?


---

Comment by git created at 2021-09-08 01:07:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-09-08 04:23:36

Replying to [comment:40 jhpalmieri]:
> Are there performance penalties for doing this...?

How can we see the performance penalty?


---

Comment by jhpalmieri created at 2021-09-08 04:47:23

Replying to [comment:42 klee]:
> Replying to [comment:40 jhpalmieri]:
> > Are there performance penalties for doing this...?
> 
> How can we see the performance penalty?

Try builds with and without and compare some timings?


---

Comment by klee created at 2021-09-08 04:53:04

Replying to [comment:43 jhpalmieri]:
> Replying to [comment:42 klee]:
> > Replying to [comment:40 jhpalmieri]:
> > > Are there performance penalties for doing this...?
> > 
> > How can we see the performance penalty?
> 
> Try builds with and without and compare some timings?

I tried a very simple script like: `timeit('a=17;a.quo_rem(5); del a')`, and find no difference.

I wonder what is a proper way to see the difference...


---

Comment by mkoeppe created at 2021-09-13 19:37:56

Changing status from needs_review to needs_info.


---

Comment by jhpalmieri created at 2021-09-13 21:57:38

Replying to [comment:44 klee]:
> Replying to [comment:43 jhpalmieri]:
> > Replying to [comment:42 klee]:
> > > Replying to [comment:40 jhpalmieri]:
> > > > Are there performance penalties for doing this...?
> > > 
> > > How can we see the performance penalty?
> > 
> > Try builds with and without and compare some timings?
> 
> I tried a very simple script like: `timeit('a=17;a.quo_rem(5); del a')`, and find no difference.
> 
> I wonder what is a proper way to see the difference...

I ran `./sage -t --long src/sage/matrix/*.pyx` a few times:

Develop: average time 83.3 seconds.

This ticket: average time 93.1 seconds.

I also tried `./sage -t --long src/sage/matrix/matrix_gfpn_dense.pyx` a few times:

Develop: average time 28.4 seconds

This ticket: average time 37.0 seconds


---

Comment by jhpalmieri created at 2021-09-13 21:58:39

Some other files in `matrix` showed very little difference, so maybe the slowdown only occurs in certain types of operations.


---

Comment by nbruin created at 2021-11-20 23:00:42

From:

https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html


```
... When enabled, functions will bind to an instance when looked up as a class attribute
```


I don't know what triggers the binding behaviour, but I imagine there may be a code path that runs into this and perhaps ends up not binding anyway (thus creating overhead) or ends up binding in a way that was previously done in a more efficient way (cached perhaps?)

The timings above show the impact can be quite significant: I think too high a penalty to incur in general. Note that the documentation also says:


```
Changed in version 3.0.0: Default changed from False to True
```


so figuring out what's causing the slowdown is a prereq to upgrading to 3.0.0 (once that finally is released). If there's a particular scenario where it's bad to have binding, we might just be able to turn it off in those cases.


---

Comment by @tobiasdiez created at 2022-01-08 12:40:45

What's the status here? The performance issues don't seem to be too bad, especially since they apparently only affect certain functions/modules.

Binding=true is also required for #30884 since the decorator library internally uses inspection on the decorated function. So if one wants to decorate cython functions, then they have to be "bound".


---

Comment by klee created at 2022-01-10 00:35:01

Replying to [comment:50 gh-tobiasdiez]:
> What's the status here? The performance issues don't seem to be too bad, especially since they apparently only affect certain functions/modules.

I agree with comment:48. The penalty seems significant to me. We need to know how much damage we would get and where, and to see if there is a way to reduce the damage.


---

Comment by git created at 2022-03-20 17:27:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-03-20 21:48:08

After merging the latest dev branch, this now throws

```
File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/all_cmdline.py", line 19, in <module>
    from sage.all import *
  File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/all.py", line 135, in <module>
    from sage.symbolic.all   import *
  File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/symbolic/all.py", line 8, in <module>
    import sage.symbolic.expression  # initialize pynac before .ring
  File "sage/symbolic/expression.pyx", line 1, in init sage.symbolic.expression
    # -*- coding: utf-8 -*-
  File "sage/symbolic/function.pyx", line 144, in init sage.symbolic.function
    from .expression import (
ImportError: cannot import name call_registered_function
```

when importing `sage.all`, see eg github build workflow. Any idea on how to fix it?

This method was introduced in #32386 (or one of its dependencies).


---

Comment by git created at 2022-04-02 11:45:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-04-02 15:24:33

I tried to investigate this is a bit, but didn't get far.

With bindings=true, the `expression.cpp` file contains the new lines


```
...
static PyMethodDef __pyx_mdef_4sage_8symbolic_10expression_121call_registered_function = {"call_registered_function", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_121call_registered_function, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_120call_registered_function};
....
static PyMethodDef __pyx_mdef_4sage_8symbolic_10expression_123find_registered_function = {"find_registered_function", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_123find_registered_function, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_122find_registered_function};
....
```


However, it no longer contains

```
static PyMethodDef __pyx_methods[] = {
  {"is_Expression", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_79is_Expression, METH_O, __pyx_doc_4sage_8symbolic_10expression_78is_Expression},
  {"is_SymbolicEquation", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_81is_SymbolicEquation, METH_O, __pyx_doc_4sage_8symbolic_10expression_80is_SymbolicEquation},
  {"_is_SymbolicVariable", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_83_is_SymbolicVariable, METH_O, __pyx_doc_4sage_8symbolic_10expression_82_is_SymbolicVariable},
  {"_repr_Expression", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_91_repr_Expression, METH_O, __pyx_doc_4sage_8symbolic_10expression_90_repr_Expression},
  {"_latex_Expression", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_93_latex_Expression, METH_O, __pyx_doc_4sage_8symbolic_10expression_92_latex_Expression},
  {"new_Expression", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_99new_Expression, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_98new_Expression},
  {"new_Expression_from_pyobject", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_101new_Expression_from_pyobject, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_100new_Expression_from_pyobject},
  {"new_Expression_wild", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_103new_Expression_wild, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_102new_Expression_wild},
  {"new_Expression_symbol", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_105new_Expression_symbol, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_104new_Expression_symbol},
  {"print_order", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_107print_order, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_106print_order},
  {"print_sorted", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_109print_sorted, METH_O, __pyx_doc_4sage_8symbolic_10expression_108print_sorted},
  {"math_sorted", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_111math_sorted, METH_O, __pyx_doc_4sage_8symbolic_10expression_110math_sorted},
  {"mixed_order", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_113mixed_order, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_112mixed_order},
  {"mixed_sorted", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_115mixed_sorted, METH_O, __pyx_doc_4sage_8symbolic_10expression_114mixed_sorted},
  {"call_registered_function", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_121call_registered_function, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_120call_registered_function},
  {"find_registered_function", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_123find_registered_function, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_122find_registered_function},
  {"register_or_update_function", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_4sage_8symbolic_10expression_125register_or_update_function, METH_VARARGS|METH_KEYWORDS, __pyx_doc_4sage_8symbolic_10expression_124register_or_update_function},
  {"get_sfunction_from_serial", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_127get_sfunction_from_serial, METH_O, __pyx_doc_4sage_8symbolic_10expression_126get_sfunction_from_serial},
  {"get_sfunction_from_hash", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_129get_sfunction_from_hash, METH_O, __pyx_doc_4sage_8symbolic_10expression_128get_sfunction_from_hash},
  {"make_map", (PyCFunction)__pyx_pw_4sage_8symbolic_10expression_131make_map, METH_O, __pyx_doc_4sage_8symbolic_10expression_130make_map},
  {0, 0, 0, 0}
};
```

which are present with `bindings=false`. 
Maybe its related to https://github.com/cython/cython/issues/1658.

After replacing `expression.cpp` with the one from `develop` everything seems to work fine.

Does anyone has an idea how to properly fix this? I tried setting `bindings=false` for `expression.pyx`, but then the compilation doesn't succeed anymore.


---

Comment by @tobiasdiez created at 2022-04-02 15:25:14

I took a few doctest runs as benchmarks, and could only find a very small negative impact (about 1%) if at all.

bindings=True

```
hyperfine -i --warmup 3 './sage -t --long src/sage/manifolds/differentiable/pseudo_riemannian.py' --show-output
  Time (mean ± σ):     13.183 s ±  0.266 s    [User: 14.732 s, System: 1.173 s]
  Range (min … max):   12.937 s … 13.730 s    10 runs

hyperfine -i --warmup 3 './sage -t --long src/sage/matrix/matrix0.pyx' --show-output
  Time (mean ± σ):      7.719 s ±  0.176 s    [User: 7.039 s, System: 0.918 s]
  Range (min … max):    7.472 s …  7.993 s    10 runs
```


develop

```
hyperfine -i --warmup 3 './sage -t --long src/sage/manifolds/differentiable/pseudo_riemannian.py' --show-output
  Time (mean ± σ):     13.096 s ±  0.199 s    [User: 14.618 s, System: 1.167 s]
  Range (min … max):   12.889 s … 13.524 s    10 runs

hyperfine -i --warmup 3 './sage -t --long src/sage/matrix/matrix0.pyx' --show-output
  Time (mean ± σ):      7.675 s ±  0.165 s    [User: 6.940 s, System: 0.970 s]
  Range (min … max):    7.364 s …  7.841 s    10 runs
```

(disclaimer: these were run on gitpod, so there is no guarantee that the same resources were available)


---

Comment by git created at 2022-05-01 11:41:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-01 11:43:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-07 14:39:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-07 14:40:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-05-07 14:41:46

This is now mostly working for me. A few doctests are still failing, mostly around cached functions and latex expressions. For some reason, some of the TypeErrors are now IndexErrors complaining that the index is out of bounds. Any idea where this is coming from?


---

Attachment

I tried to track down the source of the following errors:

```
      File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/repl/display/pretty_print.py", line 144, in pretty
        ok = representation(obj, self, cycle)
      File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/repl/display/fancy_repr.py", line 348, in __call__
        ascii_art_repr = ascii_art_repr or o.parent()._repr_option('element_ascii_art')
    IndexError: tuple index out of range
```


Debugging the following test script

```
import sage.all
from sage.combinat.root_system.cartan_type import CartanType
from sage.repl.rich_output import pretty_print


C = CartanType(["A", 3, 1])


class MyCartanType:
    def my_method(self):
        return "I am here!"


C._add_abstract_superclass(MyCartanType)
pretty_print(C.__class__)
# <class 'sage.combinat.root_system.type_A_affine.CartanType_with_superclass_with_superclass'>
pretty_print(C.__class__.__bases__)
# This triggers the index error, but should print
# (<class 'sage.combinat.root_system.type_A_affine.CartanType_with_superclass'>,
#    <class ...__main__.MyCartanType...>)
```


leads to the following output in `fancy_repr.py`, line 348:
![]( Screenshot 2022-05-08 133226.jpg)

For some reason calling `parent` throws the IndexError. The python debugger doesn't give more insights, and I have no experience with cython debugging to see where the indexerror is thrown. So it would be nice if someone with more cython experience can take this from here.


---

Comment by klee created at 2022-05-09 06:00:29

Replying to [comment:54 gh-tobiasdiez]:
> After merging the latest dev branch, this now throws
> {{{
> File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/all_cmdline.py", line 19, in <module>
>     from sage.all import *
>   File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/all.py", line 135, in <module>
>     from sage.symbolic.all   import *
>   File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/symbolic/all.py", line 8, in <module>
>     import sage.symbolic.expression  # initialize pynac before .ring
>   File "sage/symbolic/expression.pyx", line 1, in init sage.symbolic.expression
>     # -*- coding: utf-8 -*-
>   File "sage/symbolic/function.pyx", line 144, in init sage.symbolic.function
>     from .expression import (
> ImportError: cannot import name call_registered_function
> }}}
> when importing `sage.all`, see eg github build workflow. Any idea on how to fix it?
> 
> This method was introduced in #32386 (or one of its dependencies). 

It seems that cython fails to import the function `call_registered_function` from `sage.symbolic.expression` via the `src/sage/symbolic/pynac_function_impl.pxi` file, where it is defined. I am not sure if we could regard this as a bug of cython as `.pxi` files are not supposed to contain function definitions. I wonder why it is moved there in the first place. Anyway I think we should ask to cython community about this first before we refactor our code.


---

Comment by klee created at 2022-05-09 07:25:19

Replying to [comment:64 klee]:
> Anyway I think we should ask to cython community about this first before we refactor our code.

I filed an issue:

https://github.com/cython/cython/issues/4775

expecting any input from cython experts.


---

Comment by @tobiasdiez created at 2022-05-09 11:39:28

Thanks for opening the issue.

Do you have an idea where the IndexError is coming from?


---

Comment by git created at 2022-05-10 07:21:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-05-10 07:26:01

Replying to [comment:65 klee]:
> Replying to [comment:64 klee]:
> > Anyway I think we should ask to cython community about this first before we refactor our code.
> 
> I filed an issue:
> 
> https://github.com/cython/cython/issues/4775
> 
> expecting any input from cython experts. 

According to the answer, there was a circular import that somehow was hidden but revealed only with `binding=True`. Hence I think changing global imports to local imports are the right solution.


---

Comment by klee created at 2022-05-10 08:00:12

Replying to [comment:66 gh-tobiasdiez]:
> Do you have an idea where the IndexError is coming from?

Note that with `binding=False`:

```
class NewClass:
    def parent(self):
        return 1

NewClass.parent()
...
TypeError: parent() missing 1 required positional argument: 'self'
```


```
%%cython
cdef class NewClass:
    def parent(self):
        return 1

NewClass.parent()
...
TypeError: unbound method NewClass.parent() needs an argument
```


With `binding=True`:

```
%%cython
cimport cython
`@`cython.binding(True)
cdef class NewClass:
    def parent(self):
        return 1

NewClass.parent()
...
IndexError: tuple index out of range

NewClass.parent(2)
1
```


In the latter, `NewClass` is of course not an object but a class, hence `NewClass.parent()` invokes unbound method `.parent` which is a cython function that thinks it is bound. Hence it tries to get "self" from its dictionary of arguments. As the dictionary is empty, it raises `IndexError`. I think this is a bug of cython. It should raise `TypeError` as it should follow Python behavior.

Cython issue:

https://github.com/cython/cython/issues/4779


---

Comment by klee created at 2022-05-11 00:10:30

Replying to [comment:69 klee]:
> Cython issue:
> 
> https://github.com/cython/cython/issues/4779

They are fixing this bug. I think we should wait for the new Cython instead of "fixing it" on our side.


---

Comment by klee created at 2022-05-11 00:24:42

Replying to [comment:57 gh-tobiasdiez]:
> I took a few doctest runs as benchmarks, and could only find a very small negative impact (about 1%) if at all.

Now I think we should regard this 1% as our debt (it was not ours), or as something to pay to get proper introspection to cython functions, which weighs more than the 1%.  

Perhaps we may selectively turn on "binding=False" for some cython functions critical for performance.


---

Comment by @tobiasdiez created at 2022-05-11 19:45:02

Replying to [comment:69 klee]:
> Replying to [comment:66 gh-tobiasdiez]:
> > Do you have an idea where the IndexError is coming from?
> 
> Note that with `binding=False`:
> {{{
> class NewClass:
>     def parent(self):
>         return 1
> 
> NewClass.parent()
> ...
> TypeError: parent() missing 1 required positional argument: 'self'
> }}}
> {{{
> %%cython
> cdef class NewClass:
>     def parent(self):
>         return 1
> 
> NewClass.parent()
> ...
> TypeError: unbound method NewClass.parent() needs an argument
> }}}
> 
> With `binding=True`:
> {{{
> %%cython
> cimport cython
> `@`cython.binding(True)
> cdef class NewClass:
>     def parent(self):
>         return 1
> 
> NewClass.parent()
> ...
> IndexError: tuple index out of range
> 
> NewClass.parent(2)
> 1
> }}}
> 
> In the latter, `NewClass` is of course not an object but a class, hence `NewClass.parent()` invokes unbound method `.parent` which is a cython function that thinks it is bound. Hence it tries to get "self" from its dictionary of arguments. As the dictionary is empty, it raises `IndexError`. I think this is a bug of cython. It should raise `TypeError` as it should follow Python behavior.
> 
> Cython issue:
> 
> https://github.com/cython/cython/issues/4779
> 
> 

Nice! Thanks for doing the analysis and finding a nice minimal example reproducing the issue.


---

Comment by @tobiasdiez created at 2022-05-18 00:15:08

Should be fixed in the new cython release. Updating to it is tracked at #33864.


---

Comment by git created at 2022-05-21 13:21:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-05-22 13:34:21

Seems like the update of cython to 0.29.30 didn't help, the index errors are still present (at least in the github workflow).


---

Comment by git created at 2022-07-14 15:14:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-07 20:53:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-08-08 15:48:53

This is mostly working now. There are a few failing doctests related to pickling, and what I believe is connected, module names (see the build & test workflow).
Moreover, a couple of doctests fail in pynac_impl.pxi. I sadly don't have the expertise to fix these (on my own) and would appreciate input from cython experts.


---

Comment by git created at 2022-11-10 06:31:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by klee created at 2022-11-10 06:33:46

This is working now. While I am not a cython expert, I managed to fix remaining failing doctests. Setting "needs review" to test.


---

Comment by klee created at 2022-11-10 06:33:46

Changing status from needs_info to needs_review.


---

Comment by klee created at 2022-11-10 06:50:07

To break circular imports, it is now not possible to import 

```
    call_registered_function, 
    find_registered_function, 
    register_or_update_function,
    get_sfunction_from_hash,
    get_sfunction_from_serial
```

from `sage.symbolic.function`. They should be imported from `sage.symbolic.expression`, where they are defined.

But then I could not figure out how to deprecate old imports. Or it would be better to make them importable from `sage.symbolic.function` as well. But I couldn't figure out how to do this either!


---

Comment by @tobiasdiez created at 2022-11-10 10:26:49

Thanks, nice that its working now.


---

Comment by git created at 2022-11-11 02:48:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-11-11 02:49:55

The last commit allows importing

```
    call_registered_function, 
    find_registered_function, 
    register_or_update_function,
    get_sfunction_from_hash,
    get_sfunction_from_serial
```

from `sage.symbolic.function`.


---

Comment by jhpalmieri created at 2022-11-11 04:38:11

I think that Cython has to be rebuilt for this to take effect. (At least, I got some doctest failures when I built by just using the branch, and they went away after doing `make distclean` and trying again.) Can you modify the branch to trigger that, for example by bumping up the patch level on the Cython version number?


---

Comment by klee created at 2022-11-11 05:42:48

Replying to [comment:87 John Palmieri]:
> I think that Cython has to be rebuilt for this to take effect.

Perhaps no for Cython itself, but yes all cython files must be rebuilt.

> Can you modify the branch to trigger that, for example by bumping up the patch level on the Cython version number?

Okay.


---

Comment by git created at 2022-11-11 05:43:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-11-12 12:56:50

That Cython 3 adopts binding=True as default is promising, but perhaps we need to have some (however coarse) data on the performance effect on the overall sage library before we proceed.

John, if you experimented with the branch to check performance, would you share what you observed? 

We may ask more developers to experiment with the branch for their favorite part of the sage library and collect their reports. Or could we write a script to do that automatically? What do you think? 

Depending on the collected data, in the worst case (abhorring personally :), we may go with binding=False even with Cython 3.


---

Comment by jhpalmieri created at 2022-11-13 01:21:32

I ran `./sage -tp --global_iterations 10 --long src/sage/matrix/` and I saw a 2-3% increase with this branch, but the timings are pretty variable, so I don't know how much stock to put in this. (A similar test — `./sage -t --file_iterations 10 --long src/sage/matrix/matrix2.pyx` — showed no difference.)


---

Comment by klee created at 2022-11-13 11:25:45

Replying to [comment:91 John Palmieri]:
> I ran `./sage -tp --global_iterations 10 --long src/sage/matrix/` and I saw a 2-3% increase with this branch, but the timings are pretty variable, so I don't know how much stock to put in this. (A similar test — `./sage -t --file_iterations 10 --long src/sage/matrix/matrix2.pyx` — showed no difference.)

Thanks. To do the comparison for all files in the sage library, I added the following lines to the sage doctester:

```diff
--- a/src/sage/doctest/reporting.py
+++ b/src/sage/doctest/reporting.py
`@``@` -556,6 +556,11 `@``@` class DocTestReporter(SageObject):
             import traceback
             log(traceback.format_exc(), end="")
 
+        with open('timings.csv', 'a', encoding="utf-8") as f:
+            if timeout or return_code:
+                f.write(', '.join([source.printpath, '-1', '-1']) + '\n')
+            else:
+                f.write(', '.join([source.printpath, '{:.3f}'.format(postscript['cputime']), '{:.3f}'.format(postscript['walltime'])]) + '\n')
 
     def finalize(self):
         """
```

Then I am running `sage -t --all` collecting all cpu and wall timings. I will post the raw data when it will finish. 

It will be interesting to do this on different platforms.


---

Comment by klee created at 2022-11-14 00:09:31

Attached csv files for the doctest timings "before the branch" and "after the branch" on mac pro.


---

Comment by klee created at 2022-11-14 01:33:46

I did some statistics on the timings data:

- -1.115 percent point increase (yes minus!) in wall timings over all doctested files.

- 0.049 percent point increase in wall timings over only doctested files that have increased wall timings.

The unexpected negative value makes me suspect the validity of the raw data. I attached stats.ipynb that I used.

Please do your own tests. Perhaps you may make stats more reliable and more significant.


---

Comment by klee created at 2022-11-14 02:24:43

The maximum increase of wall timings over doctested files whose name contains "matrix" is 0.101 percent.


---

Comment by nbruin created at 2022-11-14 02:38:05

OK, I think the following illustrates what we're contending with here.

```cython
%%cython
cimport cython
`@`cython.binding(False)
cdef class Unbinding:
    def test(self):
        return 1
`@`cython.binding(True)
cdef class Binding:
    def test(self):
        return 1

def fetch_test(a, N=100):
    for i in range(N):
        _ = a.test

def call_test(a, N=100):
    for i in range(N):
        _ = a.test()
```

With this we find:

```
sage: U=Unbinding()
....: B=Binding()
sage: %timeit fetch_test(U,100000)
2.95 ms ± 37.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit fetch_test(B,100000)
2.67 ms ± 31.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit call_test(U,100000)
3.52 ms ± 44.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit call_test(B,100000)
4.71 ms ± 99 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

As you can see, fetching the binding method is actually a slight bit faster, but actually calling it takes considerably more time (and of the timings here it is the one that fluctuate most between different tests where the cython classes are compiled fresh).

So in tests where calling really cheap methods is dominant [perhaps some part of the coercion framework?] this can have quite an adverse effect. Interestingly, just fetching the method is not much of a problem.

replacing `test` by `__hash__` in the tests above gives similar timings to the `B` case, so it seems that `cython` has previously outperforming method-calls and with `Binding=True` brings performance down to standard python built-in methods.

I think with `binding=True` we're supposed to get a call-frame on the stack, so constructing that would cost a bit more.


---

Comment by klee created at 2022-11-14 04:18:17

Replying to [comment:96 Nils Bruin]:
> So in tests where calling really cheap methods is dominant [perhaps some part of the coercion framework?] this can have quite an adverse effect. 

By this, are you characterizing the files that have higher increase in timings?  

I am confused to find many files that have negative increase in wall timings. Do you think that this is possible or merely it may be a mistake in my test?


---

Comment by nbruin created at 2022-11-14 08:20:56

Replying to [comment:97 Kwankyu Lee]:
> I am confused to find many files that have negative increase in wall timings. Do you think that this is possible or merely it may be a mistake in my test?

I'm confused too. There is clearly a mechanism for it to cost more time, but it seems unlikely that we'd be fetching but not calling methods a lot all over the place. Irt's encouraging to see that the penalty is very low (negative?) for the doctests, but the doctests are not necessarily representative for normal workloads.

Would you be able to locate a doctest that particularly shows an improvement? Then we can profile that and see where the difference comes from.


---

Comment by klee created at 2022-11-14 09:15:23

Sorry... I was doing a stupid thing! There was a grave error in the script I posted in comment:92. I was collecting cumulative times! Here is the correct script: 

```diff
--- a/src/sage/doctest/reporting.py
+++ b/src/sage/doctest/reporting.py
`@``@` -556,6 +556,11 `@``@` class DocTestReporter(SageObject):
             import traceback
             log(traceback.format_exc(), end="")
 
+        with open('timings.csv', 'a', encoding="utf-8") as f:
+            if timeout or return_code:
+                f.write(', '.join([source.printpath, '-1', '-1']) + '\n')
+            else:
+                f.write(', '.join([source.printpath, '{:.3f}'.format(cpu), '{:.3f}'.format(wall)]) + '\n')
 
     def finalize(self):
         """
```


I will do it all again. Sorry!


---

Comment by klee created at 2022-11-15 00:30:03

Now I did it all again.

Excluding files with doctest timings less than 0.0001 second,
- the average percent of wall timing increase is 4.68 percent (3395 files)
- the number of files with increased timing is 1646
- the number of files with the same timing is 2
- the number of files with decreased timing is 1747

Excluding files with doctest timings less than 0.001 second,
- the average percent of wall timing increase is 4.92 percent (3286 files)
- the number of files with increased timing is 1623
- the number of files with the same timing is 2
- the number of files with decreased timing is 1661
Excluding files with doctest timings less than 0.01 second,
- the average percent of wall timing increase is 6.64 percent (2699 files)
- the number of files with increased timing is 1460
- the number of files with the same timing is 0
- the number of files with decreased timing is 1239
Excluding files with doctest timings less than 0.1 second,
- the average percent of wall timing increase is 7.98 percent (2054 files)
- the number of files with increased timing is 1189
- the number of files with the same timing is 0
- the number of files with decreased timing is 865
Excluding files with doctest timings less than 1 second,
- the average percent of wall timing increase is 1.02 percent (1051 files)
- the number of files with increased timing is 571
- the number of files with the same timing is 0
- the number of files with decreased timing is 480


---

Comment by klee created at 2022-11-15 01:16:52

Top 50 files (excluding files with doctest timings less than 0.001 second):

```
src/sage/categories/integral_domains.py
	before: [' 0.079306', ' 0.079273']
	 after: [' 0.307988', ' 0.308937']
src/sage/libs/ntl/ntl_GF2EContext.pyx
	before: [' 0.066746', ' 0.067700']
	 after: [' 0.230420', ' 0.231831']
src/sage/categories/finite_fields.py
	before: [' 0.070238', ' 0.071095']
	 after: [' 0.238406', ' 0.238891']
src/sage/categories/commutative_additive_groups.py
	before: [' 0.098865', ' 0.098834']
	 after: [' 0.311287', ' 0.312079']
src/sage/rings/finite_rings/hom_prime_finite_field.pyx
	before: [' 0.079094', ' 0.079135']
	 after: [' 0.244617', ' 0.245865']
src/sage/tests/books/judson-abstract-algebra/finite-sage.py
	before: [' 0.076353', ' 0.077725']
	 after: [' 0.239775', ' 0.239721']
src/sage/libs/ntl/ntl_GF2E.pyx
	before: [' 0.089370', ' 0.090014']
	 after: [' 0.262272', ' 0.262794']
src/sage/categories/lambda_bracket_algebras_with_basis.py
	before: [' 0.097998', ' 0.098038']
	 after: [' 0.268013', ' 0.267976']
src/sage/modules/fp_graded/steenrod/profile.py
	before: [' 0.118401', ' 0.118368']
	 after: [' 0.315856', ' 0.316445']
src/sage/tests/books/computational-mathematics-with-sagemath/numbertheory_doctest.py
	before: [' 0.098483', ' 0.099181']
	 after: [' 0.264293', ' 0.264477']
src/sage/rings/polynomial/polynomial_ring_homomorphism.pyx
	before: [' 0.096629', ' 0.096598']
	 after: [' 0.256126', ' 0.256090']
src/doc/en/tutorial/tour_coercion.rst
	before: [' 0.129263', ' 0.129233']
	 after: [' 0.324057', ' 0.324398']
src/sage/rings/padics/qadic_flint_FM.pyx
	before: [' 0.105452', ' 0.105449']
	 after: [' 0.264721', ' 0.264679']
src/sage/categories/lie_conformal_algebras_with_basis.py
	before: [' 0.124969', ' 0.124975']
	 after: [' 0.313038', ' 0.313321']
src/sage/categories/filtered_hopf_algebras_with_basis.py
	before: [' 0.133197', ' 0.135361']
	 after: [' 0.337238', ' 0.338512']
src/doc/en/constructions/number_theory.rst
	before: [' 0.130093', ' 0.130113']
	 after: [' 0.322955', ' 0.323989']
src/sage/rings/finite_rings/finite_field_pari_ffelt.py
	before: [' 0.108719', ' 0.108720']
	 after: [' 0.270101', ' 0.270075']
src/sage/schemes/generic/spec.py
	before: [' 0.108496', ' 0.109052']
	 after: [' 0.269601', ' 0.269582']
src/sage/schemes/cyclic_covers/constructor.py
	before: [' 0.102909', ' 0.109477']
	 after: [' 0.264389', ' 0.270194']
src/sage/rings/padics/tutorial.py
	before: [' 0.107419', ' 0.107395']
	 after: [' 0.263088', ' 0.263073']
src/sage/matrix/echelon_matrix.pyx
	before: [' 0.113268', ' 0.113426']
	 after: [' 0.276956', ' 0.277302']
src/sage/libs/ntl/ntl_GF2X.pyx
	before: [' 0.122267', ' 0.122516']
	 after: [' 0.297580', ' 0.299164']
src/sage/categories/supercommutative_algebras.py
	before: [' 0.113472', ' 0.113498']
	 after: [' 0.275392', ' 0.275417']
src/sage/algebras/lie_conformal_algebras/neveu_schwarz_lie_conformal_algebra.py
	before: [' 0.680401', ' 0.680496']
	 after: [' 1.650387', ' 1.650289']
src/doc/fr/tutorial/tour_coercion.rst
	before: [' 0.129249', ' 0.129217']
	 after: [' 0.311773', ' 0.312020']
src/sage/categories/graded_algebras.py
	before: [' 0.122332', ' 0.122326']
	 after: [' 0.293188', ' 0.293266']
src/sage/modular/modsym/relation_matrix.py
	before: [' 0.119631', ' 0.119594']
	 after: [' 0.285118', ' 0.285071']
src/sage/rings/finite_rings/hom_finite_field_givaro.pyx
	before: [' 0.123510', ' 0.123477']
	 after: [' 0.287106', ' 0.287086']
src/sage/rings/finite_rings/maps_finite_field.py
	before: [' 0.124757', ' 0.124726']
	 after: [' 0.288412', ' 0.288380']
src/sage/databases/conway.py
	before: [' 0.133351', ' 0.133313']
	 after: [' 0.307083', ' 0.307040']
src/doc/pt/tutorial/tour_coercion.rst
	before: [' 0.133222', ' 0.133193']
	 after: [' 0.304935', ' 0.304977']
src/sage/topology/simplicial_complex_catalog.py
	before: [' 0.126303', ' 0.126971']
	 after: [' 0.289456', ' 0.290462']
src/sage/matrix/special.py
	before: [' 3.708397', ' 3.710988']
	 after: [' 8.438786', ' 8.449929']
src/sage/quadratic_forms/quadratic_form__genus.py
	before: [' 0.136494', ' 0.137692']
	 after: [' 0.307132', ' 0.308443']
src/sage/topology/simplicial_set_catalog.py
	before: [' 0.133204', ' 0.133253']
	 after: [' 0.297010', ' 0.296963']
src/doc/ja/tutorial/tour_coercion.rst
	before: [' 0.134616', ' 0.134912']
	 after: [' 0.299326', ' 0.299371']
src/sage/groups/semimonomial_transformations/semimonomial_transformation.pyx
	before: [' 0.132887', ' 0.133518']
	 after: [' 0.293834', ' 0.295359']
src/sage/coding/encoder.py
	before: [' 0.136825', ' 0.138215']
	 after: [' 0.305238', ' 0.305214']
src/sage/categories/graded_hopf_algebras_with_basis.py
	before: [' 0.145463', ' 0.145442']
	 after: [' 0.319678', ' 0.319964']
src/sage/categories/bialgebras.py
	before: [' 0.141808', ' 0.141798']
	 after: [' 0.311850', ' 0.311874']
src/doc/pt/tutorial/tour_linalg.rst
	before: [' 0.373303', ' 0.373274']
	 after: [' 0.819058', ' 0.820568']
src/sage/categories/super_algebras.py
	before: [' 0.169427', ' 0.169401']
	 after: [' 0.371249', ' 0.371973']
src/sage/matrix/tests.py
	before: [' 0.201088', ' 0.212642']
	 after: [' 0.458424', ' 0.466883']
src/sage/modules/module_functors.py
	before: [' 0.143611', ' 0.143631']
	 after: [' 0.311692', ' 0.311828']
src/sage/libs/pari/convert_sage.pyx
	before: [' 0.144688', ' 0.145325']
	 after: [' 0.313929', ' 0.314779']
src/sage/categories/examples/lie_algebras.py
	before: [' 0.151175', ' 0.151161']
	 after: [' 0.323088', ' 0.323347']
src/sage/modules/fp_graded/free_homspace.py
	before: [' 0.139569', ' 0.139584']
	 after: [' 0.298228', ' 0.298207']
src/sage/schemes/plane_conics/constructor.py
	before: [' 0.149624', ' 0.149596']
	 after: [' 0.319158', ' 0.319184']
src/sage/rings/noncommutative_ideals.pyx
	before: [' 0.161079', ' 0.161045']
	 after: [' 0.340440', ' 0.341121']
src/sage/categories/finitely_generated_lambda_bracket_algebras.py
	before: [' 0.203815', ' 0.203805']
	 after: [' 0.430212', ' 0.430773']
```



---

Comment by nbruin created at 2022-11-16 00:22:13

Replying to [comment:101 Kwankyu Lee]:
> {{{
> src/sage/crypto/lwe.py
> 	before: [' 3.879', ' 3.886']
> 	 after: [' 11.655', ' 11.658']
> src/sage/rings/tests.py
> 	before: [' 8.216', ' 7.723']
>	 after: [' 17.429', ' 16.965']
> }}}
That first one seems unduly long (already the "before" time). The second one could be the right ballpark, making that possibly a good candidate to select some doctests from and profile them both before and after to see which routines end up eating more time.

To some extent, `lwe.py` could be a good test case (if the times hold up) since the code there, as well as the doctests, don't seem to be particularly written to just test very cheap cython routine calls: the code may well end up doing that by itself. That would be pretty damning, because then any other code out there that follows similar patterns will be very negatively affected.


---

Comment by nbruin created at 2022-11-16 21:53:11

OK, based on the data that you provided, looking at the mean and the standard deviation of the difference, I don't think the hypothesis "Binding=True generally improves or decreases performance significantly over doctests" is supported. That's not too surprising. In order to see if there is any support for the hypothesis "Binding=True changes the performance of certain doctests significantly" I think we need to verify that the variation in doctest performance in general is significantly lower than the difference we're seeing. If doctesting times in general vary wildly then running them once with code A and once with code B will cause  big timing differences between them, in both directions, simply because the random variation is causing differences.

Your data gives a good start point to select some doctests for more detailed testing and the effects shown, if real, are chilling. So it's worth investigating.


---

Comment by jhpalmieri created at 2022-11-16 23:14:07

I get huge variance with some of these doctests. I ran `./sage -t --long --file-iterations 10 src/sage/crypto/lwe.py` multiple times, without and with this branch:

- without: 2.2 seconds (total), 19.7, 8.8
- with: 19.8, 3.6, 5.0

`./sage -t --long --file-iterations 10 src/sage/rings/tests.py`:

- without: 88.2, 92.6, 83.3, 75.3, 86.8, 74.6
- with: 82.7, 65.4, 83.9, 80.0, 77.0


---

Attachment


---

Attachment


---

Comment by klee created at 2022-11-16 23:40:11

I got new raw data with finer timings (6 digits below decimal point instead of 3), and updated the statistics.


---

Comment by klee created at 2022-11-17 01:00:51

Replying to [comment:103 Nils Bruin]:
> I think we need to verify that the variation in doctest performance in general is significantly lower than the difference we're seeing. 

I agree. So I am running these tests again and again to get stable and more confident conclusion. Welcome any technical advices for this objective.


---

Comment by nbruin created at 2022-11-17 04:15:19

Well ... if there is a lot of variance, then running a lot of times doesn't really remove it. By averaging over larger sample sizes you *may* be able to say with more confidence that the expected running time went up/down on a particular sample, but ultimately it may be the case that the the probability that code A runs faster than code B on a particular instance is only 51%. If one test runs in 2-5seconds, 80% of the time with code A and in 2.1-5.1seconds 80% of the time with code B, is it really so significant?

I'd say that such a doctest would be a very poor way of seeing a difference in performance. There are programs that run with predictable runtimes, with very low variance, such as the artificial test I wrote in comment:97. Many other sage programs run in stable runtimes too. Some of those would be better grounds for sampling, probably. Doctests are too much dominated by variable i/o conditions, because they're generally short and tiny. The actual computations are swamped by overhead. You can try and see if there are some tests that have lower variance in their runtime.

John's approach in comment:104 may be a bit better already, although for the particular tests he was doing, the variance seems unworkably high.


---

Comment by klee created at 2022-11-17 06:14:51

For variance:

A comparison with "before1" data and "before2" data (excluding files with doctest timings less than 0.001 second):  

- the average percent of wall timing increase is 1.02 percent (3300 files)

A comparison with "before2" data and "before1" data (excluding files with doctest timings less than 0.001 second):  

- the average percent of wall timing increase is -0.68 percent (3308 files)

A comparison with "after1" data "after2" data (excluding files with doctest timings less than 0.001 second):

- the average percent of wall timing increase is 0.19 percent (3233 files)

A comparison with "after2" data "after1" data (excluding files with doctest timings less than 0.001 second):

- the average percent of wall timing increase is 1.14 percent (3223 files)


---

Comment by klee created at 2022-11-17 06:17:36

To reduce variance caused by noises on the system, I ran the tests with no activity of my own.


---

Attachment


---

Attachment

I agree that there is a not-so-small variance in the timings of running doctests. But still the experiments make me believe that

- Some part of the sage library runs slower with `biding=True`
- Other part of the sage library runs faster with `binding=True` (this surprised me, but Nils provided a possible explanation)
- In average, there is about 5% performance loss with `binding=True`.

Thus before we ask sage users to accept the performance loss for all benefits of `binding=True`, we need to identify and analyze the part of sage library with performance loss and think about ways to reduce the loss (perhaps just by adding ``@`cython.binding(False)` to methods with no real need of introspection..).


---

Comment by dimpase created at 2022-11-17 09:51:35

How about making the choice of `binding=` conditional on the value of a parameter to `./configure` ?


---

Comment by klee created at 2022-11-17 12:28:38

If the default value for the parameter is `True`, then that is just a soft way of introducing `binding=True` default. Once sage is adapted to the default `binding=True`, then setting `binding=False` will make sage somewhat broken. For instance, some doctests will break :)

Still we should put some efforts to identify easy cases that may be recovered from performance loss. What would they be?


---

Comment by @tobiasdiez created at 2022-11-17 17:17:37

You can also try to use something like `hyperfine -i --warmup 3 './sage -t --long src/sage/crypto/lwe.py'`. Maybe the warmup helps to reduce the variance and effects coming from file caches.


---

Comment by nbruin created at 2022-11-17 17:40:30

Further profiling of doctests may help to find examples of slow-downs, but to see what causes the slow-down still requires individual profiling: the slow-downs measured in one file are probably not caused by changes in compiling that file (example: `lwe.py` is pure python, so any code changes in the file itself won't make a differency regarding `Binding=True` (beyond changing how much the file deoends on code that is affected by it).

It's pretty clear that the main cost `Binding=True` is imposing is that calling overhead of cython `def` methods has significantly gone up (from what was ridiculously cheap; the score now is more in line with what normal built-in does). It's still tiny, so the cost is only significant on routines that do very little work. So accessor functions for c-level attributes are probably affected a lot.
It basically means that the marginal benefit of wrapping tight loops *into* cython has now increased (provided you can then punch through the python call layer and use cdef instead).

I can't think of an easy way to locate the critical functions: profiling differences between realistic peaces of code would give some indications. I suspect much of the coercion and category framework is affected, so we may be better off marking some of the more critical routines there with `binding=False`.

Getting some realistic, striking examples to the cython people may also be a good idea. Perhaps the cost can be mitigated?

Another thing that's worth checking is if `cpdef` routines called from cython are affected. `cpdef` has some extra boiler plate around it to allow them to be shadowed runtime in a way that `cdef` doesn't have to contend with. That has always meant a (tiny) overhead on `cpdef` relative to `cdef` on the cython side, but given that `Binding=True` changes call overheads, perhaps that is affected too.


---

Attachment

Replying to [comment:114 Nils Bruin]:
> Further profiling of doctests may help to find examples of slow-downs, but to see what causes the slow-down still requires individual profiling: the slow-downs measured in one file are probably not caused by changes in compiling that file (example: `lwe.py` is pure python, so any code changes in the file itself won't make a differency regarding `Binding=True` (beyond changing how much the file deoends on code that is affected by it).
> 
> It's pretty clear that the main cost `Binding=True` is imposing is that calling overhead of cython `def` methods has significantly gone up (from what was ridiculously cheap; the score now is more in line with what normal built-in does). It's still tiny, so the cost is only significant on routines that do very little work. So accessor functions for c-level attributes are probably affected a lot.
> It basically means that the marginal benefit of wrapping tight loops *into* cython has now increased (provided you can then punch through the python call layer and use cdef instead).
> 
> I can't think of an easy way to locate the critical functions: profiling differences between realistic peaces of code would give some indications. I suspect much of the coercion and category framework is affected, so we may be better off marking some of the more critical routines there with `binding=False`.

I found one (pretty striking) example in the locations that you suspected. It is `base_ring()` method defined in `src/sage/structure/category_object.pyx`. A single call of that method takes about 25% more time "after" than "before". I attached "profiling..." notebooks for you to experiment. You may also experiment the effect of this change: 

```
--- a/src/sage/structure/category_object.pyx
+++ b/src/sage/structure/category_object.pyx
`@``@` -61,7 +61,7 `@``@` from sage.categories.category import Category
 from sage.structure.debug_options cimport debug
 from sage.misc.cachefunc import cached_method
 from sage.structure.dynamic_class import DynamicMetaclass
-
+import cython
 
 cpdef inline check_default_category(default_category, category):
     ## The resulting category is guaranteed to be
`@``@` -553,6 +553,7 `@``@` cdef class CategoryObject(SageObject):
     # Bases
     #################################################################################################
 
+    `@`cython.binding(False)
     def base_ring(self):
         """
         Return the base ring of ``self``.
```



---

Attachment

Replying to [comment:114 Nils Bruin]:
> It's still tiny, so the cost is only significant on routines that do very little work. So accessor functions for c-level attributes are probably affected a lot.

Then the performance loss shown in the doctests test is mostly contributed by small cython files whose doctests spend time mainly in running such accessor functions. The result in comment:100 seems in sync with the theory. Note that "excluding files with doctest timings less than 1 second," the average performance loss is about 1%. 

We may say that for a typical sage user, who spend time (much longer than 1 second) in running functions far from those simple accessor functions, the experienced performance loss would be negligible.


---

Comment by klee created at 2022-11-20 13:48:04

Replying to [comment:112 Kwankyu Lee]:
> Still we should put some efforts to identify easy cases that may be recovered from performance loss. What would they be?

Accessor functions to entries of an object, like coefficients of matrices or polynomials would likely be used in a tight loop. So they are easy targets to recover. For example   

```diff
--- a/src/sage/matrix/matrix_generic_dense.pyx
+++ b/src/sage/matrix/matrix_generic_dense.pyx
`@``@` -327,6 +327,7 `@``@` cdef class Matrix_generic_dense(matrix_dense.Matrix_dense):
         A._entries = v
         return A
 
+    `@`cython.binding(False)
     def _list(self):
         """
         Return reference to list of entries of self.  For internal use
```

will be beneficial. 

In general, `def` method in `cdef class` with underlined name `_xxx` (for internal use) would clearly benefit from ``@`cython.binding(False)` declaration.


---

Comment by klee created at 2022-11-21 02:21:27

Replying to [comment:117 Kwankyu Lee]:
> In general, `def` method in `cdef class` with underlined name `_xxx` (for internal use) would clearly benefit from ``@`cython.binding(False)` declaration. 

There are lots of such internal methods. If we include `_repr_` and `_latex_`, then perhaps all pyx files would be included. So before we start doing this systematically, let us discuss how to do it.

- Do we exclude non-crucial methods like `_repr_` and `_latex_`? Then what else are? Or we include them all?
- We may be better off if we make ``@`cython.binding(parameter)` dependent on a `configure`-able parameter, as Dima suggested. Then what would be the parameter name?


---

Comment by klee created at 2022-11-21 15:58:55

Replying to [comment:118 Kwankyu Lee]:
> - Do we exclude non-crucial methods like `_repr_` and `_latex_`? Then what else are? Or we include them all?

No. There's no benefit in excluding them. All underlined internal methods in cdef classes get ``@`cython.binding(False)`.

> - We may be better off if we make ``@`cython.binding(parameter)` dependent on a `configure`-able parameter, as Dima suggested. Then what would be the parameter name?

No. Let's keep things simple. The use of a configured parameter is not clear.


---

Comment by dimpase created at 2022-11-21 16:31:24

Replying to [comment:119 Kwankyu Lee]:

> > - We may be better off if we make ``@`cython.binding(parameter)` dependent on a `configure`-able parameter, as Dima suggested. Then what would be the parameter name?
> 
> No. Let's keep things simple. The use of a configured parameter is not clear. 
what's not clear about it? If `cython_binding=True` leads to performance degradation on some methods, then it should be possible for the user to turn them off. Such methods should be decorated with ``@`cython.binding(parm)` with `parm` somehow divined from the value passed to 


```
./configure --cython_bindings=parm
```


Or it's unclear to you how to implement it?

----
New commits:


---

Comment by nbruin created at 2022-11-22 00:02:45

Replying to [comment:119 Kwankyu Lee]:
> No. There's no benefit in excluding them. All underlined internal methods in cdef classes get ``@`cython.binding(False)`.

Well ... in that case, what's the benefit of excluding any methods? Why don't we just set `Binding=False` globally for sagelib and keep things as they were? Then there's no performance degradation to worry about at all. We could make that a build-time parameter, but I suspect it's going to affect some doctests, so supporting both with com at a bit of a cost.


---

Comment by klee created at 2022-11-22 00:11:37

Replying to [comment:120 Dima Pasechnik]:
> Replying to [comment:119 Kwankyu Lee]:
> 
> > > - We may be better off if we make ``@`cython.binding(parameter)` dependent on a `configure`-able parameter, as Dima suggested. Then what would be the parameter name?
> > 
> > No. Let's keep things simple. The use of a configured parameter is not clear. 
> what's not clear about it? If `cython_binding=True` leads to performance degradation on some methods, then it should be possible for the user to turn them off. 

From the analysis of experiments, in comment:114, I concluded that performance degradation is negligible. The performance loss shown in the doctests test seems mostly contributions by small cython files whose doctests spend time mainly in running accessor functions (like `base_ring()` method defined in `src/sage/structure/category_object.pyx`). It seems to me that if a user runs sage functions more than one second and experience non-negligible performance degradation, then those functions should spend time in running accessor functions in a tight loop. 

So the plan is to set `cython_binding=True` by default, and to add ``@`cython.binding(False)` decorator to the adverse accessor functions. It seems that sage library already provides many accessor functions in `_xxx()` form. In the last commit, I added the decorator to all underlined `def` methods defined in `cdef class`es. Running accessor functions in a tight loop is plausible in computing matrices, polynomials, etc. Those accessor functions need to be provided in `_xxx()` form with ``@`cython.binding(False)` decorator, if not yet.  

I thought of ``@`cython.binding(parm)` with `param=False` by default, and a user may turn on `param=True` when he or she wants. But when one wants to turn on `param=True`? This is not clear to me. (Perhaps for debugging?) I guess this is an opposite situation to the situation for which Dima originally suggested the parameter.


---

Comment by git created at 2022-11-22 00:12:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2022-11-22 00:20:57

Replying to [comment:122 Kwankyu Lee]:
> So the plan is to set `cython_binding=True` by default, and to add ``@`cython.binding(False)` decorator to the adverse accessor functions. It seems that sage library already provides many accessor functions in `_xxx()` form. In the last commit, I added the decorator to all underlined `def` methods defined in `cdef class`es. Running accessor functions in a tight loop is plausible in computing matrices, polynomials, etc. Those accessor functions need to be provided in `_xxx()` form with ``@`cython.binding(False)` decorator, if not yet.  

I don't think `_xxx` is necessarily a good indicator of the cost of the call. When that routine is producing a string, for instance (like `__repr__`) the string allocation and assembly likely takes much more time than the call.

A routine like `matrix.nrows()` on the other hand is about as cheap as it gets and that's not an underscored method.


---

Comment by klee created at 2022-11-22 00:22:54

Replying to [comment:121 Nils Bruin]:
> Replying to [comment:119 Kwankyu Lee]:
> > No. There's no benefit in excluding them. All underlined internal methods in cdef classes get ``@`cython.binding(False)`.
> 
> Well ... in that case, what's the benefit of excluding any methods? 

The benefit of `binding=True`? We get better support of introspecting cython methods, consistent help messages for cython methods like python methods, better tracebacks on exceptions, better behaving for documentation, etc.


---

Comment by klee created at 2022-11-22 00:33:32

Replying to [comment:124 Nils Bruin]:
> I don't think `_xxx` is necessarily a good indicator of the cost of the call. 

I agree. I guess there is no good indicator.


---

Comment by klee created at 2022-11-22 00:51:31

Replying to [comment:124 Nils Bruin]:
> A routine like `matrix.nrows()` on the other hand is about as cheap as it gets and that's not an underscored method.

After this ticekt, that method should be only for a user. For internal use (as accessor in a tight loop), `matrix._nrows` or `matrix._nrows()` should be used (or implemented if not exist yet).


---

Comment by git created at 2022-11-22 02:57:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2022-11-22 21:26:36

Reported upstream:
https://github.com/cython/cython/issues/5144

Preliminary timings there suggest the problem disappears with cython 3. So it would be instructive to check if the problem above persists in sage with an upgraded cython. If not, then we can just close this ticket and not do anything!


---

Comment by klee created at 2022-11-22 22:21:45

Thanks for the report.

It would be interesting to see a real-world nontrivial (unlike `base_ring()`) example that has perceivable performance degradation.


---

Comment by nbruin created at 2022-11-23 07:07:59

With Cython 3.0.0a11 it looks like "Binding" performs uniformly better. So I think we should wait for Cython 3 to come out and when we transition we can close this ticket, because the default changes there anyway.


---

Comment by klee created at 2022-11-23 09:00:06

Replying to [comment:132 Nils Bruin]:
> With Cython 3.0.0a11 it looks like "Binding" performs uniformly better.

That's good news!

> So I think we should wait for Cython 3 to come out and when we transition we can close this ticket, because the default changes there anyway.

Except one line that changes the default, the other changes of this ticket (doctest fixes and adding ``@`cython.binding(False)`) will still be necessary and useful. This ticket paves the way for Cython 3. So do you mean "merge" by "close"?


---

Comment by klee created at 2022-11-23 09:09:52

I looked at the upstream discussion. They say "Binding" is faster than "Unbinding"! That is almost unbelievably good news :)

Then it means that adding ``@`cython.binding(False)` is actually harmful with Cython 3!? 

If that is really true, then we can close this ticket and merge the commit for fixing doctest failures to the Cython 3 ticket.


---

Comment by @tobiasdiez created at 2022-11-23 13:14:24

Are there any news when Cython 3 will finally be released? If not, in light of the finding above that the bindings don't lead to (serious) performance decreases in "real life" even with cython 0.2x, I would suggest to merge this ticket without the manual `binding(false)`. In this way, we would already profit from the better debugging experience and documentation and once Cython 3 comes around gain back the performance loss.


---

Comment by klee created at 2022-11-23 13:54:24

Replying to [comment:135 Tobias Diez]:
> Are there any news when Cython 3 will finally be released?

It seems to go in beta status soon.

> If not, in light of the finding above that the bindings don't lead to (serious) performance decreases in "real life" even with cython 0.2x, I would suggest to merge this ticket without the manual `binding(false)`. In this way, we would already profit from the better debugging experience and documentation and once Cython 3 comes around gain back the performance loss.

+1 from me. But I doubt if we could agree on this. If there is a disagreement, we cannot help but go to the way Nils suggested.


---

Comment by git created at 2022-11-23 15:12:08

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by klee created at 2022-11-23 15:14:52

Peeled off the commit of adding ``@`cython.binding(False)`.


---

Comment by nbruin created at 2022-11-23 16:41:42

I'd say wait for Cython 3 and, in the mean time, use ​0c78cdf for development work if you're testing for the consequences of `binding=True`. Or perhaps just make that change manually if you want a debugging session with more details.

In any case, the branch here as it is shouldn't be merged: its net effect is an addition of 1 line (which can be reverted when cython 3 is merged). Rebase the ​0c78cdf branch instead (or perhaps just  force push it to the ticket) There's no need to pollute the change history with an incredible amount of line-addition-then-removal changes.


---

Comment by klee created at 2022-11-23 23:10:26

Replying to [comment:139 Nils Bruin]:
> Rebase the ​0c78cdf branch instead (or perhaps just  force push it to the ticket) There's no need to pollute the change history with an incredible amount of line-addition-then-removal changes.

Did you see comment:138 and the latest branch? It contains changes that will be necessary also for Cython 3.


---

Comment by nbruin created at 2022-11-23 23:57:46

Replying to [comment:140 Kwankyu Lee]:
> Did you see comment:138 and the latest branch? It contains changes that will be necessary also for Cython 3.

OK, sorry. It looks like you already cleaned up the branch (I now see the last push was indeed a "forced push"). Yes, this branch is fine then, but due to performance ramifications I think we should still wait until we're ready to upgrade to Cython 3 . 

Note that the cython folk pointed to https://github.com/cython/cython/pull/4735 which may be affecting our performance with Python 3.10+ . It may be extra reason to upgrade to Cython 3. I don't know if upgrading to an "alpha" is warranted. Apparently :

> ... if you want better performance, use Cython 3. If you value extreme language stability instead, stay with Cython 0.29.x for now. But be aware that maintenance for 0.29.x will probably end soon after Cython 3.0 is out. And that won't take as forever as it seemed for the last few years.

So ... less forever until we can upgrade to a released Cython 3!


---

Comment by @tobiasdiez created at 2022-11-24 01:08:04

Replying to [comment:141 Nils Bruin]:
> > ... if you want better performance, use Cython 3. If you value extreme language stability instead, stay with Cython 0.29.x for now. But be aware that maintenance for 0.29.x will probably end soon after Cython 3.0 is out. And that won't take as forever as it seemed for the last few years.
> 
> So ... less forever until we can upgrade to a released Cython 3!

Well, this was comment is already more than half a year old. The most recent comment about a beta of Cython 3 that I could find is https://github.com/cython/cython/issues/4022#issuecomment-1200386975, which is also 5 months old with no update since. Taking into account that the upgrade from v0.2x to v3 in Sage is also non-trivial (#29863), I would be surprised if Cython 3 will be fully supported in sage in the next few months.


---

Comment by klee created at 2022-11-24 03:37:29

This ticket is blocking other tickets (#27578, #30884, #31309, ...) for documentation improvement because of cython methods behaving differently with python methods.

We may endure slight performance degradation (which, I think, no one will notice in real computing life) to enjoy conveniences brought by this ticket and allow progress of the mentioned tickets, in the meantime we wait for Cython 3 to arrive.
