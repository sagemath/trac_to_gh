# Issue 32786: src/sage/matrix/matrix_double_sparse.pyx test failures on aarch64

Issue created by migration from https://trac.sagemath.org/ticket/33023

Original creator: @collares

Original creation time: 2021-12-14 23:06:09

CC:  mjo dimpase

Using Sage 9.5.beta8, I am seeing failures such as the one below on aarch64: 

```
sage -t --long --random-seed=138452687149883420730489596915102319785 /nix/store/1jyscb1slmz6134mlsfs9gfjs4kv8w8i-sage-src-9.5.beta8/src/sage/matrix/matrix_double_sparse.pyx
**********************************************************************
File "/nix/store/1jyscb1slmz6134mlsfs9gfjs4kv8w8i-sage-src-9.5.beta8/src/sage/matrix/matrix_double_sparse.pyx", line 95, in sage.matrix.matrix_double_sparse.Matrix_double_sparse.cholesky
Failed example:
    L = A.cholesky()
Exception raised:
    Traceback (most recent call last):
      File "/nix/store/vwd2z6p52kzhidwwvwavgw9jxp1165qh-python3-3.9.6-env/lib/python3.9/site-packages/sage/doctest/forker.py", line 694, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/nix/store/vwd2z6p52kzhidwwvwavgw9jxp1165qh-python3-3.9.6-env/lib/python3.9/site-packages/sage/doctest/forker.py", line 1096, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.matrix.matrix_double_sparse.Matrix_double_sparse.cholesky[20]>", line 1, in <module>
        L = A.cholesky()
      File "sage/matrix/matrix_double_sparse.pyx", line 110, in sage.matrix.matrix_double_sparse.Matrix_double_sparse.cholesky (build/cythonized/sage/matrix/matrix_double_sparse.c:2820)
        raise ValueError("matrix is not Hermitian")
    ValueError: matrix is not Hermitian
```



---

Comment by mjo created at 2021-12-14 23:42:48

This works on amd64 (with cvxopt installed):


```
sage -t --long --random-seed=138452687149883420730489596915102319785 src/sage/matrix/matrix_double_sparse.pyx
    [28 tests, 0.33 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.5 seconds
    cpu time: 0.3 seconds
    cumulative wall time: 0.3 seconds
```


but of course I'm just now noticing that the `--disable-cvxopt` branch I was so careful to add doesn't work at all.

Can you use `set_random_seed()` within a sage session to reproduce the failing test manually? And then let us know what the matrix is? The problem may be somewhere else entirely.


---

Comment by @collares created at 2021-12-15 00:04:04

I will try to do that, but it might take a couple of days because I do not have an aarch64 machine (the above log is from NixOS's build servers). That being said, the following comment on matrix0.pyx's is_hermitian method, which I believe is the method getting called by matrix_double_sparse.pyx, makes me think this is a precision issue:

"This routine is for matrices over exact rings and so may not  work properly for matrices over ``RR`` or ``CC``.  For matrices with approximate entries, the rings of double-precision floating-point numbers, ``RDF`` and ``CDF``, are a better choice since the :meth:`sage.matrix.matrix_double_dense.Matrix_double_dense.is_hermitian` method has a tolerance parameter.  This provides control over allowing for minor discrepancies between entries when checking equality."

Either way, I will get back to you as soon as I have the actual matrix. Thanks!


---

Comment by mjo created at 2021-12-15 00:15:17

That's a very good guess. The way the matrix class hierarchy looks, sparse matrices aren't a subclass of the corresponding dense matrices. As a result, the special `is_hermitian()` method for double dense matrices is not inherited for double sparse matrices (i.e. the failing test). Thus it's likely that the default method using naive equality is indeed causing the problem.

I believe then that this is not a new bug; just a new test case that happens to expose it.


---

Comment by mjo created at 2021-12-15 15:52:36

Does anyone know in what sense `is_hermitian(algorithm="orthonormal")` is more stable than  `is_hermitian(algorithm="naive")` for double dense matrices?

I'm tempted to write one fast `is_hermitian()` in the superclass that works for all subclasses, but the name "naive" makes me think that maybe I'm being naive.


---

Comment by @kliem created at 2021-12-15 18:01:38

I have the same error on debian updating to the current beta. See #33028 (which is now marked duplicate).


---

Comment by mjo created at 2021-12-15 21:01:55

Changing priority from minor to blocker.


---

Comment by mjo created at 2021-12-15 21:01:55

Unless I find the answer to my question in comment:5 and repair `is_hermitian()` quickly, we can mark this `# known bug` for now (before the release) and then remove the tag later after `is_hermitian()` is fixed in another ticket.


---

Comment by dimpase created at 2021-12-15 21:41:41

`is_hermitian(algorithm="naive")` is naive in the worst sense, IMHO. Just checking entry-wise tolerances for some fixed precision.

I'd instead using least squares to compute a hermitian matrix which is closest in l2 norm, and see how far it is from the matrix in question.


---

Comment by mjo created at 2021-12-15 23:21:56

Replying to [comment:8 dimpase]:
> `is_hermitian(algorithm="naive")` is naive in the worst sense, IMHO. Just checking entry-wise tolerances for some fixed precision.

But what does it handle badly?  If `A` is hermitian, than `A - A.conjugate_transpose()` should be zero, and how un-zero it is depends on the magnitudes of its entries.
 
> I'd instead using least squares to compute a hermitian matrix which is closest in l2 norm, and see how far it is from the matrix in question.

That would still involve an expression like `(A - B).norm()`, which is what we're calling naive.


---

Comment by mjo created at 2021-12-16 12:45:40

Changing status from new to needs_review.


---

Comment by mjo created at 2021-12-16 12:45:40

Here's the duct-tape fix. I opened #33031 for the real one.


---

Comment by @collares created at 2021-12-16 12:52:38

Replying to [comment:9 mjo]:
> That would still involve an expression like `(A - B).norm()`, which is what we're calling naive.

An uneducated guess: There are multiple ways to use this norm, such as `(A - B).norm() < tol` and `(A - B).norm() / A.norm() < tol`. Maybe the latter is less naive?


---

Comment by dimpase created at 2021-12-16 17:10:55

don't we have an arch-specific tag to use here?


---

Comment by mjo created at 2021-12-16 17:25:07

Replying to [comment:12 dimpase]:
> don't we have an arch-specific tag to use here?

The test checks equality of floating point numbers and so is fundamentally broken. The fact that it seems to work on amd64 is the miracle.


---

Comment by dimpase created at 2021-12-16 17:48:14

Replying to [comment:13 mjo]:
> Replying to [comment:12 dimpase]:
> > don't we have an arch-specific tag to use here?
> 
> The test checks equality of floating point numbers and so is fundamentally broken. The fact that it seems to work on amd64 is the miracle.

equality? Where?


---

Comment by mjo created at 2021-12-16 18:53:10

Replying to [comment:14 dimpase]:
> > 
> > The test checks equality of floating point numbers and so is fundamentally broken. The fact that it seems to work on amd64 is the miracle.
> 
> equality? Where?

The superclass's `is_hermitian()` method is doing `self[i,j] == self[j,i].conjugate()`.

edit: added the conjugate


---

Comment by dimpase created at 2021-12-16 19:54:40

Changing status from needs_review to positive_review.


---

Comment by dimpase created at 2021-12-16 19:54:40

OK.


---

Comment by @collares created at 2021-12-16 22:11:49

For posterity wrt the aarch64 situation: It seems like this is just GSL's normal behavior for complex numbers. For a while, GSL failed its own test suite on non-x86 archs (see https://lists.gnu.org/archive/html/bug-gsl/2018-04/msg00000.html, https://lists.gnu.org/archive/html/bug-gsl/2019-08/msg00006.html), and this was fixed by increasing the testsuite tolerance (if I understand correctly). In Sage, this leads to the following:

```
sage: n = 2
....: A = matrix.random(CDF, n, sparse=True)
....: I = matrix.identity(CDF, n, sparse=True)
....: B = A*A.conjugate_transpose() + I
sage: B.is_hermitian()
False
sage: A
[ 0.06399592195624204 + 0.9759063101371459*I   -0.6225535439278806 - 0.936748411534233*I]
[0.7034249681768727 + 0.025995399537690478*I   -0.530996200711682 - 0.9527074580528845*I]
sage: A.conjugate_transpose()
[ 0.06399592195624204 - 0.9759063101371459*I 0.7034249681768727 - 0.025995399537690478*I]
[  -0.6225535439278806 + 0.936748411534233*I   -0.530996200711682 + 0.9527074580528845*I]
sage: A[0,0] * A.conjugate_transpose()[0,0]
0.9564886041925287 + 2.9640823241848024e-19*I
```

I can't reproduce this particular problem on amd64, but I am happy the main problem was caught so quickly. Thanks for the speedy diagnosis and fix!


---

Comment by vbraun created at 2021-12-23 20:26:37

Resolution: fixed
