# Issue 21927: Memory leaks in eclib interface

Issue created by migration from Trac.

Original creator: cremona

Original creation time: 2017-01-10 10:14:43

The interface from Sage to eclib introduces memory leaks since C++ objects are created but not destroyed.  In all but one place there is an appropriate dealloc method, but not for class ECModularSymbol.

Here is a list, hopefully complete, all from sage.libs.eclib:

- In homespace.pyx the initializer for class ModularSymbols calls new to create a C++ homespace, which is correctly deallocated

- In mat.pyx, C++ matrices are created but again there is a dealloc to delete them.

- In mwrank.pyx the initializer for class _Curvedata creates a C++ Curvedata via new which is correctly deallocated.  Same for class _mw with a new nw.  Same for class _two_descent and new two_descent.

- But in newforms.pyx, the initializer for class ECModularSymbol calls new newforms() and has no dealloc method.


---

Comment by cremona created at 2017-01-10 10:16:47

I added #22077 and #10256 as dependencies since they  make many changes in sage.libs.eclib, but as they have missed release 7.5 (I assume) someone might consider it urgent to fix this leak before 7.5 despite that.


---

Comment by jdemeyer created at 2017-01-10 13:02:55

homespace? Sounds cool :-)


---

Comment by jdemeyer created at 2017-01-10 13:03:46

Replying to [comment:1 cremona]:
> I added #22077 and #10256 as dependencies since they  make many changes in sage.libs.eclib, but as they have missed release 7.5 (I assume) someone might consider it urgent to fix this leak before 7.5 despite that.

As far as I know, the memory leak is not something new. If the problem has existed for a while and people didn't complain, I don't consider it very urgent.


---

Comment by cremona created at 2017-01-10 13:44:04

That is a fair point.  The reason it came up now is that Rob Pollack and I were adding Iwasawa lambda- and mu-invariants to each of the elliptic curves in the LMFDB, which involves a one-off computation for each which uses this.  Once we had tested the code Rob was intending to run it as far as practicable, and that will only be possible once this is fixed.  And also, these computations will also use the additional functionality made available at #10256 and #22077.


---

Comment by jdemeyer created at 2017-01-10 14:00:56

Maybe we could discuss in Edinburgh?


---

Comment by cremona created at 2017-01-10 14:18:11

OK, let's.  Meanwhile I am trying the same loop to 10000 as in the asksage post, and by 5000 it is using around 15g, so I stopped it and will try again with a small patch which adds a dealloc method.


---

Comment by cremona created at 2017-01-11 08:43:34

Report on test:  after adding the dealloc method to the ECModularSYmbol class in the cython file newforms.pyx, and running the loop again, the memory usage is a lot less but it still sits at 13g at the end of the loop to 10000.  There must be something else not getting cleared.

The exact test is

```
DB = CremonaDatabase()
for N in range(1,10000):
     Cs = DB.isogeny_classes(N)
     for C in Cs:
         E=EllipticCurve(C[0][0])
         print(E.label())
         phi=E.modular_symbol()
```



---

Comment by cremona created at 2017-01-13 11:43:57

Changing status from new to needs_review.


---

Comment by cremona created at 2017-01-13 11:43:57

New commits:


---

Comment by cremona created at 2017-01-13 11:44:37

NB only the last commit is new to this ticket, the others are from #10256 (and #22077).


---

Comment by nbruin created at 2017-01-13 16:48:05

I notice these lines in the __init__

```
        C = new Curve(a1,a2,a3,a4,a6)
        CD = new Curvedata(C[0],0)
        CR = new CurveRed(CD[0])
```

for which I cannot find explicit "del"s elsewhere. Do these get deleted? I think normally every "new" should be paired with a "del". It could be that your objects disappear into another object and that deallocating them is done as part of the deallocation of that object, but then your interface have that documented and you should only access that object via the encapsulating object.


---

Comment by cremona created at 2017-01-13 17:11:52

I don't know the answer to that.  Perhaps I should try deallocating those too and seeing if it helps.  I did not write this wrapper and don't know cython wrapping at all well, but the difference is that thpse variables are local to the init function while the "new newforms..." is stored in self.


---

Comment by nbruin created at 2017-01-14 00:15:52

Replying to [comment:12 cremona]:
> I don't know the answer to that.  Perhaps I should try deallocating those too and seeing if it helps.  I did not write this wrapper and don't know cython wrapping at all well,

?? it's the C++ here (createfromcurve) that could do complicated stuff. That's yours, right?

> but the difference is that thpse variables are local to the init function while the "new newforms..." is stored in self.

Cython wouldn't be able to generate "del"s for these automatically without extensive flow analysis, though: Just because the result of "new" gets assigned to a pointer variable that is local doesn't imply that the value doesn't get stored in other places as well.

In this case it does look like you should be able to at least do a `del C; del CD; del CR` without problem: their values are only used in dereferenced form `C[0],CD[0],CR[0]`.

You would know if the routines `CurveData,CurveRed,getconductor,createfromcurve` do funny stuff (especially, if they take special measures such as "del"-ing their arguments!)

It does look like Tom must have been in a rather big hurry when he wrote this wrapper, or otherwise had a deep-rooted contempt for reusing memory.


---

Comment by jdemeyer created at 2017-01-14 08:59:56

As I mentioned on the mailing list, you don't need always need to use pointers. You could use just

```
cdef mytype obj = mytype(....)  # no del needed
```

instead of

```
cdef mytype* obj = new mytype(....)
del obj
```

This might not always work and might have performance implications, but it's at least something to try.


---

Comment by cremona created at 2017-01-14 19:44:35

If I replace

```
cdef Curve *C
```

by

```
cdef Curve C
```

I get the error

```
sage/libs/eclib/newforms.pyx:181:19: C++ class must have a nullary constructor to be stack allocated
```

even though the C++ class Curve _does_ have a nullary constructor (see line 73 in https://github.com/JohnCremona/eclib/blob/master/libsrc/eclib/curve.h).


---

Comment by nbruin created at 2017-01-14 22:43:16

Replying to [comment:15 cremona]:
> even though the C++ class Curve _does_ have a nullary constructor (see line 73 in https://github.com/JohnCremona/eclib/blob/master/libsrc/eclib/curve.h).

It looks like this signature isn't known to cython though, since it doesn't seem to be exposed in the `pxd` file: https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage/libs/eclib/__init__.pxd?h=u/cremona/22164&id=c0306ee08b94061ef1f525cdc71d24c17e004ce3#n45


---

Comment by jdemeyer created at 2017-01-15 09:17:46

Right. Cython never reads any `.h` files, it just generates `#include <foo.h>` statements. Cython only reads the `.pxd` file and according to that, there is no nullary constructor. That's of course easily fixed by add a line `Curve()` in the `cppclass Curve`.


---

Comment by cremona created at 2017-01-15 12:45:34

Thanks for the tips.   I am now trying the test again after adding those nullary constructors in the pxd file.  Before that, with "del C" and 2 similar, it made little difference: at the end of the loop there was 13g in use according to "top".

There is probably a better way to see how much memory is in use, from within Sage itself.  Can someone remind me?


---

Comment by nbruin created at 2017-01-15 20:41:29

When this was first reported I did look at `gc.get_objects()` and didn't find anything suspicious. So my guess is that the leaks are not happening on the python heap, but indeed (as indicated here) on some C++ or C heap. Valgrind would probably be your best bet.


---

Comment by cremona created at 2017-01-16 09:19:51

You are probably right.  I had a masters student parallelise some of the linear algebra code 2 or 3 years ago (code that is running in this loop) and later found through valgrind that there was a memory leak introduced then.  This is a real nuisance -- when eclib was first put into Sage I spent quite a while fixing all the valgrind issues, some of which were hard to track down. I spent a time last summer trying to find the problem here but did not succeed (see https://github.com/JohnCremona/eclib/issues/18).

I suppose this is a case of "reported upstream, waiting for a fix there".


---

Comment by cremona created at 2017-01-20 15:36:52

I am working on fixing the leak in eclib.  Meanwhile it seems that wrapping the eclib call as follows

```
`@`fork
def work_on(C):
    E=EllipticCurve(C)
    print(E.label())
    phi=E.modular_symbol()
    sys.stdout.flush()
    
DB = CremonaDatabase()

for N in range(1,10000):
     Cs = DB.isogeny_classes(N)
     for C in Cs:
         work_on(C[0][0])
```

avoids eating up memory: on a test run, it has reached 8000 (out of 10000) and does not go over 200k according to "top".


---

Comment by nbruin created at 2017-01-20 21:00:45

Replying to [comment:22 cremona]:

I see a research article coming out of this: Implementing a stack using "fork".


---

Comment by cremona created at 2017-01-20 21:43:19

Replying to [comment:23 nbruin]:
> Replying to [comment:22 cremona]:
> 
> I see a research article coming out of this: Implementing a stack using "fork".

Ha ha.  If you want to be helpful, how about this:  in line 96 of https://github.com/JohnCremona/eclib/blob/master/libsrc/arith.cc
in a class destructor, there is a delete command.  But according to valgrind the associated memory is not being deleted.  So I added a print statement just before the delete, and now it does delete -- and valgrind is happy.  But I cannot get this to work without adding a line which actually outputs something!  This still happens enve with no optimzation (-O0).


---

Comment by nbruin created at 2017-01-21 00:10:19

Replying to [comment:24 cremona]:
> Ha ha.  If you want to be helpful, how about this:  in line 96 of https://github.com/JohnCremona/eclib/blob/master/libsrc/arith.cc
> in a class destructor, there is a delete command.  But according to valgrind the associated memory is not being deleted.  So I added a print statement just before the delete, and now it does delete -- and valgrind is happy.

It's hard to believe a C++ compiler would make an error with something that simple. Have you verified valgrind is right, i.e., if you run something along the lines:

```
    int i;
    primeclass *P;
    for ( i=0; i<1000000; i++){
        P = new primeclass;
        P->init(10000);
        delete P;
    };
```

do you see memory leaking? My guess would be that valgrind somehow misses the free ...


---

Comment by cremona created at 2017-01-21 09:18:56

There was a logical explanation (of course) but quite a strange one.  I was running a test program from my test suite (as done by "make check") but running independently to use valgrind.  Using the standard test input file. However for this test, the input file contains a filename and the program attempts to open that.  In this scenario the file does not exist (the Makefile copies it from somewhere else) and the test program calls abort().  So while it is still strange that whether or not the destructor is called on abort() depends on there being code to produce output in the destructor, it was all a big red herring...


---

Comment by cremona created at 2017-01-25 19:51:41

I think I have fixed the memory leaks.  Rather than open a new ticket for upgrading eclib again I'll do that on this ticket, and the test that it can be accepted should include running the loop given here without memory usage growing.


---

Comment by git created at 2017-01-27 09:10:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2017-01-27 09:16:30

The branch u/cremona/22164 at commit 290f045 now includes (1) addition of a missing dealloc, (2) addition of null constructors for 3 eclib classes so pointers are not needed when constructing these, and (crucially) (3) a new eclib version which fixes the memory leak.  It was also merged with 7.6.beta0.

The new eclib is at http://homepages.warwick.ac.uk/staff/J.E.Cremona/ftp/eclib-20170122.tar.bz2

There are no changes there except for the bug fix, so no chenges needed to Sage except the package version and checksum change.

I tested this with the original loop over conductors to 10000 and the memory in use was totally under control.  

Please review!


---

Comment by jpflori created at 2017-01-31 11:13:18

Maybe you could add a doctest to show the memory is now under control?


---

Comment by cremona created at 2017-01-31 12:18:09

That is a good idea.  I will.


---

Comment by cremona created at 2017-01-31 12:25:43

Would something like this be OK?  Before:

```
sage: get_memory_usage()
134024.41796875
sage: for E in cremona_curves([380,400]):
....:     M = E.modular_symbol()
sage: get_memory_usage()
134070.73046875
```


After:

```
sage: get_memory_usage()
136320.72265625
sage: for E in cremona_curves([380,400]):
....:     M = E.modular_symbol()
....:     
sage: get_memory_usage()
136322.546875
```


Anything showing a greater leakage will take longer (the above is just a few seconds).  If the run goes from 11 to 400 instead then the usage goes up by 49 before and 2 after.


---

Comment by nbruin created at 2017-01-31 19:49:36

So the test should probably be something like

```
T=get_memory_usage()
for E in cremona_curves([380,400]):
    M = E.modular_symbol()
assert get_memory_usage(T) < 4
```

The value you're getting out of this will be very much dependent on the weather and the architecture you're running on, so you have to be a bit conservative in test failure to avoid too many false positives.


---

Comment by jdemeyer created at 2017-01-31 20:33:21

I remember discussing this for another application.

The best way to check that `foo()` does not leak memory is to run `foo()` a number of times and record the memory usage m<sub>i</sub> after each call of `foo()`. There is no memory leak if, for some index i, we have m<sub>i+j</sub> ≤ m<sub>i</sub> for all j = 1, ..., N (for some suitable fixed value of N like N=10).

Put in a different way: there is no memory leak if you are able to run `foo()` N times where the memory never increases beyond the initial memory usage, but allowing for a few initial calls of `foo()` where the memory is allowed to increase.


---

Comment by cremona created at 2017-01-31 21:10:05

The trouble with using this general strategy is that elliptic curves are cached, so something like

```
sage: get_memory_usage()
66277.4609375
sage: for _ in range(100):
....:     M = EllipticCurve('90a1').modular_symbol()
....:     
sage: get_memory_usage()
66277.4609375
```

shows nothing useful (in this run I had already created the modular symbol for this curve).  However one could use:

```
sage: from sage.libs.eclib.newforms import ECModularSymbol
```

directly.
Testing this I get the impression that there is a speed regression in the new version which needs to be looked into.  If you see the same, this will have to wait, and will be several days before I can work on it further.


---

Comment by cremona created at 2017-02-01 17:05:10

There is a speed regression compared with the version in 7.5 but I think this is already true for the eclib version already merged into 7.6, and it has a reason:  to get the normalization right for modular symbols (which is what that eclib upgrade was all about) one has to compute some periods to a certain precision, which requires computing a few hundred ap and then doing the numerical integration (summing series).  So there was a price to pay for getting the normalization right, and that should not stop this bug-fix leak fix going in.

I don't have time to provide more exact data now.


---

Comment by jdemeyer created at 2017-02-01 17:14:52

You can use

```
EllipticCurve('90a1').modular_symbol.clear_cache()
```

to clear the cache.


---

Comment by cremona created at 2017-02-02 09:37:38

I'm setting back to Needs Work while I add a test to show that the leak is fixed.


---

Comment by cremona created at 2017-02-02 09:37:38

Changing status from needs_review to needs_work.


---

Comment by cremona created at 2017-02-02 09:52:54

OK, so I am adding this test:

```
sage: from sage.libs.eclib.newforms import ECModularSymbol
sage: E = EllipticCurve([1,1,0,-108,-432]) # conductor 930
sage: mem = get_memory_usage()
sage: for _ in range(10): M = ECModularSymbol(E)
sage: mem2 = get_memory_usage()
sage: mem2-mem # random
3.34375
```

where the above shows a leak of 3.3MB before; after, it is 0.0.


---

Comment by git created at 2017-02-02 10:11:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2017-02-02 10:12:07

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-02-13 10:06:35

First of all, the branch needs to be rebased.

Second, I'm not totally convinced by the memleak test code: the `mem2 - mem < 1` seems rather arbitrary. Although, if it passes doctests, I can accept it.

Still, I suggest to change

```
        sage: mem2-mem # random
        0.75
        sage: assert(mem2-mem < 1)
```

to

```
        sage: (mem2 - mem < 1) or (mem2 - mem)
        True
```

This use of `or` in doctests is a neat trick I learned from Robert Bradshaw: in case of failure, you will see the actual value of `mem2 - mem`.


---

Comment by jdemeyer created at 2017-02-13 10:06:35

Changing status from needs_review to needs_work.


---

Comment by cremona created at 2017-02-13 10:38:45

I'll make the suggested changes.  I tested on more than one machine and found the exact difference mem2-mem was not the same in all runs.  It is certainly less than before though!   And certainly, the problem is much more severe after running several large examples, but these take too long for a doctest.


---

Comment by cremona created at 2017-02-13 12:17:26

I hope you will be happy with a merge of develop into my branch rather than a literal rebase.


---

Comment by jdemeyer created at 2017-02-13 12:19:44

Absolutely.


---

Comment by git created at 2017-02-13 14:29:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2017-02-13 14:30:44

OK, try this.


---

Comment by cremona created at 2017-02-13 14:30:44

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-02-13 14:34:19

Where are the eclib sources? Please put an obvious link in the ticket description.


---

Comment by jdemeyer created at 2017-02-13 14:34:19

Changing status from needs_review to needs_info.


---

Comment by cremona created at 2017-02-13 14:45:19

Sorry!


---

Comment by cremona created at 2017-02-13 14:45:19

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2017-02-13 15:05:49

Please add a doctest

```
sage: ECModularSymbol.__new__(ECModularSymbol)
Modular symbol with sign 0 over Rational Field attached to None
```

to show that this doesn't crash Sage.

The reason I ask this is that a non-trivial `__dealloc__` has potential to crash Sage if it makes assumptions which are not satisfied after `__new__`.

Here, there is no problem because Cython initializes `self.nfs = NULL` in `__new__` and deleting a `NULL` pointer is safe.


---

Comment by jdemeyer created at 2017-02-13 15:05:49

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-02-13 15:48:04

Apart from the doctest for `__new__`, this ticket looks good.


---

Comment by git created at 2017-02-13 16:28:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2017-02-13 16:29:20

OK done.  I would never have thought of that...


---

Comment by cremona created at 2017-02-13 16:29:25

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-02-14 09:32:12

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-02-15 21:27:35

On OSX I get:

```
sage -t --long src/sage/libs/eclib/newforms.pyx
4157**********************************************************************
4158File "src/sage/libs/eclib/newforms.pyx", line 135, in sage.libs.eclib.newforms.ECModularSymbol
4159Failed example:
4160    (mem2-mem < 1) or (mem2 - mem)
4161Expected:
4162    True
4163Got:
4164    2.0
4165**********************************************************************
41661 item had failures:
4167   1 of  41 in sage.libs.eclib.newforms.ECModularSymbol
4168    [96 tests, 1 failure, 60.32 s]
4169
```



---

Comment by vbraun created at 2017-02-15 21:27:35

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2017-02-15 21:42:18

I was afraid that something like this might happen. I suggest to either remove the test or implement [comment:35].


---

Comment by cremona created at 2017-02-15 21:45:45

I have no way to test on OSX.  This number is going to vary a lot from machine to machine.  I only put in a test like this because an earlier reviewer wanted me to.  there is no significance at all to the memory difference except that it is less than with the old code, and there is no way to test that!

I was going to suggest just removing this test, but I see that Jeroen is suggesting that his earlier proposal is implemented.  Well, I am not going to promise to do that since I am busy and it already took several days work actually fixing some leaks.


---

Comment by jdemeyer created at 2017-02-16 06:44:52

Replying to [comment:60 cremona]:
> Jeroen is suggesting that his earlier proposal is implemented.

Please read my comment again carefully :-)


---

Comment by cremona created at 2017-02-16 10:21:06

Yes, I spotted that.  I am not sure that Volker would be happy to have no doctest?

In fact a task I had to do today took less time than I expected so I can have a go at implementing the suggestion at 35 above.


---

Comment by cremona created at 2017-02-16 10:30:39

This looks good.  AFter

```
sage: E = EllipticCurve([1,1,0,-108,-432])
sage: def foo():
....:     M = ECModularSymbol(E)
sage: from sage.libs.eclib.newforms import ECModularSymbol
```

we have

```
sage: print(get_memory_usage())
136409.183594
sage: for _ in range(30):
....:     foo()
....:     print(get_memory_usage())
....:     
136409.367188
136409.367188
136409.367188
136409.367188
136409.367188
136409.367188
136409.367188
136409.367188
136409.367188
```

etc ad infinitum (or 30, whichever comes first).  This is a much better test since on anothe rmachine without the new version it looks like

```
sage: print(get_memory_usage())
66302.7304688
sage: for _ in range(30):
....:     foo()
....:     print(get_memory_usage())
....:     
66303.03125
66303.3242188
66303.6171875
66303.9492188
66304.2851562
66304.6210938
66304.9570312
66305.2929688
66305.6289062
66305.9648438
66306.3007812
66306.6328125
66306.96875
66307.3046875
66307.640625
66307.9765625
66308.3125
66308.6484375
66308.9804688
66309.3164062
66309.6523438
66309.9882812
66310.3242188
66310.6601562
66310.9960938
66311.3320312
66311.6640625
66312.0
66312.3359375
66312.671875
```


This suggest that in the doctest I should compare the memory usage after 1 and 10 calls rather than 0 and 10 as it is now.


---

Comment by git created at 2017-02-16 10:46:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2017-02-16 10:48:49

OK, here's a new version of the doctest.  It calls ECModularSymbol() twice before recording the first memory usage, then (as before) 10 more times before taking the second reading.  And to avoid comments about arbitrariness I test these for equality -- which works for me but is possibly too strict.

Please test again.


---

Comment by cremona created at 2017-02-16 10:48:49

Changing status from needs_work to needs_review.


---

Comment by cremona created at 2017-03-10 20:27:50

ping!


---

Comment by jdemeyer created at 2017-03-10 21:36:41

Somehow I thought this ticket was already finished...


---

Comment by jdemeyer created at 2017-03-14 18:29:59

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-03-14 18:29:59

You should mark all those memory tests as `# long time`.


---

Comment by cremona created at 2017-03-14 19:29:19

Replying to [comment:68 jdemeyer]:
> You should mark all those memory tests as `# long time`.

The lines which take a long time are tagged # long time already!  So I suppose you mean the lines which call get_memory_usage() too?  That is hardly necessary, is it?


---

Comment by jdemeyer created at 2017-03-14 19:49:39

Replying to [comment:69 cremona]:
> Replying to [comment:68 jdemeyer]:
> > You should mark all those memory tests as `# long time`.
> 
> The lines which take a long time are tagged # long time already!  So I suppose you mean the lines which call get_memory_usage() too?

Yes, I mostly mean the final line `(mem2==mem) or (mem2 - mem)`

> That is hardly necessary, is it?

Technically you are right, but it looks strange to me to run the memory tests when you are _not_ calling `ECModularSymbol(E)`. It is actually a bit dangerous since even running `mem = get_memory_usage()` might change the amount of memory allocated. So it would give me peace of mind to mark those tests as `# long time` too.


---

Comment by git created at 2017-03-14 19:55:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2017-03-14 19:55:48

Done
----
New commits:


---

Comment by cremona created at 2017-03-14 19:55:48

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-03-15 09:30:38

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-03-15 09:30:38

Sorry to spoil the party, but this regularly fails on OS X:

```
sage -t --long --warn-long 145.1 src/sage/libs/eclib/newforms.pyx
**********************************************************************
File "src/sage/libs/eclib/newforms.pyx", line 137, in sage.libs.eclib.newforms.ECModularSymbol
Failed example:
    (mem2==mem) or (mem2 - mem)                 # long time
Expected:
    True
Got:
    1.0
**********************************************************************
1 item had failures:
   1 of  42 in sage.libs.eclib.newforms.ECModularSymbol
    [97 tests, 1 failure, 41.65 s]
sage -t --long --warn-long 145.1 src/sage/libs/eclib/newforms.pyx
    [97 tests, 41.31 s]
sage -t --long --warn-long 145.1 src/sage/libs/eclib/newforms.pyx
    [97 tests, 41.64 s]
sage -t --long --warn-long 145.1 src/sage/libs/eclib/newforms.pyx
**********************************************************************
File "src/sage/libs/eclib/newforms.pyx", line 137, in sage.libs.eclib.newforms.ECModularSymbol
Failed example:
    (mem2==mem) or (mem2 - mem)                 # long time
Expected:
    True
Got:
    2.0
**********************************************************************
1 item had failures:
   1 of  42 in sage.libs.eclib.newforms.ECModularSymbol
    [97 tests, 1 failure, 41.72 s]
sage -t --long --warn-long 145.1 src/sage/libs/eclib/newforms.pyx
**********************************************************************
File "src/sage/libs/eclib/newforms.pyx", line 137, in sage.libs.eclib.newforms.ECModularSymbol
Failed example:
    (mem2==mem) or (mem2 - mem)                 # long time
Expected:
    True
Got:
    17.0
**********************************************************************
1 item had failures:
   1 of  42 in sage.libs.eclib.newforms.ECModularSymbol
    [97 tests, 1 failure, 42.46 s]
```



---

Comment by cremona created at 2017-03-15 10:35:50

What a pain.  I don't use Macs.  I do not test eclib on Macs.  If someone told me tomorrow that eclib does no longer work on some Mac system I would do absolutely nothing about it except possibly to put a warning into its documentation and wait for someone else to fix it.  Ditto cygwin.  Ditto clang, whatever that is.

It took quite a long time to track down the leak and fix it.  It has taken far longer to write a doctest which keeps people happier -- still not finished with that.  It is *obvious* that the memory used will be machine dependent, hance *stupid* to have a doctest which relies on some measure of memory.  The only sensible measure is to compare the amount of memroy in use before and after the patch, one the same machine, and the doctesting system cannot do that.

Please can we delete this doctest entirely?  It is in any case not testing that part of Sage works, only that part  of one of its dependencies does.  If that would get this into 7.6 that would be worth something.

I will delete the doctest.  That is absolutely the last contribution I will make to this ticket.


---

Comment by git created at 2017-03-15 10:39:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-03-15 11:29:57

Replying to [comment:74 cremona]:
> The only sensible measure is to compare the amount of memroy in use before and after the patch, one the same machine

That's not true. There are robust ways to test memory leaks, see [comment:35]. Of course, it's more work, but it can be done. Maybe we should have some Sage infrastructure for this, say `test_memory_leak(func)` for a function `func`.

> I will delete the doctest.

Fine for me. It will allow this ticket to finally move forward.


---

Comment by jdemeyer created at 2017-03-15 12:00:57

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2017-03-27 20:42:44

Resolution: fixed
