# Issue 31796: lcm broken in corner cases on certain polynomial rings

Issue created by migration from https://trac.sagemath.org/ticket/32033

Original creator: @EnderWannabe

Original creation time: 2021-06-22 17:05:25

CC:  bhutz

Keywords: gsoc2021

Currently, the following code fails, throwing a zero division error:


```
sage: K.<t> = GF(2)[]
sage: lcm(K(0), K(0))
```


As does

```
sage: K.<t> = RR[]
sage: lcm(K(0), K(0))
```


This ticket attempts to fix these errors.


---

Comment by @EnderWannabe created at 2021-06-22 17:13:34

One fix would be to add a try except block to polynomial_element.pyx:


```
def lcm(self, other):
    try:
        f = self*other
        g = self.gcd(other)
        q = f//g
        return ~(q.leading_coefficient())*q
    except:
        return 0
```



---

Comment by roed created at 2021-06-23 07:21:17

Seems okay, but make sure to use `except ZeroDivisionError:` instead of `except:` (which should never be used since it catches `KeyboardInterrupts`).


---

Comment by roed created at 2021-06-23 07:21:54

Also note that there are special implementations elsewhere, such as `sage.rings.polynomial.polynomial_integer_dense_flint`.


---

Comment by @EnderWannabe created at 2021-06-23 16:03:50

Replying to [comment:3 roed]:
> Also note that there are special implementations elsewhere, such as `sage.rings.polynomial.polynomial_integer_dense_flint`.

Thanks, added a try except block there as well.

The fix doesn't seem to break anything - I ran all tests.

Should we add a test to test for the fix?
----
New commits:


---

Comment by roed created at 2021-06-23 16:41:57

Yep, if you're fixing a bug you should always add a test to show that it has been fixed.  In this case, just an `lcm(R(0), R(0))` in each case will be sufficient.


---

Comment by roed created at 2021-06-23 16:43:14

You should also point to this ticket using `:trac:`32033``.


---

Comment by git created at 2021-06-23 18:06:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @EnderWannabe created at 2021-06-23 18:07:13

Changing status from new to needs_review.


---

Comment by @DaveWitteMorris created at 2021-06-23 18:19:33

I searched the sage source, and I think the other occurrences of this problem are:
	* `def _lcm(self, other)` in src/sage/rings/polynomial/polynomial_element.pyx (line 4894)
	* `def lcm(self, ntl_ZZX other)` in /src/sage/libs/ntl/ntl_ZZX.pyx (line 680)
	* `def lcm(self, MPolynomial_libsingular g)` in src/sage/rings/polynomial/multi_polynomial_libsingular.pyx (line 4862)
	* `def lcm(self, right)` in src/sage/rings/polynomial/polynomial_integer_dense_ntl.pyx (line 595)

Can these all be fixed here, or do we need another ticket for some of them?  (I think at least the first one should certainly be done here.)


---

Comment by @EnderWannabe created at 2021-06-23 18:55:04

Replying to [comment:10 gh-DaveWitteMorris]:
> Can these all be fixed here, or do we need another ticket for some of them?  (I think at least the first one should certainly be done here.)


The first one will definitely throw an error and we can fix that one here.

The one in ntl_ZZX also throws an error:

```
x1 = ntl.ZZX([0,0,0,0])
x1.lcm(x1)
```


But I am unsure how to fix it. If someone else would like to fix it here or create a ticket for it, that would be appreciated.

The multivariate polynomial works in some cases:

```
K.<t,z> = GF(3^4)[]
lcm(K(0), K(0))
0
```


But throws an error over CC for some reason:


```
K.<t,z> = CC[]
lcm(K(0), K(0))
ValueError
```


Not sure what is going on there.


The last one throws an ArithmeticError:


```
R.<x> = PolynomialRing(ZZ, implementation='NTL')
R(0).lcm(R(0))
```


So I'll push a fix and test for that.


---

Comment by git created at 2021-06-23 18:58:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-06-24 00:24:44

I feel like this is a very roundabout approach. If either one of the factors is `0`, which should be quick to check, then I would just return `0` immediately.


---

Comment by @EnderWannabe created at 2021-06-27 16:01:58

Replying to [comment:13 tscrim]:
> I feel like this is a very roundabout approach. If either one of the factors is `0`, which should be quick to check, then I would just return `0` immediately.


The idea for a try except block is that lcm is almost never called on 0, so adding an if statement that runs in all cases would be slower overall. The try except block should be quicker in 99% of cases, but slower 1% when lcm is called on 0.

This is similar to the implementation for elements of QQ, where a calculation is attempted inside a try except block, and in the case where an error is thrown, they check to see if 0 or 1 should be returned.


---

Comment by tscrim created at 2021-06-28 00:08:12

Replying to [comment:14 gh-EnderWannabe]:
> Replying to [comment:13 tscrim]:
> > I feel like this is a very roundabout approach. If either one of the factors is `0`, which should be quick to check, then I would just return `0` immediately.
> 
> 
> The idea for a try except block is that lcm is almost never called on 0, so adding an if statement that runs in all cases would be slower overall. The try except block should be quicker in 99% of cases, but slower 1% when lcm is called on 0.

The act of computing the `lcm` should be significantly more than the `is_zero()` check. So I feel any slowdown will be negligible and is not worth the extra code complexity. While it is not much, it does take a bit more time to parse and could accidentally catch some other error (especially the `ArithmeticError`), making thing harder to debug.

> This is similar to the implementation for elements of QQ, where a calculation is attempted inside a try except block, and in the case where an error is thrown, they check to see if 0 or 1 should be returned.

Actually, `Rational._lcm` does a zero check first. Note, however, that the code in `QuotientFields.ElementMethods.lcm` doesn't redirect there. That code works there because it redirects to the `lcm` in `ZZ` and does `0/1`. You can also look specifically that the `try-except` block there does **not** catch an `ArithmeticError` (or a `ZeroDivisionError`).

From what I see, much of Sage does the zero check first rather than wrap via a `try`-`except` block. At some point, we probably should deal with inconsistencies between the category level implementations and the stuff via subclasses of `Element`. Yet, that is a separate ticket.

For the `K.<t,z> = CC[]` case, you just don't have an `lcm` method defined there. We probably should implement something for UFDs, which I believe has existence and uniqueness (up to a unit).

Now I am not strictly opposed to this way of fixing things, but I think these things should be weighed before committing to them. Perhaps someone else can comment on this?


---

Comment by roed created at 2021-06-29 04:06:35

I agree with Travis that an `if` statement is better from a readability point of view, and that the speed difference will be negligible.  I also don't feel strongly, so if the author of this ticket would prefer to use the `try` block I think that getting this bug fixed is more important than the decision of which way to do it.


---

Comment by @EnderWannabe created at 2021-06-29 14:34:00

Replying to [comment:16 roed]:
> I agree with Travis that an `if` statement is better from a readability point of view, and that the speed difference will be negligible.

Makes sense to me, pushed a branch with an if statement instead of a try except block.


---

Comment by git created at 2021-06-29 14:34:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-06-29 22:08:48

Thank you. Please add your name to the authors field and we will wait for the patchbot.


---

Comment by tscrim created at 2021-07-02 05:22:13

LTGM. Thank you.


---

Comment by tscrim created at 2021-07-02 05:22:13

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-07-09 20:23:32

Resolution: fixed
