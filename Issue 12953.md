# Issue 12953: Reals sets consisting of intervals and isolated points, supporting integration.

Issue created by migration from Trac.

Original creator: ares

Original creation time: 2012-06-16 23:25:47

Assignee: Ares RibÃ³

CC:  kcrisman tscrim robertwb

This is based of previous work available from
     http://www.mail-archive.com/sage-support`@`googlegroups.com/msg21326.html
but supporting now integration on real intervals and real sets.

Laurent Claessens defined a class Interval that represents an interval (can be open, closed, half open, unbounded), and implemented union() and intersection() methods, as well as the __contains__() method that tests if a number is contained in the interval. Also defined the class ContinuousSet represening finite union and intersections of intervals by a list of disjoint intervals, and for this class ContinuousSet, union() and __contain__() methods were implemented.

We extend the previous work of Laurent Claessens defining the class RealSet, that describes any real set as a list of disjoint intervals and a list of isolated points.  We define the class RInterval of real intervals. A RInterval is now a RealSet, consituted as a list of disjoint intervals with a unique element and an empty list of isolated points. Our class RInterval is now always an open interval. The boundary/ies can be added as isolated point/s if necessary, constituting a RealSet.

For the class RealSet, we implement the intersection(), union() and __contain__(). We implement the function 'subsets' that, given two different real sets A and B, returns if A is a (proper) subset of B, and the function 'setdiff' that returns the difference of two given real sets. We implement also the infimum and the supremum of a RealSet. 

Also we support definite integration over a RealSet.


---

Comment by kcrisman created at 2012-06-17 00:30:35

Patch?


---

Comment by ares created at 2012-06-18 00:10:20

Replying to [comment:3 kcrisman]:
> Patch?
uploaded


---

Comment by vbraun created at 2013-06-20 23:52:53

Initial patch


---

Comment by vbraun created at 2013-06-20 23:56:36

Changing status from new to needs_review.


---

Attachment

I'm taking over this ticket since I need this for piecewise functions. I'm not sure what happened with the originally proposed patch, but what was attached here is not the actual code.


---

Comment by kcrisman created at 2013-06-21 00:12:03

Is `+` what we're looking for here?   Maybe something like `u` or `U`?  Just worried about the difference between this "sum" and the Minkowski sum (which is, in fact, already in Sage).

In fact, maybe these should inherit from something related to that... probably not, but just raising the possibility.

How do I get more exotic sets like the union of `1/n` for positive integer n?  ;-)


---

Comment by novoselt created at 2013-06-21 02:59:24

It think it is better to stick to the category of finite unions of intervals and points, then with functions defined on such sets and their periodic extensions (like 1 on [0, 1], 0 on (1,2), then extend periodically in one or both directions to get square wave).

Things with infinite unions lead to accumulation points and cannot really be handled in a uniform way, I suspect.


---

Comment by kcrisman created at 2013-06-21 05:06:51

Yes, I was being silly :)


---

Attachment

Patch for realsets.py


---

Comment by ares created at 2013-06-22 01:44:08

I just attached the original patch. I did not notice before that the initial patch was not correctly uploaded, I am very sorry for that.


---

Attachment

Updated patch


---

Comment by vbraun created at 2013-06-23 00:55:36

I've added the authors to my patch and incorporated any methods that made sense to me. Ares, since your patch would take a bit of work to make use of the Sage class hierarchy and since docstrings are not quite according to Sage specs I propose that we base the implementation on what I have currently posted. The imho only thing left is to decide what to do with the `toGf` method. Which is some third-party code, I suppose. Maybe you can explain what it is for? If you think it should go into Sage we could turn it into a underscore method.


---

Comment by ares created at 2013-06-24 23:04:32

Replying to [comment:12 vbraun]:
> I've added the authors to my patch and incorporated any methods that made sense to me. Ares, since your patch would take a bit of work to make use of the Sage class hierarchy and since docstrings are not quite according to Sage specs I propose that we base the implementation on what I have currently posted. The imho only thing left is to decide what to do with the `toGf` method. Which is some third-party code, I suppose. Maybe you can explain what it is for? If you think it should go into Sage we could turn it into a underscore method.

We will move the toGf method into another paquet, since we use it to support our MOLTO project demo (D6.2.pdf) and it is not directly related to realsets.


---

Comment by rws created at 2014-02-23 10:04:32

Looks and tests fine. I've fixed some typos and added the module to the reference manual.
----
New commits:


---

Comment by rws created at 2014-02-23 10:04:32

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-03-04 13:19:41

Fails on OSX:

```
sage -t --long src/sage/sets/real_set.py
**********************************************************************
File "src/sage/sets/real_set.py", line 1156, in sage.sets.real_set.RealSet.intersection
Failed example:
    s1.intersection(s2)
Expected:
    (1, 2)
Got:
    (-oo, -10] + (1, 2)
**********************************************************************
File "src/sage/sets/real_set.py", line 1158, in sage.sets.real_set.RealSet.intersection
Failed example:
    s1 & s2    # syntactic sugar
Expected:
    (1, 2)
Got:
    (-oo, -10] + (1, 2)
**********************************************************************
1 item had failures:
   2 of  11 in sage.sets.real_set.RealSet.intersection
    [191 tests, 2 failures, 0.14 s]
```



---

Comment by vbraun created at 2014-03-04 14:13:13

In fact, only fails on OSX 10.9.2 but works on 10.6... weird.


---

Comment by saludes created at 2014-03-06 07:09:35

It fails in OSX 10.7.5 too.
The error seems to be in the comparation involving one `sage.rings.real_lazy.LazyWrapper` instance:

```
sage: s1 = RealSet(0,2) + RealSet.unbounded_above_closed(10);  s1
(0, 2) + [10, +oo)
sage: s2 = RealSet(1,3) + RealSet.unbounded_below_closed(-10);  s2
(-oo, -10] + (1, 3)
sage: s1.intersection(s2)
(-oo, -10] + (1, 2)
```

Not right. Look at the intersection of the first intervals:

```
sage: i1 = s1._intervals[0]; i1
(0, 2)
sage: i2 = s2._intervals[0]; i2
(-oo, -10]
sage: i1.intersection(i2)
(-oo, -10]
```

Wrong. Compare the bounds:

```
sage: (i1._lower, i2._lower)
(0, -Infinity)
sage: cmp(i1._lower, i2._lower)
-1
sage: i1._lower < i2._lower
True
```

It doesn't fail for floats or integers:

```
sage: 0.0 < i2._lower
False
sage: type(i1._lower), type(i2._lower)
(sage.rings.real_lazy.LazyWrapper, sage.rings.infinity.MinusInfinity)
```



---

Comment by rws created at 2014-03-06 09:18:53

Confirm different (correct) behaviour on Linux:


```
...
sage: s1.intersection(s2)
(1, 2)
...
sage: i1.intersection(i2)
(0, 0)
...
sage: cmp(i1._lower, i2._lower)
1
sage: i1._lower < i2._lower
False
```



---

Comment by saludes created at 2014-03-06 09:22:14

More specifically, it seems to fail only when comparing to zero (OSX 10.7.5):


```
sage: filter(lambda x: RLF(x) < -oo, range(-10,10))
[0]
sage: filter(lambda x: RLF(float(x)/3) < -oo, range(-10,10))
[0]
```


and `+oo` is not affected:

```
sage: filter(lambda x: RLF(x) >= oo, range(-10,10))
[]
```



---

Comment by git created at 2014-03-06 09:32:00

Changing status from positive_review to needs_review.


---

Comment by git created at 2014-03-06 09:32:00

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by rws created at 2014-03-06 09:38:12

Changing status from needs_review to needs_work.


---

Comment by saludes created at 2014-03-24 07:40:39

Replying to [comment:24 rws]:
What to do now? Since the problem seems to be related with `RLF`, should we open a new ticket and redirect this to the new one?


---

Comment by vbraun created at 2014-03-24 08:14:56

My guess is that the problem is comparisons with infinity, I noticed some wonky behavior when I wrote the patch. Its tricky to debug since it apparently depends on the position of objects in memory (the fall-back comparison order).


---

Comment by rws created at 2014-03-31 16:28:39

Changing status from needs_work to positive_review.


---

Comment by rws created at 2014-03-31 16:28:39

Replying to [comment:25 saludes]:
> Replying to [comment:24 rws]:
> What to do now? Since the problem seems to be related with `RLF`, should we open a new ticket and redirect this to the new one?

If it happens on OSX only then it cannot be in this patch, so I'll set to positive. Now it depends on if people on OSX can reproduce the problem without this patch or not; by the above reasoning it should be possible. If so, please open a ticket. If not you should wait until this one is in Sage.


---

Comment by rws created at 2014-03-31 16:39:26

Um, I just see that the problem code doesn't even need this patch, so I'll go ahead and open that ticket myself.


---

Comment by rws created at 2014-04-21 07:43:27

Anything missing for this ticket being accepted?


---

Comment by vbraun created at 2014-04-21 09:56:42

Sorry, I wanted to have a look at the changes but haven't had the time yet.


---

Comment by vbraun created at 2014-04-21 14:29:07

I've added some tests for comparison with infinity; these need to be fixed before the ticket is usable. One of the gems on my machine is

```
sage: RLF(0) < oo
False
```

----
New commits:


---

Comment by vbraun created at 2014-04-21 15:05:05

See also #15004


---

Comment by vbraun created at 2014-04-21 19:47:14

There was some work in #14045 to fix comparison with `float('inf')` but didn't go any further.


---

Comment by git created at 2014-04-21 20:56:02

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2014-04-21 20:56:02

Changing status from positive_review to needs_review.


---

Comment by tscrim created at 2014-04-22 02:35:50

I don't like this change:

```diff
+        elif isinstance(x, sage.rings.real_mpfi.RealIntervalFieldElement):
+            if x.upper().is_infinity() or x.lower().is_infinity():
                 return self.gen()
```

since `RIF(0, oo)` gets turned into infinity (where is very likely to not be):

```
sage: UnsignedInfinityRing(RIF(2, oo))
Infinity
```

I think we should follow the usual paradigm for RIF:

```
sage: RIF(2, 4) == 4
False
sage: RIF(2, 4) <= 4
True
sage: RIF(2, 4) < 4
False
sage: RIF(2) == 2
True
```

So I would say this is wrong:

```
sage: RIF(2, oo) == oo
True
```

and I would raise an error anytime we're converting something which is not directly equal to a (signed) infinity. For example:

```
sage: UnsignedInfinityRing(RIF(2, oo))
Infinity
```

should raise an error, but this would be okay:

```
sage: UnsignedInfinityRing(RIF(oo, oo))
Infinity
```



---

Comment by vbraun created at 2014-04-22 09:26:25

The question is not whether or not you like a pony, but if and how RIF should coerce into the infinity ring. The way Sage works is that everything that should be comparable with infinity can be coerced into the infinity ring, so if you ever compare with infinity the comparison is done there. If you don't have a coercion (e.g. RIF before this ticket) then you will get undesirable answers from the fallback comparison (=memory location).  

So if = yes, the only question is how. Semi-infinite intervals can either coerce into infinity, or "less than infinity", or zero (the only elements of the infinity ring). Its pretty clear that anything not infinite is undesirable.


---

Comment by git created at 2014-04-22 10:36:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-04-22 10:44:51

I forgot that SR can also represent infinity and *conversion* to the infinity ring should work. For SR there is no coercion to the infinity ring since SR wants to handle its own infinities (in fact: the infinity ring coerces into SR).

Arguably that should be changed and SR also coerce into the infinity ring instead of the other way round. But then SR wouldn't be able to react to things like `oo * x`. Downside of the current way is 

```
sage: bool(SR(-1000) > oo), bool(SR(-1000) < oo)
(False, False)
```

i.e. SR doesn't know how to decide this rather simple inequality. In any case, thats for another ticket.


---

Comment by rws created at 2014-05-15 08:23:53

Merge conflicts.


---

Comment by rws created at 2014-05-15 08:23:53

Changing status from needs_review to needs_work.


---

Comment by git created at 2014-05-15 09:52:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-05-15 09:53:41

Fixed


---

Comment by vbraun created at 2014-05-15 09:53:41

Changing status from needs_work to needs_review.


---

Comment by git created at 2014-05-19 10:08:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-05-19 10:09:36

I've removed the grant acknowledgement and will put it whereever we agree on in https://groups.google.com/d/msg/sage-devel/_NtS2b8W3uo/BsBz6IcLn4cJ


---

Comment by pbruin created at 2014-05-20 15:46:49

I'm mostly happy with the fixes related to infinity, although we are nowhere close to fixing all the bugs in #11506.  Of the examples listed there, the following one is changed by this ticket:

```
sage: InfinityRing(CC(oo))
A positive finite number
```

This used to return `+Infinity`, which is not perfect either, but is at least consistent with `InfinityRing(UnsignedInfinity(oo))`.  (I'd argue that both of these should probably be undefined, since complex and unsigned infinity are in no way more positive than negative.)

Could you fix the above example to return `+Infinity` again?

I leave it to someone else to review the new code for real sets.  It would have been better if the infinity-related stuff had been done on a separate ticket.


---

Comment by git created at 2014-05-20 15:55:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vbraun created at 2014-05-20 15:58:01

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-05-20 15:58:01

Agree that it should be a separate ticket. It just wasn't clear to me in the beginning that things were this messed up. I've split off the fixing-infinity part into #11506


---

Comment by tscrim created at 2014-05-20 16:03:19

Changing status from positive_review to needs_info.


---

Comment by tscrim created at 2014-05-20 16:03:19

I let this slip off, sorry Volker. I think there should be no coercion because there is no way to deal with these (semi)infinite intervals. However if we are forced to make this a coercion, then it should be less than infinity since my (very anecdotal) evidence says that most computations won't escape to `oo`, but instead just don't have a good upper bound.

That being said, I think this should not be positively reviewed as it stands.

Do you think Nils would be a good person to ask about this, someone else, or go directly to sage-devel?


---

Comment by vbraun created at 2014-05-20 16:05:35

I've moved all infinity-related commits to #11506, let's move the discussion there.

No coercion means: comparison by memory location.


---

Comment by tscrim created at 2014-05-20 16:07:56

Okay, but the branch currently doesn't merge cleanly


---

Comment by tscrim created at 2014-05-20 16:07:56

Changing status from needs_info to needs_work.


---

Comment by pbruin created at 2014-05-20 16:16:04

Just to be clear (since Volker set this to positive review after moving the infinity-related stuff to #11506): it wasn't my intention to give a positive review except for that example.  I haven't looked at the real sets code at all.


---

Comment by git created at 2014-05-20 16:16:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-05-20 16:18:28

Changing status from needs_work to positive_review.


---

Comment by pbruin created at 2014-05-20 16:21:52

OK, I didn't notice that the real sets code had already been reviewed.


---

Comment by git created at 2014-05-24 10:03:16

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:


---

Comment by git created at 2014-05-24 10:03:16

Changing status from positive_review to needs_review.


---

Comment by pbruin created at 2014-05-24 12:31:38

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-05-25 10:09:18

Resolution: fixed
