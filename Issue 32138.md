# Issue 32138: speed up logarithms modulo composite integers

Issue created by migration from https://trac.sagemath.org/ticket/32375

Original creator: lorenz

Original creation time: 2021-08-14 04:14:01

CC:  cremona klee defeo edgarcosta kedlaya

Keywords: discrete logarithms, finite rings, composite characteristic

The current logic for `IntegerModRing_abstract.log()` is as follows:

1. If `logarithm_exists=True` was passed: Call Pari's `znlog` with just the elements.
2. Else, if the modulus is prime: Compute the orders of `a,b` and (if the logarithm exists) call Pari's `znlog` with the elements and the order of `b`.
3. Else, use generic `discrete_log` (i.e., Pohlig–Hellman).

The main reason things are done like this appears to be that `znlog` is not guaranteed to terminate if the logarithm doesn't exist, and checking if it exists is only easy (by comparing element orders) when the group is cyclic. Since we're already at it, here's what Pari does in `znlog`:

1. If the order of the base element is given, factor it and use Pohlig–Hellman.
2. Else, factor the modulus and solve each prime-power part separately using either index calculus (if p is a suitable prime) or Pohlig–Hellman with either BSGS or Pollard ρ for the base cases (depending on size).

We really shouldn't resort to generic `discrete_log()` right away if the modulus isn't prime: While indeed `(ℤ/n)*` is usually non-cyclic, we can typically reduce to the cyclic case using CRT, which we can then pass on to Pari after checking that the logarithm exists (by comparing orders).


I found out about the current, suboptimal behaviour here: [https://web.archive.org/web/20210813155145/https://cryptohack.gitbook.io/cryptobook/abstract-algebra/groups/untitled](https://web.archive.org/web/20210813155145/https://cryptohack.gitbook.io/cryptobook/abstract-algebra/groups/untitled)


---

Comment by lorenz created at 2021-08-14 04:31:30

Changing status from new to needs_review.


---

Comment by tscrim created at 2021-08-15 00:49:49

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2021-08-15 00:49:49

I am cc-ing some people who might have an opinion on this. (Sorry if you don't care.)

Some quick comments:

I don't think we need the `assert b**n == self` check to be run. I would comment it out.

I would just copy the error message where appropriate rather than put it in a `lambda` function. It obfuscates the code a bit for something effectively trivial (having an easy way to change an error message). Plus you can then have more nuanced error messages explaining where the computation failed.

Split these lines:

```diff
-n, m = 0, 1
+n = 0
+m = 0
```


```diff
-na, nb = a_red.multiplicative_order(), b_red.multiplicative_order()
+na = a_red.multiplicative_order()
nb = b_red.multiplicative_order()
```

It makes a difference in Cython code. (Related question: do we know anything about the types of some of these variables? This could make the code even faster.)

Move the import statement `from sage.arith.all import crt, lcm` outside of the `for` loop. It only needs to be done once in the function.

It is only the `crt` that could fail here, right? So

```diff
             try:
                 n = crt(n, v, m, nb)
-                m = lcm(m, nb)
             except ValueError:  # contradictory partial solutions
                 raise exc(self.modulus())
             m = lcm(m, nb)
```



---

Comment by tscrim created at 2021-08-15 00:49:49

Changing component from algebra to number theory.


---

Comment by edgarcosta created at 2021-08-15 22:39:27

Overall it looks like a solid improvement, and I agree with Travis's comments.

Another minor comment, I would consider storing a list with `nb`s and `v`s and at the end calling CRT_list which is literally doing the same as you

```
                n = crt(n, v, m, nb)
                m = lcm(m, nb)
```

but now the code would be more readable and modular.


---

Comment by git created at 2021-08-17 08:28:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2021-08-17 08:33:52

Thanks for the comments! All done (I think), except for this:

Replying to [comment:3 edgarcosta]:
> I would consider storing a list with `nb`s and `v`s and at the end calling CRT_list which is literally doing the same

— that's what I had at first, but the current version aborts earlier in some cases. (We don't want to continue running an expensive DLP computation when it's already clear that there will be no solution.)


---

Comment by lorenz created at 2021-08-17 08:33:52

Changing status from needs_work to needs_review.


---

Comment by edgarcosta created at 2021-08-17 12:35:09

Makes sense! I will wait for the tests to pass to take a more careful look into it.


---

Comment by tscrim created at 2021-08-17 22:22:47

Green patchbot. Now to some technical comments:


```diff
-for kw in kwargs.keys():
+for kw in kwargs:
```

However, while I somewhat understand why you are using `kwargs` input, you could just set `logarithm_exists=None` and check if `None`. I doubt anyone is passing `None` here and meant to.

Trivial formatting point: We try to follow Python's convention and have error messages starting with a lower case letter.


---

Comment by edgarcosta created at 2021-08-17 22:54:01

In terms of math, the code looks good! Once Travis is happy, I will give a positive review.

I agree that `logarithm_exists=None` sounds ideal to me, and less opaque why we still have it, no one needs to wonder what goes in `**kwargs`, and we can just mark it as deprecated in the documentation.

Optional formatting:
- delete the empty lines at the beginning of `if`, `for`, `try`... blocks
- `for p,e in ...` -> `for p, e in ...`
- extra minor, I'm a strong fan of https://docs.python.org/3/tutorial/inputoutput.html#fancier-output-formatting


---

Comment by tscrim created at 2021-08-17 23:11:13

Replying to [comment:8 edgarcosta]:
> I agree that `logarithm_exists=None` sounds ideal to me, and less opaque why we still have it, no one needs to wonder what goes in `**kwargs`, and we can just mark it as deprecated in the documentation.

I would just leave it out altogether from the documentation since it is deprecated and the warning/code makes it clear that it is. No need to tell a more casual user about something that is disappearing.


---

Comment by git created at 2021-08-18 03:26:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2021-08-18 03:29:15

Thanks both of you! Done.


---

Comment by tscrim created at 2021-08-18 04:21:45

Thank you. I am setting this to a positive review from comment:8.

Edgar, if there is something else you feel needs to be addressed, feel free to revert the positive review.


---

Comment by tscrim created at 2021-08-18 04:21:45

Changing status from needs_review to positive_review.


---

Comment by edgarcosta created at 2021-08-18 10:27:57

Thank you, Travis!


---

Comment by vbraun created at 2021-09-06 19:33:27

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2021-09-06 19:33:27


```
sage -t --long --warn-long 42.3 --random-seed=0 src/sage/functions/log.py
**********************************************************************
File "src/sage/functions/log.py", line 385, in sage.functions.log.log
Failed example:
    log(a,3)
Expected:
    Traceback (most recent call last):
    ...
    ValueError: No discrete log of 8 found to base 3 modulo 13
Got:
    <BLANKLINE>
    Traceback (most recent call last):
      File "/home/release/Sage/local/lib64/python3.9/site-packages/sage/functions/log.py", line 451, in log
        return args[0].log(args[1])
      File "sage/rings/finite_rings/integer_mod.pyx", line 777, in sage.rings.finite_rings.integer_mod.IntegerMod_abstract.log (build/cythonized/sage/rings/finite_rings/integer_mod.c:9308)
        raise ValueError(f"no logarithm of {self} found to base {b} modulo {self.modulus()}" \
    ValueError: no logarithm of 8 found to base 3 modulo 13
    <BLANKLINE>
    During handling of the above exception, another exception occurred:
    <BLANKLINE>
    Traceback (most recent call last):
      File "sage/symbolic/function.pyx", line 573, in sage.symbolic.function.Function.__call__ (build/cythonized/sage/symbolic/function.cpp:6731)
        args = [SR.coerce(a) for a in args]
      File "sage/structure/parent.pyx", line 1177, in sage.structure.parent.Parent.coerce (build/cythonized/sage/structure/parent.c:11028)
        cpdef coerce(self, x):
      File "sage/structure/parent.pyx", line 1209, in sage.structure.parent.Parent.coerce (build/cythonized/sage/structure/parent.c:10974)
        return (<map.Map>mor)._call_(x)
      File "sage/structure/coerce_maps.pyx", line 161, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4638)
        raise
      File "sage/structure/coerce_maps.pyx", line 156, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4530)
        return C._element_constructor(x)
      File "sage/symbolic/ring.pyx", line 402, in sage.symbolic.ring.SymbolicRing._element_constructor_ (build/cythonized/sage/symbolic/ring.cpp:6851)
        raise TypeError('positive characteristic not allowed in symbolic computations')
    TypeError: positive characteristic not allowed in symbolic computations
    <BLANKLINE>
    During handling of the above exception, another exception occurred:
    <BLANKLINE>
    Traceback (most recent call last):
      File "/home/release/Sage/local/lib64/python3.9/site-packages/sage/doctest/forker.py", line 704, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/release/Sage/local/lib64/python3.9/site-packages/sage/doctest/forker.py", line 1098, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.functions.log.log[32]>", line 1, in <module>
        log(a,Integer(3))
      File "/home/release/Sage/local/lib64/python3.9/site-packages/sage/functions/log.py", line 455, in log
        return logb(args[0], args[1])
      File "sage/symbolic/function.pyx", line 1179, in sage.symbolic.function.BuiltinFunction.__call__ (build/cythonized/sage/symbolic/function.cpp:12857)
        res = super(BuiltinFunction, self).__call__(
      File "sage/symbolic/function.pyx", line 586, in sage.symbolic.function.Function.__call__ (build/cythonized/sage/symbolic/function.cpp:6893)
        raise TypeError("cannot coerce arguments: %s" % (err))
    TypeError: cannot coerce arguments: positive characteristic not allowed in symbolic computations
**********************************************************************
1 item had failures:
   1 of  50 in sage.functions.log.log
    [330 tests, 1 failure, 1.97 s]
----------------------------------------------------------------------
sage -t --long --warn-long 42.3 --random-seed=0 src/sage/functions/log.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

Comment by git created at 2021-09-07 02:15:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2021-09-07 02:17:10

This error is a result of this absolutely hilarious piece of code in `src/sage/functions/log.py`:


```python
    except ValueError as ex:
        if repr(ex)[12:27] == "No discrete log":
            raise
```


The "fix" is easy, but the underlying issue isn't: Has there been any effort to systematize exception types in Sage so that this could be replaced by something along the lines of `except NoSolutionFound:`?


---

Comment by lorenz created at 2021-09-07 02:17:10

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2021-09-07 06:42:17

That is quite impressive of a failure. The fix LGTM.

I don't think there has been, although it could be good to have a `NoSolutionError`, perhaps as a subclass of `ArithmeticError`. This likely would need a discussion on sage-devel.


---

Comment by tscrim created at 2021-09-07 06:42:17

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-09-13 22:22:21

Resolution: fixed
