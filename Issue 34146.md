# Issue 34146: revert for LazyTaylorSeries is missing

Issue created by migration from https://trac.sagemath.org/ticket/34383

Original creator: mantepse

Original creation time: 2022-08-17 12:17:02

CC:  tscrim


```
sage: L.<z> = LazyTaylorSeriesRing(ZZ)
sage: (z-z^2).revert()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
AttributeError: 'LazyTaylorSeriesRing_with_category.element_class' object has no attribute 'revert'
```


Same for `LazySymmetricFunctions`.  `compositional_inverse` might be a good alias.


---

Comment by mantepse created at 2022-08-17 12:46:34

Unfortunately, there seems to be an inaccuracy in `Stream_plethysm`:

```
sage: h = SymmetricFunctions(QQ).h()
sage: p = SymmetricFunctions(QQ).p()
sage: L = LazySymmetricFunctions(p)
sage: X = L(p[1])
sage: e = L(lambda n: h[n]) - 1 - X
sage: g = L(None, valuation=1)
sage: g.define(X - e(g))
sage: g[0]
0
sage: g[1]
p[1]
sage: g[2]
...booooom... (max recursion error)
```



---

Comment by mantepse created at 2022-08-17 13:24:16

In the example, `h` has valuation 2, so to compute the degree 2 piece of `h(g)` we only should be accessing the degree 1 piece of `g`.  But in `Stream_plethysm.get_coefficient`, we compute `self._compute_product(2, [1, 1], 1/2)`, which in turn accesses `self._right[2]`.


---

Comment by mantepse created at 2022-08-17 14:24:26

An easy fix is as follows:

```diff
diff --git a/src/sage/data_structures/stream.py b/src/sage/data_structures/stream.py
index e54a90b8b88..b61d29544c2 100644
--- a/src/sage/data_structures/stream.py
+++ b/src/sage/data_structures/stream.py
@@ -1763,6 +1763,14 @@ class Stream_plethysm(Stream_binary):
         p = self._p
         ret = p.zero()
         for mu in wt_int_vec_iter(n, la):
+            if any(j < self._gv for j in mu):
+                continue
             temp = c
             for i, j in zip(la, mu):
                 gs = self._right[j]
                 if not gs:
                     temp = p.zero()
                     break
                 temp *= p[i](gs)
             ret += temp
         return ret
```

However, it would probably be better not to generate these integer vectors in the first place.  Moreover, it is possibly a waste to compute `p[i](gs)` for each `i` in `la` separately, if `la` has many parts repeated.


---

Comment by mantepse created at 2022-08-17 15:35:18

I have to leave now, but I just saw that possibly the implementation of plethysm in the species directory is more efficient.


---

Comment by mantepse created at 2022-08-22 14:07:36

I slightly improved the implementation.  In particular, we can now specify degree one elements in the same way as for plethysm, and it is (slightly :-) faster now:

```
sage: from sage.data_structures.stream import Stream_function, Stream_plethysm, Stream_plethysm_old
sage: s = SymmetricFunctions(QQ).s()
sage: p = SymmetricFunctions(QQ).p()
sage: f = Stream_function(lambda n: s[n], s, True, 1)
sage: g = Stream_function(lambda n: s[[1]*n], s, True, 1)
sage: h = Stream_plethysm(f, g, p)
sage: %time _ = h[10]
CPU times: user 122 ms, sys: 6 µs, total: 122 ms
Wall time: 122 ms
sage: h2 = Stream_plethysm_old(f, g, p)
sage: %time _ = h2[10]
CPU times: user 2.13 s, sys: 0 ns, total: 2.13 s
Wall time: 2.13 s
```



---

Comment by mantepse created at 2022-08-22 17:46:31

Last 10 new commits:


---

Comment by mantepse created at 2022-08-22 17:46:31

Changing keywords from "" to "LazyPowerSeries".


---

Comment by mantepse created at 2022-08-22 17:51:59

Next I'd like to implement revert for TaylorSeries, derivative, derivative_with_respect_to_p1.

Still missing: functorial_composition, arithmetic_product, logarithm for SymmetricFunctions.

All of these are needed for #32367.


---

Comment by mantepse created at 2022-08-22 20:03:43

Should we `def plethysm` and make `__call__` an alias instead?  This is the way it is done in `combinat/sf/sfa.py`.


---

Comment by tscrim created at 2022-08-23 00:13:27

I agree that we should throw out integer vectors that are asking for things less than the valuation. Actually, this is simple to modify with the current code. Just subtract `valuation * len(la)` from `n`. Then you just add back in the valuation to each component of the integer vector.

It sure looks like you have just essentially duplicated the plethysm code, which I don't think we should do, especially for marginal speed gains. I think you are better off improving the symmetric functions code directly.

Another micro-optimization that can be done is to store `len(l)` in the `integer_vector_weighted.iterator_fast` code since this never changes (it can be surprising how much this extra little function call can affect speed).


---

Comment by tscrim created at 2022-08-23 00:13:48

Replying to [comment:9 mantepse]:
> Should we `def plethysm` and make `__call__` an alias instead?  This is the way it is done in `combinat/sf/sfa.py`.

It doesn't make any difference to me.


---

Comment by mantepse created at 2022-08-23 04:59:07

I don't understand. My code is quite different, and I gain a factor 20 on the original example.


---

Comment by tscrim created at 2022-08-23 05:48:22

Sorry, I just read what you wrote and took it at face value rather than actually reading the example. Indeed, that is quite an impressive speedup. I think my comment still holds about integrating it directly into the symmetric functions code. Superficially it still looks generally like the symmetric functions code. What have you changed to get that improvement?


---

Comment by mantepse created at 2022-08-23 06:41:19

Oh, i am sorry, that teaches me a lesson! Could we perhaps do a zoom meeting today? Maybe at 5pm Japan time?


---

Comment by tscrim created at 2022-08-23 06:50:32

Sounds good. I responded via email as well.


---

Comment by git created at 2022-08-23 08:54:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-24 21:25:22

Changing status from new to needs_review.


---

Comment by mantepse created at 2022-08-24 21:28:58

NB: the new implementation of plethysm appears to be faster than the one in sage.combinat.sf.sfa!


---

Comment by tscrim created at 2022-08-25 00:03:51

Some things that should be fixed:

- `_scale_part` and `_scale_c` need doctests. I might just inline the code however as they are such small and simple functions (they are needs for the symmetric functions implementation, but I think that could be improved).
- I would explain the algorithm for `revert` in terms of (lazy) symmetric functions rather than species.
- Instead of `sum_of_terms()`, I would just directly create a dictionary and go through `p._from_dict()` to avoid the redirection.
- Even though its cached, I would make this change:
  {{{#!diff
-        if power[d]:
-            terms = [(self._scale_part(m, i), self._raise_c(c, i)) for m, c in power[d]]
+        val = power[d]:
+        if val:
+            terms = {self._scale_part(m, i): coeff for m, c in val if (coeff := self._raise_c(c, i)))}
         else:
-            terms = []
+            return self._p.zero()
 
-        return self._p.sum_of_terms(terms, distinct = True)
+        return self._p._from_dict(terms, remove_zeros=False)
  }}}
  (I only very recently learned of the `:=` syntax. it is so great to have a way to assign equality in a statement in Python. It makes writing code like the above so much easier.)

However, there is also a decent part of me that would like to see the code duplication with `sfa.plethysm()` reduced, in particular with the logic around the include/exclude. Although the same could be said for `_scale_part` and `_scale_c`, which are (essentially) the same as in the symmetric functions.

Lastly, shouldn't the compositional inverse also be implemented for lazy Laurent and Taylor series?


---

Comment by git created at 2022-08-25 10:48:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-25 14:55:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-25 19:52:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-25 21:10:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-25 21:11:18

Changing status from needs_review to needs_work.


---

Comment by mantepse created at 2022-08-25 21:11:18

revert for Taylor is still missing (possibly I can simply redirect to Laurent), and revert for SymmetricFunctions still needs some care.


---

Comment by git created at 2022-08-25 21:56:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-26 07:02:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-26 07:13:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-26 07:34:39

Concerning code duplication:

* scale_part might be a useful action on partitions.  Can this be made fast?

* the handling of degree one elements could go into a separate top-level function, but I have no idea where to place it.  Possibly sfa.py?  Alternatively it could be a method on rings.  It might look as follows:


```
def _degree_one_elements(R, include=None, exclude=None):
    """
Return variables in the ring `R`.

    INPUT:

    - ``R`` -- a :class:`Ring`
    - ``include``, ``exclude`` (optional, default ``None``) --
      iterables of variables in ``R``

    OUTPUT:
    
    - If ``include`` is specified, only these variables are returned
      as elements of ``R``.  Otherwise, all variables in ``R``
      (recursively) with the exception of those in ``exclude`` are
      returned.

    """
    if include is not None and exclude is not None:
        raise RuntimeError("include and exclude cannot both be specified")

    if include is not None:
        degree_one = [R(g) for g in include]
    else:
        try:
            degree_one = [R(g) for g in R.variable_names_recursive()]
        except AttributeError:
            try:
                degree_one = R.gens()
            except NotImplementedError:
                degree_one = []
        if exclude is not None:
            degree_one = [g for g in degree_one if g not in exclude]

    return [g for g in degree_one if g != R.one()]
```


Besides, is the following a bug?

```
sage: ZZ.variable_names()
('x',)
sage: ZZ
Integer Ring
```



---

Comment by mantepse created at 2022-08-26 07:39:34

I hope to implement implement multivariate plethysm and reversion for Taylor today, and fix the remaining (few) issues in #32367.  Wish me good luck.


---

Comment by tscrim created at 2022-08-26 07:43:45

Replying to [comment:28 mantepse]:
> * scale_part might be a useful action on partitions.  Can this be made fast?

No faster than the current implementation I think. However, +1 for making it a method of partitions. (Note that it should return an element of `_Partitions`, not the parent of itself.)

> * the handling of degree one elements could go into a separate top-level function, but I have no idea where to place it.  Possibly sfa.py?  Alternatively it could be a method on rings.  It might look as follows:
> 
> {{{
> def _degree_one_elements(R, include=None, exclude=None):
>     """
>     Return variables in the ring `R`.
> 
>     INPUT:
> 
>     - ``R`` -- a :class:`Ring`
>     - ``include``, ``exclude`` (optional, default ``None``) --
>       iterables of variables in ``R``
> 
>     OUTPUT:
>     
>     - If ``include`` is specified, only these variables are returned
>       as elements of ``R``.  Otherwise, all variables in ``R``
>       (recursively) with the exception of those in ``exclude`` are
>       returned.
> 
>     """
>     if include is not None and exclude is not None:
>         raise RuntimeError("include and exclude cannot both be specified")
> 
>     if include is not None:
>         degree_one = [R(g) for g in include]
>     else:
>         try:
>             degree_one = [R(g) for g in R.variable_names_recursive()]
>         except AttributeError:
>             try:
>                 degree_one = R.gens()
>             except NotImplementedError:
>                 degree_one = []
>         if exclude is not None:
>             degree_one = [g for g in degree_one if g not in exclude]
> 
>     return [g for g in degree_one if g != R.one()]
> }}}

+1 as a top-level function in `sfa.py`. I would call it `_parse_degree_one_elements` and maybe tweak the one-line doc to be a little more precise about what it does. However, those are fairly trivial comments.

> Besides, is the following a bug?
> {{{
> sage: ZZ.variable_names()
> ('x',)
> sage: ZZ
> Integer Ring
> }}}

I think it is the result of very legacy code with it being a subclass of `sage.structure.parent_gens.ParentWithGens` and likely a requirement of the names being non-empty. See also

```
sage: QQ.variable_names()
('x',)
```

I would like to call it a bug, but that is perhaps slightly unfair.

Good luck!


---

Comment by mantepse created at 2022-08-26 08:36:24

Replying to [comment:30 tscrim]:
> Replying to [comment:28 mantepse]:
> > * scale_part might be a useful action on partitions.  Can this be made fast?
> 
> No faster than the current implementation I think. However, +1 for making it a method of partitions. (Note that it should return an element of `_Partitions`, not the parent of itself.)

Thus, it should *not* be `_acted_upon_`, but rather `scale`, right?


---

Comment by tscrim created at 2022-08-26 08:38:09

It could be an action of `NN` on partitions, but I think that is a much broader change than what is needed. If we wanted to do that, it would definitely need to be another ticket.

So yes, I would call it something like `stretch()`.


---

Comment by mantepse created at 2022-08-26 08:58:13

Concerning the naming of the new function in `sfa.py`: it seems to me that this might be useful in other contexts, too.

It has actually very little to do with `degree_one_elements`.  Rather, it provides a safe way to get all variables in a ring, possibly excluding some (and, rarely, only including some).  (With the minor annoyance that it doesn't always work.  For example, fraction fields over iterated polynomial rings will not give the correct answer.)

I'd thus like to call it for what it does, rather than what it is used for, eg. `_variable_names_recursive`.


---

Comment by git created at 2022-08-26 10:27:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-26 10:50:10

Replying to [comment:33 mantepse]:
> I'd thus like to call it for what it does, rather than what it is used for, eg. `_variable_names_recursive`.

That's fine by me.


---

Comment by git created at 2022-08-26 12:10:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-26 17:58:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DaveWitteMorris created at 2022-08-26 18:11:41

I created #34441 for the issue about `ZZ.variable_names()` that was mentioned in comment:28 and comment:30. IMHO it's a bug.


---

Comment by git created at 2022-08-27 09:09:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-27 09:13:27

The only missing method is reversion for Taylor series now.


---

Comment by git created at 2022-08-27 16:52:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-28 08:41:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-28 09:22:40

There remains a bug in `LazyTaylorSeries.__call__`:

At the very beginning, we deal with the case where f is a polynomial:

```
        # f has finite length
        if isinstance(self._coeff_stream, Stream_exact) and not self._coeff_stream._constant:
            # constant polynomial
            poly = self.polynomial()
            if poly.is_constant():
                return P(poly)
            return P(poly(g))
```

However, this is too eager.  In the example below, we would like to compute `g.define(z / ((1-z)(g)))`, which fails, whereas `g.define(z / (1-g))` works.  Also, if we compute in the `LazyLaurentSeriesRing` instead, there is no problem.

It would be great if `LazyLaurentSeries.__call__` and `LazyTaylorSeries.__call__` and perhaps even `LazySymmetricFunction.__call__` could share some code, to avoid these inconsistencies.


Example:

```
sage: L.<z> = LazyTaylorSeriesRing(QQ)
sage: f = 1 - z
sage: g = L(None, valuation=1)
sage: g.define(z / (1 - g))
sage: g
z + z^2 + 2*z^3 + 5*z^4 + 14*z^5 + 42*z^6 + 132*z^7 + O(z^8)

sage: g = L(None, valuation=1)
sage: g.define(z / f(g))
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File ~/sage-develop/src/sage/data_structures/stream.py:329, in Stream_inexact.__getitem__(self, n)
    328 try:
--> 329     c = self._cache[n]
    330 except KeyError:

KeyError: 1

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
Input In [10], in <cell line: 1>()
----> 1 g.define(z / f(g))

File ~/sage-develop/src/sage/rings/lazy_series.py:3508, in LazyTaylorSeries.__call__(self, check, *g)
   3506     if poly.is_constant():
   3507         return P(poly)
-> 3508     return P(poly(g))
   3510 # f now has (potentially) infinitely many terms
   3511 # Lift the resulting parent to a lazy series (if possible)
   3512 # Also make sure each element of g is a LazyModuleElement
   3513 from sage.rings.polynomial.polynomial_ring import PolynomialRing_general

File ~/sage-develop/src/sage/rings/polynomial/polynomial_rational_flint.pyx:552, in sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint.__call__()
    550             return acb_z
    551 
--> 552     return Polynomial.__call__(self, *x, **kwds)
    553 
    554 cpdef Polynomial truncate(self, long n):

File ~/sage-develop/src/sage/rings/polynomial/polynomial_element.pyx:881, in sage.rings.polynomial.polynomial_element.Polynomial.__call__()
    879 d = pol.degree()
    880 
--> 881 if d <= 0 or (isinstance(a, Element) and R.is_exact() and a.is_zero()):
    882     return cst # with the right parent thanks to the above coercion
    883 elif pol._parent is R and a.is_gen():

File ~/sage-develop/src/sage/structure/element.pyx:1064, in sage.structure.element.Element.is_zero()
   1062         implement ``__bool__`` instead.
   1063     """
-> 1064     return not self
   1065 
   1066 def _cache_key(self):

File ~/sage-develop/src/sage/rings/lazy_series.py:618, in LazyModuleElement.__bool__(self)
    616     if any(a for a in self._coeff_stream._cache):
    617         return True
--> 618 if self[self._coeff_stream._approximate_order]:
    619     return True
    620 raise ValueError("undecidable as lazy Laurent series")

File ~/sage-develop/src/sage/rings/lazy_series.py:254, in LazyModuleElement.__getitem__(self, n)
    252     step = n.step if n.step is not None else 1
    253     return [R(self._coeff_stream[k]) for k in range(start, n.stop, step)]
--> 254 return R(self._coeff_stream[n])

File ~/sage-develop/src/sage/data_structures/stream.py:331, in Stream_inexact.__getitem__(self, n)
    329         c = self._cache[n]
    330     except KeyError:
--> 331         c = self.get_coefficient(n)
    332         self._cache[n] = c
    333 else:

File ~/sage-develop/src/sage/data_structures/stream.py:876, in Stream_uninitialized.get_coefficient(self, n)
    857 def get_coefficient(self, n):
    858     """
    859     Return the ``n``-th coefficient of ``self``.
    860 
   (...)
    874         1
    875     """
--> 876     return self._target[n]

TypeError: 'NoneType' object is not subscriptable
```



---

Comment by tscrim created at 2022-08-28 13:33:30

Actually, it is not a bug in the lazy Taylor series code. In fact, it i working “correctly” because it is trying a very basic test to see if it is zero or not, the test of which is out of our hands, which at the time it does not know. I would actually expect the same problem in the `LazyLaurentSeriesRing`.

To fix this, the quick-n-dirty fix would be to have an uninitialized series have `__bool__()` simply return `True` as it represents a variable that has yet to be specialized . This would make it consistent with variables of a polynomial ring or symbolic variables. )Plus, in nearly all use cases, this will end up defining a non-zero series anyways.) Actually, because of that, I would even say this is the correct thing to do, and not simply a hack solution.

A more broader change to fix the problem would be to have some kind of lazily-evaluated version of composition. Not only would it increase the code complexity when there is arguably a valid solution, it also would not be compatible with polynomials that can be evaluated at elements of the lazy series ring `R` with the result being coerced into `R`. Note that the polynomial itself does ‘’not’’ even need to convert (much less coerce) into `R`. So this would just sweep this problem under the rug (this includes even the extreme change of removing the exact implementation or feeding off to the polynomial code).

Having written all of this down, I am fully convinced we should just make it work by saying an uninitialized series is considered to be non-zero by having `__bool__()` return `True` in that case.


---

Comment by mantepse created at 2022-08-28 19:07:39

I'm afraid I simply do not understand your argument.  You say that you "would actually expect the same problem in the `LazyLaurentSeriesRing`, but I don't see the problem there:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: f = 1-z
sage: g = L(None, valuation=1)
sage: g.define(z / f(g))
sage: g
z + z^2 + 2*z^3 + 5*z^4 + 14*z^5 + 42*z^6 + 132*z^7 + O(z^8)
```

In fact, this is (essentially) a doctest.

In `LazyLaurentSeries.__call__`, if `f` is a polynomial, we use the following test before composing the polynomial with `g`:
* if `g` is not a `LazyModuleElement`, we compose
* otherwise, if `g` is a `LazyCauchyProductSeries` and `g._coeff_stream` is `Stream_exact` and `not g._coeff_stream._constant`, we also do a special case
* finally, if none of the above applies, we use the generic algorithm.

I don't see where `g.__bool__` would come into play here.


---

Comment by mantepse created at 2022-08-28 20:15:39

I tried to do a consistency check.  I'm sure it could be improved.

```
    sage: def check(L, z, verbose=False):
    ....:     # division
    ....:     lf = [0, L(0), 1, L(1), z, 1 + z, 2 + z + z^2]
    ....:     lg = [3, L(3), 1 + z, 2 + z + z^2]
    ....:     for f in lf:
    ....:         for g in lg:
    ....:             try:
    ....:                 h = f / g
    ....:                 if verbose: print("(%s) / (%s) = %s" % (f, g, h))
    ....:             except Exception as e:
    ....:                 print("%s in (%s) / (%s)" % (e, f, g))
    ....:     # composition
    ....:     f = 2 + z + z^2
    ....:     l = [(f, 0), (f, L(0)), (f, 2 + z + z^2), (f, L(3)/(1 - 2*z))]
    ....:     f = L(3)/(2 - 3*z)
    ....:     l.extend([(f, 0), (f, L(0)), (f, 3*z/(1 - 2*z))])
    ....:     for f, g in l:
    ....:         try:
    ....:             h = f(g)
    ....:             if verbose: print("(%s)(%s) = %s" % (f, g, h))
    ....:         except Exception as e:
    ....:             print("%s in (%s)(%s)" % (e, f, g))
    ....:     # reversion
    ....:     l = [2 + 3*z, 3*z + 2*z^2, 3*z/(1 - 2*z - 3*z^2)]
    ....:     for f in l:
    ....:         try:
    ....:             h = f.revert()
    ....:             if verbose: print("(%s)^{(-1)} = %s" % (f, h))
    ....:         except Exception as e:
    ....:             print("%s in (%s).revert()" % (e, f))
```


The current results are as follows:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: check(L, z)

sage: L.<z> = LazyTaylorSeriesRing(QQ)
sage: check(L, z)
unable to evaluate the series at (0,) in (3/2 + 9/4*z + 27/8*z^2 + 81/16*z^3 + 243/32*z^4 + 729/64*z^5 + 2187/128*z^6 + O(z^7))(0)
'NoneType' object is not subscriptable in (3*z + 2*z^2).revert()

sage: p = SymmetricFunctions(QQ).p()
sage: L = LazySymmetricFunctions(p)
sage: check(L, L(p[1]))
can only compose with a positive valuation series in (2*p[] + p[1] + (p[1,1]))(3*p[] + 6*p[1] + (12*p[1,1]) + (24*p[1,1,1]) + (48*p[1,1,1,1]) + (96*p[1,1,1,1,1]) + (192*p[1,1,1,1,1,1]) + O^7)
no conversion of this rational to integer in (3/2*p[] + 9/4*p[1] + (27/8*p[1,1]) + (81/16*p[1,1,1]) + (243/32*p[1,1,1,1]) + (729/64*p[1,1,1,1,1]) + (2187/128*p[1,1,1,1,1,1]) + O^7)(0)
```



---

Comment by tscrim created at 2022-08-28 23:58:45

Replying to [comment:45 mantepse]:
> I'm afraid I simply do not understand your argument.  You say that you "would actually expect the same problem in the `LazyLaurentSeriesRing`, but I don't see the problem there:
> {{{
> sage: L.<z> = LazyLaurentSeriesRing(QQ)
> sage: f = 1-z
> sage: g = L(None, valuation=1)
> sage: g.define(z / f(g))
> sage: g
> z + z^2 + 2*z^3 + 5*z^4 + 14*z^5 + 42*z^6 + 132*z^7 + O(z^8)
> }}}
> In fact, this is (essentially) a doctest.
> 
> In `LazyLaurentSeries.__call__`, if `f` is a polynomial, we use the following test before composing the polynomial with `g`:
> * if `g` is not a `LazyModuleElement`, we compose
> * otherwise, if `g` is a `LazyCauchyProductSeries` and `g._coeff_stream` is `Stream_exact` and `not g._coeff_stream._constant`, we also do a special case
> * finally, if none of the above applies, we use the generic algorithm.

In some respects, we get lucky here. I would expect the following to work:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: f = 1 - z
sage: g = L(None, valuation=1)
sage: f(g) == f.polynomial()(g)
```

In particular, the `f.polynomial()(g)` fails in exactly the same way as above.

The only reason we need to do anything special is for the negative exponents when `g` is exact. Everything else is just an optimization (as the comment there indicates, it should be replaceable by `return poly(g)`) to take advantage of caching (it could also benefit by reducing the number of multiplications too).

> I don't see where `g.__bool__` would come into play here.

It is there in the error message as there is a call to `is_zero()`.


---

Comment by tscrim created at 2022-08-29 00:08:48

I am a bit happy as it seems on a simple example that my optimization is faster:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: f = z^-1 + 2 + z + z^2 + 2*z^3
sage: g = z^-2 / (1 - z)

sage: %time (f(g))[300]
CPU times: user 25.6 ms, sys: 10 µs, total: 25.6 ms
Wall time: 25.2 ms
94862
sage: %time (f.polynomial()(g))[300]
CPU times: user 92.1 ms, sys: 0 ns, total: 92.1 ms
Wall time: 91.8 ms
94862

sage: %time (f(g))[3000]
CPU times: user 2.22 s, sys: 0 ns, total: 2.22 s
Wall time: 2.22 s
9048062
sage: %time (f.polynomial()(g))[3000]
CPU times: user 8.2 s, sys: 0 ns, total: 8.2 s
Wall time: 8.2 s
9048062
```

All come behold the power of the cache and rejoice. `:P`


---

Comment by tscrim created at 2022-08-29 00:34:05

Here is the fix with doctests added.
----
New commits:


---

Comment by mantepse created at 2022-08-29 06:57:38

Cool, and thank you for the explanation!  I missed the fact that composing a polynomial with an uninitialised series actually makes sense even when using the generic polynomial code.


---

Comment by git created at 2022-08-29 07:57:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-29 07:58:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-29 07:59:54

There are still some tests which (trivially) fail.  I am going to work on them for the next 2 hours or so.


---

Comment by git created at 2022-08-29 14:00:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-29 14:15:25

Taylor series should be OK now.

There are still slight problems with plethysm.  Some of them might be best fixed in the implementation of ordinary symmetric functions:

```
sage: p = SymmetricFunctions(QQ).p()
sage: p[2,2,1](3)
...
TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
```

However, I am not completely sure who should handle plethysms of the form `f o g` where `f` is an ordinary symmetric function and `g` is a lazy symmetric function.  The situation is similar to the case of polynomials, but not the same.  Essentially, we need to be able to express `g` as a (possibly constant, possibly lazy) symmetric function in the power sum basis.

One possibility would be to handle this in `Stream_plethysm`.  However, this goes against the general philosophy that the "exact" case is handled in `lazy_series.py`.  On the other hand, implementing yet another version of plethysm in `LazySymmetricFunction.__call__` seems like a lot of code duplication to me.


---

Comment by tscrim created at 2022-08-30 00:28:11

Replying to [comment:55 mantepse]:
> Taylor series should be OK now.

Great!

> There are still slight problems with plethysm.  Some of them might be best fixed in the implementation of ordinary symmetric functions:
> {{{
> sage: p = SymmetricFunctions(QQ).p()
> sage: p[2,2,1](3)
> ...
> TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
> }}}

Yea, this one annoys me from time to time that it doesn't at least try to coerce the element into a symmetric functions. This is for a separate ticket, but +1 for trying the coercion (or at least handling elements from the base ring)

> However, I am not completely sure who should handle plethysms of the form `f o g` where `f` is an ordinary symmetric function and `g` is a lazy symmetric function.  The situation is similar to the case of polynomials, but not the same.  Essentially, we need to be able to express `g` as a (possibly constant, possibly lazy) symmetric function in the power sum basis.

The symmetric function `f` definitely should. There is no mechanism within Python (or within the coercion framework) to automatically pass control over to `g`.

> One possibility would be to handle this in `Stream_plethysm`.  However, this goes against the general philosophy that the "exact" case is handled in `lazy_series.py`.  On the other hand, implementing yet another version of plethysm in `LazySymmetricFunction.__call__` seems like a lot of code duplication to me.

I don't know how `Stream_plethysm` could even get control of this without having `f` actually handle the object. At which point, there is an easy solution: convert `f` to a `LazySymmetricFunction` and run `__call__` on that. I will push a fix in just a minute.


---

Comment by git created at 2022-08-30 00:53:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-30 01:25:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-30 01:25:32

Replying to [comment:56 tscrim]:
> Replying to [comment:55 mantepse]:

> > There are still slight problems with plethysm.  Some of them might be best fixed in the implementation of ordinary symmetric functions:
> > {{{
> > sage: p = SymmetricFunctions(QQ).p()
> > sage: p[2,2,1](3)
> > ...
> > TypeError: only know how to compute plethysms between symmetric functions or tensors of symmetric functions
> > }}}
> 
> Yea, this one annoys me from time to time that it doesn't at least try to coerce the element into a symmetric functions. This is for a separate ticket, but +1 for trying the coercion (or at least handling elements from the base ring)

I ended up fixing this here as it was basically part of the changes I needed to make for the lazy series. We will not be able to return an element in the original parent for "constants" (broadly interpreted) without doing some cumbersome (and well-definedness is another issue too).

The check for tensor products is a bit brittle, so I've tried to make it a bit more robust (say, if the commutative ring is also a tensor product).

In trying to find a doctest for this, I found out that tensor products of commutative algebras do not know they are commutative rings:

```
sage: X = algebras.Shuffle(QQ, 'ab')
sage: Y = algebras.Shuffle(QQ, 'bc')
sage: X in CommutativeRings()
True
sage: Y in CommutativeRings()
True
sage: T = tensor([X,Y])
sage: T in CommutativeRings()
False
```

This is now #34453. While not a strict dependency for this ticket, it means I get to write the doctest I wanted.

> > One possibility would be to handle this in `Stream_plethysm`.  However, this goes against the general philosophy that the "exact" case is handled in `lazy_series.py`.  On the other hand, implementing yet another version of plethysm in `LazySymmetricFunction.__call__` seems like a lot of code duplication to me.
> 
> I don't know how `Stream_plethysm` could even get control of this without having `f` actually handle the object. At which point, there is an easy solution: convert `f` to a `LazySymmetricFunction` and run `__call__` on that. I will push a fix in just a minute.

I have now done this.


---

Comment by mantepse created at 2022-08-30 05:31:37

So, the idea is now to make `Stream_plethysm` handle the plethysm of a symmetric function with finite support and lazy symmetric functions of valuation 0?

(That's fine with me, I just want confirmation.)

(sorry for being short, I just woke up :-)


---

Comment by tscrim created at 2022-08-30 05:40:30

Replying to [comment:60 mantepse]:
> So, the idea is now to make `Stream_plethysm` handle the plethysm of a symmetric function with finite support and lazy symmetric functions of valuation 0?

Essentially yes because it already must do so.

> (sorry for being short, I just woke up :-)

No problem.


---

Comment by git created at 2022-08-30 08:38:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-30 08:45:56

It seems that we are done for now!

I am sure that code and especially tests and documentation could and should be polished, but maybe it would be good to move forward now.  At least concerning functionality, the code is a huge improvement over what we had before this ticket!

Perhaps it would make sense to make more tests systematic, and also check which tests are now redundant.

I am very grateful for all your help and expertise, Travis!


---

Comment by mantepse created at 2022-08-30 08:45:56

Changing status from needs_work to needs_review.


---

Comment by git created at 2022-08-30 09:32:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-30 09:36:22

Thank you for the changes and all your hard work.

Some comments about my changes:

- I would avoid variable names of `prod` to not cause possible confusion with the function `prod` (it isn't currently imported, but it could be and even used here).
- I am very worried about breaking the assumption of the `wt_int_vec_iter`. By not following it, the plethysm could break in a subtle way. I just reversed everything.

Isn't the `:=` syntax great? I had been missing that so much.

If my changes are good, then I we can set a positive review and move on to the next thing. We can do more polishing of the documentation and tests later.


---

Comment by git created at 2022-08-30 10:53:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-30 10:53:21

Perfect, thanks!


---

Comment by mantepse created at 2022-08-30 10:53:31

Changing status from needs_review to positive_review.


---

Comment by git created at 2022-08-30 14:51:54

Changing status from positive_review to needs_review.


---

Comment by git created at 2022-08-30 14:51:54

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by mantepse created at 2022-08-30 18:50:01

Changing status from needs_review to positive_review.


---

Comment by git created at 2022-08-31 20:22:03

Changing status from positive_review to needs_review.


---

Comment by git created at 2022-08-31 20:22:03

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by mantepse created at 2022-08-31 20:23:59

Back to positive review, these are only trivial modifications.  Please excuse the noise.


---

Comment by mantepse created at 2022-08-31 20:23:59

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-09-22 22:34:41

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2022-09-22 22:34:41


```
sage -t --long --warn-long 48.0 --random-seed=123 src/sage/combinat/sf/sfa.py
**********************************************************************
File "src/sage/combinat/sf/sfa.py", line 3139, in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm
Failed example:
    s(2*T.one())
Expected:
    (2*B[word:]#B[word:])*s[]
Got:
    (2*B[]#B[])*s[]
**********************************************************************
1 item had failures:
   1 of  48 in sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.plethysm
    [1238 tests, 1 failure, 18.82 s]
----------------------------------------------------------------------
sage -t --long --warn-long 48.0 --random-seed=123 src/sage/combinat/sf/sfa.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

Comment by git created at 2022-09-22 22:40:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-22 22:40:58

Changing status from needs_work to positive_review.


---

Comment by tscrim created at 2022-09-22 22:40:58

Same trivial fix that ended up on the later ticket #34413.


---

Comment by git created at 2022-09-25 22:27:40

Changing status from positive_review to needs_review.


---

Comment by git created at 2022-09-25 22:27:40

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by mantepse created at 2022-09-25 22:30:30

Trivial merge, hence setting back to positive review.


---

Comment by mantepse created at 2022-09-25 22:30:46

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-09-28 23:04:18

Resolution: fixed
