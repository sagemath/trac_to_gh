# Issue 23745: perfect matchings and containment

Issue created by migration from https://trac.sagemath.org/ticket/23982

Original creator: mantepse

Original creation time: 2017-10-07 09:06:55

Perfect matchings are not "normalised", that is, the pairs are not sorted.  Although that's sometimes annoying it's OK, because equality works.

However, there is a problem with containment:

```
sage: M = PerfectMatching([(2, 3), (4, 1)]); M
[(2, 3), (4, 1)]
sage: M in PerfectMatchings(4)
True
sage: set(PerfectMatchings(4))
{[(1, 2), (3, 4)], [(1, 3), (2, 4)], [(1, 4), (2, 3)]}
sage: M in set(PerfectMatchings(4))
False
```



---

Comment by mantepse created at 2017-10-07 21:07:22

New commits:


---

Comment by mantepse created at 2017-10-07 21:08:13

That was stupid, now the hash of all matchings is the same.  I'm afraid, I have to sort.


---

Comment by git created at 2017-10-07 21:11:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-07 21:13:04

In fact, I think it would be better to normalize the matching upon creation.  I'm not sure how this would be done - I guess by introducing an `_element_constructor_`?


---

Comment by git created at 2017-10-07 21:30:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-07 21:31:09

Changing status from new to needs_review.


---

Comment by tscrim created at 2017-10-08 01:54:32

How about using the hash of a `frozenset`?


---

Comment by mantepse created at 2017-10-08 05:46:14

Are you saying I should convert the matching into a `frozenset` of `frozenset`s?

If so, I still think that this should be done when the matching is created.  I think that this would minimize the overhead.

But I'm not quite sure how to do it correctly - should I do it as in `SetPartition`?  I don't understand why `SetPartition` inherits from `ClonableArray` whereas `PerfectMatching` inherits from `ElementWrapper`.


---

Comment by tscrim created at 2017-10-08 07:46:13

Replying to [comment:9 mantepse]:
> Are you saying I should convert the matching into a `frozenset` of `frozenset`s?

Only for the hashing.

> If so, I still think that this should be done when the matching is created.  I think that this would minimize the overhead.

No, we want things like `__getitem__` to work and to have more list-like behavior.

> But I'm not quite sure how to do it correctly - should I do it as in `SetPartition`?  I don't understand why `SetPartition` inherits from `ClonableArray` whereas `PerfectMatching` inherits from `ElementWrapper`.

Again, only in the `__hash__` (which we can cache if the hashing is really, actually a bottleneck).


---

Comment by mantepse created at 2017-10-08 08:02:55

Can you give me one reason why we should not sort at creation time - if you want to have list-like behaviour?

I use perfect matchings quite a lot, and I must say that having

```
sage: PerfectMatching([[3,1],[2,4]])
[(3, 1), (2, 4)]
```

is a pain.  I'm willing to live with it, but having list-like behaviour is actually counter productive, because you are not warned that the output is random.


---

Comment by mantepse created at 2017-10-08 13:12:38

Setting to "needs work", because I am now convinced that matchings should be normalised, when possible.


---

Comment by mantepse created at 2017-10-08 13:12:38

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2017-10-08 15:13:58

I agree that there is definite work to be done here. One reason to not sort at creation time is because sorting can be slow and you may not need to sort. Another reason is that sorting might not be defined.

I feel like `PerfectMatching` should inherit from `SetPartition` and likewise for the parent.


---

Comment by mantepse created at 2017-10-08 16:17:35

Replying to [comment:13 tscrim]:
> I agree that there is definite work to be done here. One reason to not sort at creation time is because sorting can be slow and you may not need to sort.

I agree, but that calls for a `check=False` parameter.

> Another reason is that sorting might not be defined.

I agree.  I would hope that it is possible to have the internal representation depend on this.

> I feel like `PerfectMatching` should inherit from `SetPartition` and likewise for the parent.

OK, if this doesn't pose huge problems, I'm all for it.  The current internal representation of set partition is a (sorted) `ClonableArray` of `Set`.

I think it would be best to have a sorted `ClonableArray` of sorted `Set`, so that openers are `[p[0] for p in P]` and closers are `[p[-1] for p in P]` whenever there is a total order available.

Unfortunately, `Set` was broken recently, see #23324.


---

Comment by mantepse created at 2017-10-08 18:21:31

That turned out to be quite easy!  I'll have a patch ready pretty soon - I just need to make sure all the old tests pass.


---

Comment by git created at 2017-10-08 21:25:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-08 21:34:34

Could you have a brief look?

I think the following items need adressing:

* the error messages are not explicit anymore.  For example, `PerfectMatching([This is the Trac macro *1,2,3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,3-macro))` now just raises an `AssertionError` without any explanation.  I don't know where to customize that yet.

* I want that `SetPartition` sorts the parts.  We now have 
  {{{
  sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n
        [(1, 3), (8, 2), (4, 7), (5, 6)]
  }}}
  which is terrible.

* as you can see, I did not change the `_repr_` of `PerfectMatching` for backwards compatibility.

* There is some functionality in `PerfectMatching`, for example, `random_element` and `conjugate_by_permutation`which really belongs into `SetPartition`.


---

Comment by mantepse created at 2017-10-08 21:56:33

Just noticed that we have

* `SetPartition.is_noncrossing` and `PerfectMatching.is_non_crossing`
* `SetPartition.to_permutation` and `PerfectMatching.to_permutation`
* `SetPartition.apply_permutation` and `PerfectMatching.conjugate_by_permutation`

and probably some more.  Crossings and nestings could go into set partitions, too.


---

Comment by git created at 2017-10-08 22:06:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-08 22:12:41

another question: `SetPartition.standardization()` is useful and makes sense for perfect matchings also, but returns a set partition.  (In fact, it always returns a generic set partition, not the more specialized `SetPartitions_set`)

Can we make it return the appropriate parent always - or should I simply repeat the definition in `PerfectMatching`?
----
New commits:


---

Comment by tscrim created at 2017-10-08 23:28:46

Replying to [comment:17 mantepse]:
> Could you have a brief look?
> 
> I think the following items need adressing:
> 
> * the error messages are not explicit anymore.  For example, `PerfectMatching([This is the Trac macro *1,2,3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,3-macro))` now just raises an `AssertionError` without any explanation.  I don't know where to customize that yet.

As the traceback shows, you can implement a more refined `check` method. However, this will result in code duplication (well...essentially) and more of a maintenance burden.

> * I want that `SetPartition` sorts the parts.  We now have 
>   {{{
>   sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n
>         [(1, 3), (8, 2), (4, 7), (5, 6)]
>   }}}
>   which is terrible.

Please be a little more explicit with the problem and avoid general (sensationalist) statements.
I do agree that there is a problem with the output of `(8, 2)`. However, there is some consistency:

```
sage: PerfectMatching([(1, 3), (2, 8), (4, 7), (5, 6)])
[(1, 3), (8, 2), (4, 7), (5, 6)]
```

This seems to be a problem with the current implementation of `__classcall_private__`. This should _not_ handle normalizing input in this case; instead that is best left to `__init__` of `SetPartition` as all code paths must go through there.

> * There is some functionality in `PerfectMatching`, for example, `random_element` and `conjugate_by_permutation`which really belongs into `SetPartition`. 

Not necessarily. At least `random_element` seems specific to perfect matchings.


---

Comment by tscrim created at 2017-10-08 23:33:09

Replying to [comment:20 mantepse]:
> another question: `SetPartition.standardization()` is useful and makes sense for perfect matchings also, but returns a set partition.  (In fact, it always returns a generic set partition, not the more specialized `SetPartitions_set`)
> 
> Can we make it return the appropriate parent always - or should I simply repeat the definition in `PerfectMatching`?

I don't think so as it is not worth the computation to find the "best" parent. Also, is it useful for it to be a `PerfectMatching`? If so, then it should just be

```python
def standardization(self):
    """
    Return the standardization of ``self``.

    See :meth:`SetPartition.standardization` for details.

    EXAMPLES::

        sage: ...
    """
    return PerfectMatchings()(SetPartition.standardization(self))
```



---

Comment by mantepse created at 2017-10-09 05:12:44

Many many thanks for looking!

Replying to [comment:21 tscrim]:

> > * I want that `SetPartition` sorts the parts.  We now have 
> >   {{{
> >   sage: n = PerfectMatching([3,8,1,7,6,5,4,2]); n
> >         [(1, 3), (8, 2), (4, 7), (5, 6)]
> >   }}}
> >   which is terrible.
> 
> Please be a little more explicit with the problem and avoid general (sensationalist) statements.
> I do agree that there is a problem with the output of `(8, 2)`. However, there is some consistency:
> {{{
> sage: PerfectMatching([(1, 3), (2, 8), (4, 7), (5, 6)])
> [(1, 3), (8, 2), (4, 7), (5, 6)]
> }}}
> This seems to be a problem with the current implementation of `__classcall_private__`. This should _not_ handle normalizing input in this case; instead that is best left to `__init__` of `SetPartition` as all code paths must go through there.

Yes, I was not explicit enough.  I should have written: `SetPartition.__init__` calls        

```
ClonableArray.__init__(self, parent, sorted(map(Set, s), key=min), check=check)
```

and unfortunately

```
sage: Set([2,8])
{8, 2}
```

I do think that this is terrible, though :-)  What I don't understand is the following:

```
sage: repr(frozenset([2,8]))
'frozenset([8, 2])'
sage: str(frozenset([2,8]))
'frozenset([8, 2])'
sage: frozenset([2,8])
frozenset({2, 8})
```


Remark to myself: we cannot simply sort at output, because of

```
sage: Set([2,8])[0]
8
```



---

Comment by mantepse created at 2017-10-09 05:54:52

OK, I did some digging, and partially understand the issue now, it's a python thing.  It is quite confusing that `Set` supports indexing, I think that this should be turned off.  This is probably related to #12955.

In fact, turning off indexing in `Set`s, one could output them in sorted order :-)

I must admit that I do not completely understand the purpose of `Set`.


---

Comment by mantepse created at 2017-10-09 22:51:45

I think I am done.  Let me list the possibly more controversial modifications:

* I deprecated `non_crossing` and `non_nesting` in favour of `noncrossing` and `nonnesting`, because this is slightly more common.  If you prefer, I'd be fine with doing it the other way round, but I think consistency is desirable.  All of these work also on set partitions now.  Therefore, some doctests in `SetPartition` involve `PerfectMatching`.

* I also deprecated `conjugate_by_permutation` in favour of `apply_permutation`.

* I added (relatively stupid) random generation for set partitions of a given set and set partitions into a given number of parts.  I needed these for testing performance.

* I kept the old printing format for perfect matchings, although the one for set partitions is probably better.

* I do not know what ``@`add_metaclass(InheritComparisonClasscallMetaclass)` is for, is this still needed for perfect matchings?

* I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.


---

Comment by git created at 2017-10-09 22:59:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-09 23:00:33

Changing status from needs_work to needs_review.


---

Comment by git created at 2017-10-10 07:03:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-10-12 06:35:56

Replying to [comment:24 mantepse]:
> OK, I did some digging, and partially understand the issue now, it's a python thing.  It is quite confusing that `Set` supports indexing, I think that this should be turned off.  This is probably related to #12955.

No, it is not related.

> In fact, turning off indexing in `Set`s, one could output them in sorted order :-)

No, it would not. In fact, this is consistent what Python does with `set`, which _is_ iterable.

> I must admit that I do not completely understand the purpose of `Set`.

It is a Sage version of `set` and supports non-hashable elements and is a parent.


---

Comment by tscrim created at 2017-10-12 06:44:52

Replying to [comment:25 mantepse]:
> * I deprecated `non_crossing` and `non_nesting` in favour of `noncrossing` and `nonnesting`, because this is slightly more common.  If you prefer, I'd be fine with doing it the other way round, but I think consistency is desirable.  All of these work also on set partitions now.  Therefore, some doctests in `SetPartition` involve `PerfectMatching`.

I have no preference. Darij and Christian are probably better people to solicit.

> * I also deprecated `conjugate_by_permutation` in favour of `apply_permutation`.

Same as above.

> * I added (relatively stupid) random generation for set partitions of a given set and set partitions into a given number of parts.  I needed these for testing performance.

I don't see why this would be controversial.

> * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.

I would just change it; it doesn't make sense to have a separate `_repr_`.

> * I do not know what ``@`add_metaclass(InheritComparisonClasscallMetaclass)` is for, is this still needed for perfect matchings?

Yes, but it is inherited from `SetPartition`.

> * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.

Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.


---

Comment by tscrim created at 2017-10-12 07:00:23

Some things that I do not like are:

- A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.

- `iter_aux` should be a separate standalone function.

- I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.

- This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.


---

Comment by mantepse created at 2017-10-12 07:00:47

Replying to [comment:31 tscrim]:

> > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
> 
> I would just change it; it doesn't make sense to have a separate `_repr_`.

Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.

> > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.
> 
> Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.

Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)


---

Comment by mantepse created at 2017-10-12 07:13:45

> - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.

so these should all become `__init__` methods?

> - `iter_aux` should be a separate standalone function.

why?

> 
> - I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.

I did not introduce any, which ones do you mean?  (Besides, personally, I find `try-except-else` *much* easier to read.  Possibly because I grew up with Pascal and Lisp.)

> - This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.

OK, but only after I understand what you want...


---

Comment by tscrim created at 2017-10-12 07:26:25

Replying to [comment:33 mantepse]:
> Replying to [comment:31 tscrim]:
> 
> > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
> > 
> > I would just change it; it doesn't make sense to have a separate `_repr_`.
> 
> Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.

What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).

> > > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.
> > 
> > Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.
> 
> Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)

No, I do not think you should change anything in `check`. I just do not understand what this had to do with `PerfectMatching._repr_` and what tolerance you are referring to.

A side issue, the lack of an error message previously was fine because of the traceback. However, it should be a `ValueError` and not an `AssertionError`.


---

Comment by tscrim created at 2017-10-12 07:38:36

Replying to [comment:34 mantepse]:
> 
> > - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.
> 
> so these should all become `__init__` methods?

No, I would just not have a `check` parameter in `__classcall_private__` (but it is good to have it in `__init__`). In case you are asking a slightly different question, in Sage code, instead of doing `PerfectMatching(foo)`, I feel we should do `PerfectMatchings()(foo, check=False)` (or whatever the appropriate parent is) as it has less indirection (i.e., is more explicit).

> > - `iter_aux` should be a separate standalone function.
> 
> why?

Because it is faster if someone needs to iterate and only have lists, it would be better documented, and works as a standalone.

> > - I do not like `try-except-else` blocks which could just be `try-except` blocks. The `else` adds extra (small) logical step that makes the flow a little harder. This might be more idiosyncratic, but it seems more complicated to me.
> 
> I did not introduce any, which ones do you mean?  (Besides, personally, I find `try-except-else` *much* easier to read.  Possibly because I grew up with Pascal and Lisp.)

I guess these do all come from the old perfect matching code. The:

```python
        try:
            next(it)
        except StopIteration:
            return True
        else:
            return False
```

What makes this more complicated to me is that exceptions generally do special behavior and program flow should continue at the same level after things are processed. So the `else` block is (typically) vacuous as exceptions should typically not dictate program flow (Python makes this unavoidable at times). It is more stylistic, but I'm (overly) opinionated.

> > - This would be a good time to clean up a lot of the documentation formatting for, e.g., `is_noncrossing`. However, this is not a requirement for a positive review by me.
> 
> OK, but only after I understand what you want...

For example:

```
    def nestings_iterator(self):
        r"""
        INPUT:

            A perfect matching on a *totally ordered* ground set.

        OUTPUT:

            We place the elements of the ground set in order on a
            line and draw the set partition by linking consecutive
            elements of each block in the upper half-plane. This
            function returns an iterator over the pairs of nesting
            lines (as a line correspond to a pair, the iterator
            produces pairs of pairs).
```

is missing the one-line description, the `INPUT` and `OUTPUT` blocks should not be intended, `INPUT` should not be there as `self` is not an input, etc.


---

Comment by mantepse created at 2017-10-12 08:02:53

> > > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
> > > 
> > > I would just change it; it doesn't make sense to have a separate `_repr_`.
> > 
> > Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.
> 
> What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).

it's not a big thing:  FindStat uses the repr of perfect matchings also for input, but this can be changed easily.  I guess in the long run it's better, the only drawback being that you cannot use the output as input anymore.

> > > > * I implemented a slightly more elaborate error message in `SetPartition.check`.  This requires that `PerfectMatching._repr_` is a bit more tolerant than before.
> > > 
> > > Huh? This does not agree with the actual change, which is simple and clearly the correct thing, and I don't see how that has anything to do with `PerfectMatching._repr_`.
> > 
> > Sorry, I don't understand.  Could you please make it explicit what I should change in `check`?  I think it is desirable to have a readable error message, no?  (before this patch there is actually no error message, just `AssertionError`)
> 
> No, I do not think you should change anything in `check`. I just do not understand what this had to do with `PerfectMatching._repr_` and what tolerance you are referring to.

The code in check is `raise ValueError("%s is not an element of %s"%(self, self.parent()))`.  For some reason, at this point, `self` is already an instance of `PerfectMatching`, so the `_repr_` should be able to print it even if the number of parts is not always two.

I admit that this is a hack, but that's not my fault.
 
> A side issue, the lack of an error message previously was fine because of the traceback.

I disagree - for me, the tracebacks are a pain if there cause is at top level.


---

Comment by mantepse created at 2017-10-12 08:11:04

Replying to [comment:36 tscrim]:
> Replying to [comment:34 mantepse]:
> > 
> > > - A `check` in `__classcall_private__` as we should always check user input and it should not be used in code.
> > 
> > so these should all become `__init__` methods?
> 
> No, I would just not have a `check` parameter in `__classcall_private__` (but it is good to have it in `__init__`).

In `SetPartition`, we do have an `__init__`.  But `__classcall_private__` calls `SetPartitions.element_class`, passing the parameter `check`.  What should it pass if `check` is not available?  Or should it be `return P.element_class(P, *args, **kwds)`?

In `PerfectMatching`, currently there is no `__init__`, but I think it would make sense, because we have the special preprocessing for involutions.

> In case you are asking a slightly different question, in Sage code, instead of doing `PerfectMatching(foo)`, I feel we should do `PerfectMatchings()(foo, check=False)` (or whatever the appropriate parent is) as it has less indirection (i.e., is more explicit).

I agree with this one, as you probably know :-)


---

Comment by mantepse created at 2017-10-14 17:57:33

ping?

(I don't know what I'm supposed to do in `__classcall_private__`, whether I should introduce `PerfectMatching.__init__`)


---

Comment by tscrim created at 2017-10-16 22:15:39

Replying to [comment:37 mantepse]:
> > > > > * I kept the old printing format for perfect matchings, although the one for set partitions is probably better.
> > > > 
> > > > I would just change it; it doesn't make sense to have a separate `_repr_`.
> > > 
> > > Well, I happen to know that it will break foreign code.  But if you insist, I'll remove it.
> > 
> > What do you mean by foreign code? Code that is in the wild? I don't see how it would break it (only their doctests/output, but in a trivial way).
> 
> it's not a big thing:  FindStat uses the repr of perfect matchings also for input, but this can be changed easily.  I guess in the long run it's better, the only drawback being that you cannot use the output as input anymore.

For the free input box I'm guessing. Well, it is very close. I leave the final decision up to you. I don't strongly care either way.

> The code in check is `raise ValueError("%s is not an element of %s"%(self, self.parent()))`.  For some reason, at this point, `self` is already an instance of `PerfectMatching`, so the `_repr_` should be able to print it even if the number of parts is not always two.

Oh, I see.

> I admit that this is a hack, but that's not my fault.

Well, its only really an issue because of the custom `_repr_` and if that is making assumptions, but those are very easy to work around (if the code gets that far).

> > A side issue, the lack of an error message previously was fine because of the traceback.
> 
> I disagree - for me, the tracebacks are a pain if there cause is at top level.

The traceback is clear and it is the final part of it that gives the fault (just not the precise reason for it failing to be a set partition). This just becomes more code to maintain.

----

I've done a bit of cleanup of the perfect matchings and some of set partitions (much more is needed there) and taken care of duplicated code, the `__init__` issues, and improved the doc formatting.

I personally don't generally like `foo()` and `foo_iterator()` methods (well, both public), but that is another issue for another ticket.

If my changes look good, then positive review.
----
New commits:


---

Comment by mantepse created at 2017-10-17 18:25:22

Could you please explain why the `check` parameter in `PerfectMatching.__classcall_private__` is wrong?

I added a `check` parameter to `AlternatingSignMatrix.__classcall_private__` in #23819, which makes me wonder what's correct.


---

Comment by tscrim created at 2017-10-18 04:45:42

Replying to [comment:41 mantepse]:
> Could you please explain why the `check` parameter in `PerfectMatching.__classcall_private__` is wrong?

I do not like it as user input should generally always be checked. Saying it is wrong is debatable, but I am not in favor of bypassing safety checks in a user-specific function.

> I added a `check` parameter to `AlternatingSignMatrix.__classcall_private__` in #23819, which makes me wonder what's correct.

I didn't catch that when I looked over #23819. I don't like it there either.


---

Comment by mantepse created at 2017-10-18 06:18:29

So, if Alice needs to bypass checks for performance, she should do `AlternatingSignMatrices(3)(m, check=False)`?


---

Comment by tscrim created at 2017-10-18 15:54:13

Replying to [comment:43 mantepse]:
> So, if Alice needs to bypass checks for performance, she should do `AlternatingSignMatrices(3)(m, check=False)`?

Yes, that is correct (or avoiding more indirection with `P.element_class(m, check=False)`).


---

Comment by mantepse created at 2017-10-18 16:23:13

Thanks, I'll decide the `repr` thing tomorrow morning (slightly leaning towards removing the special handling for perfect matchings) and then set it to positive review, if you do not protest :-)

Thanks a lot for the collaboration!


---

Comment by tscrim created at 2017-10-18 16:24:39

Replying to [comment:45 mantepse]:
> Thanks, I'll decide the `repr` thing tomorrow morning (slightly leaning towards removing the special handling for perfect matchings) and then set it to positive review, if you do not protest :-)

Just let me give it a quick look-over, but I do not expect to object to anything.

> Thanks a lot for the collaboration!

Thank you for your continued work.


---

Comment by mantepse created at 2017-10-19 11:17:58

Sorry to bother you again, Travis: `P.element_class(m, check=False)` does not work.  It seems one should do

```   
   m = my_matrix
   m.set_immutable()
   P = AlternatingSignMatrices(m.nrows())
   return P.element_class(P, m)
```

I am a bit worried about this pattern, however, because effectively one needs to know very exactly how the data is initialised - eg., here it is not sufficient to pass a matrix, one must make it immutable, too.

Having the parameter `check` seemed a bit like a middle ground - the internal representation remains hidden, only the checks are switched off.

I'd like to sort this out properly.


---

Comment by tscrim created at 2017-10-19 15:14:52

IMO, this is essentially irrelevant to this ticket, but let's work through it now. First, `P.element_class(m, check=False)` will not work because I made a typo; it should have been `P.element_class(P, m, check=False)`. Yet, in this case the check is actually done by the `_element_constructor_`, not in the actual element class. Because you are directly using `P.element_class`, you are expected to be much more careful and know what you are doing, including whether or not the matrix is immutable or not (and side effects). So again, I want to remove the `check` in the `__classcall_private__` because that is not the way to construct elements for speed reasons.


---

Comment by mantepse created at 2017-10-19 17:32:40

I admit that I had no idea which method is actually invoked when I call `element_class` - apparently it's `__init__`.  I find the number of initialisation methods very confusing.  Sticking with the `A = AlternatingSignMatrices(1)` example for concreteness:

* `A([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` invokes `__element_constructor__`, then `__init__`
* `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` calls `__classcall_private__`, then `__init__`, then `__element_constructor__`, then `__init__` again.
* calling `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` again, the first call to `__init__` is omitted...

Is there any documentation on this?


```
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-129-ec4b906ad823> in <module>()
----> 1 A.element_class(A, [[Integer(1)]], check=False)

/home/martin/sage-develop/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1607)()
    331         else:
    332             # Fast version of type.__call__(cls, *args, **kwds)
--> 333             return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    334 
    335     def __get__(cls, instance, owner):

TypeError: __init__() got an unexpected keyword argument 'check'
```



---

Comment by tscrim created at 2017-10-20 00:39:59

Replying to [comment:50 mantepse]:
> I admit that I had no idea which method is actually invoked when I call `element_class` - apparently it's `__init__`.  I find the number of initialisation methods very confusing.  Sticking with the `A = AlternatingSignMatrices(1)` example for concreteness:
> * `A([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` invokes `__element_constructor__`, then `__init__`

Single underscore `_element_constructor_`, but functionally yes (there is the indirection through `AlternatingSignMatrices.__call__` and the coercion framework).

> * `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` calls `__classcall_private__`, then `__init__`, then `__element_constructor__`, then `__init__` again.

Not true. This calls `AlternatingSignMatrix.__classcall_private__`, which really can call anything it wants to. In this case, it creates a parent, and then passes the data `[This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro)` off to that `AlternatingSignMatrices.__call__` -> `AlternatingSignMatrices._element_constructor_` -> `AlternatingSignMatrix.__init__`.

> * calling `AlternatingSignMatrix([This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))` again, the first call to `__init__` is omitted...

No, that is false (well, possibly depending on which `__init__` you are referring to). There was never a first call to `AlternatingSignMatrix.__init__`. There is a construction of the parent, but that may or may not be (re)created depending on if it has been cleared from the cache or not.

> Is there any documentation on this?

This is in the `misc/classcall_metaclass.pyx` where it is defined (and imported).

> {{{
> ---------------------------------------------------------------------------
> TypeError                                 Traceback (most recent call last)
> <ipython-input-129-ec4b906ad823> in <module>()
> ----> 1 A.element_class(A, [This is the Trac macro *Integer* that was inherited from the migration called with arguments (1))](https://trac.sagemath.org/wiki/WikiMacros#Integer-macro), check=False)
> 
> /home/martin/sage-develop/src/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1607)()
>     331         else:
>     332             # Fast version of type.__call__(cls, *args, **kwds)
> --> 333             return (<PyTypeObject*>type).tp_call(cls, args, kwds)
>     334 
>     335     def __get__(cls, instance, owner):
> 
> TypeError: __init__() got an unexpected keyword argument 'check'
> }}}

This is in the `__new__` and so many things in Sage have a similar traceback for bad (keyword) arguments. The error message at the end of the traceback tells you exactly what the problem is.


---

Comment by mantepse created at 2017-10-20 05:21:43

> Not true. [...]
> No, that is false (well, possibly depending on which `__init__` you are referring to). 

Travis, I included a print statement in `AlternatingSignMatrix.__init__`, likewise in `AlternatingSignMatrix.__classcall_private__` and `AlternatingSignMatrices._elemente_constructor_`.  That's what I get:

```
sage: A = AlternatingSignMatrices(1)
sage: A([[1]])
element_constructor
init
[1]
sage: AlternatingSignMatrix([[1,0],[0,1]])
classcall_private
init
element_constructor
init

[1 0]
[0 1]
sage: AlternatingSignMatrix([[1,0],[0,1]])
classcall_private
element_constructor
init

[1 0]
[0 1]
```



---

Comment by tscrim created at 2017-10-20 05:32:13

No, it's not. You're too focused on the output to think about what else is going on and the program flow. In this case, it is the coercion framework (I printed `asm`):

```
sage: M = matrix(ZZ, [[0,1],[1,0]])
sage: M
[0 1]
[1 0]
sage: ASM = AlternatingSignMatrices(M.nrows())
sage: _ = ASM(M)
init
[1 0]
[0 1]
init
[0 1]
[1 0]
```

The first one is from initializing `ASM.an_element()` for the coercion framework test:

```
sage: ASM.an_element()
[1 0]
[0 1]
```



---

Comment by mantepse created at 2017-10-20 05:46:06

Thank you, that makes it a little clearer.  I find the documentation in `classcall_metaclass.pyx` very hard to read, I am not sure I want to learn what a metaclass really is.  I was hoping for clear instructions, ideally by a few examples, what to implement in which method.  Since `AlternatingSignMatrix` looks quite simple, I thought I'd take it...

I need an hour now...

Thanks again!


---

Comment by tscrim created at 2017-10-20 05:47:04

Replying to [comment:54 mantepse]:
> I need an hour now...

I might be asleep then (or not doing any problem).

> Thanks again!

No problem.


---

Comment by mantepse created at 2017-10-30 13:54:28

In the end I decided against changing the `_repr_` of perfect matchings.  There is some benefit in being able to copy-pasting the output.

Travis, could you please set it to positive review.

Once I have enough energy, I'll open a metaticket for unifying `check` in sage :-)


---

Comment by tscrim created at 2017-10-30 20:28:35

Thank you for your continued work.


---

Comment by tscrim created at 2017-10-30 20:28:35

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-11-01 18:07:41

Resolution: fixed
