# Issue 22287: Optimize computing points of lattice plytopes

Issue created by migration from https://trac.sagemath.org/ticket/22524

Original creator: novoselt

Original creation time: 2017-03-06 04:57:17

A follow up to #22391. My original problem was too slow computation of zero via

```python
Delta3 = LatticePolytope([(1,0,0), (0,1,0), (0,0,1), (-1,-4,-6)])
sum(len(e.interior_points()) * len(e.dual().interior_points()) for e in Delta3.edges())
```

Sage 7.6.beta4 gives
- timeit: 5 loops, best of 3: 1.73 s per loop
- profiler: 71844 function calls (71620 primitive calls) in 1.841 seconds
With #22391
- timeit: 5 loops, best of 3: 451 ms per loop
- profiler: 46502 function calls (46434 primitive calls) in 0.570 seconds
With this one
- timeit: 25 loops, best of 3: 11.3 ms per loop
- profiler: 7793 function calls (7747 primitive calls) in 0.031 seconds

As a less contrived example, it now takes 0.41s to get `ReflexivePolytopes(3)` (cached afterwards) instead of 7.61s. Part of the speed up is due to omitting some precomputation, but it is possible to do so because of speed up on demand.

Next goal is not to rely on PALP for computing points of standalone polytopes at all, although for large sets of polytopes it still may be the fastest option.


---

Comment by novoselt created at 2017-03-06 05:13:48

Had to fix a doctest, results of `sage -t --long src/sage/schemes/toric/fano_variety.py`

```
BEFORE (7.6.beta4)
Total time for all tests: 20.5 seconds
    cpu time: 13.5 seconds
    cumulative wall time: 20.4 seconds

AFTER
Total time for all tests: 5.0 seconds
    cpu time: 3.8 seconds
    cumulative wall time: 4.9 seconds
```

----
Last 10 new commits:


---

Comment by novoselt created at 2017-03-06 05:13:48

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2017-03-06 10:13:03

For large enough lattice point listing problems, considering using normaliz. Recent tickets have added it as a backend for `Polyhedron`.


---

Comment by novoselt created at 2017-03-06 16:08:29

Sure, but in toric geometry especially related to mirror symmetry it is important to handle very simple cases fast (e.g. all reflexive polytopes have precisely one interior lattice point, the origin).

Of course, it would be nice to handle all cases efficiently, and to be able to choose new methods appropriately I tried to first optimize existing one as much as possible, in particular not to take too much time just to convert data between different types.

Thanks for taking a look!


---

Comment by git created at 2017-09-10 20:43:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2017-10-11 13:35:03

Changing keywords from "" to "sd91".


---

Comment by git created at 2017-11-09 05:03:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-11-13 01:16:59

I think an even faster way than

```python
n = N.zero_vector()
for i, coef in enumerate(c.coefficients()):
    n[i] = coef
n.set_immutable()
normals.append(n)
```

would be

```python
n = N.element_class(N, c.coefficients(), coerce=False, copy=False)
n.set_immutable()
```

(although perhaps the coerce and copy are unnecessary). In general, if you know your input is good, you can bypass the extra overhead of `__call__` and `_element_constructor_` (there are a few places where you can do this I believe).

Also, it might be better to do

```diff
-                points = list(p.vertices())
-                for j in range(nv, m.ncols()):
-                    current = M.zero_vector()
-                    for i in range(M.rank()):
-                        current[i] = m[i, j]
-                    current.set_immutable()
-                    points.append(current)
+                points = list(p.vertices()) + m.columns(copy=False)
                 p._points = PointCollection(points, M)
```

Although I have not checked if the columns are longer than `M.rank()`.

Otherwise LGTM.


---

Comment by git created at 2017-11-13 05:47:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by novoselt created at 2017-11-13 05:56:56

Thank you for the pointer, `element_class` does lead to better timing and fewer function calls.

Regarding using matrix columns - that code deals with only some part of a matrix and, more importantly, is only used in "bad" cases: when dealing with non-full-dimensional polytopes or with a separate PALP call for a single polytope rather than sequence. My quick attempts to improve them now just broke things and I don't think they are worthy of more effort - the real solution is to rely on different backend. On the other hand, for computing points of many full-dimensional polytopes at once PALP interface still may be the fastest.


---

Comment by tscrim created at 2017-11-13 06:56:16

I see. Well, you can do the same `element_class` trick for

```python
                        current = M.zero_vector()
                        for i in range(M.rank()):
                            current[i] = m[i, j]
```

(there are 2 of these) and

```python
            p = lattice.zero_vector()
            for j, e in enumerate(f.readline().split()):
                p[j] = int(e)
```



---

Comment by git created at 2017-11-14 03:17:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by novoselt created at 2017-11-14 03:29:20

Travis - many many many thanks for reviewing all these tickets, making suggestions, and pushing me to implement them! I got 3-fold reduction in function calls for `lattice_polytope.all_points(ReflexivePolytopes(3))` and the actual call to PALP is now responsible for a half of the time.

Regarding using columns of matrices - it is kind of incompatible with `element_constructor` since it expects lists or tuples, not vectors. Constructing a vector and then converting it to a list takes 3 times longer than just constructing this list directly from matrix elements.

I have also dropped `copy=False, coerce=False` since they do not seem to be used in the code and (while I cannot use vectors...) I can feed strings directly into `element_constructor` without converting them to `int` first.


---

Comment by tscrim created at 2017-11-14 03:39:14

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2017-11-14 03:39:14

Replying to [comment:14 novoselt]:
> Travis - many many many thanks for reviewing all these tickets, making suggestions, and pushing me to implement them! I got 3-fold reduction in function calls for `lattice_polytope.all_points(ReflexivePolytopes(3))` and the actual call to PALP is now responsible for a half of the time.

Not a problem. I'm sorry to took me a while to get through them all.

> Regarding using columns of matrices - it is kind of incompatible with `element_constructor` since it expects lists or tuples, not vectors. Constructing a vector and then converting it to a list takes 3 times longer than just constructing this list directly from matrix elements.

I see.

> I have also dropped `copy=False, coerce=False` since they do not seem to be used in the code and (while I cannot use vectors...) I can feed strings directly into `element_constructor` without converting them to `int` first.

Yea, that's not too surprising. I didn't think they were being used considering the datatypes, but it was more just-in-case.

LGTM. Positive review.


---

Comment by vbraun created at 2017-12-11 01:03:57

Resolution: fixed
