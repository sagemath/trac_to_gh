# Issue 25361: Triconnectivity linear time algorithm

Issue created by migration from Trac.

Original creator: meghanamreddy

Original creation time: 2018-06-17 18:13:15

CC:  dcoudert dimpase saiharsh

Keywords: connectivity, decomposition, gsoc2018

Addition of the linear time algorithm for building triconnected components of a biconnected graph. This is a huge algorithm and we will be coding it one function at a time.


---

Comment by meghanamreddy created at 2018-06-17 18:15:30

I have added the basic class structure of the Triconnectivity module. As discussed, we will first code it in Python and then convert to Cython. Harsh and I will together add functions to the module.


---

Comment by git created at 2018-06-19 17:52:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-21 07:56:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-21 07:59:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-21 15:16:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-22 06:19:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-06-22 06:31:43

For the function `build_acceptable_adjacency_structure()`, but we require the orientation of the edges of the palm tree. Hence, in the `graph_copy` we are storing, we iterate through every edge, and if the orientation in graph is different from the palm tree, we reverse it. But I discovered the following -


```
g = Graph()
g.add_edges([(2,1)])
g.edges()
[(1, 2, None)]
```



```
g = Graph()
g.add_edges([(1,2)])
g.edges()
[(1, 2, None)]
```


Irrespective of the order of source and target given in the parameter of `add_edges()`, the edge is stored as `(1, 2, None)`. In such a situation, the other option of reversing an edge is possible if the graph is directed. But I do not want to convert the graph to a digraph, one of the reasons being that while converting, two edges in either direction are added to digraph corresponding to every edge in the original graph.

Hence, as of now, I have stored an additional dictionary named `edge_reversed`, and I'm storing all the edges as keys of the dictionary and the value as True or False to denote if the edge is in the reverse direction or not. Every place where the orientation of the edge matters, I have an if and else blocks. 

I don't think this is the best method. I am still looking for other methods. Please advice if [SageMath](SageMath) has some feature which can be used here.


Also, the function `dfs1()` has been thoroughly tested. I am still testing the function `build_acceptable_adjacency_structure()`, it is hard to test without the `dfs2()` function I think.


---

Comment by dcoudert created at 2018-06-22 06:47:12

> I don't think this is the best method. I am still looking for other methods. Please advice if [SageMath](SageMath) has some feature which can be used here.

Using dictionary here is a good option. Another solution could be to use a directed graph. I'll let you know if I think about a better solution.


---

Comment by git created at 2018-06-23 16:43:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-06-23 16:47:14

Instead of using the `O(n)` `edges_incident()` to get the incident edges of a vertex during dfs, added a list `graph_copy_adjacency` which stores the incident edges of vertex `i` in `graph_copy_adjacency[i]`. Harsh, please use this list while coding the function `dfs2()`.


---

Comment by dcoudert created at 2018-06-24 09:43:05

Just a few comments on coding style

- `if (self.dfs_number[w] < self.lowpt1[v]):`. You don't need to add the brackets.

- `if check == True: ` -> `if check:`

- `if len(comp):` -> `if comp:`. Indeed, if `comp == []`, the test is false, and if `comp` is not empty, the test will be true.

- `if self.edge_status[e] != 0 :` -> `if self.edge_status[e]:`. It's `False` only if the status is 0.

- `first_son == None` -> `first_son is None` is better I think.

- use `range` and not `xrange`. In Python 3, `range` becomes an iterator.

- `edge_reverse`. Instead of a dictionary, you could use a set and consider that an edge is reversed if it belongs to that set. It's not very important.


---

Comment by git created at 2018-06-24 14:10:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-06-24 14:11:42

I have made the changes. We will follow the same style from now on.


---

Comment by git created at 2018-06-24 17:45:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-28 21:04:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-30 18:58:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-04 19:03:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-04 19:16:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-15 07:49:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-07-15 08:01:58

`@`saiharsh,
I was debugging and fixed some bugs with pathsearch() but I found an error with the function split_multi_edges() and with the `edge_status` dictionary.
* In `split_multi_edges()`, 
    `sorted_edges = sorted(self.graph_copy.multiple_edges(labels=False))` removes the edge labels, however in `edge_status` dictionary, we store the edges along with the labels. Hence, if an edge `(3,4,None)` is removed and updated in `split_multi_edges()`, a new item `(3,4)` is added to `edge_status` with label `3` (i.e., denoting removed), whereas the item `(3,4,None)` remains with old label. In the rest of the algorithm, `(3,4,None)` is used, which leads to an error. For now I have changed that line to 
    `sorted_edges = sorted(self.graph_copy.multiple_edges(labels=True))`, need to check.

* A more fundamental error is with the dictionary `edge_status` itself. If we have multiedges `(1,2)` and `(1,2)` in the input graph, in `split_multi_edges()` we intend to change the status of one of the edges to removed and the other remains as a palm tree arc. But since the two edges are identical, one over-writes the other in the dictionary `edge_status`. The dictionary `edge_status` has only one copy of the edge for every set of multi-edges. I had assumed a dictionary would be a good way to store status of the edges but did not think about this error. Please suggest a way in which we can resolve this error. I will also update if I find some fix.

Run the code for a cycle on `4` vertices with one extra edge (the multi-edge).


---

Comment by saiharsh created at 2018-07-16 13:47:35

>sorted_edges = sorted(self.graph_copy.multiple_edges(labels=True)), need to check.
I feel it won't work if all the edges have same labels.

The error in `split_multi_edges()` because we are unable to differentiate between multiple edges, so I thought to label each edge according to entry in `G.edges`.


```
        from sage.graphs.graph import Graph
        self.graph_copy = Graph(multiedges=True)
        edges = G.edges()
        # dict to map new edges with the old edges
        self.edge_label_dict = {}
        for i in range(len(edges)):
            newEdge = tuple([edges[i][0], edges[i][1], i])
            self.graph_copy.add_edge(newEdge)
            self.edge_label_dict[newEdge] = edges[i]
        self.graph_copy = self.graph_copy.copy(implementation='c_graph')
```

Now `edge_status` will have entry of all multiple edges. \\
The only one problem is while returning the final answer we need to map the graph edge labels to it's previous labels using `edge_label_dict`. which will increase the time with `O(m)`.  \\
`edge_label_dict` will take new edge and return it's previous form. \\

I have manually checked `split_multiple_edges` is working as expected. \\
Please suggest me if there is a better way to solve this problem.


---

Comment by git created at 2018-07-16 14:10:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-07-18 15:26:33

There is a bug in your approach. You are modifying the graph while building `graph_copy`.
Since you are going through the edges and only adding the modified edges, all isolated vertices will be deleted, which is not desired. 

`split_multi_edges` is still giving the wrong output. I tried the following example:

```
sage: G = Graph()
sage: G.allow_multiple_edges(True)
sage: G.add_edges([(1,2),(2,3),(3,4),(4,5),(1,5),(1,5)])
sage: tric = Triconnectivity(G)
```


The connected component corresponding to the multi edges is being done correctly. But both the edges corresponding to `(1,5)` edge - `(0,4,1)` and `(0,4,2)` are given a value of `3` after `split_multi_edges`. Only one edge must be deleted.


---

Comment by git created at 2018-07-19 07:05:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-07-19 07:13:18

The `path_search` function is working for simple graphs, and the components are being computed correctly. It will work for multi-graphs also once the bug in `split_multi_edges` is fixed (since the graph becomes a simple graph after the preprocessing in `split_multi_edges`).

The function `assemble_triconnected_components` has to be coded now, which seems to be simple since the components are already computed and a few of them have to be merged in this function.

Once this function is done, we can thoroughly test the code by comparing the output with #22157 and OGDF. We can then work on cythonizing the code.


---

Comment by git created at 2018-07-19 11:25:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-19 12:09:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-24 13:48:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-07-24 13:53:53

The triconnectivity is completed. The triconnected components are now correctly constructed.
The triconnected components are being printed when we call the `Triconnectivity` function. An example-

```
sage: from sage.graphs.connectivity import Triconnectivity
sage: G = Graph()
sage: G.add_edges([(1,2),(1,4),(1,8),(1,12),(1,13),(2,3),(2,13),(3,4)])
sage: G.add_edges([(3,13),(4,5),(4,7),(5,6),(5,7),(5,8),(6,7),(8,9),(8,11)])
sage: G.add_edges([(8,12),(9,10),(9,11),(9,12),(10,11),(10,12)])
sage: tric = Triconnectivity(G)
```


In the output, the current format of vertices is numbers starting from `0` to `n`. Hence the edges printed will use these numberings. I am currently formatting the output to change the vertex labels to original labels. Will finish that in some time.

I am also adding comments to the code to make it more readable.
Please let me know if you find any discrepancies in the output.


---

Comment by git created at 2018-07-24 19:37:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-07-24 19:42:39

The output is now in terms of original labels. The triconnected components are printed and also stored in the variables `comp_list_new` and `comp_type`. `comp_list_new[i]` contains the list of edges belonging to the `i`th component. `comp_type[i]` contains the type of `i`th component (0=bond, 1=polygon, 2=triconnected component).
These can also be accessed as - 

```
tric = Triconnectivity(G)
tric.comp_list_new
tric.comp_type
```

Also, in the triconnected components, all the original edges have labels as per the input graph `G`. However, virtual edges have a label starting with `newVEdge` followed by the number of the virtual edge, i.e., `newVEdge5` or `newVEdge14`.


---

Comment by git created at 2018-07-27 10:44:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-27 12:40:51

I played with the code and got this

```
sage: G = Graph(2)
sage: for i in range(3):
....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
....:     
sage: tric = Triconnectivity(G)
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
...
KeyError: (1, 0, 'newVEdge1')
```



---

Comment by git created at 2018-07-27 18:43:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-01 18:19:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-03 19:50:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-03 19:58:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-06 12:57:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-06 13:06:34

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dcoudert created at 2018-08-06 13:28:19

I have added the dependency to #22157.

I will do more test, but so far it's working ;)

We now have to improve / polish the code with more comments, suitable tests, possible improvements, etc.


---

Comment by dcoudert created at 2018-08-06 14:48:13

I don't understand method `staticSPQRTree`. Can you explain it to me ? In particular, why do you need to instructions like `tric.vertex_to_int[originalEdge[0]]` ?


---

Comment by git created at 2018-08-06 14:53:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-06 16:44:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-06 16:44:45

`@`Meghana: In class `LinkedListNode`, why do you need to store a pointer to list linked object ? Is it really useful ? Shouldn't this be done only inside `LinkedList` ?
Also, if I'm not mistaken, method `replace` of `LinkedList` is not used. If so we can remove it, or better modify it to avoid storing the pointer to the list in the node.

I have pushed some review modifications.


---

Comment by meghanamreddy created at 2018-08-06 17:49:26

One operation that is required in the `path_search` function is to replace an edge with a different edge in the adjacency list of a vertex.
In the OGDF code, pointers and linked lists are used. So when we need to replace an edge, *e1 = *e2 will replace the edge without requiring any changes to the `LinkedList` object.

In python, I used references to try to replicate the same. Hence, I have a `LinkedList` object and each node is a `LinkedListNode`.
Here, when I replace a node, I have to update the `next` and `prev` pointers accordingly. But if the node to be replaced is the `head` of a `LinkedList` object, updating the `next` and `prev` pointers is not sufficient. The `head` variable of the corresponding linked list contains a reference to the old node, which has to be modified. And the only way to access the `head` variable of the corresponding `LinkedList` is if we have a reference to the `LinkedList` object from the node.

And yes, we are not using the `replace` of `LinkedList`. We can remove it. Unless we find some way to avoid storing the pointer to linked list.


---

Comment by git created at 2018-08-06 21:14:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-08-06 21:25:07

tric.comp_list_new: will have all the edges which are in `G` not in graph_copy. \\
graph_copy: will have nodes from 0...n-1 similarly edges. \\
vertex_to_int: to convert vertices from `G` to graph_copy. \\

Algo: Connect all the components using virtual edges, one virtual edge will connect two components.

1. Iterate over all the edges of the components and for each component creates a tree vertex.
2. If any virtual edge and partnerNode is None (i.e first component is not found) store tree vertex in partnerNode.
3. if any virtual edge and partnerNode is exist (i.e first component is found and current tree vertex is the second component), so add an edge between them.

For this I need a dictionary(partnerNode) which has all the edges of components, \\ initially, I used graph_copy edges as graph_copy has less number of edges then all the edges combined in components(many duplicated edges).
but there is a small issue sometime (1, 2, "newVEdge") is there sometime (2, 1, "newVEdge") which lead to use try and except, in current commit I removed it by initializing with edges in components.

Coming to `tric.vertex_to_int[originalEdge[0]]` as partnerNode has edges from graph_copy(initially) and comp_list_new has edges from `G`, so I needed to convert originalEdge to graph_copy edge using vertex_to_int but in current commit I excluded it.

Is it good to keep the current approach for creating tree with 0..n-1 vertex then relabeling it or create the tree with original labels itself?


---

Comment by dcoudert created at 2018-08-07 08:13:52

Replying to [comment:46 meghanamreddy]:
> One operation that is required in the `path_search` function is to replace an edge with a different edge in the adjacency list of a vertex.
> In the OGDF code, pointers and linked lists are used. So when we need to replace an edge, *e1 = *e2 will replace the edge without requiring any changes to the `LinkedList` object.

In C, instruction like `*e1 = *e2` copy the content of the memory cells pointed by e2 to the memory cells pointed by e2. So, wouldn't it be sufficient to do `self.set_data(node.get_data())` ? Considering the instructions you have right after each calls to `replace`, I think this is exactly what you need, no ?


---

Comment by git created at 2018-08-07 13:46:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-07 14:37:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-08-07 14:47:31

> In C, instruction like `*e1 = *e2` copy the content of the memory cells pointed by e2 to the memory cells pointed by e2. So, wouldn't it be sufficient to do `self.set_data(node.get_data())` ? Considering the instructions you have right after each calls to `replace`, I think this is exactly what you need, no ?

Yes, I am sorry. You are correct. We do not need the pointer to the linked list object. Using `self.set_data(new_edge)` is sufficient. I have updated the code.

We also have the variable `in_adj` which stores the reference to a node of `LinkedList`. And modifying the data inside a node of a `LinkedList` would modify it in `in_adj` wherever it is present. So I thought we would need to replace the entire node, which is not required. As you said, we only need to replace the data inside the node.


---

Comment by git created at 2018-08-07 17:35:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-07 17:53:13

I did several improvements / simplifications in the code. More can certainly be done.

You can try to add more comments in the code in some places. It's not easy to read (and I know you had hard time coding it). It is important for the maintainability of the code.

`@`Meghana: I did some trials to use real pointers for the linked list (with mallocs), but then I have hard time for freeing the memory. I don't know if I will be able to find a smart solution.

`@`both: what about moving the `staticSPQRTree` method inside `Triconnectivity` ? I don't like the idea of accessing internal variables outside the class.
Also, I think we should add a parameter `algorithm` to method `spqr_tree` and make this method the unique / favored way to get a SPQR tree. Would you agree ?

I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.


---

Comment by meghanamreddy created at 2018-08-07 18:28:24

Replying to [comment:54 dcoudert]:
> I did several improvements / simplifications in the code. More can certainly be done.
> 
> You can try to add more comments in the code in some places. It's not easy to read (and I know you had hard time coding it). It is important for the maintainability of the code.
> 
I saw your commits, I will work on adding more comments and improving the code.

> `@`Meghana: I did some trials to use real pointers for the linked list (with mallocs), but then I have hard time for freeing the memory. I don't know if I will be able to find a smart solution.
> 
In OGDF, all the memory allocated through malloc is being freed up at the end of the `init` function. I am not sure which method you tried, but maybe I can also work on it if you think only freeing the memory is the issue.

> `@`both: what about moving the `staticSPQRTree` method inside `Triconnectivity` ? I don't like the idea of accessing internal variables outside the class.
> Also, I think we should add a parameter `algorithm` to method `spqr_tree` and make this method the unique / favored way to get a SPQR tree. Would you agree ?
> 

Yes, adding a parameter `algorithm` is a good idea, many functions in [SageMath](SageMath) have a recommended algorithm. My doubt is how do we return the triconnected components or the SPQR tree. Currently, a call to `Triconnectivity` initializes the class and computes the triconnected components. We could also push `staticSPQRTree` inside `Triconnectivity`. Should we add two more functions like `get_triconnected_components` and `get_spqr_tree`? Then a call to the algorithm would be as

```
G = Graph()
G.add_edges()
tric = Triconnectivity(G)
components = tric.get_triconnected_components()
tree = tric.get_spqr_tree()
```


Also, in this case, we should probably name the `Triconnectivity` class appropriately to reflect SPQR tree functionality.
> I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.

Okay, we can try to cythonize some parts and do the remaining after GSOC period ends. Before the GSOC deadline, we could try to ensure the python code is as good as possible.


---

Comment by dcoudert created at 2018-08-07 19:04:06

> In OGDF, all the memory allocated through malloc is being freed up at the end of the `init` function. I am not sure which method you tried, but maybe I can also work on it if you think only freeing the memory is the issue.

For all arrays used in th class, it's quite easy to do. The main issue is if we try to use pointers inside `LinkedList`. How to trac all `LinkedListNode`s and ensure we properly free them in the end.
 
> Also, in this case, we should probably name the `Triconnectivity` class appropriately to reflect SPQR tree functionality.

Exactly.

> > I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.
> 
> Okay, we can try to cythonize some parts and do the remaining after GSOC period ends. Before the GSOC deadline, we could try to ensure the python code is as good as possible.

You are right. The most important is to improve/secure the Python version for the GSoC period.


---

Comment by dcoudert created at 2018-08-08 08:15:24

~~Question: I have a doubt with the usage of method `__high` that returns either 0 or `get_data` (so I assume an edge (tuple)). Then we have tests like `self.__high(v) > self.t_stack_h[self.t_stack_top]` or `self.__high(self.node_at[self.lowpt1[w]]) < vnum`. Can you explain me the logic behind ?~~
My fault. The values in `highpt` are only integers, so it's ok.


---

Comment by git created at 2018-08-08 16:54:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-08-08 17:08:01

Until we decide on the class name, I named it `TriconnectivitySPQR`. 
Also, what would we call the algorithm of `spqr_tree` which uses the `cleave` method? For how I have referred to it as `cleave` in the description of `spqr_tree`.

I have moved the examples of `staticSPQRtree` to the function `get_spqr_tree` since this will be the function through which it will be accessed? Is that okay? In this case, we can also move the examples of `TriconnectivitySPQR` class to `get_triconnected_components`.


---

Comment by saiharsh created at 2018-08-08 17:19:24

For example [Hopcroft1973]_, #25598 failed as `spqrtree_to_graph` is adding multi edge between (3, 1), it should not add as (3, 1) edge in H as it's a virtual edge. 
`spqrtree_to_graph` will remove (3, 1) edge only if there is a bond containing (3, 1), which couldn't be possible as (3, 1) does not belong to graph G.

```
sage: G = Graph()
sage: G = Graph()
sage: G.add_edges([(1,2),(1,4),(1,8),(1,12),(1,13),(2,3),(2,13),(3,4)])
sage: G.add_edges([(3,13),(4,5),(4,7),(5,6),(5,7),(5,8),(6,7),(8,9),(8,11)])
sage: G.add_edges([(8,12),(9,10),(9,11),(9,12),(10,11),(10,12)])
sage: tree = staticSPQRTree(G)
sage: H = spqr_tree_to_graph(tree)
sage: G.is_isomorphic(H)
False
sage: tric = Triconnectivity(G)
sage: tric.print_triconnected_components()
Triconnected:  [(8, 9, None), (9, 10, None), (10, 11, None), (9, 11, None), (8, 11, None), (10, 12, None), (9, 12, None), (8, 12, 'newVEdge0')]
Bond:  [(8, 12, None), (8, 12, 'newVEdge0'), (8, 12, 'newVEdge1')]
Polygon:  [(8, 12, 'newVEdge1'), (1, 12, None), (8, 1, 'newVEdge2')]
Bond:  [(1, 8, None), (8, 1, 'newVEdge2'), (8, 1, 'newVEdge3')]
Polygon:  [(5, 8, None), (8, 1, 'newVEdge3'), (4, 5, 'newVEdge8'), (4, 1, 'newVEdge9')]
Polygon:  [(5, 6, None), (6, 7, None), (5, 7, 'newVEdge5')]
Bond:  [(5, 7, None), (5, 7, 'newVEdge5'), (5, 7, 'newVEdge6')]
Polygon:  [(5, 7, 'newVEdge6'), (4, 7, None), (5, 4, 'newVEdge7')]
Bond:  [(5, 4, 'newVEdge7'), (4, 5, 'newVEdge8'), (4, 5, None)]
Bond:  [(1, 4, None), (4, 1, 'newVEdge9'), (4, 1, 'newVEdge10')]
Polygon:  [(3, 4, None), (4, 1, 'newVEdge10'), (3, 1, 'newVEdge11')]
Triconnected:  [(1, 2, None), (2, 3, None), (3, 1, 'newVEdge11'), (3, 13, None), (2, 13, None), (1, 13, None)]
```


Please see last two printed lines where one polygon and Triconnected component share same virtual edge. \\
Output of OGDF and `tric.print_triconnected_components()` are same.
In #22157 spqr_tree code is generating a bond with (3, 1) so G.is_isomorphic(H) is True.
Similar case in [Gut2001]_.


---

Comment by dcoudert created at 2018-08-08 18:44:39

Replying to [comment:60 saiharsh]:
> For example [Hopcroft1973]_, #25598 failed as `spqrtree_to_graph` ...

In fact, we are missing the `Bond: [(3, 1, 'newVEdge11'), (3, 1, 'newVEdge11')]`. 

Can you check when this virtual edge is added and see why the bond is not added ?


---

Comment by dcoudert created at 2018-08-08 18:50:59

Replying to [comment:59 meghanamreddy]:
> Until we decide on the class name, I named it `TriconnectivitySPQR`.
OK

> Also, what would we call the algorithm of `spqr_tree` which uses the `cleave` method? For how I have referred to it as `cleave` in the description of `spqr_tree`.
I agree

> I have moved the examples of `staticSPQRtree` to the function `get_spqr_tree` since this will be the function through which it will be accessed? Is that okay? 
Yes, but you should also move the code of `__staticSPQRTree(self)` inside this method.

>In this case, we can also move the examples of `TriconnectivitySPQR` class to `get_triconnected_components`.
No, it's good to have class examples. It ease the understanding of what a class can do / is used for, without having to check all methods.


---

Comment by saiharsh created at 2018-08-08 19:19:43

Replying to [comment:61 dcoudert]:
> In fact, we are missing the `Bond: [(3, 1, 'newVEdge11'), (3, 1, 'newVEdge11')]`. 
> Can you check when this virtual edge is added and see why the bond is not added ?
I feel a bond is created if there exists a real edge followed by virtual edges, i.e 
we are expecting a bond like `Bond: [(3, 1, 'None'), (3, 1, 'newVEdge11')]` but it's not possible as (1, 3) edge is not available in `G`.\\
OGDF returns 5 bonds and each 5 bonds has one real edge.
Correct me if I am wrong. \\


---

Comment by dcoudert created at 2018-08-08 19:35:05

The `spqr_tree` method using `cleave` returns 6 bonds and I think it is what we should expect. A bond is created for each 2-cut that is in the solution, even if it has no edge.


---

Comment by dcoudert created at 2018-08-08 21:43:58

Replying to [comment:64 dcoudert]:
> The `spqr_tree` method using `cleave` returns 6 bonds and I think it is what we should expect. A bond is created for each 2-cut that is in the solution, even if it has no edge.
After second thought, I think you are right, we should correct methods `spqr_tree` and method `spqr_tree_to_graph`. Any idea on how to do that ?


---

Comment by git created at 2018-08-09 08:53:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-09 09:01:25

I found a way to fix `spqr_tree_to_graph`. It suffices to count separately the number of occurrence of edges in S or R blocks and in P blocks. As multiedges are necessarily in P blocks, if an edges is 2 times in S or R blocks but not in a P block, it is a virtual edge separating 2 blocks and it is not in the original graph. If the virtual edge separates 3 blocks, then the algorithms creates a P block.

Note that the `abs` in `num = abs(count_P[e] - count_G[e])` is not needed. In fact, we could raise an error if `count_P[e] - count_G[e] < 0` in this case...

I will try to find a fix for the `spqr_tree` with `cleave` algorithm. A simple one is to remove P-blocks with only 2 edges before the construction of the spqr tree.

Question: is it really useful to let the `'newVEdge11'` labels ?


---

Comment by git created at 2018-08-09 10:15:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-09 10:23:59

If found a simple way to fix the `spqr_tree + cleave` method: remove P blocks with only 2 edges and add an edge between neighbors.

I have fixed `spqr_tree_to_graph`. It was missing some edges that are only in P blocks. Note that the example of Sai Harsh is the one with `G = Graph('LlCG{O`@`?GBoMw?')` (vertex relabels  to start from 0).

Please do more tests.


---

Comment by dcoudert created at 2018-08-09 15:01:35

`@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error "something goes wrong").

```
sage: G = Graph('IZSsJ`@`C_O')
sage: G = Graph('K\\LPcCIAS_D?')
```

Please check.


---

Comment by saiharsh created at 2018-08-09 15:43:11

Replying to [comment:70 dcoudert]:
> `@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error "something goes wrong").
> {{{
> sage: G = Graph('IZSsJ`@`C_O')
> sage: G = Graph('K\\LPcCIAS_D?')
> }}}
> Please check.
Yes, I will but from morning make failed twice, trying to get successful build now.
I hope I will get it by tomorrow morning. Reply as soon as possible.

(raising error "something goes wrong") -> it happened means there is a block with no cycle and multiedge, it could be a path, yet to see.


---

Comment by git created at 2018-08-09 18:44:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-08-09 18:56:11

Replying to [comment:70 dcoudert]:
> `@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error "something goes wrong").
> {{{
> sage: G = Graph('IZSsJ`@`C_O')
> sage: G = Graph('K\\LPcCIAS_D?')
> }}}
> Please check.

It seems to be working fine on my laptop. I ran `cleave` and `spqr_tree` and then also checked if `G.is_isomorphic(spqr_tree_to_graph(Tree))`. The output was `True` for both the graphs.


---

Comment by git created at 2018-08-10 08:25:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-10 08:28:42

I have added parameters solver and verbose that can be passed to `vertex_connectivity`.

I have also changed the way the cocycles graph is decomposed as some cycles may share a vertex. So a decomposition into biconnected components seems better. Correct me if I'm wrong. With this modification, the small graphs can be solved on my computer.

However, I have issue with this one. Can you try ? 

```
sage: G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
sage: T = spqr_tree(G, algorithm='cleave')
```



---

Comment by meghanamreddy created at 2018-08-10 12:58:04

> However, I have issue with this one. Can you try ? 
> {{{
> sage: G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
> sage: T = spqr_tree(G, algorithm='cleave')
> }}}

This gives me the "Something goes wrong error"

```
Traceback (click to the left of this block for traceback)
...
ValueError: something goes wrong
```



---

Comment by meghanamreddy created at 2018-08-10 14:43:40

My bad, I forgot to add the parameter `algorithm` yesterday on the other two examples. These two graphs -

```
sage: G = Graph('IZSsJ`@`C_O')
sage: G = Graph('K\\LPcCIAS_D?')
```

Also give me the error `something goes wrong`.


---

Comment by dcoudert created at 2018-08-10 15:23:20

You get the error with the commits of this morning ?


---

Comment by meghanamreddy created at 2018-08-10 15:42:51

My bad again, I did a `git pull` now. Now the graphs -

```
sage: G = Graph('IZSsJ`@`C_O')
sage: G = Graph('K\\LPcCIAS_D?')
```

give no error.
The graph 

```
G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
```

gives the `something goes wrong` error.


---

Comment by git created at 2018-08-10 17:50:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-08-10 17:54:42

Replying to [comment:75 dcoudert]: 
> However, I have issue with this one. Can you try ? 
> {{{
> sage: G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
> sage: T = spqr_tree(G, algorithm='cleave')
> }}}
At last I got a successful build of sage.
As mentioned by meghana I also got the same results.
For graph 

```
G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
```

It looks like error is coming when block is an bi-connected component with no multiedges but that error block and R_blocks has three edges common
there are 

```
(6, 10, None)
(6, 19, None)
(10, 19, None)
```

If we remove these edges from the error block we will get a cycle. 
Is it like we are not deleting less edges? correct me if I am wrong.


---

Comment by dcoudert created at 2018-08-10 17:58:01

I did a small correction to avoid removing a virtual edge between 2 cycles when the virtual is in a cut with 3 or more components. The result for graph `G = Graph('F^~E?')` was not correct (a `K5` minus edge (0,1) plus 2 paths attachaed).

`@`saiharsh: yes, when we have an error, the graph is biconnected without multiple edges. Do you know if edges `(6, 10), (6,19), (10, 19)` are virtual or not ?


---

Comment by saiharsh created at 2018-08-10 18:03:30

Replying to [comment:82 dcoudert]:
> I did a small correction to avoid removing a virtual edge between 2 cycles when the virtual is in a cut with 3 or more components. The result for graph `G = Graph('F^~E?')` was not correct (a `K5` minus edge (0,1) plus 2 paths attachaed).
> 
> `@`saiharsh: yes, when we have an error, the graph is biconnected without multiple edges. Do you know if edges `(6, 10), (6,19), (10, 19)` are virtual or not ?
Only (6, 10) is a real edge, remaining (6,19), (10, 19) are virtual edges.


---

Comment by git created at 2018-08-11 10:51:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-11 11:03:08

Got it ! Take the graph 

```
    G = Graph()
    G.add_cycle([6, 13, 10, 27, 19, 26])
    G.add_edge(6, 10)
    K = [0, 1, 2, 3]
    G.add_clique(K)
    for u in [6, 10, 19]:
        for v in K:
            G.add_edge(u, v)
```

The algorithm identifies 3-cycles `[6, 10, 13], [10, 19, 27], [6, 10, 26]`, and the algorithm is right not to identify cycle `[6, 10, 19]` since it is part of a R_block. If you put all edges of these cycles in a same graph, we don't know what to do.

I have changed the way we handle cycles. I should be easier to understand, and more importantly, I think it gives the good result.

Please check & test.


---

Comment by saiharsh created at 2018-08-11 12:53:16

Replying to [comment:85 dcoudert]:
> The algorithm identifies 3-cycles `[6, 10, 13], [10, 19, 27], [6, 10, 26]`, and the algorithm is right not to identify cycle `[6, 10, 19]` since it is part of a R_block. If you put all edges of these cycles in a same graph, we don't know what to do.
Yes, you are right.
> 
> I have changed the way we handle cycles. I should be easier to understand, and more importantly, I think it gives the good result.
> 
> Please check & test.
Yes, it's easier to understand, it fixed the last problem. \\
I tested on Petersen, RandomTriangulation, paper examples and previous graphs. All are passed. \\
I will try on more graphs if I found anything I will update you.


---

Comment by git created at 2018-08-12 09:08:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-12 09:18:46

I have added the case of Q blocks in all methods.

In TriconnectivitySPQR, do we really need methods `get_triconnected_components` and `print_triconnected_components` ? We can of course let them as they are useful for testing methods in the class, but the most important is to return the SPQR tree.

I propose to modify methods so that the `__init__` performs all computations including the construction of the spqr tree, and then the `get_triconnected_components` and `print_triconnected_components` methods just have to consider the nodes of the tree. Do you agree ?


---

Comment by meghanamreddy created at 2018-08-12 10:47:41

> I propose to modify methods so that the `__init__` performs all computations including the construction of the spqr tree, and then the `get_triconnected_components` and `print_triconnected_components` methods just have to consider the nodes of the tree. Do you agree ?

Yes, I agree. We should do it. We could make the spqr tree a variable and store it in the `TriconnectivitySPQR` class in the `__init__` function. The functions `get_triconnected_components` and `print_triconnected_components` could use the tree stored in the class. 

Currently, to use this algorithm, two lines of code is required. 

```
tric = TriconnectivitySPQR(G)
tric.get_spqr_tree()
```

Making the suggested change would not decrease the two lines of code. To an external user, this structural change would not make any difference. But internally, we would have a better design. Do you agree? I will make this change.


---

Comment by dcoudert created at 2018-08-12 12:36:56

Go for it !


---

Comment by git created at 2018-08-12 19:36:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-08-12 19:45:52

I moved the spqr construction to the init. However, the doctests are failing due to the following reason.

The functions `get_triconnected_components` and `print_triconnected_components` use the nodes of the SPQR tree to output the components. Suppose we have two `bond` components, each with the same number of edges. Let the two bond edges be `(1,2)` and (`3,4)`. The corresponding nodes in the SPQR tree will be -

```
[('P', Multi-graph on 2 vertices),
 ('P', Multi-graph on 2 vertices)]
```

The ordering of these two vertices in the SPQR tree is random since both would be considered as similar vertices. When we access the vertices of the SPQR tree using `for node in self.spqr_tree.vertices()`, we could either get the bond `(1,2)` first or `(3,4)` first. Hence, while constructing the triconnected components from the SPQR tree, there is no fixed ordering of the output components, and thus the doctests will fail.


---

Comment by meghanamreddy created at 2018-08-12 19:53:38

It does not make sense to force an ordering on the nodes of the SPQR tree.
We can let the spqr tree be constructed in `init`, but use `comp_list_new` and `comp_type` to compute the components in the functions `get_triconnected_components` and `print_triconnected_components`, the way we were doing it earlier?


---

Comment by dcoudert created at 2018-08-12 22:26:06

As a SPQR tree is a graph, we can assume an ordering of the vertices. This is a strong requirement for many graph algorithms: there is a unique order of the vertices. So for these methods, you can use a loop over the vertices. You can check that one of  `(1, 2)` or `(3, 4)` will always before the other.


---

Comment by meghanamreddy created at 2018-08-13 04:54:49

Even I thought so, but I check the below example

```
Tree = Graph()
Tree.add_vertex(('P', Graph( {1:[0] }, immutable=True, multiedges=True)))
Tree.add_vertex(('P', Graph( {2:[3] }, immutable=True, multiedges=True)))
Tree.vertices()[0][1].edges()
```

In the SPQR tree, the vertices in the tree are ordered by their type - bonds first, then triconnected components and polygons after that. But within the bonds, if two bonds have the same number of vertices (it is printed as `Multi-graph on 2 vertices`), the order of these bonds is not fixed.

In the example above, I'm printing the edges of the first node of the tree. I ran it 4-5 times. And the output is not fixed. Sometimes it is `[(0, 1, None)]` and sometimes `[(2, 3, None)]`.

If I print the vertices of the tree with `Tree.vertices()`, the output is `[('P', Multi-graph on 2 vertices), ('P', Multi-graph on 2 vertices)]`.


---

Comment by dcoudert created at 2018-08-13 07:39:50

I was not expecting that. Currently the vertices are sorted (and there is a proposal for deprecating sorting to save time). It explains why we have bonds then polygons then triconnected (`P`, `S`, `R`). I thought that vertices like `('P', Multi-graph on 2 vertices)` had an implicit ordering but I don't know how immutable graphs are hashed...
So it's better to use the previous method.


---

Comment by git created at 2018-08-13 18:22:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-14 10:52:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-14 10:54:47

I did some improvements of the documentation. More can certainly be done


---

Comment by git created at 2018-08-19 16:46:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-08-19 17:00:48

In bucket sort, edges `(u, v)` are sorted in such a way that first preference is given to `v` if the same `v` then compare `u`. i.e (1, 2) will come before (0, 3). \\
Initially, we used the sorted function which is the reverse of bucket sort i.e (0, 3) will come before (1, 2). \\
As there is a change in edge processing in `split_multiple_edges`, creation of components and edges which leads to jumble in triconnectivity output. \\
Let me know if there is any other problem.


---

Comment by dcoudert created at 2018-08-19 17:33:42

The ordering is not an issue as long as the result of the triconnectivity decomposition and construction of spqr tree remains correct.

Have you check if this algorithm is effectively faster that the `sorted` method ?


---

Comment by saiharsh created at 2018-08-19 17:52:14

Replying to [comment:102 dcoudert]:
> The ordering is not an issue as long as the result of the triconnectivity decomposition and construction of spqr tree remains correct.
Yes, construction of spqr-tree remains correct. 
> 
> Have you check if this algorithm is effectively faster that the `sorted` method ?
I expect that current method is slightly better than the `sorted` method, as ``sorted`` method uses Timsort and it's running time is `O(mlogm)` m is no. of edges, whereas bucket sort uses extra space but running time is linear. \\
Practically I didn't compare both methods.


---

Comment by git created at 2018-08-19 17:58:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-21 17:16:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by meghanamreddy created at 2018-08-21 17:47:56

I made some small changes in the comments and made the sorting functions private.

And I compared the bucket sort function with the previously used `sorted` function of Python. The bucket sort seems to be slightly faster than `sorted`. I did not do extensive testing, but with a graph on `3000` vertices (`graphs.RandomBarabasiAlbert(3000,2)`), the bucket sort took about `0.64` seconds and the previous sort took about `0.7` seconds. For a grid graph on `1000` vertices, bucket sort took `0.22` seconds and the previous sort took `0.33` seconds.


---

Comment by dcoudert created at 2018-08-21 17:52:27

Changing status from new to needs_review.


---

Comment by dcoudert created at 2018-08-21 17:52:27

I set this ticket to needs review as I think it is almost ready. I will try to review it seriously before the end of the week.


---

Comment by git created at 2018-08-22 13:26:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-22 13:28:54

I did some improvements in the documentation and added a TODO block.
I still have to check that the html output looks good.


---

Comment by git created at 2018-08-22 14:05:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-22 14:06:00

For me this patch is ready. Please double check.


---

Comment by git created at 2018-08-28 16:22:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-28 16:57:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-28 17:07:27

I have exposed the `spqr_tree` method in `Graph` and done some more tests.
I was about to give positive review... but I found 2 issues, one in `spqr_tree` with the `cleave` method and one in `TriconnectivitySPQR`.

1. For some reason, some 3-cycles are not merged with algorithm `cleave`. I will check that.

```
sage: G = graphs.PetersenGraph()
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),v])
....:     
sage: T = G.spqr_tree()
sage: T2 = G.spqr_tree(algorithm="cleave")
sage: T
SPQR-tree of Petersen graph: Graph on 31 vertices
sage: T2
SPQR tree of Petersen graph: Graph on 43 vertices
```

2. Some vertices (1 in the example below) are marked as `R`-block instead of `S`-block. Please check.

```
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),v])
sage: T = G.spqr_tree()
sage: T
SPQR-tree of Petersen graph: Graph on 136 vertices
sage: for u in T:
....:     if u[0] == 'R':
....:         print(u, u[1].is_cycle())
('R', Multi-graph on 10 vertices) False
('R', Multi-graph on 4 vertices) True
```



---

Comment by git created at 2018-08-29 12:04:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-29 12:07:30

I fixed the issue with cleave. We were missing associations between cycles and virtual edges.

I added a (big) test that fails with `Hopcroft_Tarjan` as one cycle is detected as a `R` block. I will have a look at the code, but it should be easier for you to find the issue.


---

Comment by dcoudert created at 2018-08-29 12:54:08

method `finish_tric_or_poly` is called for a component with 4 edges and so given type 2 although it's a cycle. It seems that we are missing a 2-cut here. Any idea on how to correct that ?


---

Comment by git created at 2018-08-29 17:42:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-29 17:49:45

Unless I'm mistaken, there is only one biconnected simple graph without loops or multiple edges and 4 edges: a 4-cycle. So my last commit fixes the issue I detected with Hopcroft-Tarjan.

Please double check and do some more tests so that I can finally set this ticket to positive review.


---

Comment by meghanamreddy created at 2018-08-29 17:53:20

Yes, I am checking it. Will update once I do some tests.


---

Comment by dcoudert created at 2018-08-30 07:00:43

My last commit is not enough. If instead of 4-cycles, we add 5-cycles, from time to time some 5-cycles are identified as `R`-blocks :(

Consider the following example without 'R'-block

```
sage: G = graphs.CycleGraph(4)
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
sage: T = G.spqr_tree()
sage: V = G.vertices()
sage: while not Counter(u[0] for u in T)['R']:
....:     shuffle(V)
....:     G.relabel(perm=V, inplace=True)
....:     T = G.spqr_tree()
sage: Counter(u[0] for u in T)
Counter({'S': 24, 'P': 20, 'R': 1})
```

I don't know if it's a problem of the algorithm that must be fixed, or if it's a "bug" in the code.


---

Comment by git created at 2018-08-30 09:08:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-30 09:15:48

I really suspect this is an algorithmic issue (I can't find a clear answer in the papers). It would be nice if one of you can try to reproduce the issue with OGDF. If I'm right, then we can report the issue to OGDF.

Meanwhile, I found a simple way to fix the issue: maintain a list of vertices in each component that is update each time an edge is added. Then, in `finish_tric_or_poly`, we can decide the type of the component by checking if it has more edges than vertices (type 2) or not (type 1).

I have changed the construction of the last component to also use `finish_tric_or_poly`. It's cleaner this way and ensures that we have the good type. I had to update some tests accordingly.

Let me know if you agree.


---

Comment by git created at 2018-08-30 10:28:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-30 10:49:23

I discovered and fixed an issue with labeled edges as we can't do `"newVEdge" in e[2]` when `e[2]` is a number.


---

Comment by git created at 2018-08-30 11:32:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-08-30 11:34:20

I added a method to create virtual edges. It also stores the list of virtual edges which simplifies the test in the construction of the spqr tree.


---

Comment by git created at 2018-09-02 12:56:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-09-02 13:04:06

`@`Meghana, Sai Harsh: can you do a last check ?


---

Comment by saiharsh created at 2018-09-02 13:21:11

Replying to [comment:129 dcoudert]:
> `@`Meghana, Sai Harsh: can you do a last check ?
Yes, I will. \\
I will see if there is the same case in OGDF for example without 'R'-block. \\
I will try reply by Monday night, worst case Tuesday Morning.


---

Comment by meghanamreddy created at 2018-09-02 18:27:09

Yes, I will also work on it. I was travelling the last 3 days. Will work on it tomorrow.


---

Comment by meghanamreddy created at 2018-09-03 19:39:56

Replying to [comment:121 dcoudert]:
> My last commit is not enough. If instead of 4-cycles, we add 5-cycles, from time to time some 5-cycles are identified as `R`-blocks :(
> 
> Consider the following example without 'R'-block
> {{{
> sage: G = graphs.CycleGraph(4)
> sage: for u,v in G.edges(labels=False):
> ....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
> sage: for u,v in G.edges(labels=False):
> ....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
> sage: T = G.spqr_tree()
> sage: V = G.vertices()
> sage: while not Counter(u[0] for u in T)['R']:
> ....:     shuffle(V)
> ....:     G.relabel(perm=V, inplace=True)
> ....:     T = G.spqr_tree()
> sage: Counter(u[0] for u in T)
> Counter({'S': 24, 'P': 20, 'R': 1})
> }}}
> I don't know if it's a problem of the algorithm that must be fixed, or if it's a "bug" in the code.

I took a graph from the above example which has one `R` component, and ran OGDF code on it. The OGDF output contained only bonds and cycles and no triconnected components. So I feel it could be a bug in our code, I will debug it tomorrow.


---

Comment by dcoudert created at 2018-09-03 19:51:13

Con you also try adding one more level of paths to `G` and check it with OGDF ? Thanks.


---

Comment by meghanamreddy created at 2018-09-04 19:06:56

Ya, I tried. OGDF output does not have any `R` components.
Please give me some time, I am working on debugging our code.


---

Comment by saiharsh created at 2018-09-06 18:58:48

`while not Counter(u[0] for u in T)['R']:` loop ran for nearly 14 hrs on my system still no R block is found. \\
That while loop will break only if one R block is found, it's not happening for me, I am still getting the same results like OGDF `Counter({'S': 25, 'P': 20})`. \\
When will I get the same case?


---

Comment by dcoudert created at 2018-09-06 19:15:34

I one of the last commits, I changed the way to detect if a block is 'R' or 'S'. But as it is sufficient in OGDF to check if the number of edges is `>= 4`, we suspect there is something wrong somewhere, but I don't know what/where.

You can modify `finish_tric_or_poly` to just check number of edges to see the issue.


---

Comment by meghanamreddy created at 2018-09-08 16:36:59

I found the bug. It was a mistake I did, should have been more careful. Anyway, I am pushing the code in a few minutes.

David, I think we can undo the changes you made to fix the bug.


---

Comment by git created at 2018-09-08 18:12:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-09-09 04:21:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-09-09 09:21:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-09-09 09:25:38

Excellent ! Thank you.

We no longer need to count the number of vertices per components, so I removed that part.

I did several tests and for me every thing is going well now. If you also agree, I will finally set this ticket to positive review. It was quite a lot of work.


---

Comment by meghanamreddy created at 2018-09-10 17:51:18

Yes, I think we can set the ticket to positive review.


---

Comment by dcoudert created at 2018-09-10 21:15:48

This ticket was a big piece of work and you did a great job. Thanks to both of you.


---

Comment by dcoudert created at 2018-09-10 21:15:48

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-09-11 21:47:38

Author name...


---

Comment by vbraun created at 2018-09-11 21:47:38

Changing status from positive_review to needs_work.


---

Comment by dimpase created at 2018-09-11 21:54:53

Changing status from needs_work to positive_review.


---

Comment by chapoton created at 2018-09-12 14:40:53

hey, ladies and gentlemen ! coverage is supposed to be 100%

```
+Decreased doctests in graphs/connectivity.pyx: from 21 / 21 = 100% to 24 / 60 = 40%
```



---

Comment by dimpase created at 2018-09-12 14:43:32

perhaps a follow-up ticket to address testing?


---

Comment by dcoudert created at 2018-09-12 15:15:12

We implement a big algorithm that is split into sub methods. I don't know how to add doctests that are meaningful for the sub methods. Any suggestion is more than welcome.

But for sure I plan to continue working on it (remove recursions, cythonise what I can, etc.).


---

Comment by vbraun created at 2018-09-13 19:25:25

Resolution: fixed


---

Comment by dcoudert created at 2018-10-24 11:59:27

This is certainly something technical but I'll be happy to know (learn) what's going on. Thanks.


---

Comment by embray created at 2018-10-28 14:52:23

This should be re-targeted for 8.5.
