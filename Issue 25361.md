# Issue 25361: Triconnectivity linear time algorithm

archive/issues_025361.json:
```json
{
    "body": "CC:  dcoudert dimpase saiharsh\n\nKeywords: connectivity, decomposition, gsoc2018\n\nAddition of the linear time algorithm for building triconnected components of a biconnected graph. This is a huge algorithm and we will be coding it one function at a time.\n\nIssue created by migration from https://trac.sagemath.org/ticket/25598\n\n",
    "created_at": "2018-06-17T18:13:15Z",
    "labels": [
        "graph theory",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.5",
    "title": "Triconnectivity linear time algorithm",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25361",
    "user": "meghanamreddy"
}
```
CC:  dcoudert dimpase saiharsh

Keywords: connectivity, decomposition, gsoc2018

Addition of the linear time algorithm for building triconnected components of a biconnected graph. This is a huge algorithm and we will be coding it one function at a time.

Issue created by migration from https://trac.sagemath.org/ticket/25598





---

archive/issue_comments_357449.json:
```json
{
    "body": "I have added the basic class structure of the Triconnectivity module. As discussed, we will first code it in Python and then convert to Cython. Harsh and I will together add functions to the module.",
    "created_at": "2018-06-17T18:15:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357449",
    "user": "meghanamreddy"
}
```

I have added the basic class structure of the Triconnectivity module. As discussed, we will first code it in Python and then convert to Cython. Harsh and I will together add functions to the module.



---

archive/issue_comments_357450.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-19T17:52:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357450",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357451.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-21T07:56:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357451",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357452.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-21T07:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357452",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357453.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-21T15:16:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357453",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357454.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-22T06:19:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357454",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357455.json:
```json
{
    "body": "For the function `build_acceptable_adjacency_structure()`, but we require the orientation of the edges of the palm tree. Hence, in the `graph_copy` we are storing, we iterate through every edge, and if the orientation in graph is different from the palm tree, we reverse it. But I discovered the following -\n\n\n```\ng = Graph()\ng.add_edges([(2,1)])\ng.edges()\n[(1, 2, None)]\n```\n\n\n\n```\ng = Graph()\ng.add_edges([(1,2)])\ng.edges()\n[(1, 2, None)]\n```\n\n\nIrrespective of the order of source and target given in the parameter of `add_edges()`, the edge is stored as `(1, 2, None)`. In such a situation, the other option of reversing an edge is possible if the graph is directed. But I do not want to convert the graph to a digraph, one of the reasons being that while converting, two edges in either direction are added to digraph corresponding to every edge in the original graph.\n\nHence, as of now, I have stored an additional dictionary named `edge_reversed`, and I'm storing all the edges as keys of the dictionary and the value as True or False to denote if the edge is in the reverse direction or not. Every place where the orientation of the edge matters, I have an if and else blocks. \n\nI don't think this is the best method. I am still looking for other methods. Please advice if [SageMath](SageMath) has some feature which can be used here.\n\n\nAlso, the function `dfs1()` has been thoroughly tested. I am still testing the function `build_acceptable_adjacency_structure()`, it is hard to test without the `dfs2()` function I think.",
    "created_at": "2018-06-22T06:31:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357455",
    "user": "meghanamreddy"
}
```

For the function `build_acceptable_adjacency_structure()`, but we require the orientation of the edges of the palm tree. Hence, in the `graph_copy` we are storing, we iterate through every edge, and if the orientation in graph is different from the palm tree, we reverse it. But I discovered the following -


```
g = Graph()
g.add_edges([(2,1)])
g.edges()
[(1, 2, None)]
```



```
g = Graph()
g.add_edges([(1,2)])
g.edges()
[(1, 2, None)]
```


Irrespective of the order of source and target given in the parameter of `add_edges()`, the edge is stored as `(1, 2, None)`. In such a situation, the other option of reversing an edge is possible if the graph is directed. But I do not want to convert the graph to a digraph, one of the reasons being that while converting, two edges in either direction are added to digraph corresponding to every edge in the original graph.

Hence, as of now, I have stored an additional dictionary named `edge_reversed`, and I'm storing all the edges as keys of the dictionary and the value as True or False to denote if the edge is in the reverse direction or not. Every place where the orientation of the edge matters, I have an if and else blocks. 

I don't think this is the best method. I am still looking for other methods. Please advice if [SageMath](SageMath) has some feature which can be used here.


Also, the function `dfs1()` has been thoroughly tested. I am still testing the function `build_acceptable_adjacency_structure()`, it is hard to test without the `dfs2()` function I think.



---

archive/issue_comments_357456.json:
```json
{
    "body": "> I don't think this is the best method. I am still looking for other methods. Please advice if [SageMath](SageMath) has some feature which can be used here.\n\nUsing dictionary here is a good option. Another solution could be to use a directed graph. I'll let you know if I think about a better solution.",
    "created_at": "2018-06-22T06:47:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357456",
    "user": "dcoudert"
}
```

> I don't think this is the best method. I am still looking for other methods. Please advice if [SageMath](SageMath) has some feature which can be used here.

Using dictionary here is a good option. Another solution could be to use a directed graph. I'll let you know if I think about a better solution.



---

archive/issue_comments_357457.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-23T16:43:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357457",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357458.json:
```json
{
    "body": "Instead of using the `O(n)` `edges_incident()` to get the incident edges of a vertex during dfs, added a list `graph_copy_adjacency` which stores the incident edges of vertex `i` in `graph_copy_adjacency[i]`. Harsh, please use this list while coding the function `dfs2()`.",
    "created_at": "2018-06-23T16:47:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357458",
    "user": "meghanamreddy"
}
```

Instead of using the `O(n)` `edges_incident()` to get the incident edges of a vertex during dfs, added a list `graph_copy_adjacency` which stores the incident edges of vertex `i` in `graph_copy_adjacency[i]`. Harsh, please use this list while coding the function `dfs2()`.



---

archive/issue_comments_357459.json:
```json
{
    "body": "Just a few comments on coding style\n\n- `if (self.dfs_number[w] < self.lowpt1[v]):`. You don't need to add the brackets.\n\n- `if check == True: ` -> `if check:`\n\n- `if len(comp):` -> `if comp:`. Indeed, if `comp == []`, the test is false, and if `comp` is not empty, the test will be true.\n\n- `if self.edge_status[e] != 0 :` -> `if self.edge_status[e]:`. It's `False` only if the status is 0.\n\n- `first_son == None` -> `first_son is None` is better I think.\n\n- use `range` and not `xrange`. In Python 3, `range` becomes an iterator.\n\n- `edge_reverse`. Instead of a dictionary, you could use a set and consider that an edge is reversed if it belongs to that set. It's not very important.",
    "created_at": "2018-06-24T09:43:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357459",
    "user": "dcoudert"
}
```

Just a few comments on coding style

- `if (self.dfs_number[w] < self.lowpt1[v]):`. You don't need to add the brackets.

- `if check == True: ` -> `if check:`

- `if len(comp):` -> `if comp:`. Indeed, if `comp == []`, the test is false, and if `comp` is not empty, the test will be true.

- `if self.edge_status[e] != 0 :` -> `if self.edge_status[e]:`. It's `False` only if the status is 0.

- `first_son == None` -> `first_son is None` is better I think.

- use `range` and not `xrange`. In Python 3, `range` becomes an iterator.

- `edge_reverse`. Instead of a dictionary, you could use a set and consider that an edge is reversed if it belongs to that set. It's not very important.



---

archive/issue_comments_357460.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-24T14:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357460",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357461.json:
```json
{
    "body": "I have made the changes. We will follow the same style from now on.",
    "created_at": "2018-06-24T14:11:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357461",
    "user": "meghanamreddy"
}
```

I have made the changes. We will follow the same style from now on.



---

archive/issue_comments_357462.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-24T17:45:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357462",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357463.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-28T21:04:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357463",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357464.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-30T18:58:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357464",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357465.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-04T19:03:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357465",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357466.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-04T19:16:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357466",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357467.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-15T07:49:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357467",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357468.json:
```json
{
    "body": "`@`saiharsh,\nI was debugging and fixed some bugs with pathsearch() but I found an error with the function split_multi_edges() and with the `edge_status` dictionary.\n* In `split_multi_edges()`, \n    `sorted_edges = sorted(self.graph_copy.multiple_edges(labels=False))` removes the edge labels, however in `edge_status` dictionary, we store the edges along with the labels. Hence, if an edge `(3,4,None)` is removed and updated in `split_multi_edges()`, a new item `(3,4)` is added to `edge_status` with label `3` (i.e., denoting removed), whereas the item `(3,4,None)` remains with old label. In the rest of the algorithm, `(3,4,None)` is used, which leads to an error. For now I have changed that line to \n    `sorted_edges = sorted(self.graph_copy.multiple_edges(labels=True))`, need to check.\n\n* A more fundamental error is with the dictionary `edge_status` itself. If we have multiedges `(1,2)` and `(1,2)` in the input graph, in `split_multi_edges()` we intend to change the status of one of the edges to removed and the other remains as a palm tree arc. But since the two edges are identical, one over-writes the other in the dictionary `edge_status`. The dictionary `edge_status` has only one copy of the edge for every set of multi-edges. I had assumed a dictionary would be a good way to store status of the edges but did not think about this error. Please suggest a way in which we can resolve this error. I will also update if I find some fix.\n\nRun the code for a cycle on `4` vertices with one extra edge (the multi-edge).",
    "created_at": "2018-07-15T08:01:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357468",
    "user": "meghanamreddy"
}
```

`@`saiharsh,
I was debugging and fixed some bugs with pathsearch() but I found an error with the function split_multi_edges() and with the `edge_status` dictionary.
* In `split_multi_edges()`, 
    `sorted_edges = sorted(self.graph_copy.multiple_edges(labels=False))` removes the edge labels, however in `edge_status` dictionary, we store the edges along with the labels. Hence, if an edge `(3,4,None)` is removed and updated in `split_multi_edges()`, a new item `(3,4)` is added to `edge_status` with label `3` (i.e., denoting removed), whereas the item `(3,4,None)` remains with old label. In the rest of the algorithm, `(3,4,None)` is used, which leads to an error. For now I have changed that line to 
    `sorted_edges = sorted(self.graph_copy.multiple_edges(labels=True))`, need to check.

* A more fundamental error is with the dictionary `edge_status` itself. If we have multiedges `(1,2)` and `(1,2)` in the input graph, in `split_multi_edges()` we intend to change the status of one of the edges to removed and the other remains as a palm tree arc. But since the two edges are identical, one over-writes the other in the dictionary `edge_status`. The dictionary `edge_status` has only one copy of the edge for every set of multi-edges. I had assumed a dictionary would be a good way to store status of the edges but did not think about this error. Please suggest a way in which we can resolve this error. I will also update if I find some fix.

Run the code for a cycle on `4` vertices with one extra edge (the multi-edge).



---

archive/issue_comments_357469.json:
```json
{
    "body": ">sorted_edges = sorted(self.graph_copy.multiple_edges(labels=True)), need to check.\nI feel it won't work if all the edges have same labels.\n\nThe error in `split_multi_edges()` because we are unable to differentiate between multiple edges, so I thought to label each edge according to entry in `G.edges`.\n\n\n```\n        from sage.graphs.graph import Graph\n        self.graph_copy = Graph(multiedges=True)\n        edges = G.edges()\n        # dict to map new edges with the old edges\n        self.edge_label_dict = {}\n        for i in range(len(edges)):\n            newEdge = tuple([edges[i][0], edges[i][1], i])\n            self.graph_copy.add_edge(newEdge)\n            self.edge_label_dict[newEdge] = edges[i]\n        self.graph_copy = self.graph_copy.copy(implementation='c_graph')\n```\n\nNow `edge_status` will have entry of all multiple edges. \\\\\nThe only one problem is while returning the final answer we need to map the graph edge labels to it's previous labels using `edge_label_dict`. which will increase the time with `O(m)`.  \\\\\n`edge_label_dict` will take new edge and return it's previous form. \\\\\n\nI have manually checked `split_multiple_edges` is working as expected. \\\\\nPlease suggest me if there is a better way to solve this problem.",
    "created_at": "2018-07-16T13:47:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357469",
    "user": "saiharsh"
}
```

>sorted_edges = sorted(self.graph_copy.multiple_edges(labels=True)), need to check.
I feel it won't work if all the edges have same labels.

The error in `split_multi_edges()` because we are unable to differentiate between multiple edges, so I thought to label each edge according to entry in `G.edges`.


```
        from sage.graphs.graph import Graph
        self.graph_copy = Graph(multiedges=True)
        edges = G.edges()
        # dict to map new edges with the old edges
        self.edge_label_dict = {}
        for i in range(len(edges)):
            newEdge = tuple([edges[i][0], edges[i][1], i])
            self.graph_copy.add_edge(newEdge)
            self.edge_label_dict[newEdge] = edges[i]
        self.graph_copy = self.graph_copy.copy(implementation='c_graph')
```

Now `edge_status` will have entry of all multiple edges. \\
The only one problem is while returning the final answer we need to map the graph edge labels to it's previous labels using `edge_label_dict`. which will increase the time with `O(m)`.  \\
`edge_label_dict` will take new edge and return it's previous form. \\

I have manually checked `split_multiple_edges` is working as expected. \\
Please suggest me if there is a better way to solve this problem.



---

archive/issue_comments_357470.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-16T14:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357470",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357471.json:
```json
{
    "body": "There is a bug in your approach. You are modifying the graph while building `graph_copy`.\nSince you are going through the edges and only adding the modified edges, all isolated vertices will be deleted, which is not desired. \n\n`split_multi_edges` is still giving the wrong output. I tried the following example:\n\n```\nsage: G = Graph()\nsage: G.allow_multiple_edges(True)\nsage: G.add_edges([(1,2),(2,3),(3,4),(4,5),(1,5),(1,5)])\nsage: tric = Triconnectivity(G)\n```\n\n\nThe connected component corresponding to the multi edges is being done correctly. But both the edges corresponding to `(1,5)` edge - `(0,4,1)` and `(0,4,2)` are given a value of `3` after `split_multi_edges`. Only one edge must be deleted.",
    "created_at": "2018-07-18T15:26:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357471",
    "user": "meghanamreddy"
}
```

There is a bug in your approach. You are modifying the graph while building `graph_copy`.
Since you are going through the edges and only adding the modified edges, all isolated vertices will be deleted, which is not desired. 

`split_multi_edges` is still giving the wrong output. I tried the following example:

```
sage: G = Graph()
sage: G.allow_multiple_edges(True)
sage: G.add_edges([(1,2),(2,3),(3,4),(4,5),(1,5),(1,5)])
sage: tric = Triconnectivity(G)
```


The connected component corresponding to the multi edges is being done correctly. But both the edges corresponding to `(1,5)` edge - `(0,4,1)` and `(0,4,2)` are given a value of `3` after `split_multi_edges`. Only one edge must be deleted.



---

archive/issue_comments_357472.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-19T07:05:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357472",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357473.json:
```json
{
    "body": "The `path_search` function is working for simple graphs, and the components are being computed correctly. It will work for multi-graphs also once the bug in `split_multi_edges` is fixed (since the graph becomes a simple graph after the preprocessing in `split_multi_edges`).\n\nThe function `assemble_triconnected_components` has to be coded now, which seems to be simple since the components are already computed and a few of them have to be merged in this function.\n\nOnce this function is done, we can thoroughly test the code by comparing the output with #22157 and OGDF. We can then work on cythonizing the code.",
    "created_at": "2018-07-19T07:13:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357473",
    "user": "meghanamreddy"
}
```

The `path_search` function is working for simple graphs, and the components are being computed correctly. It will work for multi-graphs also once the bug in `split_multi_edges` is fixed (since the graph becomes a simple graph after the preprocessing in `split_multi_edges`).

The function `assemble_triconnected_components` has to be coded now, which seems to be simple since the components are already computed and a few of them have to be merged in this function.

Once this function is done, we can thoroughly test the code by comparing the output with #22157 and OGDF. We can then work on cythonizing the code.



---

archive/issue_comments_357474.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-19T11:25:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357474",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357475.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-19T12:09:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357475",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357476.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T13:48:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357476",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357477.json:
```json
{
    "body": "The triconnectivity is completed. The triconnected components are now correctly constructed.\nThe triconnected components are being printed when we call the `Triconnectivity` function. An example-\n\n```\nsage: from sage.graphs.connectivity import Triconnectivity\nsage: G = Graph()\nsage: G.add_edges([(1,2),(1,4),(1,8),(1,12),(1,13),(2,3),(2,13),(3,4)])\nsage: G.add_edges([(3,13),(4,5),(4,7),(5,6),(5,7),(5,8),(6,7),(8,9),(8,11)])\nsage: G.add_edges([(8,12),(9,10),(9,11),(9,12),(10,11),(10,12)])\nsage: tric = Triconnectivity(G)\n```\n\n\nIn the output, the current format of vertices is numbers starting from `0` to `n`. Hence the edges printed will use these numberings. I am currently formatting the output to change the vertex labels to original labels. Will finish that in some time.\n\nI am also adding comments to the code to make it more readable.\nPlease let me know if you find any discrepancies in the output.",
    "created_at": "2018-07-24T13:53:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357477",
    "user": "meghanamreddy"
}
```

The triconnectivity is completed. The triconnected components are now correctly constructed.
The triconnected components are being printed when we call the `Triconnectivity` function. An example-

```
sage: from sage.graphs.connectivity import Triconnectivity
sage: G = Graph()
sage: G.add_edges([(1,2),(1,4),(1,8),(1,12),(1,13),(2,3),(2,13),(3,4)])
sage: G.add_edges([(3,13),(4,5),(4,7),(5,6),(5,7),(5,8),(6,7),(8,9),(8,11)])
sage: G.add_edges([(8,12),(9,10),(9,11),(9,12),(10,11),(10,12)])
sage: tric = Triconnectivity(G)
```


In the output, the current format of vertices is numbers starting from `0` to `n`. Hence the edges printed will use these numberings. I am currently formatting the output to change the vertex labels to original labels. Will finish that in some time.

I am also adding comments to the code to make it more readable.
Please let me know if you find any discrepancies in the output.



---

archive/issue_comments_357478.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T19:37:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357478",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357479.json:
```json
{
    "body": "The output is now in terms of original labels. The triconnected components are printed and also stored in the variables `comp_list_new` and `comp_type`. `comp_list_new[i]` contains the list of edges belonging to the `i`th component. `comp_type[i]` contains the type of `i`th component (0=bond, 1=polygon, 2=triconnected component).\nThese can also be accessed as - \n\n```\ntric = Triconnectivity(G)\ntric.comp_list_new\ntric.comp_type\n```\n\nAlso, in the triconnected components, all the original edges have labels as per the input graph `G`. However, virtual edges have a label starting with `newVEdge` followed by the number of the virtual edge, i.e., `newVEdge5` or `newVEdge14`.",
    "created_at": "2018-07-24T19:42:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357479",
    "user": "meghanamreddy"
}
```

The output is now in terms of original labels. The triconnected components are printed and also stored in the variables `comp_list_new` and `comp_type`. `comp_list_new[i]` contains the list of edges belonging to the `i`th component. `comp_type[i]` contains the type of `i`th component (0=bond, 1=polygon, 2=triconnected component).
These can also be accessed as - 

```
tric = Triconnectivity(G)
tric.comp_list_new
tric.comp_type
```

Also, in the triconnected components, all the original edges have labels as per the input graph `G`. However, virtual edges have a label starting with `newVEdge` followed by the number of the virtual edge, i.e., `newVEdge5` or `newVEdge14`.



---

archive/issue_comments_357480.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-27T10:44:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357480",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357481.json:
```json
{
    "body": "I played with the code and got this\n\n```\nsage: G = Graph(2)\nsage: for i in range(3):\n....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])\n....:     \nsage: tric = Triconnectivity(G)\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n...\nKeyError: (1, 0, 'newVEdge1')\n```\n",
    "created_at": "2018-07-27T12:40:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357481",
    "user": "dcoudert"
}
```

I played with the code and got this

```
sage: G = Graph(2)
sage: for i in range(3):
....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
....:     
sage: tric = Triconnectivity(G)
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
...
KeyError: (1, 0, 'newVEdge1')
```




---

archive/issue_comments_357482.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-27T18:43:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357482",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357483.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-01T18:19:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357483",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357484.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-03T19:50:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357484",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357485.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-03T19:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357485",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357486.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-06T12:57:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357486",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357487.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2018-08-06T13:06:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357487",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_357488.json:
```json
{
    "body": "I have added the dependency to #22157.\n\nI will do more test, but so far it's working ;)\n\nWe now have to improve / polish the code with more comments, suitable tests, possible improvements, etc.",
    "created_at": "2018-08-06T13:28:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357488",
    "user": "dcoudert"
}
```

I have added the dependency to #22157.

I will do more test, but so far it's working ;)

We now have to improve / polish the code with more comments, suitable tests, possible improvements, etc.



---

archive/issue_comments_357489.json:
```json
{
    "body": "I don't understand method `staticSPQRTree`. Can you explain it to me ? In particular, why do you need to instructions like `tric.vertex_to_int[originalEdge[0]]` ?",
    "created_at": "2018-08-06T14:48:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357489",
    "user": "dcoudert"
}
```

I don't understand method `staticSPQRTree`. Can you explain it to me ? In particular, why do you need to instructions like `tric.vertex_to_int[originalEdge[0]]` ?



---

archive/issue_comments_357490.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-06T14:53:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357490",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357491.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-06T16:44:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357491",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357492.json:
```json
{
    "body": "`@`Meghana: In class `LinkedListNode`, why do you need to store a pointer to list linked object ? Is it really useful ? Shouldn't this be done only inside `LinkedList` ?\nAlso, if I'm not mistaken, method `replace` of `LinkedList` is not used. If so we can remove it, or better modify it to avoid storing the pointer to the list in the node.\n\nI have pushed some review modifications.",
    "created_at": "2018-08-06T16:44:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357492",
    "user": "dcoudert"
}
```

`@`Meghana: In class `LinkedListNode`, why do you need to store a pointer to list linked object ? Is it really useful ? Shouldn't this be done only inside `LinkedList` ?
Also, if I'm not mistaken, method `replace` of `LinkedList` is not used. If so we can remove it, or better modify it to avoid storing the pointer to the list in the node.

I have pushed some review modifications.



---

archive/issue_comments_357493.json:
```json
{
    "body": "One operation that is required in the `path_search` function is to replace an edge with a different edge in the adjacency list of a vertex.\nIn the OGDF code, pointers and linked lists are used. So when we need to replace an edge, *e1 = *e2 will replace the edge without requiring any changes to the `LinkedList` object.\n\nIn python, I used references to try to replicate the same. Hence, I have a `LinkedList` object and each node is a `LinkedListNode`.\nHere, when I replace a node, I have to update the `next` and `prev` pointers accordingly. But if the node to be replaced is the `head` of a `LinkedList` object, updating the `next` and `prev` pointers is not sufficient. The `head` variable of the corresponding linked list contains a reference to the old node, which has to be modified. And the only way to access the `head` variable of the corresponding `LinkedList` is if we have a reference to the `LinkedList` object from the node.\n\nAnd yes, we are not using the `replace` of `LinkedList`. We can remove it. Unless we find some way to avoid storing the pointer to linked list.",
    "created_at": "2018-08-06T17:49:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357493",
    "user": "meghanamreddy"
}
```

One operation that is required in the `path_search` function is to replace an edge with a different edge in the adjacency list of a vertex.
In the OGDF code, pointers and linked lists are used. So when we need to replace an edge, *e1 = *e2 will replace the edge without requiring any changes to the `LinkedList` object.

In python, I used references to try to replicate the same. Hence, I have a `LinkedList` object and each node is a `LinkedListNode`.
Here, when I replace a node, I have to update the `next` and `prev` pointers accordingly. But if the node to be replaced is the `head` of a `LinkedList` object, updating the `next` and `prev` pointers is not sufficient. The `head` variable of the corresponding linked list contains a reference to the old node, which has to be modified. And the only way to access the `head` variable of the corresponding `LinkedList` is if we have a reference to the `LinkedList` object from the node.

And yes, we are not using the `replace` of `LinkedList`. We can remove it. Unless we find some way to avoid storing the pointer to linked list.



---

archive/issue_comments_357494.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-06T21:14:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357494",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357495.json:
```json
{
    "body": "tric.comp_list_new: will have all the edges which are in `G` not in graph_copy. \\\\\ngraph_copy: will have nodes from 0...n-1 similarly edges. \\\\\nvertex_to_int: to convert vertices from `G` to graph_copy. \\\\\n\nAlgo: Connect all the components using virtual edges, one virtual edge will connect two components.\n\n1. Iterate over all the edges of the components and for each component creates a tree vertex.\n2. If any virtual edge and partnerNode is None (i.e first component is not found) store tree vertex in partnerNode.\n3. if any virtual edge and partnerNode is exist (i.e first component is found and current tree vertex is the second component), so add an edge between them.\n\nFor this I need a dictionary(partnerNode) which has all the edges of components, \\\\ initially, I used graph_copy edges as graph_copy has less number of edges then all the edges combined in components(many duplicated edges).\nbut there is a small issue sometime (1, 2, \"newVEdge\") is there sometime (2, 1, \"newVEdge\") which lead to use try and except, in current commit I removed it by initializing with edges in components.\n\nComing to `tric.vertex_to_int[originalEdge[0]]` as partnerNode has edges from graph_copy(initially) and comp_list_new has edges from `G`, so I needed to convert originalEdge to graph_copy edge using vertex_to_int but in current commit I excluded it.\n\nIs it good to keep the current approach for creating tree with 0..n-1 vertex then relabeling it or create the tree with original labels itself?",
    "created_at": "2018-08-06T21:25:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357495",
    "user": "saiharsh"
}
```

tric.comp_list_new: will have all the edges which are in `G` not in graph_copy. \\
graph_copy: will have nodes from 0...n-1 similarly edges. \\
vertex_to_int: to convert vertices from `G` to graph_copy. \\

Algo: Connect all the components using virtual edges, one virtual edge will connect two components.

1. Iterate over all the edges of the components and for each component creates a tree vertex.
2. If any virtual edge and partnerNode is None (i.e first component is not found) store tree vertex in partnerNode.
3. if any virtual edge and partnerNode is exist (i.e first component is found and current tree vertex is the second component), so add an edge between them.

For this I need a dictionary(partnerNode) which has all the edges of components, \\ initially, I used graph_copy edges as graph_copy has less number of edges then all the edges combined in components(many duplicated edges).
but there is a small issue sometime (1, 2, "newVEdge") is there sometime (2, 1, "newVEdge") which lead to use try and except, in current commit I removed it by initializing with edges in components.

Coming to `tric.vertex_to_int[originalEdge[0]]` as partnerNode has edges from graph_copy(initially) and comp_list_new has edges from `G`, so I needed to convert originalEdge to graph_copy edge using vertex_to_int but in current commit I excluded it.

Is it good to keep the current approach for creating tree with 0..n-1 vertex then relabeling it or create the tree with original labels itself?



---

archive/issue_comments_357496.json:
```json
{
    "body": "Replying to [comment:46 meghanamreddy]:\n> One operation that is required in the `path_search` function is to replace an edge with a different edge in the adjacency list of a vertex.\n> In the OGDF code, pointers and linked lists are used. So when we need to replace an edge, *e1 = *e2 will replace the edge without requiring any changes to the `LinkedList` object.\n\nIn C, instruction like `*e1 = *e2` copy the content of the memory cells pointed by e2 to the memory cells pointed by e2. So, wouldn't it be sufficient to do `self.set_data(node.get_data())` ? Considering the instructions you have right after each calls to `replace`, I think this is exactly what you need, no ?",
    "created_at": "2018-08-07T08:13:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357496",
    "user": "dcoudert"
}
```

Replying to [comment:46 meghanamreddy]:
> One operation that is required in the `path_search` function is to replace an edge with a different edge in the adjacency list of a vertex.
> In the OGDF code, pointers and linked lists are used. So when we need to replace an edge, *e1 = *e2 will replace the edge without requiring any changes to the `LinkedList` object.

In C, instruction like `*e1 = *e2` copy the content of the memory cells pointed by e2 to the memory cells pointed by e2. So, wouldn't it be sufficient to do `self.set_data(node.get_data())` ? Considering the instructions you have right after each calls to `replace`, I think this is exactly what you need, no ?



---

archive/issue_comments_357497.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-07T13:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357497",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357498.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-07T14:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357498",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357499.json:
```json
{
    "body": "> In C, instruction like `*e1 = *e2` copy the content of the memory cells pointed by e2 to the memory cells pointed by e2. So, wouldn't it be sufficient to do `self.set_data(node.get_data())` ? Considering the instructions you have right after each calls to `replace`, I think this is exactly what you need, no ?\n\nYes, I am sorry. You are correct. We do not need the pointer to the linked list object. Using `self.set_data(new_edge)` is sufficient. I have updated the code.\n\nWe also have the variable `in_adj` which stores the reference to a node of `LinkedList`. And modifying the data inside a node of a `LinkedList` would modify it in `in_adj` wherever it is present. So I thought we would need to replace the entire node, which is not required. As you said, we only need to replace the data inside the node.",
    "created_at": "2018-08-07T14:47:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357499",
    "user": "meghanamreddy"
}
```

> In C, instruction like `*e1 = *e2` copy the content of the memory cells pointed by e2 to the memory cells pointed by e2. So, wouldn't it be sufficient to do `self.set_data(node.get_data())` ? Considering the instructions you have right after each calls to `replace`, I think this is exactly what you need, no ?

Yes, I am sorry. You are correct. We do not need the pointer to the linked list object. Using `self.set_data(new_edge)` is sufficient. I have updated the code.

We also have the variable `in_adj` which stores the reference to a node of `LinkedList`. And modifying the data inside a node of a `LinkedList` would modify it in `in_adj` wherever it is present. So I thought we would need to replace the entire node, which is not required. As you said, we only need to replace the data inside the node.



---

archive/issue_comments_357500.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-07T17:35:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357500",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357501.json:
```json
{
    "body": "I did several improvements / simplifications in the code. More can certainly be done.\n\nYou can try to add more comments in the code in some places. It's not easy to read (and I know you had hard time coding it). It is important for the maintainability of the code.\n\n`@`Meghana: I did some trials to use real pointers for the linked list (with mallocs), but then I have hard time for freeing the memory. I don't know if I will be able to find a smart solution.\n\n`@`both: what about moving the `staticSPQRTree` method inside `Triconnectivity` ? I don't like the idea of accessing internal variables outside the class.\nAlso, I think we should add a parameter `algorithm` to method `spqr_tree` and make this method the unique / favored way to get a SPQR tree. Would you agree ?\n\nI'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.",
    "created_at": "2018-08-07T17:53:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357501",
    "user": "dcoudert"
}
```

I did several improvements / simplifications in the code. More can certainly be done.

You can try to add more comments in the code in some places. It's not easy to read (and I know you had hard time coding it). It is important for the maintainability of the code.

`@`Meghana: I did some trials to use real pointers for the linked list (with mallocs), but then I have hard time for freeing the memory. I don't know if I will be able to find a smart solution.

`@`both: what about moving the `staticSPQRTree` method inside `Triconnectivity` ? I don't like the idea of accessing internal variables outside the class.
Also, I think we should add a parameter `algorithm` to method `spqr_tree` and make this method the unique / favored way to get a SPQR tree. Would you agree ?

I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.



---

archive/issue_comments_357502.json:
```json
{
    "body": "Replying to [comment:54 dcoudert]:\n> I did several improvements / simplifications in the code. More can certainly be done.\n> \n> You can try to add more comments in the code in some places. It's not easy to read (and I know you had hard time coding it). It is important for the maintainability of the code.\n> \nI saw your commits, I will work on adding more comments and improving the code.\n\n> `@`Meghana: I did some trials to use real pointers for the linked list (with mallocs), but then I have hard time for freeing the memory. I don't know if I will be able to find a smart solution.\n> \nIn OGDF, all the memory allocated through malloc is being freed up at the end of the `init` function. I am not sure which method you tried, but maybe I can also work on it if you think only freeing the memory is the issue.\n\n> `@`both: what about moving the `staticSPQRTree` method inside `Triconnectivity` ? I don't like the idea of accessing internal variables outside the class.\n> Also, I think we should add a parameter `algorithm` to method `spqr_tree` and make this method the unique / favored way to get a SPQR tree. Would you agree ?\n> \n\nYes, adding a parameter `algorithm` is a good idea, many functions in [SageMath](SageMath) have a recommended algorithm. My doubt is how do we return the triconnected components or the SPQR tree. Currently, a call to `Triconnectivity` initializes the class and computes the triconnected components. We could also push `staticSPQRTree` inside `Triconnectivity`. Should we add two more functions like `get_triconnected_components` and `get_spqr_tree`? Then a call to the algorithm would be as\n\n```\nG = Graph()\nG.add_edges()\ntric = Triconnectivity(G)\ncomponents = tric.get_triconnected_components()\ntree = tric.get_spqr_tree()\n```\n\n\nAlso, in this case, we should probably name the `Triconnectivity` class appropriately to reflect SPQR tree functionality.\n> I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.\n\nOkay, we can try to cythonize some parts and do the remaining after GSOC period ends. Before the GSOC deadline, we could try to ensure the python code is as good as possible.",
    "created_at": "2018-08-07T18:28:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357502",
    "user": "meghanamreddy"
}
```

Replying to [comment:54 dcoudert]:
> I did several improvements / simplifications in the code. More can certainly be done.
> 
> You can try to add more comments in the code in some places. It's not easy to read (and I know you had hard time coding it). It is important for the maintainability of the code.
> 
I saw your commits, I will work on adding more comments and improving the code.

> `@`Meghana: I did some trials to use real pointers for the linked list (with mallocs), but then I have hard time for freeing the memory. I don't know if I will be able to find a smart solution.
> 
In OGDF, all the memory allocated through malloc is being freed up at the end of the `init` function. I am not sure which method you tried, but maybe I can also work on it if you think only freeing the memory is the issue.

> `@`both: what about moving the `staticSPQRTree` method inside `Triconnectivity` ? I don't like the idea of accessing internal variables outside the class.
> Also, I think we should add a parameter `algorithm` to method `spqr_tree` and make this method the unique / favored way to get a SPQR tree. Would you agree ?
> 

Yes, adding a parameter `algorithm` is a good idea, many functions in [SageMath](SageMath) have a recommended algorithm. My doubt is how do we return the triconnected components or the SPQR tree. Currently, a call to `Triconnectivity` initializes the class and computes the triconnected components. We could also push `staticSPQRTree` inside `Triconnectivity`. Should we add two more functions like `get_triconnected_components` and `get_spqr_tree`? Then a call to the algorithm would be as

```
G = Graph()
G.add_edges()
tric = Triconnectivity(G)
components = tric.get_triconnected_components()
tree = tric.get_spqr_tree()
```


Also, in this case, we should probably name the `Triconnectivity` class appropriately to reflect SPQR tree functionality.
> I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.

Okay, we can try to cythonize some parts and do the remaining after GSOC period ends. Before the GSOC deadline, we could try to ensure the python code is as good as possible.



---

archive/issue_comments_357503.json:
```json
{
    "body": "> In OGDF, all the memory allocated through malloc is being freed up at the end of the `init` function. I am not sure which method you tried, but maybe I can also work on it if you think only freeing the memory is the issue.\n\nFor all arrays used in th class, it's quite easy to do. The main issue is if we try to use pointers inside `LinkedList`. How to trac all `LinkedListNode`s and ensure we properly free them in the end.\n \n> Also, in this case, we should probably name the `Triconnectivity` class appropriately to reflect SPQR tree functionality.\n\nExactly.\n\n> > I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.\n> \n> Okay, we can try to cythonize some parts and do the remaining after GSOC period ends. Before the GSOC deadline, we could try to ensure the python code is as good as possible.\n\nYou are right. The most important is to improve/secure the Python version for the GSoC period.",
    "created_at": "2018-08-07T19:04:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357503",
    "user": "dcoudert"
}
```

> In OGDF, all the memory allocated through malloc is being freed up at the end of the `init` function. I am not sure which method you tried, but maybe I can also work on it if you think only freeing the memory is the issue.

For all arrays used in th class, it's quite easy to do. The main issue is if we try to use pointers inside `LinkedList`. How to trac all `LinkedListNode`s and ensure we properly free them in the end.
 
> Also, in this case, we should probably name the `Triconnectivity` class appropriately to reflect SPQR tree functionality.

Exactly.

> > I'd like to cythonize parts of the code in order to make it faster and reduce memory consumption. No emergency for that. I'll see if I can do something tomorrow.
> 
> Okay, we can try to cythonize some parts and do the remaining after GSOC period ends. Before the GSOC deadline, we could try to ensure the python code is as good as possible.

You are right. The most important is to improve/secure the Python version for the GSoC period.



---

archive/issue_comments_357504.json:
```json
{
    "body": "~~Question: I have a doubt with the usage of method `__high` that returns either 0 or `get_data` (so I assume an edge (tuple)). Then we have tests like `self.__high(v) > self.t_stack_h[self.t_stack_top]` or `self.__high(self.node_at[self.lowpt1[w]]) < vnum`. Can you explain me the logic behind ?~~\nMy fault. The values in `highpt` are only integers, so it's ok.",
    "created_at": "2018-08-08T08:15:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357504",
    "user": "dcoudert"
}
```

~~Question: I have a doubt with the usage of method `__high` that returns either 0 or `get_data` (so I assume an edge (tuple)). Then we have tests like `self.__high(v) > self.t_stack_h[self.t_stack_top]` or `self.__high(self.node_at[self.lowpt1[w]]) < vnum`. Can you explain me the logic behind ?~~
My fault. The values in `highpt` are only integers, so it's ok.



---

archive/issue_comments_357505.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-08T16:54:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357505",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357506.json:
```json
{
    "body": "Until we decide on the class name, I named it `TriconnectivitySPQR`. \nAlso, what would we call the algorithm of `spqr_tree` which uses the `cleave` method? For how I have referred to it as `cleave` in the description of `spqr_tree`.\n\nI have moved the examples of `staticSPQRtree` to the function `get_spqr_tree` since this will be the function through which it will be accessed? Is that okay? In this case, we can also move the examples of `TriconnectivitySPQR` class to `get_triconnected_components`.",
    "created_at": "2018-08-08T17:08:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357506",
    "user": "meghanamreddy"
}
```

Until we decide on the class name, I named it `TriconnectivitySPQR`. 
Also, what would we call the algorithm of `spqr_tree` which uses the `cleave` method? For how I have referred to it as `cleave` in the description of `spqr_tree`.

I have moved the examples of `staticSPQRtree` to the function `get_spqr_tree` since this will be the function through which it will be accessed? Is that okay? In this case, we can also move the examples of `TriconnectivitySPQR` class to `get_triconnected_components`.



---

archive/issue_comments_357507.json:
```json
{
    "body": "For example [Hopcroft1973]_, #25598 failed as `spqrtree_to_graph` is adding multi edge between (3, 1), it should not add as (3, 1) edge in H as it's a virtual edge. \n`spqrtree_to_graph` will remove (3, 1) edge only if there is a bond containing (3, 1), which couldn't be possible as (3, 1) does not belong to graph G.\n\n```\nsage: G = Graph()\nsage: G = Graph()\nsage: G.add_edges([(1,2),(1,4),(1,8),(1,12),(1,13),(2,3),(2,13),(3,4)])\nsage: G.add_edges([(3,13),(4,5),(4,7),(5,6),(5,7),(5,8),(6,7),(8,9),(8,11)])\nsage: G.add_edges([(8,12),(9,10),(9,11),(9,12),(10,11),(10,12)])\nsage: tree = staticSPQRTree(G)\nsage: H = spqr_tree_to_graph(tree)\nsage: G.is_isomorphic(H)\nFalse\nsage: tric = Triconnectivity(G)\nsage: tric.print_triconnected_components()\nTriconnected:  [(8, 9, None), (9, 10, None), (10, 11, None), (9, 11, None), (8, 11, None), (10, 12, None), (9, 12, None), (8, 12, 'newVEdge0')]\nBond:  [(8, 12, None), (8, 12, 'newVEdge0'), (8, 12, 'newVEdge1')]\nPolygon:  [(8, 12, 'newVEdge1'), (1, 12, None), (8, 1, 'newVEdge2')]\nBond:  [(1, 8, None), (8, 1, 'newVEdge2'), (8, 1, 'newVEdge3')]\nPolygon:  [(5, 8, None), (8, 1, 'newVEdge3'), (4, 5, 'newVEdge8'), (4, 1, 'newVEdge9')]\nPolygon:  [(5, 6, None), (6, 7, None), (5, 7, 'newVEdge5')]\nBond:  [(5, 7, None), (5, 7, 'newVEdge5'), (5, 7, 'newVEdge6')]\nPolygon:  [(5, 7, 'newVEdge6'), (4, 7, None), (5, 4, 'newVEdge7')]\nBond:  [(5, 4, 'newVEdge7'), (4, 5, 'newVEdge8'), (4, 5, None)]\nBond:  [(1, 4, None), (4, 1, 'newVEdge9'), (4, 1, 'newVEdge10')]\nPolygon:  [(3, 4, None), (4, 1, 'newVEdge10'), (3, 1, 'newVEdge11')]\nTriconnected:  [(1, 2, None), (2, 3, None), (3, 1, 'newVEdge11'), (3, 13, None), (2, 13, None), (1, 13, None)]\n```\n\n\nPlease see last two printed lines where one polygon and Triconnected component share same virtual edge. \\\\\nOutput of OGDF and `tric.print_triconnected_components()` are same.\nIn #22157 spqr_tree code is generating a bond with (3, 1) so G.is_isomorphic(H) is True.\nSimilar case in [Gut2001]_.",
    "created_at": "2018-08-08T17:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357507",
    "user": "saiharsh"
}
```

For example [Hopcroft1973]_, #25598 failed as `spqrtree_to_graph` is adding multi edge between (3, 1), it should not add as (3, 1) edge in H as it's a virtual edge. 
`spqrtree_to_graph` will remove (3, 1) edge only if there is a bond containing (3, 1), which couldn't be possible as (3, 1) does not belong to graph G.

```
sage: G = Graph()
sage: G = Graph()
sage: G.add_edges([(1,2),(1,4),(1,8),(1,12),(1,13),(2,3),(2,13),(3,4)])
sage: G.add_edges([(3,13),(4,5),(4,7),(5,6),(5,7),(5,8),(6,7),(8,9),(8,11)])
sage: G.add_edges([(8,12),(9,10),(9,11),(9,12),(10,11),(10,12)])
sage: tree = staticSPQRTree(G)
sage: H = spqr_tree_to_graph(tree)
sage: G.is_isomorphic(H)
False
sage: tric = Triconnectivity(G)
sage: tric.print_triconnected_components()
Triconnected:  [(8, 9, None), (9, 10, None), (10, 11, None), (9, 11, None), (8, 11, None), (10, 12, None), (9, 12, None), (8, 12, 'newVEdge0')]
Bond:  [(8, 12, None), (8, 12, 'newVEdge0'), (8, 12, 'newVEdge1')]
Polygon:  [(8, 12, 'newVEdge1'), (1, 12, None), (8, 1, 'newVEdge2')]
Bond:  [(1, 8, None), (8, 1, 'newVEdge2'), (8, 1, 'newVEdge3')]
Polygon:  [(5, 8, None), (8, 1, 'newVEdge3'), (4, 5, 'newVEdge8'), (4, 1, 'newVEdge9')]
Polygon:  [(5, 6, None), (6, 7, None), (5, 7, 'newVEdge5')]
Bond:  [(5, 7, None), (5, 7, 'newVEdge5'), (5, 7, 'newVEdge6')]
Polygon:  [(5, 7, 'newVEdge6'), (4, 7, None), (5, 4, 'newVEdge7')]
Bond:  [(5, 4, 'newVEdge7'), (4, 5, 'newVEdge8'), (4, 5, None)]
Bond:  [(1, 4, None), (4, 1, 'newVEdge9'), (4, 1, 'newVEdge10')]
Polygon:  [(3, 4, None), (4, 1, 'newVEdge10'), (3, 1, 'newVEdge11')]
Triconnected:  [(1, 2, None), (2, 3, None), (3, 1, 'newVEdge11'), (3, 13, None), (2, 13, None), (1, 13, None)]
```


Please see last two printed lines where one polygon and Triconnected component share same virtual edge. \\
Output of OGDF and `tric.print_triconnected_components()` are same.
In #22157 spqr_tree code is generating a bond with (3, 1) so G.is_isomorphic(H) is True.
Similar case in [Gut2001]_.



---

archive/issue_comments_357508.json:
```json
{
    "body": "Replying to [comment:60 saiharsh]:\n> For example [Hopcroft1973]_, #25598 failed as `spqrtree_to_graph` ...\n\nIn fact, we are missing the `Bond: [(3, 1, 'newVEdge11'), (3, 1, 'newVEdge11')]`. \n\nCan you check when this virtual edge is added and see why the bond is not added ?",
    "created_at": "2018-08-08T18:44:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357508",
    "user": "dcoudert"
}
```

Replying to [comment:60 saiharsh]:
> For example [Hopcroft1973]_, #25598 failed as `spqrtree_to_graph` ...

In fact, we are missing the `Bond: [(3, 1, 'newVEdge11'), (3, 1, 'newVEdge11')]`. 

Can you check when this virtual edge is added and see why the bond is not added ?



---

archive/issue_comments_357509.json:
```json
{
    "body": "Replying to [comment:59 meghanamreddy]:\n> Until we decide on the class name, I named it `TriconnectivitySPQR`.\nOK\n\n> Also, what would we call the algorithm of `spqr_tree` which uses the `cleave` method? For how I have referred to it as `cleave` in the description of `spqr_tree`.\nI agree\n\n> I have moved the examples of `staticSPQRtree` to the function `get_spqr_tree` since this will be the function through which it will be accessed? Is that okay? \nYes, but you should also move the code of `__staticSPQRTree(self)` inside this method.\n\n>In this case, we can also move the examples of `TriconnectivitySPQR` class to `get_triconnected_components`.\nNo, it's good to have class examples. It ease the understanding of what a class can do / is used for, without having to check all methods.",
    "created_at": "2018-08-08T18:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357509",
    "user": "dcoudert"
}
```

Replying to [comment:59 meghanamreddy]:
> Until we decide on the class name, I named it `TriconnectivitySPQR`.
OK

> Also, what would we call the algorithm of `spqr_tree` which uses the `cleave` method? For how I have referred to it as `cleave` in the description of `spqr_tree`.
I agree

> I have moved the examples of `staticSPQRtree` to the function `get_spqr_tree` since this will be the function through which it will be accessed? Is that okay? 
Yes, but you should also move the code of `__staticSPQRTree(self)` inside this method.

>In this case, we can also move the examples of `TriconnectivitySPQR` class to `get_triconnected_components`.
No, it's good to have class examples. It ease the understanding of what a class can do / is used for, without having to check all methods.



---

archive/issue_comments_357510.json:
```json
{
    "body": "Replying to [comment:61 dcoudert]:\n> In fact, we are missing the `Bond: [(3, 1, 'newVEdge11'), (3, 1, 'newVEdge11')]`. \n> Can you check when this virtual edge is added and see why the bond is not added ?\nI feel a bond is created if there exists a real edge followed by virtual edges, i.e \nwe are expecting a bond like `Bond: [(3, 1, 'None'), (3, 1, 'newVEdge11')]` but it's not possible as (1, 3) edge is not available in `G`.\\\\\nOGDF returns 5 bonds and each 5 bonds has one real edge.\nCorrect me if I am wrong. \\\\",
    "created_at": "2018-08-08T19:19:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357510",
    "user": "saiharsh"
}
```

Replying to [comment:61 dcoudert]:
> In fact, we are missing the `Bond: [(3, 1, 'newVEdge11'), (3, 1, 'newVEdge11')]`. 
> Can you check when this virtual edge is added and see why the bond is not added ?
I feel a bond is created if there exists a real edge followed by virtual edges, i.e 
we are expecting a bond like `Bond: [(3, 1, 'None'), (3, 1, 'newVEdge11')]` but it's not possible as (1, 3) edge is not available in `G`.\\
OGDF returns 5 bonds and each 5 bonds has one real edge.
Correct me if I am wrong. \\



---

archive/issue_comments_357511.json:
```json
{
    "body": "The `spqr_tree` method using `cleave` returns 6 bonds and I think it is what we should expect. A bond is created for each 2-cut that is in the solution, even if it has no edge.",
    "created_at": "2018-08-08T19:35:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357511",
    "user": "dcoudert"
}
```

The `spqr_tree` method using `cleave` returns 6 bonds and I think it is what we should expect. A bond is created for each 2-cut that is in the solution, even if it has no edge.



---

archive/issue_comments_357512.json:
```json
{
    "body": "Replying to [comment:64 dcoudert]:\n> The `spqr_tree` method using `cleave` returns 6 bonds and I think it is what we should expect. A bond is created for each 2-cut that is in the solution, even if it has no edge.\nAfter second thought, I think you are right, we should correct methods `spqr_tree` and method `spqr_tree_to_graph`. Any idea on how to do that ?",
    "created_at": "2018-08-08T21:43:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357512",
    "user": "dcoudert"
}
```

Replying to [comment:64 dcoudert]:
> The `spqr_tree` method using `cleave` returns 6 bonds and I think it is what we should expect. A bond is created for each 2-cut that is in the solution, even if it has no edge.
After second thought, I think you are right, we should correct methods `spqr_tree` and method `spqr_tree_to_graph`. Any idea on how to do that ?



---

archive/issue_comments_357513.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-09T08:53:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357513",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357514.json:
```json
{
    "body": "I found a way to fix `spqr_tree_to_graph`. It suffices to count separately the number of occurrence of edges in S or R blocks and in P blocks. As multiedges are necessarily in P blocks, if an edges is 2 times in S or R blocks but not in a P block, it is a virtual edge separating 2 blocks and it is not in the original graph. If the virtual edge separates 3 blocks, then the algorithms creates a P block.\n\nNote that the `abs` in `num = abs(count_P[e] - count_G[e])` is not needed. In fact, we could raise an error if `count_P[e] - count_G[e] < 0` in this case...\n\nI will try to find a fix for the `spqr_tree` with `cleave` algorithm. A simple one is to remove P-blocks with only 2 edges before the construction of the spqr tree.\n\nQuestion: is it really useful to let the `'newVEdge11'` labels ?",
    "created_at": "2018-08-09T09:01:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357514",
    "user": "dcoudert"
}
```

I found a way to fix `spqr_tree_to_graph`. It suffices to count separately the number of occurrence of edges in S or R blocks and in P blocks. As multiedges are necessarily in P blocks, if an edges is 2 times in S or R blocks but not in a P block, it is a virtual edge separating 2 blocks and it is not in the original graph. If the virtual edge separates 3 blocks, then the algorithms creates a P block.

Note that the `abs` in `num = abs(count_P[e] - count_G[e])` is not needed. In fact, we could raise an error if `count_P[e] - count_G[e] < 0` in this case...

I will try to find a fix for the `spqr_tree` with `cleave` algorithm. A simple one is to remove P-blocks with only 2 edges before the construction of the spqr tree.

Question: is it really useful to let the `'newVEdge11'` labels ?



---

archive/issue_comments_357515.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-09T10:15:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357515",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357516.json:
```json
{
    "body": "If found a simple way to fix the `spqr_tree + cleave` method: remove P blocks with only 2 edges and add an edge between neighbors.\n\nI have fixed `spqr_tree_to_graph`. It was missing some edges that are only in P blocks. Note that the example of Sai Harsh is the one with `G = Graph('LlCG{O`@`?GBoMw?')` (vertex relabels  to start from 0).\n\nPlease do more tests.",
    "created_at": "2018-08-09T10:23:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357516",
    "user": "dcoudert"
}
```

If found a simple way to fix the `spqr_tree + cleave` method: remove P blocks with only 2 edges and add an edge between neighbors.

I have fixed `spqr_tree_to_graph`. It was missing some edges that are only in P blocks. Note that the example of Sai Harsh is the one with `G = Graph('LlCG{O`@`?GBoMw?')` (vertex relabels  to start from 0).

Please do more tests.



---

archive/issue_comments_357517.json:
```json
{
    "body": "`@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error \"something goes wrong\").\n\n```\nsage: G = Graph('IZSsJ@C_O')\nsage: G = Graph('K\\\\LPcCIAS_D?')\n```\n\nPlease check.",
    "created_at": "2018-08-09T15:01:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357517",
    "user": "dcoudert"
}
```

`@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error "something goes wrong").

```
sage: G = Graph('IZSsJ@C_O')
sage: G = Graph('K\\LPcCIAS_D?')
```

Please check.



---

archive/issue_comments_357518.json:
```json
{
    "body": "Replying to [comment:70 dcoudert]:\n> `@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error \"something goes wrong\").\n> {{{\n> sage: G = Graph('IZSsJ`@`C_O')\n> sage: G = Graph('K\\\\LPcCIAS_D?')\n> }}}\n> Please check.\nYes, I will but from morning make failed twice, trying to get successful build now.\nI hope I will get it by tomorrow morning. Reply as soon as possible.\n\n(raising error \"something goes wrong\") -> it happened means there is a block with no cycle and multiedge, it could be a path, yet to see.",
    "created_at": "2018-08-09T15:43:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357518",
    "user": "saiharsh"
}
```

Replying to [comment:70 dcoudert]:
> `@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error "something goes wrong").
> {{{
> sage: G = Graph('IZSsJ`@`C_O')
> sage: G = Graph('K\\LPcCIAS_D?')
> }}}
> Please check.
Yes, I will but from morning make failed twice, trying to get successful build now.
I hope I will get it by tomorrow morning. Reply as soon as possible.

(raising error "something goes wrong") -> it happened means there is a block with no cycle and multiedge, it could be a path, yet to see.



---

archive/issue_comments_357519.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-09T18:44:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357519",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357520.json:
```json
{
    "body": "Replying to [comment:70 dcoudert]:\n> `@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error \"something goes wrong\").\n> {{{\n> sage: G = Graph('IZSsJ`@`C_O')\n> sage: G = Graph('K\\\\LPcCIAS_D?')\n> }}}\n> Please check.\n\nIt seems to be working fine on my laptop. I ran `cleave` and `spqr_tree` and then also checked if `G.is_isomorphic(spqr_tree_to_graph(Tree))`. The output was `True` for both the graphs.",
    "created_at": "2018-08-09T18:56:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357520",
    "user": "meghanamreddy"
}
```

Replying to [comment:70 dcoudert]:
> `@`SaiHarsh: with the 2 following graphs, the `spqr_tree + cleave` method falls into the case that should never happen (raising error "something goes wrong").
> {{{
> sage: G = Graph('IZSsJ`@`C_O')
> sage: G = Graph('K\\LPcCIAS_D?')
> }}}
> Please check.

It seems to be working fine on my laptop. I ran `cleave` and `spqr_tree` and then also checked if `G.is_isomorphic(spqr_tree_to_graph(Tree))`. The output was `True` for both the graphs.



---

archive/issue_comments_357521.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-10T08:25:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357521",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357522.json:
```json
{
    "body": "I have added parameters solver and verbose that can be passed to `vertex_connectivity`.\n\nI have also changed the way the cocycles graph is decomposed as some cycles may share a vertex. So a decomposition into biconnected components seems better. Correct me if I'm wrong. With this modification, the small graphs can be solved on my computer.\n\nHowever, I have issue with this one. Can you try ? \n\n```\nsage: G = Graph(']\\\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??@a???CC???O?G??OA??P?????H??')\nsage: T = spqr_tree(G, algorithm='cleave')\n```\n",
    "created_at": "2018-08-10T08:28:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357522",
    "user": "dcoudert"
}
```

I have added parameters solver and verbose that can be passed to `vertex_connectivity`.

I have also changed the way the cocycles graph is decomposed as some cycles may share a vertex. So a decomposition into biconnected components seems better. Correct me if I'm wrong. With this modification, the small graphs can be solved on my computer.

However, I have issue with this one. Can you try ? 

```
sage: G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??@a???CC???O?G??OA??P?????H??')
sage: T = spqr_tree(G, algorithm='cleave')
```




---

archive/issue_comments_357523.json:
```json
{
    "body": "> However, I have issue with this one. Can you try ? \n> {{{\n> sage: G = Graph(']\\\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')\n> sage: T = spqr_tree(G, algorithm='cleave')\n> }}}\n\nThis gives me the \"Something goes wrong error\"\n\n```\nTraceback (click to the left of this block for traceback)\n...\nValueError: something goes wrong\n```\n",
    "created_at": "2018-08-10T12:58:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357523",
    "user": "meghanamreddy"
}
```

> However, I have issue with this one. Can you try ? 
> {{{
> sage: G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
> sage: T = spqr_tree(G, algorithm='cleave')
> }}}

This gives me the "Something goes wrong error"

```
Traceback (click to the left of this block for traceback)
...
ValueError: something goes wrong
```




---

archive/issue_comments_357524.json:
```json
{
    "body": "My bad, I forgot to add the parameter `algorithm` yesterday on the other two examples. These two graphs -\n\n```\nsage: G = Graph('IZSsJ@C_O')\nsage: G = Graph('K\\\\LPcCIAS_D?')\n```\n\nAlso give me the error `something goes wrong`.",
    "created_at": "2018-08-10T14:43:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357524",
    "user": "meghanamreddy"
}
```

My bad, I forgot to add the parameter `algorithm` yesterday on the other two examples. These two graphs -

```
sage: G = Graph('IZSsJ@C_O')
sage: G = Graph('K\\LPcCIAS_D?')
```

Also give me the error `something goes wrong`.



---

archive/issue_comments_357525.json:
```json
{
    "body": "You get the error with the commits of this morning ?",
    "created_at": "2018-08-10T15:23:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357525",
    "user": "dcoudert"
}
```

You get the error with the commits of this morning ?



---

archive/issue_comments_357526.json:
```json
{
    "body": "My bad again, I did a `git pull` now. Now the graphs -\n\n```\nsage: G = Graph('IZSsJ@C_O')\nsage: G = Graph('K\\\\LPcCIAS_D?')\n```\n\ngive no error.\nThe graph \n\n```\nG = Graph(']\\\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??@a???CC???O?G??OA??P?????H??')\n```\n\ngives the `something goes wrong` error.",
    "created_at": "2018-08-10T15:42:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357526",
    "user": "meghanamreddy"
}
```

My bad again, I did a `git pull` now. Now the graphs -

```
sage: G = Graph('IZSsJ@C_O')
sage: G = Graph('K\\LPcCIAS_D?')
```

give no error.
The graph 

```
G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??@a???CC???O?G??OA??P?????H??')
```

gives the `something goes wrong` error.



---

archive/issue_comments_357527.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-10T17:50:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357527",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357528.json:
```json
{
    "body": "Replying to [comment:75 dcoudert]: \n> However, I have issue with this one. Can you try ? \n> {{{\n> sage: G = Graph(']\\\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')\n> sage: T = spqr_tree(G, algorithm='cleave')\n> }}}\nAt last I got a successful build of sage.\nAs mentioned by meghana I also got the same results.\nFor graph \n\n```\nG = Graph(']\\\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??@a???CC???O?G??OA??P?????H??')\n```\n\nIt looks like error is coming when block is an bi-connected component with no multiedges but that error block and R_blocks has three edges common\nthere are \n\n```\n(6, 10, None)\n(6, 19, None)\n(10, 19, None)\n```\n\nIf we remove these edges from the error block we will get a cycle. \nIs it like we are not deleting less edges? correct me if I am wrong.",
    "created_at": "2018-08-10T17:54:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357528",
    "user": "saiharsh"
}
```

Replying to [comment:75 dcoudert]: 
> However, I have issue with this one. Can you try ? 
> {{{
> sage: G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??`@`a???CC???O?G??OA??P?????H??')
> sage: T = spqr_tree(G, algorithm='cleave')
> }}}
At last I got a successful build of sage.
As mentioned by meghana I also got the same results.
For graph 

```
G = Graph(']\\eHS_Q_cCI?GG?aOGCA?Q??AO?O?c??Oa??_A??AC?G??@a???CC???O?G??OA??P?????H??')
```

It looks like error is coming when block is an bi-connected component with no multiedges but that error block and R_blocks has three edges common
there are 

```
(6, 10, None)
(6, 19, None)
(10, 19, None)
```

If we remove these edges from the error block we will get a cycle. 
Is it like we are not deleting less edges? correct me if I am wrong.



---

archive/issue_comments_357529.json:
```json
{
    "body": "I did a small correction to avoid removing a virtual edge between 2 cycles when the virtual is in a cut with 3 or more components. The result for graph `G = Graph('F^~E?')` was not correct (a `K5` minus edge (0,1) plus 2 paths attachaed).\n\n`@`saiharsh: yes, when we have an error, the graph is biconnected without multiple edges. Do you know if edges `(6, 10), (6,19), (10, 19)` are virtual or not ?",
    "created_at": "2018-08-10T17:58:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357529",
    "user": "dcoudert"
}
```

I did a small correction to avoid removing a virtual edge between 2 cycles when the virtual is in a cut with 3 or more components. The result for graph `G = Graph('F^~E?')` was not correct (a `K5` minus edge (0,1) plus 2 paths attachaed).

`@`saiharsh: yes, when we have an error, the graph is biconnected without multiple edges. Do you know if edges `(6, 10), (6,19), (10, 19)` are virtual or not ?



---

archive/issue_comments_357530.json:
```json
{
    "body": "Replying to [comment:82 dcoudert]:\n> I did a small correction to avoid removing a virtual edge between 2 cycles when the virtual is in a cut with 3 or more components. The result for graph `G = Graph('F^~E?')` was not correct (a `K5` minus edge (0,1) plus 2 paths attachaed).\n> \n> `@`saiharsh: yes, when we have an error, the graph is biconnected without multiple edges. Do you know if edges `(6, 10), (6,19), (10, 19)` are virtual or not ?\nOnly (6, 10) is a real edge, remaining (6,19), (10, 19) are virtual edges.",
    "created_at": "2018-08-10T18:03:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357530",
    "user": "saiharsh"
}
```

Replying to [comment:82 dcoudert]:
> I did a small correction to avoid removing a virtual edge between 2 cycles when the virtual is in a cut with 3 or more components. The result for graph `G = Graph('F^~E?')` was not correct (a `K5` minus edge (0,1) plus 2 paths attachaed).
> 
> `@`saiharsh: yes, when we have an error, the graph is biconnected without multiple edges. Do you know if edges `(6, 10), (6,19), (10, 19)` are virtual or not ?
Only (6, 10) is a real edge, remaining (6,19), (10, 19) are virtual edges.



---

archive/issue_comments_357531.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-11T10:51:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357531",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357532.json:
```json
{
    "body": "Got it ! Take the graph \n\n```\n    G = Graph()\n    G.add_cycle([6, 13, 10, 27, 19, 26])\n    G.add_edge(6, 10)\n    K = [0, 1, 2, 3]\n    G.add_clique(K)\n    for u in [6, 10, 19]:\n        for v in K:\n            G.add_edge(u, v)\n```\n\nThe algorithm identifies 3-cycles `[6, 10, 13], [10, 19, 27], [6, 10, 26]`, and the algorithm is right not to identify cycle `[6, 10, 19]` since it is part of a R_block. If you put all edges of these cycles in a same graph, we don't know what to do.\n\nI have changed the way we handle cycles. I should be easier to understand, and more importantly, I think it gives the good result.\n\nPlease check & test.",
    "created_at": "2018-08-11T11:03:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357532",
    "user": "dcoudert"
}
```

Got it ! Take the graph 

```
    G = Graph()
    G.add_cycle([6, 13, 10, 27, 19, 26])
    G.add_edge(6, 10)
    K = [0, 1, 2, 3]
    G.add_clique(K)
    for u in [6, 10, 19]:
        for v in K:
            G.add_edge(u, v)
```

The algorithm identifies 3-cycles `[6, 10, 13], [10, 19, 27], [6, 10, 26]`, and the algorithm is right not to identify cycle `[6, 10, 19]` since it is part of a R_block. If you put all edges of these cycles in a same graph, we don't know what to do.

I have changed the way we handle cycles. I should be easier to understand, and more importantly, I think it gives the good result.

Please check & test.



---

archive/issue_comments_357533.json:
```json
{
    "body": "Replying to [comment:85 dcoudert]:\n> The algorithm identifies 3-cycles `[6, 10, 13], [10, 19, 27], [6, 10, 26]`, and the algorithm is right not to identify cycle `[6, 10, 19]` since it is part of a R_block. If you put all edges of these cycles in a same graph, we don't know what to do.\nYes, you are right.\n> \n> I have changed the way we handle cycles. I should be easier to understand, and more importantly, I think it gives the good result.\n> \n> Please check & test.\nYes, it's easier to understand, it fixed the last problem. \\\\\nI tested on Petersen, RandomTriangulation, paper examples and previous graphs. All are passed. \\\\\nI will try on more graphs if I found anything I will update you.",
    "created_at": "2018-08-11T12:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357533",
    "user": "saiharsh"
}
```

Replying to [comment:85 dcoudert]:
> The algorithm identifies 3-cycles `[6, 10, 13], [10, 19, 27], [6, 10, 26]`, and the algorithm is right not to identify cycle `[6, 10, 19]` since it is part of a R_block. If you put all edges of these cycles in a same graph, we don't know what to do.
Yes, you are right.
> 
> I have changed the way we handle cycles. I should be easier to understand, and more importantly, I think it gives the good result.
> 
> Please check & test.
Yes, it's easier to understand, it fixed the last problem. \\
I tested on Petersen, RandomTriangulation, paper examples and previous graphs. All are passed. \\
I will try on more graphs if I found anything I will update you.



---

archive/issue_comments_357534.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-12T09:08:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357534",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357535.json:
```json
{
    "body": "I have added the case of Q blocks in all methods.\n\nIn TriconnectivitySPQR, do we really need methods `get_triconnected_components` and `print_triconnected_components` ? We can of course let them as they are useful for testing methods in the class, but the most important is to return the SPQR tree.\n\nI propose to modify methods so that the `__init__` performs all computations including the construction of the spqr tree, and then the `get_triconnected_components` and `print_triconnected_components` methods just have to consider the nodes of the tree. Do you agree ?",
    "created_at": "2018-08-12T09:18:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357535",
    "user": "dcoudert"
}
```

I have added the case of Q blocks in all methods.

In TriconnectivitySPQR, do we really need methods `get_triconnected_components` and `print_triconnected_components` ? We can of course let them as they are useful for testing methods in the class, but the most important is to return the SPQR tree.

I propose to modify methods so that the `__init__` performs all computations including the construction of the spqr tree, and then the `get_triconnected_components` and `print_triconnected_components` methods just have to consider the nodes of the tree. Do you agree ?



---

archive/issue_comments_357536.json:
```json
{
    "body": "> I propose to modify methods so that the `__init__` performs all computations including the construction of the spqr tree, and then the `get_triconnected_components` and `print_triconnected_components` methods just have to consider the nodes of the tree. Do you agree ?\n\nYes, I agree. We should do it. We could make the spqr tree a variable and store it in the `TriconnectivitySPQR` class in the `__init__` function. The functions `get_triconnected_components` and `print_triconnected_components` could use the tree stored in the class. \n\nCurrently, to use this algorithm, two lines of code is required. \n\n```\ntric = TriconnectivitySPQR(G)\ntric.get_spqr_tree()\n```\n\nMaking the suggested change would not decrease the two lines of code. To an external user, this structural change would not make any difference. But internally, we would have a better design. Do you agree? I will make this change.",
    "created_at": "2018-08-12T10:47:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357536",
    "user": "meghanamreddy"
}
```

> I propose to modify methods so that the `__init__` performs all computations including the construction of the spqr tree, and then the `get_triconnected_components` and `print_triconnected_components` methods just have to consider the nodes of the tree. Do you agree ?

Yes, I agree. We should do it. We could make the spqr tree a variable and store it in the `TriconnectivitySPQR` class in the `__init__` function. The functions `get_triconnected_components` and `print_triconnected_components` could use the tree stored in the class. 

Currently, to use this algorithm, two lines of code is required. 

```
tric = TriconnectivitySPQR(G)
tric.get_spqr_tree()
```

Making the suggested change would not decrease the two lines of code. To an external user, this structural change would not make any difference. But internally, we would have a better design. Do you agree? I will make this change.



---

archive/issue_comments_357537.json:
```json
{
    "body": "Go for it !",
    "created_at": "2018-08-12T12:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357537",
    "user": "dcoudert"
}
```

Go for it !



---

archive/issue_comments_357538.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-12T19:36:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357538",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357539.json:
```json
{
    "body": "I moved the spqr construction to the init. However, the doctests are failing due to the following reason.\n\nThe functions `get_triconnected_components` and `print_triconnected_components` use the nodes of the SPQR tree to output the components. Suppose we have two `bond` components, each with the same number of edges. Let the two bond edges be `(1,2)` and (`3,4)`. The corresponding nodes in the SPQR tree will be -\n\n```\n[('P', Multi-graph on 2 vertices),\n ('P', Multi-graph on 2 vertices)]\n```\n\nThe ordering of these two vertices in the SPQR tree is random since both would be considered as similar vertices. When we access the vertices of the SPQR tree using `for node in self.spqr_tree.vertices()`, we could either get the bond `(1,2)` first or `(3,4)` first. Hence, while constructing the triconnected components from the SPQR tree, there is no fixed ordering of the output components, and thus the doctests will fail.",
    "created_at": "2018-08-12T19:45:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357539",
    "user": "meghanamreddy"
}
```

I moved the spqr construction to the init. However, the doctests are failing due to the following reason.

The functions `get_triconnected_components` and `print_triconnected_components` use the nodes of the SPQR tree to output the components. Suppose we have two `bond` components, each with the same number of edges. Let the two bond edges be `(1,2)` and (`3,4)`. The corresponding nodes in the SPQR tree will be -

```
[('P', Multi-graph on 2 vertices),
 ('P', Multi-graph on 2 vertices)]
```

The ordering of these two vertices in the SPQR tree is random since both would be considered as similar vertices. When we access the vertices of the SPQR tree using `for node in self.spqr_tree.vertices()`, we could either get the bond `(1,2)` first or `(3,4)` first. Hence, while constructing the triconnected components from the SPQR tree, there is no fixed ordering of the output components, and thus the doctests will fail.



---

archive/issue_comments_357540.json:
```json
{
    "body": "It does not make sense to force an ordering on the nodes of the SPQR tree.\nWe can let the spqr tree be constructed in `init`, but use `comp_list_new` and `comp_type` to compute the components in the functions `get_triconnected_components` and `print_triconnected_components`, the way we were doing it earlier?",
    "created_at": "2018-08-12T19:53:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357540",
    "user": "meghanamreddy"
}
```

It does not make sense to force an ordering on the nodes of the SPQR tree.
We can let the spqr tree be constructed in `init`, but use `comp_list_new` and `comp_type` to compute the components in the functions `get_triconnected_components` and `print_triconnected_components`, the way we were doing it earlier?



---

archive/issue_comments_357541.json:
```json
{
    "body": "As a SPQR tree is a graph, we can assume an ordering of the vertices. This is a strong requirement for many graph algorithms: there is a unique order of the vertices. So for these methods, you can use a loop over the vertices. You can check that one of  `(1, 2)` or `(3, 4)` will always before the other.",
    "created_at": "2018-08-12T22:26:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357541",
    "user": "dcoudert"
}
```

As a SPQR tree is a graph, we can assume an ordering of the vertices. This is a strong requirement for many graph algorithms: there is a unique order of the vertices. So for these methods, you can use a loop over the vertices. You can check that one of  `(1, 2)` or `(3, 4)` will always before the other.



---

archive/issue_comments_357542.json:
```json
{
    "body": "Even I thought so, but I check the below example\n\n```\nTree = Graph()\nTree.add_vertex(('P', Graph( {1:[0] }, immutable=True, multiedges=True)))\nTree.add_vertex(('P', Graph( {2:[3] }, immutable=True, multiedges=True)))\nTree.vertices()[0][1].edges()\n```\n\nIn the SPQR tree, the vertices in the tree are ordered by their type - bonds first, then triconnected components and polygons after that. But within the bonds, if two bonds have the same number of vertices (it is printed as `Multi-graph on 2 vertices`), the order of these bonds is not fixed.\n\nIn the example above, I'm printing the edges of the first node of the tree. I ran it 4-5 times. And the output is not fixed. Sometimes it is `[(0, 1, None)]` and sometimes `[(2, 3, None)]`.\n\nIf I print the vertices of the tree with `Tree.vertices()`, the output is `[('P', Multi-graph on 2 vertices), ('P', Multi-graph on 2 vertices)]`.",
    "created_at": "2018-08-13T04:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357542",
    "user": "meghanamreddy"
}
```

Even I thought so, but I check the below example

```
Tree = Graph()
Tree.add_vertex(('P', Graph( {1:[0] }, immutable=True, multiedges=True)))
Tree.add_vertex(('P', Graph( {2:[3] }, immutable=True, multiedges=True)))
Tree.vertices()[0][1].edges()
```

In the SPQR tree, the vertices in the tree are ordered by their type - bonds first, then triconnected components and polygons after that. But within the bonds, if two bonds have the same number of vertices (it is printed as `Multi-graph on 2 vertices`), the order of these bonds is not fixed.

In the example above, I'm printing the edges of the first node of the tree. I ran it 4-5 times. And the output is not fixed. Sometimes it is `[(0, 1, None)]` and sometimes `[(2, 3, None)]`.

If I print the vertices of the tree with `Tree.vertices()`, the output is `[('P', Multi-graph on 2 vertices), ('P', Multi-graph on 2 vertices)]`.



---

archive/issue_comments_357543.json:
```json
{
    "body": "I was not expecting that. Currently the vertices are sorted (and there is a proposal for deprecating sorting to save time). It explains why we have bonds then polygons then triconnected (`P`, `S`, `R`). I thought that vertices like `('P', Multi-graph on 2 vertices)` had an implicit ordering but I don't know how immutable graphs are hashed...\nSo it's better to use the previous method.",
    "created_at": "2018-08-13T07:39:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357543",
    "user": "dcoudert"
}
```

I was not expecting that. Currently the vertices are sorted (and there is a proposal for deprecating sorting to save time). It explains why we have bonds then polygons then triconnected (`P`, `S`, `R`). I thought that vertices like `('P', Multi-graph on 2 vertices)` had an implicit ordering but I don't know how immutable graphs are hashed...
So it's better to use the previous method.



---

archive/issue_comments_357544.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-13T18:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357544",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357545.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-14T10:52:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357545",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357546.json:
```json
{
    "body": "I did some improvements of the documentation. More can certainly be done",
    "created_at": "2018-08-14T10:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357546",
    "user": "dcoudert"
}
```

I did some improvements of the documentation. More can certainly be done



---

archive/issue_comments_357547.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-19T16:46:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357547",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357548.json:
```json
{
    "body": "In bucket sort, edges `(u, v)` are sorted in such a way that first preference is given to `v` if the same `v` then compare `u`. i.e (1, 2) will come before (0, 3). \\\\\nInitially, we used the sorted function which is the reverse of bucket sort i.e (0, 3) will come before (1, 2). \\\\\nAs there is a change in edge processing in `split_multiple_edges`, creation of components and edges which leads to jumble in triconnectivity output. \\\\\nLet me know if there is any other problem.",
    "created_at": "2018-08-19T17:00:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357548",
    "user": "saiharsh"
}
```

In bucket sort, edges `(u, v)` are sorted in such a way that first preference is given to `v` if the same `v` then compare `u`. i.e (1, 2) will come before (0, 3). \\
Initially, we used the sorted function which is the reverse of bucket sort i.e (0, 3) will come before (1, 2). \\
As there is a change in edge processing in `split_multiple_edges`, creation of components and edges which leads to jumble in triconnectivity output. \\
Let me know if there is any other problem.



---

archive/issue_comments_357549.json:
```json
{
    "body": "The ordering is not an issue as long as the result of the triconnectivity decomposition and construction of spqr tree remains correct.\n\nHave you check if this algorithm is effectively faster that the `sorted` method ?",
    "created_at": "2018-08-19T17:33:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357549",
    "user": "dcoudert"
}
```

The ordering is not an issue as long as the result of the triconnectivity decomposition and construction of spqr tree remains correct.

Have you check if this algorithm is effectively faster that the `sorted` method ?



---

archive/issue_comments_357550.json:
```json
{
    "body": "Replying to [comment:102 dcoudert]:\n> The ordering is not an issue as long as the result of the triconnectivity decomposition and construction of spqr tree remains correct.\nYes, construction of spqr-tree remains correct. \n> \n> Have you check if this algorithm is effectively faster that the `sorted` method ?\nI expect that current method is slightly better than the `sorted` method, as ``sorted`` method uses Timsort and it's running time is `O(mlogm)` m is no. of edges, whereas bucket sort uses extra space but running time is linear. \\\\\nPractically I didn't compare both methods.",
    "created_at": "2018-08-19T17:52:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357550",
    "user": "saiharsh"
}
```

Replying to [comment:102 dcoudert]:
> The ordering is not an issue as long as the result of the triconnectivity decomposition and construction of spqr tree remains correct.
Yes, construction of spqr-tree remains correct. 
> 
> Have you check if this algorithm is effectively faster that the `sorted` method ?
I expect that current method is slightly better than the `sorted` method, as ``sorted`` method uses Timsort and it's running time is `O(mlogm)` m is no. of edges, whereas bucket sort uses extra space but running time is linear. \\
Practically I didn't compare both methods.



---

archive/issue_comments_357551.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-19T17:58:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357551",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357552.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-21T17:16:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357552",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357553.json:
```json
{
    "body": "I made some small changes in the comments and made the sorting functions private.\n\nAnd I compared the bucket sort function with the previously used `sorted` function of Python. The bucket sort seems to be slightly faster than `sorted`. I did not do extensive testing, but with a graph on `3000` vertices (`graphs.RandomBarabasiAlbert(3000,2)`), the bucket sort took about `0.64` seconds and the previous sort took about `0.7` seconds. For a grid graph on `1000` vertices, bucket sort took `0.22` seconds and the previous sort took `0.33` seconds.",
    "created_at": "2018-08-21T17:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357553",
    "user": "meghanamreddy"
}
```

I made some small changes in the comments and made the sorting functions private.

And I compared the bucket sort function with the previously used `sorted` function of Python. The bucket sort seems to be slightly faster than `sorted`. I did not do extensive testing, but with a graph on `3000` vertices (`graphs.RandomBarabasiAlbert(3000,2)`), the bucket sort took about `0.64` seconds and the previous sort took about `0.7` seconds. For a grid graph on `1000` vertices, bucket sort took `0.22` seconds and the previous sort took `0.33` seconds.



---

archive/issue_comments_357554.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-08-21T17:52:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357554",
    "user": "dcoudert"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_357555.json:
```json
{
    "body": "I set this ticket to needs review as I think it is almost ready. I will try to review it seriously before the end of the week.",
    "created_at": "2018-08-21T17:52:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357555",
    "user": "dcoudert"
}
```

I set this ticket to needs review as I think it is almost ready. I will try to review it seriously before the end of the week.



---

archive/issue_comments_357556.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-22T13:26:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357556",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357557.json:
```json
{
    "body": "I did some improvements in the documentation and added a TODO block.\nI still have to check that the html output looks good.",
    "created_at": "2018-08-22T13:28:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357557",
    "user": "dcoudert"
}
```

I did some improvements in the documentation and added a TODO block.
I still have to check that the html output looks good.



---

archive/issue_comments_357558.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-22T14:05:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357558",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357559.json:
```json
{
    "body": "For me this patch is ready. Please double check.",
    "created_at": "2018-08-22T14:06:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357559",
    "user": "dcoudert"
}
```

For me this patch is ready. Please double check.



---

archive/issue_comments_357560.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-28T16:22:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357560",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357561.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-28T16:57:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357561",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357562.json:
```json
{
    "body": "I have exposed the `spqr_tree` method in `Graph` and done some more tests.\nI was about to give positive review... but I found 2 issues, one in `spqr_tree` with the `cleave` method and one in `TriconnectivitySPQR`.\n\n1. For some reason, some 3-cycles are not merged with algorithm `cleave`. I will check that.\n\n```\nsage: G = graphs.PetersenGraph()\nsage: for u,v in G.edges(labels=False):\n....:     G.add_path([u,G.add_vertex(),G.add_vertex(),v])\n....:     \nsage: T = G.spqr_tree()\nsage: T2 = G.spqr_tree(algorithm=\"cleave\")\nsage: T\nSPQR-tree of Petersen graph: Graph on 31 vertices\nsage: T2\nSPQR tree of Petersen graph: Graph on 43 vertices\n```\n\n2. Some vertices (1 in the example below) are marked as `R`-block instead of `S`-block. Please check.\n\n```\nsage: for u,v in G.edges(labels=False):\n....:     G.add_path([u,G.add_vertex(),G.add_vertex(),v])\nsage: T = G.spqr_tree()\nsage: T\nSPQR-tree of Petersen graph: Graph on 136 vertices\nsage: for u in T:\n....:     if u[0] == 'R':\n....:         print(u, u[1].is_cycle())\n('R', Multi-graph on 10 vertices) False\n('R', Multi-graph on 4 vertices) True\n```\n",
    "created_at": "2018-08-28T17:07:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357562",
    "user": "dcoudert"
}
```

I have exposed the `spqr_tree` method in `Graph` and done some more tests.
I was about to give positive review... but I found 2 issues, one in `spqr_tree` with the `cleave` method and one in `TriconnectivitySPQR`.

1. For some reason, some 3-cycles are not merged with algorithm `cleave`. I will check that.

```
sage: G = graphs.PetersenGraph()
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),v])
....:     
sage: T = G.spqr_tree()
sage: T2 = G.spqr_tree(algorithm="cleave")
sage: T
SPQR-tree of Petersen graph: Graph on 31 vertices
sage: T2
SPQR tree of Petersen graph: Graph on 43 vertices
```

2. Some vertices (1 in the example below) are marked as `R`-block instead of `S`-block. Please check.

```
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),v])
sage: T = G.spqr_tree()
sage: T
SPQR-tree of Petersen graph: Graph on 136 vertices
sage: for u in T:
....:     if u[0] == 'R':
....:         print(u, u[1].is_cycle())
('R', Multi-graph on 10 vertices) False
('R', Multi-graph on 4 vertices) True
```




---

archive/issue_comments_357563.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-29T12:04:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357563",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357564.json:
```json
{
    "body": "I fixed the issue with cleave. We were missing associations between cycles and virtual edges.\n\nI added a (big) test that fails with `Hopcroft_Tarjan` as one cycle is detected as a `R` block. I will have a look at the code, but it should be easier for you to find the issue.",
    "created_at": "2018-08-29T12:07:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357564",
    "user": "dcoudert"
}
```

I fixed the issue with cleave. We were missing associations between cycles and virtual edges.

I added a (big) test that fails with `Hopcroft_Tarjan` as one cycle is detected as a `R` block. I will have a look at the code, but it should be easier for you to find the issue.



---

archive/issue_comments_357565.json:
```json
{
    "body": "method `finish_tric_or_poly` is called for a component with 4 edges and so given type 2 although it's a cycle. It seems that we are missing a 2-cut here. Any idea on how to correct that ?",
    "created_at": "2018-08-29T12:54:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357565",
    "user": "dcoudert"
}
```

method `finish_tric_or_poly` is called for a component with 4 edges and so given type 2 although it's a cycle. It seems that we are missing a 2-cut here. Any idea on how to correct that ?



---

archive/issue_comments_357566.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-29T17:42:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357566",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357567.json:
```json
{
    "body": "Unless I'm mistaken, there is only one biconnected simple graph without loops or multiple edges and 4 edges: a 4-cycle. So my last commit fixes the issue I detected with Hopcroft-Tarjan.\n\nPlease double check and do some more tests so that I can finally set this ticket to positive review.",
    "created_at": "2018-08-29T17:49:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357567",
    "user": "dcoudert"
}
```

Unless I'm mistaken, there is only one biconnected simple graph without loops or multiple edges and 4 edges: a 4-cycle. So my last commit fixes the issue I detected with Hopcroft-Tarjan.

Please double check and do some more tests so that I can finally set this ticket to positive review.



---

archive/issue_comments_357568.json:
```json
{
    "body": "Yes, I am checking it. Will update once I do some tests.",
    "created_at": "2018-08-29T17:53:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357568",
    "user": "meghanamreddy"
}
```

Yes, I am checking it. Will update once I do some tests.



---

archive/issue_comments_357569.json:
```json
{
    "body": "My last commit is not enough. If instead of 4-cycles, we add 5-cycles, from time to time some 5-cycles are identified as `R`-blocks :(\n\nConsider the following example without 'R'-block\n\n```\nsage: G = graphs.CycleGraph(4)\nsage: for u,v in G.edges(labels=False):\n....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])\nsage: for u,v in G.edges(labels=False):\n....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])\nsage: T = G.spqr_tree()\nsage: V = G.vertices()\nsage: while not Counter(u[0] for u in T)['R']:\n....:     shuffle(V)\n....:     G.relabel(perm=V, inplace=True)\n....:     T = G.spqr_tree()\nsage: Counter(u[0] for u in T)\nCounter({'S': 24, 'P': 20, 'R': 1})\n```\n\nI don't know if it's a problem of the algorithm that must be fixed, or if it's a \"bug\" in the code.",
    "created_at": "2018-08-30T07:00:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357569",
    "user": "dcoudert"
}
```

My last commit is not enough. If instead of 4-cycles, we add 5-cycles, from time to time some 5-cycles are identified as `R`-blocks :(

Consider the following example without 'R'-block

```
sage: G = graphs.CycleGraph(4)
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
sage: for u,v in G.edges(labels=False):
....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
sage: T = G.spqr_tree()
sage: V = G.vertices()
sage: while not Counter(u[0] for u in T)['R']:
....:     shuffle(V)
....:     G.relabel(perm=V, inplace=True)
....:     T = G.spqr_tree()
sage: Counter(u[0] for u in T)
Counter({'S': 24, 'P': 20, 'R': 1})
```

I don't know if it's a problem of the algorithm that must be fixed, or if it's a "bug" in the code.



---

archive/issue_comments_357570.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-30T09:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357570",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357571.json:
```json
{
    "body": "I really suspect this is an algorithmic issue (I can't find a clear answer in the papers). It would be nice if one of you can try to reproduce the issue with OGDF. If I'm right, then we can report the issue to OGDF.\n\nMeanwhile, I found a simple way to fix the issue: maintain a list of vertices in each component that is update each time an edge is added. Then, in `finish_tric_or_poly`, we can decide the type of the component by checking if it has more edges than vertices (type 2) or not (type 1).\n\nI have changed the construction of the last component to also use `finish_tric_or_poly`. It's cleaner this way and ensures that we have the good type. I had to update some tests accordingly.\n\nLet me know if you agree.",
    "created_at": "2018-08-30T09:15:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357571",
    "user": "dcoudert"
}
```

I really suspect this is an algorithmic issue (I can't find a clear answer in the papers). It would be nice if one of you can try to reproduce the issue with OGDF. If I'm right, then we can report the issue to OGDF.

Meanwhile, I found a simple way to fix the issue: maintain a list of vertices in each component that is update each time an edge is added. Then, in `finish_tric_or_poly`, we can decide the type of the component by checking if it has more edges than vertices (type 2) or not (type 1).

I have changed the construction of the last component to also use `finish_tric_or_poly`. It's cleaner this way and ensures that we have the good type. I had to update some tests accordingly.

Let me know if you agree.



---

archive/issue_comments_357572.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-30T10:28:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357572",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357573.json:
```json
{
    "body": "I discovered and fixed an issue with labeled edges as we can't do `\"newVEdge\" in e[2]` when `e[2]` is a number.",
    "created_at": "2018-08-30T10:49:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357573",
    "user": "dcoudert"
}
```

I discovered and fixed an issue with labeled edges as we can't do `"newVEdge" in e[2]` when `e[2]` is a number.



---

archive/issue_comments_357574.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-30T11:32:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357574",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357575.json:
```json
{
    "body": "I added a method to create virtual edges. It also stores the list of virtual edges which simplifies the test in the construction of the spqr tree.",
    "created_at": "2018-08-30T11:34:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357575",
    "user": "dcoudert"
}
```

I added a method to create virtual edges. It also stores the list of virtual edges which simplifies the test in the construction of the spqr tree.



---

archive/issue_comments_357576.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-02T12:56:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357576",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357577.json:
```json
{
    "body": "`@`Meghana, Sai Harsh: can you do a last check ?",
    "created_at": "2018-09-02T13:04:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357577",
    "user": "dcoudert"
}
```

`@`Meghana, Sai Harsh: can you do a last check ?



---

archive/issue_comments_357578.json:
```json
{
    "body": "Replying to [comment:129 dcoudert]:\n> `@`Meghana, Sai Harsh: can you do a last check ?\nYes, I will. \\\\\nI will see if there is the same case in OGDF for example without 'R'-block. \\\\\nI will try reply by Monday night, worst case Tuesday Morning.",
    "created_at": "2018-09-02T13:21:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357578",
    "user": "saiharsh"
}
```

Replying to [comment:129 dcoudert]:
> `@`Meghana, Sai Harsh: can you do a last check ?
Yes, I will. \\
I will see if there is the same case in OGDF for example without 'R'-block. \\
I will try reply by Monday night, worst case Tuesday Morning.



---

archive/issue_comments_357579.json:
```json
{
    "body": "Yes, I will also work on it. I was travelling the last 3 days. Will work on it tomorrow.",
    "created_at": "2018-09-02T18:27:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357579",
    "user": "meghanamreddy"
}
```

Yes, I will also work on it. I was travelling the last 3 days. Will work on it tomorrow.



---

archive/issue_comments_357580.json:
```json
{
    "body": "Replying to [comment:121 dcoudert]:\n> My last commit is not enough. If instead of 4-cycles, we add 5-cycles, from time to time some 5-cycles are identified as `R`-blocks :(\n> \n> Consider the following example without 'R'-block\n> {{{\n> sage: G = graphs.CycleGraph(4)\n> sage: for u,v in G.edges(labels=False):\n> ....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])\n> sage: for u,v in G.edges(labels=False):\n> ....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])\n> sage: T = G.spqr_tree()\n> sage: V = G.vertices()\n> sage: while not Counter(u[0] for u in T)['R']:\n> ....:     shuffle(V)\n> ....:     G.relabel(perm=V, inplace=True)\n> ....:     T = G.spqr_tree()\n> sage: Counter(u[0] for u in T)\n> Counter({'S': 24, 'P': 20, 'R': 1})\n> }}}\n> I don't know if it's a problem of the algorithm that must be fixed, or if it's a \"bug\" in the code.\n\nI took a graph from the above example which has one `R` component, and ran OGDF code on it. The OGDF output contained only bonds and cycles and no triconnected components. So I feel it could be a bug in our code, I will debug it tomorrow.",
    "created_at": "2018-09-03T19:39:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357580",
    "user": "meghanamreddy"
}
```

Replying to [comment:121 dcoudert]:
> My last commit is not enough. If instead of 4-cycles, we add 5-cycles, from time to time some 5-cycles are identified as `R`-blocks :(
> 
> Consider the following example without 'R'-block
> {{{
> sage: G = graphs.CycleGraph(4)
> sage: for u,v in G.edges(labels=False):
> ....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
> sage: for u,v in G.edges(labels=False):
> ....:     G.add_path([u,G.add_vertex(),G.add_vertex(),G.add_vertex(),v])
> sage: T = G.spqr_tree()
> sage: V = G.vertices()
> sage: while not Counter(u[0] for u in T)['R']:
> ....:     shuffle(V)
> ....:     G.relabel(perm=V, inplace=True)
> ....:     T = G.spqr_tree()
> sage: Counter(u[0] for u in T)
> Counter({'S': 24, 'P': 20, 'R': 1})
> }}}
> I don't know if it's a problem of the algorithm that must be fixed, or if it's a "bug" in the code.

I took a graph from the above example which has one `R` component, and ran OGDF code on it. The OGDF output contained only bonds and cycles and no triconnected components. So I feel it could be a bug in our code, I will debug it tomorrow.



---

archive/issue_comments_357581.json:
```json
{
    "body": "Con you also try adding one more level of paths to `G` and check it with OGDF ? Thanks.",
    "created_at": "2018-09-03T19:51:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357581",
    "user": "dcoudert"
}
```

Con you also try adding one more level of paths to `G` and check it with OGDF ? Thanks.



---

archive/issue_comments_357582.json:
```json
{
    "body": "Ya, I tried. OGDF output does not have any `R` components.\nPlease give me some time, I am working on debugging our code.",
    "created_at": "2018-09-04T19:06:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357582",
    "user": "meghanamreddy"
}
```

Ya, I tried. OGDF output does not have any `R` components.
Please give me some time, I am working on debugging our code.



---

archive/issue_comments_357583.json:
```json
{
    "body": "`while not Counter(u[0] for u in T)['R']:` loop ran for nearly 14 hrs on my system still no R block is found. \\\\\nThat while loop will break only if one R block is found, it's not happening for me, I am still getting the same results like OGDF `Counter({'S': 25, 'P': 20})`. \\\\\nWhen will I get the same case?",
    "created_at": "2018-09-06T18:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357583",
    "user": "saiharsh"
}
```

`while not Counter(u[0] for u in T)['R']:` loop ran for nearly 14 hrs on my system still no R block is found. \\
That while loop will break only if one R block is found, it's not happening for me, I am still getting the same results like OGDF `Counter({'S': 25, 'P': 20})`. \\
When will I get the same case?



---

archive/issue_comments_357584.json:
```json
{
    "body": "I one of the last commits, I changed the way to detect if a block is 'R' or 'S'. But as it is sufficient in OGDF to check if the number of edges is `>= 4`, we suspect there is something wrong somewhere, but I don't know what/where.\n\nYou can modify `finish_tric_or_poly` to just check number of edges to see the issue.",
    "created_at": "2018-09-06T19:15:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357584",
    "user": "dcoudert"
}
```

I one of the last commits, I changed the way to detect if a block is 'R' or 'S'. But as it is sufficient in OGDF to check if the number of edges is `>= 4`, we suspect there is something wrong somewhere, but I don't know what/where.

You can modify `finish_tric_or_poly` to just check number of edges to see the issue.



---

archive/issue_comments_357585.json:
```json
{
    "body": "I found the bug. It was a mistake I did, should have been more careful. Anyway, I am pushing the code in a few minutes.\n\nDavid, I think we can undo the changes you made to fix the bug.",
    "created_at": "2018-09-08T16:36:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357585",
    "user": "meghanamreddy"
}
```

I found the bug. It was a mistake I did, should have been more careful. Anyway, I am pushing the code in a few minutes.

David, I think we can undo the changes you made to fix the bug.



---

archive/issue_comments_357586.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-08T18:12:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357586",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357587.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-09T04:21:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357587",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357588.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-09T09:21:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357588",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_357589.json:
```json
{
    "body": "Excellent ! Thank you.\n\nWe no longer need to count the number of vertices per components, so I removed that part.\n\nI did several tests and for me every thing is going well now. If you also agree, I will finally set this ticket to positive review. It was quite a lot of work.",
    "created_at": "2018-09-09T09:25:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357589",
    "user": "dcoudert"
}
```

Excellent ! Thank you.

We no longer need to count the number of vertices per components, so I removed that part.

I did several tests and for me every thing is going well now. If you also agree, I will finally set this ticket to positive review. It was quite a lot of work.



---

archive/issue_comments_357590.json:
```json
{
    "body": "Yes, I think we can set the ticket to positive review.",
    "created_at": "2018-09-10T17:51:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357590",
    "user": "meghanamreddy"
}
```

Yes, I think we can set the ticket to positive review.



---

archive/issue_comments_357591.json:
```json
{
    "body": "This ticket was a big piece of work and you did a great job. Thanks to both of you.",
    "created_at": "2018-09-10T21:15:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357591",
    "user": "dcoudert"
}
```

This ticket was a big piece of work and you did a great job. Thanks to both of you.



---

archive/issue_comments_357592.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-09-10T21:15:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357592",
    "user": "dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_357593.json:
```json
{
    "body": "Author name...",
    "created_at": "2018-09-11T21:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357593",
    "user": "vbraun"
}
```

Author name...



---

archive/issue_comments_357594.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2018-09-11T21:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357594",
    "user": "vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_357595.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2018-09-11T21:54:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357595",
    "user": "dimpase"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_357596.json:
```json
{
    "body": "hey, ladies and gentlemen ! coverage is supposed to be 100%\n\n```\n+Decreased doctests in graphs/connectivity.pyx: from 21 / 21 = 100% to 24 / 60 = 40%\n```\n",
    "created_at": "2018-09-12T14:40:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357596",
    "user": "chapoton"
}
```

hey, ladies and gentlemen ! coverage is supposed to be 100%

```
+Decreased doctests in graphs/connectivity.pyx: from 21 / 21 = 100% to 24 / 60 = 40%
```




---

archive/issue_comments_357597.json:
```json
{
    "body": "perhaps a follow-up ticket to address testing?",
    "created_at": "2018-09-12T14:43:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357597",
    "user": "dimpase"
}
```

perhaps a follow-up ticket to address testing?



---

archive/issue_comments_357598.json:
```json
{
    "body": "We implement a big algorithm that is split into sub methods. I don't know how to add doctests that are meaningful for the sub methods. Any suggestion is more than welcome.\n\nBut for sure I plan to continue working on it (remove recursions, cythonise what I can, etc.).",
    "created_at": "2018-09-12T15:15:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357598",
    "user": "dcoudert"
}
```

We implement a big algorithm that is split into sub methods. I don't know how to add doctests that are meaningful for the sub methods. Any suggestion is more than welcome.

But for sure I plan to continue working on it (remove recursions, cythonise what I can, etc.).



---

archive/issue_comments_357599.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-09-13T19:25:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357599",
    "user": "vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_357600.json:
```json
{
    "body": "This is certainly something technical but I'll be happy to know (learn) what's going on. Thanks.",
    "created_at": "2018-10-24T11:59:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357600",
    "user": "dcoudert"
}
```

This is certainly something technical but I'll be happy to know (learn) what's going on. Thanks.



---

archive/issue_comments_357601.json:
```json
{
    "body": "This should be re-targeted for 8.5.",
    "created_at": "2018-10-28T14:52:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25361",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25361#issuecomment-357601",
    "user": "embray"
}
```

This should be re-targeted for 8.5.
