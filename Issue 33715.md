# Issue 33715: Add methods to compute holomorphic differentials of function field

Issue created by migration from https://trac.sagemath.org/ticket/33952

Original creator: klee

Original creation time: 2022-06-05 02:52:50

CC:  @brentbaccala

It is simple to computer the space of holomorphic differentials based on the current function field machinery.


---

Comment by git created at 2022-06-05 02:53:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-06-05 02:56:43

Changing status from new to needs_review.


---

Comment by @DisneyHogg created at 2022-06-27 08:07:19

The code can be very slow and presumably use a lot of memory as in the following case, where for me Sage eventually crashes. 

```
F.<s5> = QQ.extension(polygen(QQ)^2-5, embedding=2)
K.<x> = FunctionField(F)
_.<Y> = K[]
f = -20*x^6 + (45*s5 + 75)*x^4*Y + 68*x^3*Y^2 + (-180*s5 - 400)*x^3*Y + (189*s5 + 441)*x^2*Y^2 + (45*s5 + 75)*x*Y^3 - 20*Y^4 + (-63*s5 - 141)*x*Y^2 + (-180*s5 - 400)*Y^3 + (144*s5 + 322)*Y^2
L.<y> = K.extension(f)
L.basis_of_holomorphic_differentials()
```

This example comes from a genuine use case I have wanted differentials for, and Maple can do the corresponding calculation in less than a second. Perhaps add a warning or a note about this in the documentation, otherwise the code looks good.


---

Comment by klee created at 2022-06-27 09:14:11

Replying to [comment:5 gh-DisneyHogg]:
> The code can be very slow and presumably use a lot of memory as in the following case, where for me Sage eventually crashes. 
> {{{
> F.<s5> = QQ.extension(polygen(QQ)^2-5, embedding=2)
> K.<x> = FunctionField(F)
> _.<Y> = K[]
> f = -20*x^6 + (45*s5 + 75)*x^4*Y + 68*x<sup>3*Y</sup>2 + (-180*s5 - 400)*x^3*Y + (189*s5 + 441)*x<sup>2*Y</sup>2 + (45*s5 + 75)*x*Y^3 - 20*Y^4 + (-63*s5 - 141)*x*Y^2 + (-180*s5 - 400)*Y^3 + (144*s5 + 322)*Y^2
> L.<y> = K.extension(f)
> L.basis_of_holomorphic_differentials()
> }}}
> This example comes from a genuine use case I have wanted differentials for, and Maple can do the corresponding calculation in less than a second. 

Sorry that the method does not help your genuine use case. Indeed it takes forever just to compute `L.maximal_order_infinite()`, which needs to be done before any computation can proceed. It does the computation through Singular's `normal` function that computes the integral closure of a given ideal. It seems that the Singular function does not work well with number fields...  

> Perhaps add a warning or a note about this in the documentation, otherwise the code looks good. 

The above failure is not directly related with the code here. So it seems inappropriate to add a warning or note to the new method.


---

Comment by git created at 2022-06-27 09:17:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-06-27 10:30:48

Changing status from needs_review to positive_review.


---

Comment by @DisneyHogg created at 2022-06-27 10:30:48

Replying to [comment:6 klee]:

> The above failure is not directly related with the code here. So it seems inappropriate to add a warning or note to the new method.

Happy with this approach, so give positive review.


---

Comment by klee created at 2022-06-27 11:57:23

Thanks!

cc-ed to the characteristic-zero function field expert.


---

Comment by @BrentBaccala created at 2022-07-02 00:22:52

Replying to [comment:10 klee]:
> Thanks!
> 
> cc-ed to the characteristic-zero function field expert.

Thanks for the cc, klee, I'll take a look.


---

Comment by klee created at 2022-07-02 01:49:18

Replying to [comment:11 gh-BrentBaccala]:
> Replying to [comment:10 klee]:
> > Thanks!
> > 
> > cc-ed to the characteristic-zero function field expert.
> 
> Thanks for the cc, klee, I'll take a look.

Meanwhile, I narrowed it down to this singular code (which computes the integral basis of the infinite maximal order of the example function field):


```
LIB "normal.lib";
ring S = (0,s5),(x,y),dp;
minpoly = s5^2 - 5;
ideal i = x^18+(9*s5+20)*y*x^15+(-9/4*s5-15/4)*y*x^14+(-36/5*s5-161/10)*y^2*x^12+(63/20*s5+141/20)*y^2*x^11+(-189/20*s5-441/20)*y^2*x^10-17/5*y^2*x^9+(9*s5+20)*y^3*x^6+(-9/4*s5-15/4)*y^3*x^5+y^4;
normal(i);
```


which takes forever.


---

Comment by klee created at 2022-07-02 23:22:34

I received this reply from the author of `normal.lib`, Gert-Martin Greuel:
----
The ideal is fine and the algorithm works well. However, due to
coefficient swell in char 0 it takes long.
You can control the computational progress by setting `option(prot);`
before the computation (the manual explains the symbols).

I did the computation in a large finite char and then it took 31 sec
(on my MacBook Air M1). The protocol gives you an impression of the
large number of Groebner basis computations. Here is my input

```
option(prot);
LIB "normal.lib";
ring S = (32003,s5),(x,y),dp;
minpoly = s5^2 - 5;
ideal i = x^18+(9*s5+20)*y*x^15+(-9/4*s5-15/4)*y*x^14+(-36/5*s5-161/10)*y^2*x^12+(63/20*s5+141/20)*y^2*x^11+(-189/20*s5-441/20)*y^2*x^10-17/5*y^2*x^9+(9*s5+20)*y^3*x^6+(-9/4*s5-15/4)*y^3*x^5+y^4;
int t=timer;
list nor = normal(i);
timer-t;   //shows the time in sec
nor;
```

I stopped the computation in char 0 after 5 h but the protocol shows
that it works correctly. However the total time to finish is
unpredictable.


---

Comment by vbraun created at 2022-07-09 22:31:05

Resolution: fixed
