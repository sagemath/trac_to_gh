# Issue 32999: timeouts in parallel/map_reduce.py

Issue created by migration from https://trac.sagemath.org/ticket/33236

Original creator: @mwageringel

Original creation time: 2022-01-27 21:35:48

CC:  @kliem mjo

Keywords: map_reduce, timeout

The following doctest frequently results in a deadlock (for example on the patchbots and the [mailing list](https://groups.google.com/g/sage-release/search?q=map_reduce)):

```
    sage: from sage.parallel.map_reduce import (RESetMPExample, AbortError)
    sage: EX = RESetMPExample(maxl=100)
    sage: try:
    ....:     res = EX.run(timeout=float(0.01))
    ....: except AbortError:
    ....:     print("Computation timeout")
    ....: else:
    ....:     print("Computation normally finished")
    ....:     res
    Computation timeout
```


This is caused by the worker process (actually its thief thread) acquiring a lock on the shared `_aborted` boolean value, while simultaneously the worker process is terminated, so that the lock is never released. Indeed, the Python [documentation](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate) says:

    _if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock._




---

Comment by @mwageringel created at 2022-01-27 21:40:41

Changing status from new to needs_review.


---

Comment by @mwageringel created at 2022-01-27 21:40:41

Possibe solutions:

1. Access the `_aborted` value without locking. This is "[not necessarily process-safe](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value)", but is a viable compromise as the value is only set once, and if the computation is aborted, any remaining computation of the thread does not matter anyway.

2. Replace the thief `Thread` by its own `mp.Process`. That way, it can exit normally when the worker process is terminated, but I am not sure about potential performance implications.

3. Before terminating the worker processes, block the main process to let the thief threads exit on their own. This would require some form of communication from the thief threads back to the main process.

This branch implements option 1, as it is simple and does not change the current behavior too much.

----
New commits:


---

Comment by @mwageringel created at 2022-01-27 21:42:03

Changing component from performance to doctest framework.


---

Comment by mjo created at 2022-02-05 01:26:22

Changing status from needs_review to positive_review.


---

Comment by mjo created at 2022-02-05 01:26:22

I haven't been able to reproduce the failure, but I stared at the code long enough that I believe Option 1 is at best the simplest fix, and at worst harmless.

For posterity, it also looks like we could pass in our own `multiprocessing.Lock` object, which we could then `release()` manually while we are terminating the workers: at that point, the value of `_aborted` is fixed and should only be read.


---

Comment by @mwageringel created at 2022-02-05 10:42:45

Thank you.

I should have posted this earlier, but for completeness here is a minimal example that illustrates the problem:

```python
from time import sleep
from threading import Thread
import multiprocessing as mp
import ctypes

_aborted = mp.Value(ctypes.c_bool, False, lock=True)

def thief():
    for a in range(20):
        print(-a)
        with _aborted.get_lock():  # this lock does not get released when terminated
            sleep(0.5)

def worker():
    t = Thread(target=thief, name="Thief")
    t.start()
    for a in range(20):
        print(a)
        sleep(0.5)

w = mp.Process(target=worker, name="Worker")
w.start()
sleep(2.2)
w.terminate()
sleep(1)
print("aborted = %s" % _aborted.value)  # deadlocks
```



---

Comment by vbraun created at 2022-02-13 10:16:38

Resolution: fixed
