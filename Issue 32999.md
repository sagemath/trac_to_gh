# Issue 32999: timeouts in parallel/map_reduce.py

archive/issues_032999.json:
```json
{
    "body": "CC:  @kliem @orlitzky\n\nKeywords: map_reduce, timeout\n\nThe following doctest frequently results in a deadlock (for example on the patchbots and the [mailing list](https://groups.google.com/g/sage-release/search?q=map_reduce)):\n\n```\n    sage: from sage.parallel.map_reduce import (RESetMPExample, AbortError)\n    sage: EX = RESetMPExample(maxl=100)\n    sage: try:\n    ....:     res = EX.run(timeout=float(0.01))\n    ....: except AbortError:\n    ....:     print(\"Computation timeout\")\n    ....: else:\n    ....:     print(\"Computation normally finished\")\n    ....:     res\n    Computation timeout\n```\n\n\nThis is caused by the worker process (actually its thief thread) acquiring a lock on the shared `_aborted` boolean value, while simultaneously the worker process is terminated, so that the lock is never released. Indeed, the Python [documentation](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate) says:\n\n    *if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock.*\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/33236\n\n",
    "created_at": "2022-01-27T21:35:48Z",
    "labels": [
        "component: performance",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.6",
    "title": "timeouts in parallel/map_reduce.py",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/32999",
    "user": "https://github.com/mwageringel"
}
```
CC:  @kliem @orlitzky

Keywords: map_reduce, timeout

The following doctest frequently results in a deadlock (for example on the patchbots and the [mailing list](https://groups.google.com/g/sage-release/search?q=map_reduce)):

```
    sage: from sage.parallel.map_reduce import (RESetMPExample, AbortError)
    sage: EX = RESetMPExample(maxl=100)
    sage: try:
    ....:     res = EX.run(timeout=float(0.01))
    ....: except AbortError:
    ....:     print("Computation timeout")
    ....: else:
    ....:     print("Computation normally finished")
    ....:     res
    Computation timeout
```


This is caused by the worker process (actually its thief thread) acquiring a lock on the shared `_aborted` boolean value, while simultaneously the worker process is terminated, so that the lock is never released. Indeed, the Python [documentation](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.terminate) says:

    *if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock.*



Issue created by migration from https://trac.sagemath.org/ticket/33236





---

archive/issue_comments_470016.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-01-27T21:40:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470016",
    "user": "https://github.com/mwageringel"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_470017.json:
```json
{
    "body": "Possibe solutions:\n\n1. Access the `_aborted` value without locking. This is \"[not necessarily process-safe](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value)\", but is a viable compromise as the value is only set once, and if the computation is aborted, any remaining computation of the thread does not matter anyway.\n\n2. Replace the thief `Thread` by its own `mp.Process`. That way, it can exit normally when the worker process is terminated, but I am not sure about potential performance implications.\n\n3. Before terminating the worker processes, block the main process to let the thief threads exit on their own. This would require some form of communication from the thief threads back to the main process.\n\nThis branch implements option 1, as it is simple and does not change the current behavior too much.\n\n----\nNew commits:",
    "created_at": "2022-01-27T21:40:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470017",
    "user": "https://github.com/mwageringel"
}
```

Possibe solutions:

1. Access the `_aborted` value without locking. This is "[not necessarily process-safe](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value)", but is a viable compromise as the value is only set once, and if the computation is aborted, any remaining computation of the thread does not matter anyway.

2. Replace the thief `Thread` by its own `mp.Process`. That way, it can exit normally when the worker process is terminated, but I am not sure about potential performance implications.

3. Before terminating the worker processes, block the main process to let the thief threads exit on their own. This would require some form of communication from the thief threads back to the main process.

This branch implements option 1, as it is simple and does not change the current behavior too much.

----
New commits:



---

archive/issue_comments_470018.json:
```json
{
    "body": "Changing component from performance to doctest framework.",
    "created_at": "2022-01-27T21:42:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470018",
    "user": "https://github.com/mwageringel"
}
```

Changing component from performance to doctest framework.



---

archive/issue_comments_470019.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-02-05T01:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470019",
    "user": "https://github.com/orlitzky"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_470020.json:
```json
{
    "body": "I haven't been able to reproduce the failure, but I stared at the code long enough that I believe Option 1 is at best the simplest fix, and at worst harmless.\n\nFor posterity, it also looks like we could pass in our own `multiprocessing.Lock` object, which we could then `release()` manually while we are terminating the workers: at that point, the value of `_aborted` is fixed and should only be read.",
    "created_at": "2022-02-05T01:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470020",
    "user": "https://github.com/orlitzky"
}
```

I haven't been able to reproduce the failure, but I stared at the code long enough that I believe Option 1 is at best the simplest fix, and at worst harmless.

For posterity, it also looks like we could pass in our own `multiprocessing.Lock` object, which we could then `release()` manually while we are terminating the workers: at that point, the value of `_aborted` is fixed and should only be read.



---

archive/issue_comments_470021.json:
```json
{
    "body": "Thank you.\n\nI should have posted this earlier, but for completeness here is a minimal example that illustrates the problem:\n\n```python\nfrom time import sleep\nfrom threading import Thread\nimport multiprocessing as mp\nimport ctypes\n\n_aborted = mp.Value(ctypes.c_bool, False, lock=True)\n\ndef thief():\n    for a in range(20):\n        print(-a)\n        with _aborted.get_lock():  # this lock does not get released when terminated\n            sleep(0.5)\n\ndef worker():\n    t = Thread(target=thief, name=\"Thief\")\n    t.start()\n    for a in range(20):\n        print(a)\n        sleep(0.5)\n\nw = mp.Process(target=worker, name=\"Worker\")\nw.start()\nsleep(2.2)\nw.terminate()\nsleep(1)\nprint(\"aborted = %s\" % _aborted.value)  # deadlocks\n```\n",
    "created_at": "2022-02-05T10:42:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470021",
    "user": "https://github.com/mwageringel"
}
```

Thank you.

I should have posted this earlier, but for completeness here is a minimal example that illustrates the problem:

```python
from time import sleep
from threading import Thread
import multiprocessing as mp
import ctypes

_aborted = mp.Value(ctypes.c_bool, False, lock=True)

def thief():
    for a in range(20):
        print(-a)
        with _aborted.get_lock():  # this lock does not get released when terminated
            sleep(0.5)

def worker():
    t = Thread(target=thief, name="Thief")
    t.start()
    for a in range(20):
        print(a)
        sleep(0.5)

w = mp.Process(target=worker, name="Worker")
w.start()
sleep(2.2)
w.terminate()
sleep(1)
print("aborted = %s" % _aborted.value)  # deadlocks
```




---

archive/issue_comments_470022.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2022-02-13T10:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32999#issuecomment-470022",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_029883.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-02-13T10:16:38Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/32999",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/32999#event-29883"
}
```
