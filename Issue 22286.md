# Issue 22286: Symbolic power of a matrix

Issue created by migration from https://trac.sagemath.org/ticket/22523

Original creator: mforets

Original creation time: 2017-03-06 00:44:16

CC:  tmonteil

Keywords: days84

Compute the k-th power of a matrix, where k is a symbolic variable.

See [this question](https://ask.sagemath.org/question/35658/general-power-of-a-matrix/#35666).


---

Comment by mforets created at 2017-03-10 19:06:41

this patch is broken:


```
sage: A = random_matrix(RDF, 2)
sage: A

[-0.9428173549065391  -0.301642050267529]
[ 0.6212822063471177 -0.9690284523509545]
sage: A^x
...
AttributeError: 'sage.matrix.matrix_real_double_dense.Matrix_real_double_dense' object has no attribute '_matrix_power_symbolic'
```


just adding the new `_matrix_power_symbolic` and updating the generic ` __pow__` doesn't seem to be correct. some hints?
----
New commits:


---

Comment by tmonteil created at 2017-03-10 19:12:25

Either `_matrix_power_symbolic` is a function and then you should call `_matrix_power_symbolic(self, n)`, or `_matrix_power_symbolic` is a method (of a generic matrix class), and then you should call `self._matrix_power_symbolic(n)`. Here, you seem to mix both points by calling `self._matrix_power_symbolic(self, n)` (so that `self` is used for the two arguments of `_matrix_power_symbolic`).


---

Comment by tmonteil created at 2017-03-10 19:19:11

Replying to [comment:3 tmonteil]:
> Either `_matrix_power_symbolic` is a function and then you should call `_matrix_power_symbolic(self, n)`, or `_matrix_power_symbolic` is a method (of a generic matrix class), and then you should call `self._matrix_power_symbolic(n)`. Here, you seem to mix both points by calling `self._matrix_power_symbolic(self, n)` (so that `self` is used for the first two arguments of `_matrix_power_symbolic`). 
>


---

Comment by git created at 2017-03-11 13:30:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mforets created at 2017-03-11 13:30:50

Changing status from new to needs_review.


---

Comment by git created at 2017-03-11 19:59:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-03-12 15:29:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mforets created at 2017-04-10 07:47:35

also related, this other [ask.sagemath question](https://ask.sagemath.org/question/8280/an-nvarn/)


---

Comment by mforets created at 2017-04-10 07:51:03

the patchbot is complaining about:


```
sage -t --long src/doc/en/reference/references/index.rst
    Error: TAB character found at line 797
    [0 tests, 0.00 s]
----------------------------------------------------------------------
sage -t --long src/doc/en/reference/references/index.rst  # Tab character found
----------------------------------------------------------------------
```


i'll try to fix this.


---

Comment by git created at 2017-04-11 08:48:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-04-11 16:02:48

Some quick comments:

- Use `Jk[i,i]` instead of `Jk[i][i]` as the latter creates a temporary `vector` object. However, I would do
  {{{#!python
            Jk_ii = Jk[i,i]
            if hasattr(Jk_ii, 'radical_expression'):
                Jk_ii = Jk_ii.radical_expression()
  }}}
- Use ``` instead of `$` for latex formatting in docstrings.
- In the `INPUT:` block: `- ``A`` -- a square matrix over an exact field` Note the removal of the period too.
- Make `A` and `A^n` in latex.
- Is there some reason why the function is not a `cdef` function?
- I don't understand why you try to change the base ring to `QQbar`. Could you justify this?
- This seems strange: `vector(SR, i).list()`. Why not `[SR.zero()]*i`?
- I would use a call to `binomial` instead of `(factorial_n/(factorial(n-i)*factorial(i))` because it probably requires less operations when `n` is big. Perhaps some testing is needed here.
- How many of those imports are needed in the function? Having them there slows the function down.
- I'm not completely sure about creating the blank (dense) matrix and then filling it in afterwards. I feel like a better solution would be to just construct the data for the matrix and then construct the matrix from that (if this is even needed).


---

Comment by mforets created at 2017-04-11 18:15:07

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-04-12 19:15:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mforets created at 2017-04-12 19:24:27

`@`tscrim : thanks for the feedback, i've tried to correct the formatting issues.

some testing for the algorithm before changes (before 32e7cf9):

Test in the rationals, two-dimensional:


```
    sage: k = var('k')
    sage: A = matrix(QQ, 2, [1/2, -1, 2, 0])
    sage: timeit('A^k')
    5 loops, best of 3: 105 ms per loop
```


Test of the [stochastic matrix](https://en.wikipedia.org/wiki/Stochastic_matrix) in wikipedia:


```
    sage: A = matrix([[0, 0, 1/2, 0, 1/2], [0, 0, 1, 0, 0], [1/4, 1/4, 0, 1/4, 1/4], [0, 0, 1/2, 0, 1/2], [0, 0, 0, 0, 1]])
    sage: timeit('A^k')
    5 loops, best of 3: 192 ms per loop
```


Test in the symbolic ring:


```
    sage: n = var('n')
    sage: A = matrix([[pi, e],[0, -2*I]])
    sage: timeit('A^n')
    25 loops, best of 3: 26 ms per loop
```


here are some partial answers:

> - Use `Jk[i,i]` instead of `Jk[i][i]` as the latter creates a temporary `vector` object. However, I would do
>   {{{#!python
>             Jk_ii = Jk[i,i]
>             if hasattr(Jk_ii, 'radical_expression'):
>                 Jk_ii = Jk_ii.radical_expression()
>   }}}

yes, it is better that way. it didn't have an impact in the timing of my quick examples above, though (+- 10ms)

> - I don't understand why you try to change the base ring to `QQbar`. Could you justify this?

this is to cover the cases where the eigenvalues do not belong to the same ring as the given matrix. in general the `jordan_form` method breaks with the message `RuntimeError: Some eigenvalue does not exist in Rational Field.` 

For example consider taking the jordan form of `A = matrix(2, [1, 2, 1, -2])`. 

On the other hand, the example `A = matrix([[pi, e],[0, -2*I]])` tests the case when it is not possible to transform to QQbar (it would break with ``TypeError: Illegal initializer for algebraic number``). 

> - This seems strange: `vector(SR, i).list()`. Why not `[SR.zero()]*i`?

sure, i'm used to thinking in matrices/vectors in the 1st place, rather than lists :) 

done in the new commit, for the record it didn't have an impact on timeit for the 3 examples above (+- 5..10ms)

> - I would use a call to `binomial` instead of `(factorial_n/(factorial(n-i)*factorial(i))` because it probably requires less operations when `n` is big. Perhaps some testing is needed here.

right, at least with the binomial method the code is more clear.

more generally, i'm not confident that jordanization will be useful at all for 
'big' n, since this operation is very costly. however if the matrix is very sparse then maybe it works, i didn't try any of that.

> - How many of those imports are needed in the function? Having them there slows the function down.

well yes, i was able to get rid of importing vector, based on the suggestion of above.


---

Comment by mforets created at 2017-04-13 13:11:55

> Is there some reason why the function is not a cdef function? 

i tried `def` -> `cdef` in the function's definition, but this breaks many things (compilation). where can i learn more about using cdef in Sage library code? thanks

> I'm not completely sure about creating the blank (dense) matrix and then filling it in afterwards. I feel like a better solution would be to just construct the data for the matrix and then construct the matrix from that (if this is even needed). 

hmm i would normally use the same matrix to store partial computations (instead of creating a new one, say). are you suggesting that it's preferable to do differently like what, use lists? 

in this particular case, there are `FJ_k.set_row(i, Jk_row_i)` and `FJ.set_block(k, k, FJ_k)` inside a loop. yes, the matrix `FJ` is needed afterwards to do the computation `P * FJ * Pinv`.


---

Comment by tscrim created at 2017-04-15 04:12:51

Replying to [comment:16 mforets]:
> > Is there some reason why the function is not a cdef function? 
> 
> i tried `def` -> `cdef` in the function's definition, but this breaks many things (compilation). where can i learn more about using cdef in Sage library code? thanks

Hmm...interesting. I will try this and see what I can do. To learn about `cdef`, you should probably go to Cython's docs. The error messages on these failures can be helpful sometimes to fix things.

> > I'm not completely sure about creating the blank (dense) matrix and then filling it in afterwards. I feel like a better solution would be to just construct the data for the matrix and then construct the matrix from that (if this is even needed). 
> 
> hmm i would normally use the same matrix to store partial computations (instead of creating a new one, say). are you suggesting that it's preferable to do differently like what, use lists? 

Ideally you would use a single list, but a list of lists also works. At least for dense matrices. If the matrix was expected to be sparse, then a dict is good. The issue is more of that element creation is a relatively heavy operation compared to creating lists. Although I would directly modify the matrix `FJ`.

> in this particular case, there are `FJ_k.set_row(i, Jk_row_i)` and `FJ.set_block(k, k, FJ_k)` inside a loop. yes, the matrix `FJ` is needed afterwards to do the computation `P * FJ * Pinv`.

However, `FJ_k` is not. I would just like to modify `FJ` since the intermediate matrix `FJ_k` doesn't really need to be there.


---

Comment by git created at 2017-04-17 22:31:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mforets created at 2017-04-17 22:38:24

Changing status from needs_work to needs_review.


---

Comment by mforets created at 2017-04-17 22:48:24

for the 2x2 case there is a simple closed formula by [K. S. Williams](http://people.math.carleton.ca/~williams/papers/pdf/175.pdf). since it does not require the jordan form, it can also be used with an inexact ring, and maybe it's faster (i don't plan to try it, just a comment.)


---

Comment by tscrim created at 2017-04-17 23:18:13

Let's get this into Sage. Positive review.


---

Comment by tscrim created at 2017-04-17 23:18:13

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-04-23 12:58:09

Resolution: fixed


---

Comment by slelievre created at 2018-04-02 18:08:44

Follow-up at #25028 after a bug was reported (and a fix found) at
[Ask Sage question 41622](https://ask.sagemath.org/question/41622/bug-in-general-power-of-a-matrix).
