# Issue 21312: Can't interrupt cleanly RecursivelyEnumeratedSet.graded_component

archive/issues_021075.json:
```json
{
    "assignees": [],
    "body": "From the [Iterators and KeyboardInterrupt](https://groups.google.com/forum/#!topic/sage-devel/-VdAiudU6o0) discussion on  sage-devel, here is a reproducable bug:\n\n```\nsage: def f(a):\n....:    sleep(0.1)\n....:    return [a-1,a+1]\nsage: C = RecursivelyEnumeratedSet([0], f, structure='symmetric')\nsage: from cysignals.alarm import alarm\nsage: alarm(0.45); C.graded_component(10)\nTraceback (most recent call last):\n...\nAlarmInterrupt: \nsage: C.graded_component(1)\n{-1, 1}\nsage: C.graded_component(2)\n{-2, 2}\nsage: C.graded_component(3)\nTraceback (most recent call last):\n...\nStopIteration: \nsage: C.graded_component(4)\nTraceback (most recent call last):\n...\nStopIteration: \n```\n\nCC:  @hivert\n\nBranch: **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)**\n\nReviewer: **Salvatore Stella**\n\nAuthor: **S\u00e9bastien Labb\u00e9**\n\nComponent: **combinatorics**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/21312_\n\n",
    "closed_at": "2016-08-27T08:36:18Z",
    "created_at": "2016-08-23T08:58:29Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-7.4",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Can't interrupt cleanly RecursivelyEnumeratedSet.graded_component",
    "type": "issue",
    "updated_at": "2016-08-27T16:59:39Z",
    "url": "https://github.com/sagemath/sage/issues/21312",
    "user": "https://github.com/seblabbe"
}
```
From the [Iterators and KeyboardInterrupt](https://groups.google.com/forum/#!topic/sage-devel/-VdAiudU6o0) discussion on  sage-devel, here is a reproducable bug:

```
sage: def f(a):
....:    sleep(0.1)
....:    return [a-1,a+1]
sage: C = RecursivelyEnumeratedSet([0], f, structure='symmetric')
sage: from cysignals.alarm import alarm
sage: alarm(0.45); C.graded_component(10)
Traceback (most recent call last):
...
AlarmInterrupt: 
sage: C.graded_component(1)
{-1, 1}
sage: C.graded_component(2)
{-2, 2}
sage: C.graded_component(3)
Traceback (most recent call last):
...
StopIteration: 
sage: C.graded_component(4)
Traceback (most recent call last):
...
StopIteration: 
```

CC:  @hivert

Branch: **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)**

Reviewer: **Salvatore Stella**

Author: **Sébastien Labbé**

Component: **combinatorics**

_Issue created by migration from https://trac.sagemath.org/ticket/21312_





---

archive/issue_events_296853.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2016-08-23T08:58:29Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "milestone_number": null,
    "milestone_title": "sage-7.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296853"
}
```



---

archive/issue_events_296854.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2016-08-23T08:58:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
    "label_color": "0000ff",
    "label_name": "c: combinatorics",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296854"
}
```



---

archive/issue_events_296855.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2016-08-23T08:58:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296855"
}
```



---

archive/issue_events_296856.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2016-08-23T08:58:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296856"
}
```



---

archive/issue_comments_311614.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-From the [Iterators and KeyboardInterrupt](https://groups.google.com/forum/#!topic/sage-devel/-VdAiudU6o0) discussion on  sage-devel, I created this reproducable bug:\n+From the [Iterators and KeyboardInterrupt](https://groups.google.com/forum/#!topic/sage-devel/-VdAiudU6o0) discussion on  sage-devel, here is a reproducable bug:\n \n ```\n sage: def f(a):\n``````\n",
    "created_at": "2016-08-23T08:59:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311614",
    "user": "https://github.com/seblabbe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-From the [Iterators and KeyboardInterrupt](https://groups.google.com/forum/#!topic/sage-devel/-VdAiudU6o0) discussion on  sage-devel, I created this reproducable bug:
+From the [Iterators and KeyboardInterrupt](https://groups.google.com/forum/#!topic/sage-devel/-VdAiudU6o0) discussion on  sage-devel, here is a reproducable bug:
 
 ```
 sage: def f(a):
``````




---

archive/issue_comments_311615.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nMaybe using `sig_check`, we can fix this?\n\nhttps://github.com/sagemath/cysignals/blob/master/docs/source/index.rst#using-sig_check",
    "created_at": "2016-08-23T09:04:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311615",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:2" align="right">comment:2</div>

Maybe using `sig_check`, we can fix this?

https://github.com/sagemath/cysignals/blob/master/docs/source/index.rst#using-sig_check



---

archive/issue_comments_311616.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nIt goes down to `graded_component_iterator` method:\n\n```python\nsage: def f(a):\n....:     sleep(0.05)\n....:     return [a-1,a+1]\nsage: C = RecursivelyEnumeratedSet([0], f, structure='symmetric')\nsage: it = C.graded_component_iterator()\nsage: next(it)\n{0}\nsage: next(it)\n{-1, 1}\nsage: next(it)\n{-2, 2}\nsage: next(it)\n{-3, 3}\nsage: from cysignals.alarm import alarm\nsage: alarm(0.02); next(it)\nTraceback (most recent call last):\n...\nAlarmInterrupt: \nsage: next(it)\nTraceback (most recent call last):\n...\nStopIteration: \n```",
    "created_at": "2016-08-23T09:17:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311616",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:3" align="right">comment:3</div>

It goes down to `graded_component_iterator` method:

```python
sage: def f(a):
....:     sleep(0.05)
....:     return [a-1,a+1]
sage: C = RecursivelyEnumeratedSet([0], f, structure='symmetric')
sage: it = C.graded_component_iterator()
sage: next(it)
{0}
sage: next(it)
{-1, 1}
sage: next(it)
{-2, 2}
sage: next(it)
{-3, 3}
sage: from cysignals.alarm import alarm
sage: alarm(0.02); next(it)
Traceback (most recent call last):
...
AlarmInterrupt: 
sage: next(it)
Traceback (most recent call last):
...
StopIteration: 
```



---

archive/issue_comments_311617.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nIn essence this seems to be the same issue I came with in sage-devel: \ngraded_component_iterator constructs an iterator using yield and these do not behave nicely when they get interrupted.",
    "created_at": "2016-08-23T09:34:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311617",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:4" align="right">comment:4</div>

In essence this seems to be the same issue I came with in sage-devel: 
graded_component_iterator constructs an iterator using yield and these do not behave nicely when they get interrupted.



---

archive/issue_comments_311618.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nI think I have an idea. We simply need to get rid of the `graded_component_iterator` in the code of `graded_component`. Then, this will not be the same code for structure graded and structure symmetric. I will try this as soon as I get a compiled sage in a few minutes.",
    "created_at": "2016-08-23T09:41:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311618",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:5" align="right">comment:5</div>

I think I have an idea. We simply need to get rid of the `graded_component_iterator` in the code of `graded_component`. Then, this will not be the same code for structure graded and structure symmetric. I will try this as soon as I get a compiled sage in a few minutes.



---

archive/issue_events_296857.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2016-08-23T11:05:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296857"
}
```



---

archive/issue_comments_311619.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a\"><code>6634754</code></a></td><td><code>21312: avoid using iterator for graded_component</code></td></tr></table>\n",
    "created_at": "2016-08-23T11:05:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311619",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:6"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a"><code>6634754</code></a></td><td><code>21312: avoid using iterator for graded_component</code></td></tr></table>




---

archive/issue_comments_311620.json:
```json
{
    "body": "Commit: **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)**",
    "created_at": "2016-08-23T11:05:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311620",
    "user": "https://github.com/seblabbe"
}
```

Commit: **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)**



---

archive/issue_comments_311621.json:
```json
{
    "body": "Branch: **[u/slabbe/21312](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/21312)**",
    "created_at": "2016-08-23T11:05:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311621",
    "user": "https://github.com/seblabbe"
}
```

Branch: **[u/slabbe/21312](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/21312)**



---

archive/issue_comments_311622.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nThanks for this fix; at first glance it looks ok to me, I will try to give it a more in-depth review soon.\n\nOn a related topic: in my usual testing example I get a major slowdown replacing my custom made iterator with a `RecursivelyEnumeratedSet`. To explore a 8-regular graph with 25080 vertices it takes 54.6 seconds as opposed to 29.9. I am not sure if this depends on the `__hash__` function I implemented or to the fact that I am a little bit more careful on which edges I travel along and which I can disregard a priori.\n\nAnother thing: maybe `depth_first_search_iterator` can be tweaked not to compute a whole graded component before returning. I have half and idea on how to do this, let me carefully think if it is feasible.",
    "created_at": "2016-08-23T12:36:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311622",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:7" align="right">comment:7</div>

Thanks for this fix; at first glance it looks ok to me, I will try to give it a more in-depth review soon.

On a related topic: in my usual testing example I get a major slowdown replacing my custom made iterator with a `RecursivelyEnumeratedSet`. To explore a 8-regular graph with 25080 vertices it takes 54.6 seconds as opposed to 29.9. I am not sure if this depends on the `__hash__` function I implemented or to the fact that I am a little bit more careful on which edges I travel along and which I can disregard a priori.

Another thing: maybe `depth_first_search_iterator` can be tweaked not to compute a whole graded component before returning. I have half and idea on how to do this, let me carefully think if it is feasible.



---

archive/issue_comments_311623.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\n> I will try to give it a more in-depth review soon. \n\nGreat. Also, I created #21311 just this morning while looking at the code on github if you can have a look at it.\n\n> On a related topic: in my usual testing example I get a major slowdown\n\nIf you can provide a working example illustrating this, I will be curious in investigating it.\n \n> Another thing: maybe `depth_first_search_iterator` can be tweaked not to compute a whole graded component before returning. I have half and idea on how to do this, let me carefully think if it is feasible.\n\nGreat! Tell me you think it works.",
    "created_at": "2016-08-23T12:58:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311623",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:8" align="right">comment:8</div>

> I will try to give it a more in-depth review soon. 

Great. Also, I created #21311 just this morning while looking at the code on github if you can have a look at it.

> On a related topic: in my usual testing example I get a major slowdown

If you can provide a working example illustrating this, I will be curious in investigating it.
 
> Another thing: maybe `depth_first_search_iterator` can be tweaked not to compute a whole graded component before returning. I have half and idea on how to do this, let me carefully think if it is feasible.

Great! Tell me you think it works.



---

archive/issue_comments_311624.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\n> On a related topic: in my usual testing example I get a major slowdown\n> > If you can provide a working example illustrating this, I will be curious in investigating it.\n\nTo get the example I am thinking about you need to merge in #21254 and #19538.\nThen\n\n```\nsage: A = ClusterAlgebra(['E',8])\nsage: %time A.explore_to_depth(infinity)\nCPU times: user 27.1 s, sys: 215 ms, total: 27.3 s\nWall time: 27.2 s\n```\nand\n\n```\nsage: A = ClusterAlgebra(['E',8])\nsage: seeds = RecursivelyEnumeratedSet([A.initial_seed()], lambda S:\n[S.mutate(i,inplace=False) for i in range(8)], structure='symmetric')\nsage: %time  len(list(seeds))\nCPU times: user 54.1 s, sys: 68 ms, total: 54.1 s\nWall time: 54.1 s\n25080\n```\n(you need to recreate `A` because it keeps track of few computationally\nintense bits).\n\nThe speedup I get, I think, depend mostly on line 1961 and partly on line 1968\nof cluster_algebra.py. The first makes sure that once an edge is known we do not\nwalk it twice, the second enforces the fact that we only need to walk three\nsides of a square.",
    "created_at": "2016-08-23T13:23:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311624",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:9" align="right">comment:9</div>

> On a related topic: in my usual testing example I get a major slowdown
> > If you can provide a working example illustrating this, I will be curious in investigating it.

To get the example I am thinking about you need to merge in #21254 and #19538.
Then

```
sage: A = ClusterAlgebra(['E',8])
sage: %time A.explore_to_depth(infinity)
CPU times: user 27.1 s, sys: 215 ms, total: 27.3 s
Wall time: 27.2 s
```
and

```
sage: A = ClusterAlgebra(['E',8])
sage: seeds = RecursivelyEnumeratedSet([A.initial_seed()], lambda S:
[S.mutate(i,inplace=False) for i in range(8)], structure='symmetric')
sage: %time  len(list(seeds))
CPU times: user 54.1 s, sys: 68 ms, total: 54.1 s
Wall time: 54.1 s
25080
```
(you need to recreate `A` because it keeps track of few computationally
intense bits).

The speedup I get, I think, depend mostly on line 1961 and partly on line 1968
of cluster_algebra.py. The first makes sure that once an edge is known we do not
walk it twice, the second enforces the fact that we only need to walk three
sides of a square.



---

archive/issue_comments_311625.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\n> The speedup I get, I think, depend mostly on line 1961 and partly on line 1968\n> of cluster_algebra.py. The first makes sure that once an edge is known we do not\n> walk it twice, the second enforces the fact that we only need to walk three\n> sides of a square.\n\nIn my experience, this kind of thing can be done by adding information into the nodes:\n\n```\nA = ClusterAlgebra(['E',8])\ninitial_node = tuple(A.initial_seed(), -1)\ninitial_nodes = [initial_node]\ndef succ(node):\n    S, i = node\n    allowed_directions = range(i+1, 8)\n    return [(S.mutate(j,inplace=False),j) for j in allowed_directions]\nseeds = RecursivelyEnumeratedSet(initial_nodes, succ, structure='symmetric')\n```\nThen `post_process` can return only the interesting part (at least now for forest, it works) of each node.\n\nBut I can't say if such an approach could work in your case.",
    "created_at": "2016-08-23T13:53:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311625",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:10" align="right">comment:10</div>

> The speedup I get, I think, depend mostly on line 1961 and partly on line 1968
> of cluster_algebra.py. The first makes sure that once an edge is known we do not
> walk it twice, the second enforces the fact that we only need to walk three
> sides of a square.

In my experience, this kind of thing can be done by adding information into the nodes:

```
A = ClusterAlgebra(['E',8])
initial_node = tuple(A.initial_seed(), -1)
initial_nodes = [initial_node]
def succ(node):
    S, i = node
    allowed_directions = range(i+1, 8)
    return [(S.mutate(j,inplace=False),j) for j in allowed_directions]
seeds = RecursivelyEnumeratedSet(initial_nodes, succ, structure='symmetric')
```
Then `post_process` can return only the interesting part (at least now for forest, it works) of each node.

But I can't say if such an approach could work in your case.



---

archive/issue_comments_311626.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\n> The speedup I get, I think, depend mostly on line 1961 and partly on line 1968\n> of cluster_algebra.py. The first makes sure that once an edge is known we do not\n> walk it twice, the second enforces the fact that we only need to walk three\n> sides of a square.\n\nThe speedup seems to be very close to a factor of 2.\n\n```\nsage: table([\"E8(yours) E6 E7 E8\".split(),[54.1/27.2, 2.97/1.59, 19.2/9.57, 143./72]])\n  E8(yours)          E6                 E7                 E8\n  1.98897058823529   1.86792452830189   2.00626959247649   1.98611111111111\n```\n\nI would guess this is not a coincidence... I still do not see how lines 1961 or 1968 give a improvement by a factor of 2 ?",
    "created_at": "2016-08-23T19:58:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311626",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:11" align="right">comment:11</div>

> The speedup I get, I think, depend mostly on line 1961 and partly on line 1968
> of cluster_algebra.py. The first makes sure that once an edge is known we do not
> walk it twice, the second enforces the fact that we only need to walk three
> sides of a square.

The speedup seems to be very close to a factor of 2.

```
sage: table(["E8(yours) E6 E7 E8".split(),[54.1/27.2, 2.97/1.59, 19.2/9.57, 143./72]])
  E8(yours)          E6                 E7                 E8
  1.98897058823529   1.86792452830189   2.00626959247649   1.98611111111111
```

I would guess this is not a coincidence... I still do not see how lines 1961 or 1968 give a improvement by a factor of 2 ?



---

archive/issue_comments_311627.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nCan you try with my code but with line 1961 commented out and j!= i instead of j>i in line 1968?\nI think I ran this once for E8 and runtime almost doubled.",
    "created_at": "2016-08-23T22:49:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311627",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:12" align="right">comment:12</div>

Can you try with my code but with line 1961 commented out and j!= i instead of j>i in line 1968?
I think I ran this once for E8 and runtime almost doubled.



---

archive/issue_comments_311628.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nCommenting out line 1961 and changing line 1968 as you suggest makes `explore_to_depth` slower but not 2 times slower. With this change, using `RecursivelyEnumeratedSet` is about 15% slower :\n\n```python\nsage: from pandas import DataFrame\nsage: df = DataFrame(index=\"E6 E7 E8\".split())\nsage: df['explore_to_depth'] = [2.53, 15.8, 124.]\nsage: df['rec_enum_set'] = [2.91, 18.5, 141.]\nsage: df['ratio'] = df.rec_enum_set / df.explore_to_depth\nsage: df\n    explore_to_depth      rec_enum_set             ratio\nE6  2.53000000000000  2.91000000000000  1.15019762845850\nE7  15.8000000000000  18.5000000000000  1.17088607594937\nE8  124.000000000000  141.000000000000  1.13709677419355\n```\n\nAre there other hypothesis you are using on the structure of the graph?",
    "created_at": "2016-08-24T07:11:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311628",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:13" align="right">comment:13</div>

Commenting out line 1961 and changing line 1968 as you suggest makes `explore_to_depth` slower but not 2 times slower. With this change, using `RecursivelyEnumeratedSet` is about 15% slower :

```python
sage: from pandas import DataFrame
sage: df = DataFrame(index="E6 E7 E8".split())
sage: df['explore_to_depth'] = [2.53, 15.8, 124.]
sage: df['rec_enum_set'] = [2.91, 18.5, 141.]
sage: df['ratio'] = df.rec_enum_set / df.explore_to_depth
sage: df
    explore_to_depth      rec_enum_set             ratio
E6  2.53000000000000  2.91000000000000  1.15019762845850
E7  15.8000000000000  18.5000000000000  1.17088607594937
E8  124.000000000000  141.000000000000  1.13709677419355
```

Are there other hypothesis you are using on the structure of the graph?



---

archive/issue_comments_311629.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nI do not think I am using any other assumption.\n\nNote that the main loop I would write without using the assumptions above would be\n\n```\nwhile gets_bigger and depth_counter < kwargs.get('depth', infinity):\n     # remember if we got a new seed\n     gets_bigger = False\n\n     for key in clusters.keys():\n         sd, directions = clusters[key]\n         while directions:\n             # we can mutate in some direction\n             i = directions.pop()\n             new_sd  = sd.mutate(i, inplace=False, mutating_F=mutating_F)\n             new_cl = frozenset(new_sd.g_vectors())\n             if not new_cl in clusters:\n                 # we got a new seed\n                 gets_bigger = True\n                 # next round do not mutate back to sd and do commuting mutations only in directions j > i\n                 new_directions = [ j for j in allowed_dirs if j != i ]\n                 clusters[new_cl] = [ new_sd, new_directions ]\n                 yield new_sd\n     # we went one step deeper\n     depth_counter += 1\n```\nwhich should be slightly faster than the version you tested because it does not\nrun the useless line\n\n```\nj = map(tuple,clusters[new_cl][0].g_vectors()).index(new_sd.g_vector(i))\n```",
    "created_at": "2016-08-24T07:46:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311629",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:14" align="right">comment:14</div>

I do not think I am using any other assumption.

Note that the main loop I would write without using the assumptions above would be

```
while gets_bigger and depth_counter < kwargs.get('depth', infinity):
     # remember if we got a new seed
     gets_bigger = False

     for key in clusters.keys():
         sd, directions = clusters[key]
         while directions:
             # we can mutate in some direction
             i = directions.pop()
             new_sd  = sd.mutate(i, inplace=False, mutating_F=mutating_F)
             new_cl = frozenset(new_sd.g_vectors())
             if not new_cl in clusters:
                 # we got a new seed
                 gets_bigger = True
                 # next round do not mutate back to sd and do commuting mutations only in directions j > i
                 new_directions = [ j for j in allowed_dirs if j != i ]
                 clusters[new_cl] = [ new_sd, new_directions ]
                 yield new_sd
     # we went one step deeper
     depth_counter += 1
```
which should be slightly faster than the version you tested because it does not
run the useless line

```
j = map(tuple,clusters[new_cl][0].g_vectors()).index(new_sd.g_vector(i))
```



---

archive/issue_comments_311630.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nAh! I am not sure how `RecursivelyEnumeratedSet` does things but there is one\nlast assumption I am using:\nI know which is the last direction I walked to get to any vertex so at the next pass I am not travelling in that direction.",
    "created_at": "2016-08-24T07:56:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311630",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:15" align="right">comment:15</div>

Ah! I am not sure how `RecursivelyEnumeratedSet` does things but there is one
last assumption I am using:
I know which is the last direction I walked to get to any vertex so at the next pass I am not travelling in that direction.



---

archive/issue_comments_311631.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\n> which should be slightly faster than the version you tested because it does not run the \n> useless line `j = map(tuple,clusters[new_cl][0].g_vectors()).index(new_sd.g_vector(i))`\n\nI had already commented that line in my previous post, also since commenting only line 1961 gives a syntax error. The only difference with your suggestion was that I was using\n\n```python\nnew_directions = [ j for j in allowed_dirs if j != i or new_sd.b_matrix()[j,i] != 0 ]\n```\ninstead of\n\n```python\nnew_directions = [ j for j in allowed_dirs if j != i ]\n```\n\n\nReplying to [@etn40ff](#comment%3A15):\n> Ah! I am not sure how `RecursivelyEnumeratedSet` does things but there is one\n> last assumption I am using:\n> I know which is the last direction I walked to get to any vertex so at the next pass I am not travelling in that direction.\n\nAn hypothesis that we can't do right now inside the code of `RecursivelyEnumeratedSet` with symmetric structure since if `y in succ(x)`, then we can't assume that\n\n```python\nlist(succ(x)).index(y) == list(succ(y)).index(x)\n```\nAlso, the graph might not be k-regular (to make sure, that is the number of outgoing edges being constant).\n\nBut we can use that hypothesis in the `succ` function:\n\n```python\nsage: A = ClusterAlgebra(['E',6])\nsage: def succ(S):\n....:     p = S.path_from_initial_seed()\n....:     i = p[-1] if p else -1\n....:     return [S.mutate(j,inplace=False) for j in range(6) if j != i]\nsage: seeds = RecursivelyEnumeratedSet([A.initial_seed()], succ, structure='symmetric')\nsage: %time len(list(seeds))\nCPU times: user 2.69 s, sys: 200 ms, total: 2.89 s\nWall time: 2.75 s\n833\n```\n\nWith this new `succ` function and removing the part `or new_sd.b_matrix()[j,i] != 0`, the ratio become about 5% slower using `RecursivelyEnumeratedSet` :\n\n```python\nsage: from pandas import DataFrame\nsage: df = DataFrame(index=\"E6 E7 E8\".split())\nsage: df['explore_to_depth'] = [2.61, 16.1, 121.]\nsage: df['rec_enum_set'] = [2.75, 16.9, 128.]\nsage: df['ratio'] = df.rec_enum_set / df.explore_to_depth\nsage: df\n    explore_to_depth      rec_enum_set             ratio\nE6  2.61000000000000  2.75000000000000  1.05363984674330\nE7  16.1000000000000  16.9000000000000  1.04968944099379\nE8  121.000000000000  128.000000000000  1.05785123966942\n```",
    "created_at": "2016-08-24T19:38:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311631",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:16" align="right">comment:16</div>

> which should be slightly faster than the version you tested because it does not run the 
> useless line `j = map(tuple,clusters[new_cl][0].g_vectors()).index(new_sd.g_vector(i))`

I had already commented that line in my previous post, also since commenting only line 1961 gives a syntax error. The only difference with your suggestion was that I was using

```python
new_directions = [ j for j in allowed_dirs if j != i or new_sd.b_matrix()[j,i] != 0 ]
```
instead of

```python
new_directions = [ j for j in allowed_dirs if j != i ]
```


Replying to [@etn40ff](#comment%3A15):
> Ah! I am not sure how `RecursivelyEnumeratedSet` does things but there is one
> last assumption I am using:
> I know which is the last direction I walked to get to any vertex so at the next pass I am not travelling in that direction.

An hypothesis that we can't do right now inside the code of `RecursivelyEnumeratedSet` with symmetric structure since if `y in succ(x)`, then we can't assume that

```python
list(succ(x)).index(y) == list(succ(y)).index(x)
```
Also, the graph might not be k-regular (to make sure, that is the number of outgoing edges being constant).

But we can use that hypothesis in the `succ` function:

```python
sage: A = ClusterAlgebra(['E',6])
sage: def succ(S):
....:     p = S.path_from_initial_seed()
....:     i = p[-1] if p else -1
....:     return [S.mutate(j,inplace=False) for j in range(6) if j != i]
sage: seeds = RecursivelyEnumeratedSet([A.initial_seed()], succ, structure='symmetric')
sage: %time len(list(seeds))
CPU times: user 2.69 s, sys: 200 ms, total: 2.89 s
Wall time: 2.75 s
833
```

With this new `succ` function and removing the part `or new_sd.b_matrix()[j,i] != 0`, the ratio become about 5% slower using `RecursivelyEnumeratedSet` :

```python
sage: from pandas import DataFrame
sage: df = DataFrame(index="E6 E7 E8".split())
sage: df['explore_to_depth'] = [2.61, 16.1, 121.]
sage: df['rec_enum_set'] = [2.75, 16.9, 128.]
sage: df['ratio'] = df.rec_enum_set / df.explore_to_depth
sage: df
    explore_to_depth      rec_enum_set             ratio
E6  2.61000000000000  2.75000000000000  1.05363984674330
E7  16.1000000000000  16.9000000000000  1.04968944099379
E8  121.000000000000  128.000000000000  1.05785123966942
```



---

archive/issue_comments_311632.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nok 5% may depend on your code being more general or storing more info. I'd be happy to live with it. Now the problem is: how do I enforce the other two assumptions?\n\nPS: This ticket was meant to solve an issue and we are discussing something else. I guess we better leave this open till we are done.",
    "created_at": "2016-08-24T19:51:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311632",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:17" align="right">comment:17</div>

ok 5% may depend on your code being more general or storing more info. I'd be happy to live with it. Now the problem is: how do I enforce the other two assumptions?

PS: This ticket was meant to solve an issue and we are discussing something else. I guess we better leave this open till we are done.



---

archive/issue_comments_311633.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nMeanwhile, I was managed to use the second assumption (if I am not mistaken):\n\n```python\nsage: A = ClusterAlgebra(['E',8])\nsage: allowed_dirs = range(8)\nsage: def succ(S):\n....:     p = S.path_from_initial_seed()\n....:     if p:\n....:         i = p[-1]\n....:         L = []\n....:         for j in allowed_dirs:\n....:              new_sd = S.mutate(j, inplace=False)\n....:              if j > i or new_sd.b_matrix()[j,i] != 0:\n....:                  L.append(new_sd)\n....:         return L\n....:     else:\n....:         return [S.mutate(j,inplace=False) for j in allowed_dirs]\nsage: seeds = RecursivelyEnumeratedSet([A.initial_seed()], succ) # not symmetric anymore right?\n```\n\nbut I do not get any significant improvement compare to just avoid branches `j!=i` :\n\n```python\nsage: %time len(list(seeds))\nCPU times: user 2min 8s, sys: 605 ms, total: 2min 8s\nWall time: 2min 8s\n25080\n```\n\nwhich is the same (128 s) as above.",
    "created_at": "2016-08-24T20:18:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311633",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:18" align="right">comment:18</div>

Meanwhile, I was managed to use the second assumption (if I am not mistaken):

```python
sage: A = ClusterAlgebra(['E',8])
sage: allowed_dirs = range(8)
sage: def succ(S):
....:     p = S.path_from_initial_seed()
....:     if p:
....:         i = p[-1]
....:         L = []
....:         for j in allowed_dirs:
....:              new_sd = S.mutate(j, inplace=False)
....:              if j > i or new_sd.b_matrix()[j,i] != 0:
....:                  L.append(new_sd)
....:         return L
....:     else:
....:         return [S.mutate(j,inplace=False) for j in allowed_dirs]
sage: seeds = RecursivelyEnumeratedSet([A.initial_seed()], succ) # not symmetric anymore right?
```

but I do not get any significant improvement compare to just avoid branches `j!=i` :

```python
sage: %time len(list(seeds))
CPU times: user 2min 8s, sys: 605 ms, total: 2min 8s
Wall time: 2min 8s
25080
```

which is the same (128 s) as above.



---

archive/issue_comments_311634.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nReplying to [@etn40ff](#comment%3A17):\n> ok 5% may depend on your code being more general or storing more info. I'd be happy to live with it. Now the problem is: how do I enforce the other two assumptions?\n\nI don't know if we can make the first assumption cleanly into the function `succ` (difficult to understand line 1959), but maybe the Recursively Enumerated Set class can be changed (or copied and changed) so that  the [line](https://github.com/sagemath/sage/blob/master/src/sage/sets/recursively_enumerated_set.pyx#L1032) does: if `y in B` then change `y` so that we do not go to `x` when we visit `y`.\n\nWe should test if it works and if it is worth it, and if so, create a new ticket for it.\n\n> PS: This ticket was meant to solve an issue and we are discussing something else. I guess we better leave this open till we are done.\n\nI agree. I wait for a review of this ticket then:)",
    "created_at": "2016-08-24T21:00:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311634",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:19" align="right">comment:19</div>

Replying to [@etn40ff](#comment%3A17):
> ok 5% may depend on your code being more general or storing more info. I'd be happy to live with it. Now the problem is: how do I enforce the other two assumptions?

I don't know if we can make the first assumption cleanly into the function `succ` (difficult to understand line 1959), but maybe the Recursively Enumerated Set class can be changed (or copied and changed) so that  the [line](https://github.com/sagemath/sage/blob/master/src/sage/sets/recursively_enumerated_set.pyx#L1032) does: if `y in B` then change `y` so that we do not go to `x` when we visit `y`.

We should test if it works and if it is worth it, and if so, create a new ticket for it.

> PS: This ticket was meant to solve an issue and we are discussing something else. I guess we better leave this open till we are done.

I agree. I wait for a review of this ticket then:)



---

archive/issue_comments_311635.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nI had a look at the code and it seems good to me. I am waiting for sage to finish building before running `sage -t --long` to give a positive review.\n\nOn the other topic discussed in the comments of this ticket: I ended up keeping the implementation I had in #21254 with a `try` statement to catch `KeyboardIntterrupt`. At the moment it is faster and I do not have much time to refactor the code to use `RecursivelyEnumeratedSet`. I will probably leave this as a task for a future ticket.",
    "created_at": "2016-08-26T08:49:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311635",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:20" align="right">comment:20</div>

I had a look at the code and it seems good to me. I am waiting for sage to finish building before running `sage -t --long` to give a positive review.

On the other topic discussed in the comments of this ticket: I ended up keeping the implementation I had in #21254 with a `try` statement to catch `KeyboardIntterrupt`. At the moment it is faster and I do not have much time to refactor the code to use `RecursivelyEnumeratedSet`. I will probably leave this as a task for a future ticket.



---

archive/issue_comments_311636.json:
```json
{
    "body": "Author: **S\u00e9bastien Labb\u00e9**",
    "created_at": "2016-08-26T09:19:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311636",
    "user": "https://github.com/seblabbe"
}
```

Author: **Sébastien Labbé**



---

archive/issue_comments_311637.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nNo problem. `RecursivelyEnumeratedSet` should be fast so that people really want to use it. So your example raises good questions.",
    "created_at": "2016-08-26T09:19:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311637",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:21" align="right">comment:21</div>

No problem. `RecursivelyEnumeratedSet` should be fast so that people really want to use it. So your example raises good questions.



---

archive/issue_comments_311638.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nPositive review.\n\nIt does make sense for code such as #21254 to use `RecursivelyEnumeratedSet` just because it is useless to keep reinventing the wheel each time. Moreover it offers quite a lot of useful features. \n\nTwo consideration about speed: \n\n1) I guess there are several use cases in which the function `succ` is expensive but it is not too expensive, once a duplicate element has been found, to trim the directions in which `succ` is computed. This is the case, for example, of the code we discussed. It could be useful if `RecursivelyEnumeratedSet` could take a second function as input that is called each time a new element in the set is found and that takes care of pruning the search tree accordingly.\n\n2) how essential is the `'forest'` requirement to the parallelized map/reduce? The code we discussed could benefit much from this.",
    "created_at": "2016-08-26T13:26:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311638",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:22" align="right">comment:22</div>

Positive review.

It does make sense for code such as #21254 to use `RecursivelyEnumeratedSet` just because it is useless to keep reinventing the wheel each time. Moreover it offers quite a lot of useful features. 

Two consideration about speed: 

1) I guess there are several use cases in which the function `succ` is expensive but it is not too expensive, once a duplicate element has been found, to trim the directions in which `succ` is computed. This is the case, for example, of the code we discussed. It could be useful if `RecursivelyEnumeratedSet` could take a second function as input that is called each time a new element in the set is found and that takes care of pruning the search tree accordingly.

2) how essential is the `'forest'` requirement to the parallelized map/reduce? The code we discussed could benefit much from this.



---

archive/issue_comments_311639.json:
```json
{
    "body": "Reviewer: **Salvatore Stella**",
    "created_at": "2016-08-26T13:26:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311639",
    "user": "https://github.com/etn40ff"
}
```

Reviewer: **Salvatore Stella**



---

archive/issue_events_296858.json:
```json
{
    "actor": "https://github.com/etn40ff",
    "created_at": "2016-08-26T13:26:39Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296858"
}
```



---

archive/issue_events_296859.json:
```json
{
    "actor": "https://github.com/etn40ff",
    "created_at": "2016-08-26T13:26:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296859"
}
```



---

archive/issue_comments_311640.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nI will keep your comment 1) in mind for future evolvement of RecEnumSet.\n\n> 2) how essential is the `'forest'` requirement to the parallelized map/reduce? The code we discussed could benefit much from this.\n\nWell you can set `structure='forest'` and see what happens. You will get elements generated twice in different trees and the independant workers will assume their element is new and will continue their search pruning its successors. Depending on the case, you can get an iterator that never halts even if the graph is finite...\n\nTo adapt the parallel map reduce code to work on graphs that are not forest, some communication should be added between workers. But then, it becomes less easy to get efficient parallel computations. That question should be asked to Florent:\n\n  Could their be a common set of already known nodes that is shared among the workers so that they could know if they find a new node or not?",
    "created_at": "2016-08-26T15:16:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311640",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:23" align="right">comment:23</div>

I will keep your comment 1) in mind for future evolvement of RecEnumSet.

> 2) how essential is the `'forest'` requirement to the parallelized map/reduce? The code we discussed could benefit much from this.

Well you can set `structure='forest'` and see what happens. You will get elements generated twice in different trees and the independant workers will assume their element is new and will continue their search pruning its successors. Depending on the case, you can get an iterator that never halts even if the graph is finite...

To adapt the parallel map reduce code to work on graphs that are not forest, some communication should be added between workers. But then, it becomes less easy to get efficient parallel computations. That question should be asked to Florent:

  Could their be a common set of already known nodes that is shared among the workers so that they could know if they find a new node or not?



---

archive/issue_comments_311641.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\n> Well you can set structure='forest' and see what happens.\n\nNothing good: say your function is symmetric then it will continuously bounce in between two elements. If I am not mistaken `'forest'` does not check for already produced elements.",
    "created_at": "2016-08-26T15:36:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311641",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:24" align="right">comment:24</div>

> Well you can set structure='forest' and see what happens.

Nothing good: say your function is symmetric then it will continuously bounce in between two elements. If I am not mistaken `'forest'` does not check for already produced elements.



---

archive/issue_comments_311642.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nReplying to [@etn40ff](#comment%3A22):\n\n> 2) how essential is the `'forest'` requirement to the parallelized\n\n  map/reduce? The code we discussed could benefit much from this.\n\nIt is essential. I'm planning to write some analogous code for directed\nacyclic graph, but this need to completely rethink the algorithm. If I manage,\nthere certainly will be two independent codes for forests and DAGs. And there\nis a good change that the DAG code will be less efficient.\n\nUsing the forest hypothesis, a work stealing algorithm allows the perform the\ncomputation with minimal communications. This is crucial because in Python,\ncommunication are done interprocess through pickling, so that they are quite\nslow. For DAGs, you need a strategy to ensure that two differents processes\nare not computing the same nodes...",
    "created_at": "2016-08-26T22:47:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311642",
    "user": "https://github.com/hivert"
}
```

<div id="comment:25" align="right">comment:25</div>

Replying to [@etn40ff](#comment%3A22):

> 2) how essential is the `'forest'` requirement to the parallelized

  map/reduce? The code we discussed could benefit much from this.

It is essential. I'm planning to write some analogous code for directed
acyclic graph, but this need to completely rethink the algorithm. If I manage,
there certainly will be two independent codes for forests and DAGs. And there
is a good change that the DAG code will be less efficient.

Using the forest hypothesis, a work stealing algorithm allows the perform the
computation with minimal communications. This is crucial because in Python,
communication are done interprocess through pickling, so that they are quite
slow. For DAGs, you need a strategy to ensure that two differents processes
are not computing the same nodes...



---

archive/issue_events_296860.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-08-27T08:36:18Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296860"
}
```



---

archive/issue_events_296861.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "a21f6f48f1361d63e953060899a8e341c42136d6",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2016-08-27T08:36:18Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/21312#event-296861"
}
```



---

archive/issue_comments_311643.json:
```json
{
    "body": "Changed branch from **[u/slabbe/21312](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/21312)** to **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)**",
    "created_at": "2016-08-27T08:36:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311643",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[u/slabbe/21312](https://github.com/sagemath/sagetrac-mirror/tree/u/slabbe/21312)** to **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)**



---

archive/issue_comments_311644.json:
```json
{
    "body": "Changed commit from **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)** to none",
    "created_at": "2016-08-27T16:59:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311644",
    "user": "https://github.com/etn40ff"
}
```

Changed commit from **[`6634754`](https://github.com/sagemath/sagetrac-mirror/commit/6634754063f50147ed813b34a4f822f3b616945a)** to none



---

archive/issue_comments_311645.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nReplying to [@hivert](#comment%3A25):\n> This is crucial because in Python,\n> communication are done interprocess through pickling, so that they are quite\n> slow.\n\nThat's a bummer! I am not sure DAGs would could be used in my case either.\n\nOne stray thought: can you use hashes for communication rather than the whole objects? You could get some mileage from the fact that you will be pickling a smaller amount of data.",
    "created_at": "2016-08-27T16:59:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/21312",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/21312#issuecomment-311645",
    "user": "https://github.com/etn40ff"
}
```

<div id="comment:27" align="right">comment:27</div>

Replying to [@hivert](#comment%3A25):
> This is crucial because in Python,
> communication are done interprocess through pickling, so that they are quite
> slow.

That's a bummer! I am not sure DAGs would could be used in my case either.

One stray thought: can you use hashes for communication rather than the whole objects? You could get some mileage from the fact that you will be pickling a smaller amount of data.
