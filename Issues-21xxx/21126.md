# Issue 21126: Twisting in tensor products

archive/issues_021126.json:
```json
{
    "body": "CC:  @tscrim @jhpalmieri @nthiery @darijgr\n\nKeywords: tensor product, cohomology\n\nThe tensor product of cohomology rings of product of two spaces is twisted in the following sense:\n\n(a \u2297 b) \u2323 (c \u2297 d) = (-1)<sup>|b|\u00b7|c|</sup>(a \u2323 c)\u2297(b \u2323 d)\n\nHowever there is no way to inform sage of this twisting at the moment:\n\n```\nS_2 = delta_complexes.SurfaceOfGenus(2);\nH = S_2.cohomology_ring(QQ);\nH2 = tensor([H,H]); \n```\nIn H2 the multiplication is the non-twisted one.\n\nmaybe tensor([H,H], twisted=True) could be introduced.\n\nIssue created by migration from https://trac.sagemath.org/ticket/21363\n\n",
    "created_at": "2016-08-29T16:01:11Z",
    "labels": [
        "component: algebraic topology",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.4",
    "title": "Twisting in tensor products",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21126",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```
CC:  @tscrim @jhpalmieri @nthiery @darijgr

Keywords: tensor product, cohomology

The tensor product of cohomology rings of product of two spaces is twisted in the following sense:

(a ⊗ b) ⌣ (c ⊗ d) = (-1)<sup>|b|·|c|</sup>(a ⌣ c)⊗(b ⌣ d)

However there is no way to inform sage of this twisting at the moment:

```
S_2 = delta_complexes.SurfaceOfGenus(2);
H = S_2.cohomology_ring(QQ);
H2 = tensor([H,H]); 
```
In H2 the multiplication is the non-twisted one.

maybe tensor([H,H], twisted=True) could be introduced.

Issue created by migration from https://trac.sagemath.org/ticket/21363





---

archive/issue_comments_292388.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2016-08-29T16:42:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292388",
    "user": "https://github.com/tscrim"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_292389.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to algebraic topology.",
    "created_at": "2016-08-29T16:42:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292389",
    "user": "https://github.com/tscrim"
}
```

Changing component from PLEASE CHANGE to algebraic topology.



---

archive/issue_comments_292390.json:
```json
{
    "body": "So for this, the tensor creates an instance of `sage.combinat.free_module.CombinatorialFreeModule_Tensor`, which is in the category\n\n```sage\nsage: H2.category()\nCategory of finite dimensional tensor products of algebras with basis over Rational Field\n```\nNow the easiest way out would be creating a class for the tensor product of two homology spaces (which could be something we might want anyways) that inherits from `CombinatorialFreeModule_Tensor` and overrides `product_on_basis` (which comes from the category).\n\nAnother approach that is more work, but much more gratifying (and something we need to do) is changing around the categories. In particular, from Hatcher, the cohomology over a commutative ring is a commutative superalgebra. So we would need to change its category:\n\n```sage\nsage: H.category()\nCategory of finite dimensional graded algebras with basis over Rational Field\n```\nThen we would need to create a category of tensor products of commutative superalgebras with a default (twisted) multiplication.\n\nI'm more for doing option 2, but it could have some technical issues that we might have to work through as well. I'll leave the choice up to you.",
    "created_at": "2016-08-29T16:42:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292390",
    "user": "https://github.com/tscrim"
}
```

So for this, the tensor creates an instance of `sage.combinat.free_module.CombinatorialFreeModule_Tensor`, which is in the category

```sage
sage: H2.category()
Category of finite dimensional tensor products of algebras with basis over Rational Field
```
Now the easiest way out would be creating a class for the tensor product of two homology spaces (which could be something we might want anyways) that inherits from `CombinatorialFreeModule_Tensor` and overrides `product_on_basis` (which comes from the category).

Another approach that is more work, but much more gratifying (and something we need to do) is changing around the categories. In particular, from Hatcher, the cohomology over a commutative ring is a commutative superalgebra. So we would need to change its category:

```sage
sage: H.category()
Category of finite dimensional graded algebras with basis over Rational Field
```
Then we would need to create a category of tensor products of commutative superalgebras with a default (twisted) multiplication.

I'm more for doing option 2, but it could have some technical issues that we might have to work through as well. I'll leave the choice up to you.



---

archive/issue_comments_292391.json:
```json
{
    "body": "Ok, I'm fine with both ways (the second seems more future proof, so that would be my personal choice).\n\nThe only problem is that I have very little idea about sage type theory... err.. the categorical background behind sage objects ;-)\n\nlooking at superalgebras definition (acutally never heard of) Clifford algebras are also the natural examples.\n\nSo: where can I learn about category structures as implemented in sage?",
    "created_at": "2016-08-29T17:05:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292391",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

Ok, I'm fine with both ways (the second seems more future proof, so that would be my personal choice).

The only problem is that I have very little idea about sage type theory... err.. the categorical background behind sage objects ;-)

looking at superalgebras definition (acutally never heard of) Clifford algebras are also the natural examples.

So: where can I learn about category structures as implemented in sage?



---

archive/issue_comments_292392.json:
```json
{
    "body": "Replying to [comment:2 kalmar]:\n> Ok, I'm fine with both ways (the second seems more future proof, so that would be my personal choice).\n> \n> The only problem is that I have very little idea about sage type theory... err.. the categorical background behind sage objects ;-)\n\n>\n> So: where can I learn about category structures as implemented in sage?\n\n\nIn the `src/sage/categories/` folder is where the source code is. There's a detailed description of Sage's category framework [here](http://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html). [Simon King's tutorial](http://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html) is more on creating parents and elements, so doesn't quite apply.\n\nOne of the easiest ways to start working on this would be to copy code from elsewhere in Sage. I would probably mimic what is done in `sage/categories/algebras.py` first (don't forget to also add the imports).\n\n> looking at superalgebras definition (acutally never heard of) Clifford algebras are also the natural examples.\n\n\nYes, Clifford algebras are the standard examples of superalgebras. Exterior algebras (which are a special case of Clifford algebras) and their generalizations of C(D)GA (Commutative (Differential) Graded Algebras) are also another class of good examples.",
    "created_at": "2016-08-29T17:34:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292392",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:2 kalmar]:
> Ok, I'm fine with both ways (the second seems more future proof, so that would be my personal choice).
> 
> The only problem is that I have very little idea about sage type theory... err.. the categorical background behind sage objects ;-)

>
> So: where can I learn about category structures as implemented in sage?


In the `src/sage/categories/` folder is where the source code is. There's a detailed description of Sage's category framework [here](http://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html). [Simon King's tutorial](http://doc.sagemath.org/html/en/thematic_tutorials/coercion_and_categories.html) is more on creating parents and elements, so doesn't quite apply.

One of the easiest ways to start working on this would be to copy code from elsewhere in Sage. I would probably mimic what is done in `sage/categories/algebras.py` first (don't forget to also add the imports).

> looking at superalgebras definition (acutally never heard of) Clifford algebras are also the natural examples.


Yes, Clifford algebras are the standard examples of superalgebras. Exterior algebras (which are a special case of Clifford algebras) and their generalizations of C(D)GA (Commutative (Differential) Graded Algebras) are also another class of good examples.



---

archive/issue_comments_292393.json:
```json
{
    "body": "Sorry that I dropped, I had shit-load of work on other projects (I still do, but I'm sick of them);\n\nI see (in master) that You did introduced code for SuperAlgebras and SuperModules;\n\nIf I still want to work on the thing, is there something I can help?",
    "created_at": "2016-10-09T10:44:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292393",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

Sorry that I dropped, I had shit-load of work on other projects (I still do, but I'm sick of them);

I see (in master) that You did introduced code for SuperAlgebras and SuperModules;

If I still want to work on the thing, is there something I can help?



---

archive/issue_comments_292394.json:
```json
{
    "body": "The first thing we need to do is put the cohomology ring in the category of graded commutative superalgebras (we currently have a restricting the base ring is a field). The second would be implementing a category of `TensorProducts` for superalgebras with a `product_on_basis` method analogous for that of `AlgebrasWithBasis` in `SuperalgebrasWithBasis`.",
    "created_at": "2016-10-09T13:46:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292394",
    "user": "https://github.com/tscrim"
}
```

The first thing we need to do is put the cohomology ring in the category of graded commutative superalgebras (we currently have a restricting the base ring is a field). The second would be implementing a category of `TensorProducts` for superalgebras with a `product_on_basis` method analogous for that of `AlgebrasWithBasis` in `SuperalgebrasWithBasis`.



---

archive/issue_comments_292395.json:
```json
{
    "body": "It looks that it would be nice to have `SuperAlgebrasWithBasis.example()`;\n\nAlso I think something should be put to cohomology documentation as a (test case?)\nthat the tensor-product of cohomologies (e.g. H\u00b9(S\u00b9)\u2297H\u00b9(S\u00b9)) respects the anticommutativity present in (i.e. H\u00b9(S\u00b9\u00d7S\u00b9)).\n\nWhat do You think?\n\n\nBelow is the very first try; For now without any docs.\n\nPutting cohomology rings in the category of graded commutative superalgebras:\n\n```diff\ndiff --git a/src/sage/homology/homology_vector_space_with_basis.py b/src/sage/homology/homology_vector_space_with_basis.py\nindex 3835e13..17597bc 100644\n--- a/src/sage/homology/homology_vector_space_with_basis.py\n+++ b/src/sage/homology/homology_vector_space_with_basis.py\n@@ -435,7 +435,7 @@ class CohomologyRing(HomologyVectorSpaceWithBasis):\n             sage: H = RP2.cohomology_ring(GF(5))\n             sage: TestSuite(H).run()\n         \"\"\"\n-        cat = Algebras(base_ring).WithBasis().Graded().FiniteDimensional()\n+        cat = Superalgebras(base_ring).WithBasis().Graded().FiniteDimensional()\n         HomologyVectorSpaceWithBasis.__init__(self, base_ring, cell_complex, True, cat)\n \n     def _repr_(self):\n```\n\nFor the second:\n\n```diff\ndiff --git a/src/sage/categories/super_algebras_with_basis.py b/src/sage/categories/super_algebras_with_basis.py\nindex 9a4a1bc..198ec04 100644\n--- a/src/sage/categories/super_algebras_with_basis.py\n+++ b/src/sage/categories/super_algebras_with_basis.py\n@@ -59,3 +59,22 @@ class SuperAlgebrasWithBasis(SuperModulesCategory):\n             from sage.algebras.associated_graded import AssociatedGradedAlgebra\n             return AssociatedGradedAlgebra(self)\n \n+        class TensorProducts(TensorProductsCategory):\n+        \"\"\"\n+        The category of superalgebras with basis constructed by tensor product of superalgebras with basis\n+        \"\"\"\n+\n+        class ParentMethods:\n+            \"\"\"\n+            implements operations on tensor products of superalgebras with basis\n+            \"\"\"\n+\n+            def product_on_basis(self, t1, t2):\n+                \"\"\"\n+                The product of the superalgebra on the basis, as per\n+                ``SuperalgebrasWithBasis.ParentMethods.product_on_basis``.\n+                \"\"\"\n+\n+                l = (module.monomial(x1)*module.monomial(x2) for (module, x1, x2) in zip(self._sets, t1, t2))\n+\n+                return (-1)^(x1.degree()*x2.degree())*tensor(l)\n```",
    "created_at": "2016-10-10T14:19:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292395",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

It looks that it would be nice to have `SuperAlgebrasWithBasis.example()`;

Also I think something should be put to cohomology documentation as a (test case?)
that the tensor-product of cohomologies (e.g. H¹(S¹)⊗H¹(S¹)) respects the anticommutativity present in (i.e. H¹(S¹×S¹)).

What do You think?


Below is the very first try; For now without any docs.

Putting cohomology rings in the category of graded commutative superalgebras:

```diff
diff --git a/src/sage/homology/homology_vector_space_with_basis.py b/src/sage/homology/homology_vector_space_with_basis.py
index 3835e13..17597bc 100644
--- a/src/sage/homology/homology_vector_space_with_basis.py
+++ b/src/sage/homology/homology_vector_space_with_basis.py
@@ -435,7 +435,7 @@ class CohomologyRing(HomologyVectorSpaceWithBasis):
             sage: H = RP2.cohomology_ring(GF(5))
             sage: TestSuite(H).run()
         """
-        cat = Algebras(base_ring).WithBasis().Graded().FiniteDimensional()
+        cat = Superalgebras(base_ring).WithBasis().Graded().FiniteDimensional()
         HomologyVectorSpaceWithBasis.__init__(self, base_ring, cell_complex, True, cat)
 
     def _repr_(self):
```

For the second:

```diff
diff --git a/src/sage/categories/super_algebras_with_basis.py b/src/sage/categories/super_algebras_with_basis.py
index 9a4a1bc..198ec04 100644
--- a/src/sage/categories/super_algebras_with_basis.py
+++ b/src/sage/categories/super_algebras_with_basis.py
@@ -59,3 +59,22 @@ class SuperAlgebrasWithBasis(SuperModulesCategory):
             from sage.algebras.associated_graded import AssociatedGradedAlgebra
             return AssociatedGradedAlgebra(self)
 
+        class TensorProducts(TensorProductsCategory):
+        """
+        The category of superalgebras with basis constructed by tensor product of superalgebras with basis
+        """
+
+        class ParentMethods:
+            """
+            implements operations on tensor products of superalgebras with basis
+            """
+
+            def product_on_basis(self, t1, t2):
+                """
+                The product of the superalgebra on the basis, as per
+                ``SuperalgebrasWithBasis.ParentMethods.product_on_basis``.
+                """
+
+                l = (module.monomial(x1)*module.monomial(x2) for (module, x1, x2) in zip(self._sets, t1, t2))
+
+                return (-1)^(x1.degree()*x2.degree())*tensor(l)
```



---

archive/issue_comments_292396.json:
```json
{
    "body": "The second looks good, but for the first, you should also add `.Commutative()`.\n\n> It looks that it would be nice to have SuperAlgebrasWithBasis.example();\n\n\nI think having a `Superalgebras(R).example()` should be done as a separate ticket (but +1 to doing it).\n\n> Also I think something should be put to cohomology documentation as a (test case?) that the tensor-product of cohomologies (e.g. H\u00b9(S\u00b9)\u2297H\u00b9(S\u00b9)) respects the anticommutativity present in (i.e. H\u00b9(S\u00b9\u00d7S\u00b9)). \n\n\n+1 to adding such an example to the cohomology ring doc.",
    "created_at": "2016-10-10T14:31:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292396",
    "user": "https://github.com/tscrim"
}
```

The second looks good, but for the first, you should also add `.Commutative()`.

> It looks that it would be nice to have SuperAlgebrasWithBasis.example();


I think having a `Superalgebras(R).example()` should be done as a separate ticket (but +1 to doing it).

> Also I think something should be put to cohomology documentation as a (test case?) that the tensor-product of cohomologies (e.g. H¹(S¹)⊗H¹(S¹)) respects the anticommutativity present in (i.e. H¹(S¹×S¹)). 


+1 to adding such an example to the cohomology ring doc.



---

archive/issue_comments_292397.json:
```json
{
    "body": "Then why is Commutative commented from axiom_whitelist in `super_modules.py`?\n\nI know it is a matter of convention (CDGAs are commutative, where we mean graded anitcommutativity, etc.), so what does actually the axiom_list mean?\n\nDoes Algebras(R).Commutative() mean something else than Algebras(R).Graded().Commutative() (as it should?) Where can one find out?",
    "created_at": "2016-10-10T15:04:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292397",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

Then why is Commutative commented from axiom_whitelist in `super_modules.py`?

I know it is a matter of convention (CDGAs are commutative, where we mean graded anitcommutativity, etc.), so what does actually the axiom_list mean?

Does Algebras(R).Commutative() mean something else than Algebras(R).Graded().Commutative() (as it should?) Where can one find out?



---

archive/issue_comments_292398.json:
```json
{
    "body": "We do not want to automatically pass commutativity for precisely the reason you mentioned (although replace `Graded()` by `Super()`): the forgetful functor from superalgebras to algebras does not preserve the commutative axiom. It makes it so that if you really meant a commutative superalgebra, you must do `Algebras(R).Super().Commutative()`, not `Algebras(R).Commutative().Super()` (did you want it to be commutative as an algebra or as a superalgebra?).",
    "created_at": "2016-10-10T15:10:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292398",
    "user": "https://github.com/tscrim"
}
```

We do not want to automatically pass commutativity for precisely the reason you mentioned (although replace `Graded()` by `Super()`): the forgetful functor from superalgebras to algebras does not preserve the commutative axiom. It makes it so that if you really meant a commutative superalgebra, you must do `Algebras(R).Super().Commutative()`, not `Algebras(R).Commutative().Super()` (did you want it to be commutative as an algebra or as a superalgebra?).



---

archive/issue_comments_292399.json:
```json
{
    "body": "ok, thanks;\n\nMaybe the last question before I sit back to work:\n* `CohomologyRing` now became `Superalgebras(base_ring).WithBasis().Graded().FiniteDimensional().Commutative()`\nHowever `Superalgebras.extra_super_categories()` returns `Graded()` as well. Isn't then `.Graded()` in the list above superfluous (as already implied by `Superalgebras`)?",
    "created_at": "2016-10-10T15:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292399",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

ok, thanks;

Maybe the last question before I sit back to work:
* `CohomologyRing` now became `Superalgebras(base_ring).WithBasis().Graded().FiniteDimensional().Commutative()`
However `Superalgebras.extra_super_categories()` returns `Graded()` as well. Isn't then `.Graded()` in the list above superfluous (as already implied by `Superalgebras`)?



---

archive/issue_comments_292400.json:
```json
{
    "body": "You are correct, it is superfluous. However, it gives a visual cue to anyone looking at the code that the grading we want is not the (natural) **Z**<sub>2</sub> grading.",
    "created_at": "2016-10-10T16:20:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292400",
    "user": "https://github.com/tscrim"
}
```

You are correct, it is superfluous. However, it gives a visual cue to anyone looking at the code that the grading we want is not the (natural) **Z**<sub>2</sub> grading.



---

archive/issue_comments_292401.json:
```json
{
    "body": "Ok, I'm struggling with yet another problem:\n\nTo confirm that cohomology rings are recognized as super:\n\n```\nsage: S_2 = delta_complexes.SurfaceOfGenus(1);\nsage: H = S_2.cohomology_ring();\nsage: H.category()\nJoin of \nCategory of graded algebras with basis over Rational Field and \nCategory of finite dimensional algebras with basis over Rational Field and \nCategory of super algebras over Rational Field and \nCategory of commutative algebras over Rational Field\n```\n\nYet tensor product of those is not a super algebra (I also checked `.categories()`:\n\n```\nsage: H2 = H.tensor(H);\nsage: H2.category()\nCategory of finite dimensional tensor products of algebras with basis over Rational Field\n```\n\nI thought it's enough to add \n\n```\ndef extra_super_categories(self):\n    return [self.base_category()]\n\n```\nto `SuperAlgebrasWithBasis.TensorProducts`, to make sage recognize tensor product of super algebras as a super algebra. It does so on the category level:\n\n```\nsage: SuperAlgebrasWithBasis(QQ).TensorProducts().super_categories()\n[Category of super algebras with basis over Rational Field,\n Category of tensor products of algebras with basis over Rational Field]\n```\n\nCool. Yet the example as above still fails to live up to category of super algebras;\nI also checked that `H2.product_on_basis` points to the method from the category of algebras;\n\nWhat am I missing??",
    "created_at": "2016-10-10T21:42:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292401",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

Ok, I'm struggling with yet another problem:

To confirm that cohomology rings are recognized as super:

```
sage: S_2 = delta_complexes.SurfaceOfGenus(1);
sage: H = S_2.cohomology_ring();
sage: H.category()
Join of 
Category of graded algebras with basis over Rational Field and 
Category of finite dimensional algebras with basis over Rational Field and 
Category of super algebras over Rational Field and 
Category of commutative algebras over Rational Field
```

Yet tensor product of those is not a super algebra (I also checked `.categories()`:

```
sage: H2 = H.tensor(H);
sage: H2.category()
Category of finite dimensional tensor products of algebras with basis over Rational Field
```

I thought it's enough to add 

```
def extra_super_categories(self):
    return [self.base_category()]

```
to `SuperAlgebrasWithBasis.TensorProducts`, to make sage recognize tensor product of super algebras as a super algebra. It does so on the category level:

```
sage: SuperAlgebrasWithBasis(QQ).TensorProducts().super_categories()
[Category of super algebras with basis over Rational Field,
 Category of tensor products of algebras with basis over Rational Field]
```

Cool. Yet the example as above still fails to live up to category of super algebras;
I also checked that `H2.product_on_basis` points to the method from the category of algebras;

What am I missing??



---

archive/issue_comments_292402.json:
```json
{
    "body": "There are subtleties with the `WithBasis` and `Graded` constructions:\n\n```\nsage: type(Algebras(QQ).WithBasis().Graded())\n<class 'sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis_with_category'>\nsage: type(Algebras(QQ).Graded().WithBasis())\n<class 'sage.categories.category.JoinCategory_with_category'>\n```\nThe former is the correct order: algebras that have a distinguished basis and that basis is graded (the other is algebras that are graded that have a distinguished basis, not necessarily graded). So, the order of `Super().WithBasis().Graded()` is correct and the `Graded()` is actually not superfluous on second thought.\n\nWhat we probably need to do is create a little stub category like `GradedSuperalgebrasWithBasis` similar to `GradedAlgebrasWithBasis`. We probably also need an another `CategoryWithAxiom` called `Commutative` of `Superalgebras`(`WithBasis`). I can take care of this if you want me to (if so, please push your current branch so I can work off of that).",
    "created_at": "2016-10-11T13:58:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292402",
    "user": "https://github.com/tscrim"
}
```

There are subtleties with the `WithBasis` and `Graded` constructions:

```
sage: type(Algebras(QQ).WithBasis().Graded())
<class 'sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis_with_category'>
sage: type(Algebras(QQ).Graded().WithBasis())
<class 'sage.categories.category.JoinCategory_with_category'>
```
The former is the correct order: algebras that have a distinguished basis and that basis is graded (the other is algebras that are graded that have a distinguished basis, not necessarily graded). So, the order of `Super().WithBasis().Graded()` is correct and the `Graded()` is actually not superfluous on second thought.

What we probably need to do is create a little stub category like `GradedSuperalgebrasWithBasis` similar to `GradedAlgebrasWithBasis`. We probably also need an another `CategoryWithAxiom` called `Commutative` of `Superalgebras`(`WithBasis`). I can take care of this if you want me to (if so, please push your current branch so I can work off of that).



---

archive/issue_comments_292403.json:
```json
{
    "body": "I would be happy to learn more the category framework, by doing this on my own.\nI have to say that [the primer](http://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html) is well, a (draft of) primer, i.e. not very informative e.g. for the task of implementing Your own category.\n\nGraded-non-Graded.\n\nYep, I understand this distinction, but constructor of `SuperAlgebrasWithBasis` actually adds `.Graded()` to categories (in `.extra_super_categories`). What then this `.Graded()` in `.extra_super_categories` mean??\n\nI also wanted to ask this, but thought this is particularly stupid question:\nI noticed that `SuperAlgebrasWithBasis` inherit from `SuperModulesCategory`, whereas \n`AlgebrasWithBasis` inherit from `CategoryWithAxiom_over_base_ring`. Is this related to Your second paragraph (which I don't quite comprehend right now)?",
    "created_at": "2016-10-11T16:43:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292403",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

I would be happy to learn more the category framework, by doing this on my own.
I have to say that [the primer](http://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html) is well, a (draft of) primer, i.e. not very informative e.g. for the task of implementing Your own category.

Graded-non-Graded.

Yep, I understand this distinction, but constructor of `SuperAlgebrasWithBasis` actually adds `.Graded()` to categories (in `.extra_super_categories`). What then this `.Graded()` in `.extra_super_categories` mean??

I also wanted to ask this, but thought this is particularly stupid question:
I noticed that `SuperAlgebrasWithBasis` inherit from `SuperModulesCategory`, whereas 
`AlgebrasWithBasis` inherit from `CategoryWithAxiom_over_base_ring`. Is this related to Your second paragraph (which I don't quite comprehend right now)?



---

archive/issue_comments_292404.json:
```json
{
    "body": "Replying to [comment:14 kalmar]:\n> I would be happy to learn more the category framework, by doing this on my own.\n> I have to say that [the primer](http://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html) is well, a (draft of) primer, i.e. not very informative e.g. for the task of implementing Your own category.\n\n\nWell, to be fair, this is a much more challenging example of a category construction.\n\n> Graded-non-Graded.\n> \n> Yep, I understand this distinction, but constructor of `SuperAlgebrasWithBasis` actually adds `.Graded()` to categories (in `.extra_super_categories`). What then this `.Graded()` in `.extra_super_categories` mean??\n\n\nIt means every superalgebra with basis is (naturally) a graded algebra with basis.\n\n> I also wanted to ask this, but thought this is particularly stupid question:\n> I noticed that `SuperAlgebrasWithBasis` inherit from `SuperModulesCategory`, whereas \n> `AlgebrasWithBasis` inherit from `CategoryWithAxiom_over_base_ring`. Is this related to Your second paragraph (which I don't quite comprehend right now)?\n\n\nThat is because we construct a super algebra from an algebra via a functorial construction (i.e., adding the grading), whereas an algebra is a concrete category created by imposing axioms. It is related to the second paragraph, and is the reasoning why we need a stub category (at least, for the code).",
    "created_at": "2016-10-11T17:02:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292404",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:14 kalmar]:
> I would be happy to learn more the category framework, by doing this on my own.
> I have to say that [the primer](http://doc.sagemath.org/html/en/reference/categories/sage/categories/primer.html) is well, a (draft of) primer, i.e. not very informative e.g. for the task of implementing Your own category.


Well, to be fair, this is a much more challenging example of a category construction.

> Graded-non-Graded.
> 
> Yep, I understand this distinction, but constructor of `SuperAlgebrasWithBasis` actually adds `.Graded()` to categories (in `.extra_super_categories`). What then this `.Graded()` in `.extra_super_categories` mean??


It means every superalgebra with basis is (naturally) a graded algebra with basis.

> I also wanted to ask this, but thought this is particularly stupid question:
> I noticed that `SuperAlgebrasWithBasis` inherit from `SuperModulesCategory`, whereas 
> `AlgebrasWithBasis` inherit from `CategoryWithAxiom_over_base_ring`. Is this related to Your second paragraph (which I don't quite comprehend right now)?


That is because we construct a super algebra from an algebra via a functorial construction (i.e., adding the grading), whereas an algebra is a concrete category created by imposing axioms. It is related to the second paragraph, and is the reasoning why we need a stub category (at least, for the code).



---

archive/issue_comments_292405.json:
```json
{
    "body": "Ok, just for future readers:\n\n[This](http://doc.sagemath.org/html/en/reference/categories/sage/categories/category_with_axiom.html) is a much better resource for learning the category framework.\n\n---\nNew commits:",
    "created_at": "2016-10-13T20:20:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292405",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

Ok, just for future readers:

[This](http://doc.sagemath.org/html/en/reference/categories/sage/categories/category_with_axiom.html) is a much better resource for learning the category framework.

---
New commits:



---

archive/issue_comments_292406.json:
```json
{
    "body": "Yes, sorry for not posting that link (I mixed it up with the primer while I was running around with my busy past week). Let me know if you come across any other problems or when you're ready for me to take a look at (part of) things.",
    "created_at": "2016-10-15T18:56:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292406",
    "user": "https://github.com/tscrim"
}
```

Yes, sorry for not posting that link (I mixed it up with the primer while I was running around with my busy past week). Let me know if you come across any other problems or when you're ready for me to take a look at (part of) things.



---

archive/issue_comments_292407.json:
```json
{
    "body": "If I understand Correctly I have to implement `GradedSuperAlgebrasWithBasis` as an object of `GradedSuperModulesCategory` which then should be object of the join of (I mean inherit from both of) (`Regressive`?)`CovariantConstructionCategory` and `Category_over_base_ring`?\n\nIf we have this I need to \n\n* add `Commutative` axiom to both `SuperAlgebras` and `SuperAlgebrasWithBasis`, so that (deconstructing call creating cohomology ring) `SuperAlgebras(base_ring).WithBasis().Graded().FiniteDimensional().Commutative()` constructs\n  1. first a (regressive) object of `GradedSuperAlgebrasWithBasis`, then\n  2. (insert some magic here) adds Commutative axiom.\n\nThen the final thing will be an object of `CategoryWithAxiom_over_base_ring`, i.e. a superalgebra (with presence of basis and grading now \"shadowed\" by insertion of the axiom `Commutative`) and therefore call to `TensorProduct` will finally pick the right category (and `product_on_basis()`).\n\nIs that correct?\n\nQuestion no. 1: `SuperModulesCategory` (super of `SuperAlgebrasWithBasis`) is not considered **Regressive** (as `GradedModulesCategory` is). As far as I understand the goal is to implement e.g. tensor product of superalgebras as a superalgebra, hence `SuperAlgebraWithBasis` should be considered as Regressive? Is there a need to reflect that in code?\n\nQuestion no. 2: Implementing the axiom `Commutative` should I create separate files \"commutative_super_algebras.py\" with `class CommutativeSuperAlgebra(CategoryWithAxiom_over_base_ring)`, or should I rather implement those as subclasses in super_algebras.py (and similarly for \"_with_basis\")?",
    "created_at": "2016-10-18T18:33:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292407",
    "user": "https://trac.sagemath.org/admin/accounts/users/kalmar"
}
```

If I understand Correctly I have to implement `GradedSuperAlgebrasWithBasis` as an object of `GradedSuperModulesCategory` which then should be object of the join of (I mean inherit from both of) (`Regressive`?)`CovariantConstructionCategory` and `Category_over_base_ring`?

If we have this I need to 

* add `Commutative` axiom to both `SuperAlgebras` and `SuperAlgebrasWithBasis`, so that (deconstructing call creating cohomology ring) `SuperAlgebras(base_ring).WithBasis().Graded().FiniteDimensional().Commutative()` constructs
  1. first a (regressive) object of `GradedSuperAlgebrasWithBasis`, then
  2. (insert some magic here) adds Commutative axiom.

Then the final thing will be an object of `CategoryWithAxiom_over_base_ring`, i.e. a superalgebra (with presence of basis and grading now "shadowed" by insertion of the axiom `Commutative`) and therefore call to `TensorProduct` will finally pick the right category (and `product_on_basis()`).

Is that correct?

Question no. 1: `SuperModulesCategory` (super of `SuperAlgebrasWithBasis`) is not considered **Regressive** (as `GradedModulesCategory` is). As far as I understand the goal is to implement e.g. tensor product of superalgebras as a superalgebra, hence `SuperAlgebraWithBasis` should be considered as Regressive? Is there a need to reflect that in code?

Question no. 2: Implementing the axiom `Commutative` should I create separate files "commutative_super_algebras.py" with `class CommutativeSuperAlgebra(CategoryWithAxiom_over_base_ring)`, or should I rather implement those as subclasses in super_algebras.py (and similarly for "_with_basis")?



---

archive/issue_comments_292408.json:
```json
{
    "body": "I think most of what you said is correct, but I would need to play with things to see if they actually are correct (or have Nicolas come in and answer). The end point is that the `Super` should catch the commutative, but behave regressively with respect to the `FiniteDimensional`.\n\nThe answer to question 1 is no because of the commutativity issue. The answer to question 2 is you probably do not need a separate file, although it could be desirable. We should implement a `_test_commutativity` method similar to `_test_associativity`, but that doesn't have to be done here.",
    "created_at": "2016-10-18T20:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21126",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21126#issuecomment-292408",
    "user": "https://github.com/tscrim"
}
```

I think most of what you said is correct, but I would need to play with things to see if they actually are correct (or have Nicolas come in and answer). The end point is that the `Super` should catch the commutative, but behave regressively with respect to the `FiniteDimensional`.

The answer to question 1 is no because of the commutativity issue. The answer to question 2 is you probably do not need a separate file, although it could be desirable. We should implement a `_test_commutativity` method similar to `_test_associativity`, but that doesn't have to be done here.
