# Issue 21041: Polyhedron.integral_points(): Generalize Smith form based enumeration to rational and semi-rational polytopes

archive/issues_020804.json:
```json
{
    "body": "As a follow-up to #21037, the method for integer point enumeration using triangulation and Smith form (a simple implementation of normaliz's method (see #20885 comment:6) in `simplex_points` is limited to lattice polytopes. Normaliz is much faster and has an implementation for rational (non-lattice) polytopes. A generalization to include the case of semi-rational polytopes (i.e., possibly irrational translations of lattice polytopes) could be valuable; example:\n\n```\n    sage: P = Polyhedron(vertices=((0, 0), (1743,3134))) + 1/1000*vector(AA, [AA(sqrt(5)), AA(sqrt(5))])\n    sage: P.integral_points()  # takes LONG\n```\n\n\nCC:  @tscrim @novoselt @dimpase @videlec @vbraun winfried\n\nIssue created by migration from https://trac.sagemath.org/ticket/21041\n\n",
    "created_at": "2016-07-17T23:18:29Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "Polyhedron.integral_points(): Generalize Smith form based enumeration to rational and semi-rational polytopes",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21041",
    "user": "https://github.com/mkoeppe"
}
```
As a follow-up to #21037, the method for integer point enumeration using triangulation and Smith form (a simple implementation of normaliz's method (see #20885 comment:6) in `simplex_points` is limited to lattice polytopes. Normaliz is much faster and has an implementation for rational (non-lattice) polytopes. A generalization to include the case of semi-rational polytopes (i.e., possibly irrational translations of lattice polytopes) could be valuable; example:

```
    sage: P = Polyhedron(vertices=((0, 0), (1743,3134))) + 1/1000*vector(AA, [AA(sqrt(5)), AA(sqrt(5))])
    sage: P.integral_points()  # takes LONG
```


CC:  @tscrim @novoselt @dimpase @videlec @vbraun winfried

Issue created by migration from https://trac.sagemath.org/ticket/21041





---

archive/issue_comments_287093.json:
```json
{
    "body": "<a id='comment:1'></a>Would it be beneficial to expand a rational polytope so that its points are integral, and then filter out the points which would not be integers upon shrinking?\n\nI'm guessing the way to check for translates of a rational/lattice polytope is to actually look at the differences of the vertices relative to a fixed vertex?",
    "created_at": "2016-07-17T23:46:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287093",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:1'></a>Would it be beneficial to expand a rational polytope so that its points are integral, and then filter out the points which would not be integers upon shrinking?

I'm guessing the way to check for translates of a rational/lattice polytope is to actually look at the differences of the vertices relative to a fixed vertex?



---

archive/issue_comments_287094.json:
```json
{
    "body": "<a id='comment:2'></a>Replying to [comment:1 tscrim]:\n> Would it be beneficial to expand a rational polytope so that its points are integral, and then filter out the points which would not be integers upon shrinking?\n\n\nYes, that could be a simple technique that would require only small changes of the code.\nThe normaliz manual (https://www.normaliz.uni-osnabrueck.de/wp-content/uploads/2016/04/Normaliz3.1.1Documentation.pdf, page 64, section 6.1) explains an \"approximation technique\" similar to this idea.\n\n> I'm guessing the way to check for translates of a rational/lattice polytope is to actually look at the differences of the vertices relative to a fixed vertex?\n\n\nIt is explained, for example, in http://www.combinatorics.org/ojs/index.php/eljc/article/view/v15i1r16/pdf Lemma 11.",
    "created_at": "2016-07-18T11:07:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287094",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:2'></a>Replying to [comment:1 tscrim]:
> Would it be beneficial to expand a rational polytope so that its points are integral, and then filter out the points which would not be integers upon shrinking?


Yes, that could be a simple technique that would require only small changes of the code.
The normaliz manual (https://www.normaliz.uni-osnabrueck.de/wp-content/uploads/2016/04/Normaliz3.1.1Documentation.pdf, page 64, section 6.1) explains an "approximation technique" similar to this idea.

> I'm guessing the way to check for translates of a rational/lattice polytope is to actually look at the differences of the vertices relative to a fixed vertex?


It is explained, for example, in http://www.combinatorics.org/ojs/index.php/eljc/article/view/v15i1r16/pdf Lemma 11.



---

archive/issue_comments_287095.json:
```json
{
    "body": "<a id='comment:3'></a>Replying to [comment:2 mkoeppe]:\n> Replying to [comment:1 tscrim]:\n> > Would it be beneficial to expand a rational polytope so that its points are integral, and then filter out the points which would not be integers upon shrinking?\n\n> \n> Yes, that could be a simple technique that would require only small changes of the code.\n> The normaliz manual (https://www.normaliz.uni-osnabrueck.de/wp-content/uploads/2016/04/Normaliz3.1.1Documentation.pdf, page 64, section 6.1) explains an \"approximation technique\" similar to this idea.\n\n\nThe hard part, to me, of this would be constructing the approximation lattice polytope. Would we just take the convex hull of all of the cell containing each of the non-integral vertices of the original polytope? Or is there a smarter method?\n\nI'm thinking we should implement both approaches (at least for now to see if one definitely beats the other). Plus, the approximation could be used as a general purpose technique.\n\n> > I'm guessing the way to check for translates of a rational/lattice polytope is to actually look at the differences of the vertices relative to a fixed vertex?\n\n> \n> It is explained, for example, in \u200bhttp://www.combinatorics.org/ojs/index.php/eljc/article/view/v15i1r16/pdf Lemma 11.\n\n\nThank you for the reference. Do you think you could provide this implementation? I am pretty sure I could do the first half above.",
    "created_at": "2016-07-18T14:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287095",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:3'></a>Replying to [comment:2 mkoeppe]:
> Replying to [comment:1 tscrim]:
> > Would it be beneficial to expand a rational polytope so that its points are integral, and then filter out the points which would not be integers upon shrinking?

> 
> Yes, that could be a simple technique that would require only small changes of the code.
> The normaliz manual (https://www.normaliz.uni-osnabrueck.de/wp-content/uploads/2016/04/Normaliz3.1.1Documentation.pdf, page 64, section 6.1) explains an "approximation technique" similar to this idea.


The hard part, to me, of this would be constructing the approximation lattice polytope. Would we just take the convex hull of all of the cell containing each of the non-integral vertices of the original polytope? Or is there a smarter method?

I'm thinking we should implement both approaches (at least for now to see if one definitely beats the other). Plus, the approximation could be used as a general purpose technique.

> > I'm guessing the way to check for translates of a rational/lattice polytope is to actually look at the differences of the vertices relative to a fixed vertex?

> 
> It is explained, for example, in â€‹http://www.combinatorics.org/ojs/index.php/eljc/article/view/v15i1r16/pdf Lemma 11.


Thank you for the reference. Do you think you could provide this implementation? I am pretty sure I could do the first half above.



---

archive/issue_comments_287096.json:
```json
{
    "body": "<a id='comment:4'></a>This should have low priority until someone \"really\" wants to do computations with semirational polytopes.\nFor the more common case of rational polytopes, with MUCH less effort one can make an \"easy\" implementation of a normaliz interface (using file passing instead of using libnormaliz).",
    "created_at": "2016-07-18T14:42:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287096",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:4'></a>This should have low priority until someone "really" wants to do computations with semirational polytopes.
For the more common case of rational polytopes, with MUCH less effort one can make an "easy" implementation of a normaliz interface (using file passing instead of using libnormaliz).



---

archive/issue_comments_287097.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [comment:4 mkoeppe]:\n> For the more common case of rational polytopes, with MUCH less effort one can make an \"easy\" implementation of a normaliz interface (using file passing instead of using libnormaliz).\n\nNote that such file passings and system calls add a considerable constant overhead (perhaps 0.1s on modern systems). This makes it horrible for large numbers of small polytopes. So it would be nice to have a library interface even though I don't volunteer to implement it ;-)",
    "created_at": "2016-07-18T14:54:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287097",
    "user": "https://github.com/novoselt"
}
```

<a id='comment:5'></a>Replying to [comment:4 mkoeppe]:
> For the more common case of rational polytopes, with MUCH less effort one can make an "easy" implementation of a normaliz interface (using file passing instead of using libnormaliz).

Note that such file passings and system calls add a considerable constant overhead (perhaps 0.1s on modern systems). This makes it horrible for large numbers of small polytopes. So it would be nice to have a library interface even though I don't volunteer to implement it ;-)



---

archive/issue_comments_287098.json:
```json
{
    "body": "<a id='comment:6'></a>Perhaps we should split this into 2 tickets, one for the rational case(s) and one of the semirational case? I can probably get the rational case(s) done tonight.\n\nUnfortunately I cannot write code to interface with (lib)normaliz (addendum - without taking some time to do some reading and experimenting), but I will be happy to review it.",
    "created_at": "2016-07-18T14:55:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287098",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>Perhaps we should split this into 2 tickets, one for the rational case(s) and one of the semirational case? I can probably get the rational case(s) done tonight.

Unfortunately I cannot write code to interface with (lib)normaliz (addendum - without taking some time to do some reading and experimenting), but I will be happy to review it.



---

archive/issue_comments_287099.json:
```json
{
    "body": "<a id='comment:7'></a>I'm visiting the normaliz people later this week. Maybe we will make a quick libnormaliz interface. Stay tuned.",
    "created_at": "2016-07-18T15:00:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287099",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:7'></a>I'm visiting the normaliz people later this week. Maybe we will make a quick libnormaliz interface. Stay tuned.



---

archive/issue_comments_287100.json:
```json
{
    "body": "<a id='comment:8'></a>For the rational case, we now have an implementation using normaliz in #20885. It can handle for example this:\n\n```\nsage: P = Polyhedron(vertices=((0, 0), (1789345,37121))) + 1/1000*polytopes.hypercube(2)\nsage: V=P.vertices_list()\nsage: P = Polyhedron(vertices=V, backend='normaliz')\nsage: %timeit P.integral_points()\n1 loop, best of 3: 134 ms per loop\nsage: len(P.integral_points())\n3654\n```",
    "created_at": "2016-11-27T02:20:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21041",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21041#issuecomment-287100",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:8'></a>For the rational case, we now have an implementation using normaliz in #20885. It can handle for example this:

```
sage: P = Polyhedron(vertices=((0, 0), (1789345,37121))) + 1/1000*polytopes.hypercube(2)
sage: V=P.vertices_list()
sage: P = Polyhedron(vertices=V, backend='normaliz')
sage: %timeit P.integral_points()
1 loop, best of 3: 134 ms per loop
sage: len(P.integral_points())
3654
```
