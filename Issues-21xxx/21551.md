# Issue 21551: (1/(1006987929*pi - 3163545880)).n() raises division by zero error

archive/issues_021551.json:
```json
{
    "body": "CC:  @paulmasson\n\nAs reported on [sage-devel](https://groups.google.com/d/topic/sage-devel/znjYsqv8BKw/discussion), using 7.4.beta6, I get\n\n```\nsage: (1/(1006987929*pi - 3163545880)).n()\nTraceback (most recent call last)\n...\nValueError: power::eval(): division by zero\n```\n\nBut providing digits works:\n\n```\nsage: (1/(1006987929*pi - 3163545880)).n(digits=50)\n3.2389954278022058869923921595406901102762355827180e6\n```\n\nMaybe also related:\n\n```\nsage: a = 1/(1006987929*pi - 3163545880)\nsage: b = 1/3/(333362599*pi - 1047289492)\nsage: bool(a<b)\nTraceback (most recent call last)\n...\nRuntimeError: ECL says: Error executing code in Maxima: expt: undefined: 0 to a negative exponent.\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/21788\n\n",
    "created_at": "2016-10-31T11:53:00Z",
    "labels": [
        "component: numerical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.5",
    "title": "(1/(1006987929*pi - 3163545880)).n() raises division by zero error",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21551",
    "user": "https://github.com/seblabbe"
}
```
CC:  @paulmasson

As reported on [sage-devel](https://groups.google.com/d/topic/sage-devel/znjYsqv8BKw/discussion), using 7.4.beta6, I get

```
sage: (1/(1006987929*pi - 3163545880)).n()
Traceback (most recent call last)
...
ValueError: power::eval(): division by zero
```

But providing digits works:

```
sage: (1/(1006987929*pi - 3163545880)).n(digits=50)
3.2389954278022058869923921595406901102762355827180e6
```

Maybe also related:

```
sage: a = 1/(1006987929*pi - 3163545880)
sage: b = 1/3/(333362599*pi - 1047289492)
sage: bool(a<b)
Traceback (most recent call last)
...
RuntimeError: ECL says: Error executing code in Maxima: expt: undefined: 0 to a negative exponent.
```

Issue created by migration from https://trac.sagemath.org/ticket/21788





---

archive/issue_comments_298869.json:
```json
{
    "body": "It works with digits provided the number is big enough\n\n```\nsage: (1/(1006987929*pi - 3163545880)).n(digits=14)\nTraceback (most recent call last):\n...\nValueError: power::eval(): division by zero\n```\nThe default precision is 2<sup>53</sup> which is roughly 16 digits in base 10.",
    "created_at": "2016-10-31T14:33:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298869",
    "user": "https://github.com/videlec"
}
```

It works with digits provided the number is big enough

```
sage: (1/(1006987929*pi - 3163545880)).n(digits=14)
Traceback (most recent call last):
...
ValueError: power::eval(): division by zero
```
The default precision is 2<sup>53</sup> which is roughly 16 digits in base 10.



---

archive/issue_comments_298870.json:
```json
{
    "body": "You can also see that\n\n```\nsage: 1 / (1006987929*RR.pi() - 3163545880)\n+infinity\n```",
    "created_at": "2016-10-31T14:35:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298870",
    "user": "https://github.com/videlec"
}
```

You can also see that

```
sage: 1 / (1006987929*RR.pi() - 3163545880)
+infinity
```



---

archive/issue_comments_298871.json:
```json
{
    "body": "But\n\n```\nsage: 1 / (1006987929*RealField(64).pi() - 3163545880)\n3.23904019306184012e6\n```",
    "created_at": "2016-10-31T14:36:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298871",
    "user": "https://github.com/videlec"
}
```

But

```
sage: 1 / (1006987929*RealField(64).pi() - 3163545880)
3.23904019306184012e6
```



---

archive/issue_comments_298872.json:
```json
{
    "body": "```\nsage: (1006987929*pi - 3163545880).n(54)\n4.76837158203125e-7\nsage: (1006987929*pi - 3163545880).n(53)\n0.000000000000000\n```\nThis is just one of these border cases. The only thing you can do atm is raising precision, which just sets the bar higher.\n\nThe only real solution would be to recognize that pi is irrational and raise the precision automatically. Drawback is that it could become slow.",
    "created_at": "2016-11-01T06:34:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298872",
    "user": "https://github.com/rwst"
}
```

```
sage: (1006987929*pi - 3163545880).n(54)
4.76837158203125e-7
sage: (1006987929*pi - 3163545880).n(53)
0.000000000000000
```
This is just one of these border cases. The only thing you can do atm is raising precision, which just sets the bar higher.

The only real solution would be to recognize that pi is irrational and raise the precision automatically. Drawback is that it could become slow.



---

archive/issue_comments_298873.json:
```json
{
    "body": "Replying to [comment:2 vdelecroix]:\n> You can also see that\n> \n> ```\n> sage: 1 / (1006987929*RR.pi() - 3163545880)\n> +infinity\n> ```\n\n\nDo you want infinity returned in this case too? I'll open a ticket if so.",
    "created_at": "2016-11-01T06:37:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298873",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:2 vdelecroix]:
> You can also see that
> 
> ```
> sage: 1 / (1006987929*RR.pi() - 3163545880)
> +infinity
> ```


Do you want infinity returned in this case too? I'll open a ticket if so.



---

archive/issue_comments_298874.json:
```json
{
    "body": "Replying to [comment:6 rws]:\n> Replying to [comment:2 vdelecroix]:\n> > You can also see that\n> > \n> > ```\n> > sage: 1 / (1006987929*RR.pi() - 3163545880)\n> > +infinity\n> > ```\n\n> \n> Do you want infinity returned in this case too?\n\n\nThis would be **very** wrong. In the case of floating point there is a dramatic cancelation.",
    "created_at": "2016-11-01T07:18:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298874",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:6 rws]:
> Replying to [comment:2 vdelecroix]:
> > You can also see that
> > 
> > ```
> > sage: 1 / (1006987929*RR.pi() - 3163545880)
> > +infinity
> > ```

> 
> Do you want infinity returned in this case too?


This would be **very** wrong. In the case of floating point there is a dramatic cancelation.



---

archive/issue_comments_298875.json:
```json
{
    "body": "Replying to [comment:5 rws]:\n> {{{\n> sage: (1006987929*pi - 3163545880).n(54)\n> 4.76837158203125e-7\n> sage: (1006987929*pi - 3163545880).n(53)\n> 0.000000000000000\n> }}}\n> This is just one of these border cases. The only thing you can do atm is raising precision, which just sets the bar higher.\n\n>\n> The only real solution would be to recognize that pi is irrational and raise the precision automatically. Drawback is that it could become slow.\n\n\n+1. `pi` is even transcendental. Hence for polynomials in `pi` with rational coefficients we should just increase precision (knowing in advance that it can not be zero).",
    "created_at": "2016-11-01T07:23:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298875",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:5 rws]:
> {{{
> sage: (1006987929*pi - 3163545880).n(54)
> 4.76837158203125e-7
> sage: (1006987929*pi - 3163545880).n(53)
> 0.000000000000000
> }}}
> This is just one of these border cases. The only thing you can do atm is raising precision, which just sets the bar higher.

>
> The only real solution would be to recognize that pi is irrational and raise the precision automatically. Drawback is that it could become slow.


+1. `pi` is even transcendental. Hence for polynomials in `pi` with rational coefficients we should just increase precision (knowing in advance that it can not be zero).



---

archive/issue_comments_298876.json:
```json
{
    "body": "Maybe I created that ticket too fast: I wrongly thought that inputs given to `numerical_approx` was about the number of digits (or bits) of precision of the output, not of the intermediate computations.\n\nMaybe that ticket could be closed as won't fix. Or maybe this ticket goal could be to improve the documentation of `numerical_approx` to explain the meaning of the inputs, because I believe this is misleading:\n\n```\n   Return a numerical approximation of \"self\" with \"prec\" bits (or\n   decimal \"digits\") of precision.\n```",
    "created_at": "2016-11-02T10:10:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298876",
    "user": "https://github.com/seblabbe"
}
```

Maybe I created that ticket too fast: I wrongly thought that inputs given to `numerical_approx` was about the number of digits (or bits) of precision of the output, not of the intermediate computations.

Maybe that ticket could be closed as won't fix. Or maybe this ticket goal could be to improve the documentation of `numerical_approx` to explain the meaning of the inputs, because I believe this is misleading:

```
   Return a numerical approximation of "self" with "prec" bits (or
   decimal "digits") of precision.
```



---

archive/issue_comments_298877.json:
```json
{
    "body": "Replying to [comment:9 slabbe]:\n> Maybe I created that ticket too fast: I wrongly thought that inputs given to `numerical_approx` was about the number of digits (or bits) of precision of the output, not of the intermediate computations.\n\n\nCorrect me but there is no way to get more precision out of operations with numbers of smaller precision, so the precision value is needed from the start.\n\n> Maybe that ticket could be closed as won't fix. Or maybe this ticket goal could be to improve the documentation of `numerical_approx` to explain the meaning of the inputs, because I believe this is misleading:\n> \n> \n> ```\n>    Return a numerical approximation of \"self\" with \"prec\" bits (or\n>    decimal \"digits\") of precision.\n> ```\n\n\nYes, and I think the division by zero `ValueError` should be caught and rethrown with an additional hint to raise the precision.",
    "created_at": "2016-11-02T13:42:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298877",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:9 slabbe]:
> Maybe I created that ticket too fast: I wrongly thought that inputs given to `numerical_approx` was about the number of digits (or bits) of precision of the output, not of the intermediate computations.


Correct me but there is no way to get more precision out of operations with numbers of smaller precision, so the precision value is needed from the start.

> Maybe that ticket could be closed as won't fix. Or maybe this ticket goal could be to improve the documentation of `numerical_approx` to explain the meaning of the inputs, because I believe this is misleading:
> 
> 
> ```
>    Return a numerical approximation of "self" with "prec" bits (or
>    decimal "digits") of precision.
> ```


Yes, and I think the division by zero `ValueError` should be caught and rethrown with an additional hint to raise the precision.



---

archive/issue_comments_298878.json:
```json
{
    "body": "Replying to [comment:10 rws]:\n> Correct me but there is no way to get more precision out of operations with numbers of smaller precision, so the precision value is needed from the start.\n\n\nThe only thing that I would correct in the last sentence is : \"so  *some high enough* precision is needed from the start\".\n\nMaybe this is not what we want for `numerical_approx` function because it involves more computations (involving real interval arithmetics?) to compute what high enough precision is needed for the computations to get the output with the desired precision. But to me this is what I expected `numerical_approx` to do after reading its documentation:\n\n```python\nsage: def high_enough_precision(X, desired_prec):\n....:     prec = desired_prec\n....:     while -log(RealIntervalField(prec)(X).diameter(),2) < desired_prec:\n....:         prec +=1\n....:     return prec\n....:\nsage: high_enough_precision(pi, 53)\n54\nsage: high_enough_precision(pi-3.14, 53)\n65\nsage: B = (1/(1006987929*pi - 3163545880))\nsage: high_enough_precision(B, 53)\n108\n```\n\nThen, using 108 bits of precision in the internal computations really gives 53 bits of precision for the output:\n\n```python\nsage: RealIntervalField(108)(B)\n3.238995427802206?e6\nsage: B.n(digits=50)\n3.2389954278022058869923921595406901102762355827180e6\n```\n \n \n> Yes, and I think the division by zero `ValueError` should be caught and rethrown with an additional hint to raise the precision.\n\n\nYes, it might be an intermediate solution. Because sometimes there is no `ValueError`, but the precision should still be raised like in the case of `pi-3.14`.",
    "created_at": "2016-11-02T14:39:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21551",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21551#issuecomment-298878",
    "user": "https://github.com/seblabbe"
}
```

Replying to [comment:10 rws]:
> Correct me but there is no way to get more precision out of operations with numbers of smaller precision, so the precision value is needed from the start.


The only thing that I would correct in the last sentence is : "so  *some high enough* precision is needed from the start".

Maybe this is not what we want for `numerical_approx` function because it involves more computations (involving real interval arithmetics?) to compute what high enough precision is needed for the computations to get the output with the desired precision. But to me this is what I expected `numerical_approx` to do after reading its documentation:

```python
sage: def high_enough_precision(X, desired_prec):
....:     prec = desired_prec
....:     while -log(RealIntervalField(prec)(X).diameter(),2) < desired_prec:
....:         prec +=1
....:     return prec
....:
sage: high_enough_precision(pi, 53)
54
sage: high_enough_precision(pi-3.14, 53)
65
sage: B = (1/(1006987929*pi - 3163545880))
sage: high_enough_precision(B, 53)
108
```

Then, using 108 bits of precision in the internal computations really gives 53 bits of precision for the output:

```python
sage: RealIntervalField(108)(B)
3.238995427802206?e6
sage: B.n(digits=50)
3.2389954278022058869923921595406901102762355827180e6
```
 
 
> Yes, and I think the division by zero `ValueError` should be caught and rethrown with an additional hint to raise the precision.


Yes, it might be an intermediate solution. Because sometimes there is no `ValueError`, but the precision should still be raised like in the case of `pi-3.14`.
