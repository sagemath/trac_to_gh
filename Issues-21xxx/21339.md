# Issue 21339: TestSet Decoder for LinearCodes

archive/issues_021102.json:
```json
{
    "body": "A new version of the ticket #14973 adapted to the new coding Theory framework \n\nCC:  @johanrosenkilde dlucas danielaugot\n\nKeywords: sd75\n\nAuthor: Irene M\u00e1rquez-Corbella, Miguel Marco\n\nBranch: u/imarquez/groebner-decoder\n\nCommit: 76b83d7663419b1c0fdb4aec79e194b0767f3bea\n\nIssue created by migration from https://trac.sagemath.org/ticket/21339\n\n",
    "created_at": "2016-08-25T21:34:14Z",
    "labels": [
        "component: coding theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.4",
    "title": "TestSet Decoder for LinearCodes",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21339",
    "user": "https://trac.sagemath.org/admin/accounts/users/imarquez"
}
```
A new version of the ticket #14973 adapted to the new coding Theory framework 

CC:  @johanrosenkilde dlucas danielaugot

Keywords: sd75

Author: Irene Márquez-Corbella, Miguel Marco

Branch: u/imarquez/groebner-decoder

Commit: 76b83d7663419b1c0fdb4aec79e194b0767f3bea

Issue created by migration from https://trac.sagemath.org/ticket/21339





---

archive/issue_comments_292028.json:
```json
{
    "body": "<a id='comment:2'></a>This is a ticket still under work (documentation still needs some work)\n\n---\nNew commits:",
    "created_at": "2016-08-25T21:37:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292028",
    "user": "https://trac.sagemath.org/admin/accounts/users/imarquez"
}
```

<a id='comment:2'></a>This is a ticket still under work (documentation still needs some work)

---
New commits:



---

archive/issue_comments_292029.json:
```json
{
    "body": "<a id='comment:4'></a>Hi Irene,\n\nthere was a very minor conflict (traling whitespace) in merging with develop. \n\nDaniel\n\n---\nNew commits:",
    "created_at": "2016-08-26T08:25:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292029",
    "user": "https://trac.sagemath.org/admin/accounts/users/danielaugot"
}
```

<a id='comment:4'></a>Hi Irene,

there was a very minor conflict (traling whitespace) in merging with develop. 

Daniel

---
New commits:



---

archive/issue_comments_292030.json:
```json
{
    "body": "<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-26T08:46:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292030",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_292031.json:
```json
{
    "body": "<a id='comment:7'></a>I will continue working in the documentation and extra functions in the following days.",
    "created_at": "2016-08-26T08:50:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292031",
    "user": "https://trac.sagemath.org/admin/accounts/users/imarquez"
}
```

<a id='comment:7'></a>I will continue working in the documentation and extra functions in the following days.



---

archive/issue_comments_292032.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-27T08:56:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292032",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_292033.json:
```json
{
    "body": "<a id='comment:11'></a>New functions have been added: coset_leaders,  coset_weight_distribution, covering_radius(without Magma), newton_radius and unique_decoding_radius().\n\nDocumentation now is correct",
    "created_at": "2016-08-27T08:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292033",
    "user": "https://trac.sagemath.org/admin/accounts/users/imarquez"
}
```

<a id='comment:11'></a>New functions have been added: coset_leaders,  coset_weight_distribution, covering_radius(without Magma), newton_radius and unique_decoding_radius().

Documentation now is correct



---

archive/issue_comments_292034.json:
```json
{
    "body": "<a id='comment:12'></a>Sorry before is covering_radius (without the optional package of GUAVA)",
    "created_at": "2016-08-27T09:11:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292034",
    "user": "https://trac.sagemath.org/admin/accounts/users/imarquez"
}
```

<a id='comment:12'></a>Sorry before is covering_radius (without the optional package of GUAVA)



---

archive/issue_comments_292035.json:
```json
{
    "body": "<a id='comment:13'></a>Hello Irene,\n\nI actually implemented a version of `covering_radius` which does not use GUAVA in\n#19913. It automatically detects if GUAVA is installed, and if it's not, it uses a\nvery slow Python algorithm instead of using GUAVA.\n\nWe should benchmark your implementation and mine, and keep the fastest one.\nBTW, I did some benchmarking GUAVA vs. naive Python implementation, and GUAVA was\nalways faster (which is why I automatically use GUAVA calls if the user has GUAVA installed).\n\nDavid",
    "created_at": "2016-08-27T09:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292035",
    "user": "https://trac.sagemath.org/admin/accounts/users/dlucas"
}
```

<a id='comment:13'></a>Hello Irene,

I actually implemented a version of `covering_radius` which does not use GUAVA in
#19913. It automatically detects if GUAVA is installed, and if it's not, it uses a
very slow Python algorithm instead of using GUAVA.

We should benchmark your implementation and mine, and keep the fastest one.
BTW, I did some benchmarking GUAVA vs. naive Python implementation, and GUAVA was
always faster (which is why I automatically use GUAVA calls if the user has GUAVA installed).

David



---

archive/issue_comments_292036.json:
```json
{
    "body": "<a id='comment:14'></a>In the _insert_next_fq method, you treat these two different cases:\n\n```\n        if List:\n            for i in s:\n                new = v.__copy__()\n                for q in Fqstar:\n                    new[i]=q\n                    if new not in List:\n                        List.append(new.__copy__())\n        else:\n            for i in s:\n                new = v.__copy__()\n                for q in Fqstar:\n                    new[i]=q\n                    List.append(new.__copy__())\n```\n\nis it really what you want to do? wouldn't it make sense to just use the first case everywhere?",
    "created_at": "2016-08-29T10:32:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292036",
    "user": "https://github.com/miguelmarco"
}
```

<a id='comment:14'></a>In the _insert_next_fq method, you treat these two different cases:

```
        if List:
            for i in s:
                new = v.__copy__()
                for q in Fqstar:
                    new[i]=q
                    if new not in List:
                        List.append(new.__copy__())
        else:
            for i in s:
                new = v.__copy__()
                for q in Fqstar:
                    new[i]=q
                    List.append(new.__copy__())
```

is it really what you want to do? wouldn't it make sense to just use the first case everywhere?



---

archive/issue_comments_292037.json:
```json
{
    "body": "<a id='comment:15'></a>That whole helper-method can be simplified into an almost-one-liner: all error-vectors of weight 1 can be created as:\n\n```\n   I = identity_matrix(F, n)\n   single_errs = ( a * I.row(i) for a in F for i in range(n) )\n```\n\nNow you want to extend `List` with the elements `[ v + e for e in single_errs ]`. \nBut you want to avoid duplicating the elements already in `List`. Therefore you should use a `set` for `List`. This causes a small snag since `set`s only work for **immutable** vectors.\n\nAssuming `single_errs` was computed outside at the beginning of the method, then the update of `List` in the loop of `coset_leaders` could look like\n\n```\n    shifts = [ v + e for e in single_errs ]\n    for w in shifts: w.set_immutable()\n    List.union(shifts)\n```\n\n`List` breaks the convention of starting variables with minuscule. What about the name `worklist`?\n\nBest,\nJohan",
    "created_at": "2016-08-29T13:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292037",
    "user": "https://github.com/johanrosenkilde"
}
```

<a id='comment:15'></a>That whole helper-method can be simplified into an almost-one-liner: all error-vectors of weight 1 can be created as:

```
   I = identity_matrix(F, n)
   single_errs = ( a * I.row(i) for a in F for i in range(n) )
```

Now you want to extend `List` with the elements `[ v + e for e in single_errs ]`. 
But you want to avoid duplicating the elements already in `List`. Therefore you should use a `set` for `List`. This causes a small snag since `set`s only work for **immutable** vectors.

Assuming `single_errs` was computed outside at the beginning of the method, then the update of `List` in the loop of `coset_leaders` could look like

```
    shifts = [ v + e for e in single_errs ]
    for w in shifts: w.set_immutable()
    List.union(shifts)
```

`List` breaks the convention of starting variables with minuscule. What about the name `worklist`?

Best,
Johan



---

archive/issue_comments_292038.json:
```json
{
    "body": "<a id='comment:16'></a>The keyword `algorithm` for the \"one\"/\"all\" of `coset_leaders` is not good: `algorithm` is reserved for different methods with which to compute the result. What about `representative = True`, where `representative = False` means to output all of them.",
    "created_at": "2016-08-29T13:46:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292038",
    "user": "https://github.com/johanrosenkilde"
}
```

<a id='comment:16'></a>The keyword `algorithm` for the "one"/"all" of `coset_leaders` is not good: `algorithm` is reserved for different methods with which to compute the result. What about `representative = True`, where `representative = False` means to output all of them.



---

archive/issue_comments_292039.json:
```json
{
    "body": "<a id='comment:17'></a>Replying to [comment:14 mmarco]:\n> In the _insert_next_fq method, you treat these two different cases:\n> is it really what you want to do? wouldn't it make sense to just use the first case everywhere?\n\n\nI think the `if` condition should be kept. It makes a difference and avoids a linear search inside a `for` loop in the case `List` is empty.\n\n> This causes a small snag since sets only work for immutable vectors.\n\n\nI think we should not return immutable vectors from coset leaders. The output might be used for further computations by the user and then it will create strange issues, which will be hard to debug. The less surprises we have for the user, the better it is.\n\n> `List` breaks the convention of starting variables with minuscule. What about the name `worklist`?\n\n\nThis can be done I suppose, just for consistency.\n\n> The keyword algorithm for the \"one\"/\"all\" of coset_leaders is not good\n\n\nI agree. This is not really a different algorithm.",
    "created_at": "2016-11-27T08:58:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292039",
    "user": "https://github.com/ppurka"
}
```

<a id='comment:17'></a>Replying to [comment:14 mmarco]:
> In the _insert_next_fq method, you treat these two different cases:
> is it really what you want to do? wouldn't it make sense to just use the first case everywhere?


I think the `if` condition should be kept. It makes a difference and avoids a linear search inside a `for` loop in the case `List` is empty.

> This causes a small snag since sets only work for immutable vectors.


I think we should not return immutable vectors from coset leaders. The output might be used for further computations by the user and then it will create strange issues, which will be hard to debug. The less surprises we have for the user, the better it is.

> `List` breaks the convention of starting variables with minuscule. What about the name `worklist`?


This can be done I suppose, just for consistency.

> The keyword algorithm for the "one"/"all" of coset_leaders is not good


I agree. This is not really a different algorithm.



---

archive/issue_comments_292040.json:
```json
{
    "body": "<a id='comment:18'></a>If you care about the `coset_leaders` method I see many improvements possibles:\n* use `deque` instead of `list` for the worklist;\n* append generators instead of real lists;\n* take care to enumerate your candidates uniquely;\n* use a hashed container for the syndromes already seen;\n* early abort when you have seen all the possible syndromes;\n* normalize syndromes (e.g. only keep those starting with `1`).\n\nJust as a quick model you might want to look at this:\n\n```sage\nimport collections\n\ndef coset_leaders_one(C):\n    H = C.parity_check_matrix().transpose()\n    K = C.base_ring()\n    q = K.cardinality()\n    def my_generator(v):\n        t = list(v)\n        for i, vi in enumerate(v):\n            if vi: break\n            for a in K:\n                if a:\n                    t[i] = a\n                    yield vector(t)\n            t[i] = 0\n    def normalize(s):\n        for si in s:\n            if si:\n                return tuple(s / si)\n        return tuple(s)\n    z = vector(K, C.length())\n    sz = normalize(C.syndrome(z))\n    S = {sz: z}\n    generators = collections.deque([my_generator(z)])\n    target_size = (q ** H.ncols() - 1) // (q - 1) + 1\n    while generators:\n        g = generators.popleft()\n        for v in g:\n            syndrome = normalize(v*H)\n            if syndrome not in S:\n                S[syndrome] = v\n                if len(S) == target_size:\n                    r = [S.pop(sz)]\n                    for s in S.values():\n                        r.extend(a * s for a in K if a)\n                    return r\n                if not v[0]:\n                    generators.append(my_generator(v))\n```\n\nYou can adapt this for the case where you want them all.",
    "created_at": "2016-12-03T23:58:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292040",
    "user": "https://trac.sagemath.org/admin/accounts/users/ylchapuy"
}
```

<a id='comment:18'></a>If you care about the `coset_leaders` method I see many improvements possibles:
* use `deque` instead of `list` for the worklist;
* append generators instead of real lists;
* take care to enumerate your candidates uniquely;
* use a hashed container for the syndromes already seen;
* early abort when you have seen all the possible syndromes;
* normalize syndromes (e.g. only keep those starting with `1`).

Just as a quick model you might want to look at this:

```sage
import collections

def coset_leaders_one(C):
    H = C.parity_check_matrix().transpose()
    K = C.base_ring()
    q = K.cardinality()
    def my_generator(v):
        t = list(v)
        for i, vi in enumerate(v):
            if vi: break
            for a in K:
                if a:
                    t[i] = a
                    yield vector(t)
            t[i] = 0
    def normalize(s):
        for si in s:
            if si:
                return tuple(s / si)
        return tuple(s)
    z = vector(K, C.length())
    sz = normalize(C.syndrome(z))
    S = {sz: z}
    generators = collections.deque([my_generator(z)])
    target_size = (q ** H.ncols() - 1) // (q - 1) + 1
    while generators:
        g = generators.popleft()
        for v in g:
            syndrome = normalize(v*H)
            if syndrome not in S:
                S[syndrome] = v
                if len(S) == target_size:
                    r = [S.pop(sz)]
                    for s in S.values():
                        r.extend(a * s for a in K if a)
                    return r
                if not v[0]:
                    generators.append(my_generator(v))
```

You can adapt this for the case where you want them all.



---

archive/issue_comments_292041.json:
```json
{
    "body": "<a id='comment:19'></a>You might also look at this implementation: [u/ylchapuy/coset_leaders](https://git.sagemath.org/sage.git/diff?id=u/ylchapuy/coset_leaders)",
    "created_at": "2016-12-13T16:28:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292041",
    "user": "https://trac.sagemath.org/admin/accounts/users/ylchapuy"
}
```

<a id='comment:19'></a>You might also look at this implementation: [u/ylchapuy/coset_leaders](https://git.sagemath.org/sage.git/diff?id=u/ylchapuy/coset_leaders)



---

archive/issue_comments_292042.json:
```json
{
    "body": "<a id='comment:20'></a>`@`ylchapuy Thank you for this implementation. If you have this implementation in a Ticket somewhere please try to get it in first, and make this ticket a dependency of the other one. Your implementation is several hundred times faster than this one.\n\nMeanwhile, I have been checking whether the coset leaders returned in your function \"match\" with the coset leaders returned by the implementation in this ticket. I haven't looked into it in detail, but there is a discrepancy. The discrepancy is not present for all codes though.\n\n\n\n```python\nsage: from coset_1 import coset_leaders_one\nsage: from coset_2 import coset_leaders\nsage: C = codes.ReedSolomonCode(7,5,GF(8,'a'))\n/mnt/usb/Installations/sage/src/bin/sage-ipython:1: DeprecationWarning: codes.Re\nedSolomonCode is now deprecated. Please use codes.GeneralizedReedSolomonCode ins\ntead.\nSee http://trac.sagemath.org/18928 for details.\n  #!/usr/bin/env python\nsage: L1 = coset_leaders_one(C)\nsage: L2 = coset_leaders(C, \"one\")\nsage: L2_2 = flatten(L2)\nsage: L1bool = [False]*len(L1)\nsage: L2bool = [False]*len(L2)\nsage: Fqstar = C.base_ring().list()[1:]\nsage: for i,w in enumerate(L1):\n....:     wlist = [_*w for _ in Fqstar]\n....:     for _w in wlist:\n....:         if _w in L2_2:\n....:             L1bool[i] = True\n....:             break\n....: for i,v in enumerate(L2_2):\n....:     vlist = [_*v for _ in Fqstar]\n....:     for _v in vlist:\n....:         if _v in L1:\n....:             L2bool[i] = True\n....:             break\n....:\nsage: all(L1bool)\nTrue\nsage: all(L2bool)\nFalse\nsage: %time L1 = coset_leaders_one(C)\nCPU times: user 6.67 ms, sys: 0 ns, total: 6.67 ms\nWall time: 6.02 ms\nsage: %time L2 = coset_leaders(C)\nCPU times: user 8.43 s, sys: 3.33 ms, total: 8.44 s\nWall time: 8.39 s\nsage: len(L1)\n64\nsage: len(L2)\n64\nsage: len(L2_2)\n64\n```",
    "created_at": "2017-02-04T13:47:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292042",
    "user": "https://github.com/ppurka"
}
```

<a id='comment:20'></a>`@`ylchapuy Thank you for this implementation. If you have this implementation in a Ticket somewhere please try to get it in first, and make this ticket a dependency of the other one. Your implementation is several hundred times faster than this one.

Meanwhile, I have been checking whether the coset leaders returned in your function "match" with the coset leaders returned by the implementation in this ticket. I haven't looked into it in detail, but there is a discrepancy. The discrepancy is not present for all codes though.



```python
sage: from coset_1 import coset_leaders_one
sage: from coset_2 import coset_leaders
sage: C = codes.ReedSolomonCode(7,5,GF(8,'a'))
/mnt/usb/Installations/sage/src/bin/sage-ipython:1: DeprecationWarning: codes.Re
edSolomonCode is now deprecated. Please use codes.GeneralizedReedSolomonCode ins
tead.
See http://trac.sagemath.org/18928 for details.
  #!/usr/bin/env python
sage: L1 = coset_leaders_one(C)
sage: L2 = coset_leaders(C, "one")
sage: L2_2 = flatten(L2)
sage: L1bool = [False]*len(L1)
sage: L2bool = [False]*len(L2)
sage: Fqstar = C.base_ring().list()[1:]
sage: for i,w in enumerate(L1):
....:     wlist = [_*w for _ in Fqstar]
....:     for _w in wlist:
....:         if _w in L2_2:
....:             L1bool[i] = True
....:             break
....: for i,v in enumerate(L2_2):
....:     vlist = [_*v for _ in Fqstar]
....:     for _v in vlist:
....:         if _v in L1:
....:             L2bool[i] = True
....:             break
....:
sage: all(L1bool)
True
sage: all(L2bool)
False
sage: %time L1 = coset_leaders_one(C)
CPU times: user 6.67 ms, sys: 0 ns, total: 6.67 ms
Wall time: 6.02 ms
sage: %time L2 = coset_leaders(C)
CPU times: user 8.43 s, sys: 3.33 ms, total: 8.44 s
Wall time: 8.39 s
sage: len(L1)
64
sage: len(L2)
64
sage: len(L2_2)
64
```



---

archive/issue_comments_292043.json:
```json
{
    "body": "<a id='comment:21'></a>Replying to [comment:20 ppurka]:\n> `@`ylchapuy Thank you for this implementation. If you have this implementation in a Ticket somewhere please try to get it in first, and make this ticket a dependency of the other one. Your implementation is several hundred times faster than this one.\n\n\nThe ticket where this should be done is #19913 .\n\nSadly I won't have time to do more on this in the foreseeable future, but would be pleased if someone else is motivated enough to integrate this on his own.",
    "created_at": "2017-02-04T16:57:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292043",
    "user": "https://trac.sagemath.org/admin/accounts/users/ylchapuy"
}
```

<a id='comment:21'></a>Replying to [comment:20 ppurka]:
> `@`ylchapuy Thank you for this implementation. If you have this implementation in a Ticket somewhere please try to get it in first, and make this ticket a dependency of the other one. Your implementation is several hundred times faster than this one.


The ticket where this should be done is #19913 .

Sadly I won't have time to do more on this in the foreseeable future, but would be pleased if someone else is motivated enough to integrate this on his own.



---

archive/issue_comments_292044.json:
```json
{
    "body": "<a id='comment:22'></a>And as a side remark, the code in the branch from comment:19 is even much better.\n\n6 time faster on your example code:\n\n```\nsage: C\n[7, 5, 3] Generalized Reed-Solomon Code over Finite Field in a of size 2^3\nsage: %timeit coset_leaders_one(C)\n100 loops, best of 3: 3.03 ms per loop\nsage: %timeit _coset_leaders(C)\n1000 loops, best of 3: 477 \u00b5s per loop\n```\n\nand on a some bigger examples\n\n```\nsage: C = codes.random_linear_code(GF(7), 32, 27)\nsage: %timeit coset_leaders_one(C)\n1 loop, best of 3: 1.35 s per loop\nsage: %timeit _coset_leaders(C)\n10 loops, best of 3: 78.2 ms per loop\nsage: C = codes.random_linear_code(GF(3), 32, 22)\nsage: %timeit coset_leaders_one(C)\n1 loop, best of 3: 23.8 s per loop\nsage: %timeit _coset_leaders(C)\n1 loop, best of 3: 1.18 s per loop\n```\n\nI didn't try with the implementation from here...",
    "created_at": "2017-02-06T09:55:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21339#issuecomment-292044",
    "user": "https://trac.sagemath.org/admin/accounts/users/ylchapuy"
}
```

<a id='comment:22'></a>And as a side remark, the code in the branch from comment:19 is even much better.

6 time faster on your example code:

```
sage: C
[7, 5, 3] Generalized Reed-Solomon Code over Finite Field in a of size 2^3
sage: %timeit coset_leaders_one(C)
100 loops, best of 3: 3.03 ms per loop
sage: %timeit _coset_leaders(C)
1000 loops, best of 3: 477 µs per loop
```

and on a some bigger examples

```
sage: C = codes.random_linear_code(GF(7), 32, 27)
sage: %timeit coset_leaders_one(C)
1 loop, best of 3: 1.35 s per loop
sage: %timeit _coset_leaders(C)
10 loops, best of 3: 78.2 ms per loop
sage: C = codes.random_linear_code(GF(3), 32, 22)
sage: %timeit coset_leaders_one(C)
1 loop, best of 3: 23.8 s per loop
sage: %timeit _coset_leaders(C)
1 loop, best of 3: 1.18 s per loop
```

I didn't try with the implementation from here...
