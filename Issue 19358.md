# Issue 19358: Implement a check that a hyperplane arrangement is free

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-11-18 05:07:54

Assignee: tscrim

CC:  vbraun chapoton mmarco

Keywords: free, hyperplane arrangement

We follow Barakat and Cuntz in arXiv:1011.4228 to check if a hyperplane arrangement is free.


---

Comment by tscrim created at 2015-11-18 05:12:17

New commits:


---

Comment by tscrim created at 2015-11-18 05:12:17

Changing status from new to needs_review.


---

Comment by git created at 2015-12-08 06:29:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-12-08 06:37:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2016-01-11 20:13:27

* do you check for "freeness" or some stronger "inductive freeness" ?
* in `to_symmetric_space`

```
return S.sum(G[i]*c for i,c in enumerate(self.coefficients()[1:]))
```

why is there `[1:]` ?
* maybe you should rather write
`chordality is equivalent to freeness`
and name the files "`check_freeness`"


---

Comment by tscrim created at 2016-01-20 16:34:41

Replying to [comment:4 chapoton]:
> * do you check for "freeness" or some stronger "inductive freeness" ?

As I understand it, this is just freeness, but I will make a detailed reading and double-check this.

> * in `to_symmetric_space`
> {{{
> return S.sum(G[i]*c for i,c in enumerate(self.coefficients()[1:]))
> }}}
> why is there `[1:]` ?

Because the first coefficient of a hyperplane is the constant part (as the arrangements do not need to be central, i.e., they are allowed to be affine hyperplanes).

> * maybe you should rather write
> `chordality is equivalent to freeness`
> and name the files "`check_freeness`"

Will change.


---

Comment by git created at 2016-01-21 21:17:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-01-21 21:20:11

Replying to [comment:6 tscrim]:
> Replying to [comment:4 chapoton]:
> > * do you check for "freeness" or some stronger "inductive freeness" ?
> 
> As I understand it, this is just freeness, but I will make a detailed reading and double-check this.

This does not check inductive freeness because it does not check both the exponent condition and the freeness of the restriction. However this would make for a good followup.

> > * in `to_symmetric_space`
> > {{{
> > return S.sum(G[i]*c for i,c in enumerate(self.coefficients()[1:]))
> > }}}
> > why is there `[1:]` ?
> 
> Because the first coefficient of a hyperplane is the constant part (as the arrangements do not need to be central, i.e., they are allowed to be affine hyperplanes).

In my recent push, I now forbid affine hyperplanes since I don't believe they make sense in the symmetric space.

> > * maybe you should rather write
> > `chordality is equivalent to freeness`
> > and name the files "`check_freeness`"
> 
> Will change.

Done.


---

Comment by git created at 2016-01-22 13:36:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2016-01-27 18:41:56

I have just given a very quick look at the code, but it seems to me that you are actually computing a free resolution of the logarithmic derivation module. Or at least the first steps of it. Is that correct?

If this is the case, maybe it would be worth doing so by using Singular, which already has this implemented.

Something like


```
sage: R.<x,y,z,t> = QQ[]
sage: f = x^3 + y^3 +z^3+ t^3
sage: I = f.jacobian_ideal()
sage: IS = I._singular_()
sage: res = IS.mres(0)
sage: res
[1]:
   _[1]=t^2
   _[2]=z^2
   _[3]=y^2
   _[4]=x^2
[2]:
   _[1]=z^2*gen(1)-t^2*gen(2)
   _[2]=y^2*gen(1)-t^2*gen(3)
   _[3]=y^2*gen(2)-z^2*gen(3)
   _[4]=x^2*gen(1)-t^2*gen(4)
   _[5]=x^2*gen(2)-z^2*gen(4)
   _[6]=x^2*gen(3)-y^2*gen(4)
[3]:
   _[1]=y^2*gen(1)-z^2*gen(2)+t^2*gen(3)
   _[2]=x^2*gen(1)-z^2*gen(4)+t^2*gen(5)
   _[3]=x^2*gen(2)-y^2*gen(4)+t^2*gen(6)
   _[4]=x^2*gen(3)-y^2*gen(5)+z^2*gen(6)
[4]:
   _[1]=x^2*gen(1)-y^2*gen(2)+z^2*gen(3)-t^2*gen(4)
sage: len(res)
4
```


should give you a minimal free resolution of the logarithmic derivation module of every homogenous polynomial f, so it would be free iff len(res)<=2 .

For the  non homogenous case, one might need to work a little bit with the homogenization of the polynomial, but it can also be done.

Could you please compare the timings of your code with the singular method?


---

Comment by mmarco created at 2016-01-29 12:53:51

Another question: is this granted to work for non crystalographic arrangements?


---

Comment by tscrim created at 2016-01-29 15:12:11

Replying to [comment:11 mmarco]:
> Another question: is this granted to work for non crystalographic arrangements?

Barakat and Cuntz say explicitly at the beginning of Section 6 "free _central_ arrangement". So it works well beyond inversion arrangements.

Replying to [comment:10 mmarco]:
> I have just given a very quick look at the code, but it seems to me that you are actually computing a free resolution of the logarithmic derivation module. Or at least the first steps of it. Is that correct?

From some quick Googling (your paper no less) and my (relatively small) understanding of this area of math, I believe so.

> If this is the case, maybe it would be worth doing so by using Singular, which already has this implemented.

I am not surprised, but a lot of Singular does not seem to be (well) exposed with good interface classes. (Actually, AFAIK this is the first implementation of a not-necessarily-free module in Sage.) I came across Singular's free resolution code after I had made this, but I was lazy. This did what I wanted and I didn't want to figure out the Singular interface and write the wrappers.

> Something like
> {{{
> sage: R.<x,y,z,t> = QQ[]
> sage: f = x^3 + y^3 +z^3+ t^3
> sage: I = f.jacobian_ideal()
> sage: IS = I._singular_()
> sage: res = IS.mres(0)
> sage: len(res)
> 4
> }}}
> should give you a minimal free resolution of the logarithmic derivation module of every homogenous polynomial f, so it would be free iff len(res)<=2 .
> 
> For the non homogenous case, one might need to work a little bit with the homogenization of the polynomial, but it can also be done.
> 
> Could you please compare the timings of your code with the singular method?

I am all but certain your code works faster when the arrangement is not free. I could (should) optimize my code by doing a backtracking algorithm too; at least that would make it a more fair comparison. On my next push, I will include an option for both algorithms.


---

Comment by mmarco created at 2016-01-29 16:13:42

Yes, we should probably write some parent class for these kinds of modules. And maybe also one for resolutions. Maybe a good fit for GSoC?


---

Comment by tscrim created at 2016-01-29 16:32:06

Replying to [comment:14 mmarco]:
> Yes, we should probably write some parent class for these kinds of modules. And maybe also one for resolutions. Maybe a good fit for GSoC?

I agree, and also another (strongly correlated) one would be exposing more from Singular. I would also be willing to (help) mentor this project too.


---

Comment by mmarco created at 2016-01-29 16:46:40

I added a draft of the proposal to the wiki in https://wiki.sagemath.org/GSoC/2016 . Feel free to modify it.


---

Comment by git created at 2016-01-29 19:52:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-01-29 19:53:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-01-29 19:59:42

The Singular code rips my implementation to shreads. It at least 2x faster (often times much more so) in the cases I tested (inversion arrangements for types A<sub>3</sub> and B<sub>3</sub>), so I am making that the default. However, I am still using it to construct the basis, but if you know how to pull that from Singular's resolution, I would be happy to include that as well.

I implemented by backtracking in a recursive fashion since I didn't want to deal with managing my own stack, and if you're doing something with 1000 hyperplanes (reaching Python's recursion depth limit), then you are probably better off waiting for the universe to implode. It is possible there are further optimizations to be done with that code, but since Singular does the biggest thing, checking for freeness, really fast, I'm inclined to leaving it alone for now.


---

Comment by mmarco created at 2016-01-29 23:21:59

Hmmm, usually when I want to compute a basis I do so by taking the syzygy module of the jacobian ideal of the polynomial. This procedure has always given me a basis, but now I am not sure if it is granted to work always.

Let me think about it for a few days.


---

Comment by tscrim created at 2016-01-30 01:22:35

Replying to [comment:20 mmarco]:
> Hmmm, usually when I want to compute a basis I do so by taking the syzygy module of the jacobian ideal of the polynomial. This procedure has always given me a basis, but now I am not sure if it is granted to work always.

I am pretty sure you're right. I will add this and check.


---

Comment by mmarco created at 2016-01-30 12:55:32

If you add this method, unless you have a proof that grants to get the correct result, there should be a check. Saito criterion seems like the fastest way to check if something is a basis. That way we can fall back to other implementation if this happen to fail.


---

Comment by tscrim created at 2016-02-02 17:00:18

Actually, from my testing using inversion arrangements, the syzygy module often results in a non-square matrix (even after passing it through `less_generators`). So I don't think this is a viable method. I did push the code to the branch

```
u/tscrim/check_free_with_basis-19595
```

if you want to take a look (and I'm not sure if I got Saito's criterion correct either).

Perhaps we should just include this as-is for now and do a follow-up ticket for finding a faster way to construct the basis?


---

Comment by mmarco created at 2016-02-02 17:11:10

There is a singular command called mstd, that produces a minimal set of generators of an ideal of module. Try something like:


```
sage: H.<x,y,z> = HyperplaneArrangements(QQ)
sage: A = H( x-z, y-z, x+y, x+z, y+z, x, y, z)
sage: f = A.defining_polynomial()
sage: I = f + f.jacobian_ideal()
sage: IS = I._singular_()
sage: ISS = IS.syz()
sage: MSTD = ISS.mstd()
sage: M = MSTD[2]._sage_().transpose().submatrix(0,1)
sage: M
[                              x                               y                               z]
[                              0                     x^2*y - y^3                     x^2*z - z^3]
[                              0 x*y^3 + y^4 - x*y*z^2 - y^2*z^2                               0]
sage: M.determinant()/f
-1
```



---

Comment by git created at 2016-02-02 17:22:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-02-02 17:24:36

That worked very well. As a safety precaution, I had it fallback to the Barakat-Cuntz algorithm if the Singular method failed to produce a basis but the arrangement was determined to be free.


---

Comment by git created at 2016-02-02 18:23:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2016-02-02 18:32:41

In some point (either the methods of the arrangement class, or the auxilar functions they call) there should be a check that the arrangement is central. Otherwise all these algorithms might not make sense. Right now things might fail at the `to_symmetric_space` function, but a more informative error would be nice. I am adding it now.


Otherwise, it looks good. Let me pass the testsuite and check that the documentation builds correctly, and, if you are ok with my corrections, we can call it a day.

----
New commits:


---

Comment by git created at 2016-02-02 18:35:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-02-02 19:13:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-02-02 19:16:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-02-02 19:18:16

That is good with me. I made some other little tweaks:

- Since we are removing the trailing whitespace, I changed the indentation to make things easier to read.
- I made the errors Python3 compatible and capitalized correctly (since they are not full sentences).

If you're happy with my changes, then positive review.

Thank you for doing the review.


---

Comment by mmarco created at 2016-02-03 08:15:47

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-02-03 08:22:55

Merge conflict, wait for the next beta...


---

Comment by vbraun created at 2016-02-03 08:22:55

Changing status from positive_review to needs_work.


---

Comment by git created at 2016-02-03 15:36:40

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by tscrim created at 2016-02-03 15:38:09

Changing status from needs_work to positive_review.


---

Comment by tscrim created at 2016-02-03 15:38:09

I looked at and merged in any ticket that was closed or on positive review that could have had a conflict with this one. Can you check again to see if this merges with your beta branch?


---

Comment by git created at 2016-02-05 15:50:30

Changing status from positive_review to needs_review.


---

Comment by git created at 2016-02-05 15:50:30

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by tscrim created at 2016-02-05 15:51:48

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-02-05 19:32:33

Changing status from positive_review to needs_info.


---

Comment by vbraun created at 2016-02-05 19:32:33

There was no conflict, but you changed the branch anyways. Why?


---

Comment by tscrim created at 2016-02-05 19:40:16

Because it showed up as red on trac, and I wanted to make sure there would be no conflict with your branch.


---

Comment by tscrim created at 2016-02-05 19:40:16

Changing status from needs_info to positive_review.


---

Comment by vbraun created at 2016-02-05 21:31:52

Please don't make changes to positively-reviewed tickets unless there is a real issue next time. If you don't get a conflict while merging then do not push.


---

Comment by vbraun created at 2016-02-06 21:00:30

Resolution: fixed
