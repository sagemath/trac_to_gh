# Issue 24141: Doctest failures related to sympy

Issue created by migration from https://trac.sagemath.org/ticket/24378

Original creator: jdemeyer

Original creation time: 2017-12-15 09:38:20

CC:  rws charpent

On two patchbots which have many optional packages installed:

```
sage -t --long src/sage/functions/other.py
**********************************************************************
File "src/sage/functions/other.py", line 2862, in sage.functions.other.Function_crootof
Failed example:
    c.n()
Exception raised:
    Traceback (most recent call last):
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 517, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 920, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.functions.other.Function_crootof[1]>", line 1, in <module>
        c.n()
      File "sage/structure/element.pyx", line 865, in sage.structure.element.Element.n (build/cythonized/sage/structure/element.c:8131)
        return self.numerical_approx(prec, digits, algorithm)
      File "sage/symbolic/expression.pyx", line 5824, in sage.symbolic.expression.Expression.numerical_approx (build/cythonized/sage/symbolic/expression.cpp:36286)
        x = x._convert(kwds)
      File "sage/symbolic/expression.pyx", line 1259, in sage.symbolic.expression.Expression._convert (build/cythonized/sage/symbolic/expression.cpp:10663)
        res = self._gobj.evalf(0, kwds)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/functions/other.py", line 2920, in _evalf_
        sobj = CRootOf(Poly(poly._sympy_()), int(index))
      File "sage/rings/complex_number.pyx", line 1058, in sage.rings.complex_number.ComplexNumber.__int__ (build/cythonized/sage/rings/complex_number.c:10918)
        raise TypeError("can't convert complex to int; use int(abs(z))")
    TypeError: can't convert complex to int; use int(abs(z))
**********************************************************************
File "src/sage/functions/other.py", line 2864, in sage.functions.other.Function_crootof
Failed example:
    c.n(100)
Exception raised:
    Traceback (most recent call last):
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 517, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 920, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.functions.other.Function_crootof[2]>", line 1, in <module>
        c.n(Integer(100))
      File "sage/structure/element.pyx", line 865, in sage.structure.element.Element.n (build/cythonized/sage/structure/element.c:8131)
        return self.numerical_approx(prec, digits, algorithm)
      File "sage/symbolic/expression.pyx", line 5824, in sage.symbolic.expression.Expression.numerical_approx (build/cythonized/sage/symbolic/expression.cpp:36286)
        x = x._convert(kwds)
      File "sage/symbolic/expression.pyx", line 1259, in sage.symbolic.expression.Expression._convert (build/cythonized/sage/symbolic/expression.cpp:10663)
        res = self._gobj.evalf(0, kwds)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/functions/other.py", line 2920, in _evalf_
        sobj = CRootOf(Poly(poly._sympy_()), int(index))
      File "sage/rings/complex_number.pyx", line 1058, in sage.rings.complex_number.ComplexNumber.__int__ (build/cythonized/sage/rings/complex_number.c:10918)
        raise TypeError("can't convert complex to int; use int(abs(z))")
    TypeError: can't convert complex to int; use int(abs(z))
**********************************************************************
File "src/sage/functions/other.py", line 2866, in sage.functions.other.Function_crootof
Failed example:
    (c^6 + c + 1).n(100) < 1e-25
Exception raised:
    Traceback (most recent call last):
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 517, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 920, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.functions.other.Function_crootof[3]>", line 1, in <module>
        (c**Integer(6) + c + Integer(1)).n(Integer(100)) < RealNumber('1e-25')
      File "sage/structure/element.pyx", line 865, in sage.structure.element.Element.n (build/cythonized/sage/structure/element.c:8131)
        return self.numerical_approx(prec, digits, algorithm)
      File "sage/symbolic/expression.pyx", line 5824, in sage.symbolic.expression.Expression.numerical_approx (build/cythonized/sage/symbolic/expression.cpp:36286)
        x = x._convert(kwds)
      File "sage/symbolic/expression.pyx", line 1259, in sage.symbolic.expression.Expression._convert (build/cythonized/sage/symbolic/expression.cpp:10663)
        res = self._gobj.evalf(0, kwds)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/functions/other.py", line 2920, in _evalf_
        sobj = CRootOf(Poly(poly._sympy_()), int(index))
      File "sage/rings/complex_number.pyx", line 1058, in sage.rings.complex_number.ComplexNumber.__int__ (build/cythonized/sage/rings/complex_number.c:10918)
        raise TypeError("can't convert complex to int; use int(abs(z))")
    TypeError: can't convert complex to int; use int(abs(z))
**********************************************************************
File "src/sage/functions/other.py", line 2908, in sage.functions.other.Function_crootof._evalf_
Failed example:
    complex_root_of(x^2-2, 1).n()
Exception raised:
    Traceback (most recent call last):
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 517, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 920, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.functions.other.Function_crootof._evalf_[0]>", line 1, in <module>
        complex_root_of(x**Integer(2)-Integer(2), Integer(1)).n()
      File "sage/structure/element.pyx", line 865, in sage.structure.element.Element.n (build/cythonized/sage/structure/element.c:8131)
        return self.numerical_approx(prec, digits, algorithm)
      File "sage/symbolic/expression.pyx", line 5824, in sage.symbolic.expression.Expression.numerical_approx (build/cythonized/sage/symbolic/expression.cpp:36286)
        x = x._convert(kwds)
      File "sage/symbolic/expression.pyx", line 1259, in sage.symbolic.expression.Expression._convert (build/cythonized/sage/symbolic/expression.cpp:10663)
        res = self._gobj.evalf(0, kwds)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/functions/other.py", line 2920, in _evalf_
        sobj = CRootOf(Poly(poly._sympy_()), int(index))
      File "sage/rings/complex_number.pyx", line 1058, in sage.rings.complex_number.ComplexNumber.__int__ (build/cythonized/sage/rings/complex_number.c:10918)
        raise TypeError("can't convert complex to int; use int(abs(z))")
    TypeError: can't convert complex to int; use int(abs(z))
**********************************************************************
2 items had failures:
   3 of   5 in sage.functions.other.Function_crootof
   1 of   3 in sage.functions.other.Function_crootof._evalf_
    [622 tests, 4 failures, 17.27 s]  
sage -t --long src/sage/interfaces/sympy.py
**********************************************************************
File "src/sage/interfaces/sympy.py", line 617, in sage.interfaces.sympy._sympysage_crootof
Failed example:
    (sols[0]+1)._sage_().n()
Exception raised:
    Traceback (most recent call last):
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 517, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 920, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.interfaces.sympy._sympysage_crootof[6]>", line 1, in <module>
        (sols[Integer(0)]+Integer(1))._sage_().n()
      File "sage/structure/element.pyx", line 865, in sage.structure.element.Element.n (build/cythonized/sage/structure/element.c:8131)
        return self.numerical_approx(prec, digits, algorithm)
      File "sage/symbolic/expression.pyx", line 5824, in sage.symbolic.expression.Expression.numerical_approx (build/cythonized/sage/symbolic/expression.cpp:36286)
        x = x._convert(kwds)
      File "sage/symbolic/expression.pyx", line 1259, in sage.symbolic.expression.Expression._convert (build/cythonized/sage/symbolic/expression.cpp:10663)
        res = self._gobj.evalf(0, kwds)
      File "/home/patchbot/sage-patchbot/local/lib/python2.7/site-packages/sage/functions/other.py", line 2920, in _evalf_
        sobj = CRootOf(Poly(poly._sympy_()), int(index))
      File "sage/rings/complex_number.pyx", line 1058, in sage.rings.complex_number.ComplexNumber.__int__ (build/cythonized/sage/rings/complex_number.c:10918)
        raise TypeError("can't convert complex to int; use int(abs(z))")
    TypeError: can't convert complex to int; use int(abs(z))
**********************************************************************
1 item had failures:
   1 of   8 in sage.interfaces.sympy._sympysage_crootof
    [218 tests, 1 failure, 3.27 s]
```



---

Comment by rws created at 2017-12-15 10:05:39

That exact arguments are made inexact is a bug in itself. But that they are made complex (EDIT: in some machines) is beyond me.
----
New commits:


---

Comment by rws created at 2017-12-15 10:05:39

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-12-15 10:29:48

Do you have an idea why this depends on the system?


---

Comment by jdemeyer created at 2017-12-15 10:52:08

Replying to [comment:4 rws]:
> That exact arguments are made inexact is a bug in itself. But that they are made complex (EDIT: in some machines) is beyond me.

Do you know where this happens? It seems to me that it is Pynac doing this.


---

Comment by vdelecroix created at 2017-12-15 11:07:51

Some sympy behavior depends on the presence/absence of gmpy2. We had this trouble before the upgrade.


---

Comment by jdemeyer created at 2017-12-15 11:14:15

Replying to [comment:4 rws]:
> That exact arguments are made inexact is a bug in itself.

Right, this ticket should just fix that.


---

Comment by jdemeyer created at 2017-12-15 11:14:20

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-12-15 11:22:39

Replying to [comment:10 jdemeyer]:
> Replying to [comment:4 rws]:
> > That exact arguments are made inexact is a bug in itself.
> 
> Right, this ticket should just fix that.

Indeed `numerical_approximation` of symbolic expression is lazily converting all arguments to the same parent. Which is very wrong when a function is defined on `R x N`.

Perhaps it would be good to add in `_evalf_` the check

```
if not isinstance(index, numbers.Integral):
    raise ValueError
```


Though I am curious about this sympy misbehavior.


---

Comment by vdelecroix created at 2017-12-15 11:39:04

Indeed there is a sympy bug that is now tracked at #24380.


---

Comment by vdelecroix created at 2017-12-15 11:40:25

`numerical_approx` is very wrong when evaluating. It converts `x^2 - 2` to `x^2 - 2.0` and hence loosing precision for no good reason.


---

Comment by vdelecroix created at 2017-12-15 14:09:38

There was indeed a bug in sympy: #24380 needs review!


---

Comment by rws created at 2017-12-16 08:31:52

I suggest accepting my quick fix to resolve the blocker. Meanwhile I'm looking into Pynac.


---

Comment by jdemeyer created at 2017-12-16 08:40:45

If your only goal is to resolve the blocker doctest failures, then I think it is better to use `# known bug`. The fact that the index is made floating-point is the real bug, whether it is real or complex is just a small variation.


---

Comment by rws created at 2017-12-16 09:07:38

Replying to [comment:17 vdelecroix]:
> `numerical_approx` is very wrong when evaluating. It converts `x^2 - 2` to `x^2 - 2.0` and hence loosing precision for no good reason.

I disagree in this case. The result is exactly what was asked for.


---

Comment by vdelecroix created at 2017-12-16 09:18:28

Replying to [comment:21 rws]:
> Replying to [comment:17 vdelecroix]:
> > `numerical_approx` is very wrong when evaluating. It converts `x^2 - 2` to `x^2 - 2.0` and hence loosing precision for no good reason.
> 
> I disagree in this case. The result is exactly what was asked for.

The problem under discussion is that you have a number specified by an equation like `x^2 - 2 = 0`. Now, you want an numerical approximation of it. I claim that there is not much reason to transform the equation into `1.0 * x^2 - 2.0` for doing that. In particular, this is *not* what the user wants. This kind of conversion is a can of worms. If you want 100 bits of your number, and start by converting the coefficients to floating points with 100 bits of precision you might loose your roots.

Note that in sympy they solve the original equation with appropriate root finding algorithms on rational numbers.


---

Comment by rws created at 2017-12-16 09:42:06

Replying to [comment:22 vdelecroix]:
> Replying to [comment:21 rws]:
> > Replying to [comment:17 vdelecroix]:
> > > `numerical_approx` is very wrong when evaluating. It converts `x^2 - 2` to `x^2 - 2.0` and hence loosing precision for no good reason.
> > 
> > I disagree in this case. The result is exactly what was asked for.
> 
> The problem under discussion is that you have a number specified by an equation like `x^2 - 2 = 0`. Now, you want an numerical approximation of it.

No, that is solving. `N()` just converts symbolic expressions---if they happen to contain symbols you won't get a number, you get an error. `_convert()` helps with that.

> Note that in sympy they solve the original equation with appropriate root finding algorithms on rational numbers.

This has nothing to do with this ticket. This ticket is about losing precision in expressions that can be FP evaluated because they contain no symbols but may contain functions. While the result precision from the function at hand `complex_root_of` is in principle not affected by the exactness of the index there may be existing/future functions where it is. This can be fixed by not FP converting exact function arguments and letting the function itself (i.e. its `evalf` member) decide what to do with exact arguments. I may well be wrong, and the best solution instead is a type database for function arguments...


---

Comment by rws created at 2017-12-16 09:47:13

Replying to [comment:22 vdelecroix]:
> Note that in sympy they solve the original equation with appropriate root finding algorithms on rational numbers.

Yes but we don't do the solving. We let SymPy do it.


---

Comment by rws created at 2017-12-17 06:52:53

Changing status from needs_work to needs_review.


---

Comment by rws created at 2017-12-17 06:53:26

New commits:


---

Comment by rws created at 2017-12-17 07:18:08

See #24397 for the fix.


---

Comment by jdemeyer created at 2017-12-17 08:41:38

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-12-17 08:41:38

You should add the ticket number: `# known bug (Trac #24397)`.


---

Comment by git created at 2017-12-17 14:13:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2017-12-17 14:14:22

Changing status from needs_work to needs_review.


---

Comment by rws created at 2017-12-17 15:17:44

Fortunately this can be resolved easily.
----
New commits:


---

Comment by rws created at 2017-12-17 15:30:31

I have added the information to https://github.com/pynac/pynac/wiki/%7C-floating-point-evaluation, but Sage `Function` initialization options need better docs too.


---

Comment by jdemeyer created at 2017-12-17 20:49:01

If this fixes the actual underlying issue, could you add

```
sage: complex_root_of(x^8-1, 7).n(2)
```

as a doctest?


---

Comment by jdemeyer created at 2017-12-17 20:49:01

Changing status from needs_review to needs_work.


---

Comment by rws created at 2017-12-18 07:19:41

It fixes the issue but there are other problems at super-low precision.


---

Comment by git created at 2017-12-18 07:48:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2017-12-18 07:49:15

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-12-18 08:37:58

The expression `prec*3/10` will behave differently on Python 2 and Python 3. You should either use `//` or `from __future__ import division` such that it works the same on Python 2 and Python 3.


---

Comment by jdemeyer created at 2017-12-18 08:37:58

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-12-18 08:39:51

What is the meaning of the factor `3/10` anyway?


---

Comment by rws created at 2017-12-18 08:48:29

Replying to [comment:40 jdemeyer]:
> What is the meaning of the factor `3/10` anyway?

An approximation to `log(2,10)` (EDITED) which is good enough until about 1000 bits precision.


---

Comment by jdemeyer created at 2017-12-18 08:53:40

Replying to [comment:41 rws]:
> Replying to [comment:40 jdemeyer]:
> > What is the meaning of the factor `3/10` anyway?
> 
> An approximation to `log(2,10)` (EDITED) which is good enough until about 1000 bits precision.

Then why don't use the actual value `0.3010299956639812`? That avoids the problem with division also.


---

Comment by git created at 2017-12-18 09:00:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2017-12-18 09:00:47

Changing status from needs_work to needs_review.


---

Comment by rws created at 2017-12-20 14:01:19

Ping?


---

Comment by vdelecroix created at 2017-12-21 16:25:10

`ceil(prec*log(2,10)))` is terrible. Why not using `0.3010299956639812` as suggested in [This is the Trac macro *comment:42* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:42-macro)? A possible alternative would be

```
from math import log10
int(prec * log10(2))
```

You definitely do not want to use two symbolic functions here.


---

Comment by git created at 2017-12-22 06:01:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-12-22 22:02:22

Or better yet, use the sympy function `prec_to_dps` which is meant to convert bits to digits:

```
from sympy.core.evalf import prec_to_dps
```



---

Comment by rws created at 2017-12-23 06:16:47

Thanks both. I'll make a fresh branch.


---

Comment by rws created at 2017-12-23 07:21:26

A minor note is that the results from `prec_dps(n)` are not identical to the previously proposed formulae at small values, even with a suitable shift.
----
New commits:


---

Comment by jdemeyer created at 2017-12-23 09:48:48

Good for me if this passes patchbot testing.


---

Comment by rws created at 2017-12-24 06:14:51

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-12-26 09:25:47

Resolution: fixed
