# Issue 28150: Implement function that returns the balanced digit representation of an integer

Issue created by migration from https://trac.sagemath.org/ticket/28387

Original creator: @sheareralexj

Original creation time: 2019-08-22 22:01:20

This ticket adds the balanced_digits function, returning the digit representation of an integer where the digits are centered at 0. For example, this enables:

```
sage: 8.balanced_digits(3)
[-1, 0, 1]
```


```
sage: 33.balanced_digits(6)
[3, -1, 1]
```




---

Comment by @sheareralexj created at 2019-08-22 22:57:10

Changing status from new to needs_review.


---

Comment by @sheareralexj created at 2019-08-22 22:57:10

New commits:


---

Comment by bruno created at 2019-08-23 10:31:32

Changing status from needs_review to needs_work.


---

Comment by bruno created at 2019-08-23 10:31:32

That's a good idea to add this. I've a few comments on your implementation though. 

## Incorrect algorithm?

First, it is not clear to me (so the docstring should be adapted) what is the exact specification. I would say that the balanced base `b` uses `b` digits centered around zero. Thus if `b` is odd, there is only one possibility, namely digits between `-b//2` and `b//2` (both included). For instance in base 9, one uses digits from -4 to 4. If `b` is even, one has to choose between digits from `-b//2` to `b//2-1` or `-b//2+1` to `b//2` (base 10 for instance: either -5 to 4 or -4 to 5), and this is defined by the value of `positive_shift`. Is that we you have in mind? Note that in this case, your implementation has a problem:

```python
sage: n = -46
sage: n.balanced_digits(10) # correct
[4, -5]
sage: n.balanced_digits(10, positive_shift=True) # should be [4, 5, -1]
[4, -5]
```


I think that a correct algorithm (if my specification in the one you have in mind) would be easier to write using a "balanced `quo_rem`" that on input `a` and `b` returns `(q, r)` such that `a = b*q + r` with `-b//2 <= r <= b//2` (with the same subtleties for even bases). This could go as follows:

```python
def balanced_quo_rem(self, right, positive_shift=True):
    q, r = self.quo_rem(right)
    if r > right//2:
        return (q+1, r-right)
    if right % 2 == 0 and not positive_shift and r == right//2:
        return (q+1, r-right)
    return (q, r)
```


Then the algorithm could be implemented as (I just put the main idea):


```python
def balanced_digits(self, base, positive_shift=True):
    digits = []
    n = self
    while n > 0:
        q, r = n.balanced_quo_rem(base, positive_shift)
        digits.append(r)
        n = q
    return digits
```



## Other remarks

Below, I indicate a few general comments on your current implementation (and the docstring, tests, etc.), though it should be changed anyway.

#### In the docstring

1. There should not be a blank line as first line;
1. It should be "Return" rather than "Returns" (as mentioned in [the doc](http://doc.sagemath.org/html/en/developer/coding_basics.html#the-docstring-of-a-function-content));
1. Following the doc also, I would put a blank line between the first sentence ("Return ... given base") and the rest of the specification;
1. I would write "Return **the** list of balanced digits" rather than "Return a list of balanced digit" (since there is uniqueness);
1. You should replace `b/2` by `b//2` in the docstring to indicate a floor division (if the base is odd);
1. Your `::` alone on a line should be replaced by `TESTS::`;
1. You should write a more precise specification more generally.

#### In the code itself

1. I think that having `base = 10` as default would be a good idea, to be consistent with `n.digits()` for instance (should be then mentioned in the doc obviously);
1. You may raise an `Exception` if the base is not an integer (and add an `EXAMPLE` for this). Something like:
   {{{#!python
if isinstance(base, Integer): 
    _base = base
else:
    try:
        _base = Integer(base)
    except TypeError:
        raise ValueError('base should be an integer')
   }}}
1. You should not use `floor(b/2)`, but rather `b//2`;
1. You may compute `self_abs` and `neg` as follows: `self_abs, neg = self.abs(), self.sign()`


---

Comment by bruno created at 2019-08-23 11:32:16

Actually, there is another (simpler?) algorithm:

1. First compute the classical base `b` representation of the input integer `n`;
2. Scan the digits from low to high order, and if a digit `d` is larger than `b//2`, replace `d` by `d-b` and remove one to the next digit. 

You still have to manage the subtlety for even bases but that's not a big deal. Also, the two-step algorithm I mention works for nonnegative integers. For negative integers, do the same with `abs(n)` and take the opposite of all digits. For even bases, you have to do it with `not positive shift`.


---

Comment by @sheareralexj created at 2019-08-23 17:41:57

Thanks for reviewing, and thanks for finding the error! Yeah, it seems the issue is that the code is handling negatives incorrectly. Today  I'll work at fixing this as well as implementing your other suggestions and algorithms.

Thanks!


---

Comment by git created at 2019-08-24 02:19:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @sheareralexj created at 2019-08-24 02:25:14

I updated the code and used the documentation you suggested. I tested the runtime on all three algorithms and went with the last one (using the standard n.digits(b) function) as it worked fastest for large bases.


---

Comment by @sheareralexj created at 2019-08-24 02:25:24

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2019-08-26 09:51:45

Changing status from needs_review to needs_work.


---

Comment by bruno created at 2019-08-26 09:51:45

The new version is much better indeed! I still have a two remarks:

- The case `base = 2` is problematic. Depending on `positive_shift` it can only represent nonnegative or nonpositive integers. The simplest way to deal with it is probably to impose that `base > 2`.

- I would add some details in the docstring for the parameter `positive_shift`. In the block `INPUT`, you may write something like "For even bases, the representation uses digits from `-b//2 + 1` to `b//2` if set to True, and from `-b//2` to `b//2-1` otherwise. This has no effect for odd bases."


---

Comment by git created at 2019-08-26 19:40:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @sheareralexj created at 2019-08-26 19:44:01

Awesome, made those two edits. Thank you much.


---

Comment by @sheareralexj created at 2019-08-26 19:44:01

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2019-08-27 08:12:44

Changing status from needs_review to positive_review.


---

Comment by bruno created at 2019-08-27 08:12:44

That's fine for me!

A side note: It is usually not needed (nor advised) to merge new versions in a branch. As long as the merge automatically works¹, it is fine. The history is simpler to read if there aren't several merges.

¹ This is showed by the color of the link to the branch in the description: Green is OK, red is NOT OK, orange means NOT TESTED and you just need to click the link for trac to try the merge (and change the color accordingly).


---

Comment by vbraun created at 2019-09-02 21:40:41

Resolution: fixed
