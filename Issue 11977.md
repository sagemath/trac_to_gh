# Issue 11977: float('nan')>1 crashes Sage.

Issue created by migration from https://trac.sagemath.org/ticket/12149

Original creator: was

Original creation time: 2011-12-13 05:08:19

Assignee: AlexGhitza

The optimizations in #10314 ignored the fact that floating point numbers can be nan, which leads to it being trivial to completely crash Sage.  I ran into exactly this when doing real work, so I'm annoyed. 


```
sage: float('nan') > 1

Program received signal SIGFPE, Arithmetic exception.
0x00007fff89c3b82a in __kill ()
(gdb) bt
#0  0x00007fff89c3b82a in __kill ()
#1  0x00000001013c530e in __gmp_invalid_operation ()
#2  0x00000001013cf579 in __gmpz_cmp_d ()
#3  0x00000001035fd09e in __pyx_pf_4sage_5rings_7integer_7Integer_7__richcmp__ (__pyx_v_left=0x5bd7, __pyx_v_right=0x10b2a0470, __pyx_v_op=0) at integer.c:7855
```


The traceback points to this code integer.pyx:

```
            elif PyFloat_CheckExact(left):
                c = -mpz_cmp_d((<Integer>right).value, PyFloat_AsDouble(left))
```


There is similar code a few lines down for the other direction, hence this also crashes

```
sage: 1 < float('nan')
Unhandled SIGFPE:
```



---

Comment by was created at 2011-12-13 05:38:02

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2011-12-13 08:10:47

One can be more careful by adding `sig_on()`/`sig_off()`: [http://sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling](http://sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling).  I'm not saying one should, I'll leave that to the author of this ticket.


---

Comment by was created at 2011-12-13 08:18:50

Replying to [comment:2 jdemeyer]:
> One can be more careful by adding `sig_on()`/`sig_off()`: [http://sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling](http://sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling). 
>  I'm not saying one should, I'll leave that to the author of this ticket.

To me, using signal handling instead of simply checking whether or not the float is a nan (using isfinite) is a much worse solution to this problem.    Do you think otherwise, and if so, why?


---

Comment by jdemeyer created at 2011-12-13 08:40:40

Replying to [comment:3 was]:
> To me, using signal handling instead of simply checking whether or not the float is a nan (using isfinite) is a much worse solution to this problem.    Do you think otherwise, and if so, why?
I was not proposing it as a solution to this problem, just to add the signal handling in addition as an extra safeguard.

Ideally there would have been `sig_on()`/`sig_off()` already, such that this ticket would say:

```
sage: float('nan') > 1
Tracback (most recent call last):
...
RuntimeError: Floating Point Error
```

which doesn't crash Sage.


---

Comment by SimonKing created at 2011-12-13 09:23:30

`float('nan')` does not result in an error. Comparison must not result in an error, according to Python specifications, if I remember correctly.

Hence, using sigon/sigoff seems the wrong thing to do, because of the raised floating point error. In addition: Wouldn't sigon/sigoff slow the code down? I don't know by how much, though.


---

Comment by jdemeyer created at 2011-12-13 09:33:48

Replying to [comment:5 SimonKing]:
> Hence, using sigon/sigoff seems the wrong thing to do
Within Cython code, sig_on/sig_off is *never* the wrong thing to do.  It might be unneeded, might slow things down, but it is never wrong.

> Wouldn't sigon/sigoff slow the code down?
Yes, it would.  Typically, the slowdown is in the 10ns~20ns range which is very little unless it's done in a tight loop.


---

Comment by SimonKing created at 2011-12-13 09:52:25

Replying to [comment:6 jdemeyer]:
> Replying to [comment:5 SimonKing]:
> > Hence, using sigon/sigoff seems the wrong thing to do
> Within Cython code, sig_on/sig_off is *never* the wrong thing to do.

OK, let me rephrase it: It is wrong to use sig_on/sig_off in comparison code without "try-except". And, if I am not mistaken, "try-except" adds another small overhead. I presume that comparison occurs very frequently in many applications, and thus I'd go for speed.

That's to say: We should test both versions, William's and the "try-sigon-sigoff-except" version, and compare timings.


---

Comment by SimonKing created at 2011-12-13 10:06:48

I tried

```
                try:
                    sig_on()
                    c = mpz_cmp_d((<Integer>left).value, PyFloat_AsDouble(right))
                    sig_off()
                except RuntimeError:
                    sig_off()
                    return False
```

but when I test it, then the error is not silently caught. Instead, I get:

```
sage: a = float('nan'); b = 1 
sage: a<b, a>b, b<a, b>a 
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libcsage.so(print_backtrace+0x31)[0x7fdb346132d0]
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libcsage.so(_sig_off_warning+0x6f)[0x7fdb34613050]
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/python2.6/site-packages/sage/rings/integer.so(+0x2a0ba)[0x7fdb2ca390ba]
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libpython2.6.so.1.0(PyObject_RichCompare+0x61)[0x7fdb39c538b1]
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libpython2.6.so.1.0(PyEval_EvalFrameEx+0x3355)[0x7fdb39cb11d5]
...
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libpython2.6.so.1.0(PyRun_FileExFlags+0xb0)[0x7fdb39cd4c90]
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libpython2.6.so.1.0(PyRun_SimpleFileExFlags+0xdc)[0x7fdb39cd4e5c]
/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/local/lib/libpython2.6.so.1.0(Py_Main+0xb36)[0x7fdb39ce2186]
/lib/libc.so.6(__libc_start_main+0xfd)[0x7fdb38fe0c4d]
python[0x400699]
(False, False, False, False)
```


What did I do wrong?


---

Comment by jdemeyer created at 2011-12-13 10:38:47

Replying to [comment:8 SimonKing]:
> What did I do wrong?
You should not put the second `sig_off()`, see the example in [http://sagemath.org/doc/developer/coding_in_cython.html#using-sig-on-and-sig-off](http://sagemath.org/doc/developer/coding_in_cython.html#using-sig-on-and-sig-off)


---

Comment by jdemeyer created at 2011-12-13 10:40:08

Replying to [comment:7 SimonKing]:
> It is wrong to use sig_on/sig_off in comparison code without "try-except".
Why is that?


---

Comment by SimonKing created at 2011-12-13 10:55:53

Replying to [comment:10 jdemeyer]:
> Replying to [comment:7 SimonKing]:
> > It is wrong to use sig_on/sig_off in comparison code without "try-except".
> Why is that?

Because comparison in Python must not result in an error, if I remember correctly the Python specifications.

Here are timings, using `a = 1, b = 2, c = 1".

Vanilla sage-4.8.alpha3:

```
sage: timeit("a==b",number=10^5)
100000 loops, best of 3: 271 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 268 ns per loop
sage: timeit("a==x",number=10^5)
100000 loops, best of 3: 13.8 µs per loop
```


William's patch:

```
sage: timeit("a==b",number=10^5)
100000 loops, best of 3: 260 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 266 ns per loop
sage: timeit("a==x",number=10^5)
100000 loops, best of 3: 14.7 µs per loop
```


try-sigon-sigoff-except:

```
sage: timeit("a==b",number=10^5)
100000 loops, best of 3: 272 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 266 ns per loop
sage: timeit("a==x",number=10^5)
100000 loops, best of 3: 13.6 µs per loop
```


So, it is not really that much of a difference.


---

Comment by jdemeyer created at 2011-12-13 11:30:25

Replying to [comment:11 SimonKing]:
> Because comparison in Python must not result in an error, if I remember correctly the Python specifications.
So it's a minor issue about specifications, not a big deal.  Doing something against the Python specifications isn't an issue if you're trying to avoid complete crashes of Sage.

It's like airbags: sure, people might have hearing problems because of an airbag deployment, but that's a minor issue compared to what the airbag prevents.


---

Comment by SimonKing created at 2011-12-13 17:12:29

Replying to [comment:12 jdemeyer]:
> Replying to [comment:11 SimonKing]:
> > Because comparison in Python must not result in an error, if I remember correctly the Python specifications.
> So it's a minor issue about specifications, not a big deal.  Doing something against the Python specifications isn't an issue if you're trying to avoid complete crashes of Sage.

And what does that mean? Use William's patch, or a try-sig_on-sig_off-except patch?


---

Comment by was created at 2011-12-13 20:29:43

Replying to [comment:13 SimonKing]:
> Replying to [comment:12 jdemeyer]:
> > So it's a minor issue about specifications, not a big deal.  Doing something against the Python specifications isn't an issue if you're trying to avoid complete crashes of Sage.
> 
> And what does that mean? Use William's patch, or a try-sig_on-sig_off-except patch?

jdemeyer is remarking that as a general rule we should wrap code that might send SIGFPE signals  in sig_on/sig_off.    With the patch I've attached, I believe there is no possible way that the relevant code will ever send a SIGFPE signal.  For such code, it would make no sense at all to use sig_on/sig_off.

I think SimonKing's timings above are bogus, because you say that you use "a = 1, b = 2, c = 1", which are all integers, yet the relevant code path will only be hit if one operand is a Sage integer and the other is a Python float.   You need to test with a Sage integer, a Python float that isn't float('nan'), and also with one that is.  Probably your differences in timings are meaningless noise.   I wish timeout output both a mean and standard deviation, so one could tell whether comparisons are meaningful.


---

Comment by SimonKing created at 2011-12-13 20:58:34

Replying to [comment:14 was]:
> I think SimonKing's timings above are bogus, because you say that you use "a = 1, b = 2, c = 1", which are all integers, yet the relevant code path will only be hit if one operand is a Sage integer and the other is a Python float.

Oops, you're right, I didn't notice that your changes are in a code block where one operand is a Python float.


---

Comment by SimonKing created at 2011-12-13 21:10:19

Here are better timings (I hope):

Unpatched 4.8.alpha3:

```
sage: a = 1
sage: b = float(1)
sage: c = float(2.5)
sage: timeit("a==b",number=10^5)
100000 loops, best of 3: 320 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 323 ns per loop
```


With William's patch:

```
sage: a = 1
sage: b = float(1)
sage: c = float(2.5)
sage: d = float('nan')
sage: timeit("a==b",number=10^5)
100000 loops, best of 3: 336 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 333 ns per loop
sage: timeit("a==d",number=10^5)
100000 loops, best of 3: 281 ns per loop
```


With the sig_on/off alternative:

```
sage: a = 1
sage: b = float(1)
sage: c = float(2.5)
sage: d = float('nan')
sage: timeit("a==b",number=10^5)
100000 loops, best of 3: 369 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 369 ns per loop
sage: timeit("a==c",number=10^5)
100000 loops, best of 3: 369 ns per loop
sage: timeit("a==d",number=10^5)
100000 loops, best of 3: 3.92 µs per loop
```


I don't know the standard deviation of these timings (does "timeit" offer such statistics?) - when repeating the tests, I sometimes got 380 ns, not 369 ns.

But the timings seem to suggest that William's patch is 10% faster in the "number" case and is a lot faster in the "not a number" case.


---

Comment by was created at 2011-12-13 21:33:34

I think this is pretty definitive that in this particular case the best approach is to use isfinite instead of signals and exceptions.  Even in the non-exceptional case, the overhead of signals and exceptions exceeds that of just calling isfinite.


---

Comment by jdemeyer created at 2011-12-14 09:49:53

Replying to [comment:14 was]:
> jdemeyer is remarking that as a general rule we should wrap code that might send SIGFPE signals  in sig_on/sig_off.
Yes, that's what I meant.  I never said this code must be wrapped in `sig_on()`/`sig_off()`, just that you should be aware of this.  You thought about the possibility and decided not to add `sig_on()`/`sig_off()` which is a choice that can be defended.

By the way: it's almost impossible that simply adding `sig_on()`/`sig_off()` would make the execution time jump from 281ns to 3.92µs, so probably you did something wrong there.


---

Comment by SimonKing created at 2011-12-14 10:02:07

Replying to [comment:18 jdemeyer]:
> By the way: it's almost impossible that simply adding `sig_on()`/`sig_off()` would make the execution time jump from 281ns to 3.92µs, so probably you did something wrong there.

Don't forget the time for catching the error. My code looks like

```
               try:
                   sig_on()
                   c = mpz_cmp_d((<Integer>left).value, PyFloat_AsDouble(right))
                   sig_off()
               except RuntimeError:
                   return False
```

I doubt that this is obviously wrong, provided that we want to return "False" instead of letting the runtime error be raised.


---

Comment by was created at 2011-12-14 19:31:59

SimonKing -- could you please, please referee my patch?   You're the best person to do it at this point, since you've done the hard work of checking that it doesn't introduce a major speed regression etc.  It's only a few lines of code -- much less than you wrote just doing tests.  Thanks!!


---

Comment by SimonKing created at 2011-12-14 20:18:05

Replying to [comment:20 was]:
> SimonKing -- could you please, please referee my patch?

Sure! Right now I am preparing my talk for the Sage-Flint days, but I can certainly run the doc tests. And I think if they pass then we have a positive review, since we checked that the timings are fine and the patch looks fine, and (of course) the original problem is fixed.


---

Comment by SimonKing created at 2011-12-14 21:20:50

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-12-14 21:20:50

It needs work. I find the following errors:

```
$ ./sage -t -long devel/sage/sage/functions/min_max.py
sage -t -long "devel/sage/sage/functions/min_max.py"
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 22:
    sage: min_symbolic(3,5,x)
Expected:
    min(x, 3)
Got:
    min(x, inf)
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 74:
    sage: min_symbolic(3,5,x)
Expected:
    min(x, 3)
Got:
    min(x, inf)
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 78:
    sage: min_symbolic([3,5,x])
Expected:
    min(x, 3)
Got:
    min(x, inf)
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 237:
    sage: min_symbolic(3, x).subs(x=5)
Expected:
    3
Got:
    inf
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 239:
    sage: min_symbolic(3, 5, x)
Expected:
    min(x, 3)
Got:
    min(x, inf)
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 241:
    sage: min_symbolic([3,5,x])
Expected:
    min(x, 3)
Got:
    min(x, inf)
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 259:
    sage: t.subs(x=3) # indirect doctest
Expected:
    3
Got:
    inf
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 261:
    sage: min_symbolic(5,3)
Expected:
    3
Got:
    inf
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 265:
    sage: u.subs(x=-1)
Expected:
    -1
Got:
    0
**********************************************************************
File "/mnt/local/king/SAGE/rebase/sage-4.8.alpha3/devel/sage/sage/functions/min_max.py", line 269:
    sage: min_symbolic([3,x])
Expected:
    min(x, 3)
Got:
    min(x, inf)
**********************************************************************
4 items had failures:
   1 of   5 in __main__.example_0
   2 of  19 in __main__.example_1
   3 of   9 in __main__.example_5
   4 of  11 in __main__.example_6
***Test Failed*** 10 failures.
For whitespace errors, see the file /mnt/local/king/.sage/tmp/min_max_5906.py
         [2.4 s]
```



---

Comment by was created at 2011-12-15 01:07:20

Changing status from needs_work to needs_review.


---

Comment by was created at 2011-12-15 01:07:20

Simon -- nice find.  I've fixed the code to use isnan instead, so that the infinite comparison is still done by GMP (correctly).  Please referee again.


---

Comment by SimonKing created at 2011-12-15 06:22:07

Do we want this?

```
sage: 1==float('nan')
False
sage: 1!=float('nan')
False
```

I think One should differ from "not a number".


---

Comment by SimonKing created at 2011-12-15 06:57:31

PS:

```
sage: 1!=float('nan')
False
sage: float(1)!=float('nan')
True
```



---

Comment by SimonKing created at 2011-12-15 06:57:31

Changing status from needs_review to needs_work.


---

Attachment

apply *only* this (none above)


---

Comment by was created at 2011-12-15 20:23:03

Changing status from needs_work to needs_review.


---

Comment by was created at 2011-12-15 20:23:03

I've posted a new patch.


---

Comment by SimonKing created at 2011-12-15 20:57:21

Do we also want to fix the following inconsistency?

```
sage: float(1.1) < float('nan')
False
sage: 1.1 < float('nan')
True
```


If we want to fix it: Here, or on a different ticket?


---

Comment by was created at 2011-12-15 21:01:13

Replying to [comment:27 SimonKing]:
> Do we also want to fix the following inconsistency?
> {{{
> sage: float(1.1) < float('nan')
> False
> sage: 1.1 < float('nan')
> True
> }}}
> 
> If we want to fix it: Here, or on a different ticket?

Yes, we should fix that, but since the relevant code will be in a completely different file, I think it should *definitely* be a new ticket.  Please open one and post a link here.


---

Comment by SimonKing created at 2011-12-15 21:32:35

Replying to [comment:28 was]:
> Yes, we should fix that, but since the relevant code will be in a completely different file, I think it should *definitely* be a new ticket.  Please open one and post a link here. 

See #12160.


---

Comment by davidloeffler created at 2011-12-31 12:58:59

All doctests pass with this installed, and it fixes the crash. I don't want to tread on Simon's toes, but we should probably get this fixed quickly, so I'm going to give this a positive review.


---

Comment by davidloeffler created at 2011-12-31 12:58:59

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2012-01-03 08:49:21

Resolution: fixed
