# Issue 31755: FiniteRankFreeModuleMorphism: Add method SVD (singular value decomposition)

Issue created by migration from https://trac.sagemath.org/ticket/31992

Original creator: mkoeppe

Original creation time: 2021-06-16 17:30:36

CC:  egourgoulhon @mjungmath @honglizhaobob

This operation is currently available for matrices over `RDF`.

The version for `FiniteRankFreeModuleMorphism` would define a new basis on each of the domain and codomain (with an orthogonal change of basis) so that the matrix of the morphism in the new bases is the diagonal of the singular values.


---

Comment by @honglizhaobob created at 2021-07-05 21:23:26

Replying to [comment:1 mkoeppe]:

Sorry for asking a naive question... In the description, what does `RDF` refer to ("this operation is currently available for matrices over `RDF`")?


---

Comment by mkoeppe created at 2021-07-05 21:37:19

RDF is the "real double-precision field" - equivalent of `double` in C.
https://doc.sagemath.org/html/en/reference/rings_numerical/sage/rings/real_double.html


---

Comment by @honglizhaobob created at 2021-07-06 01:50:23

Replying to [comment:3 mkoeppe]:
> RDF is the "real double-precision field" - equivalent of `double` in C.
> https://doc.sagemath.org/html/en/reference/rings_numerical/sage/rings/real_double.html

Thanks professor. Additionally, in implementing the SVD, should we resort to external libraries such as `numpy`, or is it a better practice to use `sage` methods whenever possible?


---

Comment by @honglizhaobob created at 2021-07-06 02:36:39

If I'm understanding correctly after reading the code, we are still working with matrices (instead of high-dimensional tensors). Suppose `A` is the matrix obtained from `M.hom(N, some_matrix, basis=(e, f))`. Let `x.parent() == M`, `y.parent() == N`. Then we have:


```
y = A*x
y = U * S * V_dagger * x            # do SVD on A
(U_dagger * y) = S * (V_dagger * x) # invert U
y_prime = S*x_prime                 # renamed x and y
```


In code, we will reassign the default bases of `M` and `N`:

```
M._def_basis = V
N._def_basis = U                    # certainly, this reassignment needs more
                                    # work in terms of actual implementations
}}} 

such that `S` would be the result of `hom.matrix()` in this new basis.


---

Comment by mkoeppe created at 2021-07-06 03:44:55

Replying to [comment:4 gh-honglizhaobob]:
> in implementing the SVD, should we resort to external libraries such as `numpy`, or is it a better practice to use `sage` methods whenever possible?

In Sage we support a wide range of rings for the arithmetic, and consequently often use multiple libraries for the implementation and also have an in-Sage generic implementation.

The existing implementation of `SVD` in `src/sage/matrix/matrix_double_dense.pyx` just calls `scipy.linalg.svd`.

It would be quite useful to add a generic implementation that only uses the general methods that Sage matrices offer. In that way, we could have access to arbitrary precision and symbolic computations.

It would also be good to check what other libraries that we already use or could easily use also provide implementations of SVD.


---

Comment by @honglizhaobob created at 2021-07-06 06:37:12

Replying to [comment:6 mkoeppe]:
> Replying to [comment:4 gh-honglizhaobob]:
> > in implementing the SVD, should we resort to external libraries such as `numpy`, or is it a better practice to use `sage` methods whenever possible?
> 
> In Sage we support a wide range of rings for the arithmetic, and consequently often use multiple libraries for the implementation and also have an in-Sage generic implementation.
> 
> The existing implementation of `SVD` in `src/sage/matrix/matrix_double_dense.pyx` just calls `scipy.linalg.svd`.
> 
> It would be quite useful to add a generic implementation that only uses the general methods that Sage matrices offer. In that way, we could have access to arbitrary precision and symbolic computations.
> 
> It would also be good to check what other libraries that we already use or could easily use also provide implementations of SVD.

I think currently `SVD()` doesn't support other fields such as `ZZ`, or `QQ`. We may be restricted to `RDF` if we choose to use `matrix_double_dense.pyx`.


---

Comment by mkoeppe created at 2021-07-06 07:03:09

Yes, that's right -- and that's I think also exactly what `scipy.linalg.svd` provides. That's why I said that it will be good to check what other implementations are available in other software. A quick search for "arbitrary precision svd" did not lead me to good results though


---

Comment by @honglizhaobob created at 2021-07-06 07:24:16

Replying to [comment:8 mkoeppe]:
> Yes, that's right -- and that's I think also exactly what `scipy.linalg.svd` provides. That's why I said that it will be good to check what other implementations are available in other software. A quick search for "arbitrary precision svd" did not lead me to good results though

Could we consider symbolic SVD such as in MATLAB or `sympy`？ This way we can preserve the `QQ` structure, however I feel svd on `ZZ` will be a bit demanding..


---

Comment by mkoeppe created at 2021-07-06 12:51:06

Replying to [comment:9 gh-honglizhaobob]:
> Could we consider symbolic SVD such as in MATLAB or `sympy`？ This way we can preserve the `QQ` structure

Do you have an example or link that illustrates what you have in mind?


---

Comment by @honglizhaobob created at 2021-07-07 07:01:47

Replying to [comment:10 mkoeppe]:
> Replying to [comment:9 gh-honglizhaobob]:
> > Could we consider symbolic SVD such as in MATLAB or `sympy`？ This way we can preserve the `QQ` structure
> 
> Do you have an example or link that illustrates what you have in mind?

In `sympy`, by `Matrix.singular_value_decomposition()` which would return symbolic results: https://docs.sympy.org/latest/modules/matrices/matrices.html


---

Comment by @honglizhaobob created at 2021-07-07 07:03:22

Replying to [comment:11 gh-honglizhaobob]:

Pushed a preliminary version which only deals with `RDF`, added a method `diagonalize()` in `FiniteRankFreeModuleMorphism`.


---

Comment by @mjungmath created at 2021-07-09 07:54:16

Be careful what you push. You accidentally pushed your from the built generated files. The source code you want to modify is in `src/sage/`.

Can you please rebase the branch accordingly?


---

Comment by git created at 2021-07-09 21:28:08

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @honglizhaobob created at 2021-07-09 21:31:54

Replying to [comment:15 gh-mjungmath]:
> Be careful what you push. You accidentally pushed your from the built generated files. The source code you want to modify is in `src/sage/`.
> 
> Can you please rebase the branch accordingly?

Sorry, I have reset and pushed the code again.


---

Comment by mkoeppe created at 2021-07-09 22:09:22

I've opened #32171 (Matrix: Add generic SVD method using sympy)


---

Comment by @mjungmath created at 2021-07-09 22:40:25

Replying to [comment:17 gh-honglizhaobob]:
> Sorry, I have reset and pushed the code again.

Don't worry. Thanks for taking care of it. :)


---

Comment by mkoeppe created at 2021-07-10 21:10:32

When ready for review, please set author name here on the ticket to your full name, and set to "needs_review".


---

Comment by mkoeppe created at 2021-07-10 21:17:03

The `EXAMPLES` section should probably be extended so that one can see the effect of the function.

Some development tools that help with this: 
- `./sage -fixdoctests src/sage/tensor/modules/free_module_morphism.py` will run the doctests and update the output
- `./sage -docbuild reference/tensor_free_modules html` will build the HMTL documentation - looking at it may reveal mistakes in the markup of the docstring
