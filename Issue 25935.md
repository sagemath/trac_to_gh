# Issue 25935: Plot standard tableau with descents

Issue created by migration from https://trac.sagemath.org/ticket/26172

Original creator: Bruce

Original creation time: 2018-09-01 12:57:38

CC:  tscrim mantepse aschilling deinst kdilks

This is a utility to plot a standard tableau with the option of highlighting the descents.


---

Comment by Bruce created at 2018-09-01 12:58:17

Changing priority from major to minor.


---

Comment by Bruce created at 2018-09-01 12:58:17

Changing type from PLEASE CHANGE to enhancement.


---

Comment by Bruce created at 2018-09-01 13:07:10

New commits:


---

Comment by Bruce created at 2018-09-01 13:07:10

Changing status from new to needs_review.


---

Comment by Bruce created at 2018-09-01 14:10:29

Changing status from needs_review to needs_info.


---

Comment by Bruce created at 2018-09-01 14:10:29

This fails the doctests but I don't know how to fix it.


---

Comment by git created at 2018-09-01 14:10:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-10-10 06:31:19

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2018-10-10 06:31:19

Hi Bruce, sorry it took so long for me to get to this ticket. I ran the tests locally, and I was unable to get any failures. I made some changes, in particular, I allow plotting when the tableau is not necessarily standard, but I left the standard enforcement when `descents=True`. If my changes are good, then positive review.
----
New commits:


---

Comment by mantepse created at 2018-10-10 13:56:37

I must say that I think this goes in the wrong direction, at least partially, for two reasons:

* While it is quite natural to highlight descents, it would be just as natural to highlight cells specified by other properties.  Therefore, it would be much better to be able to pass a function taking a cell and returning a boolean, or even a colour, which specifies which cells to highlight and how.

* moreover, I think this functionality really should also work on the console (when using ascii or unicode art) and for LaTeX (I think `view` also uses LaTeX, doesn't it?).

(To make "wrong direction" more precise: if I understand correctly, `plot` adds yet another interface for related functionality, which is frustrating for the user if she wants to combine functionality.)


---

Comment by mantepse created at 2018-10-10 18:58:46

Here is a proof of concept.  With the patch below, the following prints the descents in red.  This does not deal with LaTeX yet:


```
sage: T = StandardTableau([[1,3,6,9],[2,4,10],[5,7],[8]])
sage: P = T.parent()
sage: from colorama import Fore
sage: P.options.highlight = lambda (x,y): Fore.RED + "%s" + Fore.RESET if T(x,y) in T.standard_descents() else "%s"
sage: P.options.convention = "french"
sage: P.options.ascii_art = "table"
sage: ascii_art(T)
sage: unicode_art(T)
```


I am very unsure about how to best pass the colour or decoration yet.  Comments welcome.


```diff
diff --git a/src/sage/combinat/tableau.py b/src/sage/combinat/tableau.py
index b805e4c144..b948942ef5 100644
--- a/src/sage/combinat/tableau.py
+++ b/src/sage/combinat/tableau.py
@@ -414,13 +414,22 @@ class Tableau(ClonableList):
             for i,e in enumerate(row):
                 col_widths[i] = max(col_widths[i], len(e))
 
-        if self.parent().options('convention') == "French":
-            str_tab = reversed(str_tab)
+        highlight = self.parent().options('highlight')
+        if highlight:
+            lines = [" "
+                     + " ".join(highlight((i,j))%("{:>{width}}".format(e,width=col_widths[j]))
+                                for j, e in enumerate(row))
+                     for i, row in enumerate(str_tab)]
+        else:
+            lines = [" "
+                     + " ".join("{:>{width}}".format(e,width=col_widths[i])
+                                for i,e in enumerate(row))
+                     for row in str_tab]
 
-        return "\n".join(" "
-                         + " ".join("{:>{width}}".format(e,width=col_widths[i])
-                                    for i,e in enumerate(row))
-                         for row in str_tab)
+        if self.parent().options('convention') == "English":
+            return "\n".join(lines)
+        else:
+            return "\n".join(reversed(lines))
 
     def _repr_compact(self):
         """
@@ -435,6 +444,9 @@ class Tableau(ClonableList):
         """
         if not self:
             return '-'
+        highlight = self.parent().options('highlight')
+        if highlight:
+            return '/'.join(','.join(highlight((i, j))%r for j, r in enumerate(row)) for i, row in enumerate(self))
         return '/'.join(','.join('%s'%r for r in row) for row in self)
 
     def _ascii_art_(self):
@@ -618,6 +630,7 @@ class Tableau(ClonableList):
         for w in col_widths[1:]:
             l1 += dh + h + h + h*w
         matr.append(l1 + dl)
+        highlight = self.parent().options('highlight')
         for nrow,row in enumerate(str_tab):
             l1 = ""; l2 = ""
             n = len(str_tab[nrow+1]) if nrow+1 < len(str_tab) else 0
@@ -632,9 +645,9 @@ class Tableau(ClonableList):
                 else:
                     l1 += uh + h*(2+w)
                 if use_unicode:
-                    l2 += u"{} {:^{width}} ".format(v, e, width=w)
+                    l2 += v + highlight((nrow, i))%(u" {:^{width}} ".format(e, width=w))
                 else:
-                    l2 += "{} {:^{width}} ".format(v, e, width=w)
+                    l2 += v + highlight((nrow, i))%(" {:^{width}} ".format(e, width=w))
             if i+1 <= n:
                 l1 += vl
             else:
@@ -684,22 +697,29 @@ class Tableau(ClonableList):
         if not self:
             return "."
 
-        if self.parent().options('convention') == "English":
-            T = self
-        else:
-            T = reversed(self)
-
         # Get the widths of the columns
-        str_tab = [[str(_) for _ in row] for row in T]
+        str_tab = [[str(_) for _ in row] for row in self]
         col_widths = [1]*len(self[0])
         for row in str_tab:
             for i,e in enumerate(row):
                 col_widths[i] = max(col_widths[i], len(e))
 
-        return "\n".join("|"
-                         + "|".join("{:^{width}}".format(e, width=col_widths[i])
-                                    for i,e in enumerate(row))
-                         + "|" for row in str_tab)
+        highlight = self.parent().options('highlight')
+        if highlight:
+            lines = ["|"
+                     + "|".join(highlight((i,j))%("{:^{width}}".format(e, width=col_widths[j]))
+                                for j, e in enumerate(row))
+                     + "|" for i, row in enumerate(str_tab)]
+        else:
+            lines = ["|"
+                     + "|".join("{:^{width}}".format(e, width=col_widths[j])
+                                for j, e in enumerate(row))
+                     + "|" for row in str_tab]
+
+        if self.parent().options('convention') == "English":
+            return "\n".join(lines)
+        else:
+            return "\n".join(reversed(lines))
 
     def _latex_(self):
         r"""
@@ -5501,6 +5521,9 @@ class Tableaux(UniqueRepresentation, Parent):
                         values=dict(English='use the English convention',French='use the French convention'),
                         case_sensitive=False)
         notation = dict(alt_name="convention")
+        highlight = dict(default=None,
+                         checker=lambda v: True,
+                         description='Sets a function specifying which cells should be highlighted')
 
     def _element_constructor_(self, t):
         r"""
```



---

Comment by tscrim created at 2018-10-10 21:42:27

Plotting, latex, and unicode/ascii art are all different ways to doing this. This is a step forward as plotting is a common thing people would try and no reasonable user will be frustrated by having multiple options. Do your additions on a separate ticket. We can always add more highlighting options easily later too.


---

Comment by mantepse created at 2018-10-11 05:02:47

Travis, you misread what I wrote:

> (To make "wrong direction" more precise: if I understand correctly, plot adds yet another interface for related functionality, which is frustrating for the user if she wants to combine functionality.)

But even your statement

> no reasonable user will be frustrated by having multiple options

is debatable, as, for example, #18302 exhibits some of the problems with having very many interfaces.  I also vaguely remember problems with viewing vs. plotting of crystals.

Another minor point is that it will be slightly surprising that `plot` picks out `StandardTableau`, and there are no `plot` methods for the other tableaux classes.  For these I guess one might want to highlight other things (for example, the jeu de taquin path, or something we cannot think of today), which may clash with the option.

If you insist on `plot` (joke: why is this method inconsistent with `m = matrix([This is the Trac macro *1,2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2-macro)); m.plot()`?), please at least make it respect the `convention` option.

(In case you like my idea, feel free to develop it further, I have no time and energy for another ticket currently, sorry about that.)


---

Comment by tscrim created at 2018-10-11 12:53:23

Replying to [comment:11 mantepse]:
> Travis, you misread what I wrote:
> 
> > (To make "wrong direction" more precise: if I understand correctly, plot adds yet another interface for related functionality, which is frustrating for the user if she wants to combine functionality.)

I did correctly read what you wrote. Another interface means another option.

> But even your statement
> 
> > no reasonable user will be frustrated by having multiple options
> 
> is debatable, as, for example, #18302 exhibits some of the problems with having very many interfaces.  I also vaguely remember problems with viewing vs. plotting of crystals.

#18302 is not a valid comparisons for a few different reasons in that `show` is doing the *exact* same as another option, it is not confusing with the other "natural" option (i.e., not have show) and it is a debate over having one name, and `show` also does provide some behavior that is not available in other ways.

`view()` versus `plot()` for crystals has to do with implemented/developed functionality. I would be a +1 for adding better `plot()` for crystals. The problem with that is that most of the vertices don't have a `plot`, so it doesn't look as nice.

> Another minor point is that it will be slightly surprising that `plot` picks out `StandardTableau`, and there are no `plot` methods for the other tableaux classes.  For these I guess one might want to highlight other things (for example, the jeu de taquin path, or something we cannot think of today), which may clash with the option.

It is there for any `Tableau`. Read the code. We can always change the option later if we come to a clash, but IMO this abstract concept of a possible clash argument is a fallacy.

> If you insist on `plot` (joke: why is this method inconsistent with `m = matrix([This is the Trac macro *1,2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2-macro)); m.plot()`?), please at least make it respect the `convention` option.

+1 for having `plot` respect `convention`; that is a good point.


---

Comment by mantepse created at 2018-10-11 14:03:07

OK.


---

Comment by Bruce created at 2018-11-11 22:40:51

Changing status from needs_review to positive_review.


---

Comment by Bruce created at 2018-11-11 22:40:51

Travis checked my change over my shoulder.
----
New commits:


---

Comment by vbraun created at 2018-11-12 21:11:21

Resolution: fixed
