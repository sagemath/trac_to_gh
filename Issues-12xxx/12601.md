# Issue 12601: @cached_method does not work for special methods

archive/issues_012429.json:
```json
{
    "body": "Caching does not work for the `~` operator.\n\n```\nsage: class A(object):\n...    @cached_method\n...    def __invert__(self):\n...        return 1\nsage: a = A() \nsage: ~a is ~a\nFalse\n```\n\nAlso the value of `a.__invert__` changes when calling `~a`.\n\nThis happens because special methods are called through the type and not the actual instance for new-style classes: http://docs.python.org/release/2.7.2/reference/datamodel.html?highlight=data%20model#special-method-lookup-for-new-style-classes\n\nAs of 5.0.beta4 no operators in sage use ``@`cached_method`.\n\nAssignee: @jasongrout\n\nCC:  simonking\n\nKeywords: cached_method, cache, operator, special method\n\nUpstream: Completely fixed; Fix reported upstream\n\nReviewer: Nils Bruin\n\nAuthor: Simon King\n\nBranch: u/SimonKing/ticket/12601\n\nDependencies: #15038\n\nCommit: 6cf1fad162f761dd9a0191a7f8d862cb6300583b\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/12601\n\n",
    "closed_at": "2013-12-20T22:52:21Z",
    "created_at": "2012-02-27T15:16:52Z",
    "labels": [
        "component: misc",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.1",
    "title": "@cached_method does not work for special methods",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12601",
    "user": "https://github.com/saraedum"
}
```
Caching does not work for the `~` operator.

```
sage: class A(object):
...    @cached_method
...    def __invert__(self):
...        return 1
sage: a = A() 
sage: ~a is ~a
False
```

Also the value of `a.__invert__` changes when calling `~a`.

This happens because special methods are called through the type and not the actual instance for new-style classes: http://docs.python.org/release/2.7.2/reference/datamodel.html?highlight=data%20model#special-method-lookup-for-new-style-classes

As of 5.0.beta4 no operators in sage use ``@`cached_method`.

Assignee: @jasongrout

CC:  simonking

Keywords: cached_method, cache, operator, special method

Upstream: Completely fixed; Fix reported upstream

Reviewer: Nils Bruin

Author: Simon King

Branch: u/SimonKing/ticket/12601

Dependencies: #15038

Commit: 6cf1fad162f761dd9a0191a7f8d862cb6300583b

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/12601





---

archive/issue_comments_155736.json:
```json
{
    "body": "<a id='comment:1'></a>As discussed with Simon, I'm working on a patch for this.",
    "created_at": "2012-02-27T15:17:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155736",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:1'></a>As discussed with Simon, I'm working on a patch for this.



---

archive/issue_comments_155737.json:
```json
{
    "body": "Changing type from defect to enhancement.",
    "created_at": "2012-02-27T15:39:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155737",
    "user": "https://github.com/simon-king-jena"
}
```

Changing type from defect to enhancement.



---

archive/issue_comments_155738.json:
```json
{
    "body": "<a id='comment:2'></a>Since no operators in Sage use `@`cached_method (yet), one shouldn't mark this ticket as \"defect\" but as \"enhancement\", I believe.\n\nSince I don't think I am \"upstream\", I think the \"report upstream\" field should be \"Doesn't apply\".",
    "created_at": "2012-02-27T15:39:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155738",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>Since no operators in Sage use `@`cached_method (yet), one shouldn't mark this ticket as "defect" but as "enhancement", I believe.

Since I don't think I am "upstream", I think the "report upstream" field should be "Doesn't apply".



---

archive/issue_comments_155739.json:
```json
{
    "body": "<a id='comment:3'></a>I didn't consider you \"upstream\" - I reported it to sage-release.\n\nI filed it as a bug because code I used in 4.8 broke with 5.0. This is also fixed by solving this underlying problem. But you're right, this is an enhancement.",
    "created_at": "2012-02-27T15:56:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155739",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:3'></a>I didn't consider you "upstream" - I reported it to sage-release.

I filed it as a bug because code I used in 4.8 broke with 5.0. This is also fixed by solving this underlying problem. But you're right, this is an enhancement.



---

archive/issue_comments_155740.json:
```json
{
    "body": "<a id='comment:4'></a>Replying to [comment:3 saraedum]:\n> I didn't consider you \"upstream\" - I reported it to sage-release.\n\n\nI see - or better, I didn't see: I am not regularly reading that list...\n\nAnyway. I think it would be nice to have a mechanism to make use of the cached_method decorator for magical Python methods such as `__invert__` or `__hash__`.",
    "created_at": "2012-02-27T17:10:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155740",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>Replying to [comment:3 saraedum]:
> I didn't consider you "upstream" - I reported it to sage-release.


I see - or better, I didn't see: I am not regularly reading that list...

Anyway. I think it would be nice to have a mechanism to make use of the cached_method decorator for magical Python methods such as `__invert__` or `__hash__`.



---

archive/issue_events_034131.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12601#event-34131"
}
```



---

archive/issue_comments_155741.json:
```json
{
    "body": "<a id='comment:7'></a>Note to myself: Don't forget this ticket...",
    "created_at": "2013-08-15T09:58:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155741",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>Note to myself: Don't forget this ticket...



---

archive/issue_comments_155742.json:
```json
{
    "body": "<a id='comment:8'></a>I think I found the problem. Since the special method of the class is called, the `__get__` method of `CachedMethod` is relevant. Its purpose is to return a \"cached method caller\" that is bound to the instance.\n\nThis `__get__` method currently supposes that it is *only* called if the attribute is not overridden on the instance's `__dict__`. Namely, if the `CachedMethodCaller` is in the instance's `__dict__`, then Python's attribute lookup will not care about the `CachedMethod` if the instance's class.\n\nHence, `__get__` currently does\n\n```python\n        # This is for Parents or Elements that do not allow attribute assignment:\n        try:\n            name = self._cachedfunc.__name__\n        except AttributeError:\n            name = self.__name__\n        try:\n            return (<dict>inst.__cached_methods).__getitem__(name)\n        except (AttributeError,TypeError,KeyError),msg:\n            pass\n```\nand would then create a *new* `CachedMethodCaller`. However, in the example from the ticket description, there already is a `CachedMethodCaller` in the instance's `__dict__`, but it is ignored by the `__get__` method of the `CachedMethod`.\n\nSo, a potential solution is to additionally check `inst.__dict__.__getitem__(name)`.\n\nWhat I don't like about this solution is that it would involve an additional dictionary lookup, which would slow-down every call to a cached method, fortunately only in the case that the instance does not support attribute assignment. And in addition, the call to the special method will *always* involve running this `__get__` method and doing a dictionary lookup.\n\nAlternatively, one could create a special kind of cached method, specifically for special methods of new style classes whose instances allow for attribute assignment.",
    "created_at": "2013-08-15T22:17:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155742",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>I think I found the problem. Since the special method of the class is called, the `__get__` method of `CachedMethod` is relevant. Its purpose is to return a "cached method caller" that is bound to the instance.

This `__get__` method currently supposes that it is *only* called if the attribute is not overridden on the instance's `__dict__`. Namely, if the `CachedMethodCaller` is in the instance's `__dict__`, then Python's attribute lookup will not care about the `CachedMethod` if the instance's class.

Hence, `__get__` currently does

```python
        # This is for Parents or Elements that do not allow attribute assignment:
        try:
            name = self._cachedfunc.__name__
        except AttributeError:
            name = self.__name__
        try:
            return (<dict>inst.__cached_methods).__getitem__(name)
        except (AttributeError,TypeError,KeyError),msg:
            pass
```
and would then create a *new* `CachedMethodCaller`. However, in the example from the ticket description, there already is a `CachedMethodCaller` in the instance's `__dict__`, but it is ignored by the `__get__` method of the `CachedMethod`.

So, a potential solution is to additionally check `inst.__dict__.__getitem__(name)`.

What I don't like about this solution is that it would involve an additional dictionary lookup, which would slow-down every call to a cached method, fortunately only in the case that the instance does not support attribute assignment. And in addition, the call to the special method will *always* involve running this `__get__` method and doing a dictionary lookup.

Alternatively, one could create a special kind of cached method, specifically for special methods of new style classes whose instances allow for attribute assignment.



---

archive/issue_comments_155743.json:
```json
{
    "body": "Attachment [trac12601-cached_special_methods.patch](tarball://root/attachments/some-uuid/ticket12601/trac12601-cached_special_methods.patch) by @simon-king-jena created at 2013-08-16 10:36:34",
    "created_at": "2013-08-16T10:36:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155743",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac12601-cached_special_methods.patch](tarball://root/attachments/some-uuid/ticket12601/trac12601-cached_special_methods.patch) by @simon-king-jena created at 2013-08-16 10:36:34



---

archive/issue_comments_155744.json:
```json
{
    "body": "<a id='comment:9'></a>In principle, it would be possible to change `CachedMethod.__get__` to deal both with usual and special methods. However, the price to pay would be either a slow-down when using cached methods on instances that don't allow attribute assignment, or cached special methods would be slow.\n\nTherefore, I created a new class `CachedSpecialMethod` that overloads the `__get__` method. Now, cached_method is a function (not an alias of `CachedMethod`) that chooses amongst `CachedMethod` and `CachedSpecialMethod` based on the name of the wrapped method.\n\nI also tried to tweak the case of (usual) cached methods in the case of forbidden attribute assignment.\n\n**__Timings and examples__**\n\n__With the patch:__\n\n```\nsage: class CCache(object):\n....:     @cached_method\n....:     def __hash__(self):\n....:         print \"computing hash\"\n....:         return int(5)\n....:     @cached_method\n....:     def f(self):\n....:         print \"computing cached method with no args\"\n....:         return 4\n....:     @cached_method\n....:     def g(self, x):\n....:         print \"computing cached method with args\"\n....:         return x*2\n....:     \nsage: class CNoncache(object):\n....:     def __hash__(self):\n....:         return int(5)\n....:     def f(self):\n....:         return 4\n....:     def g(self, x):\n....:         return x*2\n....:     \nsage: c = CCache()\nsage: hash(c)\ncomputing hash\n5\nsage: hash(c)\n5\nsage: c.f()\ncomputing cached method with no args\n4\nsage: c.f()\n4\nsage: c.g(4)\ncomputing cached method with args\n8\nsage: c.g(4)\n8\nsage: c.g(int(4))\n8\nsage: %timeit hash(c)\n1000000 loops, best of 3: 241 ns per loop\nsage: %timeit c.f()\n10000000 loops, best of 3: 139 ns per loop\nsage: %timeit c.g(4)\n1000000 loops, best of 3: 694 ns per loop\nsage: n = CNoncache()\nsage: %timeit hash(n)\n1000000 loops, best of 3: 827 ns per loop\nsage: %timeit n.f()\n1000000 loops, best of 3: 389 ns per loop\nsage: %timeit n.g(4)\n1000000 loops, best of 3: 669 ns per loop\n```\nNote that the cached hash is *faster* than an uncached hash that returns a constant number!!\n\nWithout attribute assignment (special methods can't be wrapped in Cython, so I can't wrap `__hash__`):\n\n```\nsage: cython(\"\"\"\n....: from sage.structure.parent cimport Parent\n....: from sage.misc.cachefunc import cached_method\n....: cdef class MyParent(Parent):\n....:     @cached_method\n....:     def f(self):\n....:         return 4\n....:     @cached_method\n....:     def g(self,x):\n....:         return x*2\n....: \"\"\")\nsage: m = MyParent()\nsage: m.f() is m.f()\nTrue\nsage: m.g(4) is m.g(4)\nTrue\nsage: %timeit m.f()\n1000000 loops, best of 3: 237 ns per loop\nsage: %timeit m.g(4)\n1000000 loops, best of 3: 831 ns per loop\n```\n\n__Without the patch__\n\nThe classes and instances are defined as above. As we know, caching the hash did not work, but of course it did work on usual methods:\n\n```\nsage: hash(c)\ncomputing hash\n5\nsage: hash(c)\ncomputing hash\n5\nsage: c.f() is c.f()\ncomputing cached method with no args\nTrue\nsage: c.g(int(4)) is c.g(4)\ncomputing cached method with args\nTrue\n```\nThe timing with the possibility to assign attributes did not change (as expected):\n\n```\nsage: %timeit c.f()\n10000000 loops, best of 3: 137 ns per loop\nsage: %timeit c.g(4)\n1000000 loops, best of 3: 702 ns per loop\n```\nThe timings without attribute assignment did improve with my patch as well:\n\n```\nsage: %timeit m.f()\n1000000 loops, best of 3: 334 ns per loop\nsage: %timeit m.g(4)\n1000000 loops, best of 3: 958 ns per loop\n```\n\n**__Conclusion__**\n\nI believe that my patch solves the problem and would be glad about a review :)\n\nI didn't run the full test suite yet.\n\nIt could be that there is an interference with #15038, which I thus add as a dependency (it already has positive review).",
    "created_at": "2013-08-16T11:01:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155744",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>In principle, it would be possible to change `CachedMethod.__get__` to deal both with usual and special methods. However, the price to pay would be either a slow-down when using cached methods on instances that don't allow attribute assignment, or cached special methods would be slow.

Therefore, I created a new class `CachedSpecialMethod` that overloads the `__get__` method. Now, cached_method is a function (not an alias of `CachedMethod`) that chooses amongst `CachedMethod` and `CachedSpecialMethod` based on the name of the wrapped method.

I also tried to tweak the case of (usual) cached methods in the case of forbidden attribute assignment.

**__Timings and examples__**

__With the patch:__

```
sage: class CCache(object):
....:     @cached_method
....:     def __hash__(self):
....:         print "computing hash"
....:         return int(5)
....:     @cached_method
....:     def f(self):
....:         print "computing cached method with no args"
....:         return 4
....:     @cached_method
....:     def g(self, x):
....:         print "computing cached method with args"
....:         return x*2
....:     
sage: class CNoncache(object):
....:     def __hash__(self):
....:         return int(5)
....:     def f(self):
....:         return 4
....:     def g(self, x):
....:         return x*2
....:     
sage: c = CCache()
sage: hash(c)
computing hash
5
sage: hash(c)
5
sage: c.f()
computing cached method with no args
4
sage: c.f()
4
sage: c.g(4)
computing cached method with args
8
sage: c.g(4)
8
sage: c.g(int(4))
8
sage: %timeit hash(c)
1000000 loops, best of 3: 241 ns per loop
sage: %timeit c.f()
10000000 loops, best of 3: 139 ns per loop
sage: %timeit c.g(4)
1000000 loops, best of 3: 694 ns per loop
sage: n = CNoncache()
sage: %timeit hash(n)
1000000 loops, best of 3: 827 ns per loop
sage: %timeit n.f()
1000000 loops, best of 3: 389 ns per loop
sage: %timeit n.g(4)
1000000 loops, best of 3: 669 ns per loop
```
Note that the cached hash is *faster* than an uncached hash that returns a constant number!!

Without attribute assignment (special methods can't be wrapped in Cython, so I can't wrap `__hash__`):

```
sage: cython("""
....: from sage.structure.parent cimport Parent
....: from sage.misc.cachefunc import cached_method
....: cdef class MyParent(Parent):
....:     @cached_method
....:     def f(self):
....:         return 4
....:     @cached_method
....:     def g(self,x):
....:         return x*2
....: """)
sage: m = MyParent()
sage: m.f() is m.f()
True
sage: m.g(4) is m.g(4)
True
sage: %timeit m.f()
1000000 loops, best of 3: 237 ns per loop
sage: %timeit m.g(4)
1000000 loops, best of 3: 831 ns per loop
```

__Without the patch__

The classes and instances are defined as above. As we know, caching the hash did not work, but of course it did work on usual methods:

```
sage: hash(c)
computing hash
5
sage: hash(c)
computing hash
5
sage: c.f() is c.f()
computing cached method with no args
True
sage: c.g(int(4)) is c.g(4)
computing cached method with args
True
```
The timing with the possibility to assign attributes did not change (as expected):

```
sage: %timeit c.f()
10000000 loops, best of 3: 137 ns per loop
sage: %timeit c.g(4)
1000000 loops, best of 3: 702 ns per loop
```
The timings without attribute assignment did improve with my patch as well:

```
sage: %timeit m.f()
1000000 loops, best of 3: 334 ns per loop
sage: %timeit m.g(4)
1000000 loops, best of 3: 958 ns per loop
```

**__Conclusion__**

I believe that my patch solves the problem and would be glad about a review :)

I didn't run the full test suite yet.

It could be that there is an interference with #15038, which I thus add as a dependency (it already has positive review).



---

archive/issue_comments_155745.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-08-16T11:01:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155745",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_155746.json:
```json
{
    "body": "<a id='comment:10'></a>PS: One thing I worry about is the startup time. After all, for each cached method, it is now needed to decide whether the function name starts and ends with two underscores.",
    "created_at": "2013-08-16T11:03:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155746",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>PS: One thing I worry about is the startup time. After all, for each cached method, it is now needed to decide whether the function name starts and ends with two underscores.



---

archive/issue_comments_155747.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:10 SimonKing]:\n> PS: One thing I worry about is the startup time. After all, for each cached method, it is now needed to decide whether the function name starts and ends with two underscores.\n\n\nIf that's a problem, why not just leave them separate decorators? By the time someone is decorating a special method, they probably are doing the wrong thing or they really know what they're doing. Plus, not all `__*__` are special method, are they? Since the list of special methods is short and discrete, I think you should match on the whole name. Perhaps the list is available in the python library somewhere.\n\nIncidentally, I suspect that this will not work for cdef classes at all, due to the special way in which special methods get compiled (and the fact they end up in slots)\n\nBy the way, have you done timings on `ArgumentFixer` overhead? Calling a cached function with arguments has considerable overhead (easily 4 times as expensive). As a result, instantiating a `CachedRepresentation` no-op class with `__init__` arguments is much more expensive than instantiating the corresponding normal no-op class. I think this can really affect things like creating matrices from a list of arguments (the default way!) because the parent, the matrix algebra, must get created.\n\n`ArgumentFixer` can definitely be improved: several lists there get intensively rewritten and some methods get looked up where straight `PyList_...` python library calls could get used. I'm not sure to what extent that would improve the situation and how much we lose to this overhead in practice, but it's definitely a possible source: `ArgumentFixer` is not definitely not without cost and it gets used for any cached method/function call that has arguments.",
    "created_at": "2013-08-16T15:11:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155747",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:11'></a>Replying to [comment:10 SimonKing]:
> PS: One thing I worry about is the startup time. After all, for each cached method, it is now needed to decide whether the function name starts and ends with two underscores.


If that's a problem, why not just leave them separate decorators? By the time someone is decorating a special method, they probably are doing the wrong thing or they really know what they're doing. Plus, not all `__*__` are special method, are they? Since the list of special methods is short and discrete, I think you should match on the whole name. Perhaps the list is available in the python library somewhere.

Incidentally, I suspect that this will not work for cdef classes at all, due to the special way in which special methods get compiled (and the fact they end up in slots)

By the way, have you done timings on `ArgumentFixer` overhead? Calling a cached function with arguments has considerable overhead (easily 4 times as expensive). As a result, instantiating a `CachedRepresentation` no-op class with `__init__` arguments is much more expensive than instantiating the corresponding normal no-op class. I think this can really affect things like creating matrices from a list of arguments (the default way!) because the parent, the matrix algebra, must get created.

`ArgumentFixer` can definitely be improved: several lists there get intensively rewritten and some methods get looked up where straight `PyList_...` python library calls could get used. I'm not sure to what extent that would improve the situation and how much we lose to this overhead in practice, but it's definitely a possible source: `ArgumentFixer` is not definitely not without cost and it gets used for any cached method/function call that has arguments.



---

archive/issue_comments_155748.json:
```json
{
    "body": "<a id='comment:12'></a>Replying to [comment:11 nbruin]:\n> Replying to [comment:10 SimonKing]:\n> > PS: One thing I worry about is the startup time. After all, for each cached method, it is now needed to decide whether the function name starts and ends with two underscores.\n\n> \n> If that's a problem, why not just leave them separate decorators?\n\n\n*If* that's a problem. I simply don't know yet whether it is noticeable in startup-time. If it does not create a slow-down, I think it is more convenient to have a single decorator that works for both kind of methods.\n\n> Plus, not all `__*__` are special method, are they? Since the list of special methods is short and discrete, I think you should match on the whole name. Perhaps the list is available in the python library somewhere.\n\n\nRight. However, if we are talking about a cached non-special double underscore method for an instance that allows to assign attributes, then the distinction between `CachedMethod` and `CachedSpecialMethod` is irrelevant! Namely, if attribute assignment works, then the `__get__` method will be called precisely once. There are only three reasons why the `__get__` method could be called repeatedly:\n- Attribute assignment does not work, hence, stuff will be stored in (and retrieved from) `inst.__cached_methods`.\n- We have a special method, so that Python won't look into `inst.__dict__`.\n- The user does `del inst.method_name`.\n\nSo, I think it is a non-issue. But of course, we could do a look-up in a finite list of special methods. I just fear that this would create an even bigger slow-down (*if* there is any slow-down noticeable).\n\n> Incidentally, I suspect that this will not work for cdef classes at all, due to the special way in which special methods get compiled (and the fact they end up in slots)\n\n\nSure. That's why I wrote \"(special methods can't be wrapped in Cython, so I can't wrap `__hash__`)\" in comment:9.\n\nIn any case, cdef classes do not play totally nicely with cached methods anyway. They quite often don't allow attribute assignment, and that's why I introduced `inst.__cached_methods` in the first place, a couple of years ago. Without it, cached methods on cdef classes would not only be even slower, but they wouldn't be cached at all!\n \n> By the way, have you done timings on `ArgumentFixer` overhead?\n\n\nI didn't change argument fixer here. There was some change in #15038, namely: Postpone creation of the argument fixer. I think it was #8611 and #11115 when I last worked on speeding up the argument fixer.\n\n> Calling a cached function with arguments has considerable overhead (easily 4 times as expensive). As a result, instantiating a `CachedRepresentation` no-op class with `__init__` arguments is much more expensive than instantiating the corresponding normal no-op class. I think this can really affect things like creating matrices from a list of arguments (the default way!) because the parent, the matrix algebra, must get created.\n\n\nThat's clearly for a different ticket. Actually I have played with the idea of using an `ArgumentFixer` in `CachedRepresentation.__classcall__` so that different equivalent ways of providing arguments (by position or by name) result in the same instance of the class. And then, further optimisations (e.g., for singleton classes) would easily available.\n\n> `ArgumentFixer` can definitely be improved: several lists there get intensively rewritten and some methods get looked up where straight `PyList_...` python library calls could get used. I'm not sure to what extent that would improve the situation and how much we lose to this overhead in practice, but it's definitely a possible source: `ArgumentFixer` is not definitely not without cost and it gets used for any cached method/function call that has arguments.\n\n\nAgain, that's a different ticket.",
    "created_at": "2013-08-16T16:07:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155748",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>Replying to [comment:11 nbruin]:
> Replying to [comment:10 SimonKing]:
> > PS: One thing I worry about is the startup time. After all, for each cached method, it is now needed to decide whether the function name starts and ends with two underscores.

> 
> If that's a problem, why not just leave them separate decorators?


*If* that's a problem. I simply don't know yet whether it is noticeable in startup-time. If it does not create a slow-down, I think it is more convenient to have a single decorator that works for both kind of methods.

> Plus, not all `__*__` are special method, are they? Since the list of special methods is short and discrete, I think you should match on the whole name. Perhaps the list is available in the python library somewhere.


Right. However, if we are talking about a cached non-special double underscore method for an instance that allows to assign attributes, then the distinction between `CachedMethod` and `CachedSpecialMethod` is irrelevant! Namely, if attribute assignment works, then the `__get__` method will be called precisely once. There are only three reasons why the `__get__` method could be called repeatedly:
- Attribute assignment does not work, hence, stuff will be stored in (and retrieved from) `inst.__cached_methods`.
- We have a special method, so that Python won't look into `inst.__dict__`.
- The user does `del inst.method_name`.

So, I think it is a non-issue. But of course, we could do a look-up in a finite list of special methods. I just fear that this would create an even bigger slow-down (*if* there is any slow-down noticeable).

> Incidentally, I suspect that this will not work for cdef classes at all, due to the special way in which special methods get compiled (and the fact they end up in slots)


Sure. That's why I wrote "(special methods can't be wrapped in Cython, so I can't wrap `__hash__`)" in comment:9.

In any case, cdef classes do not play totally nicely with cached methods anyway. They quite often don't allow attribute assignment, and that's why I introduced `inst.__cached_methods` in the first place, a couple of years ago. Without it, cached methods on cdef classes would not only be even slower, but they wouldn't be cached at all!
 
> By the way, have you done timings on `ArgumentFixer` overhead?


I didn't change argument fixer here. There was some change in #15038, namely: Postpone creation of the argument fixer. I think it was #8611 and #11115 when I last worked on speeding up the argument fixer.

> Calling a cached function with arguments has considerable overhead (easily 4 times as expensive). As a result, instantiating a `CachedRepresentation` no-op class with `__init__` arguments is much more expensive than instantiating the corresponding normal no-op class. I think this can really affect things like creating matrices from a list of arguments (the default way!) because the parent, the matrix algebra, must get created.


That's clearly for a different ticket. Actually I have played with the idea of using an `ArgumentFixer` in `CachedRepresentation.__classcall__` so that different equivalent ways of providing arguments (by position or by name) result in the same instance of the class. And then, further optimisations (e.g., for singleton classes) would easily available.

> `ArgumentFixer` can definitely be improved: several lists there get intensively rewritten and some methods get looked up where straight `PyList_...` python library calls could get used. I'm not sure to what extent that would improve the situation and how much we lose to this overhead in practice, but it's definitely a possible source: `ArgumentFixer` is not definitely not without cost and it gets used for any cached method/function call that has arguments.


Again, that's a different ticket.



---

archive/issue_comments_155749.json:
```json
{
    "body": "<a id='comment:13'></a>According to the patchbot, there is no slow-down in startup time. Hence, we might think of following your suggestion to let ``@`cached_method` do a slightly more expensive test for choosing between `CachedMethod` and `CachedSpecialMethod`.\n\nRecall that I am not totally convinced that a more explicit choice (\"only be special for methods that are *really* special in Python\") has any benefit. Choosing a `CachedSpecialMethod` for a double-underscore *non-special* method will result in a working cached method, but might have a speed-penalty. However, this speed-penalty would only occur if the instance does not allow attribute assignment; otherwise, there is no difference in speed nor in functionality between the two wrappers. That's why I think it is fine to just test for double underscores.\n\nAnyway, the patchbot also reports a failure. I could not reproduce it at home. So, I hope it is random noise.",
    "created_at": "2013-08-16T21:03:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155749",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>According to the patchbot, there is no slow-down in startup time. Hence, we might think of following your suggestion to let ``@`cached_method` do a slightly more expensive test for choosing between `CachedMethod` and `CachedSpecialMethod`.

Recall that I am not totally convinced that a more explicit choice ("only be special for methods that are *really* special in Python") has any benefit. Choosing a `CachedSpecialMethod` for a double-underscore *non-special* method will result in a working cached method, but might have a speed-penalty. However, this speed-penalty would only occur if the instance does not allow attribute assignment; otherwise, there is no difference in speed nor in functionality between the two wrappers. That's why I think it is fine to just test for double underscores.

Anyway, the patchbot also reports a failure. I could not reproduce it at home. So, I hope it is random noise.



---

archive/issue_comments_155750.json:
```json
{
    "body": "<a id='comment:14'></a>The second patchbot finds that all tests pass. So, we may have detected a neutrino...",
    "created_at": "2013-08-16T22:35:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155750",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>The second patchbot finds that all tests pass. So, we may have detected a neutrino...



---

archive/issue_comments_155751.json:
```json
{
    "body": "<a id='comment:15'></a>Review, anyone?",
    "created_at": "2013-10-14T14:37:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155751",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>Review, anyone?



---

archive/issue_comments_155752.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [comment:12 SimonKing]:\n\n> Right. However, if we are talking about a cached non-special double underscore\n> method for an instance that allows to assign attributes, then the distinction\n> between `CachedMethod` and `CachedSpecialMethod` is irrelevant!\n\n\nOnly if the number of calls is significantly larger than 1.\n\n> But of course, we could do a look-up in a finite list of special methods. I\n> just fear that this would create an even bigger slow-down (*if* there is any\n> slow-down noticeable).\n\n\nNo that should be fine. Strings like that would be fully interned, so looking\nthem up in a set or as dictionary keys will actually be significantly faster\nthan doing string manipulations. (remember that these are attribute names.\nPython is very much invested in making attribute lookup lightning fast)\n\nExample:\n\n```\nspecial_methods=set(['__get__','__set__','__hash__'])\n\ndef is_special1(method):\n  return method in special_methods\ndef is_special2(method):\n  return method.startswith('__') and method.endswith('__')\n```\nLookup is quite a bit faster than doing string manipulations:\n\n```\nsage: timeit(\"is_special1('__hash__')\",number=100000)\n100000 loops, best of 3: 124 ns per loop\nsage: timeit(\"is_special2('__hash__')\",number=100000)\n100000 loops, best of 3: 380 ns per loop\n```",
    "created_at": "2013-10-14T17:31:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155752",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:16'></a>Replying to [comment:12 SimonKing]:

> Right. However, if we are talking about a cached non-special double underscore
> method for an instance that allows to assign attributes, then the distinction
> between `CachedMethod` and `CachedSpecialMethod` is irrelevant!


Only if the number of calls is significantly larger than 1.

> But of course, we could do a look-up in a finite list of special methods. I
> just fear that this would create an even bigger slow-down (*if* there is any
> slow-down noticeable).


No that should be fine. Strings like that would be fully interned, so looking
them up in a set or as dictionary keys will actually be significantly faster
than doing string manipulations. (remember that these are attribute names.
Python is very much invested in making attribute lookup lightning fast)

Example:

```
special_methods=set(['__get__','__set__','__hash__'])

def is_special1(method):
  return method in special_methods
def is_special2(method):
  return method.startswith('__') and method.endswith('__')
```
Lookup is quite a bit faster than doing string manipulations:

```
sage: timeit("is_special1('__hash__')",number=100000)
100000 loops, best of 3: 124 ns per loop
sage: timeit("is_special2('__hash__')",number=100000)
100000 loops, best of 3: 380 ns per loop
```



---

archive/issue_comments_155753.json:
```json
{
    "body": "<a id='comment:17'></a>In an attempt to be a little systematic in extracting a complete list of methods that get stored in slots on a type object (those are the methods that need special attention, right?), I used\n\n```\ngrep 'SLOT(\".*\"' Objects/typeobject.c\n```\nto extract the relevant lines from the definition of `slotdefs` in the python source. When processed, I obtain the list:\n\n```\n['__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__delslice__', '__div__', '__eq__', '__float__', '__floordiv__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__', '__setslice__', '__str__', '__sub__', '__truediv__', '__xor__', 'next']\n```\nHopefully this list is complete. Is there another source of such methods? I noticed that there is a non-underscored method in there as well: `next` (this got fixed in Python 3). Admittedly, one should probably never cache that, but it's not the job of the decorator to enforce that.\n\nUnfortunately, this list is not complete. For instance:\n\n```\nclass T(object):\n  @cached_method\n  def __complex__(self):\n    print \"called\"\n    return 1\nt=T()\n```\ndoes not cache on `complex(t)`. The key seems to by calls to `_PyObject_LookupSpecial`, which does the lookup on the type rather than on the instance. The only uses of this routine yield:\n\n```\n\"__length_hint__\", \"__format__\", \"__missing__\", \"__instancecheck__\", \"__subclasscheck__\", \"__complex__\", \"__reversed__\", \"__unicode__\", \"__dir__\", \"__sizeof__\"\n```\nso hopefully adding those *does* give us a complete list.",
    "created_at": "2013-10-14T20:22:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155753",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:17'></a>In an attempt to be a little systematic in extracting a complete list of methods that get stored in slots on a type object (those are the methods that need special attention, right?), I used

```
grep 'SLOT(".*"' Objects/typeobject.c
```
to extract the relevant lines from the definition of `slotdefs` in the python source. When processed, I obtain the list:

```
['__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__delslice__', '__div__', '__eq__', '__float__', '__floordiv__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__', '__setslice__', '__str__', '__sub__', '__truediv__', '__xor__', 'next']
```
Hopefully this list is complete. Is there another source of such methods? I noticed that there is a non-underscored method in there as well: `next` (this got fixed in Python 3). Admittedly, one should probably never cache that, but it's not the job of the decorator to enforce that.

Unfortunately, this list is not complete. For instance:

```
class T(object):
  @cached_method
  def __complex__(self):
    print "called"
    return 1
t=T()
```
does not cache on `complex(t)`. The key seems to by calls to `_PyObject_LookupSpecial`, which does the lookup on the type rather than on the instance. The only uses of this routine yield:

```
"__length_hint__", "__format__", "__missing__", "__instancecheck__", "__subclasscheck__", "__complex__", "__reversed__", "__unicode__", "__dir__", "__sizeof__"
```
so hopefully adding those *does* give us a complete list.



---

archive/issue_comments_155754.json:
```json
{
    "body": "<a id='comment:18'></a>Replying to [comment:16 nbruin]:\n> Example:\n> \n> \n> ```\n> special_methods=set(['__get__','__set__','__hash__'])\n> \n> def is_special1(method):\n>   return method in special_methods\n> def is_special2(method):\n>   return method.startswith('__') and method.endswith('__')\n> ```\n\n\nWith the full list and with Cython, one gets\n\n```\nsage: cython(\"\"\"\n....: cdef list special_methods = ['__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__delslice__', '__div__', '__eq__', '__float__', '__floordiv__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__', '__setslice__', '__str__', '__sub__', '__truediv__', '__xor__', 'next']\n....: def is_special1(str method):\n....:     return method in special_methods\n....: def is_special2(str method):\n....:     return method.startswith('__') and method.endswith('__')\n....: \"\"\"\n....: )\n....: \nsage: timeit(\"is_special1('__hash__')\",number=100000)\n100000 loops, best of 3: 835 ns per loop\nsage: timeit(\"is_special2('__hash__')\",number=100000)\n100000 loops, best of 3: 161 ns per loop\n```\nSo, I disagree. If Cython is used then `startswith` and `endswith` are faster.",
    "created_at": "2013-10-14T20:33:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155754",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>Replying to [comment:16 nbruin]:
> Example:
> 
> 
> ```
> special_methods=set(['__get__','__set__','__hash__'])
> 
> def is_special1(method):
>   return method in special_methods
> def is_special2(method):
>   return method.startswith('__') and method.endswith('__')
> ```


With the full list and with Cython, one gets

```
sage: cython("""
....: cdef list special_methods = ['__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__delslice__', '__div__', '__eq__', '__float__', '__floordiv__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__', '__setslice__', '__str__', '__sub__', '__truediv__', '__xor__', 'next']
....: def is_special1(str method):
....:     return method in special_methods
....: def is_special2(str method):
....:     return method.startswith('__') and method.endswith('__')
....: """
....: )
....: 
sage: timeit("is_special1('__hash__')",number=100000)
100000 loops, best of 3: 835 ns per loop
sage: timeit("is_special2('__hash__')",number=100000)
100000 loops, best of 3: 161 ns per loop
```
So, I disagree. If Cython is used then `startswith` and `endswith` are faster.



---

archive/issue_comments_155755.json:
```json
{
    "body": "<a id='comment:19'></a>PS: If the list only contains three elements (as in your not very realistic example), then still the string methods are faster.\n\n```\nsage: cython(\"\"\"                                     \ncdef list special_methods = ['__get__', '__set__', '__hash__']def is_special1(str method):    return method in special_methodsdef is_special2(str method):    return method.startswith('__') and method.endswith('__')\"\"\"                                                         )                                                         ....: \nsage: timeit(\"is_special1('__hash__')\",number=100000)\n100000 loops, best of 3: 174 ns per loop\nsage: timeit(\"is_special2('__hash__')\",number=100000)\n100000 loops, best of 3: 159 ns per loop\n```\n\nPPS: When we use a frozenset instead, then using the string methods is not faster any more, even with the complete set of special attribute names.\n\n```\nsage: cython(\"\"\"                                     \ncdef frozenset special_methods = frozenset(['__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__delslice__', '__div__', '__eq__', '__float__', '__floordiv__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__', '__setslice__', '__str__', '__sub__', '__truediv__', '__xor__', 'next'])\ndef is_special1(str method):\n    return method in special_methods\ndef is_special2(str method):\n    return method.startswith('__') and method.endswith('__')\n\"\"\"\n)\n....: \nsage: timeit(\"is_special1('__hash__')\",number=100000)\n100000 loops, best of 3: 113 ns per loop\nsage: timeit(\"is_special2('__hash__')\",number=100000)\n100000 loops, best of 3: 169 ns per loop\n```",
    "created_at": "2013-10-14T20:40:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155755",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>PS: If the list only contains three elements (as in your not very realistic example), then still the string methods are faster.

```
sage: cython("""                                     
cdef list special_methods = ['__get__', '__set__', '__hash__']def is_special1(str method):    return method in special_methodsdef is_special2(str method):    return method.startswith('__') and method.endswith('__')"""                                                         )                                                         ....: 
sage: timeit("is_special1('__hash__')",number=100000)
100000 loops, best of 3: 174 ns per loop
sage: timeit("is_special2('__hash__')",number=100000)
100000 loops, best of 3: 159 ns per loop
```

PPS: When we use a frozenset instead, then using the string methods is not faster any more, even with the complete set of special attribute names.

```
sage: cython("""                                     
cdef frozenset special_methods = frozenset(['__abs__', '__add__', '__and__', '__call__', '__cmp__', '__coerce__', '__contains__', '__del__', '__delattr__', '__delete__', '__delitem__', '__delslice__', '__div__', '__eq__', '__float__', '__floordiv__', '__ge__', '__get__', '__getattr__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__set__', '__setattr__', '__setitem__', '__setslice__', '__str__', '__sub__', '__truediv__', '__xor__', 'next'])
def is_special1(str method):
    return method in special_methods
def is_special2(str method):
    return method.startswith('__') and method.endswith('__')
"""
)
....: 
sage: timeit("is_special1('__hash__')",number=100000)
100000 loops, best of 3: 113 ns per loop
sage: timeit("is_special2('__hash__')",number=100000)
100000 loops, best of 3: 169 ns per loop
```



---

archive/issue_comments_155756.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:19 SimonKing]:\n\n> PPS: When we use a frozenset instead, then using the string methods is not faster any more, even with the complete set of special attribute names.\n\n\nRight, better use sets to check membership. Also, note that `next` is a special method that does not get detected with the underscore rule.\n\nI've edited #12601:comment:17 above with a list of special methods which should be usable as a lookup. It doesn't seem there's a store of these available somewhere already, so it looks like we'll have to make our own set.",
    "created_at": "2013-10-14T20:49:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155756",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:20'></a>Replying to [comment:19 SimonKing]:

> PPS: When we use a frozenset instead, then using the string methods is not faster any more, even with the complete set of special attribute names.


Right, better use sets to check membership. Also, note that `next` is a special method that does not get detected with the underscore rule.

I've edited #12601:comment:17 above with a list of special methods which should be usable as a lookup. It doesn't seem there's a store of these available somewhere already, so it looks like we'll have to make our own set.



---

archive/issue_comments_155757.json:
```json
{
    "body": "<a id='comment:22'></a>New commits:",
    "created_at": "2013-10-15T08:58:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155757",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>New commits:



---

archive/issue_comments_155758.json:
```json
{
    "body": "<a id='comment:23'></a>I have created a git branch for this ticket, containing the original patch, removing some trailing whitespace that the patch has introduced, and then changing the detection of special method names to using a frozenset of all names that Nils has mentioned here (note that Nils presented two lists, and I combined both).\n\nTests pass for me. Needs review, then.",
    "created_at": "2013-10-15T08:58:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155758",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>I have created a git branch for this ticket, containing the original patch, removing some trailing whitespace that the patch has introduced, and then changing the detection of special method names to using a frozenset of all names that Nils has mentioned here (note that Nils presented two lists, and I combined both).

Tests pass for me. Needs review, then.



---

archive/issue_comments_155759.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-10-16T05:29:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155759",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_155760.json:
```json
{
    "body": "<a id='comment:24'></a>Looks good to me. The approach seems solid. We'll see how it stands up once people start using it.",
    "created_at": "2013-10-16T05:29:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155760",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:24'></a>Looks good to me. The approach seems solid. We'll see how it stands up once people start using it.



---

archive/issue_comments_155761.json:
```json
{
    "body": "<a id='comment:25'></a>Please clarify whether the patch or branch should be merged. In the latter case, set the milestone to sage-6.0. Also, the Reviewer field should be filled in.",
    "created_at": "2013-10-16T12:32:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155761",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:25'></a>Please clarify whether the patch or branch should be merged. In the latter case, set the milestone to sage-6.0. Also, the Reviewer field should be filled in.



---

archive/issue_events_034132.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-16T14:41:09Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12601#event-34132"
}
```



---

archive/issue_events_034133.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-16T14:41:09Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "milestone": "sage-6.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12601#event-34133"
}
```



---

archive/issue_comments_155762.json:
```json
{
    "body": "<a id='comment:26'></a>I hope Nils does not mind that I filled the fields for him (as he gave a positive review).",
    "created_at": "2013-10-16T14:41:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155762",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>I hope Nils does not mind that I filled the fields for him (as he gave a positive review).



---

archive/issue_events_034134.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2013-12-17T18:39:51Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "milestone": "sage-6.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12601#event-34134"
}
```



---

archive/issue_events_034135.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2013-12-17T18:39:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "milestone": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12601#event-34135"
}
```



---

archive/issue_events_034136.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-12-20T22:52:21Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12601#event-34136"
}
```



---

archive/issue_comments_155763.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-12-20T22:52:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12601",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12601#issuecomment-155763",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
