# Issue 12808: Optimize ClassCallMetaClass using Cython

archive/issues_012636.json:
```json
{
    "body": "When a class `C` is an instance of `ClasscallMetaclass`, then for any constructor call, the system currently looks for `__classcall__` and `__classcall_private__` in `C`. This adds quite an overhead and this could be cached, assuming no one modifies `C` (which seems reasonable). Improving this speeds up, in particular, all call to the constructor of a subclass of `UniqueRepresentation`, eg. many parents, all categories...\n\n__Apply__\n\n* [attachment:trac_12808-classcall_speedup-fh.patch]\n* [attachment:trac_12808_nested_class_cython.patch]\n* [attachment:trac_12808-classcall_cdef.patch]\n\n\nAssignee: @jasongrout\n\nCC:  @nthiery simonking\n\nKeywords: classcall UniqueRepresentation\n\nReviewer: Simon King, Florent Hivert\n\nAuthor: Florent Hivert, Simon King\n\nMerged: sage-5.1.beta0\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/12808\n\n",
    "closed_at": "2012-05-06T12:18:10Z",
    "created_at": "2012-04-04T15:23:29Z",
    "labels": [
        "component: misc"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.1",
    "title": "Optimize ClassCallMetaClass using Cython",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12808",
    "user": "https://github.com/hivert"
}
```
When a class `C` is an instance of `ClasscallMetaclass`, then for any constructor call, the system currently looks for `__classcall__` and `__classcall_private__` in `C`. This adds quite an overhead and this could be cached, assuming no one modifies `C` (which seems reasonable). Improving this speeds up, in particular, all call to the constructor of a subclass of `UniqueRepresentation`, eg. many parents, all categories...

__Apply__

* [attachment:trac_12808-classcall_speedup-fh.patch]
* [attachment:trac_12808_nested_class_cython.patch]
* [attachment:trac_12808-classcall_cdef.patch]


Assignee: @jasongrout

CC:  @nthiery simonking

Keywords: classcall UniqueRepresentation

Reviewer: Simon King, Florent Hivert

Author: Florent Hivert, Simon King

Merged: sage-5.1.beta0

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/12808





---

archive/issue_comments_191634.json:
```json
{
    "body": "<a id='comment:1'></a>\nBefore\n\n```\nsage: %timeit ZZ in Rings()\n625 loops, best of 3: 1.13 \u00b5s per loop\n```\nAfter the preliminary patch\n\n```\nsage: %timeit ZZ in Rings()\n625 loops, best of 3: 448 ns per loops\n```",
    "created_at": "2012-04-04T15:27:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191634",
    "user": "https://github.com/hivert"
}
```

<a id='comment:1'></a>
Before

```
sage: %timeit ZZ in Rings()
625 loops, best of 3: 1.13 µs per loop
```
After the preliminary patch

```
sage: %timeit ZZ in Rings()
625 loops, best of 3: 448 ns per loops
```



---

archive/issue_comments_191635.json:
```json
{
    "body": "<a id='comment:2'></a>\nI'm finishing the patch, I've added a large optimization for the other branch\nwhere there is no `__classcall__`\n\nHere are the results in the basis case (no `__classcall__`)::\n\n```\nsage: class Rien(object):\n...       pass\nsage: from sage.misc.classcall_metaclass import ClasscallMetaclass\nsage: class NOCALL(object):\n...      __metaclass__ = ClasscallMetaclass\n...      pass\n\nStandard Python class:\n\nsage: %timeit [Rien() for i in range(10000)]\n125 loops, best of 3: 1.7 ms per loop\n\nCurrently:\n\nsage: %timeit [NOCALL() for i in range(10000)]\n25 loops, best of 3: 15.9 ms per loop\n\nCython version:\n\nsage: %timeit [NOCALL() for i in range(10000)]\n125 loops, best of 3: 3.59 ms per loop\n\nCython optimized version:\n\nsage: %timeit [NOCALL() for i in range(10000)]\n125 loops, best of 3: 1.76 ms per loop\n```\nSo I'm 5% only slower than normal class.\n\nHere are the results in the basis case (no `__classcall__`)::\n\n```\nsage: class CALL(object):\n...       __metaclass__ = ClasscallMetaclass\n...       @staticmethod\n...       def __classcall_private__(cls, arg):\n...           arg = arg + arg\n...           return arg\n\nCurrently:\n\nsage: %timeit [CALL(i) for i in range(10000)]\n25 loops, best of 3: 8.7 ms per loop\n\nCython version:\n\nsage: %timeit [CALL(i) for i in range(10000)]\n125 loops, best of 3: 4.33 ms per loop\n\nCython optimized version (no mesurable difference from the preceding):\n\nsage: %timeit [CALL(i) for i in range(10000)]\n125 loops, best of 3: 4.34 ms per loop\n```\nHere I'm twice as fast as before.\n\nI'm cleanup the patch (doctests) an will post it shortly.",
    "created_at": "2012-04-05T17:18:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191635",
    "user": "https://github.com/hivert"
}
```

<a id='comment:2'></a>
I'm finishing the patch, I've added a large optimization for the other branch
where there is no `__classcall__`

Here are the results in the basis case (no `__classcall__`)::

```
sage: class Rien(object):
...       pass
sage: from sage.misc.classcall_metaclass import ClasscallMetaclass
sage: class NOCALL(object):
...      __metaclass__ = ClasscallMetaclass
...      pass

Standard Python class:

sage: %timeit [Rien() for i in range(10000)]
125 loops, best of 3: 1.7 ms per loop

Currently:

sage: %timeit [NOCALL() for i in range(10000)]
25 loops, best of 3: 15.9 ms per loop

Cython version:

sage: %timeit [NOCALL() for i in range(10000)]
125 loops, best of 3: 3.59 ms per loop

Cython optimized version:

sage: %timeit [NOCALL() for i in range(10000)]
125 loops, best of 3: 1.76 ms per loop
```
So I'm 5% only slower than normal class.

Here are the results in the basis case (no `__classcall__`)::

```
sage: class CALL(object):
...       __metaclass__ = ClasscallMetaclass
...       @staticmethod
...       def __classcall_private__(cls, arg):
...           arg = arg + arg
...           return arg

Currently:

sage: %timeit [CALL(i) for i in range(10000)]
25 loops, best of 3: 8.7 ms per loop

Cython version:

sage: %timeit [CALL(i) for i in range(10000)]
125 loops, best of 3: 4.33 ms per loop

Cython optimized version (no mesurable difference from the preceding):

sage: %timeit [CALL(i) for i in range(10000)]
125 loops, best of 3: 4.34 ms per loop
```
Here I'm twice as fast as before.

I'm cleanup the patch (doctests) an will post it shortly.



---

archive/issue_comments_191636.json:
```json
{
    "body": "<a id='comment:3'></a>\nSorry, I can not do any serious work (reviewing), as I am in the middle of holidays. But it looks promising!",
    "created_at": "2012-04-09T23:30:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191636",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Sorry, I can not do any serious work (reviewing), as I am in the middle of holidays. But it looks promising!



---

archive/issue_comments_191637.json:
```json
{
    "body": "<a id='comment:4'></a>\nHi Florent!\n\nI know the patch is preliminary, but here are two comments:\n\nIn the new file classcall_metaclass_cy.pyx, it is not explained what `__classcall__` and `__classcall_private__` do, and when to implement which. Actually, I have never used `__classcall_private__` myself.\n\nIn the old python version of classcall_metaclass, you move `__call__` to `__call__disable`. Why do you not completely remove the slow Python call method?",
    "created_at": "2012-04-20T07:09:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191637",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Hi Florent!

I know the patch is preliminary, but here are two comments:

In the new file classcall_metaclass_cy.pyx, it is not explained what `__classcall__` and `__classcall_private__` do, and when to implement which. Actually, I have never used `__classcall_private__` myself.

In the old python version of classcall_metaclass, you move `__call__` to `__call__disable`. Why do you not completely remove the slow Python call method?



---

archive/issue_comments_191638.json:
```json
{
    "body": "<a id='comment:5'></a>\nAlso, why not going all the way and remove the python version completely? Or at least: Why not cythonizing (and caching?) the `__contains__` method?",
    "created_at": "2012-04-20T07:18:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191638",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Also, why not going all the way and remove the python version completely? Or at least: Why not cythonizing (and caching?) the `__contains__` method?



---

archive/issue_comments_191639.json:
```json
{
    "body": "<a id='comment:6'></a>\nOr ideally, one could try to provide a generalised metaclass framework in Sage. Namely, one could think of having different small metaclasses, each providing a particular feature. For example:\n\n* We have `NestedMetaclass`.\n* We already have `__classcall__` (perhaps resulting in a unique parent structure or in a dynamic class).\n* At #11794, I suggest a metaclass that provides a fast cached hash.\n* Just \"brainstorming\": Perhaps it would be a useful feature for debugging to print which Python methods are called of a particular instance. I could imagine a metaclass that could be used to *temporarily* switch that feature on.\n\nAnd if we have different \"small\" metaclasses then it would be useful to combine them. But that's a problem for Python: If A, B and C have different metaclasses, you can not simply have a class definition like\n\n```\n    class D(A,B,C): pass\n```\n\nThis is (I guess) why `ClasscallMetaclass` inherits from `NestedMetaclass`. But Ticket #11794 provides examples for a different and more skalable solution: *Make metaclasses dynamic!*\n\nSo, what I mean by a generalised metaclass framework in Sage is:\n* Implement a base class `SageMetaclass`, from which all metaclasses (such as `NestedMetaclass` and `ClasscallMetaclass` and `FastHashMetaclass`) are derived.\n* Make it so that if A, B, C are classes with different metaclasses (all derived from `SageMetaclass`) can be used as base classes for a new class. In that way, the features provided by metaclasses could be freely combined.\n\nBut I guess that's a topic for a different ticket...",
    "created_at": "2012-04-20T07:55:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191639",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Or ideally, one could try to provide a generalised metaclass framework in Sage. Namely, one could think of having different small metaclasses, each providing a particular feature. For example:

* We have `NestedMetaclass`.
* We already have `__classcall__` (perhaps resulting in a unique parent structure or in a dynamic class).
* At #11794, I suggest a metaclass that provides a fast cached hash.
* Just "brainstorming": Perhaps it would be a useful feature for debugging to print which Python methods are called of a particular instance. I could imagine a metaclass that could be used to *temporarily* switch that feature on.

And if we have different "small" metaclasses then it would be useful to combine them. But that's a problem for Python: If A, B and C have different metaclasses, you can not simply have a class definition like

```
    class D(A,B,C): pass
```

This is (I guess) why `ClasscallMetaclass` inherits from `NestedMetaclass`. But Ticket #11794 provides examples for a different and more skalable solution: *Make metaclasses dynamic!*

So, what I mean by a generalised metaclass framework in Sage is:
* Implement a base class `SageMetaclass`, from which all metaclasses (such as `NestedMetaclass` and `ClasscallMetaclass` and `FastHashMetaclass`) are derived.
* Make it so that if A, B, C are classes with different metaclasses (all derived from `SageMetaclass`) can be used as base classes for a new class. In that way, the features provided by metaclasses could be freely combined.

But I guess that's a topic for a different ticket...



---

archive/issue_comments_191640.json:
```json
{
    "body": "<a id='comment:7'></a>\nPS: If that works, one could also get rid of the `DynamicClasscallMetaclass`, which seems like a hack that became necessary since one can not freely combine base classes with different metaclasses.",
    "created_at": "2012-04-20T08:06:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191640",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
PS: If that works, one could also get rid of the `DynamicClasscallMetaclass`, which seems like a hack that became necessary since one can not freely combine base classes with different metaclasses.



---

archive/issue_comments_191641.json:
```json
{
    "body": "<a id='comment:8'></a>\nHi Simon,\n\nThanks for all those remarks and sorry for not having finished this one as fast as I wanted.\n\nReplying to [SimonKing](#comment%3A5):\n> Also, why not going all the way and remove the python version completely? Or at least: Why not cythonizing (and caching?) the `__contains__` method?\n\n\nObviously. Please see my patch on sage combinat's queue which already adresses all those remarks. I'm currently doing intensive timing to be sure that we have the fastest way. \n\nFlorent",
    "created_at": "2012-04-20T08:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191641",
    "user": "https://github.com/hivert"
}
```

<a id='comment:8'></a>
Hi Simon,

Thanks for all those remarks and sorry for not having finished this one as fast as I wanted.

Replying to [SimonKing](#comment%3A5):
> Also, why not going all the way and remove the python version completely? Or at least: Why not cythonizing (and caching?) the `__contains__` method?


Obviously. Please see my patch on sage combinat's queue which already adresses all those remarks. I'm currently doing intensive timing to be sure that we have the fastest way. 

Florent



---

archive/issue_comments_191642.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [SimonKing](#comment%3A6):\n> This is (I guess) why `ClasscallMetaclass` inherits from `NestedMetaclass`. But Ticket #11794 provides examples for a different and more skalable solution: *Make metaclasses dynamic!*\n\n\nYes it is. We discussed last week with Nicolas of switching the inheritance\norder here. That is using only `NestedMetaclass` for Categories. I still have\nto check that this doesn't break pickling of Parent with a nested Element.\n\n> So, what I mean by a generalised metaclass framework in Sage is:\n> * Implement a base class `SageMetaclass`, from which all metaclasses (such as `NestedMetaclass` and `ClasscallMetaclass` and `FastHashMetaclass`) are derived.\n> * Make it so that if A, B, C are classes with different metaclasses (all derived from `SageMetaclass`) can be used as base classes for a new class. In that way, the features provided by metaclasses could be freely combined.\n> \n> But I guess that's a topic for a different ticket...\n\n\n+1 for this and for keeping it for a different ticket.",
    "created_at": "2012-04-20T08:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191642",
    "user": "https://github.com/hivert"
}
```

<a id='comment:9'></a>
Replying to [SimonKing](#comment%3A6):
> This is (I guess) why `ClasscallMetaclass` inherits from `NestedMetaclass`. But Ticket #11794 provides examples for a different and more skalable solution: *Make metaclasses dynamic!*


Yes it is. We discussed last week with Nicolas of switching the inheritance
order here. That is using only `NestedMetaclass` for Categories. I still have
to check that this doesn't break pickling of Parent with a nested Element.

> So, what I mean by a generalised metaclass framework in Sage is:
> * Implement a base class `SageMetaclass`, from which all metaclasses (such as `NestedMetaclass` and `ClasscallMetaclass` and `FastHashMetaclass`) are derived.
> * Make it so that if A, B, C are classes with different metaclasses (all derived from `SageMetaclass`) can be used as base classes for a new class. In that way, the features provided by metaclasses could be freely combined.
> 
> But I guess that's a topic for a different ticket...


+1 for this and for keeping it for a different ticket.



---

archive/issue_comments_191643.json:
```json
{
    "body": "<a id='comment:10'></a>\nHi Simon,\n\nI just uploaded an updated patch. I still have to lauch the tests (but I've to run for a train now) and to check the documentation. The code together with the timings should hopefully be the final version here.\nI'll put the needs review after the tests and doc rereading.\n\nThanks for your remarks.\n\nFlorent",
    "created_at": "2012-04-20T08:52:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191643",
    "user": "https://github.com/hivert"
}
```

<a id='comment:10'></a>
Hi Simon,

I just uploaded an updated patch. I still have to lauch the tests (but I've to run for a train now) and to check the documentation. The code together with the timings should hopefully be the final version here.
I'll put the needs review after the tests and doc rereading.

Thanks for your remarks.

Florent



---

archive/issue_comments_191644.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-04-20T14:18:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191644",
    "user": "https://github.com/hivert"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_191645.json:
```json
{
    "body": "<a id='comment:12'></a>\nCould it be that the patch was created by something like \"hg remove sage/misc/classcall_metaclass.py\" followed by \"hg add sage/misc/classcall_metaclass.pyx\"?\n\nI am no mercurial expert, but I was told that one should better use \"hg rename sage/misc/classcall_metaclass.py sage/misc/classcall_metaclass.pyx\".",
    "created_at": "2012-04-22T08:46:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191645",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>
Could it be that the patch was created by something like "hg remove sage/misc/classcall_metaclass.py" followed by "hg add sage/misc/classcall_metaclass.pyx"?

I am no mercurial expert, but I was told that one should better use "hg rename sage/misc/classcall_metaclass.py sage/misc/classcall_metaclass.pyx".



---

archive/issue_comments_191646.json:
```json
{
    "body": "<a id='comment:13'></a>\nWhile we are at it: Shouldn't we also try whether changing unique_representation.py into unique_representation.pyx yields a speedup (but not changing \"class\" into \"cdef class\", I guess that won't work)?",
    "created_at": "2012-04-22T08:58:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191646",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>
While we are at it: Shouldn't we also try whether changing unique_representation.py into unique_representation.pyx yields a speedup (but not changing "class" into "cdef class", I guess that won't work)?



---

archive/issue_comments_191647.json:
```json
{
    "body": "<a id='comment:14'></a>\nI have created an alternative patch (using hg rename). It is smaller than the original patch, but should result in identical code. So, either of the patches could be used, but I guess the smaller patch is easier to read (because one sees more easily the additional differences between classcall_metaclass.py and classcall_metaclass.pyx)\n\nApply trac_12808-classcall_speedup2.patch",
    "created_at": "2012-04-22T09:16:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191647",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>
I have created an alternative patch (using hg rename). It is smaller than the original patch, but should result in identical code. So, either of the patches could be used, but I guess the smaller patch is easier to read (because one sees more easily the additional differences between classcall_metaclass.py and classcall_metaclass.pyx)

Apply trac_12808-classcall_speedup2.patch



---

archive/issue_comments_191648.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1,5 @@\n When a class `C` is an instance of `ClasscallMetaclass`, then for any constructor call, the system currently looks for `__classcall__` and `__classcall_private__` in `C`. This adds quite an overhead and this could be cached, assuming no one modifies `C` (which seems reasonable). Improving this speeds up, in particular, all call to the constructor of a subclass of `UniqueRepresentation`, eg. many parents, all categories...\n+\n+__Apply__\n+\n+[attachment:trac_12808-classcall_speedup2.patch]\n``````\n",
    "created_at": "2012-04-22T09:16:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191648",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1,5 @@
 When a class `C` is an instance of `ClasscallMetaclass`, then for any constructor call, the system currently looks for `__classcall__` and `__classcall_private__` in `C`. This adds quite an overhead and this could be cached, assuming no one modifies `C` (which seems reasonable). Improving this speeds up, in particular, all call to the constructor of a subclass of `UniqueRepresentation`, eg. many parents, all categories...
+
+__Apply__
+
+[attachment:trac_12808-classcall_speedup2.patch]
``````




---

archive/issue_comments_191649.json:
```json
{
    "body": "<a id='comment:15'></a>\nGood news: All doctests pass.\n\nI am astonished that the C-level way of calling `type.__call__` is so much faster. That suggests to cythonise sage.structure.dynamic_class as well, so that dynamic classes are created more quickly! Shall this be done on a different ticket?",
    "created_at": "2012-04-22T12:25:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191649",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>
Good news: All doctests pass.

I am astonished that the C-level way of calling `type.__call__` is so much faster. That suggests to cythonise sage.structure.dynamic_class as well, so that dynamic classes are created more quickly! Shall this be done on a different ticket?



---

archive/issue_comments_191650.json:
```json
{
    "body": "<a id='comment:16'></a>\nProbably the dynamic class cythonisation should be on a different ticket. However, it seems that the change to cython will not be so difficult: I simply renamed dynamic_class.py into dynamic_class.pyx (and added two lines to module_list.py), and the test suite seems to pass (most of it is already finished). And then, one can apply your trick with `type.__call__`.",
    "created_at": "2012-04-22T18:08:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191650",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>
Probably the dynamic class cythonisation should be on a different ticket. However, it seems that the change to cython will not be so difficult: I simply renamed dynamic_class.py into dynamic_class.pyx (and added two lines to module_list.py), and the test suite seems to pass (most of it is already finished). And then, one can apply your trick with `type.__call__`.



---

archive/issue_comments_191651.json:
```json
{
    "body": "<a id='comment:17'></a>\nI see that you added `_included_private_doc_`. Could you elaborate on it? I just searched the sources for that name, but it does not occur anywhere except in your patch. So, what does it do?",
    "created_at": "2012-04-22T19:04:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191651",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>
I see that you added `_included_private_doc_`. Could you elaborate on it? I just searched the sources for that name, but it does not occur anywhere except in your patch. So, what does it do?



---

archive/issue_comments_191652.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [SimonKing](#comment%3A16):\n> Probably the dynamic class cythonisation should be on a different ticket. However, it seems that the change to cython will not be so difficult: I simply renamed dynamic_class.py into dynamic_class.pyx (and added two lines to module_list.py), and the test suite seems to pass (most of it is already finished). And then, one can apply your trick with `type.__call__`.\n\n\nThanks for trying this out! It's cool that it works.\n\nNow, do you mind postponing to a later ticket after #11935? I am doing a couple small changes to dynamic_class in my upcoming reviewer's patch (hopefuly tomorrow).",
    "created_at": "2012-04-22T21:34:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191652",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:18'></a>
Replying to [SimonKing](#comment%3A16):
> Probably the dynamic class cythonisation should be on a different ticket. However, it seems that the change to cython will not be so difficult: I simply renamed dynamic_class.py into dynamic_class.pyx (and added two lines to module_list.py), and the test suite seems to pass (most of it is already finished). And then, one can apply your trick with `type.__call__`.


Thanks for trying this out! It's cool that it works.

Now, do you mind postponing to a later ticket after #11935? I am doing a couple small changes to dynamic_class in my upcoming reviewer's patch (hopefuly tomorrow).



---

archive/issue_comments_191653.json:
```json
{
    "body": "<a id='comment:19'></a>\nNote that there is a conflict with #12215, so, either of the patches needs to be rebased. But I guess we first see what patch will be reviewed first...",
    "created_at": "2012-04-23T09:40:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191653",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>
Note that there is a conflict with #12215, so, either of the patches needs to be rebased. But I guess we first see what patch will be reviewed first...



---

archive/issue_comments_191654.json:
```json
{
    "body": "<a id='comment:20'></a>\nSome further questions (in addition to my question about the r\u00f4le of _included_private_doc_):\n\nWhy is `__all__ = ['ClasscallType', 'ClasscallMetaclass', 'typecall', 'timeCall']` added? Isn't importing also possible without that? Or is it needed to make `from sage.misc.classcall_metaclass import *` work?\n\nWhy is there a two-step cythonisation? I mean, why is there a cdef class `ClasscallType` implementing the special methods, and then `ClasscallMetaclass` defined by double inheritance from `ClasscallType` and `NestedClassMetaclass`? Wouldn't it be better/easier/faster to cdef `NestedClassMetaclass` as well, and then cdef `ClasscallMetaclass` directly, without having the `ClasscallType`?\n\nI guess the typecall function will be useful in other modules (e.g., when cythonising dynamic_class). But it only is def. Shouldn't it rather be `cdef inline`?\n\nConcerning the timing tools provided in the module: Is there still no \"central\" location for all aspects of timing? I thought there were occasional discussions on sage-devel about a benchmark/timing framework.",
    "created_at": "2012-04-23T09:55:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191654",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>
Some further questions (in addition to my question about the rôle of _included_private_doc_):

Why is `__all__ = ['ClasscallType', 'ClasscallMetaclass', 'typecall', 'timeCall']` added? Isn't importing also possible without that? Or is it needed to make `from sage.misc.classcall_metaclass import *` work?

Why is there a two-step cythonisation? I mean, why is there a cdef class `ClasscallType` implementing the special methods, and then `ClasscallMetaclass` defined by double inheritance from `ClasscallType` and `NestedClassMetaclass`? Wouldn't it be better/easier/faster to cdef `NestedClassMetaclass` as well, and then cdef `ClasscallMetaclass` directly, without having the `ClasscallType`?

I guess the typecall function will be useful in other modules (e.g., when cythonising dynamic_class). But it only is def. Shouldn't it rather be `cdef inline`?

Concerning the timing tools provided in the module: Is there still no "central" location for all aspects of timing? I thought there were occasional discussions on sage-devel about a benchmark/timing framework.



---

archive/issue_comments_191655.json:
```json
{
    "body": "<a id='comment:21'></a>\nHi Simon,\n\nThanks for your in depth review.\n\nReplying to [SimonKing](#comment%3A20):\n> Some further questions (in addition to my question about the r\u00f4le of _included_private_doc_):\n\n\nThis is a tentative inclusion of the doc of the special methods (see\n[this thread](http://groups.google.com/group/sage-devel/browse_thread/thread/b1cf6b2243bba673?hl=en) on sage devel.\n\n> Why is `__all__ = ['ClasscallType', 'ClasscallMetaclass', 'typecall', 'timeCall']` added? Isn't importing also possible without that? Or is it needed to make `from sage.misc.classcall_metaclass import *` work?\n\n\nI just want to hide the few class I wrote here for timing (CRef, C2, C3,\nC2C). With this line, they are neither imported with import *, nor documented.\n\n> Why is there a two-step cythonisation? I mean, why is there a cdef class\n> `ClasscallType` implementing the special methods, and then\n> `ClasscallMetaclass` defined by double inheritance from `ClasscallType` and\n> `NestedClassMetaclass`? Wouldn't it be better/easier/faster to cdef\n> `NestedClassMetaclass` as well, and then cdef `ClasscallMetaclass` directly,\n> without having the `ClasscallType`?\n\n\nThere is this discussion about cleaning up the way metaclass are defined and\nused in Sage. I just wanted to keep features separate. Should we decide to\nmerge or rewrite the metaclass architecture, I'd rather to keep this for a\ndifferent ticket.\n\n> I guess the typecall function will be useful in other modules (e.g., when\n> cythonising dynamic_class). But it only is def. Shouldn't it rather be `cdef\n> inline`?\n\n\nYou mean `cpdef inline` (we may want to call it from Python) ? I had the\nimpression from C that this inline doesn't do anything if the function is\ndefined in a different module. More precisely, in C/C++ inline only work if\nthe function is defined in `.h` instead of `.c`. Does Cython do\nanything for that ?\n\n> Concerning the timing tools provided in the module: Is there still no\n> \"central\" location for all aspects of timing? I thought there were\n> occasional discussions on sage-devel about a benchmark/timing framework.\n\n\nNot that I know of.\n\nFlorent",
    "created_at": "2012-04-23T10:21:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191655",
    "user": "https://github.com/hivert"
}
```

<a id='comment:21'></a>
Hi Simon,

Thanks for your in depth review.

Replying to [SimonKing](#comment%3A20):
> Some further questions (in addition to my question about the rôle of _included_private_doc_):


This is a tentative inclusion of the doc of the special methods (see
[this thread](http://groups.google.com/group/sage-devel/browse_thread/thread/b1cf6b2243bba673?hl=en) on sage devel.

> Why is `__all__ = ['ClasscallType', 'ClasscallMetaclass', 'typecall', 'timeCall']` added? Isn't importing also possible without that? Or is it needed to make `from sage.misc.classcall_metaclass import *` work?


I just want to hide the few class I wrote here for timing (CRef, C2, C3,
C2C). With this line, they are neither imported with import *, nor documented.

> Why is there a two-step cythonisation? I mean, why is there a cdef class
> `ClasscallType` implementing the special methods, and then
> `ClasscallMetaclass` defined by double inheritance from `ClasscallType` and
> `NestedClassMetaclass`? Wouldn't it be better/easier/faster to cdef
> `NestedClassMetaclass` as well, and then cdef `ClasscallMetaclass` directly,
> without having the `ClasscallType`?


There is this discussion about cleaning up the way metaclass are defined and
used in Sage. I just wanted to keep features separate. Should we decide to
merge or rewrite the metaclass architecture, I'd rather to keep this for a
different ticket.

> I guess the typecall function will be useful in other modules (e.g., when
> cythonising dynamic_class). But it only is def. Shouldn't it rather be `cdef
> inline`?


You mean `cpdef inline` (we may want to call it from Python) ? I had the
impression from C that this inline doesn't do anything if the function is
defined in a different module. More precisely, in C/C++ inline only work if
the function is defined in `.h` instead of `.c`. Does Cython do
anything for that ?

> Concerning the timing tools provided in the module: Is there still no
> "central" location for all aspects of timing? I thought there were
> occasional discussions on sage-devel about a benchmark/timing framework.


Not that I know of.

Florent



---

archive/issue_comments_191656.json:
```json
{
    "body": "<a id='comment:22'></a>\nI forgot: thanks for creating a new patch. I didn't use rename because at some point of my experiment, I was having the two files `*.py` and `*_c.pyx` with the `*.py` importing the other. Then I copied the documentation from `*.py` to `*_c.pyx` until the `*.py` becomes nearly empty. At the end, I renamed the `*_c.pyx` into the `*.pyx` and removed the `*.py`. \n\nHow did you manage to get a patch using rename at the end ?\n\nFlorent",
    "created_at": "2012-04-23T10:28:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191656",
    "user": "https://github.com/hivert"
}
```

<a id='comment:22'></a>
I forgot: thanks for creating a new patch. I didn't use rename because at some point of my experiment, I was having the two files `*.py` and `*_c.pyx` with the `*.py` importing the other. Then I copied the documentation from `*.py` to `*_c.pyx` until the `*.py` becomes nearly empty. At the end, I renamed the `*_c.pyx` into the `*.pyx` and removed the `*.py`. 

How did you manage to get a patch using rename at the end ?

Florent



---

archive/issue_comments_191657.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [hivert](#comment%3A21):\n> > Why is `__all__ = ['ClasscallType', 'ClasscallMetaclass', 'typecall', 'timeCall']` added? Isn't importing also possible without that? Or is it needed to make `from sage.misc.classcall_metaclass import *` work?\n\n> \n> I just want to hide the few class I wrote here for timing (CRef, C2, C3,\n> C2C). With this line, they are neither imported with import *, nor documented.\n\n\nSo, it is not for making something importable, but for *excluding* something from automatic import? Cool!\n\n> > Why is there a two-step cythonisation?\n\n> \n> There is this discussion about cleaning up the way metaclass are defined and\n> used in Sage.\n\n\nYou mean the [sage-combinat-devel](http://groups.google.com/group/sage-combinat-devel/browse_thread/thread/ae09de5a608525e5) thread I started?\n\n> I just wanted to keep features separate.\n\n\nWell, I actually think cythoning `NestedClassMetaclass` is *less* intrusive than your patch.\n\nCompare: You have to *add* a new cdef class `ClasscallType` and change the inheritance of `ClasscallMetaclass`. I suggest to change `NestedClassMetaclass` into a cdef class, keep the inheritance of `ClasscallMetaclass`, and avoid the addition of `ClasscallType`.\n\nI think I will test it...\n\n> You mean `cpdef inline` (we may want to call it from Python) ?\n\n\nYes, I forgot the letter \"p\".\n\n> I had the\n> impression from C that this inline doesn't do anything if the function is\n> defined in a different module. More precisely, in C/C++ inline only work if\n> the function is defined in `.h` instead of `.c`. Does Cython do\n> anything for that ?\n\n\nI expected it to be inlined, if it is defined cpdef inline in the pxd file, and then cimported into another cython file. But I don't know if that is really done, actually.",
    "created_at": "2012-04-23T11:40:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191657",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>
Replying to [hivert](#comment%3A21):
> > Why is `__all__ = ['ClasscallType', 'ClasscallMetaclass', 'typecall', 'timeCall']` added? Isn't importing also possible without that? Or is it needed to make `from sage.misc.classcall_metaclass import *` work?

> 
> I just want to hide the few class I wrote here for timing (CRef, C2, C3,
> C2C). With this line, they are neither imported with import *, nor documented.


So, it is not for making something importable, but for *excluding* something from automatic import? Cool!

> > Why is there a two-step cythonisation?

> 
> There is this discussion about cleaning up the way metaclass are defined and
> used in Sage.


You mean the [sage-combinat-devel](http://groups.google.com/group/sage-combinat-devel/browse_thread/thread/ae09de5a608525e5) thread I started?

> I just wanted to keep features separate.


Well, I actually think cythoning `NestedClassMetaclass` is *less* intrusive than your patch.

Compare: You have to *add* a new cdef class `ClasscallType` and change the inheritance of `ClasscallMetaclass`. I suggest to change `NestedClassMetaclass` into a cdef class, keep the inheritance of `ClasscallMetaclass`, and avoid the addition of `ClasscallType`.

I think I will test it...

> You mean `cpdef inline` (we may want to call it from Python) ?


Yes, I forgot the letter "p".

> I had the
> impression from C that this inline doesn't do anything if the function is
> defined in a different module. More precisely, in C/C++ inline only work if
> the function is defined in `.h` instead of `.c`. Does Cython do
> anything for that ?


I expected it to be inlined, if it is defined cpdef inline in the pxd file, and then cimported into another cython file. But I don't know if that is really done, actually.



---

archive/issue_comments_191658.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [hivert](#comment%3A22):\n> How did you manage to get a patch using rename at the end ?\n\n\nManually. Namely: Apply your patch, copy the touched/new files to a temporary directory, remove your patch, `hg qnew`, then `hg rename`, then move the copy of your file over to the file that has just been created by `hg rename`, and then `hg qrefresh`.",
    "created_at": "2012-04-23T11:42:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191658",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'></a>
Replying to [hivert](#comment%3A22):
> How did you manage to get a patch using rename at the end ?


Manually. Namely: Apply your patch, copy the touched/new files to a temporary directory, remove your patch, `hg qnew`, then `hg rename`, then move the copy of your file over to the file that has just been created by `hg rename`, and then `hg qrefresh`.



---

archive/issue_comments_191659.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [SimonKing](#comment%3A23):\n> [...]\n\n>\n> So, it is not for making something importable, but for *excluding* something from automatic import? Cool!\n\n\nYep ! see\n[importing * from a package](http://docs.python.org/tutorial/modules.html#importing-from-a-package)\n\n> > > Why is there a two-step cythonisation?\n\n> > \n> > There is this discussion about cleaning up the way metaclass are defined and\n> > used in Sage.\n\n> \n> You mean the [sage-combinat-devel](http://groups.google.com/group/sage-combinat-devel/browse_thread/thread/ae09de5a608525e5) thread I started?\n\n\nYes ! An some face to face discussion we had with Nicolas.\n\n> > I just wanted to keep features separate.\n\n> \n> Well, I actually think cythoning `NestedClassMetaclass` is *less* intrusive than your patch.\n> \n> Compare: You have to *add* a new cdef class `ClasscallType` and change the inheritance of `ClasscallMetaclass`. I suggest to change `NestedClassMetaclass` into a cdef class, keep the inheritance of `ClasscallMetaclass`, and avoid the addition of `ClasscallType`.\n\n>\n> I think I will test it...\n\n\nExcept that at some point Nicolas suggested to keep NestedClassMetaclass for\nCategories... The truth is that I've currently no idea on the good way\nmetaclass should be organized in Sage. So I tried to avoid any interface\nchanges. I was even surprised that the Cythonizing work so well without\nbreaking anything in Sage. Now If you think there is a better/faster\nway. Please give it a try.\n\n> > I had the\n> > impression from C that this inline doesn't do anything if the function is\n> > defined in a different module. More precisely, in C/C++ inline only work if\n> > the function is defined in `.h` instead of `.c`. Does Cython do\n> > anything for that ?\n\n> \n> I expected it to be inlined, if it is defined cpdef inline in the pxd file, and then cimported into another cython file. But I don't know if that is really done, actually.\n\n\nI'll look at the compiled result.",
    "created_at": "2012-04-23T12:40:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191659",
    "user": "https://github.com/hivert"
}
```

<a id='comment:25'></a>
Replying to [SimonKing](#comment%3A23):
> [...]

>
> So, it is not for making something importable, but for *excluding* something from automatic import? Cool!


Yep ! see
[importing * from a package](http://docs.python.org/tutorial/modules.html#importing-from-a-package)

> > > Why is there a two-step cythonisation?

> > 
> > There is this discussion about cleaning up the way metaclass are defined and
> > used in Sage.

> 
> You mean the [sage-combinat-devel](http://groups.google.com/group/sage-combinat-devel/browse_thread/thread/ae09de5a608525e5) thread I started?


Yes ! An some face to face discussion we had with Nicolas.

> > I just wanted to keep features separate.

> 
> Well, I actually think cythoning `NestedClassMetaclass` is *less* intrusive than your patch.
> 
> Compare: You have to *add* a new cdef class `ClasscallType` and change the inheritance of `ClasscallMetaclass`. I suggest to change `NestedClassMetaclass` into a cdef class, keep the inheritance of `ClasscallMetaclass`, and avoid the addition of `ClasscallType`.

>
> I think I will test it...


Except that at some point Nicolas suggested to keep NestedClassMetaclass for
Categories... The truth is that I've currently no idea on the good way
metaclass should be organized in Sage. So I tried to avoid any interface
changes. I was even surprised that the Cythonizing work so well without
breaking anything in Sage. Now If you think there is a better/faster
way. Please give it a try.

> > I had the
> > impression from C that this inline doesn't do anything if the function is
> > defined in a different module. More precisely, in C/C++ inline only work if
> > the function is defined in `.h` instead of `.c`. Does Cython do
> > anything for that ?

> 
> I expected it to be inlined, if it is defined cpdef inline in the pxd file, and then cimported into another cython file. But I don't know if that is really done, actually.


I'll look at the compiled result.



---

archive/issue_comments_191660.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [hivert](#comment%3A25):\n> Except that at some point Nicolas suggested to keep NestedClassMetaclass for\n> Categories...\n\n\nI suggest to keep it as well. I just want to cdef it.",
    "created_at": "2012-04-23T13:00:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191660",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>
Replying to [hivert](#comment%3A25):
> Except that at some point Nicolas suggested to keep NestedClassMetaclass for
> Categories...


I suggest to keep it as well. I just want to cdef it.



---

archive/issue_comments_191661.json:
```json
{
    "body": "Attachment [trac_12808-classcall_speedup-fh.patch](tarball://root/attachments/some-uuid/ticket12808/trac_12808-classcall_speedup-fh.patch) by @hivert created at 2012-04-23 19:42:15\n\nTentative patch",
    "created_at": "2012-04-23T19:42:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191661",
    "user": "https://github.com/hivert"
}
```

Attachment [trac_12808-classcall_speedup-fh.patch](tarball://root/attachments/some-uuid/ticket12808/trac_12808-classcall_speedup-fh.patch) by @hivert created at 2012-04-23 19:42:15

Tentative patch



---

archive/issue_comments_191662.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -2,4 +2,4 @@\n \n __Apply__\n \n-[attachment:trac_12808-classcall_speedup2.patch]\n+[attachment:trac_12808-classcall_speedup-fh.patch]\n``````\n",
    "created_at": "2012-04-23T19:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191662",
    "user": "https://github.com/hivert"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -2,4 +2,4 @@
 
 __Apply__
 
-[attachment:trac_12808-classcall_speedup2.patch]
+[attachment:trac_12808-classcall_speedup-fh.patch]
``````




---

archive/issue_comments_191663.json:
```json
{
    "body": "<a id='comment:28'></a>\nHow has the patch changed?",
    "created_at": "2012-04-23T21:01:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191663",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:28'></a>
How has the patch changed?



---

archive/issue_comments_191664.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [SimonKing](#comment%3A28):\n> How has the patch changed?\n\n\nOups ! Sorry I forgot to click \"submit changes\". Simon, your patch is broken. It is missing `classcall_metaclass.pxd` and as a consequence make Sage segfault as startup. I just added the file compared to your patch.\n\nFlorent",
    "created_at": "2012-04-23T21:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191664",
    "user": "https://github.com/hivert"
}
```

<a id='comment:29'></a>
Replying to [SimonKing](#comment%3A28):
> How has the patch changed?


Oups ! Sorry I forgot to click "submit changes". Simon, your patch is broken. It is missing `classcall_metaclass.pxd` and as a consequence make Sage segfault as startup. I just added the file compared to your patch.

Florent



---

archive/issue_comments_191665.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [hivert](#comment%3A29):\n> Oups ! Sorry I forgot to click \"submit changes\". Simon, your patch is broken. It is missing `classcall_metaclass.pxd` and as a consequence make Sage segfault as startup. I just added the file compared to your patch.\n\n\nAha! So, I forgot `hg add` at some point.",
    "created_at": "2012-04-24T05:08:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191665",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:30'></a>
Replying to [hivert](#comment%3A29):
> Oups ! Sorry I forgot to click "submit changes". Simon, your patch is broken. It is missing `classcall_metaclass.pxd` and as a consequence make Sage segfault as startup. I just added the file compared to your patch.


Aha! So, I forgot `hg add` at some point.



---

archive/issue_comments_191666.json:
```json
{
    "body": "<a id='comment:31'></a>\nIt is relatively easy to change nested_class.py into nested_class.pyx (though not totally trivial). But I was not able to change `NestedClassMetaclass` into a cdef class.\n\nApparently, the problem is that during initialisation of a cdef class (derived from type, at least) the name and the module of that class are not known yet. Hence, a crash in nested_pickle, which is called during initialisation. However, if one determines name and module in a different way and passes it directly to nested_pickle, then there is a different crash, and here I don't understand what is wrong, yet.",
    "created_at": "2012-04-24T06:58:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191666",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:31'></a>
It is relatively easy to change nested_class.py into nested_class.pyx (though not totally trivial). But I was not able to change `NestedClassMetaclass` into a cdef class.

Apparently, the problem is that during initialisation of a cdef class (derived from type, at least) the name and the module of that class are not known yet. Hence, a crash in nested_pickle, which is called during initialisation. However, if one determines name and module in a different way and passes it directly to nested_pickle, then there is a different crash, and here I don't understand what is wrong, yet.



---

archive/issue_comments_191667.json:
```json
{
    "body": "<a id='comment:32'></a>\nI notice that the crash seems to be related with importing the nested class examples in the nested_class module. Perhaps one needs to avoid any application of nested classes in the nested_class module, and move the examples to a different module?",
    "created_at": "2012-04-24T07:30:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191667",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:32'></a>
I notice that the crash seems to be related with importing the nested class examples in the nested_class module. Perhaps one needs to avoid any application of nested classes in the nested_class module, and move the examples to a different module?



---

archive/issue_comments_191668.json:
```json
{
    "body": "<a id='comment:33'></a>\nReplying to [SimonKing](#comment%3A32):\n> Perhaps one needs to avoid any application of nested classes in the nested_class module, and move the examples to a different module?\n\n\nNope, doesn't work.\n\nSo, currently, it seems (easily) possible to change nested_class.py into nested_class.pyx (even so that all tests pass), but impossible to change `class NestedClassMetaclass` into `cdef class NestedClassMetaclass`. Hence, probably your approach is the way to go: Introduce a new cdef class, implement fast cython methods there, and then let `ClasscallMetaclass` double inherit from the new cdef class and from `NestedClassMetaclass`.\n\nI still think that a meta-metaclass could do the same job automatically (namely: We implement various cdef classes, and the meta-metaclass combines them and turns them into a metaclass). But that is clearly a different topic.",
    "created_at": "2012-04-24T07:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191668",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:33'></a>
Replying to [SimonKing](#comment%3A32):
> Perhaps one needs to avoid any application of nested classes in the nested_class module, and move the examples to a different module?


Nope, doesn't work.

So, currently, it seems (easily) possible to change nested_class.py into nested_class.pyx (even so that all tests pass), but impossible to change `class NestedClassMetaclass` into `cdef class NestedClassMetaclass`. Hence, probably your approach is the way to go: Introduce a new cdef class, implement fast cython methods there, and then let `ClasscallMetaclass` double inherit from the new cdef class and from `NestedClassMetaclass`.

I still think that a meta-metaclass could do the same job automatically (namely: We implement various cdef classes, and the meta-metaclass combines them and turns them into a metaclass). But that is clearly a different topic.



---

archive/issue_comments_191669.json:
```json
{
    "body": "<a id='comment:34'></a>\nIt seems that indeed it is impossible to use a cdef class as metaclass - see the example that I gave at [cython-users](http://groups.google.com/group/cython-users/browse_thread/thread/f1f7f004ee06aaad).\n\nHence, I guess your indirect solution (namely to define fast methods in a cdef class `ClasscallType` and then derive from it a usual Python class `ClasscallMetaclass`) is probably the only feasible.",
    "created_at": "2012-04-24T10:19:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191669",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
It seems that indeed it is impossible to use a cdef class as metaclass - see the example that I gave at [cython-users](http://groups.google.com/group/cython-users/browse_thread/thread/f1f7f004ee06aaad).

Hence, I guess your indirect solution (namely to define fast methods in a cdef class `ClasscallType` and then derive from it a usual Python class `ClasscallMetaclass`) is probably the only feasible.



---

archive/issue_comments_191670.json:
```json
{
    "body": "<a id='comment:35'></a>\nReplying to [SimonKing](#comment%3A34):\n> It seems that indeed it is impossible to use a cdef class as metaclass - see the example that I gave at [cython-users](http://groups.google.com/group/cython-users/browse_thread/thread/f1f7f004ee06aaad).\n\n\nFor the record, It is possible ! I answered on the cython-users thread.\n\nFlorent",
    "created_at": "2012-04-24T15:05:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191670",
    "user": "https://github.com/hivert"
}
```

<a id='comment:35'></a>
Replying to [SimonKing](#comment%3A34):
> It seems that indeed it is impossible to use a cdef class as metaclass - see the example that I gave at [cython-users](http://groups.google.com/group/cython-users/browse_thread/thread/f1f7f004ee06aaad).


For the record, It is possible ! I answered on the cython-users thread.

Florent



---

archive/issue_comments_191671.json:
```json
{
    "body": "<a id='comment:36'></a>\nReplying to [hivert](#comment%3A35):\n> For the record, It is possible ! I answered on the cython-users thread.\n\n\nIndeed! It seems that changing `NestedClassMetaclass` into a cdef class with the help of your trick works fine.\n\nBy the way, the `__init__` of nested classes does nothing more than calling `nested_pickle`, but this does nothing more than to call `modify_for_nested_pickle`. That should thus be simplified, and perhaps even cpdef'd!\n\nAlso, when `nested_pickle` calls `modify_for_nested_pickle`, it always looks up `sys.modules[...]` - thus, why not store `sys.modules` in a `cdef dict` variable?!\n\nI only touched the nested classes, not `ClasscallMetaclass`, and the test suite isn't completed yet, but most seems to pass.\n\nWhat next? As I have pointed out, it seems more straight forward to cdef both `NestedClassMetaclass` and its subclass `ClasscallMetaclass` directly, not via an additional `ClasscallType`. How should it be organised?\n\nVariant 1: I produce a patch that does the changes in nested_class, and includes most of the changes from your patch (but not `ClasscallType`). Then I post it here, and we cross-review.\n\nVariant 2: I review your patch from here, and do my changes (which would revert your changes in the bases of `ClasscallMetaclass`) on a different ticket.\n\nWhat do you prefer?",
    "created_at": "2012-04-24T15:51:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191671",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:36'></a>
Replying to [hivert](#comment%3A35):
> For the record, It is possible ! I answered on the cython-users thread.


Indeed! It seems that changing `NestedClassMetaclass` into a cdef class with the help of your trick works fine.

By the way, the `__init__` of nested classes does nothing more than calling `nested_pickle`, but this does nothing more than to call `modify_for_nested_pickle`. That should thus be simplified, and perhaps even cpdef'd!

Also, when `nested_pickle` calls `modify_for_nested_pickle`, it always looks up `sys.modules[...]` - thus, why not store `sys.modules` in a `cdef dict` variable?!

I only touched the nested classes, not `ClasscallMetaclass`, and the test suite isn't completed yet, but most seems to pass.

What next? As I have pointed out, it seems more straight forward to cdef both `NestedClassMetaclass` and its subclass `ClasscallMetaclass` directly, not via an additional `ClasscallType`. How should it be organised?

Variant 1: I produce a patch that does the changes in nested_class, and includes most of the changes from your patch (but not `ClasscallType`). Then I post it here, and we cross-review.

Variant 2: I review your patch from here, and do my changes (which would revert your changes in the bases of `ClasscallMetaclass`) on a different ticket.

What do you prefer?



---

archive/issue_comments_191672.json:
```json
{
    "body": "<a id='comment:37'></a>\nHi Simon,\n\n> Also, when `nested_pickle` calls `modify_for_nested_pickle`, it always looks up `sys.modules[...]` - thus, why not store `sys.modules` in a `cdef dict` variable?!\n\n\nDoes this give a large speed-up ? I would guess that the dict search is the\nbottleneck, but without serious profiling one cannot be sure.\n\n> I only touched the nested classes, not `ClasscallMetaclass`, and the test suite isn't completed yet, but most seems to pass.\n> \n> What next? As I have pointed out, it seems more straight forward to cdef both `NestedClassMetaclass` and its subclass `ClasscallMetaclass` directly, not via an additional `ClasscallType`. How should it be organised?\n\n\nSure ! ClasscallType was for me a step before doing more in depth change in\nthe Metaclass infrastructure. I was quite scared to do those in depth change\nin Sage/Python and feared a lot of hard to debug segfaults. So I did the check\nby very small steps changing the less possible Sage files. Fortunately, it\nwent quite smooth. I planned to keep the rest of the metaclass infrastructure\nfor another patch but if you think you cdefing NestedClassMetaclass is easily\ndone, we can do both at once an thus the need of ClasscallType vanishes.\n\n> Variant 1: I produce a patch that does the changes in nested_class, and includes most of the changes from your patch (but not `ClasscallType`). Then I post it here, and we cross-review.\n> \n> Variant 2: I review your patch from here, and do my changes (which would revert your changes in the bases of `ClasscallMetaclass`) on a different ticket.\n> \n> What do you prefer?\n\n\nAs you wish ! I most probably wont be working on that ticket anymore, unless\nfor addressing some reviewer remark or to help you if you need. The two\nvariants are equal to me and you can consider yourself the owner of that\nticker if you wish. We just need to have some clean review. So if you go for\nvariant 2, I think you first need to positive review my change, and then\nrevamp them and I will review you additions.\n\nSo please shoot as you prefer ;-)\n\nFlorent",
    "created_at": "2012-04-24T23:06:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191672",
    "user": "https://github.com/hivert"
}
```

<a id='comment:37'></a>
Hi Simon,

> Also, when `nested_pickle` calls `modify_for_nested_pickle`, it always looks up `sys.modules[...]` - thus, why not store `sys.modules` in a `cdef dict` variable?!


Does this give a large speed-up ? I would guess that the dict search is the
bottleneck, but without serious profiling one cannot be sure.

> I only touched the nested classes, not `ClasscallMetaclass`, and the test suite isn't completed yet, but most seems to pass.
> 
> What next? As I have pointed out, it seems more straight forward to cdef both `NestedClassMetaclass` and its subclass `ClasscallMetaclass` directly, not via an additional `ClasscallType`. How should it be organised?


Sure ! ClasscallType was for me a step before doing more in depth change in
the Metaclass infrastructure. I was quite scared to do those in depth change
in Sage/Python and feared a lot of hard to debug segfaults. So I did the check
by very small steps changing the less possible Sage files. Fortunately, it
went quite smooth. I planned to keep the rest of the metaclass infrastructure
for another patch but if you think you cdefing NestedClassMetaclass is easily
done, we can do both at once an thus the need of ClasscallType vanishes.

> Variant 1: I produce a patch that does the changes in nested_class, and includes most of the changes from your patch (but not `ClasscallType`). Then I post it here, and we cross-review.
> 
> Variant 2: I review your patch from here, and do my changes (which would revert your changes in the bases of `ClasscallMetaclass`) on a different ticket.
> 
> What do you prefer?


As you wish ! I most probably wont be working on that ticket anymore, unless
for addressing some reviewer remark or to help you if you need. The two
variants are equal to me and you can consider yourself the owner of that
ticker if you wish. We just need to have some clean review. So if you go for
variant 2, I think you first need to positive review my change, and then
revamp them and I will review you additions.

So please shoot as you prefer ;-)

Florent



---

archive/issue_comments_191673.json:
```json
{
    "body": "<a id='comment:38'></a>\nHi Florent,\n\nReplying to [hivert](#comment%3A37):\n> > Also, when `nested_pickle` calls `modify_for_nested_pickle`, it always looks up `sys.modules[...]` - thus, why not store `sys.modules` in a `cdef dict` variable?!\n\n> \n> Does this give a large speed-up ? I would guess that the dict search is the\n> bottleneck, but without serious profiling one cannot be sure.\n\n\nLet's test:\n\n```\nsage: cython(\"\"\"\n....: import sys\n....: cdef D = sys.modules\n....: d = sys.modules\n....: def test1(name):\n....:     cdef int i\n....:     for i from 0<=i<1000000:\n....:         a = D[name]\n....: def test2(name):\n....:     cdef int i\n....:     for i from 0<=i<1000000:\n....:         a = d[name]\n....: def test3(name):\n....:     cdef int i\n....:     for i from 0<=i<1000000:\n....:         a = sys.modules[name]\n....: \"\"\")\nsage: name = \"sage\"\nsage: %time test1(name)\nCPU times: user 0.02 s, sys: 0.00 s, total: 0.02 s\nWall time: 0.02 s\nsage: %time test2(name)\nCPU times: user 0.08 s, sys: 0.00 s, total: 0.08 s\nWall time: 0.08 s\nsage: %time test3(name)\nCPU times: user 0.11 s, sys: 0.00 s, total: 0.11 s\nWall time: 0.12 s\n\"\"\")\n```\n\nConclusion: Assigning `sys.modules` to a Python variable brings a speed-up of 1/3, and assigning it to a Cython variable brings a speed-up of 5/6. So, the speed-up obtained from Cython is indeed huge.\n \n> Sure ! ClasscallType was for me a step before doing more in depth change in\n> the Metaclass infrastructure. I was quite scared to do those in depth change\n> in Sage/Python and feared a lot of hard to debug segfaults.\n\n\nFear thee not!\n\n> I planned to keep the rest of the metaclass infrastructure\n> for another patch but if you think you cdefing NestedClassMetaclass is easily\n> done, we can do both at once an thus the need of ClasscallType vanishes.\n\n\nYes, it is easily done - *if* one knows what to cimport. How did you find out?\n\n\"Easy\" means that one can really just change def into cdef. And in addition to that, I tried to call some frequently used routine directly, in order to avoid a calling overhead, and also I cpdefined that routine.\n\n> > Variant 1: I produce a patch that does the changes in nested_class, and includes most of the changes from your patch (but not `ClasscallType`). Then I post it here, and we cross-review.\n> > \n> > Variant 2: I review your patch from here, and do my changes (which would revert your changes in the bases of `ClasscallMetaclass`) on a different ticket.\n> > \n> > What do you prefer?\n\n> \n> As you wish ! I most probably wont be working on that ticket anymore, unless\n> for addressing some reviewer remark or to help you if you need. The two\n> variants are equal to me and you can consider yourself the owner of that\n> ticker if you wish. We just need to have some clean review.\n\n\nMy preference is to do it on one ticket (the common topic being \"cdefine `ClasscallMetaclass`\", which of course also involves cdefining `NestedClassMetaclass`).\n\nConcerning clean review: I would provide a patch that is to be applied before your patch (dealing with nested classes) and another one to be applied after your patch (refactoring the bases of classcall metaclass).\n\nHence, we can easily cross-review, which is considered to be \"clean\".",
    "created_at": "2012-04-25T06:37:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191673",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'></a>
Hi Florent,

Replying to [hivert](#comment%3A37):
> > Also, when `nested_pickle` calls `modify_for_nested_pickle`, it always looks up `sys.modules[...]` - thus, why not store `sys.modules` in a `cdef dict` variable?!

> 
> Does this give a large speed-up ? I would guess that the dict search is the
> bottleneck, but without serious profiling one cannot be sure.


Let's test:

```
sage: cython("""
....: import sys
....: cdef D = sys.modules
....: d = sys.modules
....: def test1(name):
....:     cdef int i
....:     for i from 0<=i<1000000:
....:         a = D[name]
....: def test2(name):
....:     cdef int i
....:     for i from 0<=i<1000000:
....:         a = d[name]
....: def test3(name):
....:     cdef int i
....:     for i from 0<=i<1000000:
....:         a = sys.modules[name]
....: """)
sage: name = "sage"
sage: %time test1(name)
CPU times: user 0.02 s, sys: 0.00 s, total: 0.02 s
Wall time: 0.02 s
sage: %time test2(name)
CPU times: user 0.08 s, sys: 0.00 s, total: 0.08 s
Wall time: 0.08 s
sage: %time test3(name)
CPU times: user 0.11 s, sys: 0.00 s, total: 0.11 s
Wall time: 0.12 s
""")
```

Conclusion: Assigning `sys.modules` to a Python variable brings a speed-up of 1/3, and assigning it to a Cython variable brings a speed-up of 5/6. So, the speed-up obtained from Cython is indeed huge.
 
> Sure ! ClasscallType was for me a step before doing more in depth change in
> the Metaclass infrastructure. I was quite scared to do those in depth change
> in Sage/Python and feared a lot of hard to debug segfaults.


Fear thee not!

> I planned to keep the rest of the metaclass infrastructure
> for another patch but if you think you cdefing NestedClassMetaclass is easily
> done, we can do both at once an thus the need of ClasscallType vanishes.


Yes, it is easily done - *if* one knows what to cimport. How did you find out?

"Easy" means that one can really just change def into cdef. And in addition to that, I tried to call some frequently used routine directly, in order to avoid a calling overhead, and also I cpdefined that routine.

> > Variant 1: I produce a patch that does the changes in nested_class, and includes most of the changes from your patch (but not `ClasscallType`). Then I post it here, and we cross-review.
> > 
> > Variant 2: I review your patch from here, and do my changes (which would revert your changes in the bases of `ClasscallMetaclass`) on a different ticket.
> > 
> > What do you prefer?

> 
> As you wish ! I most probably wont be working on that ticket anymore, unless
> for addressing some reviewer remark or to help you if you need. The two
> variants are equal to me and you can consider yourself the owner of that
> ticker if you wish. We just need to have some clean review.


My preference is to do it on one ticket (the common topic being "cdefine `ClasscallMetaclass`", which of course also involves cdefining `NestedClassMetaclass`).

Concerning clean review: I would provide a patch that is to be applied before your patch (dealing with nested classes) and another one to be applied after your patch (refactoring the bases of classcall metaclass).

Hence, we can easily cross-review, which is considered to be "clean".



---

archive/issue_comments_191674.json:
```json
{
    "body": "<a id='comment:39'></a>\nHi Simon,\n\n> Conclusion: Assigning `sys.modules` to a Python variable brings a speed-up\n> of 1/3, and assigning it to a Cython variable brings a speed-up of 5/6. So,\n> the speed-up obtained from Cython is indeed huge.\n\n\nCool ! So my intuition where wrong. This is something I don't feel very\ncomfortable with Python. When I try to predict which part of the code should\nbe optimized I'm too often wrong. I remember being much better at that in\nMuPAD. I have the impression that Python is not very predictable, but maybe\nit's just me. I guess I need to optimize more code.\n\n> > Sure ! ClasscallType was for me a step before doing more in depth change in\n> > the Metaclass infrastructure. I was quite scared to do those in depth change\n> > in Sage/Python and feared a lot of hard to debug segfaults.\n\n> \n> Fear thee not!\n\n\n;-)\n\n> > I planned to keep the rest of the metaclass infrastructure\n> > for another patch but if you think you cdefing NestedClassMetaclass is easily\n> > done, we can do both at once an thus the need of ClasscallType vanishes.\n\n> \n> Yes, it is easily done - *if* one knows what to cimport. How did you find out?\n\n\nThey is an example (writen by Robert I think) in Parent. Googling \"Cython\nsubclassing builtin\" gives some good examples:\n\n- http://wiki.cython.org/FAQ/cdef_derive\n- http://docs.cython.org/src/userguide/extension_types.html#external-extension-types\n- http://www.mail-archive.com/cython-dev`@`codespeak.net/msg04857.html\n\nI guess I was lucky too !\n\n> \"Easy\" means that one can really just change def into cdef. And in addition\n> to that, I tried to call some frequently used routine directly, in order to\n> avoid a calling overhead, and also I cpdefined that routine.\n\n\nNo weird segfault and hardcore debugging. This is easy enough ! Cool !\n\n> My preference is to do it on one ticket (the common topic being \"cdefine `ClasscallMetaclass`\", which of course also involves cdefining `NestedClassMetaclass`).\n> \n> Concerning clean review: I would provide a patch that is to be applied before your patch (dealing with nested classes) and another one to be applied after your patch (refactoring the bases of classcall metaclass).\n> \n> Hence, we can easily cross-review, which is considered to be \"clean\".\n\n\nExcellent. I'm waiting for your input. I'll have time to review it at Sage\nDays 38 if not before.\n\nFlorent",
    "created_at": "2012-04-25T07:31:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191674",
    "user": "https://github.com/hivert"
}
```

<a id='comment:39'></a>
Hi Simon,

> Conclusion: Assigning `sys.modules` to a Python variable brings a speed-up
> of 1/3, and assigning it to a Cython variable brings a speed-up of 5/6. So,
> the speed-up obtained from Cython is indeed huge.


Cool ! So my intuition where wrong. This is something I don't feel very
comfortable with Python. When I try to predict which part of the code should
be optimized I'm too often wrong. I remember being much better at that in
MuPAD. I have the impression that Python is not very predictable, but maybe
it's just me. I guess I need to optimize more code.

> > Sure ! ClasscallType was for me a step before doing more in depth change in
> > the Metaclass infrastructure. I was quite scared to do those in depth change
> > in Sage/Python and feared a lot of hard to debug segfaults.

> 
> Fear thee not!


;-)

> > I planned to keep the rest of the metaclass infrastructure
> > for another patch but if you think you cdefing NestedClassMetaclass is easily
> > done, we can do both at once an thus the need of ClasscallType vanishes.

> 
> Yes, it is easily done - *if* one knows what to cimport. How did you find out?


They is an example (writen by Robert I think) in Parent. Googling "Cython
subclassing builtin" gives some good examples:

- http://wiki.cython.org/FAQ/cdef_derive
- http://docs.cython.org/src/userguide/extension_types.html#external-extension-types
- http://www.mail-archive.com/cython-dev`@`codespeak.net/msg04857.html

I guess I was lucky too !

> "Easy" means that one can really just change def into cdef. And in addition
> to that, I tried to call some frequently used routine directly, in order to
> avoid a calling overhead, and also I cpdefined that routine.


No weird segfault and hardcore debugging. This is easy enough ! Cool !

> My preference is to do it on one ticket (the common topic being "cdefine `ClasscallMetaclass`", which of course also involves cdefining `NestedClassMetaclass`).
> 
> Concerning clean review: I would provide a patch that is to be applied before your patch (dealing with nested classes) and another one to be applied after your patch (refactoring the bases of classcall metaclass).
> 
> Hence, we can easily cross-review, which is considered to be "clean".


Excellent. I'm waiting for your input. I'll have time to review it at Sage
Days 38 if not before.

Florent



---

archive/issue_comments_191675.json:
```json
{
    "body": "<a id='comment:40'></a>\nWe suggested the following approaches towards getting fast metaclasses.\n\n* You suggested: \"Let a metaclass be a Python class that gets fast methods from a Cython class\"\n* I suggested: \"Implement the metaclass directly in Cython\" (you showed how it works)\n\nHere, I study the question whether we should expect a significant speed difference in the two approaches.\n\nLet the following be put in a pyx file that we attach to a Sage session:\n\n```\ncdef class T1:\n    def __call__(self, x):\n        return x\n\ncdef class T2:\n    def __hash__(self):\n        return 123\n\ncdef class T3:\n    def __add__(self, x):\n        return self\n\ncdef class T4:\n    def test(self, x):\n        return x\n```\n\nHence, we have Cython classes, the first three of them providing typical \"magical\" methods, the fourth a custom method. In the Sage session, we derive a Python class from the four classes, and, to make it more \"realistic\", we give a second base.\n\n```\nsage: C1 = type(\"C1\",(T1,Parent),{})\nsage: C2 = type(\"C2\",(T2,Parent),{})\nsage: C3 = type(\"C3\",(T3,Parent),{})\nsage: C4 = type(\"C4\",(T4,Parent),{})\n```\n\nC1,...,C4 correspond to metaclasses implemented as you suggest, T1,...,T4 as I suggest.\n\nIt could be that in future we want to have meta-metaclasses, which would allow to mix the metaclasses. Hence, I am also considering new classes derived from C1,...,C4 resp. from T1,...,T4:\n\n```\nsage: Cdirect = type(\"Cdirect\",(T1,T2,T3,T4,Parent),{})\nsage: Cindirect = type(\"Cindirect\",(C1,C2,C3,C4),{})       \n```\nLet us create instances of each class:\n\n```\nsage: c1 = C1()\nsage: c2 = C2()\nsage: c3 = C3()\nsage: c4 = C4()\nsage: t1 = T1()\nsage: t2 = T2() \nsage: t3 = T3()\nsage: t4 = T4()\nsage: ci = Cindirect()\nsage: cd = Cdirect()  \n```\n\nNow for the timings. First, the call method:\n\n```\nsage: timeit(\"a = c1(3)\", number=300000)    \n300000 loops, best of 3: 280 ns per loop\nsage: timeit(\"a = t1(3)\", number=300000)\n300000 loops, best of 3: 277 ns per loop\nsage: timeit(\"a = ci(3)\", number=300000)\n300000 loops, best of 3: 279 ns per loop\nsage: timeit(\"a = cd(3)\", number=300000)\n300000 loops, best of 3: 278 ns per loop\n```\n\nNext, the hash:\n\n```\nsage: timeit(\"a = hash(c2)\", number=300000)\n300000 loops, best of 3: 87.6 ns per loop\nsage: timeit(\"a = hash(t2)\", number=300000)\n300000 loops, best of 3: 85.9 ns per loop\nsage: timeit(\"a = hash(ci)\", number=300000)\n300000 loops, best of 3: 83.6 ns per loop\nsage: timeit(\"a = hash(cd)\", number=300000)\n300000 loops, best of 3: 99.7 ns per loop\n```\n\nArithmetics:\n\n```\nsage: timeit(\"a = c3+c3\", number=300000)   \n300000 loops, best of 3: 149 ns per loop\nsage: timeit(\"a = t3+t3\", number=300000)\n300000 loops, best of 3: 83 ns per loop\nsage: timeit(\"a = ci+ci\", number=300000)\n300000 loops, best of 3: 77.8 ns per loop\nsage: timeit(\"a = cd+cd\", number=300000)\n300000 loops, best of 3: 77.4 ns per loop\n```\n\nAnd a non-magical method:\n\n```\nsage: timeit(\"a = c4.test(4)\", number=300000)\n300000 loops, best of 3: 327 ns per loop\nsage: timeit(\"a = t4.test(4)\", number=300000)\n300000 loops, best of 3: 285 ns per loop\nsage: timeit(\"a = ci.test(4)\", number=300000)\n300000 loops, best of 3: 444 ns per loop\nsage: timeit(\"a = cd.test(4)\", number=300000)\n300000 loops, best of 3: 364 ns per loop\n```\n\nSummary:\n\nFor the magical methods, there is no significant speed difference between our suggestions (with exception of addition, but that result looks strange, and I don't really believe it). This would even hold if (in future) we would consider to create metaclasses \"dynamically\" (i.e., in the same way as I have created `Cindirect` and `Cdirect` above).\n\nIt only pays off to *directly* implement stuff in Cython, if non-magical methods are concerned. But I doubt that we want non-magical methods for metaclasses.\n\nSo, the decision between our suggestions must rely on different reasons: Which one is simpler and easier to maintain? The plus of my suggestion is that it is direct, i.e., there are less layers of indirection. The plus of your suggestion is that it works without creating an extension type for builtin types.\n\nAfter a break, I will attach my two patches, and then the discussion can start...",
    "created_at": "2012-04-25T14:45:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191675",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:40'></a>
We suggested the following approaches towards getting fast metaclasses.

* You suggested: "Let a metaclass be a Python class that gets fast methods from a Cython class"
* I suggested: "Implement the metaclass directly in Cython" (you showed how it works)

Here, I study the question whether we should expect a significant speed difference in the two approaches.

Let the following be put in a pyx file that we attach to a Sage session:

```
cdef class T1:
    def __call__(self, x):
        return x

cdef class T2:
    def __hash__(self):
        return 123

cdef class T3:
    def __add__(self, x):
        return self

cdef class T4:
    def test(self, x):
        return x
```

Hence, we have Cython classes, the first three of them providing typical "magical" methods, the fourth a custom method. In the Sage session, we derive a Python class from the four classes, and, to make it more "realistic", we give a second base.

```
sage: C1 = type("C1",(T1,Parent),{})
sage: C2 = type("C2",(T2,Parent),{})
sage: C3 = type("C3",(T3,Parent),{})
sage: C4 = type("C4",(T4,Parent),{})
```

C1,...,C4 correspond to metaclasses implemented as you suggest, T1,...,T4 as I suggest.

It could be that in future we want to have meta-metaclasses, which would allow to mix the metaclasses. Hence, I am also considering new classes derived from C1,...,C4 resp. from T1,...,T4:

```
sage: Cdirect = type("Cdirect",(T1,T2,T3,T4,Parent),{})
sage: Cindirect = type("Cindirect",(C1,C2,C3,C4),{})       
```
Let us create instances of each class:

```
sage: c1 = C1()
sage: c2 = C2()
sage: c3 = C3()
sage: c4 = C4()
sage: t1 = T1()
sage: t2 = T2() 
sage: t3 = T3()
sage: t4 = T4()
sage: ci = Cindirect()
sage: cd = Cdirect()  
```

Now for the timings. First, the call method:

```
sage: timeit("a = c1(3)", number=300000)    
300000 loops, best of 3: 280 ns per loop
sage: timeit("a = t1(3)", number=300000)
300000 loops, best of 3: 277 ns per loop
sage: timeit("a = ci(3)", number=300000)
300000 loops, best of 3: 279 ns per loop
sage: timeit("a = cd(3)", number=300000)
300000 loops, best of 3: 278 ns per loop
```

Next, the hash:

```
sage: timeit("a = hash(c2)", number=300000)
300000 loops, best of 3: 87.6 ns per loop
sage: timeit("a = hash(t2)", number=300000)
300000 loops, best of 3: 85.9 ns per loop
sage: timeit("a = hash(ci)", number=300000)
300000 loops, best of 3: 83.6 ns per loop
sage: timeit("a = hash(cd)", number=300000)
300000 loops, best of 3: 99.7 ns per loop
```

Arithmetics:

```
sage: timeit("a = c3+c3", number=300000)   
300000 loops, best of 3: 149 ns per loop
sage: timeit("a = t3+t3", number=300000)
300000 loops, best of 3: 83 ns per loop
sage: timeit("a = ci+ci", number=300000)
300000 loops, best of 3: 77.8 ns per loop
sage: timeit("a = cd+cd", number=300000)
300000 loops, best of 3: 77.4 ns per loop
```

And a non-magical method:

```
sage: timeit("a = c4.test(4)", number=300000)
300000 loops, best of 3: 327 ns per loop
sage: timeit("a = t4.test(4)", number=300000)
300000 loops, best of 3: 285 ns per loop
sage: timeit("a = ci.test(4)", number=300000)
300000 loops, best of 3: 444 ns per loop
sage: timeit("a = cd.test(4)", number=300000)
300000 loops, best of 3: 364 ns per loop
```

Summary:

For the magical methods, there is no significant speed difference between our suggestions (with exception of addition, but that result looks strange, and I don't really believe it). This would even hold if (in future) we would consider to create metaclasses "dynamically" (i.e., in the same way as I have created `Cindirect` and `Cdirect` above).

It only pays off to *directly* implement stuff in Cython, if non-magical methods are concerned. But I doubt that we want non-magical methods for metaclasses.

So, the decision between our suggestions must rely on different reasons: Which one is simpler and easier to maintain? The plus of my suggestion is that it is direct, i.e., there are less layers of indirection. The plus of your suggestion is that it works without creating an extension type for builtin types.

After a break, I will attach my two patches, and then the discussion can start...



---

archive/issue_comments_191676.json:
```json
{
    "body": "Attachment [trac_12808-classcall_cdef.patch](tarball://root/attachments/some-uuid/ticket12808/trac_12808-classcall_cdef.patch) by @simon-king-jena created at 2012-04-25 15:58:26\n\nMake ClasscallMetaclass an extension type of type",
    "created_at": "2012-04-25T15:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191676",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_12808-classcall_cdef.patch](tarball://root/attachments/some-uuid/ticket12808/trac_12808-classcall_cdef.patch) by @simon-king-jena created at 2012-04-25 15:58:26

Make ClasscallMetaclass an extension type of type



---

archive/issue_comments_191677.json:
```json
{
    "body": "Changing author from \"Florent Hivert\" to \"Florent Hivert, Simon King\"",
    "created_at": "2012-04-25T16:08:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191677",
    "user": "https://github.com/simon-king-jena"
}
```

Changing author from "Florent Hivert" to "Florent Hivert, Simon King"



---

archive/issue_comments_191678.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -2,4 +2,10 @@\n \n __Apply__\n \n-[attachment:trac_12808-classcall_speedup-fh.patch]\n+* [attachment:trac_12808-classcall_speedup-fh.patch]\n+* [attachment:trac_12808_nested_class_cython.patch]\n+\n+and we have to decide whether the third patch helps to make the code clearer:\n+\n+* [attachment:trac_12808-classcall_cdef.patch]\n+\n``````\n",
    "created_at": "2012-04-25T16:08:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191678",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -2,4 +2,10 @@
 
 __Apply__
 
-[attachment:trac_12808-classcall_speedup-fh.patch]
+* [attachment:trac_12808-classcall_speedup-fh.patch]
+* [attachment:trac_12808_nested_class_cython.patch]
+
+and we have to decide whether the third patch helps to make the code clearer:
+
+* [attachment:trac_12808-classcall_cdef.patch]
+
``````




---

archive/issue_comments_191679.json:
```json
{
    "body": "<a id='comment:41'></a>\nI have attached my two patches. Your patch and my patch actually turn out to be independent.\n\nPurpose of my first patch: Make `NestedClassMetaclass` an extension type of type, and avoid some calling overhead during its creation.\n\nPurpose of my second patch: Make `ClasscallMetclass` an extension type as well, directly derived from `NestedClassMetaclass`.\n\n**__Timings__**\n\nWith **sage-5.1.notebook unpatched**, I get for Florent's examples\n\n```\nsage: class Rien(object):\n....:     pass\n....:\nsage: from sage.misc.classcall_metaclass import ClasscallMetaclass\nsage: class NOCALL(object):\n....:     __metaclass__ = ClasscallMetaclass\n....:     pass\n....:\nsage: %timeit [Rien() for i in range(10000)]\n125 loops, best of 3: 1.74 ms per loop\nsage: %timeit [NOCALL() for i in range(10000)]\n25 loops, best of 3: 16.7 ms per loop\nsage: class CALL(object):\n....:     __metaclass__ = ClasscallMetaclass\n....:     @staticmethod\n....:     def __classcall_private__(cls, arg):\n....:         arg = arg + arg\n....:         return arg\n....:\nsage: %timeit [CALL(i) for i in range(10000)]\n25 loops, best of 3: 9.05 ms per loop\n```\nHere is something with `__classcall__` instead of `__classcall_private__`, and in a way that has less overhead than `arg+arg`:\n\n```\nsage: class NewCall(object):\n....:     __metaclass__ = ClasscallMetaclass\n....:     @staticmethod\n....:     def __classcall__(cls, C):\n....:         return C\n....:\nsage: C = ZZ.__class__\nsage: timeit(\"a = NewCall(C)\", number=10000)\n10000 loops, best of 3: 878 ns per loop\n```\nAnd finally a \"nested class\" example:\n\n```\nsage: from sage.misc.nested_class import NestedClassMetaclass\nsage: def test_nest():\n....:     class A:\n....:         __metaclass__ = NestedClassMetaclass\n....:         class B:\n....:             pass\n....:\nsage: %timeit test_nest()\n625 loops, best of 3: 33.1 \u00b5s per loop\n```\n\nNow, the same examples with my first patch:\n\n```\nsage: %timeit [Rien() for i in range(10000)]\n125 loops, best of 3: 1.76 ms per loop\nsage: %timeit [NOCALL() for i in range(10000)]\n25 loops, best of 3: 18.3 ms per loop\nsage: %timeit [CALL(i) for i in range(10000)]\n25 loops, best of 3: 10.7 ms per loop\nsage: %timeit test_nest()\n625 loops, best of 3: 23.6 \u00b5s per loop\n```\n\nNow, with your patch only:\n\n```\nsage: %timeit [Rien() for i in range(10000)]\n125 loops, best of 3: 1.77 ms per loop\nsage: %timeit [NOCALL() for i in range(10000)]\n125 loops, best of 3: 2.05 ms per loop\nsage: %timeit [CALL(i) for i in range(10000)]\n125 loops, best of 3: 4.34 ms per loop\nsage: timeit(\"a = NewCall(C)\", number=10000)\n10000 loops, best of 3: 889 ns per loop\nsage: %timeit test_nest()\n625 loops, best of 3: 32.8 \u00b5s per loop\n```\n\nThus, our patches treat orthogonal aspects. Now, the first two patches together:\n\n```\nsage: %timeit [Rien() for i in range(10000)]\n125 loops, best of 3: 1.78 ms per loop\nsage: %timeit [NOCALL() for i in range(10000)]\n125 loops, best of 3: 2 ms per loop\nsage: %timeit [CALL(i) for i in range(10000)]\n125 loops, best of 3: 4.34 ms per loop\nsage: timeit(\"a = NewCall(C)\", number=10000)\n10000 loops, best of 3: 895 ns per loop\nsage: %timeit test_nest()\n625 loops, best of 3: 23.6 \u00b5s per loop\n```\n\nAnd with all three patches:\n\n```\nsage: %timeit [Rien() for i in range(10000)]\n125 loops, best of 3: 1.75 ms per loop\nsage: %timeit [NOCALL() for i in range(10000)]\n125 loops, best of 3: 2.08 ms per loop\nsage: %timeit [CALL(i) for i in range(10000)]\n125 loops, best of 3: 4.44 ms per loop\nsage: timeit(\"a = NewCall(C)\", number=10000)\n10000 loops, best of 3: 897 ns per loop\nsage: %timeit test_nest()\n625 loops, best of 3: 23.6 \u00b5s per loop\n```\n\n__CONCLUSION__\n\nMy first patch does improve the time spent for the creation of a nested class. Your patch improves a lot of things for classcall metaclass. My second patch makes (I think) the inheritance a bit clearer, but it does not provide a speed-up. The reason is explained in my previous post.\n\nApply trac_12808-classcall_speedup-fh.patch trac_12808_nested_class_cython.patch trac_12808-classcall_cdef.patch",
    "created_at": "2012-04-25T16:08:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191679",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:41'></a>
I have attached my two patches. Your patch and my patch actually turn out to be independent.

Purpose of my first patch: Make `NestedClassMetaclass` an extension type of type, and avoid some calling overhead during its creation.

Purpose of my second patch: Make `ClasscallMetclass` an extension type as well, directly derived from `NestedClassMetaclass`.

**__Timings__**

With **sage-5.1.notebook unpatched**, I get for Florent's examples

```
sage: class Rien(object):
....:     pass
....:
sage: from sage.misc.classcall_metaclass import ClasscallMetaclass
sage: class NOCALL(object):
....:     __metaclass__ = ClasscallMetaclass
....:     pass
....:
sage: %timeit [Rien() for i in range(10000)]
125 loops, best of 3: 1.74 ms per loop
sage: %timeit [NOCALL() for i in range(10000)]
25 loops, best of 3: 16.7 ms per loop
sage: class CALL(object):
....:     __metaclass__ = ClasscallMetaclass
....:     @staticmethod
....:     def __classcall_private__(cls, arg):
....:         arg = arg + arg
....:         return arg
....:
sage: %timeit [CALL(i) for i in range(10000)]
25 loops, best of 3: 9.05 ms per loop
```
Here is something with `__classcall__` instead of `__classcall_private__`, and in a way that has less overhead than `arg+arg`:

```
sage: class NewCall(object):
....:     __metaclass__ = ClasscallMetaclass
....:     @staticmethod
....:     def __classcall__(cls, C):
....:         return C
....:
sage: C = ZZ.__class__
sage: timeit("a = NewCall(C)", number=10000)
10000 loops, best of 3: 878 ns per loop
```
And finally a "nested class" example:

```
sage: from sage.misc.nested_class import NestedClassMetaclass
sage: def test_nest():
....:     class A:
....:         __metaclass__ = NestedClassMetaclass
....:         class B:
....:             pass
....:
sage: %timeit test_nest()
625 loops, best of 3: 33.1 µs per loop
```

Now, the same examples with my first patch:

```
sage: %timeit [Rien() for i in range(10000)]
125 loops, best of 3: 1.76 ms per loop
sage: %timeit [NOCALL() for i in range(10000)]
25 loops, best of 3: 18.3 ms per loop
sage: %timeit [CALL(i) for i in range(10000)]
25 loops, best of 3: 10.7 ms per loop
sage: %timeit test_nest()
625 loops, best of 3: 23.6 µs per loop
```

Now, with your patch only:

```
sage: %timeit [Rien() for i in range(10000)]
125 loops, best of 3: 1.77 ms per loop
sage: %timeit [NOCALL() for i in range(10000)]
125 loops, best of 3: 2.05 ms per loop
sage: %timeit [CALL(i) for i in range(10000)]
125 loops, best of 3: 4.34 ms per loop
sage: timeit("a = NewCall(C)", number=10000)
10000 loops, best of 3: 889 ns per loop
sage: %timeit test_nest()
625 loops, best of 3: 32.8 µs per loop
```

Thus, our patches treat orthogonal aspects. Now, the first two patches together:

```
sage: %timeit [Rien() for i in range(10000)]
125 loops, best of 3: 1.78 ms per loop
sage: %timeit [NOCALL() for i in range(10000)]
125 loops, best of 3: 2 ms per loop
sage: %timeit [CALL(i) for i in range(10000)]
125 loops, best of 3: 4.34 ms per loop
sage: timeit("a = NewCall(C)", number=10000)
10000 loops, best of 3: 895 ns per loop
sage: %timeit test_nest()
625 loops, best of 3: 23.6 µs per loop
```

And with all three patches:

```
sage: %timeit [Rien() for i in range(10000)]
125 loops, best of 3: 1.75 ms per loop
sage: %timeit [NOCALL() for i in range(10000)]
125 loops, best of 3: 2.08 ms per loop
sage: %timeit [CALL(i) for i in range(10000)]
125 loops, best of 3: 4.44 ms per loop
sage: timeit("a = NewCall(C)", number=10000)
10000 loops, best of 3: 897 ns per loop
sage: %timeit test_nest()
625 loops, best of 3: 23.6 µs per loop
```

__CONCLUSION__

My first patch does improve the time spent for the creation of a nested class. Your patch improves a lot of things for classcall metaclass. My second patch makes (I think) the inheritance a bit clearer, but it does not provide a speed-up. The reason is explained in my previous post.

Apply trac_12808-classcall_speedup-fh.patch trac_12808_nested_class_cython.patch trac_12808-classcall_cdef.patch



---

archive/issue_comments_191680.json:
```json
{
    "body": "<a id='comment:42'></a>\nHi Simon,\n\nThanks a lot for this in depth timing measurement !\n\n> My first patch does improve the time spent for the creation of a nested\n> class.\n\n\nExcellent !\n\n> Your patch improves a lot of things for classcall metaclass. My second patch\n> makes (I think) the inheritance a bit clearer, but it does not provide a\n> speed-up. The reason is explained in my previous post.\n\n\nI fully agree that it is clearer. There may be however some speed penalty with\ngetting rid of `ClasscallType` if we need at some point to construct a lot\nof classes which need the classcall trick but without nested classes. I don't\nknow if this usecase is realistic at all. Do you have any idea on this\nquestion ? I don't even know if the current dynamic class allows it. Anyway,\nthere won't be any overhead from the point of view of the instances creation\nand, manipulation but there may be when creating the **classes**\nthemselves. Therefore I think we should measure the relative price of creating\n**classes** which `ClasscallType` vs `ClasscallMetaclass`. I'll\ninvestigate this while reviewing your patch.\n\nSo my current opinion is: we should do the timing while we can easily do\nit. Then if nothing is measurable with the current Sage usage, but measurable\nwith some weird one, we should remove `ClasscallType` (any unused code and\nmoreover confusing code shouldn't remain) keeping somewhere a note saying that\nif the weird usecase appear (which I don't really believe) we should separate\n`ClasscallType` vs `ClasscallMetaclass`.\n\nCheers,\n\nFlorent",
    "created_at": "2012-04-25T16:35:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191680",
    "user": "https://github.com/hivert"
}
```

<a id='comment:42'></a>
Hi Simon,

Thanks a lot for this in depth timing measurement !

> My first patch does improve the time spent for the creation of a nested
> class.


Excellent !

> Your patch improves a lot of things for classcall metaclass. My second patch
> makes (I think) the inheritance a bit clearer, but it does not provide a
> speed-up. The reason is explained in my previous post.


I fully agree that it is clearer. There may be however some speed penalty with
getting rid of `ClasscallType` if we need at some point to construct a lot
of classes which need the classcall trick but without nested classes. I don't
know if this usecase is realistic at all. Do you have any idea on this
question ? I don't even know if the current dynamic class allows it. Anyway,
there won't be any overhead from the point of view of the instances creation
and, manipulation but there may be when creating the **classes**
themselves. Therefore I think we should measure the relative price of creating
**classes** which `ClasscallType` vs `ClasscallMetaclass`. I'll
investigate this while reviewing your patch.

So my current opinion is: we should do the timing while we can easily do
it. Then if nothing is measurable with the current Sage usage, but measurable
with some weird one, we should remove `ClasscallType` (any unused code and
moreover confusing code shouldn't remain) keeping somewhere a note saying that
if the weird usecase appear (which I don't really believe) we should separate
`ClasscallType` vs `ClasscallMetaclass`.

Cheers,

Florent



---

archive/issue_comments_191681.json:
```json
{
    "body": "<a id='comment:43'></a>\nDear Florent,\n\nReplying to [hivert](#comment%3A42):\n> I fully agree that it is clearer. There may be however some speed penalty with\n> getting rid of `ClasscallType` if we need at some point to construct a lot\n> of classes which need the classcall trick but without nested classes.\n\n\nWell, the problem is as I have explained in the sage-combinat-devel thread. Some classes would actually not use more than the `__call__` method (so, morally, `ClasscallMetaclass` should only do this one thing), while some would only need nesting or another `__init__` (so, `NestedClassMetaclass` should only do this one thing), and others only need a custom `__reduce__` method (so, `DynamicMetaclass` should only to this one thing).\n\nHowever, in typical applications, we want to construct a class that simultaneously derives from classes with different metaclasses. That is only possible if we have metaclasses that combine different features. Hence, `ClasscallMetaclass` inherits from `NestedClassMetaclass` (although it often does not need nesting), and there is an additional `DynamicClasscallMetaclass`, just to cope with dynamic classes that have a classcall.\n\nI'd really like to have these combined metaclasses created automatically, hence, using a meta-metaclass.\n\nConcerning time penalty: As I have demonstrated above, there is no time penalty for special methods of a class C that are inherited from different Cython classes - even if the inheritance is indirect. A speed penalty only seems to occur, if one has an *indirect* inheritance of *non-magical* methods.\n\nHence, if C is actually used as a metaclass, I would expect that both approaches (defining the fast magical methods in `ClasscallType` and other auxiliar types or directly in `ClasscallMetaclass` and other metaclasses) are equal, speed-wise.\n\n> I don't\n> know if this usecase is realistic at all.\n\n\nSee above: There *is* need for combined metaclasses, even though in some applications a pure one-trick metaclass would be enough.\n\n> Anyway,\n> there won't be any overhead from the point of view of the instances creation\n> and, manipulation but there may be when creating the **classes**\n> themselves.\n\n\nWell, the timings that I presented were for a class C, and I measured some methods (e.g. `__call__`) of its instances. However, I think the same observations will hold if C actually is a *meta*class, and we would measure `__call__` etc. of its instances (which are classes).\n\nBut of course the time for creating (not just for calling) the instances matters as well.\n\nCheers,\n\nSimon",
    "created_at": "2012-04-25T18:30:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191681",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:43'></a>
Dear Florent,

Replying to [hivert](#comment%3A42):
> I fully agree that it is clearer. There may be however some speed penalty with
> getting rid of `ClasscallType` if we need at some point to construct a lot
> of classes which need the classcall trick but without nested classes.


Well, the problem is as I have explained in the sage-combinat-devel thread. Some classes would actually not use more than the `__call__` method (so, morally, `ClasscallMetaclass` should only do this one thing), while some would only need nesting or another `__init__` (so, `NestedClassMetaclass` should only do this one thing), and others only need a custom `__reduce__` method (so, `DynamicMetaclass` should only to this one thing).

However, in typical applications, we want to construct a class that simultaneously derives from classes with different metaclasses. That is only possible if we have metaclasses that combine different features. Hence, `ClasscallMetaclass` inherits from `NestedClassMetaclass` (although it often does not need nesting), and there is an additional `DynamicClasscallMetaclass`, just to cope with dynamic classes that have a classcall.

I'd really like to have these combined metaclasses created automatically, hence, using a meta-metaclass.

Concerning time penalty: As I have demonstrated above, there is no time penalty for special methods of a class C that are inherited from different Cython classes - even if the inheritance is indirect. A speed penalty only seems to occur, if one has an *indirect* inheritance of *non-magical* methods.

Hence, if C is actually used as a metaclass, I would expect that both approaches (defining the fast magical methods in `ClasscallType` and other auxiliar types or directly in `ClasscallMetaclass` and other metaclasses) are equal, speed-wise.

> I don't
> know if this usecase is realistic at all.


See above: There *is* need for combined metaclasses, even though in some applications a pure one-trick metaclass would be enough.

> Anyway,
> there won't be any overhead from the point of view of the instances creation
> and, manipulation but there may be when creating the **classes**
> themselves.


Well, the timings that I presented were for a class C, and I measured some methods (e.g. `__call__`) of its instances. However, I think the same observations will hold if C actually is a *meta*class, and we would measure `__call__` etc. of its instances (which are classes).

But of course the time for creating (not just for calling) the instances matters as well.

Cheers,

Simon



---

archive/issue_comments_191682.json:
```json
{
    "body": "<a id='comment:44'></a>\nReplying to [SimonKing](#comment%3A43):\n> But of course the time for creating (not just for calling) the instances matters as well.\n\n\nIn my previous posts, I have demonstrated that some \"magical\" methods are equally fast for a cdef class and for a python class that inherits from the cdef class. See `__call__`, `__hash__` and `__add__`. I only found a speed penalty for inherited non-magical methods.\n\nHowever, the creation of instances is indeed A LOT faster for cdef classes than for Python classes. Recall the definition of T1, ..., T4, C1, ..., C4, Cdirect and Cindirect. We get\n\n```\nsage: timeit(\"a = T1()\", number=300000)      \n300000 loops, best of 3: 102 ns per loop\nsage: timeit(\"a = T2()\", number=300000)\n300000 loops, best of 3: 102 ns per loop\nsage: timeit(\"a = T3()\", number=300000)\n300000 loops, best of 3: 102 ns per loop\nsage: timeit(\"a = T4()\", number=300000)\n300000 loops, best of 3: 102 ns per loop\nsage: timeit(\"a = C1()\", number=300000)\n300000 loops, best of 3: 16.9 \u00b5s per loop\nsage: timeit(\"a = C2()\", number=300000)\n300000 loops, best of 3: 17 \u00b5s per loop\nsage: timeit(\"a = C3()\", number=300000)\n300000 loops, best of 3: 17.2 \u00b5s per loop\nsage: timeit(\"a = C4()\", number=300000)\n300000 loops, best of 3: 17 \u00b5s per loop\nsage: timeit(\"a = Cdirect()\", number=300000)\n300000 loops, best of 3: 18.8 \u00b5s per loop\nsage: timeit(\"a = Cindirect()\", number=300000)\n300000 loops, best of 3: 20.1 \u00b5s per loop\n```\n\nAccording to these timings, I would expect that the creation of classes with an actual cdef metaclass (as with my second patch) is faster than the creation of classes with a Python metaclass that inherits from a cdef class (like `ClasscallType`). Let's test:\n\n```\nsage: cython(\"\"\"\n....: from sage.misc.classcall_metaclass import ClasscallMetaclass\n....: def test_creation():\n....:     class A:\n....:         __metaclass__ = ClasscallMetaclass  \n....:         @staticmethod\n....:         def __classcall__(cls, x):\n....:             return x\n....: \"\"\")    \n```\n\nWithout patches:\n\n```\nsage: timeit(\"test_creation()\", number=10000)\n10000 loops, best of 3: 41.7 \u00b5s per loop\n```\n\nWith your patch only:\n\n```\nsage: timeit(\"test_creation()\", number=10000)\n10000 loops, best of 3: 45.8 \u00b5s per loop\n```\n\nWith the first two patches:\n\n```\nsage: timeit(\"test_creation()\", number=10000)\n10000 loops, best of 3: 38.5 \u00b5s per loop\n```\n\nWith all three patches:\n\n```\nsage: timeit(\"test_creation()\", number=10000) \n10000 loops, best of 3: 38.5 \u00b5s per loop\n```\n\nAnd when cimporting the metaclass (which of course only works with all three patches):\n\n```\nsage: cython(\"\"\"\n....: from sage.misc.classcall_metaclass cimport ClasscallMetaclass\n....: def test_creation():\n....:     class A:\n....:         __metaclass__ = ClasscallMetaclass  \n....:         @staticmethod\n....:         def __classcall__(cls, x):\n....:             return x\n....: \"\"\")    \nsage: timeit(\"test_creation()\", number=10000)\n10000 loops, best of 3: 38.2 \u00b5s per loop\n```\n\nIn other words: It seems that directly cdefining the metaclasses is not only clearer than the use of `ClasscallType`, but it is indeed a little (but not much) faster.",
    "created_at": "2012-04-25T22:33:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191682",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:44'></a>
Replying to [SimonKing](#comment%3A43):
> But of course the time for creating (not just for calling) the instances matters as well.


In my previous posts, I have demonstrated that some "magical" methods are equally fast for a cdef class and for a python class that inherits from the cdef class. See `__call__`, `__hash__` and `__add__`. I only found a speed penalty for inherited non-magical methods.

However, the creation of instances is indeed A LOT faster for cdef classes than for Python classes. Recall the definition of T1, ..., T4, C1, ..., C4, Cdirect and Cindirect. We get

```
sage: timeit("a = T1()", number=300000)      
300000 loops, best of 3: 102 ns per loop
sage: timeit("a = T2()", number=300000)
300000 loops, best of 3: 102 ns per loop
sage: timeit("a = T3()", number=300000)
300000 loops, best of 3: 102 ns per loop
sage: timeit("a = T4()", number=300000)
300000 loops, best of 3: 102 ns per loop
sage: timeit("a = C1()", number=300000)
300000 loops, best of 3: 16.9 µs per loop
sage: timeit("a = C2()", number=300000)
300000 loops, best of 3: 17 µs per loop
sage: timeit("a = C3()", number=300000)
300000 loops, best of 3: 17.2 µs per loop
sage: timeit("a = C4()", number=300000)
300000 loops, best of 3: 17 µs per loop
sage: timeit("a = Cdirect()", number=300000)
300000 loops, best of 3: 18.8 µs per loop
sage: timeit("a = Cindirect()", number=300000)
300000 loops, best of 3: 20.1 µs per loop
```

According to these timings, I would expect that the creation of classes with an actual cdef metaclass (as with my second patch) is faster than the creation of classes with a Python metaclass that inherits from a cdef class (like `ClasscallType`). Let's test:

```
sage: cython("""
....: from sage.misc.classcall_metaclass import ClasscallMetaclass
....: def test_creation():
....:     class A:
....:         __metaclass__ = ClasscallMetaclass  
....:         @staticmethod
....:         def __classcall__(cls, x):
....:             return x
....: """)    
```

Without patches:

```
sage: timeit("test_creation()", number=10000)
10000 loops, best of 3: 41.7 µs per loop
```

With your patch only:

```
sage: timeit("test_creation()", number=10000)
10000 loops, best of 3: 45.8 µs per loop
```

With the first two patches:

```
sage: timeit("test_creation()", number=10000)
10000 loops, best of 3: 38.5 µs per loop
```

With all three patches:

```
sage: timeit("test_creation()", number=10000) 
10000 loops, best of 3: 38.5 µs per loop
```

And when cimporting the metaclass (which of course only works with all three patches):

```
sage: cython("""
....: from sage.misc.classcall_metaclass cimport ClasscallMetaclass
....: def test_creation():
....:     class A:
....:         __metaclass__ = ClasscallMetaclass  
....:         @staticmethod
....:         def __classcall__(cls, x):
....:             return x
....: """)    
sage: timeit("test_creation()", number=10000)
10000 loops, best of 3: 38.2 µs per loop
```

In other words: It seems that directly cdefining the metaclasses is not only clearer than the use of `ClasscallType`, but it is indeed a little (but not much) faster.



---

archive/issue_comments_191683.json:
```json
{
    "body": "<a id='comment:45'></a>\nHi Simon,\n\nThanks again for those very precise timing measures. I'm sorry I wasn't\ncompletely clear on the timing I wanted to have. Here is what I hope is a\nclearer explanation:\n\nThere is a common usage of `ClasscallMetaclass` and\n`__classcall_private__` for elements in order to delegate the creation to\nthe parent. For example, the call\n\n```\nsage: PerfectMatching([(1,2),(3,4)])\nPerfectMatching [(1, 2), (3, 4)]\n```\nactually create the parent:\n\n```\nsage: P4 = PerfectMatchings(4); P4\nSet of perfect matchings of {1, 2, 3, 4}\n```\nAnd calls\n\n```\nsage: P4([(1,2),(3,4)])\nPerfectMatching [(1, 2), (3, 4)]\n```\nThis is done by a classcall trick. There isn't currently a lot of this trick\nin Sage library but many more are coming from the Sage-combinat queue.\n\nNow I don't see any element class having a nested class. So in an ideal world,\nwe'd like to have `PerfectMatching` in `ClasscallMetaclass` but not in\n`NestedClassMetaclass`. From your timings, I clearly see that being in\n`NestedClassMetaclass` doesn't impact creation of the element, but I was\nwondering how it impact the creation of the class `element_class`\nitself. As I said, I don't currently see any usecase where we will create a\nlot of `element_class` but who knows...\n\nSo here are the timings:\n\n```\nsage: from sage.misc.classcall_metaclass import ClasscallType\nsage: from sage.structure.element import Element\n\nsage: %timeit  type('toto', (Element,), {})\n625 loops, best of 3: 25.9 \u00b5s per loop\nsage: %timeit  ClasscallType('toto', (Element,), {})\n625 loops, best of 3: 31 \u00b5s per loop\n```\nWith your patch cdefing `NestedclassMetaclass`, there is a slight overhead\nin being in `NestedClassMetaclass`:\n\n```\nsage: %timeit  ClasscallMetaclass('toto', (Element,), {})\n625 loops, best of 3: 36.9 \u00b5s per loop\n```\nThe overhead is quite similar when `NestedclassMetaclass` is not cdef:\n\n```\nsage: %timeit  ClasscallMetaclass('toto', (Element,), {})\n625 loops, best of 3: 37.2 \u00b5s per loop\n```\nNow this case is not very realistic since there are no methods in the new\nclass. Let's put some by getting a realistic dictionary:\n\n```\nsage: dct = dict(PerfectMatching.__dict__)\nsage: len(dct)\n24\n```\nWith a cdef `NestedclassMetaclass`\n\n```\nsage: %timeit  type('toto', (Element,), dct)\n625 loops, best of 3: 27 \u00b5s per loop\nsage: %timeit  ClasscallType('toto', (Element,), dct)\n625 loops, best of 3: 31.7 \u00b5s per loop\nsage: %timeit  ClasscallMetaclass('toto', (Element,), dct)\n625 loops, best of 3: 48.9 \u00b5s per loop\n```\nWithout a cdef `NestedclassMetaclass`\n\n```\nsage: %timeit  type('toto', (Element,), dct)\n625 loops, best of 3: 28.8 \u00b5s per loop\nsage: %timeit  ClasscallType('toto', (Element,), dct)\n625 loops, best of 3: 32.5 \u00b5s per loop\nsage: %timeit  ClasscallMetaclass('toto', (Element,), dct)\n625 loops, best of 3: 50.6 \u00b5s per loop\n```\n\n\nAs a conclusion in some realistic usecases: the slowdown for having\n`ClasscallMetaclass` systematically inheriting from\n`NestedclassMetaclass`, that is no `ClasscallType` is 48.9 \u00b5s vs 31.7\n\u00b5s. This is non negligible (after all calling the\n`modify_for_nested_pickle` indeed has a cost) but much less that I\nexpected. Since I see no realistic usage in creating a lot of such classes, I\nthink I'm Ok with your second patch. I'd like to have Nicolas opinion on that,\nsince he is the one that raised this question.\n\nI'm reviewing your two patches (after having lunch).\n\nFlorent",
    "created_at": "2012-04-26T12:40:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191683",
    "user": "https://github.com/hivert"
}
```

<a id='comment:45'></a>
Hi Simon,

Thanks again for those very precise timing measures. I'm sorry I wasn't
completely clear on the timing I wanted to have. Here is what I hope is a
clearer explanation:

There is a common usage of `ClasscallMetaclass` and
`__classcall_private__` for elements in order to delegate the creation to
the parent. For example, the call

```
sage: PerfectMatching([(1,2),(3,4)])
PerfectMatching [(1, 2), (3, 4)]
```
actually create the parent:

```
sage: P4 = PerfectMatchings(4); P4
Set of perfect matchings of {1, 2, 3, 4}
```
And calls

```
sage: P4([(1,2),(3,4)])
PerfectMatching [(1, 2), (3, 4)]
```
This is done by a classcall trick. There isn't currently a lot of this trick
in Sage library but many more are coming from the Sage-combinat queue.

Now I don't see any element class having a nested class. So in an ideal world,
we'd like to have `PerfectMatching` in `ClasscallMetaclass` but not in
`NestedClassMetaclass`. From your timings, I clearly see that being in
`NestedClassMetaclass` doesn't impact creation of the element, but I was
wondering how it impact the creation of the class `element_class`
itself. As I said, I don't currently see any usecase where we will create a
lot of `element_class` but who knows...

So here are the timings:

```
sage: from sage.misc.classcall_metaclass import ClasscallType
sage: from sage.structure.element import Element

sage: %timeit  type('toto', (Element,), {})
625 loops, best of 3: 25.9 µs per loop
sage: %timeit  ClasscallType('toto', (Element,), {})
625 loops, best of 3: 31 µs per loop
```
With your patch cdefing `NestedclassMetaclass`, there is a slight overhead
in being in `NestedClassMetaclass`:

```
sage: %timeit  ClasscallMetaclass('toto', (Element,), {})
625 loops, best of 3: 36.9 µs per loop
```
The overhead is quite similar when `NestedclassMetaclass` is not cdef:

```
sage: %timeit  ClasscallMetaclass('toto', (Element,), {})
625 loops, best of 3: 37.2 µs per loop
```
Now this case is not very realistic since there are no methods in the new
class. Let's put some by getting a realistic dictionary:

```
sage: dct = dict(PerfectMatching.__dict__)
sage: len(dct)
24
```
With a cdef `NestedclassMetaclass`

```
sage: %timeit  type('toto', (Element,), dct)
625 loops, best of 3: 27 µs per loop
sage: %timeit  ClasscallType('toto', (Element,), dct)
625 loops, best of 3: 31.7 µs per loop
sage: %timeit  ClasscallMetaclass('toto', (Element,), dct)
625 loops, best of 3: 48.9 µs per loop
```
Without a cdef `NestedclassMetaclass`

```
sage: %timeit  type('toto', (Element,), dct)
625 loops, best of 3: 28.8 µs per loop
sage: %timeit  ClasscallType('toto', (Element,), dct)
625 loops, best of 3: 32.5 µs per loop
sage: %timeit  ClasscallMetaclass('toto', (Element,), dct)
625 loops, best of 3: 50.6 µs per loop
```


As a conclusion in some realistic usecases: the slowdown for having
`ClasscallMetaclass` systematically inheriting from
`NestedclassMetaclass`, that is no `ClasscallType` is 48.9 µs vs 31.7
µs. This is non negligible (after all calling the
`modify_for_nested_pickle` indeed has a cost) but much less that I
expected. Since I see no realistic usage in creating a lot of such classes, I
think I'm Ok with your second patch. I'd like to have Nicolas opinion on that,
since he is the one that raised this question.

I'm reviewing your two patches (after having lunch).

Florent



---

archive/issue_comments_191684.json:
```json
{
    "body": "<a id='comment:46'></a>\nReplying to [hivert](#comment%3A45):\n>\n> There is a common usage of `ClasscallMetaclass` and\n> `__classcall_private__` for elements in order to delegate the creation to\n> the parent.\n> ...\n> Now I don't see any element class having a nested class. So in an ideal world,\n> we'd like to have `PerfectMatching` in `ClasscallMetaclass` but not in\n> `NestedClassMetaclass`.\n\n\nGood example! That's exactly along the lines of the [sage-combinat thread](http://groups.google.com/group/sage-combinat-devel/browse_thread/thread/ae09de5a608525e5) I started: We have common use cases in which we want to combine the nested class feature with the classcall feature, and thus someone has decided to make classcall inherit from nested class, although there are examples in which this is not needed.\n\nInstead, one could either create a pure classcall metaclass on the one hand, and a combined `ClasscallNestedClassMetaclass` on the other hand: This is similar to the `DynamicClasscallMetaclass`, which is a combined class for `DynamicMetaclass` and `ClasscallMetaclass`. Of course, having \"pure\" `ClasscallMetaclass`, `NestedClassMetaclass` and `DynamicMetaclass`, we would need to create four combined metaclasses to cover all potential use cases.\n\nOr: We could have a meta-metaclass that creates the combined metaclasses automatically...",
    "created_at": "2012-04-26T12:57:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191684",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:46'></a>
Replying to [hivert](#comment%3A45):
>
> There is a common usage of `ClasscallMetaclass` and
> `__classcall_private__` for elements in order to delegate the creation to
> the parent.
> ...
> Now I don't see any element class having a nested class. So in an ideal world,
> we'd like to have `PerfectMatching` in `ClasscallMetaclass` but not in
> `NestedClassMetaclass`.


Good example! That's exactly along the lines of the [sage-combinat thread](http://groups.google.com/group/sage-combinat-devel/browse_thread/thread/ae09de5a608525e5) I started: We have common use cases in which we want to combine the nested class feature with the classcall feature, and thus someone has decided to make classcall inherit from nested class, although there are examples in which this is not needed.

Instead, one could either create a pure classcall metaclass on the one hand, and a combined `ClasscallNestedClassMetaclass` on the other hand: This is similar to the `DynamicClasscallMetaclass`, which is a combined class for `DynamicMetaclass` and `ClasscallMetaclass`. Of course, having "pure" `ClasscallMetaclass`, `NestedClassMetaclass` and `DynamicMetaclass`, we would need to create four combined metaclasses to cover all potential use cases.

Or: We could have a meta-metaclass that creates the combined metaclasses automatically...



---

archive/issue_comments_191685.json:
```json
{
    "body": "<a id='comment:47'></a>\nReplying to [SimonKing](#comment%3A46):\n> Replying to [hivert](#comment%3A45):\n> >\n> > There is a common usage of `ClasscallMetaclass` and\n> > `__classcall_private__` for elements in order to delegate the creation to\n> > the parent.\n> > ...\n> > Now I don't see any element class having a nested class. So in an ideal world,\n> > we'd like to have `PerfectMatching` in `ClasscallMetaclass` but not in\n> > `NestedClassMetaclass`.\n\n> \n> Good example!\n\n\nThat said: I think we should focus here on making things faster while preserving the existing scheme. The meta-metaclass thingy (or the explicit creation of metaclasses that combine some \"pure\" metaclasses) should be done on a different ticket, if at all.",
    "created_at": "2012-04-26T12:59:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191685",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:47'></a>
Replying to [SimonKing](#comment%3A46):
> Replying to [hivert](#comment%3A45):
> >
> > There is a common usage of `ClasscallMetaclass` and
> > `__classcall_private__` for elements in order to delegate the creation to
> > the parent.
> > ...
> > Now I don't see any element class having a nested class. So in an ideal world,
> > we'd like to have `PerfectMatching` in `ClasscallMetaclass` but not in
> > `NestedClassMetaclass`.

> 
> Good example!


That said: I think we should focus here on making things faster while preserving the existing scheme. The meta-metaclass thingy (or the explicit creation of metaclasses that combine some "pure" metaclasses) should be done on a different ticket, if at all.



---

archive/issue_comments_191686.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Simon King\"",
    "created_at": "2012-04-26T16:45:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191686",
    "user": "https://github.com/simon-king-jena"
}
```

Changing reviewer from "" to "Simon King"



---

archive/issue_comments_191687.json:
```json
{
    "body": "<a id='comment:48'></a>\nI forgot: Since your patch looks fine to me (independent on whether we eventually decide to cdef `ClasscallMetaclass` directly) and since all tests pass and the documentation looks fine, I give your part of the work a positive review.",
    "created_at": "2012-04-26T16:45:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191687",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:48'></a>
I forgot: Since your patch looks fine to me (independent on whether we eventually decide to cdef `ClasscallMetaclass` directly) and since all tests pass and the documentation looks fine, I give your part of the work a positive review.



---

archive/issue_comments_191688.json:
```json
{
    "body": "<a id='comment:49'></a>\nReplying to [SimonKing](#comment%3A48):\n> I forgot: Since your patch looks fine to me (independent on whether we eventually decide to cdef `ClasscallMetaclass` directly) and since all tests pass and the documentation looks fine, I give your part of the work a positive review.\n\n\nOk ! For your part I've a question: is there any reason why do you call\n`sys_module` in `nested_pickle` whereas you call `sys.module` in\n`NestedClassMetaclass.__init__` ?\n\nOtherwise things looks good !\n\nFlorent",
    "created_at": "2012-04-26T17:34:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191688",
    "user": "https://github.com/hivert"
}
```

<a id='comment:49'></a>
Replying to [SimonKing](#comment%3A48):
> I forgot: Since your patch looks fine to me (independent on whether we eventually decide to cdef `ClasscallMetaclass` directly) and since all tests pass and the documentation looks fine, I give your part of the work a positive review.


Ok ! For your part I've a question: is there any reason why do you call
`sys_module` in `nested_pickle` whereas you call `sys.module` in
`NestedClassMetaclass.__init__` ?

Otherwise things looks good !

Florent



---

archive/issue_comments_191689.json:
```json
{
    "body": "Attachment [trac_12808_nested_class_cython.patch](tarball://root/attachments/some-uuid/ticket12808/trac_12808_nested_class_cython.patch) by @simon-king-jena created at 2012-04-26 19:45:16\n\nCythonise nested classes",
    "created_at": "2012-04-26T19:45:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191689",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_12808_nested_class_cython.patch](tarball://root/attachments/some-uuid/ticket12808/trac_12808_nested_class_cython.patch) by @simon-king-jena created at 2012-04-26 19:45:16

Cythonise nested classes



---

archive/issue_comments_191690.json:
```json
{
    "body": "<a id='comment:50'></a>\nReplying to [hivert](#comment%3A49):\n> Ok ! For your part I've a question: is there any reason why do you call\n> `sys_module` in `nested_pickle` whereas you call `sys.module` in\n> `NestedClassMetaclass.__init__` ?\n\n\nThanks for spotting it! I have updated the nested_class patch.\n\nApply trac_12808-classcall_speedup-fh.patch trac_12808_nested_class_cython.patch trac_12808-classcall_cdef.patch",
    "created_at": "2012-04-26T19:47:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191690",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:50'></a>
Replying to [hivert](#comment%3A49):
> Ok ! For your part I've a question: is there any reason why do you call
> `sys_module` in `nested_pickle` whereas you call `sys.module` in
> `NestedClassMetaclass.__init__` ?


Thanks for spotting it! I have updated the nested_class patch.

Apply trac_12808-classcall_speedup-fh.patch trac_12808_nested_class_cython.patch trac_12808-classcall_cdef.patch



---

archive/issue_comments_191691.json:
```json
{
    "body": "Changing reviewer from \"Simon King\" to \"Simon King, Florent Hivert\"",
    "created_at": "2012-04-26T21:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191691",
    "user": "https://github.com/hivert"
}
```

Changing reviewer from "Simon King" to "Simon King, Florent Hivert"



---

archive/issue_comments_191692.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-04-26T21:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191692",
    "user": "https://github.com/hivert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_191693.json:
```json
{
    "body": "<a id='comment:51'></a>\nThen it's a positive review for me !\n\nI also created #12886 as a followup.\n\nThanks Simon.",
    "created_at": "2012-04-26T21:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191693",
    "user": "https://github.com/hivert"
}
```

<a id='comment:51'></a>
Then it's a positive review for me !

I also created #12886 as a followup.

Thanks Simon.



---

archive/issue_comments_191694.json:
```json
{
    "body": "<a id='comment:52'></a>\nPlease decide which patches have to be applied.",
    "created_at": "2012-04-26T22:20:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191694",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:52'></a>
Please decide which patches have to be applied.



---

archive/issue_events_040747.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2012-04-26T22:20:36Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "milestone": "sage-5.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12808#event-40747"
}
```



---

archive/issue_comments_191695.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2012-04-26T22:20:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191695",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_191696.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -4,8 +4,5 @@\n \n * [attachment:trac_12808-classcall_speedup-fh.patch]\n * [attachment:trac_12808_nested_class_cython.patch]\n-\n-and we have to decide whether the third patch helps to make the code clearer:\n-\n * [attachment:trac_12808-classcall_cdef.patch]\n \n``````\n",
    "created_at": "2012-04-26T22:24:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191696",
    "user": "https://github.com/hivert"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -4,8 +4,5 @@
 
 * [attachment:trac_12808-classcall_speedup-fh.patch]
 * [attachment:trac_12808_nested_class_cython.patch]
-
-and we have to decide whether the third patch helps to make the code clearer:
-
 * [attachment:trac_12808-classcall_cdef.patch]
 
``````




---

archive/issue_comments_191697.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2012-04-26T22:24:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191697",
    "user": "https://github.com/hivert"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_191698.json:
```json
{
    "body": "<a id='comment:53'></a>\nReplying to [jdemeyer](#comment%3A52):\n> Please decide which patches have to be applied.\n\n\nSorry ! I forgot to remove Simon's question. It's decided.\n\nFlorent",
    "created_at": "2012-04-26T22:24:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191698",
    "user": "https://github.com/hivert"
}
```

<a id='comment:53'></a>
Replying to [jdemeyer](#comment%3A52):
> Please decide which patches have to be applied.


Sorry ! I forgot to remove Simon's question. It's decided.

Florent



---

archive/issue_comments_191699.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-04-26T22:24:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191699",
    "user": "https://github.com/hivert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_191700.json:
```json
{
    "body": "<a id='comment:55'></a>\nThere is a trivial conflict between this ticket and #12215 (in unique_representation.py). Which one should go first?",
    "created_at": "2012-04-30T08:22:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191700",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:55'></a>
There is a trivial conflict between this ticket and #12215 (in unique_representation.py). Which one should go first?



---

archive/issue_comments_191701.json:
```json
{
    "body": "<a id='comment:56'></a>\nI guess this one should go in first,: After all, #12215 has not been reviewed, yet.",
    "created_at": "2012-04-30T10:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191701",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:56'></a>
I guess this one should go in first,: After all, #12215 has not been reviewed, yet.



---

archive/issue_comments_191702.json:
```json
{
    "body": "<a id='comment:57'></a>\nReplying to [SimonKing](#comment%3A56):\n> I guess this one should go in first,: After all, #12215 has not been reviewed, yet.\n\n\nOk. May I let you handle the rebase?",
    "created_at": "2012-04-30T11:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191702",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:57'></a>
Replying to [SimonKing](#comment%3A56):
> I guess this one should go in first,: After all, #12215 has not been reviewed, yet.


Ok. May I let you handle the rebase?



---

archive/issue_comments_191703.json:
```json
{
    "body": "<a id='comment:58'></a>\nReplying to [nthiery](#comment%3A57):\n> Replying to [SimonKing](#comment%3A56):\n> > I guess this one should go in first,: After all, #12215 has not been reviewed, yet.\n\n> \n> Ok. May I let you handle the rebase?\n\n\nOK.",
    "created_at": "2012-04-30T13:02:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191703",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:58'></a>
Replying to [nthiery](#comment%3A57):
> Replying to [SimonKing](#comment%3A56):
> > I guess this one should go in first,: After all, #12215 has not been reviewed, yet.

> 
> Ok. May I let you handle the rebase?


OK.



---

archive/issue_comments_191704.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-05-06T12:18:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191704",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_comments_191705.json:
```json
{
    "body": "Changing merged from \"\" to \"sage-5.1.beta0\"",
    "created_at": "2012-05-06T12:18:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12808#issuecomment-191705",
    "user": "https://github.com/jdemeyer"
}
```

Changing merged from "" to "sage-5.1.beta0"



---

archive/issue_events_040748.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2012-05-06T12:18:10Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/12808",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12808#event-40748"
}
```
