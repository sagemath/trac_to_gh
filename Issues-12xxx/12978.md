# Issue 12978: conditionally_defined decorator for methods and other attributes

archive/issues_012806.json:
```json
{
    "assignees": [
        "https://github.com/jasongrout"
    ],
    "body": "<div id=\"comment:0\"></div>\n\nGoal: implement conditionally defined methods (and nested classes?):\n\nTypical use cases:\n\n```\nclass A(...):\n\n    ...\n\n    @conditionaly_defined(has=\"product_with_basis\")\n    def product(self):\n        ... build the product by bilinearity\n\n    # Would be nice to have, but seems to be not easily possible\n    @conditionaly_defined(lambda self: self.q() == 2):\n    class MyBasis:\n        ... \n```\n\nThen, for ``a`` an instance of ``A``, the above condition would be\nevaluated at runtime, when a.product is first accessed, like for lazy\nattributes.\n\nThat's a feature we used a lot in the category code in MuPAD.\n\n\nDepends on #15056\n\nCC:  @sagetrac-sage-combinat @simon-king-jena @saliola\n\nComponent: **misc**\n\nKeywords: **conditionally_defined**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/12978_\n\n",
    "created_at": "2012-05-19T16:54:30Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/enhancement",
        "https://github.com/sagemath/sage/labels/c%3A%20categories",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "conditionally_defined decorator for methods and other attributes",
    "type": "issue",
    "updated_at": "2022-12-29T01:32:56Z",
    "url": "https://github.com/sagemath/sage/issues/12978",
    "user": "https://github.com/nthiery"
}
```
<div id="comment:0"></div>

Goal: implement conditionally defined methods (and nested classes?):

Typical use cases:

```
class A(...):

    ...

    @conditionaly_defined(has="product_with_basis")
    def product(self):
        ... build the product by bilinearity

    # Would be nice to have, but seems to be not easily possible
    @conditionaly_defined(lambda self: self.q() == 2):
    class MyBasis:
        ... 
```

Then, for ``a`` an instance of ``A``, the above condition would be
evaluated at runtime, when a.product is first accessed, like for lazy
attributes.

That's a feature we used a lot in the category code in MuPAD.


Depends on #15056

CC:  @sagetrac-sage-combinat @simon-king-jena @saliola

Component: **misc**

Keywords: **conditionally_defined**

_Issue created by migration from https://trac.sagemath.org/ticket/12978_





---

archive/issue_events_177915.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2012-05-19T16:54:30Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177915"
}
```



---

archive/issue_events_177916.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2012-05-19T16:54:30Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177916"
}
```



---

archive/issue_events_177917.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2012-05-19T16:54:30Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20categories",
    "label_color": "0000ff",
    "label_name": "c: categories",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177917"
}
```



---

archive/issue_events_177918.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2012-05-19T16:54:30Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/wishlist%20item",
    "label_color": "e81ff9",
    "label_name": "wishlist item",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177918"
}
```



---

archive/issue_events_177919.json:
```json
{
    "actor": "https://github.com/jasongrout",
    "created_at": "2012-05-19T16:54:30Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "subject": "https://github.com/nthiery",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177919"
}
```



---

archive/issue_comments_147402.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nNicolas, I have questions to this feature request.\n\nWhat do you want to happen, if the condition in \"conditionally_defined\" is not met? Raise an attribute error (probably yes)?\n\nIt seems to me that in your proposal we would either have a certain method defined, or have it not defined at all. Wouldn't it be nice to have *several* implementations of a method, and choose one of them according to certain parameters?\n\nI guess the extended proposal could not be done by a simple decorator, because a decorator only expects a single function as input.\n\nAnyway. I think it would be possible to create a wrapper that is bound to the class and has a `__get__` method that will then choose one of the wrapped methods and bind it to a specific instance.\n\nNote that in an awkward manual way, it is probably already possible to mimic this behaviour. Something like:\n\n```\nclass C:\n    def __init__(self, n):\n        self.n = n\n    @lazy_attribute\n    def fancy_method(self):\n        if self.n>0:\n            return self.method1\n        return self.method2\n    def method1(self, m):\n        print \"method 1\"\n        return self.n*m\n    def method2(self, m):\n        print \"method 2\"\n        return self.n+m\n```\nIndeed, you would then have\n\n```\nsage: c1 = C(3)\nsage: c2 = C(-3)\nsage: c1.fancy_method(2)\nmethod 1\n6\nsage: c2.fancy_method(2)\nmethod 2\n-1\n```\n\nSo, you suggest to have a decorator that makes this behaviour automatic?\n\nPerhaps the choice could be made exactly as in my example. The syntax could be:\n\n```\nclass C:\n    @conditional_method(some_function)\n    def method_name(self, ...=)\n        <the default implementation>\n    def method1(...):\n        <first alternative implementation of method_name>\n    def method2(...):\n        <second alternative implementation of method_name>\n    ...\n```\nwhere some_function expects `self` as argument and returns a string `chosen_name`. And then, `self.method_name` will be overridden by `getattr(self,chosen_name)`; only if self has no attribute `chosen_name` (which is the case, e.g., if `chosen_name=\"\"`), then the default implementation is returned.\n\nDo you think this is a good approach/good syntax?",
    "created_at": "2013-08-15T08:31:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147402",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Nicolas, I have questions to this feature request.

What do you want to happen, if the condition in "conditionally_defined" is not met? Raise an attribute error (probably yes)?

It seems to me that in your proposal we would either have a certain method defined, or have it not defined at all. Wouldn't it be nice to have *several* implementations of a method, and choose one of them according to certain parameters?

I guess the extended proposal could not be done by a simple decorator, because a decorator only expects a single function as input.

Anyway. I think it would be possible to create a wrapper that is bound to the class and has a `__get__` method that will then choose one of the wrapped methods and bind it to a specific instance.

Note that in an awkward manual way, it is probably already possible to mimic this behaviour. Something like:

```
class C:
    def __init__(self, n):
        self.n = n
    @lazy_attribute
    def fancy_method(self):
        if self.n>0:
            return self.method1
        return self.method2
    def method1(self, m):
        print "method 1"
        return self.n*m
    def method2(self, m):
        print "method 2"
        return self.n+m
```
Indeed, you would then have

```
sage: c1 = C(3)
sage: c2 = C(-3)
sage: c1.fancy_method(2)
method 1
6
sage: c2.fancy_method(2)
method 2
-1
```

So, you suggest to have a decorator that makes this behaviour automatic?

Perhaps the choice could be made exactly as in my example. The syntax could be:

```
class C:
    @conditional_method(some_function)
    def method_name(self, ...=)
        <the default implementation>
    def method1(...):
        <first alternative implementation of method_name>
    def method2(...):
        <second alternative implementation of method_name>
    ...
```
where some_function expects `self` as argument and returns a string `chosen_name`. And then, `self.method_name` will be overridden by `getattr(self,chosen_name)`; only if self has no attribute `chosen_name` (which is the case, e.g., if `chosen_name=""`), then the default implementation is returned.

Do you think this is a good approach/good syntax?



---

archive/issue_comments_147403.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nHi Simon!\n\nReplying to [@simon-king-jena](#comment%3A1):\n> What do you want to happen, if the condition in \"conditionally_defined\" is not met? Raise an attribute error (probably yes)?\n\nI want the same behavior as for a lazy attribute when the value is\nNotImplemented: in that case, the lookup proceeds in the super class\nhierarchy. And of course if it's not found there we get an\nAttributeError.\n\n> Wouldn't it be nice to have *several* implementations of a method,\n> and choose one of them according to certain parameters?\n\nThis indeed sounds like a natural feature, but I don't have a strong\nuse case yet for it. In all the examples I have in my mind, the\n\"other\" implementations are provided by the super classes. So I would\nfocus on the decorator for the simple ``conditionally_defined'' case first and gather\nexperience on its use before thinking about a good syntax for\n``several implementations''; it might at then end be just simpler and more\nexplicit to stick to doing this manually with a lazy attribute as in your example above.\n\nCheers,\n                              Nicolas",
    "created_at": "2013-08-16T06:29:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147403",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:2" align="right">comment:2</div>

Hi Simon!

Replying to [@simon-king-jena](#comment%3A1):
> What do you want to happen, if the condition in "conditionally_defined" is not met? Raise an attribute error (probably yes)?

I want the same behavior as for a lazy attribute when the value is
NotImplemented: in that case, the lookup proceeds in the super class
hierarchy. And of course if it's not found there we get an
AttributeError.

> Wouldn't it be nice to have *several* implementations of a method,
> and choose one of them according to certain parameters?

This indeed sounds like a natural feature, but I don't have a strong
use case yet for it. In all the examples I have in my mind, the
"other" implementations are provided by the super classes. So I would
focus on the decorator for the simple ``conditionally_defined'' case first and gather
experience on its use before thinking about a good syntax for
``several implementations''; it might at then end be just simpler and more
explicit to stick to doing this manually with a lazy attribute as in your example above.

Cheers,
                              Nicolas



---

archive/issue_comments_147404.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nReplying to [@nthiery](#comment%3A2):\n> I want the same behavior as for a lazy attribute when the value is\n> NotImplemented: in that case, the lookup proceeds in the super class\n> hierarchy.\n\nDo I understand correctly that you want the following behaviour:\n\n```python\nclass A(object):\n    def my_method(self, *args,**kwargs):\n        <default_implementation>\nclass B(A):\n    @conditionally_defined(f)\n    def my_method(self, *args,**kwargs):\n        <other implementation>\n```\nsuch that the default implementation is used when `f(self)` evaluates to False (or an attribute error is raised if the the `super(B,B)` does not define `my_method`), and uses the specialised \"other implementation\" if `f(self)` evaluates to True?\n\nI am pretty sure that one can use lazy_attribute behind the scenes, and the job of `@conditionally_defined` would be to create this lazy attribute, so that the user does not need to do it.",
    "created_at": "2013-08-16T08:13:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147404",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Replying to [@nthiery](#comment%3A2):
> I want the same behavior as for a lazy attribute when the value is
> NotImplemented: in that case, the lookup proceeds in the super class
> hierarchy.

Do I understand correctly that you want the following behaviour:

```python
class A(object):
    def my_method(self, *args,**kwargs):
        <default_implementation>
class B(A):
    @conditionally_defined(f)
    def my_method(self, *args,**kwargs):
        <other implementation>
```
such that the default implementation is used when `f(self)` evaluates to False (or an attribute error is raised if the the `super(B,B)` does not define `my_method`), and uses the specialised "other implementation" if `f(self)` evaluates to True?

I am pretty sure that one can use lazy_attribute behind the scenes, and the job of `@conditionally_defined` would be to create this lazy attribute, so that the user does not need to do it.



---

archive/issue_comments_147405.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [@simon-king-jena](#comment%3A3):\n> Do I understand correctly that you want the following behaviour:\n> \n> ```python\n> class A(object):\n>     def my_method(self, *args,**kwargs):\n>         <default_implementation>\n> class B(A):\n>     @conditionally_defined(f)\n>     def my_method(self, *args,**kwargs):\n>         <other implementation>\n> ```\n> such that the default implementation is used when `f(self)` evaluates to False (or an attribute error is raised if the the `super(B,B)` does not define `my_method`), and uses the specialised \"other implementation\" if `f(self)` evaluates to True?\n\n+1\n\n> I am pretty sure that one can use lazy_attribute behind the scenes,\n> and the job of `@conditionally_defined` would be to create this lazy\n> attribute, so that the user does not need to do it.\n\nDefinitely!\n\nCheers,\n                          Nicolas",
    "created_at": "2013-08-16T11:04:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147405",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [@simon-king-jena](#comment%3A3):
> Do I understand correctly that you want the following behaviour:
> 
> ```python
> class A(object):
>     def my_method(self, *args,**kwargs):
>         <default_implementation>
> class B(A):
>     @conditionally_defined(f)
>     def my_method(self, *args,**kwargs):
>         <other implementation>
> ```
> such that the default implementation is used when `f(self)` evaluates to False (or an attribute error is raised if the the `super(B,B)` does not define `my_method`), and uses the specialised "other implementation" if `f(self)` evaluates to True?

+1

> I am pretty sure that one can use lazy_attribute behind the scenes,
> and the job of `@conditionally_defined` would be to create this lazy
> attribute, so that the user does not need to do it.

Definitely!

Cheers,
                          Nicolas



---

archive/issue_comments_147406.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nI found out how to deal with cached special (= double underscore) methods -- see #12601. So, I will attempt to make the new decorator work with special methods as well.",
    "created_at": "2013-08-16T11:06:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147406",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

I found out how to deal with cached special (= double underscore) methods -- see #12601. So, I will attempt to make the new decorator work with special methods as well.



---

archive/issue_comments_147407.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nWhat about the documentation? Of course, if we have an instance x and a conditionally defined method meth, then `x.meth` will be a specific implementation, and we get its documentation. But what shall be the documentation of `x.__class__.meth`?\n\nIn the simplest approach, it would be the documentation of the default method.\n\nIn a less simple approach, it would prepend `\"Conditionally defined method: \"` to the doc string of the one of the methods (I guess the default is the method inherited from the super class).\n\nIn an even less simple approach, it would start with `\"Conditionally defined method, choosing from methods with the following documentation:\"`, followed by a concatenation of the doc string of the inherited method and the specialised method. The inherited method might be conditional, too. So, we might take care of nesting.\n\nIn the most complicated approach, we would even add the documentation of the choosing function to the documentation of the wrapped methods.",
    "created_at": "2013-08-16T11:13:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147407",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

What about the documentation? Of course, if we have an instance x and a conditionally defined method meth, then `x.meth` will be a specific implementation, and we get its documentation. But what shall be the documentation of `x.__class__.meth`?

In the simplest approach, it would be the documentation of the default method.

In a less simple approach, it would prepend `"Conditionally defined method: "` to the doc string of the one of the methods (I guess the default is the method inherited from the super class).

In an even less simple approach, it would start with `"Conditionally defined method, choosing from methods with the following documentation:"`, followed by a concatenation of the doc string of the inherited method and the specialised method. The inherited method might be conditional, too. So, we might take care of nesting.

In the most complicated approach, we would even add the documentation of the choosing function to the documentation of the wrapped methods.



---

archive/issue_comments_147408.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nReplying to [@simon-king-jena](#comment%3A6):\n> What about the documentation? Of course, if we have an instance x and a conditionally defined method meth, then `x.meth` will be a specific implementation, and we get its documentation. But what shall be the documentation of `x.__class__.meth`?\n> \n> In the simplest approach, it would be the documentation of the default method.\n> \n> In a less simple approach, it would prepend `\"Conditionally defined method: \"` to the doc string of the one of the methods (I guess the default is the method inherited from the super class).\n> \n> In an even less simple approach, it would start with `\"Conditionally defined method, choosing from methods with the following documentation:\"`, followed by a concatenation of the doc string of the inherited method and the specialised method. The inherited method might be conditional, too. So, we might take care of nesting.\n> \n> In the most complicated approach, we would even add the documentation of the choosing function to the documentation of the wrapped methods.\n\nHmm, good point.\n\nFor now I would go for the simplest: just use the documentation of the\nmethod. And add a recommendation that this documentation should\nmention that the method is conditionally defined. A typical use case\nwould then be:\n\n```\n    @conditionally_defined(hasattr=\"bar\")\n    def product(self, x, y):\n        \"\"\"\n\tReturn the product of `x` and `y`.\n\n\t.. NOTE::\n\n\t    This implementation uses ``self.product_on_basis`` and is\n\t    only defined if this method is defined.\n\t\"\"\"\n\t...\n```\n\nOnce we will have some practical experience, it will be always time to\nimplement something more sophisticated if we fill it's really needed.\n\nCheers,\n                     Nicolas",
    "created_at": "2013-08-16T15:14:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147408",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:7" align="right">comment:7</div>

Replying to [@simon-king-jena](#comment%3A6):
> What about the documentation? Of course, if we have an instance x and a conditionally defined method meth, then `x.meth` will be a specific implementation, and we get its documentation. But what shall be the documentation of `x.__class__.meth`?
> 
> In the simplest approach, it would be the documentation of the default method.
> 
> In a less simple approach, it would prepend `"Conditionally defined method: "` to the doc string of the one of the methods (I guess the default is the method inherited from the super class).
> 
> In an even less simple approach, it would start with `"Conditionally defined method, choosing from methods with the following documentation:"`, followed by a concatenation of the doc string of the inherited method and the specialised method. The inherited method might be conditional, too. So, we might take care of nesting.
> 
> In the most complicated approach, we would even add the documentation of the choosing function to the documentation of the wrapped methods.

Hmm, good point.

For now I would go for the simplest: just use the documentation of the
method. And add a recommendation that this documentation should
mention that the method is conditionally defined. A typical use case
would then be:

```
    @conditionally_defined(hasattr="bar")
    def product(self, x, y):
        """
	Return the product of `x` and `y`.

	.. NOTE::

	    This implementation uses ``self.product_on_basis`` and is
	    only defined if this method is defined.
	"""
	...
```

Once we will have some practical experience, it will be always time to
implement something more sophisticated if we fill it's really needed.

Cheers,
                     Nicolas



---

archive/issue_comments_147409.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@nthiery](#comment%3A7):\n> For now I would go for the simplest: just use the documentation of the\n> method.\n\nWhich of them? The one gotten from the super-class, or the one that will only be there under special conditions?",
    "created_at": "2013-08-16T16:09:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147409",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@nthiery](#comment%3A7):
> For now I would go for the simplest: just use the documentation of the
> method.

Which of them? The one gotten from the super-class, or the one that will only be there under special conditions?



---

archive/issue_comments_147410.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@simon-king-jena](#comment%3A8):\n> Replying to [@nthiery](#comment%3A7):\n> > For now I would go for the simplest: just use the documentation of the\n> > method.\n> \n> \n> Which of them? The one gotten from the super-class, or the one that will only be there under special conditions?\n\nThe one defined under the special condition (as in my example above).",
    "created_at": "2013-08-16T16:30:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147410",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@simon-king-jena](#comment%3A8):
> Replying to [@nthiery](#comment%3A7):
> > For now I would go for the simplest: just use the documentation of the
> > method.
> 
> 
> Which of them? The one gotten from the super-class, or the one that will only be there under special conditions?

The one defined under the special condition (as in my example above).



---

archive/issue_comments_147411.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nWith the patch that I just attached, one can do the following:\n\n```\nsage: from sage.misc.conditionally_defined import conditionally_defined\nsage: class C(object):     \n....:     def some_method(self):\n....:         print \"method of C\"\n....:     def __hash__(self):\n....:         print \"hash of C\"\n....:         return int(3)\n....:     \nsage: class D(C):          \n....:     @conditionally_defined(lambda x: x.con>0)\n....:     def some_method(self):\n....:         \"some doc of some method of D\"\n....:         print \"method of D\"\n....:     @conditionally_defined(lambda x: x.con<0)\n....:     def __hash__(self):\n....:         \"some do of hash of D\"\n....:         print \"hash of D\"\n....:         return int(14)\n....:     \nsage: class E(D):          \n....:     @conditionally_defined(lambda x: x.con>0)\n....:     def further_method(self):\n....:         \"doc of further method\"\n....:         print \"no matter what\"\n....:     @conditionally_defined(lambda x: x.con==0)\n....:     def some_method(self):\n....:         \"this is the doc of some method of E\"\n....:         print \"method of E\"\n....:         \nsage: x = E()\nsage: y = E()\nsage: z = E()\nsage: x.con = 1\nsage: y.con = -1\nsage: z.con = 0\n```\n\n__\"Normal\" methods__\n\nThe implementation of `some_method` is correctly chosen, according to the value of `.con`:\n\n```\nsage: x.some_method()\nmethod of D\nsage: y.some_method()\nmethod of C\nsage: z.some_method()\nmethod of E\n```\n\nIf there is no definition available in the super-class, only the default method is used:\n\n```\nsage: x.further_method()\nno matter what\nsage: y.further_method()\nno matter what\nsage: z.further_method()\nno matter what\n```\n\n__Documentation__\n\nThe attribute of the instance is the chosen implementation, thus documented accordingly. The documentation of the attribute of the class is given by the default implementation, and Sage also adds the documentation of the wrapper (I think this is the usual behaviour in Sage):\n\n```\nsage: x.some_method?\nType:       instancemethod\nString Form:<bound method E.some_method of <__main__.E object at 0x55dfb10>>\nFile:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-3-a00430d63569>\nDefinition: x.some_method(self)\nDocstring:  some doc of some method of D\nsage: y.some_method?\nType:       instancemethod\nString Form:<bound method E.some_method of <__main__.E object at 0x55dfb50>>\nFile:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-2-333131ba1041>\nDefinition: y.some_method(self)\nDocstring:  x.__init__(...) initializes x; see help(type(x)) for signature\nsage: z.some_method?\nType:       instancemethod\nString Form:<bound method E.some_method of <__main__.E object at 0x55df750>>\nFile:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-4-1bdca786a56b>\nDefinition: z.some_method(self)\nDocstring:  this is the doc of some method of E\nsage: E.some_method?\nType:       conditionally_defined\nString Form:Conditionally defined method 'some_method'\nFile:       /home/simon/SAGE/prerelease/sage-5.11.beta3/local/lib/python2.7/site-packages/sage/misc/conditionally_defined.so\nDefinition: E.some_method(self, meth)\nDocstring:  this is the doc of some method of E\n\nClass Docstring:\n   A wrapper for methods whose definition depends on the state of an\n   instance\nCall def:   E.some_method(self, meth)\nsage: D.some_method?\nType:       conditionally_defined\nString Form:Conditionally defined method 'some_method'\nFile:       /home/simon/SAGE/prerelease/sage-5.11.beta3/local/lib/python2.7/site-packages/sage/misc/conditionally_defined.so\nDefinition: D.some_method(self, meth)\nDocstring:  some doc of some method of D\n\nClass Docstring:\n   A wrapper for methods whose definition depends on the state of an\n   instance\nCall def:   D.some_method(self, meth)\n```\n\n__Special methods__\n\nThe hash is correctly chosen for the instance, according to the value of the `.con` attribute:\n\n```\nsage: hash(x)\nhash of C\n3\nsage: hash(y)\nhash of D\n14\nsage: hash(z)\nhash of C\n3\n```\nI verified that the hash function is not created repeatedly. In particular, changing the value of the `.con ` attribute does not change the hash function---a conditional method is fixed once for all:\n\n```\nsage: z.con = -1\nsage: hash(z)\nhash of C\n3\n```\nOnly when we delete the stored choice of an implementation, the changed choice takes effect:\n\n```\nsage: del z.__hash__\nsage: hash(z)\nhash of D\n14\n```\n\nNicolas, does this sound like a solution to your feature request? Do you miss something?\n\nWe should look at timings, in particular for special methods, I should add documentation, and then you can review it.",
    "created_at": "2013-08-16T20:42:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147411",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:10" align="right">comment:10</div>

With the patch that I just attached, one can do the following:

```
sage: from sage.misc.conditionally_defined import conditionally_defined
sage: class C(object):     
....:     def some_method(self):
....:         print "method of C"
....:     def __hash__(self):
....:         print "hash of C"
....:         return int(3)
....:     
sage: class D(C):          
....:     @conditionally_defined(lambda x: x.con>0)
....:     def some_method(self):
....:         "some doc of some method of D"
....:         print "method of D"
....:     @conditionally_defined(lambda x: x.con<0)
....:     def __hash__(self):
....:         "some do of hash of D"
....:         print "hash of D"
....:         return int(14)
....:     
sage: class E(D):          
....:     @conditionally_defined(lambda x: x.con>0)
....:     def further_method(self):
....:         "doc of further method"
....:         print "no matter what"
....:     @conditionally_defined(lambda x: x.con==0)
....:     def some_method(self):
....:         "this is the doc of some method of E"
....:         print "method of E"
....:         
sage: x = E()
sage: y = E()
sage: z = E()
sage: x.con = 1
sage: y.con = -1
sage: z.con = 0
```

__"Normal" methods__

The implementation of `some_method` is correctly chosen, according to the value of `.con`:

```
sage: x.some_method()
method of D
sage: y.some_method()
method of C
sage: z.some_method()
method of E
```

If there is no definition available in the super-class, only the default method is used:

```
sage: x.further_method()
no matter what
sage: y.further_method()
no matter what
sage: z.further_method()
no matter what
```

__Documentation__

The attribute of the instance is the chosen implementation, thus documented accordingly. The documentation of the attribute of the class is given by the default implementation, and Sage also adds the documentation of the wrapper (I think this is the usual behaviour in Sage):

```
sage: x.some_method?
Type:       instancemethod
String Form:<bound method E.some_method of <__main__.E object at 0x55dfb10>>
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-3-a00430d63569>
Definition: x.some_method(self)
Docstring:  some doc of some method of D
sage: y.some_method?
Type:       instancemethod
String Form:<bound method E.some_method of <__main__.E object at 0x55dfb50>>
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-2-333131ba1041>
Definition: y.some_method(self)
Docstring:  x.__init__(...) initializes x; see help(type(x)) for signature
sage: z.some_method?
Type:       instancemethod
String Form:<bound method E.some_method of <__main__.E object at 0x55df750>>
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-4-1bdca786a56b>
Definition: z.some_method(self)
Docstring:  this is the doc of some method of E
sage: E.some_method?
Type:       conditionally_defined
String Form:Conditionally defined method 'some_method'
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/local/lib/python2.7/site-packages/sage/misc/conditionally_defined.so
Definition: E.some_method(self, meth)
Docstring:  this is the doc of some method of E

Class Docstring:
   A wrapper for methods whose definition depends on the state of an
   instance
Call def:   E.some_method(self, meth)
sage: D.some_method?
Type:       conditionally_defined
String Form:Conditionally defined method 'some_method'
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/local/lib/python2.7/site-packages/sage/misc/conditionally_defined.so
Definition: D.some_method(self, meth)
Docstring:  some doc of some method of D

Class Docstring:
   A wrapper for methods whose definition depends on the state of an
   instance
Call def:   D.some_method(self, meth)
```

__Special methods__

The hash is correctly chosen for the instance, according to the value of the `.con` attribute:

```
sage: hash(x)
hash of C
3
sage: hash(y)
hash of D
14
sage: hash(z)
hash of C
3
```
I verified that the hash function is not created repeatedly. In particular, changing the value of the `.con ` attribute does not change the hash function---a conditional method is fixed once for all:

```
sage: z.con = -1
sage: hash(z)
hash of C
3
```
Only when we delete the stored choice of an implementation, the changed choice takes effect:

```
sage: del z.__hash__
sage: hash(z)
hash of D
14
```

Nicolas, does this sound like a solution to your feature request? Do you miss something?

We should look at timings, in particular for special methods, I should add documentation, and then you can review it.



---

archive/issue_comments_147412.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nNice! this looks good!\n\nJust being curious: does this play well with `@`cached_method? That is, can we do something like:\n\n```\n    @conditionally_defined(...)\n    @cached_method\n    def ...\n```\n\nCould you further implement the `has=\"...\"` (or `hasattr=\"...\"`) argument to `@conditionally_defined` as in the example of the ticket description?\n\nThe ticket description also mentions conditionally defined nested classes. I actually don't remember putting this there; did I really? Do we have any strong use case? Otherwise I guess we can postpone the feature.\n\nThanks!",
    "created_at": "2013-08-17T07:28:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147412",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:11" align="right">comment:11</div>

Nice! this looks good!

Just being curious: does this play well with `@`cached_method? That is, can we do something like:

```
    @conditionally_defined(...)
    @cached_method
    def ...
```

Could you further implement the `has="..."` (or `hasattr="..."`) argument to `@conditionally_defined` as in the example of the ticket description?

The ticket description also mentions conditionally defined nested classes. I actually don't remember putting this there; did I really? Do we have any strong use case? Otherwise I guess we can postpone the feature.

Thanks!



---

archive/issue_comments_147413.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nReplying to [@nthiery](#comment%3A11):\n> Just being curious: does this play well with `@`cached_method? That is, can we do something like:\n> \n> ```\n>     @conditionally_defined(...)\n>     @cached_method\n>     def ...\n> ```\n\nDidn't try yet. Ideally, it would also work to do\n\n```\n    @cached_method\n    @conditionally_defined\n```\nmeaning that we have a cached method whose underlying implementation depends on a condition. I.e., if the condition is not met, then the method inherited from the super-class is taken, and then cached (even when it is not cached in the super-class).\n \n> Could you further implement the `has=\"...\"` (or `hasattr=\"...\"`) argument to `@conditionally_defined` as in the example of the ticket description?\n\nI hope so.\n\n> The ticket description also mentions conditionally defined nested classes. I actually don't remember putting this there; did I really? Do we have any strong use case? Otherwise I guess we can postpone the feature.\n\nI think nobody has changed the ticket description after you created it :)\n\nBut anyway, I think it can not work with the current implementation, yet. Namely, if the condition is met, then the wrapped \"function\" will be turned into a bound method (by calling `types.MethodType`). I guess this would fail if the \"function\" is in fact a class.",
    "created_at": "2013-08-17T08:00:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147413",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:12" align="right">comment:12</div>

Replying to [@nthiery](#comment%3A11):
> Just being curious: does this play well with `@`cached_method? That is, can we do something like:
> 
> ```
>     @conditionally_defined(...)
>     @cached_method
>     def ...
> ```

Didn't try yet. Ideally, it would also work to do

```
    @cached_method
    @conditionally_defined
```
meaning that we have a cached method whose underlying implementation depends on a condition. I.e., if the condition is not met, then the method inherited from the super-class is taken, and then cached (even when it is not cached in the super-class).
 
> Could you further implement the `has="..."` (or `hasattr="..."`) argument to `@conditionally_defined` as in the example of the ticket description?

I hope so.

> The ticket description also mentions conditionally defined nested classes. I actually don't remember putting this there; did I really? Do we have any strong use case? Otherwise I guess we can postpone the feature.

I think nobody has changed the ticket description after you created it :)

But anyway, I think it can not work with the current implementation, yet. Namely, if the condition is met, then the wrapped "function" will be turned into a bound method (by calling `types.MethodType`). I guess this would fail if the "function" is in fact a class.



---

archive/issue_comments_147414.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nReplying to [@simon-king-jena](#comment%3A12):\n> I think nobody has changed the ticket description after you created it :)\n> \n> But anyway, I think it can not work with the current implementation, yet. Namely, if the condition is met, then the wrapped \"function\" will be turned into a bound method (by calling `types.MethodType`). I guess this would fail if the \"function\" is in fact a class.\n\nOk, just ignore this feature then.",
    "created_at": "2013-08-17T11:22:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147414",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:13" align="right">comment:13</div>

Replying to [@simon-king-jena](#comment%3A12):
> I think nobody has changed the ticket description after you created it :)
> 
> But anyway, I think it can not work with the current implementation, yet. Namely, if the condition is met, then the wrapped "function" will be turned into a bound method (by calling `types.MethodType`). I guess this would fail if the "function" is in fact a class.

Ok, just ignore this feature then.



---

archive/issue_comments_147415.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nThe problem with nested classes is that, if you define\n\n```\nclass C:\n    __metaclass__ = NestedClassMetaclass\n    class D:\n        pass\n```\nthen *during creation of C* (`NestedClassMetaclass.__init__(C)`) all attributes of C that are classes get their names changed (here: It becomes \"C.D\" instead of \"D\"). But if you pack the nested class into a conditionally_defined decorator, then `NestedClassMetaclass.__init__(C)` will not realise that D is a class, and will thus not change the name.\n\nMoreover, at least in the current implementation, the conditionally_defined decorator operates with the name of the wrapped object. But if this name is not a valid attribute name (such as `\"C.D\"`) then the whole construction will fail anyway.\n\nIn any case, I think it would be more interesting to be able to conditionally define a cached method, in *both* versions I suggested:\n\n```\n    @cached_method\n    @conditionally_defined(...):\n    def meth(...):\n        ...\n```\nbeing a cached method whose underlying implementation is conditional, and\n\n```\n    @conditionally_defined(...):\n    @cached_method\n    def meth(...):\n        ...\n```\nbeing a cached method that is only used conditionally.",
    "created_at": "2013-08-17T15:14:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147415",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:14" align="right">comment:14</div>

The problem with nested classes is that, if you define

```
class C:
    __metaclass__ = NestedClassMetaclass
    class D:
        pass
```
then *during creation of C* (`NestedClassMetaclass.__init__(C)`) all attributes of C that are classes get their names changed (here: It becomes "C.D" instead of "D"). But if you pack the nested class into a conditionally_defined decorator, then `NestedClassMetaclass.__init__(C)` will not realise that D is a class, and will thus not change the name.

Moreover, at least in the current implementation, the conditionally_defined decorator operates with the name of the wrapped object. But if this name is not a valid attribute name (such as `"C.D"`) then the whole construction will fail anyway.

In any case, I think it would be more interesting to be able to conditionally define a cached method, in *both* versions I suggested:

```
    @cached_method
    @conditionally_defined(...):
    def meth(...):
        ...
```
being a cached method whose underlying implementation is conditional, and

```
    @conditionally_defined(...):
    @cached_method
    def meth(...):
        ...
```
being a cached method that is only used conditionally.



---

archive/issue_comments_147416.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-Goal: implement conditionally defined methods and nested classes:\n+Goal: implement conditionally defined methods (and nested classes?):\n \n Typical use cases:\n \n@@ -11,7 +11,7 @@\n     def product(self):\n         ... build the product by bilinearity\n \n-\n+    # Would be nice to have, but seems to be not easily possible\n     @conditionaly_defined(lambda self: self.q() == 2):\n     class MyBasis:\n         ... \n``````\n",
    "created_at": "2013-08-17T19:44:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147416",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-Goal: implement conditionally defined methods and nested classes:
+Goal: implement conditionally defined methods (and nested classes?):
 
 Typical use cases:
 
@@ -11,7 +11,7 @@
     def product(self):
         ... build the product by bilinearity
 
-
+    # Would be nice to have, but seems to be not easily possible
     @conditionaly_defined(lambda self: self.q() == 2):
     class MyBasis:
         ... 
``````




---

archive/issue_comments_147417.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nFor now, I think nested classes won't work.\n\nReplying to [@simon-king-jena](#comment%3A14):\n> In any case, I think it would be more interesting to be able to conditionally define a cached method, in *both* versions I suggested:\n> \n> ```\n>     @cached_method\n>     @conditionally_defined(...):\n>     def meth(...):\n>         ...\n> ```\n> being a cached method whose underlying implementation is conditional, and\n> \n> ```\n>     @conditionally_defined(...):\n>     @cached_method\n>     def meth(...):\n>         ...\n> ```\n> being a cached method that is only used conditionally.\n\nThat's why I add #15056 as a dependency.",
    "created_at": "2013-08-17T19:44:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147417",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:15" align="right">comment:15</div>

For now, I think nested classes won't work.

Replying to [@simon-king-jena](#comment%3A14):
> In any case, I think it would be more interesting to be able to conditionally define a cached method, in *both* versions I suggested:
> 
> ```
>     @cached_method
>     @conditionally_defined(...):
>     def meth(...):
>         ...
> ```
> being a cached method whose underlying implementation is conditional, and
> 
> ```
>     @conditionally_defined(...):
>     @cached_method
>     def meth(...):
>         ...
> ```
> being a cached method that is only used conditionally.

That's why I add #15056 as a dependency.



---

archive/issue_comments_147418.json:
```json
{
    "body": "Dependencies: **#15056**",
    "created_at": "2013-08-17T19:44:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147418",
    "user": "https://github.com/simon-king-jena"
}
```

Dependencies: **#15056**



---

archive/issue_events_177920.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-08-17T19:44:18Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "title_is": "conditionally_defined decorator for methods and other attributes",
    "title_was": "conditionally_defined decorator for methods and nested classes",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177920"
}
```



---

archive/issue_comments_147419.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nAt some point, I need to find out what class the default implementation is defined for, so that one can get the non-default implementation by a call to `super`. That's a problem. Currently, I go up the class hierarchy and test whether the conditionally_defined instance is in the `__dict__` of the class. But if the conditionally_defined instance is wrapped in a different wrapper (e.g., a cached_method), then this way of determining the class will fail.\n\nI wonder if Python gives this information automatically, when it invokes `__get__`. To be investigated...",
    "created_at": "2013-08-18T16:49:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147419",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:16" align="right">comment:16</div>

At some point, I need to find out what class the default implementation is defined for, so that one can get the non-default implementation by a call to `super`. That's a problem. Currently, I go up the class hierarchy and test whether the conditionally_defined instance is in the `__dict__` of the class. But if the conditionally_defined instance is wrapped in a different wrapper (e.g., a cached_method), then this way of determining the class will fail.

I wonder if Python gives this information automatically, when it invokes `__get__`. To be investigated...



---

archive/issue_comments_147420.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nWith the latest version of #15056 and the patch that I have just attached, one can do (that's currently the only doctest):\n\n```\n    sage: from sage.misc.conditionally_defined import conditionally_defined\n    sage: class A(object):\n    ....:     @cached_method\n    ....:     def method1(self, x):\n    ....:         print \"calling cached method1\"\n    ....:         return -x\n    ....:     def method2(self, x):\n    ....:         print \"calling method2\"\n    ....:         return 2*x\n    sage: class B(A):\n    ....:     @conditionally_defined(lambda x: x.con>0)\n    ....:     def method1(self, x):\n    ....:         print \"calling uncached method1\"\n    ....:         return x^2\n    ....:     @cached_method\n    ....:     @conditionally_defined(lambda x: x.con<0)\n    ....:     def method2(self, x):\n    ....:         print \"calling alternative method2\"\n    ....:         return 2+x\n    sage: x = B()\n    sage: y = B()\n    sage: x.con = 1\n    sage: y.con = -1\n```\n\nThe method `method1` of the two instances `x` or `y` is either a usual method,\nor a cached method, depending on the value of the attribute `.con`:\n\n```\n    sage: x.method1\n    <bound method B.method1 of <__main__.B object at ...>>\n    sage: y.method1\n    Cached version of <bound method B.method1 of <__main__.B object at ...>>\n    sage: x.method1(3)\n    calling uncached method1\n    9\n    sage: x.method1(3)\n    calling uncached method1\n    9\n    sage: y.method1(3)\n    calling cached method1\n    -3\n    sage: y.method1(3) is y.method1(3)\n    True\n```\nThe method `method2` is cached, but the underlying function of the cached\nmethod is conditionally defined::\n\n```\n    sage: x.method2\n    Cached version of <bound method B.method2 of <__main__.B object at ...>>\n    sage: y.method2\n    Cached version of <bound method B.method2 of <__main__.B object at ...>>\n    sage: x.method2(3)\n    calling method2\n    6\n    sage: x.method2(3) is x.method2(3)\n    True\n    sage: y.method2(3)\n    calling alternative method2\n    5\n    sage: y.method2(3) is y.method2(3)\n    True\n```\n\nDo you agree that this seems useful?",
    "created_at": "2013-08-18T17:25:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147420",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:17" align="right">comment:17</div>

With the latest version of #15056 and the patch that I have just attached, one can do (that's currently the only doctest):

```
    sage: from sage.misc.conditionally_defined import conditionally_defined
    sage: class A(object):
    ....:     @cached_method
    ....:     def method1(self, x):
    ....:         print "calling cached method1"
    ....:         return -x
    ....:     def method2(self, x):
    ....:         print "calling method2"
    ....:         return 2*x
    sage: class B(A):
    ....:     @conditionally_defined(lambda x: x.con>0)
    ....:     def method1(self, x):
    ....:         print "calling uncached method1"
    ....:         return x^2
    ....:     @cached_method
    ....:     @conditionally_defined(lambda x: x.con<0)
    ....:     def method2(self, x):
    ....:         print "calling alternative method2"
    ....:         return 2+x
    sage: x = B()
    sage: y = B()
    sage: x.con = 1
    sage: y.con = -1
```

The method `method1` of the two instances `x` or `y` is either a usual method,
or a cached method, depending on the value of the attribute `.con`:

```
    sage: x.method1
    <bound method B.method1 of <__main__.B object at ...>>
    sage: y.method1
    Cached version of <bound method B.method1 of <__main__.B object at ...>>
    sage: x.method1(3)
    calling uncached method1
    9
    sage: x.method1(3)
    calling uncached method1
    9
    sage: y.method1(3)
    calling cached method1
    -3
    sage: y.method1(3) is y.method1(3)
    True
```
The method `method2` is cached, but the underlying function of the cached
method is conditionally defined::

```
    sage: x.method2
    Cached version of <bound method B.method2 of <__main__.B object at ...>>
    sage: y.method2
    Cached version of <bound method B.method2 of <__main__.B object at ...>>
    sage: x.method2(3)
    calling method2
    6
    sage: x.method2(3) is x.method2(3)
    True
    sage: y.method2(3)
    calling alternative method2
    5
    sage: y.method2(3) is y.method2(3)
    True
```

Do you agree that this seems useful?



---

archive/issue_comments_147421.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nReplying to [@simon-king-jena](#comment%3A16):\n> At some point, I need to find out what class the default implementation is defined for, so that one can get the non-default implementation by a call to `super`. That's a problem. Currently, I go up the class hierarchy and test whether the conditionally_defined instance is in the `__dict__` of the class. But if the conditionally_defined instance is wrapped in a different wrapper (e.g., a cached_method), then this way of determining the class will fail.\n> \n> I wonder if Python gives this information automatically, when it invokes `__get__`. To be investigated...\n\nPS: In my current patch, I trust that the class that Python gives as an argument to `__get__` is the class in which the object-to-be-bound is found. It seems to work.",
    "created_at": "2013-08-18T17:28:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147421",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:18" align="right">comment:18</div>

Replying to [@simon-king-jena](#comment%3A16):
> At some point, I need to find out what class the default implementation is defined for, so that one can get the non-default implementation by a call to `super`. That's a problem. Currently, I go up the class hierarchy and test whether the conditionally_defined instance is in the `__dict__` of the class. But if the conditionally_defined instance is wrapped in a different wrapper (e.g., a cached_method), then this way of determining the class will fail.
> 
> I wonder if Python gives this information automatically, when it invokes `__get__`. To be investigated...

PS: In my current patch, I trust that the class that Python gives as an argument to `__get__` is the class in which the object-to-be-bound is found. It seems to work.



---

archive/issue_comments_147422.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nI updated the \"proof of concept\" again. In addition to the previous example, the implementation now plays well with the category framework. Namely, in the following example from the doctest, both the default and the non-default implementation of a conditionally defined method are defined in the element classes of categories, and the method which the implementation depends on is defined in the category, too.\n\nNote that one can now provide either a function or a string to the decorator. In the latter case, it tests the instance for the presence of an attribute of the given name.\n\nFrom the doctests:\n\n```\n    sage: from sage.misc.conditionally_defined import conditionally_defined\n    sage: from sage.structure.element import Element\n```\nWe define some category with some element method:\n\n```\n    sage: class MyCategory(Category):\n    ....:     def super_categories(self):\n    ....:         return [Objects()]\n    ....:     class ElementMethods:\n    ....:         def conditional_method(self, x):\n    ....:             print \"this works without helper\"\n    ....:             return -x\n```\nNext, we define a sub-category in which the afore-mentioned element class is\noverloaded, provided that the element has an attribute `\"helper\"`:\n\n```\n    sage: class MySubCategory(Category):\n    ....:     def super_categories(self):\n    ....:         return [MyCategory()]\n    ....:     class ElementMethods:\n    ....:         @conditionally_defined(\"helper\")\n    ....:         def conditional_method(self, x):\n    ....:             return self.helper(x)^2\n```\nWe define a third category that provides an element method called `\"helper\"`:\n\n```\n    sage: class MyHelperCategory(Category):\n    ....:    def super_categories(self):\n    ....:        return [Objects()]\n    ....:    class ElementMethods:\n    ....:         def helper(self, x):\n    ....:             print \"category helper\"\n    ....:             return x*2\n```\nFor using a conditionally defined method, it is necessary to either be able to\nassign attributes to the instance, or there must be a public attribute\n`__cached_methods` of type `<dict>`. Therefore, we create a Python version\nof `sage.structure.element.Element`:\n\n```\n    sage: class MyElement(Element): pass\n```\nWe define two parents. Both are objects of our second category, which\nconditionally overloads an element method. Only the parent `P2` is also an\nobject of the \"helper category\", which provides the prerequisite of\noverloading the conditional element method:\n\n```\n    sage: P1 = Parent(category=MySubCategory())\n    sage: P2 = Parent(category=Category.join([MySubCategory(),MyHelperCategory()]))\n```\nWe show that inheritance of a conditionally defined method from a category\neven works if the constructed elements are not instances of the category's\nelement class:\n\n```\n    sage: e1 = MyElement(P1)\n    sage: e2 = MyElement(P2)\n    sage: isinstance(e1, e1.parent().category().element_class)\n    False\n    sage: isinstance(e2, e2.parent().category().element_class)\n    False\n```\nNow, `e`` does not have a \"helper\" method, and thus its conditional method\nrelies on an implementation that does not ue the \"helper\". But `e2` does\nhave the \"helper\" method, and its conditional method makes use of it:\n\n```\n    sage: e1.conditional_method(2)\n    this works without helper\n    -2\n    sage: e2.conditional_method(2)\n    category helper\n    16\n```\n\nNicolas, do you think of further features or use cases? Otherwise, I think I should finalise the patch by adding docs and tests to every method.",
    "created_at": "2013-08-18T23:30:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147422",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:19" align="right">comment:19</div>

I updated the "proof of concept" again. In addition to the previous example, the implementation now plays well with the category framework. Namely, in the following example from the doctest, both the default and the non-default implementation of a conditionally defined method are defined in the element classes of categories, and the method which the implementation depends on is defined in the category, too.

Note that one can now provide either a function or a string to the decorator. In the latter case, it tests the instance for the presence of an attribute of the given name.

From the doctests:

```
    sage: from sage.misc.conditionally_defined import conditionally_defined
    sage: from sage.structure.element import Element
```
We define some category with some element method:

```
    sage: class MyCategory(Category):
    ....:     def super_categories(self):
    ....:         return [Objects()]
    ....:     class ElementMethods:
    ....:         def conditional_method(self, x):
    ....:             print "this works without helper"
    ....:             return -x
```
Next, we define a sub-category in which the afore-mentioned element class is
overloaded, provided that the element has an attribute `"helper"`:

```
    sage: class MySubCategory(Category):
    ....:     def super_categories(self):
    ....:         return [MyCategory()]
    ....:     class ElementMethods:
    ....:         @conditionally_defined("helper")
    ....:         def conditional_method(self, x):
    ....:             return self.helper(x)^2
```
We define a third category that provides an element method called `"helper"`:

```
    sage: class MyHelperCategory(Category):
    ....:    def super_categories(self):
    ....:        return [Objects()]
    ....:    class ElementMethods:
    ....:         def helper(self, x):
    ....:             print "category helper"
    ....:             return x*2
```
For using a conditionally defined method, it is necessary to either be able to
assign attributes to the instance, or there must be a public attribute
`__cached_methods` of type `<dict>`. Therefore, we create a Python version
of `sage.structure.element.Element`:

```
    sage: class MyElement(Element): pass
```
We define two parents. Both are objects of our second category, which
conditionally overloads an element method. Only the parent `P2` is also an
object of the "helper category", which provides the prerequisite of
overloading the conditional element method:

```
    sage: P1 = Parent(category=MySubCategory())
    sage: P2 = Parent(category=Category.join([MySubCategory(),MyHelperCategory()]))
```
We show that inheritance of a conditionally defined method from a category
even works if the constructed elements are not instances of the category's
element class:

```
    sage: e1 = MyElement(P1)
    sage: e2 = MyElement(P2)
    sage: isinstance(e1, e1.parent().category().element_class)
    False
    sage: isinstance(e2, e2.parent().category().element_class)
    False
```
Now, `e`` does not have a "helper" method, and thus its conditional method
relies on an implementation that does not ue the "helper". But `e2` does
have the "helper" method, and its conditional method makes use of it:

```
    sage: e1.conditional_method(2)
    this works without helper
    -2
    sage: e2.conditional_method(2)
    category helper
    16
```

Nicolas, do you think of further features or use cases? Otherwise, I think I should finalise the patch by adding docs and tests to every method.



---

archive/issue_comments_147423.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nReplying to [@simon-king-jena](#comment%3A18):\n> > At some point, I need to find out what class the default\n> > implementation is defined for, so that one can get the non-default\n> > implementation by a call to `super`. That's a problem. Currently,\n> > I go up the class hierarchy and test whether the\n> > conditionally_defined instance is in the `__dict__` of the\n> > class. But if the conditionally_defined instance is wrapped in a\n> > different wrapper (e.g., a cached_method), then this way of\n> > determining the class will fail.\n\nI haven't looked at the code; just wondering: since ``lazy_attribute``\nis already doing something like this could this piece of work be\ndelegated to it?\n\n> PS: In my current patch, I trust that the class that Python gives as\n> an argument to `__get__` is the class in which the\n> object-to-be-bound is found. It seems to work.\n\nThe Descriptor protocol is described quite in detail in\nhttp://docs.python.org/2/howto/descriptor.html; maybe it says\nsomething about this.\n\n\nBy the way: the\n\n```\n    @cached_method\n    @conditionally_method\n    ...\n```\nfeature is nice looking for comprehensiveness, but I am really not\nsure I have a real use case for it. So if dropping this feature makes\nthe code simpler, go for it.\n\nCheers,\n                          Nicolas",
    "created_at": "2013-08-19T13:00:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147423",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:20" align="right">comment:20</div>

Replying to [@simon-king-jena](#comment%3A18):
> > At some point, I need to find out what class the default
> > implementation is defined for, so that one can get the non-default
> > implementation by a call to `super`. That's a problem. Currently,
> > I go up the class hierarchy and test whether the
> > conditionally_defined instance is in the `__dict__` of the
> > class. But if the conditionally_defined instance is wrapped in a
> > different wrapper (e.g., a cached_method), then this way of
> > determining the class will fail.

I haven't looked at the code; just wondering: since ``lazy_attribute``
is already doing something like this could this piece of work be
delegated to it?

> PS: In my current patch, I trust that the class that Python gives as
> an argument to `__get__` is the class in which the
> object-to-be-bound is found. It seems to work.

The Descriptor protocol is described quite in detail in
http://docs.python.org/2/howto/descriptor.html; maybe it says
something about this.


By the way: the

```
    @cached_method
    @conditionally_method
    ...
```
feature is nice looking for comprehensiveness, but I am really not
sure I have a real use case for it. So if dropping this feature makes
the code simpler, go for it.

Cheers,
                          Nicolas



---

archive/issue_comments_147424.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@simon-king-jena](#comment%3A19):\n> Nicolas, do you think of further features or use cases? Otherwise, I\n> think I should finalise the patch by adding docs and tests to every\n> method.\n\nI think this looks great. Go ahead and finalize! Thanks!\n\n(besides, I'd rather use your skills for #10963 :-))\n\nCheers,",
    "created_at": "2013-08-19T13:01:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147424",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@simon-king-jena](#comment%3A19):
> Nicolas, do you think of further features or use cases? Otherwise, I
> think I should finalise the patch by adding docs and tests to every
> method.

I think this looks great. Go ahead and finalize! Thanks!

(besides, I'd rather use your skills for #10963 :-))

Cheers,



---

archive/issue_comments_147425.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nReplying to [@nthiery](#comment%3A20):\n> Replying to [@simon-king-jena](#comment%3A18):\n> > > At some point, I need to find out what class the default\n> > > implementation is defined for, so that one can get the non-default\n> > > implementation by a call to `super`. That's a problem. Currently,\n> > > I go up the class hierarchy and test whether the\n> > > conditionally_defined instance is in the `__dict__` of the\n> > > class. But if the conditionally_defined instance is wrapped in a\n> > > different wrapper (e.g., a cached_method), then this way of\n> > > determining the class will fail.\n> \n> \n> I haven't looked at the code; just wondering: since ``lazy_attribute``\n> is already doing something like this could this piece of work be\n> delegated to it?\n\nNo, because `lazy_attribute` does not care about what is defined in the super-class. But the `conditionally_defined` decorator *has* to care about what is defined in the super-class, and thus has to know \"super with respect to WHAT class\".\n\nBy the way, a simple lazy attribute would not work on special methods of instances of `<object>`.\n\n> The Descriptor protocol is described quite in detail in\n> http://docs.python.org/2/howto/descriptor.html; maybe it says\n> something about this.\n\nThank you, I'll have a look\n \n> \n> By the way: the\n> \n> ```\n>     @cached_method\n>     @conditionally_method\n>     ...\n> ```\n> feature is nice looking for comprehensiveness, but I am really not\n> sure I have a real use case for it.\n\nNo?? Well, you could of course obtain a similar behaviour if you use the `@`cached_method decorator *both* on the default implementation and the non-default implementation:\n\n```\nclass A(object):\n    @cached_method\n    def method1(self,...):\n        ...\nclass B(A):\n    @conditionally_defined(...)\n    @cached_method\n    def method1(self, ...):\n        ...\n```\nThis has *nearly* the same effect as this:\n\n```\nclass A(object):\n    def method1(self,...):\n        ...\nclass B(A):\n    @cached_method\n    @conditionally_defined(...)\n    def method1(self, ...):\n        ...\n```\n\nThe difference between the two approaches is that in the second approach the class A has a non-cached method1. And perhaps it is intended that it does not have a cache.\n\n> So if dropping this feature makes\n> the code simpler, go for it.\n\n```\n@cached_method\n@conditionally_defined(...)\n```\nis implemented in #15056 (which I think is useful independent of conditionally_defined).\n\n```\n@conditionally_defined(...)\n@cached_method\n```\nis implemented here, and it does not pose an additional complication: We want (under a certain condition) to bind a method to an instance, and that's the same as binding a `CachedMethodCaller` to the instance.",
    "created_at": "2013-08-19T15:00:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147425",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:22" align="right">comment:22</div>

Replying to [@nthiery](#comment%3A20):
> Replying to [@simon-king-jena](#comment%3A18):
> > > At some point, I need to find out what class the default
> > > implementation is defined for, so that one can get the non-default
> > > implementation by a call to `super`. That's a problem. Currently,
> > > I go up the class hierarchy and test whether the
> > > conditionally_defined instance is in the `__dict__` of the
> > > class. But if the conditionally_defined instance is wrapped in a
> > > different wrapper (e.g., a cached_method), then this way of
> > > determining the class will fail.
> 
> 
> I haven't looked at the code; just wondering: since ``lazy_attribute``
> is already doing something like this could this piece of work be
> delegated to it?

No, because `lazy_attribute` does not care about what is defined in the super-class. But the `conditionally_defined` decorator *has* to care about what is defined in the super-class, and thus has to know "super with respect to WHAT class".

By the way, a simple lazy attribute would not work on special methods of instances of `<object>`.

> The Descriptor protocol is described quite in detail in
> http://docs.python.org/2/howto/descriptor.html; maybe it says
> something about this.

Thank you, I'll have a look
 
> 
> By the way: the
> 
> ```
>     @cached_method
>     @conditionally_method
>     ...
> ```
> feature is nice looking for comprehensiveness, but I am really not
> sure I have a real use case for it.

No?? Well, you could of course obtain a similar behaviour if you use the `@`cached_method decorator *both* on the default implementation and the non-default implementation:

```
class A(object):
    @cached_method
    def method1(self,...):
        ...
class B(A):
    @conditionally_defined(...)
    @cached_method
    def method1(self, ...):
        ...
```
This has *nearly* the same effect as this:

```
class A(object):
    def method1(self,...):
        ...
class B(A):
    @cached_method
    @conditionally_defined(...)
    def method1(self, ...):
        ...
```

The difference between the two approaches is that in the second approach the class A has a non-cached method1. And perhaps it is intended that it does not have a cache.

> So if dropping this feature makes
> the code simpler, go for it.

```
@cached_method
@conditionally_defined(...)
```
is implemented in #15056 (which I think is useful independent of conditionally_defined).

```
@conditionally_defined(...)
@cached_method
```
is implemented here, and it does not pose an additional complication: We want (under a certain condition) to bind a method to an instance, and that's the same as binding a `CachedMethodCaller` to the instance.



---

archive/issue_comments_147426.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nBy the way, here is yet another example. This time, it is for a special Python method (`__len__`). \n\nScenario: We have a class A, with `len` being implemented. But the instances are mutable. in a sub-class B, some instances are immutable (but not all). If an instance is immutable, we want that the length is cached (which is possible by #12601).\n\nThis can be done as follows:\n\n```\nsage: class A(object):\n....:     def __init__(self, n):\n....:         self.data = range(n)\n....:     def __len__(self):\n....:         return len(self.data)\nsage: class B(A):                \n....:     def __init__(self, n, immutable):\n....:         A.__init__(self, n)\n....:         if immutable:\n....:             self.is_immutable = True\n....:     @conditionally_defined(\"is_immutable\")\n....:     @cached_method\n....:     def __len__(self):\n....:         return super(B,self).__len__()\n```\nFirst of all, the length works for both mutable and \"immutable\" instances of B:\n\n```\nsage: a = B(3,False)\nsage: b = B(5,True)\nsage: len(a)\n3\nsage: len(b)\n5\n```\nOf course, one can alter both instances, but we see that the length of b is cached, in contrast to the length of a:\n\n```\nsage: a.data.append(4)\nsage: b.data.append(5)\nsage: len(a)\n4\nsage: len(b)\n5\nsage: len(b.data)\n6\n```\n\nNote that the cached length function is very fast. Compare with this:\n\n```\nsage: class C(object):\n....:     def __len__(self):\n....:         return int(5)\n....:     \nsage: c = C()\nsage: len(c)\n5\nsage: len(b)\n5\nsage: %timeit len(c)\n1000000 loops, best of 3: 793 ns per loop\nsage: %timeit len(b)\n1000000 loops, best of 3: 377 ns per loop\n```\n\nThis is because a `CachedMethodCallerNoArgs` has Cython speed.",
    "created_at": "2013-08-19T15:13:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147426",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:23" align="right">comment:23</div>

By the way, here is yet another example. This time, it is for a special Python method (`__len__`). 

Scenario: We have a class A, with `len` being implemented. But the instances are mutable. in a sub-class B, some instances are immutable (but not all). If an instance is immutable, we want that the length is cached (which is possible by #12601).

This can be done as follows:

```
sage: class A(object):
....:     def __init__(self, n):
....:         self.data = range(n)
....:     def __len__(self):
....:         return len(self.data)
sage: class B(A):                
....:     def __init__(self, n, immutable):
....:         A.__init__(self, n)
....:         if immutable:
....:             self.is_immutable = True
....:     @conditionally_defined("is_immutable")
....:     @cached_method
....:     def __len__(self):
....:         return super(B,self).__len__()
```
First of all, the length works for both mutable and "immutable" instances of B:

```
sage: a = B(3,False)
sage: b = B(5,True)
sage: len(a)
3
sage: len(b)
5
```
Of course, one can alter both instances, but we see that the length of b is cached, in contrast to the length of a:

```
sage: a.data.append(4)
sage: b.data.append(5)
sage: len(a)
4
sage: len(b)
5
sage: len(b.data)
6
```

Note that the cached length function is very fast. Compare with this:

```
sage: class C(object):
....:     def __len__(self):
....:         return int(5)
....:     
sage: c = C()
sage: len(c)
5
sage: len(b)
5
sage: %timeit len(c)
1000000 loops, best of 3: 793 ns per loop
sage: %timeit len(b)
1000000 loops, best of 3: 377 ns per loop
```

This is because a `CachedMethodCallerNoArgs` has Cython speed.



---

archive/issue_comments_147427.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nDear Nicolas,\n\nReplying to [@simon-king-jena](#comment%3A22):\n> Replying to [@nthiery](#comment%3A20):\n> > The Descriptor protocol is described quite in detail in\n> > http://docs.python.org/2/howto/descriptor.html; maybe it says\n> > something about this.\n> \n> \n> Thank you, I'll have a look\n\nI had, and it confirms that the current implementation is OK.",
    "created_at": "2013-08-19T15:47:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147427",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:24" align="right">comment:24</div>

Dear Nicolas,

Replying to [@simon-king-jena](#comment%3A22):
> Replying to [@nthiery](#comment%3A20):
> > The Descriptor protocol is described quite in detail in
> > http://docs.python.org/2/howto/descriptor.html; maybe it says
> > something about this.
> 
> 
> Thank you, I'll have a look

I had, and it confirms that the current implementation is OK.



---

archive/issue_events_177921.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-08-22T12:48:08Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177921"
}
```



---

archive/issue_comments_147428.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nI have attached a new patch version, and now I think the conditionally_defined wrapper is feature-complete. The documentation provides extensive tests.\n\nRestriction:\n- We *must* have new style classes, since for an old style class there seems to be no way to access the class hierarchy.\n\nWhat one can do with the wrapper:\n- It works on usual methods and special Python methods (`__hash__`, `__len__`, ...)\n- It works well in combination with other wrappers such as cached_method and lazy_attribute.\n- It works within the category framework. To make it work, if `B` is a class, `B.bar` must yield the wrapper and not the unbound method in default implementation.\n- Even though `B.bar` is a wrapper, it behaves like an unbound method: When calling it like `B.bar(b, *args, **kwds)` with `b` an instance of `B` then it calls the default implementation on `b` with the given additional arguments. Note that this is not necessarily the same as `b.bar(*args,**kwds)`, because the latter may be the non-default implementation inherited from a super-class.\n- Introspection works. Again, since `B.bar` is a wrapper and not an unbound method, we need some magic, namely methods `_sage_doc_`, `_sage_src_` etc.\n\nThe only thing I can currently think of that does not work:\n\n```\nclass A(object):\n    x = 5\nclass B(A):\n    @conditionally_defined(lambda x: x.condition>0)\n    x = 7\n```\nNo idea how this can be made work.\n\nI just realise that I forgot to add examples for the introspection method. Once they are added, it can be reviewed!",
    "created_at": "2013-08-22T12:48:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147428",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:25" align="right">comment:25</div>

I have attached a new patch version, and now I think the conditionally_defined wrapper is feature-complete. The documentation provides extensive tests.

Restriction:
- We *must* have new style classes, since for an old style class there seems to be no way to access the class hierarchy.

What one can do with the wrapper:
- It works on usual methods and special Python methods (`__hash__`, `__len__`, ...)
- It works well in combination with other wrappers such as cached_method and lazy_attribute.
- It works within the category framework. To make it work, if `B` is a class, `B.bar` must yield the wrapper and not the unbound method in default implementation.
- Even though `B.bar` is a wrapper, it behaves like an unbound method: When calling it like `B.bar(b, *args, **kwds)` with `b` an instance of `B` then it calls the default implementation on `b` with the given additional arguments. Note that this is not necessarily the same as `b.bar(*args,**kwds)`, because the latter may be the non-default implementation inherited from a super-class.
- Introspection works. Again, since `B.bar` is a wrapper and not an unbound method, we need some magic, namely methods `_sage_doc_`, `_sage_src_` etc.

The only thing I can currently think of that does not work:

```
class A(object):
    x = 5
class B(A):
    @conditionally_defined(lambda x: x.condition>0)
    x = 7
```
No idea how this can be made work.

I just realise that I forgot to add examples for the introspection method. Once they are added, it can be reviewed!



---

archive/issue_comments_147429.json:
```json
{
    "body": "Attachment: **[trac12978-conditionally_defined.patch.gz](https://github.com/sagemath/sage/files/ticket12978/trac12978-conditionally_defined.patch.gz)**\n\nTo be reviewed",
    "created_at": "2013-08-22T13:02:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147429",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment: **[trac12978-conditionally_defined.patch.gz](https://github.com/sagemath/sage/files/ticket12978/trac12978-conditionally_defined.patch.gz)**

To be reviewed



---

archive/issue_comments_147430.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nOK, now the doctest coverage is complete. Ready for review!",
    "created_at": "2013-08-22T13:02:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147430",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:26" align="right">comment:26</div>

OK, now the doctest coverage is complete. Ready for review!



---

archive/issue_comments_147431.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nIt isn't \"wishlist\" any more....",
    "created_at": "2013-08-22T20:47:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147431",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:27" align="right">comment:27</div>

It isn't "wishlist" any more....



---

archive/issue_events_177922.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-08-22T20:47:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177922"
}
```



---

archive/issue_events_177923.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-08-22T20:47:47Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/wishlist%20item",
    "label_color": "e81ff9",
    "label_name": "wishlist item",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177923"
}
```



---

archive/issue_events_177924.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177924"
}
```



---

archive/issue_events_177925.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177925"
}
```



---

archive/issue_events_177926.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177926"
}
```



---

archive/issue_events_177927.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177927"
}
```



---

archive/issue_events_177928.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177928"
}
```



---

archive/issue_events_177929.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177929"
}
```



---

archive/issue_events_177930.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-20T19:28:19Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177930"
}
```



---

archive/issue_events_177931.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-20T19:28:19Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177931"
}
```



---

archive/issue_comments_147432.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nneeds a git branch, if this is still of any pertinence",
    "created_at": "2015-05-20T19:28:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/12978#issuecomment-147432",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:31" align="right">comment:31</div>

needs a git branch, if this is still of any pertinence



---

archive/issue_events_177932.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-20T19:28:19Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177932"
}
```



---

archive/issue_events_177933.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2015-05-20T19:28:19Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177933"
}
```



---

archive/issue_events_177934.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:32:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/12978",
    "milestone_number": null,
    "milestone_title": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/12978#event-177934"
}
```
