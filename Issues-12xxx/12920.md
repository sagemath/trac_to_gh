# Issue 12920: Testsuite: allow sharing code between is_bar and _test_bar methods

archive/issues_012748.json:
```json
{
    "body": "`is_method` / `_test_from_is_method`: method wrappers to factor out code between `is_bar` and `_test_bar` methods\n\nFrom the documentation:\n\nThe typical usecase for those wrappers is as follow: Consider a\ncategory `Foo` with a subcategory `Bar`.  `Foo` wants to\nprovide a method `Foo.ParentMethods.is_bar` such that, for `F`\nin `Foo()`, `F.is_bar()` returns whether `F` satisfies all\nthe properties of `Bar()`. The method `is_bar` is allowed to\nassume that `F` indeed satisfies all the properties specified by\n`Foo()`. It may decide to upgrade the category of `F` to\n`Bar()`.\n\n`Bar` itself wants to provide a method\n`Bar.ParentMethod._test_bar` which is supposed to do some\nreasonable sanity checks on `F` to determine whether it\nsatisfies all the properties of `Bar`. If yes, `F._test_bla()`\nshould return None; otherwise it should raise some (hopefully\nmeaningful) assertion.  Note that `Bar()` will typically\noverride `is_bar` by a trivial method that always returns\n`True`.\n\nThe purpose of two decorators `is_method` and\n`_test_method_from_is` is to factor out the logic between the two\nrelated methods `F.is_bla()` and `F._test_bla()`. They take as\ninput a Python function `is_bla(self, proof=False, **options)`.\nThis function should proceed as usual for a `_test method` (see\n:class:`TestSuite`). If `proof` is `True`, then the answer\nshould be provably correct. At the end, `is_bla` should return\n`None`, or a category that will be used to refine the category\nof `F`.\n\n\n**Assignee:** mvngu\n\n**CC:**  sage-combinat\n\n**Keywords:** days38\n\n**Reviewer:** Franco Saliola\n\n**Author:** Nicolas M. Thi\u00e9ry\n\n**Status:** needs_work\n\nIssue created by migration from https://trac.sagemath.org/ticket/12920\n\n",
    "created_at": "2012-05-07T18:43:51Z",
    "labels": [
        "component: misc",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.6",
    "title": "Testsuite: allow sharing code between is_bar and _test_bar methods",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12920",
    "user": "https://github.com/nthiery"
}
```
`is_method` / `_test_from_is_method`: method wrappers to factor out code between `is_bar` and `_test_bar` methods

From the documentation:

The typical usecase for those wrappers is as follow: Consider a
category `Foo` with a subcategory `Bar`.  `Foo` wants to
provide a method `Foo.ParentMethods.is_bar` such that, for `F`
in `Foo()`, `F.is_bar()` returns whether `F` satisfies all
the properties of `Bar()`. The method `is_bar` is allowed to
assume that `F` indeed satisfies all the properties specified by
`Foo()`. It may decide to upgrade the category of `F` to
`Bar()`.

`Bar` itself wants to provide a method
`Bar.ParentMethod._test_bar` which is supposed to do some
reasonable sanity checks on `F` to determine whether it
satisfies all the properties of `Bar`. If yes, `F._test_bla()`
should return None; otherwise it should raise some (hopefully
meaningful) assertion.  Note that `Bar()` will typically
override `is_bar` by a trivial method that always returns
`True`.

The purpose of two decorators `is_method` and
`_test_method_from_is` is to factor out the logic between the two
related methods `F.is_bla()` and `F._test_bla()`. They take as
input a Python function `is_bla(self, proof=False, **options)`.
This function should proceed as usual for a `_test method` (see
:class:`TestSuite`). If `proof` is `True`, then the answer
should be provably correct. At the end, `is_bla` should return
`None`, or a category that will be used to refine the category
of `F`.


**Assignee:** mvngu

**CC:**  sage-combinat

**Keywords:** days38

**Reviewer:** Franco Saliola

**Author:** Nicolas M. Thi√©ry

**Status:** needs_work

Issue created by migration from https://trac.sagemath.org/ticket/12920





---

archive/issue_comments_182558.json:
```json
{
    "body": "**Changing status** from new to needs_review.",
    "created_at": "2012-05-07T18:46:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182558",
    "user": "https://github.com/nthiery"
}
```

**Changing status** from new to needs_review.



---

archive/issue_comments_182559.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1 +1,32 @@\n+``is_method`` / ``_test_from_is_method``: method wrappers to factor out code between ``is_bar`` and ``_test_bar`` methods\n \n+From the documentation:\n+\n+The typical usecase for those wrappers is as follow: Consider a\n+category ``Foo`` with a subcategory ``Bar``.  ``Foo`` wants to\n+provide a method ``Foo.ParentMethods.is_bar`` such that, for ``F``\n+in ``Foo()``, ``F.is_bar()`` returns whether ``F`` satisfies all\n+the properties of ``Bar()``. The method ``is_bar`` is allowed to\n+assume that ``F`` indeed satisfies all the properties specified by\n+``Foo()``. It may decide to upgrade the category of ``F`` to\n+``Bar()``.\n+\n+``Bar`` itself wants to provide a method\n+``Bar.ParentMethod._test_bar`` which is supposed to do some\n+reasonable sanity checks on ``F`` to determine whether it\n+satisfies all the properties of ``Bar``. If yes, ``F._test_bla()``\n+should return None; otherwise it should raise some (hopefully\n+meaningful) assertion.  Note that ``Bar()`` will typically\n+override ``is_bar`` by a trivial method that always returns\n+``True``.\n+\n+The purpose of two decorators ``is_method`` and\n+``_test_method_from_is`` is to factor out the logic between the two\n+related methods ``F.is_bla()`` and ``F._test_bla()``. They take as\n+input a Python function ``is_bla(self, proof=False, **options)``.\n+This function should proceed as usual for a ``_test method`` (see\n+:class:`TestSuite`). If ``proof`` is ``True``, then the answer\n+should be provably correct. At the end, ``is_bla`` should return\n+``None``, or a category that will be used to refine the category\n+of ``F``.\n+\n``````\n",
    "created_at": "2012-05-07T18:46:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182559",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1 +1,32 @@
+``is_method`` / ``_test_from_is_method``: method wrappers to factor out code between ``is_bar`` and ``_test_bar`` methods
 
+From the documentation:
+
+The typical usecase for those wrappers is as follow: Consider a
+category ``Foo`` with a subcategory ``Bar``.  ``Foo`` wants to
+provide a method ``Foo.ParentMethods.is_bar`` such that, for ``F``
+in ``Foo()``, ``F.is_bar()`` returns whether ``F`` satisfies all
+the properties of ``Bar()``. The method ``is_bar`` is allowed to
+assume that ``F`` indeed satisfies all the properties specified by
+``Foo()``. It may decide to upgrade the category of ``F`` to
+``Bar()``.
+
+``Bar`` itself wants to provide a method
+``Bar.ParentMethod._test_bar`` which is supposed to do some
+reasonable sanity checks on ``F`` to determine whether it
+satisfies all the properties of ``Bar``. If yes, ``F._test_bla()``
+should return None; otherwise it should raise some (hopefully
+meaningful) assertion.  Note that ``Bar()`` will typically
+override ``is_bar`` by a trivial method that always returns
+``True``.
+
+The purpose of two decorators ``is_method`` and
+``_test_method_from_is`` is to factor out the logic between the two
+related methods ``F.is_bla()`` and ``F._test_bla()``. They take as
+input a Python function ``is_bla(self, proof=False, **options)``.
+This function should proceed as usual for a ``_test method`` (see
+:class:`TestSuite`). If ``proof`` is ``True``, then the answer
+should be provably correct. At the end, ``is_bla`` should return
+``None``, or a category that will be used to refine the category
+of ``F``.
+
``````




---

archive/issue_comments_182560.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,32 +1,32 @@\n-``is_method`` / ``_test_from_is_method``: method wrappers to factor out code between ``is_bar`` and ``_test_bar`` methods\n+{{{is_method}} / {{{_test_from_is_method}}: method wrappers to factor out code between {{{is_bar}} and {{{_test_bar}} methods\n \n From the documentation:\n \n The typical usecase for those wrappers is as follow: Consider a\n-category ``Foo`` with a subcategory ``Bar``.  ``Foo`` wants to\n-provide a method ``Foo.ParentMethods.is_bar`` such that, for ``F``\n-in ``Foo()``, ``F.is_bar()`` returns whether ``F`` satisfies all\n-the properties of ``Bar()``. The method ``is_bar`` is allowed to\n-assume that ``F`` indeed satisfies all the properties specified by\n-``Foo()``. It may decide to upgrade the category of ``F`` to\n-``Bar()``.\n+category {{{Foo}} with a subcategory {{{Bar}}.  {{{Foo}} wants to\n+provide a method {{{Foo.ParentMethods.is_bar}} such that, for {{{F}}\n+in {{{Foo()}}, {{{F.is_bar()}} returns whether {{{F}} satisfies all\n+the properties of {{{Bar()}}. The method {{{is_bar}} is allowed to\n+assume that {{{F}} indeed satisfies all the properties specified by\n+{{{Foo()}}. It may decide to upgrade the category of {{{F}} to\n+{{{Bar()}}.\n \n-``Bar`` itself wants to provide a method\n-``Bar.ParentMethod._test_bar`` which is supposed to do some\n-reasonable sanity checks on ``F`` to determine whether it\n-satisfies all the properties of ``Bar``. If yes, ``F._test_bla()``\n+{{{Bar}} itself wants to provide a method\n+{{{Bar.ParentMethod._test_bar}} which is supposed to do some\n+reasonable sanity checks on {{{F}} to determine whether it\n+satisfies all the properties of {{{Bar}}. If yes, {{{F._test_bla()}}\n should return None; otherwise it should raise some (hopefully\n-meaningful) assertion.  Note that ``Bar()`` will typically\n-override ``is_bar`` by a trivial method that always returns\n-``True``.\n+meaningful) assertion.  Note that {{{Bar()}} will typically\n+override {{{is_bar}} by a trivial method that always returns\n+{{{True}}.\n \n-The purpose of two decorators ``is_method`` and\n-``_test_method_from_is`` is to factor out the logic between the two\n-related methods ``F.is_bla()`` and ``F._test_bla()``. They take as\n-input a Python function ``is_bla(self, proof=False, **options)``.\n-This function should proceed as usual for a ``_test method`` (see\n-:class:`TestSuite`). If ``proof`` is ``True``, then the answer\n-should be provably correct. At the end, ``is_bla`` should return\n-``None``, or a category that will be used to refine the category\n-of ``F``.\n+The purpose of two decorators {{{is_method}} and\n+{{{_test_method_from_is}} is to factor out the logic between the two\n+related methods {{{F.is_bla()}} and {{{F._test_bla()}}. They take as\n+input a Python function {{{is_bla(self, proof=False, **options)}}.\n+This function should proceed as usual for a {{{_test method}} (see\n+:class:`TestSuite`). If {{{proof}} is {{{True}}, then the answer\n+should be provably correct. At the end, {{{is_bla}} should return\n+{{{None}}, or a category that will be used to refine the category\n+of {{{F}}.\n \n``````\n",
    "created_at": "2012-05-07T18:51:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182560",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,32 +1,32 @@
-``is_method`` / ``_test_from_is_method``: method wrappers to factor out code between ``is_bar`` and ``_test_bar`` methods
+{{{is_method}} / {{{_test_from_is_method}}: method wrappers to factor out code between {{{is_bar}} and {{{_test_bar}} methods
 
 From the documentation:
 
 The typical usecase for those wrappers is as follow: Consider a
-category ``Foo`` with a subcategory ``Bar``.  ``Foo`` wants to
-provide a method ``Foo.ParentMethods.is_bar`` such that, for ``F``
-in ``Foo()``, ``F.is_bar()`` returns whether ``F`` satisfies all
-the properties of ``Bar()``. The method ``is_bar`` is allowed to
-assume that ``F`` indeed satisfies all the properties specified by
-``Foo()``. It may decide to upgrade the category of ``F`` to
-``Bar()``.
+category {{{Foo}} with a subcategory {{{Bar}}.  {{{Foo}} wants to
+provide a method {{{Foo.ParentMethods.is_bar}} such that, for {{{F}}
+in {{{Foo()}}, {{{F.is_bar()}} returns whether {{{F}} satisfies all
+the properties of {{{Bar()}}. The method {{{is_bar}} is allowed to
+assume that {{{F}} indeed satisfies all the properties specified by
+{{{Foo()}}. It may decide to upgrade the category of {{{F}} to
+{{{Bar()}}.
 
-``Bar`` itself wants to provide a method
-``Bar.ParentMethod._test_bar`` which is supposed to do some
-reasonable sanity checks on ``F`` to determine whether it
-satisfies all the properties of ``Bar``. If yes, ``F._test_bla()``
+{{{Bar}} itself wants to provide a method
+{{{Bar.ParentMethod._test_bar}} which is supposed to do some
+reasonable sanity checks on {{{F}} to determine whether it
+satisfies all the properties of {{{Bar}}. If yes, {{{F._test_bla()}}
 should return None; otherwise it should raise some (hopefully
-meaningful) assertion.  Note that ``Bar()`` will typically
-override ``is_bar`` by a trivial method that always returns
-``True``.
+meaningful) assertion.  Note that {{{Bar()}} will typically
+override {{{is_bar}} by a trivial method that always returns
+{{{True}}.
 
-The purpose of two decorators ``is_method`` and
-``_test_method_from_is`` is to factor out the logic between the two
-related methods ``F.is_bla()`` and ``F._test_bla()``. They take as
-input a Python function ``is_bla(self, proof=False, **options)``.
-This function should proceed as usual for a ``_test method`` (see
-:class:`TestSuite`). If ``proof`` is ``True``, then the answer
-should be provably correct. At the end, ``is_bla`` should return
-``None``, or a category that will be used to refine the category
-of ``F``.
+The purpose of two decorators {{{is_method}} and
+{{{_test_method_from_is}} is to factor out the logic between the two
+related methods {{{F.is_bla()}} and {{{F._test_bla()}}. They take as
+input a Python function {{{is_bla(self, proof=False, **options)}}.
+This function should proceed as usual for a {{{_test method}} (see
+:class:`TestSuite`). If {{{proof}} is {{{True}}, then the answer
+should be provably correct. At the end, {{{is_bla}} should return
+{{{None}}, or a category that will be used to refine the category
+of {{{F}}.
 
``````




---

archive/issue_comments_182561.json:
```json
{
    "body": "**Changing keywords** from \"\" to \"days38\".",
    "created_at": "2012-05-07T18:52:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182561",
    "user": "https://github.com/nthiery"
}
```

**Changing keywords** from "" to "days38".



---

archive/issue_comments_182562.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,32 +1,32 @@\n-{{{is_method}} / {{{_test_from_is_method}}: method wrappers to factor out code between {{{is_bar}} and {{{_test_bar}} methods\n+`is_method` / `_test_from_is_method`: method wrappers to factor out code between `is_bar` and `_test_bar` methods\n \n From the documentation:\n \n The typical usecase for those wrappers is as follow: Consider a\n-category {{{Foo}} with a subcategory {{{Bar}}.  {{{Foo}} wants to\n-provide a method {{{Foo.ParentMethods.is_bar}} such that, for {{{F}}\n-in {{{Foo()}}, {{{F.is_bar()}} returns whether {{{F}} satisfies all\n-the properties of {{{Bar()}}. The method {{{is_bar}} is allowed to\n-assume that {{{F}} indeed satisfies all the properties specified by\n-{{{Foo()}}. It may decide to upgrade the category of {{{F}} to\n-{{{Bar()}}.\n+category `Foo` with a subcategory `Bar`.  `Foo` wants to\n+provide a method `Foo.ParentMethods.is_bar` such that, for `F`\n+in `Foo()`, `F.is_bar()` returns whether `F` satisfies all\n+the properties of `Bar()`. The method `is_bar` is allowed to\n+assume that `F` indeed satisfies all the properties specified by\n+`Foo()`. It may decide to upgrade the category of `F` to\n+`Bar()`.\n \n-{{{Bar}} itself wants to provide a method\n-{{{Bar.ParentMethod._test_bar}} which is supposed to do some\n-reasonable sanity checks on {{{F}} to determine whether it\n-satisfies all the properties of {{{Bar}}. If yes, {{{F._test_bla()}}\n+`Bar` itself wants to provide a method\n+`Bar.ParentMethod._test_bar` which is supposed to do some\n+reasonable sanity checks on `F` to determine whether it\n+satisfies all the properties of `Bar`. If yes, `F._test_bla()`\n should return None; otherwise it should raise some (hopefully\n-meaningful) assertion.  Note that {{{Bar()}} will typically\n-override {{{is_bar}} by a trivial method that always returns\n-{{{True}}.\n+meaningful) assertion.  Note that `Bar()` will typically\n+override `is_bar` by a trivial method that always returns\n+`True`.\n \n-The purpose of two decorators {{{is_method}} and\n-{{{_test_method_from_is}} is to factor out the logic between the two\n-related methods {{{F.is_bla()}} and {{{F._test_bla()}}. They take as\n-input a Python function {{{is_bla(self, proof=False, **options)}}.\n-This function should proceed as usual for a {{{_test method}} (see\n-:class:`TestSuite`). If {{{proof}} is {{{True}}, then the answer\n-should be provably correct. At the end, {{{is_bla}} should return\n-{{{None}}, or a category that will be used to refine the category\n-of {{{F}}.\n+The purpose of two decorators `is_method` and\n+`_test_method_from_is` is to factor out the logic between the two\n+related methods `F.is_bla()` and `F._test_bla()`. They take as\n+input a Python function `is_bla(self, proof=False, **options)`.\n+This function should proceed as usual for a `_test method` (see\n+:class:`TestSuite`). If `proof` is `True`, then the answer\n+should be provably correct. At the end, `is_bla` should return\n+`None`, or a category that will be used to refine the category\n+of `F`.\n \n``````\n",
    "created_at": "2012-05-07T18:54:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182562",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,32 +1,32 @@
-{{{is_method}} / {{{_test_from_is_method}}: method wrappers to factor out code between {{{is_bar}} and {{{_test_bar}} methods
+`is_method` / `_test_from_is_method`: method wrappers to factor out code between `is_bar` and `_test_bar` methods
 
 From the documentation:
 
 The typical usecase for those wrappers is as follow: Consider a
-category {{{Foo}} with a subcategory {{{Bar}}.  {{{Foo}} wants to
-provide a method {{{Foo.ParentMethods.is_bar}} such that, for {{{F}}
-in {{{Foo()}}, {{{F.is_bar()}} returns whether {{{F}} satisfies all
-the properties of {{{Bar()}}. The method {{{is_bar}} is allowed to
-assume that {{{F}} indeed satisfies all the properties specified by
-{{{Foo()}}. It may decide to upgrade the category of {{{F}} to
-{{{Bar()}}.
+category `Foo` with a subcategory `Bar`.  `Foo` wants to
+provide a method `Foo.ParentMethods.is_bar` such that, for `F`
+in `Foo()`, `F.is_bar()` returns whether `F` satisfies all
+the properties of `Bar()`. The method `is_bar` is allowed to
+assume that `F` indeed satisfies all the properties specified by
+`Foo()`. It may decide to upgrade the category of `F` to
+`Bar()`.
 
-{{{Bar}} itself wants to provide a method
-{{{Bar.ParentMethod._test_bar}} which is supposed to do some
-reasonable sanity checks on {{{F}} to determine whether it
-satisfies all the properties of {{{Bar}}. If yes, {{{F._test_bla()}}
+`Bar` itself wants to provide a method
+`Bar.ParentMethod._test_bar` which is supposed to do some
+reasonable sanity checks on `F` to determine whether it
+satisfies all the properties of `Bar`. If yes, `F._test_bla()`
 should return None; otherwise it should raise some (hopefully
-meaningful) assertion.  Note that {{{Bar()}} will typically
-override {{{is_bar}} by a trivial method that always returns
-{{{True}}.
+meaningful) assertion.  Note that `Bar()` will typically
+override `is_bar` by a trivial method that always returns
+`True`.
 
-The purpose of two decorators {{{is_method}} and
-{{{_test_method_from_is}} is to factor out the logic between the two
-related methods {{{F.is_bla()}} and {{{F._test_bla()}}. They take as
-input a Python function {{{is_bla(self, proof=False, **options)}}.
-This function should proceed as usual for a {{{_test method}} (see
-:class:`TestSuite`). If {{{proof}} is {{{True}}, then the answer
-should be provably correct. At the end, {{{is_bla}} should return
-{{{None}}, or a category that will be used to refine the category
-of {{{F}}.
+The purpose of two decorators `is_method` and
+`_test_method_from_is` is to factor out the logic between the two
+related methods `F.is_bla()` and `F._test_bla()`. They take as
+input a Python function `is_bla(self, proof=False, **options)`.
+This function should proceed as usual for a `_test method` (see
+:class:`TestSuite`). If `proof` is `True`, then the answer
+should be provably correct. At the end, `is_bla` should return
+`None`, or a category that will be used to refine the category
+of `F`.
 
``````




---

archive/attachments_017418.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_12920-is_test_methods-nt.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket12920/trac_12920-is_test_methods-nt.patch",
    "created_at": "2013-03-28T23:09:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/roed314"
}
```



---

archive/issue_comments_182563.json:
```json
{
    "body": "<a id='comment:5'></a>\n",
    "created_at": "2013-03-28T23:09:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182563",
    "user": "https://github.com/roed314"
}
```

<a id='comment:5'></a>




---

archive/issue_events_040805.json:
```json
{
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "label": "component: doctest framework",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40805"
}
```



---

archive/issue_comments_182564.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2013-07-09T07:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182564",
    "user": "https://github.com/videlec"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_182565.json:
```json
{
    "body": "<a id='comment:6'></a>\nNeeds to rebase on 5-11.beta3 (reject on unittest.py).\n\nThe patch may definitely be useful. There are two things that I dislike.\n\n1) When you add the decorator the code does not correspond anymore to a is_X method (it does not return a boolean but raise an error or return a refined category). In other words, it is unreadable. Moreover, when you want to access the documentation (reusing your example)\n\n```\nsage: F = FiniteUnion([GF(2), GF(3)])\nsage: F.is_finite?\n```\nyou get something that you do not want to see here.\n\n2) the speed\n\n```\nsage: %timeit F.is_finite()\n10000 loops, best of 3: 27.2 us per loop\n```\njust to compare\n\n```\nsage: class P:\n....:     def is_finite(self):\n....:         return True\nsage: p = P()\nsage: %timeit p.is_finite()\n1000000 loops, best of 3: 218 ns per loop\n```\nwhich is how `is_finite` should be implemented for a finite set.",
    "created_at": "2013-07-09T07:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12920#issuecomment-182565",
    "user": "https://github.com/videlec"
}
```

<a id='comment:6'></a>
Needs to rebase on 5-11.beta3 (reject on unittest.py).

The patch may definitely be useful. There are two things that I dislike.

1) When you add the decorator the code does not correspond anymore to a is_X method (it does not return a boolean but raise an error or return a refined category). In other words, it is unreadable. Moreover, when you want to access the documentation (reusing your example)

```
sage: F = FiniteUnion([GF(2), GF(3)])
sage: F.is_finite?
```
you get something that you do not want to see here.

2) the speed

```
sage: %timeit F.is_finite()
10000 loops, best of 3: 27.2 us per loop
```
just to compare

```
sage: class P:
....:     def is_finite(self):
....:         return True
sage: p = P()
sage: %timeit p.is_finite()
1000000 loops, best of 3: 218 ns per loop
```
which is how `is_finite` should be implemented for a finite set.



---

archive/issue_events_040806.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40806"
}
```



---

archive/issue_events_040807.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40807"
}
```



---

archive/issue_events_040808.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40808"
}
```



---

archive/issue_events_040809.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40809"
}
```



---

archive/issue_events_040810.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40810"
}
```



---

archive/issue_events_040811.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40811"
}
```



---

archive/issue_events_040812.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40812"
}
```



---

archive/issue_events_040813.json:
```json
{
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "label": "component: doctest framework",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40813"
}
```



---

archive/issue_events_040814.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-01-24T09:31:33Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40814"
}
```



---

archive/issue_events_040815.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-01-24T09:31:33Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "milestone": "sage-7.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40815"
}
```



---

archive/issue_events_040816.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/12920",
    "rename": {
        "from": "Decorators for sharing code between is_bar and _test_bar methods.",
        "to": "Testsuite: allow sharing code between is_bar and _test_bar methods"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12920#event-40816"
}
```
