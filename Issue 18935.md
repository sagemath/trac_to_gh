# Issue 18935: More capable method `valuation` for polynomials

Issue created by migration from Trac.

Original creator: bruno

Original creation time: 2015-09-09 09:33:30

This ticket aims at improving the method `valuation` for polynomials in two ways:

1. The method `valuation` for dense polynomials can be called in the following ways:
  * Without argument, return the largest power of the variable that divides the input polynomial.
  * With a polynomial (with the same parent) as argument, return the largest power of this polynomial which divides the input polynomial.

  I propose to allow another possible argument: If the argument is an element of the base ring of the parent, it returns the minimum of the valuations of the arguments. This is consistent with PARI.

2. The method `valuation` for sparse polynomials is much less capable than the method for dense polynomials. I propose to have the same behaviors in both cases.


---

Comment by git created at 2016-06-10 13:44:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-07-25 14:18:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bruno created at 2017-07-25 14:18:52

Changing status from new to needs_review.


---

Comment by bruno created at 2017-07-25 14:19:15

Changing keywords from "" to "polynomial".


---

Comment by mmezzarobba created at 2017-07-27 10:11:36


```
sage: R.<x,y,z> = ZZ[]
sage: p = 4*x*y + z^2 - 9*x + 39*z
sage: p.valuation(-2)
...
ValueError: You can only compute the valuation with respect to a integer larger than 1.
```



```
sage: R.<x,y,z> = QQ[]
sage: p = 4*x*y + z^2 - 9*x + 39*z
sage: p.valuation(1/2)
...
TypeError: no conversion of this rational to integer
```



---

Comment by mmezzarobba created at 2017-07-27 14:04:46

I would be tempted to simplify the version in `multi_polynomial.pyx` roughly as follows (not tested!):

```
        if arg is None:
            ex = self.exponents()
            return tuple(min(e[i] for e in ex) for i in range(self.nvariables()))

        arg = self.parent().coerce(arg)

        if arg.is_constant():
            arg = arg.constant_coefficient()
            return min(c.valuation(arg) for c in self.coefficients())

        try:
            ind = self.parent().gens().index(arg)
        except ValueError:
            pass
        else:
            return min(e[ind] for e in self.exponents())

        if arg.nvariables() == 1:
            return self.polynomial(arg.variable(0)).valuation()

        k = 0
        tmp = arg
        while tmp.divides(self):
            k += 1
            tmp *= arg
        return k
```


Also, I wonder if actually performing the exact division (and replacing self with the quotient) at each loop turn wouldn't be better, but this is generic code any case, I don't think that it matters much.


---

Comment by SimonKing created at 2019-07-26 08:04:36

The pyflakes plugin rightfully complains about the fact that in this changeset

```diff
`@``@` -200,9 +200,17 `@``@` class Polynomial_generic_sparse(Polynomial):
             sage: R(0).valuation()
             +Infinity
         """
-        if not self.__coeffs:
+        if not self:
             return infinity
-        return ZZ(min(self.__coeffs))
+
+        if p is infinity:
+            return -self.degree()
+
+        if p is None:
+            c = self.__coeffs.keys()
+            return ZZ(min(self.__coeffs.keys()))
+
+        return Polynomial.valuation(self, p)
 
```

the variable `c` is defined but not used. In fact, the corresponding line can just be deleted. I can do it as a reviewer patch. Since the tests pass for the patchbots, I can then see if I give it a positive review (need to look more closely at the code first).


---

Comment by SimonKing created at 2019-07-26 08:14:51

Also I was told by Vincent Delecroix that it would be better (since this is a rather old ticket based on a very old branch) to rebase it on top of the latest develop (not merging develop, he said).


---

Comment by SimonKing created at 2019-07-26 08:24:48

The first commit that is shown for the branch of this ticket is named `#19171: New method divides`.

Do I understand correctly that this commit was originally intended for #19171, but didn't get merged after all? So, my review will about this one as well.

EDIT: It is rather strange that the topic of #19171 was "Add a method 'divide' to Polynomial", and the commit adding the "New method divides" was not merged.


---

Comment by SimonKing created at 2019-07-26 08:33:24

Not good. When trying to rebase on top of develop, there is a merge conflict with the commit from #19171


---

Comment by SimonKing created at 2019-07-26 09:23:52

What I am trying now is whether the suspicious commit is needed at all.


---

Comment by SimonKing created at 2019-07-26 09:35:06

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2019-07-26 09:35:06

Sorry, it gets too complicated. Leaving out the [commit named "#19171: New method divides"](https://git.sagemath.org/sage.git/commit/?h=9a548adcf9a998a78254ba98df730b1311e9d559&id=9a189c7bdc29953d6ada184f7b0db503c6da4677) didn't solve the problem, as the second commit didn't merge either.

So, I think I will not continue to try and rebase it, and I'd appreciate if the author did.


---

Comment by git created at 2019-08-21 12:22:32

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by bruno created at 2019-08-21 12:28:15

Changing status from needs_work to needs_review.


---

Comment by bruno created at 2019-08-21 12:28:15

Hi Simon, I've rebased on develop. It should be OK now.


---

Comment by SimonKing created at 2019-08-21 13:00:44

Replying to [ticket:19172 bruno]:
>   I propose to allow another possible argument: If the argument is an element of the base ring of the parent, it returns the minimum of the valuations of the arguments. This is consistent with PARI.

I don't understand what that specification means. Valuation has two arguments, namely `self` and `arg` resp. `p`. So, if the argument (`p`?) is an element of the base ring of "the parent" (the parent of `self`?) then it returns the minimum of the valuations of the arguments (i.e., of `self` and of `p` --- but with respect to what shall the valuation of `self` be taken? And what do you do if the base ring of the parent does not support a valuation, so that the valuation of `p` is not defined?).
I am sure you mean something else, but this is what I understood from your specification.


---

Comment by bruno created at 2019-08-21 13:47:07

Replying to [comment:16 SimonKing]:
> Replying to [ticket:19172 bruno]:
> >   I propose to allow another possible argument: If the argument is an element of the base ring of the parent, it returns the minimum of the valuations of the arguments. This is consistent with PARI.
> 
> I don't understand what that specification means. Valuation has two arguments, namely `self` and `arg` resp. `p`. So, if the argument (`p`?) is an element of the base ring of "the parent" (the parent of `self`?) then it returns the minimum of the valuations of the arguments (i.e., of `self` and of `p` --- but with respect to what shall the valuation of `self` be taken? And what do you do if the base ring of the parent does not support a valuation, so that the valuation of `p` is not defined?).
> I am sure you mean something else, but this is what I understood from your specification.
>  

There was a typo: I meant "it returns the minimum of the valuations of the coefficients." So it means that if `self` is a polynomial over a ring `R` and `p` is an element of `R`, `self.valuation(p)` computes for each coefficient of `self` its valuation with respect to `p` and returns the minimum of these values. This is very convenient when working over `QQ['x']['y']` and asking the valuation with respect to `'x'`, or even over `ZZ['x']` and asking for the valuation with respect to any prime number.

Of course, this implies that the base ring must have a method `valuation`. The ticket is rather old so I don't have everything fresh in my memory, but do we have examples of rings that do not have such a method?


---

Comment by tscrim created at 2021-05-13 02:59:04

If you wanted to do some micro-optimizations, you can do:

```diff
               raise NotImplementedError
 
+       P = parent(p) # the function from sage.structure.element is faster
+
-       if is_FractionField(p.parent()):
+       if is_FractionField(P):
             if p.denominator().is_unit():
                 p = p.numerator()
+                P = parent(p)
             else:
                 raise TypeError("The denominator should be a unit.")
 
-        if self.base_ring().has_coerce_map_from(p.parent()):
-            return min(c.valuation(p) for c in self.coefficients())
+        if self._parent._base.has_coerce_map_from(P):
+            return min(self.get_unsafe(k).valuation(p)
+                       for k in range(self.degree()+1)
+                       if self.get_unsafe(k))
 
-        elif self.parent().has_coerce_map_from(p.parent()):
-            p = self.parent().coerce(p)
+        elif self._parent.has_coerce_map_from(P):
+            p = self._parent.coerce(p)
             k = 0
             while p.divides(self):
                 k += 1
-                self = self.__floordiv__(p)
+                self = self._floordiv_(p)  # Same parent
```

----
New commits:


---

Comment by git created at 2021-05-13 04:22:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2021-05-16 21:18:57

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2021-05-16 21:18:57

What is intended for the corner cases

```
sage: ZZ['x'].gen().valuation(1)
sage: ZZ['x'].zero().valuation(0)
sage: ZZ['x'].zero().valuation(1)
```

(the code is not careful enough: min of empty sequence or infinite loop)

The above must appear in doctests.


---

Comment by vdelecroix created at 2021-05-16 21:20:50

The following `if arg not in self.parent()` is not a good idea as the method `__contains__` is not supposed to be useful in any meaningful way. You could replace the whole block

```
        if arg not in self.parent():
            if self.parent().has_coerce_map_from(arg.parent()):
                arg = self.parent()(arg)
            else:
                raise TypeError("The parent of the polynomial {} is not {}".format(arg,self.parent()))
```

by the one line

```
arg = self.parent().coerce(arg)
```



---

Comment by vdelecroix created at 2021-05-16 21:21:31

Similarly, `if arg in self.base_ring():` is not good

```
sage: QQ.one() in ZZ
True
```



---

Comment by vdelecroix created at 2021-05-16 21:27:40

For multivariate polynomials why not use the simpler template

```
if arg is None:
   ...

arg = parent.coerce(arg)
if arg.is_zero():
    ...
elif self.is_zero():
    ...
elif arg.is_constant():
    ...
elif arg.is_generator():
    ...
# etc 
```

