# Issue 34185: implement functorial composition of lazy symmetric functiosn

Issue created by migration from https://trac.sagemath.org/ticket/34422

Original creator: mantepse

Original creation time: 2022-08-24 13:28:31

CC:  tscrim




---

Comment by mantepse created at 2022-08-24 13:33:07

Changing keywords from "" to "LazyPowerSeries".


---

Comment by mantepse created at 2022-08-24 13:51:25

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2022-08-24 13:51:25

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2022-08-24 13:51:25

Last 10 new commits:


---

Comment by git created at 2022-08-24 21:00:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-24 21:03:28

I have no idea whether this operation has a good interpretation on the representation theoretic level.


---

Comment by mantepse created at 2022-08-24 21:03:28

Changing status from new to needs_review.


---

Comment by tscrim created at 2022-08-25 00:23:07

I am not sure either. Although it would be nice to (also) have an explanation not in terms of species of what the code does.

Additionally:

```diff
     def functorial_composition(self, *args):
-        r"""Returns the functorial composition of ``self`` and ``g``.
+        r"""
+        Return the functorial composition of ``self`` and ``g``.
```



---

Comment by git created at 2022-08-30 12:09:44

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mantepse created at 2022-08-30 12:10:16

Replying to [comment:5 mantepse]:
> I have no idea whether this operation has a good interpretation on the representation theoretic level.

That was a somewhat silly statement, please excuse me, since the operation is built around a representation theoretic construction, and this construction is even described in the docstring.

So, a better question is how functorial composition relates to other operations with symmetric functions.  I do not have an answer.


---

Comment by mantepse created at 2022-08-30 12:10:36

Changing status from needs_review to needs_work.


---

Comment by mantepse created at 2022-08-30 13:46:04

Replying to [comment:8 mantepse]:
> Replying to [comment:5 mantepse]:
> > I have no idea whether this operation has a good interpretation on the representation theoretic level.
> 
> That was a somewhat silly statement, please excuse me, since the operation is built around a representation theoretic construction, and this construction is even described in the docstring.
> 
> So, a better question is how functorial composition relates to other operations with symmetric functions.  I do not have an answer.

I just realised that the functorial composition `f.functorial_composition(g)` is (at least by Begeron-Labelle-Leroux and Décoste-Labelle-Leroux) only defined for symmetric functions `g` which correspond to a permutation representation, i.e., a group action.

This does not have anything to do with the currently failing doctest, which I still have to fix.


---

Comment by git created at 2022-08-30 14:43:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-08-30 14:44:21

ready for review.


---

Comment by mantepse created at 2022-08-30 14:44:21

Changing status from needs_work to needs_review.


---

Comment by git created at 2022-08-30 14:55:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-31 01:23:21

If it cannot be described as an operation just on symmetric functions, then that is indicating that it probably should not be here but only in the species code that uses the lazy symmetric functions.

You're assuming `g` is a lazy symmetric function but you are allowed usual symmetric functions as input.

It took me a while to see that the `Stream_map_coefficients` is not passing the lambda function `lambda x: x, m`... Although it is still converting over the zeros. I think this could be made slightly faster by

```diff
-            g = Stream_map_coefficients(g._coeff_stream, lambda x: x, p)
-            f = Stream_map_coefficients(self._coeff_stream, lambda x: x, p)
+            sR = self.parent()._laurent_poly_ring
+            g = Stream_map_coefficients(g._coeff_stream, p, R)
+            f = Stream_map_coefficients(self._coeff_stream, p, sR)
```



```diff
-g_u = g[u.size()]
+g_u = g[sum(u)]
+g_u = g[sum(u._list)]  # or even faster, but less encapsulation
```

(I know it is much better OOP to do what you had, but Python is so slow...)

Wouldn't floor division `//` be better than usual division `/` in `g_cycle_type()`?


```diff
-res = p(0)
+res = p.zero()
```


Instead of `Partition(foo)`, you can use `_Partitions(foo)` to skip a few steps.

Trivial detail, this double blank line looked weird to my eye:

```diff
         labellings of their vertices with two 1's and two 2's.
-
 
         The derivative of the symmetric function `\sum_n h_n`, times
         `p_1` is the neutral element with respect to functorial
         composition::
```



---

Comment by mantepse created at 2022-08-31 21:06:18

I agree that we could also move functorial composition to the species generating functions code, I am not completely sure what is better.  Here is the precise representation theoretic description:

Let `S_n` be the group of permutations of `{1,...,n}` and, for a finite set `X`, let `S_X` be the group of permutations of `X`.

Let `f_n: S_n -> GL(V_n)` be a sequence of representations of the symmetric groups and let `g_n: S_n -> S_{X_n}` be a sequence of group actions (also known as permutation representations of the symmetric groups).  Then their 'functorial composition' is the sequence of representations `f_{X_n} o g_n: S_n -> GL(V_{|X_n|})`.

I have no idea whether this is interesting enough to warrant inclusion in `LazySymmetricFunction`.  It does enjoy some nice properties:

*  `h_1 sum_{k >= 0} h_k` is a right neutral element, and if `F` corresponds to a group action, also a left neutral element.
* `(F1 + F2).functorial_composition(G) = F1.functorial_composition(G) + F2.functorial_composition(G)`.
* `(F1 x F2).functorial_composition(G) = F1.functorial_composition(G) x F2.functorial_composition(G)`, where `x` denotes the Hadamard (or inner tensor) product of sequences of representations.

If we do *not* want to have it as a method of `LazySymmetricFunction` I need some technical help: unfortunately I made this ticket an unnecessary dependency of #34423.  However, I can only move it into `species/generating_series.py` once `LazyPowerSeries` is gone.  How can I `rebase` #34423 on #34413 (or even better, on #34383)?


---

Comment by tscrim created at 2022-09-01 10:11:38

Thank you for the explanation. I am guessing you are taking the Frobenius map on these symmetric group actions/representations to get symmetric functions?

Since you can implement it in `LazySymmetricFunctions`, then it probably should go there. I think we just need to do a reverse-engineering of sorts of the code into documentation. I guess if we are using the Frobenius map, then we can describe things in terms of power sums (and extend by properties you’ve given?).

Is there some way to tell if a lazy Symmetric function `F` corresponds to a group action? Does this just mean all of the coefficients are nonnegative integers in the Schur (or powersum?) basis?


---

Comment by mantepse created at 2022-09-01 10:50:55

Below is more information, in case you are interested.  However, punchline is that we agree.

Yes, to go from the representation to the symmetric function we take the Frobenius map, which is called cycle index series in species jargon.

I don't see any sensible way to extend the functorial composition even to representations (i.e., sums of Schur functions with nonnegative coefficients) in the second argument.  The first argument can be any symmetric function over any ring, however.

If you live in the symmetric function world, it may be a bit surprising that the functorial composition is well defined, although it is not hard to see.  However, if you live in the species world, this is completely obvious.

Finally: I don't know of a good way to check whether a symmetric function corresponds to a group action.  If it is Schur-non-negative, we have a representation, so this is necessary.  Also, it must be powersum-non-negative.  But this is not sufficient.  Per Alexandersson and Nima Amini have a charaterisation for group actions of _cyclic groups_.  It is very likely possible to do the same for group actions of the symmetric group.  In fact, you could simply check whether your character is a character in the Burnside ring, but this will be horribly inefficient.


---

Comment by git created at 2022-09-01 12:13:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-01 12:13:46

Sorry for the merge.


---

Comment by git created at 2022-09-01 12:23:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-01 12:40:40

Replying to [comment:17 mantepse]:
> I don't see any sensible way to extend the functorial composition even to representations (i.e., sums of Schur functions with nonnegative coefficients) in the second argument.  The first argument can be any symmetric function over any ring, however.

This is confusing me a bit. Are there some restrictions on the input for this to be defined? If we are indeed limited on the inputs, then we definitely need to move this to the species code.

For the technical help, there are a few ways out of this. One is to create a new branch for the later ticket based on the new dependency and and just cherry-pick the requisite commits. Second would be a more technical rebase using the `-i` option. A third option is the most hacks where we just move the code on the replacement ticket.

> If you live in the symmetric function world, it may be a bit surprising that the functorial composition is well defined, although it is not hard to see.  However, if you live in the species world, this is completely obvious.

In particular, it seems to conflict with this statement. My take on this is that it works for any pair of inputs.

> Finally: I don't know of a good way to check whether a symmetric function corresponds to a group action.  If it is Schur-non-negative, we have a representation, so this is necessary.  Also, it must be powersum-non-negative.  But this is not sufficient.  Per Alexandersson and Nima Amini have a charaterisation for group actions of _cyclic groups_.  It is very likely possible to do the same for group actions of the symmetric group.  In fact, you could simply check whether your character is a character in the Burnside ring, but this will be horribly inefficient.

We can at least do a culling for the “easy” check of Schur and powersum positivity. We can just then say anything beyond that, it is up to the user to make sure it is valid input (maybe with an example with the code on how to check).


---

Comment by mantepse created at 2022-09-01 12:50:17

There is absolutely no restriction on `self`.  The restriction on `g` is, that it must be the Frobenius character of a (sequence of) group actions.  The resulting Frobenius character is then well defined.

If `F` happens to be a formal sum (over any coefficient ring) of group actions, and `G` is a sequences of (true) group actions, the functorial composition is even well defined as a formal sum of group action.

I am quite sure that there are other examples of methods where `self` is any member of the class but the other arguments must satisfy some conditions.

> We can at least do a culling for the “easy” check of Schur and powersum positivity. We can just then say anything beyond that, it is up to the user to make sure it is valid input (maybe with an example with the code on how to check). 

Even checking for Schur positivity may be extremely time consuming.  But I can check whether there are other easy checks (there should be).

I am currently investigating a performance issue.


---

Comment by tscrim created at 2022-09-01 12:57:59

Maybe it is okay here since we are giving this a basically symmetric-functions-only description (up to being able to make it precise when it will work, but that is not so serious) and the more I think about it, the less I am convinced by my justifications.

Indeed, you’re right that we can impose conditions on the inputs (including `self`) for certain methods. That was a weak argument in general; I was thinking it highlighted more than it does that we should be working with species.

Since we are converting to the powersums anyways, we can check positivity there at least. I agree that the Schur positivity check is less important and can be skipped for speed.


---

Comment by mantepse created at 2022-09-01 15:08:52

There are indeed a few obvious checks, but the code is tricky enough so that I first want to make sure I have a few good tests.

Here is a first summary:

* For a partition `s` of `n`, all partitions `t = g_cycle_type(n)` should have the same size, which should be the number of elements in `G[n]`, which is `n!` times the coefficient of `p[1,...,1]` in the Frobenius character of `G`. Therefore, `f_t = f[t.size()]` is only a single computation, and if `not f_t`,  we can return immediately.

* the main issue is that we are potentially computing very large coefficients of `self`, and there is no way around that.

* I am guessing that using `p.element_class(p, terms)` would save some time.


---

Comment by git created at 2022-09-01 21:45:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-01 21:52:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-09-01 21:53:36

Ready!


---

Comment by tscrim created at 2022-09-01 23:19:08

Thanks. Onto the next ticket.


---

Comment by tscrim created at 2022-09-01 23:19:08

Changing status from needs_review to positive_review.


---

Comment by git created at 2022-09-26 10:18:06

Changing status from positive_review to needs_review.


---

Comment by git created at 2022-09-26 10:18:06

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by mantepse created at 2022-09-26 10:20:25

trivial (automatic) merge, necessary to make the patchbots happy.


---

Comment by mantepse created at 2022-09-26 10:20:25

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-09-29 21:02:34

Resolution: fixed
