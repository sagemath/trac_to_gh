# Issue 11706: Proper implementation of quotients of g-algebras

archive/issues_011706.json:
```json
{
    "body": "Assignee: AlexGhitza\n\nCC:  burcin saliola mhansen alexanderdreyer oleksandrmotsak polybori malb\n\nKeywords: g-algebra Singular quotient\n\nThe wrapper at #4539 originally tried to use Singular for computations in quotients of g-algebras. But for some reasons it did not work, and thus it was decided to temporarily use generic quotient rings, so that the ticket can be merged.\n\nThe purpose here is to use rings constructed by Singular from a \"ring list\", which should provide a more efficient implementation.\n\nIssue created by migration from https://trac.sagemath.org/ticket/11878\n\n",
    "created_at": "2011-09-30T09:33:37Z",
    "labels": [
        "algebra",
        "major",
        "enhancement"
    ],
    "title": "Proper implementation of quotients of g-algebras",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11706",
    "user": "SimonKing"
}
```
Assignee: AlexGhitza

CC:  burcin saliola mhansen alexanderdreyer oleksandrmotsak polybori malb

Keywords: g-algebra Singular quotient

The wrapper at #4539 originally tried to use Singular for computations in quotients of g-algebras. But for some reasons it did not work, and thus it was decided to temporarily use generic quotient rings, so that the ticket can be merged.

The purpose here is to use rings constructed by Singular from a "ring list", which should provide a more efficient implementation.

Issue created by migration from https://trac.sagemath.org/ticket/11878





---

archive/issue_comments_132449.json:
```json
{
    "body": "It turns out that the code for the quotients from #4539 did not work properly, because comparison of elements of g-algebras did not take into account the relations.",
    "created_at": "2011-09-30T09:51:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11706",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11706#issuecomment-132449",
    "user": "SimonKing"
}
```

It turns out that the code for the quotients from #4539 did not work properly, because comparison of elements of g-algebras did not take into account the relations.



---

archive/issue_comments_132450.json:
```json
{
    "body": "I have a question, and probably Oleksandr knows the answer:\n\nAssume we are in a quotient ring Q (not sca) in Singular. As we know, the normal form of a polynomial p with respect to the defining ideal of the quotient ring is not automatically computed. But it can be obtained by NF(p,std(0)).\n\nI tried to create a Gr\u00f6bner strategy object G for the zero ideal in Q. However, G.normal_form(p) did *not* reduce p. G.normal_form relies on the function `redNF`, I guess from Singular's `kstd2.cc`. \n\nIs `redNF` the wrong thing to use in quotient rings? I see that `redNF` accepts several arguments, that seem to be undocumented (like many functions in Singular). Do I simply have to choose other arguments? Is it possible to obtain reduction with respect to the defining ideal of a quotient ring by using a Gr\u00f6bner strategy object, or is that the wrong approach?\n\nI found another function `kNF2` in `kstd2.cc`, which seems to have an argument for the defining ideal of a quotient ring; should I use this? Would the result be tail reduced? I am afraid it would be less efficient than using a fixed Gr\u00f6bner strategy, but perhaps that's the only way.\n\nOr, positively asked: What Singular function called from NF is responsible for the reduction of quotient ring elements?",
    "created_at": "2011-10-03T18:28:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11706",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11706#issuecomment-132450",
    "user": "SimonKing"
}
```

I have a question, and probably Oleksandr knows the answer:

Assume we are in a quotient ring Q (not sca) in Singular. As we know, the normal form of a polynomial p with respect to the defining ideal of the quotient ring is not automatically computed. But it can be obtained by NF(p,std(0)).

I tried to create a Gröbner strategy object G for the zero ideal in Q. However, G.normal_form(p) did *not* reduce p. G.normal_form relies on the function `redNF`, I guess from Singular's `kstd2.cc`. 

Is `redNF` the wrong thing to use in quotient rings? I see that `redNF` accepts several arguments, that seem to be undocumented (like many functions in Singular). Do I simply have to choose other arguments? Is it possible to obtain reduction with respect to the defining ideal of a quotient ring by using a Gröbner strategy object, or is that the wrong approach?

I found another function `kNF2` in `kstd2.cc`, which seems to have an argument for the defining ideal of a quotient ring; should I use this? Would the result be tail reduced? I am afraid it would be less efficient than using a fixed Gröbner strategy, but perhaps that's the only way.

Or, positively asked: What Singular function called from NF is responsible for the reduction of quotient ring elements?



---

archive/issue_comments_132451.json:
```json
{
    "body": "I think I start to understand. The function `initS` initialises a Gr\u00f6bner strategy in Singular, and in principle it can take an argument for the defining ideal of a quotient ring. However, it is currently used in the form `initS(i, NULL, self._strat)`, hence, the defining ideal is `NULL`. So, that's where the fix should happen.",
    "created_at": "2011-10-03T19:39:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11706",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11706#issuecomment-132451",
    "user": "SimonKing"
}
```

I think I start to understand. The function `initS` initialises a Gröbner strategy in Singular, and in principle it can take an argument for the defining ideal of a quotient ring. However, it is currently used in the form `initS(i, NULL, self._strat)`, hence, the defining ideal is `NULL`. So, that's where the fix should happen.



---

archive/issue_comments_132452.json:
```json
{
    "body": "I broadened the purpose of the ticket: Implementing quotients of multivariate polynomial rings via Singular should be just as easy as implementing quotients of g-algebras via Plural.\n\nThere is a design problem for the elements, though. I see three approaches:\n\n1. Have a single class of elements for quotients and non-quotients. Do a reduction with respect to the modulus (if there is any) when comparing, hashing or printing elements.\n2. Have two separate classes, essentially copying the old `MPolynomial_libsingular`  class for creating a `NCPolynomial_plural` class. The change would mainly amount to replacing the strings `MP` and `_libsingular` by `NCP` and `_plural`, respectively.\n3. Have two separate classes, but avoid code-duplication. For this to work, one needs to modify the arithmetic methods of `MPolynomial_libsingular`, such that for example `left._add_(right)` does not return a new instance of  `MPolynomial_libsingular`, but a new instance of  `left.__class__`.\n\nAll three approaches have disadvantages: The first approach may slow down the arithmetic of polynomials, since any call to hash, repr and cmp would involve a test whether the parent is a quotient ring. The second would imply a massive code duplication. The third may, again, slow down arithmetic, since (as in the first approach) arithmetic is spoiled by additional tests.\n\nModern editors are capable to copy-and-paste, and I prefer speed. Thus, I'll go for the second approach, unless one of you objects.",
    "created_at": "2011-10-04T06:45:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11706",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11706#issuecomment-132452",
    "user": "SimonKing"
}
```

I broadened the purpose of the ticket: Implementing quotients of multivariate polynomial rings via Singular should be just as easy as implementing quotients of g-algebras via Plural.

There is a design problem for the elements, though. I see three approaches:

1. Have a single class of elements for quotients and non-quotients. Do a reduction with respect to the modulus (if there is any) when comparing, hashing or printing elements.
2. Have two separate classes, essentially copying the old `MPolynomial_libsingular`  class for creating a `NCPolynomial_plural` class. The change would mainly amount to replacing the strings `MP` and `_libsingular` by `NCP` and `_plural`, respectively.
3. Have two separate classes, but avoid code-duplication. For this to work, one needs to modify the arithmetic methods of `MPolynomial_libsingular`, such that for example `left._add_(right)` does not return a new instance of  `MPolynomial_libsingular`, but a new instance of  `left.__class__`.

All three approaches have disadvantages: The first approach may slow down the arithmetic of polynomials, since any call to hash, repr and cmp would involve a test whether the parent is a quotient ring. The second would imply a massive code duplication. The third may, again, slow down arithmetic, since (as in the first approach) arithmetic is spoiled by additional tests.

Modern editors are capable to copy-and-paste, and I prefer speed. Thus, I'll go for the second approach, unless one of you objects.



---

archive/issue_comments_132453.json:
```json
{
    "body": "If one goes for the second approach, one should use the occasion and refactor the code of `sage.rings.polynomial.plural`, so that g-algebras and their elements will be defined in separate modules.",
    "created_at": "2011-10-04T06:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11706",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11706#issuecomment-132453",
    "user": "SimonKing"
}
```

If one goes for the second approach, one should use the occasion and refactor the code of `sage.rings.polynomial.plural`, so that g-algebras and their elements will be defined in separate modules.



---

archive/issue_comments_132454.json:
```json
{
    "body": "using\nSingulars `reduce` generated by `singular_function`\nshould automatically deal with the quotients and still sufficiently fast (for generation of rings). Of course, similarly to the usual case where we attach the GB to an ideal as strategy,\nwe can attach the quotient ideal here to the ring.\nDo not ask me about any internal Singular details at the moment.\nI suggest repairing things in a most clean way (and do a performant patch later).\nIn fact using the later patch, we might be again be faster than Singular itself (as we can eliminate the repeated initialization of the strat object).",
    "created_at": "2013-01-28T08:55:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11706",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11706#issuecomment-132454",
    "user": "PolyBoRi"
}
```

using
Singulars `reduce` generated by `singular_function`
should automatically deal with the quotients and still sufficiently fast (for generation of rings). Of course, similarly to the usual case where we attach the GB to an ideal as strategy,
we can attach the quotient ideal here to the ring.
Do not ask me about any internal Singular details at the moment.
I suggest repairing things in a most clean way (and do a performant patch later).
In fact using the later patch, we might be again be faster than Singular itself (as we can eliminate the repeated initialization of the strat object).
