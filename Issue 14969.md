# Issue 14969: Poset show should accept non-hashable or non-injective element labels

Issue created by migration from Trac.

Original creator: darij

Original creation time: 2013-09-18 04:35:28

CC:  jmantysalo vittucek

Keywords: combinat, show, plot, posets


```
sage: P = Poset({1: [2,3]})
sage: labs = {i: P.rank(i) for i in range(1, 4)}
sage: labs
{1: 0, 2: 1, 3: 1}
sage: P.show(element_labels=labs)
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
<ipython-input-38-dfd00191eb55> in <module>()
----> 1 P.show(element_labels=labs)

/home/darij/sage-5.12.beta5/local/lib/python2.7/site-packages/sage/combinat/posets/posets.pyc in show(self, label_elements, element_labels, vertex_size, vertex_colors, layout, **kwds)
   1440         """
   1441         self.plot(label_elements=label_elements, element_labels=element_labels,
-> 1442             vertex_size=vertex_size, vertex_colors=vertex_colors, layout=layout).show(**kwds)
   1443 
   1444     `@`combinatorial_map(name="to graph")

/home/darij/sage-5.12.beta5/local/lib/python2.7/site-packages/sage/combinat/posets/posets.pyc in plot(self, label_elements, element_labels, vertex_size, vertex_colors, layout, **kwds)
   1402             relabelling = dict((self(element), label)
   1403                                for (element, label) in element_labels.items())
-> 1404             graph = graph.relabel(relabelling, inplace = False)
   1405             if rank_function: # use the rank function to set the heights
   1406                 for i in self:

/home/darij/sage-5.12.beta5/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in relabel(self, perm, inplace, return_map, check_input, complete_partial_function)
  16208                               return_map= return_map,
  16209                               check_input = check_input,
> 16210                               complete_partial_function = complete_partial_function)
  16211 
  16212             if return_map:

/home/darij/sage-5.12.beta5/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in relabel(self, perm, inplace, return_map, check_input, complete_partial_function)
  16263         if check_input:
  16264             if len(set(perm.values())) < len(perm):
> 16265                 raise NotImplementedError("Non injective relabeling")
  16266 
  16267             for v in perm.iterkeys():

NotImplementedError: Non injective relabeling
```


I understand that this, along with the lack of support for non-hashable labels, is owed to the implementation, but IMHO this means that the implementation (via relabelling the poset before plotting it, rather than as one would expect via doing everything as if the labels weren't there and then introducing them at the very end) is bad. (Incidentally, I'm not even sure that the shape of the image doesn't depend on the labels -- in the examples I've checked it seems to not depend on them, but I don't trust the code very much.)

I am not the type of mathematician who gets any enlightenment out of pictures, but even I do need to use `show()` when I'm making a presentation. Issues like this harm the presentability of Sage code.


---

Comment by vittucek created at 2018-06-28 13:46:51

Changing keywords from "combinat, show, plot, posets" to "combinat, show, plot, posets, days94".


---

Comment by vittucek created at 2018-06-28 13:46:51

Changing status from new to needs_review.


---

Comment by tscrim created at 2018-06-28 14:23:38

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2018-06-28 14:23:38

I would do this as:

```sage
class ElementWithLabel:
    """
    Auxiliary class for showing Posets with non-ijective relabeling. 
    """
    def __init__(self, element, label):
        self.element = element
        self.label = label
        
    def _latex_(self):
        return latex(self.label)

    def __repr__(self):
        return repr(self.label)

    def __hash__(self):
        return hash(repr(self.label)) ^ hash(repr(self.element))
```

or something like that for the hash. It should not need a `__str__` because of the `__repr__`. Typically we use `repr` in Sage, but I don't care if that becomes a `str`.

Also, all methods need doctests.


---

Comment by vittucek created at 2018-06-28 15:00:31

I propose the following as it has saner behaviour:

```sage
class ElementWithLabel:
    """
    Auxiliary class for showing Posets with non-ijective relabeling. 
    """
    def __init__(self, element, label):
        self.element = element
        self.label = label
        
    def _latex_(self):
        return latex(self.label)
    
    def __str__(self):
        return str(self.label)

    def __repr__(self):
        return repr(self.label)
    
    def __hash__(self):
        return hash((hash(self.element), hash(self.label)))
    
    def __eq__(self, other):
        return self.element == other.element and self.label == other.label
```


It seems that this could be useful somewhere else as well. Is there some utility module where I could move this?

Replying to [comment:9 tscrim]:
> I would do this as:
> {{{#!sage
> class ElementWithLabel:
>     """
>     Auxiliary class for showing Posets with non-ijective relabeling. 
>     """
>     def __init__(self, element, label):
>         self.element = element
>         self.label = label
>         
>     def _latex_(self):
>         return latex(self.label)
> 
>     def __repr__(self):
>         return repr(self.label)
> 
>     def __hash__(self):
>         return hash(repr(self.label)) ^ hash(repr(self.element))
> }}}
> or something like that for the hash. It should not need a `__str__` because of the `__repr__`. Typically we use `repr` in Sage, but I don't care if that becomes a `str`.
> 
> Also, all methods need doctests.


---

Comment by tscrim created at 2018-06-28 15:08:06

That is a better hash, yes. Good catch about the `__eq__`, and you should also implement a `__ne__`. However, I still disagree about the `__str__` as it is overkill:

```
sage: class Foo(object):
....:     def __repr__(self):
....:         return "hi"
....:     
sage: str(Foo())
'hi'
sage: repr(Foo())
'hi'
```



---

Comment by git created at 2018-06-28 16:16:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vittucek created at 2018-06-28 16:17:37

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-06-29 08:23:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-29 17:18:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-07-01 06:59:07

It is better (safer) to always do:

```
sage: from sage.combinat.posets.posets import ElementWithLabel
```

Your `__ne__` is missing a blankline after `TESTS::`. Also, I didn't read your proposed hash close enough when you proposed it. I think a better one would be

```
return hash((repr(self.element), repr(self.label)))
```

Because your current version would not cover non-hashable labels. You also need to add a test for both of these two cases (non-hashable (e.g., mutable matrices) and non-injective labels).


---

Comment by @darijgr created at 2018-07-23 20:12:16

Changing keywords from "combinat, show, plot, posets, days94" to "combinat, show, plot, posets, days94, daysICERM2018".


---

Comment by @darijgr created at 2018-07-23 20:12:16

The branch I've just pushed fixes the above, but the following needs to be done:

* check that my two doctests actually look reasonably (I can't launch my png viewer currently);

* similarly modify the graph code (and doctest it too).
----
New commits:


---

Comment by git created at 2018-07-23 20:12:57

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-07-23 20:28:52

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @darijgr created at 2018-07-23 20:35:56

OK, it seems that the graph plot functionality doesn't even allow vertex labels. So it's not urgent. Once the functionality is there, we should be easily able to use the ElementWithLabel class to make them non-injective.


---

Comment by git created at 2018-07-24 13:42:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-24 22:02:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-25 01:05:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @darijgr created at 2018-07-25 01:08:43

LGTM.

![](https://pbs.twimg.com/media/DiWsOPgW4AAYTSD.jpg)

LGTY?


---

Comment by @darijgr created at 2018-07-25 01:11:55

Changing keywords from "combinat, show, plot, posets, days94, daysICERM2018" to "combinat, show, plot, posets, days94, sagedays@ICERM".


---

Comment by @darijgr created at 2018-07-25 01:12:25

Changing keywords from "combinat, show, plot, posets, days94, sagedays@ICERM" to "combinat, show, plot, posets, days94, sagedays@icerm".


---

Comment by vittucek created at 2018-07-25 14:50:11

LGTM :)

But patchbot is complaining and I don't know why.


---

Comment by git created at 2018-07-25 15:50:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-07-26 03:20:36

Two more small things (sorry!). The first is you should make `ElementWithLabel` a "new-style" class (inherit from `object`). Second, I thought a little bit more about the `__hash__`, the `self.element` should be guaranteed to be hashable. So I'm thinking we should just have

```
def __hash__(self):
    return hash(self.element)
```



---

Comment by git created at 2018-07-26 14:18:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vittucek created at 2018-07-26 14:21:36

I have actually run into some caching issues when it was just `hash(self.element)` so after discussion with Nicolas and Darij I reverted my patch to the current combinantion of hashes of element and label. I guess the best argument, which iirc came from Darij, is that we might want to have same posets but with different labels and so we need to take labels into account for equality testing and for hashing.


---

Comment by tscrim created at 2018-07-26 23:23:08

Since elements are both distinct and hashable since they are used for the vertices, adding the labels does not affect the equality or hashing. I guess since this is meant to be used in a more general setting, we do not have same guarantees on the elements. So this is fine. Just one little more change to simplify the hashing code (which is the "same" as the `repr` version):

```diff
-return hash((hash(self.element), hash(self.label)))
+return hash((self.element), self.label))
```



---

Comment by vittucek created at 2018-07-27 14:08:57

Say you want to create a poset with nonijective labels and plot it several times with different options (e.g. cover labels or vertex colors etc). In that case you want to do something like this `my_poset.relabel(lambda e: ElementWithLabel(e, my_label(e)))` If we hashed only `self.element` it could happen (see e.g. the test case with `WeylGroup.bruhat_poset`) that the new relabeled poset would have the same hash as the original poset and that would break things.


---

Comment by git created at 2018-07-27 14:13:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-07-27 14:36:47

It doesn't matter if the poset has the same hash, it is the equality that matters. It is a problem if and only if they are being considered as equal and getting different hashes. Can you give explicit code that is breaking if two posets are _not_ equal (isomorphic is okay) but have the same hash?


---

Comment by vittucek created at 2018-07-27 15:48:28


```sage
sage: from sage.misc.element_with_label import ElementWithLabel
sage: P1 = Poset({1:[2,3]})                                                                  
sage: P2 = Poset({ElementWithLabel(1, "a"): [ElementWithLabel(2, "b"), ElementWithLabel(3, "c")]})
```


With the current implementation (i.e. `hash((self.element, self.label))`) this works. If we did just `hash(self.element)` then we would get 

```sage
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-29-74e94a2baaf3> in <module>()
----> 1 P2 = Poset({ElementWithLabel(Integer(1), "a"): [ElementWithLabel(Integer(2), "b"), ElementWithLabel(Integer(3), "c")]})

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/combinat/posets/posets.pyc in Poset(data, element_labels, cover_relations, linear_extension, category, facade, key)
    745     else:
    746         elements = None
--> 747     return FinitePoset(D, elements=elements, category=category, facade=facade, key=key)
    748 
    749 

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1639)()
    327         """
    328         if cls.classcall is not None:
--> 329             return cls.classcall(cls, *args, **kwds)
    330         else:
    331             # Fast version of type.__call__(cls, *args, **kwds)

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/combinat/posets/posets.pyc in __classcall__(cls, hasse_diagram, elements, category, facade, key)
    964                                                      elements=elements,
    965                                                      category=category, facade=facade,
--> 966                                                      key=key)
    967 
    968     def __init__(self, hasse_diagram, elements, category, facade, key):

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6174)()
    998         try:
    999             try:
-> 1000                 return self.cache[k]
   1001             except TypeError:  # k is not hashable
   1002                 k = dict_key(k)

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3538)()
    704 
    705         """
--> 706         cdef PyObject* wr = PyDict_GetItemWithError(self, k)
    707         if wr == NULL:
    708             raise KeyError(k)

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/cpython/dict_del_by_value.pyx in sage.cpython.dict_del_by_value.PyDict_GetItemWithError (build/cythonized/sage/cpython/dict_del_by_value.c:1199)()
     56         cdef PyDictEntry* ep
     57         cdef PyDictObject* mp = <PyDictObject*><void *>op
---> 58         ep = mp.ma_lookup(mp, <PyObject*><void*>key, PyObject_Hash(key))
     59         if ep:
     60             return ep.me_value

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in __eq__(self, other)
    588                 return False
    589         # Vertices
--> 590         if any(x not in other for x in self):
    591             return False
    592         # Finally, we are prepared to check edges:

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in <genexpr>((x,))
    588                 return False
    589         # Vertices
--> 590         if any(x not in other for x in self):
    591             return False
    592         # Finally, we are prepared to check edges:

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in has_vertex(self, vertex)
   9263         except Exception:
   9264             return False
-> 9265         return self._backend.has_vertex(vertex)
   9266 
   9267     __contains__ = has_vertex

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/graphs/base/static_sparse_backend.pyx in sage.graphs.base.static_sparse_backend.StaticSparseBackend.has_vertex (build/cythonized/sage/graphs/base/static_sparse_backend.c:10628)()
    464             False
    465         """
--> 466         return v in self._vertex_to_int
    467 
    468     def relabel(self, perm, directed):

/home/vit/src/sage/local/lib/python2.7/site-packages/sage/misc/element_with_label.pyc in __eq__(self, other)
    147             True
    148         """
--> 149         return self.element == other.element and self.label == other.label
    150 
    151     def __ne__(self, other):

AttributeError: 'int' object has no attribute 'element'

```


If I remember correctly, what's going on is that the constructor of `FinitePoset`  looks into cache which has as keys `_hasse_diagram` and then it finds the `_hasse_diagram` of `P1` and just uses that which causes these problems (`self` is ElementWithLabel while `other` is `int` ... or the other way around).


---

Comment by @darijgr created at 2018-07-27 15:55:25

The hash space may be large, but I don't like the idea of relying on distinctness of hashes.


---

Comment by vittucek created at 2018-07-27 18:36:12

Replying to [comment:37 gh-darijgr]:
> The hash space may be large, but I don't like the idea of relying on distinctness of hashes.
Cnstructor of `Poset` could use some love [https://trac.sagemath.org/ticket/23825](https://trac.sagemath.org/ticket/23825)


---

Comment by tscrim created at 2018-07-27 21:05:02

The problem is not with posets but with the equality check:

```
sage: from sage.misc.element_with_label import ElementWithLabel
sage: 1 == ElementWithLabel(1, 'a')
# BOOM
```

Here is a fix for the `__eq__` (which I think is my fault for not caching it earlier as I thought this would only be compared internally). The example now works with the simplified hash.

If my changes are good, then I think we can set a positive review.
----
New commits:


---

Comment by tscrim created at 2018-08-05 21:49:47

ping?


---

Comment by git created at 2018-08-10 11:15:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-08-10 23:24:36

Actually, that `hash` output is almost certainly different on 32 and 64 bit machines. We probably want to change said test to `hash(a) == hash(a.element)`. Also the hash docstring is now incorrect (my fault).


---

Comment by git created at 2018-08-11 09:15:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vittucek created at 2018-08-17 11:04:11

Any idea why patchbot is not green?


---

Comment by tscrim created at 2018-08-17 11:10:41

Unrelated failures (you can consider it green).


---

Comment by tscrim created at 2018-08-27 02:09:24

Ping? (Now a clearly green patchbot.)


---

Comment by jmantysalo created at 2018-08-27 05:42:04

Seems to be a clear code. I can check this one later today.


---

Comment by jmantysalo created at 2018-08-27 11:29:58

Not sure who should be author and who should be reviewed, but at least the code works.

(Got a headache when comparing `vertex_labels` in graphs and `elements_labels` in posets, but that's another story.)


---

Comment by jmantysalo created at 2018-08-27 11:30:07

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-08-30 22:25:02

Resolution: fixed
