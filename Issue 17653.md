# Issue 17653: Remove _(rich)cmp_c_impl

archive/issues_017653.json:
```json
{
    "body": "CC:  @dkrenn\n\nInstead of\n\n```\n    def _cmp_(left, right)\n    cdef int _cmp_c_impl(left, right) except -2\n```\nwe should have\n\n```\n    cpdef int _cmp_(left, right) except -2\n```\n\nAnalogously for `_richcmp_`.\n\nThere is one important functional change: If a Python class defines both `__cmp__` and `_cmp_`, then formerly the coercion framework would use `__cmp__` by default to implement relational operators like `>=`. After this ticket, `_cmp_` will be tried first, which defaults to `__cmp__`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17890\n\n",
    "closed_at": "2015-04-29T03:13:44Z",
    "created_at": "2015-03-03T09:34:04Z",
    "labels": [
        "component: cython"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.7",
    "title": "Remove _(rich)cmp_c_impl",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17653",
    "user": "https://github.com/jdemeyer"
}
```
CC:  @dkrenn

Instead of

```
    def _cmp_(left, right)
    cdef int _cmp_c_impl(left, right) except -2
```
we should have

```
    cpdef int _cmp_(left, right) except -2
```

Analogously for `_richcmp_`.

There is one important functional change: If a Python class defines both `__cmp__` and `_cmp_`, then formerly the coercion framework would use `__cmp__` by default to implement relational operators like `>=`. After this ticket, `_cmp_` will be tried first, which defaults to `__cmp__`.

Issue created by migration from https://trac.sagemath.org/ticket/17890





---

archive/issue_comments_235549.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-03-03T22:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235549",
    "user": "https://github.com/jdemeyer"
}
```

New commits:



---

archive/issue_comments_235550.json:
```json
{
    "body": "If it is slower this is very bad. Do you know why? Isn't a `cdef` function call equivalent to `cpdef` function call?\n\nVincent",
    "created_at": "2015-03-04T09:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235550",
    "user": "https://github.com/videlec"
}
```

If it is slower this is very bad. Do you know why? Isn't a `cdef` function call equivalent to `cpdef` function call?

Vincent



---

archive/issue_comments_235551.json:
```json
{
    "body": "Replying to [comment:6 vdelecroix]:\n> If it is slower this is very bad. Do you know why?\n\nYes, see [https://groups.google.com/forum/#!topic/sage-devel/AXYk1uEfuPE](https://groups.google.com/forum/#!topic/sage-devel/AXYk1uEfuPE)",
    "created_at": "2015-03-04T11:09:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235551",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:6 vdelecroix]:
> If it is slower this is very bad. Do you know why?

Yes, see [https://groups.google.com/forum/#!topic/sage-devel/AXYk1uEfuPE](https://groups.google.com/forum/#!topic/sage-devel/AXYk1uEfuPE)



---

archive/issue_comments_235552.json:
```json
{
    "body": "Related: #10130.",
    "created_at": "2015-03-04T15:52:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235552",
    "user": "https://github.com/mezzarobba"
}
```

Related: #10130.



---

archive/issue_comments_235553.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-04T16:28:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235553",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_235554.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-05T10:42:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235554",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_235555.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-03-05T10:49:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235555",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_235556.json:
```json
{
    "body": "See also #16537",
    "created_at": "2015-03-06T07:34:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235556",
    "user": "https://github.com/videlec"
}
```

See also #16537



---

archive/issue_comments_235557.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-06T08:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235557",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_235558.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-13T17:20:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235558",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235559.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-04-16T09:44:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235559",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_235560.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-04-25T14:28:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235560",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_235561.json:
```json
{
    "body": "## sage.structure.element\n\n1. In the documentation of `sage.structure.element` emphasize what should be done for Python classes as well (and the potential difference between Python and Cython). It is not very clear to me! What I understood is that we should:\n   - implement `__cmp__(left,right)` or/and `_richcmp_(left,right,op)`\n   - avoid `__eq__`, `__ne__`, etc\n\n2. What about putting\n\n```\n# Obvious case\nif left is right:\n    return _rich_to_bool(op, 0)\n```\n  directly in `__richcmp__`?\n\n## sage.structure.parent\n\n3. The default comparison for parents is by id which is natural (and I guess what Python does). But the default hash is not based on id and is the stupid one inherited from `SageObject`. Is there a reason?\n\n4. Why not using `_rich_to_bool` in `parent.pyx` instead of\n\n```\nif op == 0:  #< \n    return r  < 0\nelif op == 2: #==\n    return r == 0 \nelif op == 4: #>\n    return r  > 0\nelif op == 1: #<=\n    return r <= 0\nelif op == 3: #!=\n    return r != 0\nelif op == 5: #>=\n    return r >= 0 \n```\n  And by the way, why is there a method `cdef _rich_to_bool` on element? it would be useful as a standalone function in other places.",
    "created_at": "2015-04-25T14:28:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235561",
    "user": "https://github.com/videlec"
}
```

## sage.structure.element

1. In the documentation of `sage.structure.element` emphasize what should be done for Python classes as well (and the potential difference between Python and Cython). It is not very clear to me! What I understood is that we should:
   - implement `__cmp__(left,right)` or/and `_richcmp_(left,right,op)`
   - avoid `__eq__`, `__ne__`, etc

2. What about putting

```
# Obvious case
if left is right:
    return _rich_to_bool(op, 0)
```
  directly in `__richcmp__`?

## sage.structure.parent

3. The default comparison for parents is by id which is natural (and I guess what Python does). But the default hash is not based on id and is the stupid one inherited from `SageObject`. Is there a reason?

4. Why not using `_rich_to_bool` in `parent.pyx` instead of

```
if op == 0:  #< 
    return r  < 0
elif op == 2: #==
    return r == 0 
elif op == 4: #>
    return r  > 0
elif op == 1: #<=
    return r <= 0
elif op == 3: #!=
    return r != 0
elif op == 5: #>=
    return r >= 0 
```
  And by the way, why is there a method `cdef _rich_to_bool` on element? it would be useful as a standalone function in other places.



---

archive/issue_comments_235562.json:
```json
{
    "body": "Replying to [comment:20 vdelecroix]:\n> == sage.structure.element ==\n> \n> 1. In the documentation of `sage.structure.element` emphasize what should be done for Python classes as well (and the potential difference between Python and Cython). It is not very clear to me!\n  \nUnfortunately, it is not very clear to me either. In particular, I don't find good Python documentation about the interaction between `__cmp__`, rich comparisons like `__eq__` and `__hash__` and what Python does when you call `cmp(x,y)`. It seems that `cmp(x,y)` only calls `x.__cmp__(y)` when `x` and `y` have the same type, but I don't find this anywhere documented. And I know that inheritance works in a strange way for comparisons, but I also don't quite know how.",
    "created_at": "2015-04-25T15:23:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235562",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:20 vdelecroix]:
> == sage.structure.element ==
> 
> 1. In the documentation of `sage.structure.element` emphasize what should be done for Python classes as well (and the potential difference between Python and Cython). It is not very clear to me!
  
Unfortunately, it is not very clear to me either. In particular, I don't find good Python documentation about the interaction between `__cmp__`, rich comparisons like `__eq__` and `__hash__` and what Python does when you call `cmp(x,y)`. It seems that `cmp(x,y)` only calls `x.__cmp__(y)` when `x` and `y` have the same type, but I don't find this anywhere documented. And I know that inheritance works in a strange way for comparisons, but I also don't quite know how.



---

archive/issue_comments_235563.json:
```json
{
    "body": "Replying to [comment:20 vdelecroix]:\n> 2. What about putting\n> \n> ```\n> # Obvious case\n> if left is right:\n>     return _rich_to_bool(op, 0)\n> ```\n>   directly in `__richcmp__`?\n\n\nBecause `__richcmp__` should absolutely be as simple as possible. Don't forget that *every subclass* needs a `__richcmp__` method (because of Python's strange inheritance rules regarding comparison).",
    "created_at": "2015-04-25T15:40:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235563",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:20 vdelecroix]:
> 2. What about putting
> 
> ```
> # Obvious case
> if left is right:
>     return _rich_to_bool(op, 0)
> ```
>   directly in `__richcmp__`?


Because `__richcmp__` should absolutely be as simple as possible. Don't forget that *every subclass* needs a `__richcmp__` method (because of Python's strange inheritance rules regarding comparison).



---

archive/issue_comments_235564.json:
```json
{
    "body": "Replying to [comment:20 vdelecroix]:\n> 3. The default comparison for parents is by id which is natural (and I guess what Python does). But the default hash is not based on id and is the stupid one inherited from `SageObject`. Is there a reason?\n  \nI don't know. This ticket doesn't change anything to hashing, so I consider this outside the scope of this ticket (but you might have a point though).",
    "created_at": "2015-04-25T15:45:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235564",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:20 vdelecroix]:
> 3. The default comparison for parents is by id which is natural (and I guess what Python does). But the default hash is not based on id and is the stupid one inherited from `SageObject`. Is there a reason?
  
I don't know. This ticket doesn't change anything to hashing, so I consider this outside the scope of this ticket (but you might have a point though).



---

archive/issue_comments_235565.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-25T20:38:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235565",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235566.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-25T20:46:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235566",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235567.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-04-25T20:47:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235567",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_235568.json:
```json
{
    "body": "OK, I improved `rich_to_bool` a lot.",
    "created_at": "2015-04-25T20:47:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235568",
    "user": "https://github.com/jdemeyer"
}
```

OK, I improved `rich_to_bool` a lot.



---

archive/issue_comments_235569.json:
```json
{
    "body": "I did some experimentations with Python classes. The conclusion is:\n\n     just define `_cmp_` and `_richcmp_` (even though you redefine `__hash__`)\n\nThen:\n- rich  comparisons and comparisons work when it involves elements with the same parent (i.e. the newly defined `_cmp_` and `_richcmp_` gets called)\n- rich comparisons involving coercion is fine\n- comparison involving coercion is **wrong**: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.\n\nActually, this is not only a bug in Python but also in Cython! I added print statement in each comparisons function in `Element` and see\n\n```\nsage: cmp(1,1/3)\nElement._richcmp(1,1/3,2)\nElement._richcmp(1,1/3,2)\nElement._richcmp_(1,1/3,2)\nElement._richcmp(1,1/3,0)\nElement._richcmp(1,1/3,0)\nElement._richcmp_(1,1/3,0)\nElement._richcmp(1,1/3,4)\nElement._richcmp(1,1/3,4)\nElement._richcmp_(1,1/3,4)\n1\n```\n\nVincent",
    "created_at": "2015-04-26T09:57:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235569",
    "user": "https://github.com/videlec"
}
```

I did some experimentations with Python classes. The conclusion is:

     just define `_cmp_` and `_richcmp_` (even though you redefine `__hash__`)

Then:
- rich  comparisons and comparisons work when it involves elements with the same parent (i.e. the newly defined `_cmp_` and `_richcmp_` gets called)
- rich comparisons involving coercion is fine
- comparison involving coercion is **wrong**: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.

Actually, this is not only a bug in Python but also in Cython! I added print statement in each comparisons function in `Element` and see

```
sage: cmp(1,1/3)
Element._richcmp(1,1/3,2)
Element._richcmp(1,1/3,2)
Element._richcmp_(1,1/3,2)
Element._richcmp(1,1/3,0)
Element._richcmp(1,1/3,0)
Element._richcmp_(1,1/3,0)
Element._richcmp(1,1/3,4)
Element._richcmp(1,1/3,4)
Element._richcmp_(1,1/3,4)
1
```

Vincent



---

archive/issue_comments_235570.json:
```json
{
    "body": "Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called! So the test in `Element._cmp` seems useless.",
    "created_at": "2015-04-26T10:03:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235570",
    "user": "https://github.com/videlec"
}
```

Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called! So the test in `Element._cmp` seems useless.



---

archive/issue_comments_235571.json:
```json
{
    "body": "Replying to [comment:28 vdelecroix]:\n> Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called! So the test in `Element._cmp` seems useless.\n\n\nExcept if you do not define `_richcmp_` and do some rich comparisons (this is the case in `sage.rings.qqbar.AlgebraicReal` for example).",
    "created_at": "2015-04-26T10:07:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235571",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:28 vdelecroix]:
> Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called! So the test in `Element._cmp` seems useless.


Except if you do not define `_richcmp_` and do some rich comparisons (this is the case in `sage.rings.qqbar.AlgebraicReal` for example).



---

archive/issue_comments_235572.json:
```json
{
    "body": "Replying to [comment:27 vdelecroix]:\n> - comparison involving coercion is **wrong**: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.\n> \n> Actually, this is not only a bug in Python\n\nBug or feature?",
    "created_at": "2015-04-26T10:33:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235572",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:27 vdelecroix]:
> - comparison involving coercion is **wrong**: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.
> 
> Actually, this is not only a bug in Python

Bug or feature?



---

archive/issue_comments_235573.json:
```json
{
    "body": "And implementing `_richcmp_` instead of `__cmp__` in `AlgebraicReal` I got an incredible speedup (see #18303).",
    "created_at": "2015-04-26T10:34:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235573",
    "user": "https://github.com/videlec"
}
```

And implementing `_richcmp_` instead of `__cmp__` in `AlgebraicReal` I got an incredible speedup (see #18303).



---

archive/issue_comments_235574.json:
```json
{
    "body": "Replying to [comment:28 vdelecroix]:\n> Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!\n\nOf course not, that's a general rule for inheritance.\n\n> So the test in `Element._cmp` seems useless.\n\nWhat do you mean?",
    "created_at": "2015-04-26T10:36:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235574",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:28 vdelecroix]:
> Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!

Of course not, that's a general rule for inheritance.

> So the test in `Element._cmp` seems useless.

What do you mean?



---

archive/issue_comments_235575.json:
```json
{
    "body": "Replying to [comment:32 jdemeyer]:\n> Replying to [comment:28 vdelecroix]:\n> > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!\n\n> Of course not, that's a general rule for inheritance.\n\nI thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?\n\n> > So the test in `Element._cmp` seems useless.\n\n> What do you mean?\n\nSorry, I forgot a `_`. I wanted to say `Element._cmp_`. The default implementation does check whether `__cmp__` is redefined in element classes. This code is called only if `__cmp__` is defined but not `_richcmp_`. And it seems much better to define `_richcmp_` in children classes.\n\nVincent",
    "created_at": "2015-04-26T10:40:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235575",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:32 jdemeyer]:
> Replying to [comment:28 vdelecroix]:
> > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!

> Of course not, that's a general rule for inheritance.

I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?

> > So the test in `Element._cmp` seems useless.

> What do you mean?

Sorry, I forgot a `_`. I wanted to say `Element._cmp_`. The default implementation does check whether `__cmp__` is redefined in element classes. This code is called only if `__cmp__` is defined but not `_richcmp_`. And it seems much better to define `_richcmp_` in children classes.

Vincent



---

archive/issue_comments_235576.json:
```json
{
    "body": "Replying to [comment:30 jdemeyer]:\n> Replying to [comment:27 vdelecroix]:\n> > - comparison involving coercion is **wrong**: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.\n> > \n> > Actually, this is not only a bug in Python\n\n> Bug or feature?\n\nCall it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!",
    "created_at": "2015-04-26T10:43:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235576",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:30 jdemeyer]:
> Replying to [comment:27 vdelecroix]:
> > - comparison involving coercion is **wrong**: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.
> > 
> > Actually, this is not only a bug in Python

> Bug or feature?

Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!



---

archive/issue_comments_235577.json:
```json
{
    "body": "Replying to [comment:34 vdelecroix]:\n> Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!\n\n\nI agree. Unfortunately this is general Python behaviour and not something this ticket can fix.",
    "created_at": "2015-04-26T10:44:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235577",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:34 vdelecroix]:
> Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!


I agree. Unfortunately this is general Python behaviour and not something this ticket can fix.



---

archive/issue_comments_235578.json:
```json
{
    "body": "Replying to [comment:33 vdelecroix]:\n> Replying to [comment:32 jdemeyer]:\n> > Replying to [comment:28 vdelecroix]:\n> > > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!\n\n> > Of course not, that's a general rule for inheritance.\n> \n> I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?\n\nI don't understand what you are saying. For any method `foo`, the statement \"if you redefine `foo` in your Element class then `Element.foo` is not called\" is true.",
    "created_at": "2015-04-26T10:45:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235578",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:33 vdelecroix]:
> Replying to [comment:32 jdemeyer]:
> > Replying to [comment:28 vdelecroix]:
> > > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!

> > Of course not, that's a general rule for inheritance.
> 
> I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?

I don't understand what you are saying. For any method `foo`, the statement "if you redefine `foo` in your Element class then `Element.foo` is not called" is true.



---

archive/issue_comments_235579.json:
```json
{
    "body": "Replying to [comment:36 jdemeyer]:\n> Replying to [comment:33 vdelecroix]:\n> > Replying to [comment:32 jdemeyer]:\n> > > Replying to [comment:28 vdelecroix]:\n> > > > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!\n\n> > > Of course not, that's a general rule for inheritance.\n> > \n> > I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?\n\n> I don't understand what you are saying. For any method `foo`, the statement \"if you redefine `foo` in your Element class then `Element.foo` is not called\" is true.\n\nWhy in extension class one has to copy/paste the definition of `__richcmp__`?",
    "created_at": "2015-04-26T10:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235579",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:36 jdemeyer]:
> Replying to [comment:33 vdelecroix]:
> > Replying to [comment:32 jdemeyer]:
> > > Replying to [comment:28 vdelecroix]:
> > > > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!

> > > Of course not, that's a general rule for inheritance.
> > 
> > I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?

> I don't understand what you are saying. For any method `foo`, the statement "if you redefine `foo` in your Element class then `Element.foo` is not called" is true.

Why in extension class one has to copy/paste the definition of `__richcmp__`?



---

archive/issue_comments_235580.json:
```json
{
    "body": "Replying to [comment:35 jdemeyer]:\n> Replying to [comment:34 vdelecroix]:\n> > Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!\n\n> \n> I agree. Unfortunately this is general Python behaviour and not something this ticket can fix.\n\n\nIt needs to be emphasized in the doc then. We should try hard to avoid `cmp(x,y)`!",
    "created_at": "2015-04-26T10:51:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235580",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:35 jdemeyer]:
> Replying to [comment:34 vdelecroix]:
> > Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!

> 
> I agree. Unfortunately this is general Python behaviour and not something this ticket can fix.


It needs to be emphasized in the doc then. We should try hard to avoid `cmp(x,y)`!



---

archive/issue_comments_235581.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-04-26T13:27:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235581",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_235582.json:
```json
{
    "body": "5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).\n\n6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?\n\n7. There should be a mention of the Python issue that `cmp(a,b)` with `a` and `b` of different types does not call `_cmp_` (or `__cmp__`)",
    "created_at": "2015-04-26T13:27:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235582",
    "user": "https://github.com/videlec"
}
```

5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).

6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?

7. There should be a mention of the Python issue that `cmp(a,b)` with `a` and `b` of different types does not call `_cmp_` (or `__cmp__`)



---

archive/issue_comments_235583.json:
```json
{
    "body": "8. For `right_to_bool_sgn`:\n   - I found the following more readable\n\n```\ncdef inline bint rich_to_bool_sgn(int op, long c):\n    return rich_to_bool(op, (c > 0) - (c < 0))\n```\n  and in `Integer._cmp_`, you could optimize the sign check as well (either with your version or the one above)\n- why the input is `long c` and not `int c`? the output of `mpz_cmp` is an `int` for example.",
    "created_at": "2015-04-26T14:39:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235583",
    "user": "https://github.com/videlec"
}
```

8. For `right_to_bool_sgn`:
   - I found the following more readable

```
cdef inline bint rich_to_bool_sgn(int op, long c):
    return rich_to_bool(op, (c > 0) - (c < 0))
```
  and in `Integer._cmp_`, you could optimize the sign check as well (either with your version or the one above)
- why the input is `long c` and not `int c`? the output of `mpz_cmp` is an `int` for example.



---

archive/issue_comments_235584.json:
```json
{
    "body": "Replying to [comment:37 vdelecroix]:\n> Why in extension class one has to copy/paste the definition of `__richcmp__`?\n\nThis is vaguely explained in [https://docs.python.org/2/reference/datamodel.html#object.__hash__](https://docs.python.org/2/reference/datamodel.html#object.__hash__) (when reading this, mentally replace `__eq__` by `__richcmp__`)",
    "created_at": "2015-04-26T15:36:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235584",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:37 vdelecroix]:
> Why in extension class one has to copy/paste the definition of `__richcmp__`?

This is vaguely explained in [https://docs.python.org/2/reference/datamodel.html#object.__hash__](https://docs.python.org/2/reference/datamodel.html#object.__hash__) (when reading this, mentally replace `__eq__` by `__richcmp__`)



---

archive/issue_comments_235585.json:
```json
{
    "body": "This is how Python implements `cmp`:\n\n```c\nstatic int\ndo_cmp(PyObject *v, PyObject *w)\n{\n    int c;\n    cmpfunc f;\n\n    if (v->ob_type == w->ob_type\n        && (f = v->ob_type->tp_compare) != NULL) {\n        c = (*f)(v, w);\n        if (PyInstance_Check(v)) {\n            /* Instance tp_compare has a different signature.\n               But if it returns undefined we fall through. */\n            if (c != 2)\n                return c;\n            /* Else fall through to try_rich_to_3way_compare() */\n        }\n        else\n            return adjust_tp_compare(c);\n    }\n    /* We only get here if one of the following is true:\n       a) v and w have different types\n       b) v and w have the same type, which doesn't have tp_compare\n       c) v and w are instances, and either __cmp__ is not defined or\n          __cmp__ returns NotImplemented\n    */\n    c = try_rich_to_3way_compare(v, w);\n    if (c < 2)\n        return c;\n    c = try_3way_compare(v, w);\n    if (c < 2)\n        return c;\n    return default_3way_compare(v, w);\n}\n```\n\nNote how `tp_compare` is only called if the types of `v` and `w` are equal. If not, `__richcmp__` is used. Only if `__richcmp__` is not implemented, then `__cmp__` is tried after all.",
    "created_at": "2015-04-26T16:18:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235585",
    "user": "https://github.com/jdemeyer"
}
```

This is how Python implements `cmp`:

```c
static int
do_cmp(PyObject *v, PyObject *w)
{
    int c;
    cmpfunc f;

    if (v->ob_type == w->ob_type
        && (f = v->ob_type->tp_compare) != NULL) {
        c = (*f)(v, w);
        if (PyInstance_Check(v)) {
            /* Instance tp_compare has a different signature.
               But if it returns undefined we fall through. */
            if (c != 2)
                return c;
            /* Else fall through to try_rich_to_3way_compare() */
        }
        else
            return adjust_tp_compare(c);
    }
    /* We only get here if one of the following is true:
       a) v and w have different types
       b) v and w have the same type, which doesn't have tp_compare
       c) v and w are instances, and either __cmp__ is not defined or
          __cmp__ returns NotImplemented
    */
    c = try_rich_to_3way_compare(v, w);
    if (c < 2)
        return c;
    c = try_3way_compare(v, w);
    if (c < 2)
        return c;
    return default_3way_compare(v, w);
}
```

Note how `tp_compare` is only called if the types of `v` and `w` are equal. If not, `__richcmp__` is used. Only if `__richcmp__` is not implemented, then `__cmp__` is tried after all.



---

archive/issue_comments_235586.json:
```json
{
    "body": "Replying to [comment:40 vdelecroix]:\n> 8. For `right_to_bool_sgn`:\n>    - I found the following more readable\n> \n> ```\n> cdef inline bint rich_to_bool_sgn(int op, long c):\n>     return rich_to_bool(op, (c > 0) - (c < 0))\n> ```\n\nSure, I can change that.\n\n>   - why the input is `long c` and not `int c`? the output of `mpz_cmp` is an `int` for example.\n \nIt's an `inline` function, so it won't matter much for performance. `long` is more general than `int`, so if there is ever a use case for a `long`, it will be possible.",
    "created_at": "2015-04-26T18:58:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235586",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:40 vdelecroix]:
> 8. For `right_to_bool_sgn`:
>    - I found the following more readable
> 
> ```
> cdef inline bint rich_to_bool_sgn(int op, long c):
>     return rich_to_bool(op, (c > 0) - (c < 0))
> ```

Sure, I can change that.

>   - why the input is `long c` and not `int c`? the output of `mpz_cmp` is an `int` for example.
 
It's an `inline` function, so it won't matter much for performance. `long` is more general than `int`, so if there is ever a use case for a `long`, it will be possible.



---

archive/issue_comments_235587.json:
```json
{
    "body": "Replying to [comment:39 vdelecroix]:\n> 5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).\n> \n> 6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?\n\n\nCan we please postpone the pure Python case to a new ticket? I feel like this ticket is already getting big enough and I would prefer to focus on Cython here.",
    "created_at": "2015-04-26T19:01:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235587",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:39 vdelecroix]:
> 5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).
> 
> 6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?


Can we please postpone the pure Python case to a new ticket? I feel like this ticket is already getting big enough and I would prefer to focus on Cython here.



---

archive/issue_comments_235588.json:
```json
{
    "body": "Replying to [comment:44 jdemeyer]:\n> Replying to [comment:39 vdelecroix]:\n> > 5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).\n> > \n> > 6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?\n  \n> \n> Can we please postpone the pure Python case to a new ticket? I feel like this ticket is already getting big enough and I would prefer to focus on Cython here.\n\n\nAnd there are already two tickets depending on it ;-) I opened #18305\n\nVincent",
    "created_at": "2015-04-26T19:11:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235588",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:44 jdemeyer]:
> Replying to [comment:39 vdelecroix]:
> > 5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).
> > 
> > 6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?
  
> 
> Can we please postpone the pure Python case to a new ticket? I feel like this ticket is already getting big enough and I would prefer to focus on Cython here.


And there are already two tickets depending on it ;-) I opened #18305

Vincent



---

archive/issue_comments_235589.json:
```json
{
    "body": "For the documentation, I opened #18306.",
    "created_at": "2015-04-26T19:39:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235589",
    "user": "https://github.com/jdemeyer"
}
```

For the documentation, I opened #18306.



---

archive/issue_comments_235590.json:
```json
{
    "body": "Replying to [comment:43 jdemeyer]:\n> It's an `inline` function, so it won't matter much for performance. `long` is more general than `int`, so if there is ever a use case for a `long`, it will be possible.\n\n\nHmm, just checked the assembly output of GCC 4.8.4 and it doesn't actually optimize this properly. So I'll stick to `int` indeed.",
    "created_at": "2015-04-26T20:05:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235590",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:43 jdemeyer]:
> It's an `inline` function, so it won't matter much for performance. `long` is more general than `int`, so if there is ever a use case for a `long`, it will be possible.


Hmm, just checked the assembly output of GCC 4.8.4 and it doesn't actually optimize this properly. So I'll stick to `int` indeed.



---

archive/issue_comments_235591.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-26T20:59:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235591",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235592.json:
```json
{
    "body": "For the assembly literate: with this new branch,\n\n```\nreturn rich_to_bool(op, (c > 0) - (c < 0))\n```\nbecomes\n\n```\n    xorl    %edx, %edx\n    testl   %eax, %eax        # test c\n    setg    %dl               # c > 0\n    shrl    $31, %eax         # c < 0 computed as ((unsigned int)c) >> 31\n    subl    %eax, %edx        # shift = (c > 0) - (c < 0)\n    movl    $184563750, %eax  # bits = 184563750\n    sall    $3, %edx          # shift *= 8\n    addl    %r12d, %edx       # shift += op\n    btl %edx, %eax            # test bit \"shift\" of \"bits\"\n    jnc ...\n```\n\n---\nNew commits:",
    "created_at": "2015-04-26T21:00:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235592",
    "user": "https://github.com/jdemeyer"
}
```

For the assembly literate: with this new branch,

```
return rich_to_bool(op, (c > 0) - (c < 0))
```
becomes

```
    xorl    %edx, %edx
    testl   %eax, %eax        # test c
    setg    %dl               # c > 0
    shrl    $31, %eax         # c < 0 computed as ((unsigned int)c) >> 31
    subl    %eax, %edx        # shift = (c > 0) - (c < 0)
    movl    $184563750, %eax  # bits = 184563750
    sall    $3, %edx          # shift *= 8
    addl    %r12d, %edx       # shift += op
    btl %edx, %eax            # test bit "shift" of "bits"
    jnc ...
```

---
New commits:



---

archive/issue_comments_235593.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-04-26T21:00:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235593",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_235594.json:
```json
{
    "body": "9. implementation of `_(rich)cmp`:\n   - Why in `_(rich)cmp` it starts with the case `not have_same_parent_c(left,right)` instead of `have_same_parent_c(left,right)`. It would make it more readable the other way around.\n\n```\ncdef _richcmp(left, right):\n    if have_same_parent_c(left, right):\n        return left._richcmp_(<Element>right, op)\n\n    # different parents\n    global coercion_model\n    cdef int r\n    ...\n```\n- In `return left._(rich)cmp_(<Element>right, op)` is the `<Element>` really needed or usefull?\n- could `_left, _right = coercion_model.canonical_coercion(left, right)` be replaced with `left, right = coercion_model.canonical_coercion(left, right)`. As far as I see, there is no need of these extra variables.\n\n10. Could you add some minimal documentation to `_(rich)cmp` and `_(rich)cmp_` like\n\n```\ndef _richcmp(left, right):\n    r\"\"\"\n    Rich comparisons of elements\n\n    This should not be overriden! To implement comparisons override ``_richcmp_``\n    or/and ``_cmp_``.\n    \"\"\"\n\ndef _richcmp_(left, right):\n    r\"\"\"\n    Default implementation of rich comparisons for elements\n\n    By default it tries to see if `_cmp_` is implemented otherwise does a\n    comparison by id for ``==`` and ``!=``. Calling this default method\n    with ``<``, ``<=``, ``>`` or ``>=`` will raise a ``NotImplementedError``.\n\n    EXAMPLES::\n\n        sage: from sage.structure.parent import Parent\n        sage: from sage.structure.element import Element\n        sage: P = Parent()\n        sage: e1 = Element(P); e2 = Element(P)\n        sage: e1 == e1    # indirect doctest\n        True\n        sage: e1 == e2    # indirect doctest\n        False\n        sage: e1 < e2     # indirect doctest\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: comparison not implemented for\n        <type 'sage.structure.element.Element'>\n    \"\"\"\n```\n and I think that `_cmp_` and `_richcmp_` deserves a sphinx directive to make them appear in the reference manual.",
    "created_at": "2015-04-26T22:03:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235594",
    "user": "https://github.com/videlec"
}
```

9. implementation of `_(rich)cmp`:
   - Why in `_(rich)cmp` it starts with the case `not have_same_parent_c(left,right)` instead of `have_same_parent_c(left,right)`. It would make it more readable the other way around.

```
cdef _richcmp(left, right):
    if have_same_parent_c(left, right):
        return left._richcmp_(<Element>right, op)

    # different parents
    global coercion_model
    cdef int r
    ...
```
- In `return left._(rich)cmp_(<Element>right, op)` is the `<Element>` really needed or usefull?
- could `_left, _right = coercion_model.canonical_coercion(left, right)` be replaced with `left, right = coercion_model.canonical_coercion(left, right)`. As far as I see, there is no need of these extra variables.

10. Could you add some minimal documentation to `_(rich)cmp` and `_(rich)cmp_` like

```
def _richcmp(left, right):
    r"""
    Rich comparisons of elements

    This should not be overriden! To implement comparisons override ``_richcmp_``
    or/and ``_cmp_``.
    """

def _richcmp_(left, right):
    r"""
    Default implementation of rich comparisons for elements

    By default it tries to see if `_cmp_` is implemented otherwise does a
    comparison by id for ``==`` and ``!=``. Calling this default method
    with ``<``, ``<=``, ``>`` or ``>=`` will raise a ``NotImplementedError``.

    EXAMPLES::

        sage: from sage.structure.parent import Parent
        sage: from sage.structure.element import Element
        sage: P = Parent()
        sage: e1 = Element(P); e2 = Element(P)
        sage: e1 == e1    # indirect doctest
        True
        sage: e1 == e2    # indirect doctest
        False
        sage: e1 < e2     # indirect doctest
        Traceback (most recent call last):
        ...
        NotImplementedError: comparison not implemented for
        <type 'sage.structure.element.Element'>
    """
```
 and I think that `_cmp_` and `_richcmp_` deserves a sphinx directive to make them appear in the reference manual.



---

archive/issue_comments_235595.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-04-26T22:03:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235595",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_235596.json:
```json
{
    "body": "Replying to [comment:51 vdelecroix]:\n> 9. implementation of `_(rich)cmp`:\n>    - Why in `_(rich)cmp` it starts with the case `not have_same_parent_c(left,right)` instead of `have_same_parent_c(left,right)`. It would make it more readable the other way around.\n  \nI don't know why it would be more readable, but I can change it.\n\n>   - In `return left._(rich)cmp_(<Element>right, op)` is the `<Element>` really needed or usefull?\n \nIt's useful for efficiency. Note how `_(rich)cmp_` is declared with `Element right`. By explicitly calling this with `<Element>right`, Cython does not need to check that `right` is indeed an `Element`.\n\n>   - could `_left, _right = coercion_model.canonical_coercion(left, right)` be replaced with `left, right = coercion_model.canonical_coercion(left, right)`. As far as I see, there is no need of these extra variables.\n \nPerhaps surprisingly, there is a need at least for an extra variable `_left`. The point is that `left` is a \"self\" argument which Cython will always assume and require that it is an instance of `Element`.",
    "created_at": "2015-04-27T06:13:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235596",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:51 vdelecroix]:
> 9. implementation of `_(rich)cmp`:
>    - Why in `_(rich)cmp` it starts with the case `not have_same_parent_c(left,right)` instead of `have_same_parent_c(left,right)`. It would make it more readable the other way around.
  
I don't know why it would be more readable, but I can change it.

>   - In `return left._(rich)cmp_(<Element>right, op)` is the `<Element>` really needed or usefull?
 
It's useful for efficiency. Note how `_(rich)cmp_` is declared with `Element right`. By explicitly calling this with `<Element>right`, Cython does not need to check that `right` is indeed an `Element`.

>   - could `_left, _right = coercion_model.canonical_coercion(left, right)` be replaced with `left, right = coercion_model.canonical_coercion(left, right)`. As far as I see, there is no need of these extra variables.
 
Perhaps surprisingly, there is a need at least for an extra variable `_left`. The point is that `left` is a "self" argument which Cython will always assume and require that it is an instance of `Element`.



---

archive/issue_comments_235597.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-27T11:12:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235597",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235598.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-04-27T11:19:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235598",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_235599.json:
```json
{
    "body": "OK, I made some further changes to `_richcmp`. There is one important functional change: when comparing two elements of the same type but different parents such that no coercion is possible (e.g. vectors over a different finite field), comparison is done by `id` instead of always returning `True` for `__lt__`:\n\nbefore:\n\n```\nsage: v = vector(GF(5), [1])\nsage: w = vector(GF(7), [1])\nsage: v < w\nTrue\nsage: w < v\nTrue\n```\n\nafter, `id(v)` and `id(w)` are compared.\n\nThis caused some doctest failures, which I simply removed (there was not much point in those tests). I also discovered #18308 this way (where there should be a coercion, but there isn't).",
    "created_at": "2015-04-27T11:19:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235599",
    "user": "https://github.com/jdemeyer"
}
```

OK, I made some further changes to `_richcmp`. There is one important functional change: when comparing two elements of the same type but different parents such that no coercion is possible (e.g. vectors over a different finite field), comparison is done by `id` instead of always returning `True` for `__lt__`:

before:

```
sage: v = vector(GF(5), [1])
sage: w = vector(GF(7), [1])
sage: v < w
True
sage: w < v
True
```

after, `id(v)` and `id(w)` are compared.

This caused some doctest failures, which I simply removed (there was not much point in those tests). I also discovered #18308 this way (where there should be a coercion, but there isn't).



---

archive/issue_events_050954.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-04-27T11:19:28Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "milestone": "sage-6.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17653#event-50954"
}
```



---

archive/issue_comments_235600.json:
```json
{
    "body": "You wrote in the doc of `_richcmp`\n\n```\n        If a class wants to implement rich comparison without coercion,\n        then ``_richcmp`` should be defined (as well as ``__richcmp__``\n        as usual).\n```\nWhy not define directly `__richcmp__` in that case? This is exactly what is done in `Integer` (and also `Rational` in #18304). These could be cited as examples BTW.",
    "created_at": "2015-04-27T14:44:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235600",
    "user": "https://github.com/videlec"
}
```

You wrote in the doc of `_richcmp`

```
        If a class wants to implement rich comparison without coercion,
        then ``_richcmp`` should be defined (as well as ``__richcmp__``
        as usual).
```
Why not define directly `__richcmp__` in that case? This is exactly what is done in `Integer` (and also `Rational` in #18304). These could be cited as examples BTW.



---

archive/issue_comments_235601.json:
```json
{
    "body": "Replying to [comment:55 vdelecroix]:\n> You wrote in the doc of `_richcmp`\n> \n> ```\n>         If a class wants to implement rich comparison without coercion,\n>         then ``_richcmp`` should be defined (as well as ``__richcmp__``\n>         as usual).\n> ```\n> Why not define directly `__richcmp__` in that case?\n\n\nBecause rich comparison after coercion calls `_richcmp`, not `__richcmp__`. The only reason this works for `Integer` is that `ZZ` has no sub-rings: it is never the common parent of two different parents.",
    "created_at": "2015-04-27T15:39:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235601",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:55 vdelecroix]:
> You wrote in the doc of `_richcmp`
> 
> ```
>         If a class wants to implement rich comparison without coercion,
>         then ``_richcmp`` should be defined (as well as ``__richcmp__``
>         as usual).
> ```
> Why not define directly `__richcmp__` in that case?


Because rich comparison after coercion calls `_richcmp`, not `__richcmp__`. The only reason this works for `Integer` is that `ZZ` has no sub-rings: it is never the common parent of two different parents.



---

archive/issue_comments_235602.json:
```json
{
    "body": "For `Rational` in #18304, a similar argument holds: the only coercion to `QQ` from a Sage `Parent` is from `ZZ`. Since you're not using the coercion framework for this comparison between `Integer` and `Rational`, you're safe.\n\nIn other words: both work for very specific reasons, they are not examples to follow.",
    "created_at": "2015-04-27T15:52:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235602",
    "user": "https://github.com/jdemeyer"
}
```

For `Rational` in #18304, a similar argument holds: the only coercion to `QQ` from a Sage `Parent` is from `ZZ`. Since you're not using the coercion framework for this comparison between `Integer` and `Rational`, you're safe.

In other words: both work for very specific reasons, they are not examples to follow.



---

archive/issue_comments_235603.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-27T18:15:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235603",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235604.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-27T18:44:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235604",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235605.json:
```json
{
    "body": "Replying to [comment:56 jdemeyer]:\n> Replying to [comment:55 vdelecroix]:\n> > You wrote in the doc of `_richcmp`\n> > \n> > ```\n> >         If a class wants to implement rich comparison without coercion,\n> >         then ``_richcmp`` should be defined (as well as ``__richcmp__``\n> >         as usual).\n> > ```\n> > Why not define directly `__richcmp__` in that case?\n\n> \n> Because rich comparison after coercion calls `_richcmp`, not `__richcmp__`. The only reason this works for `Integer` is that `ZZ` has no sub-rings: it is never the common parent of two different parents.\n\n\nRight, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.\n\nSo even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.\n\nDo you have an example of a `Parent` where we want to avoid coercions?",
    "created_at": "2015-04-28T06:20:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235605",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:56 jdemeyer]:
> Replying to [comment:55 vdelecroix]:
> > You wrote in the doc of `_richcmp`
> > 
> > ```
> >         If a class wants to implement rich comparison without coercion,
> >         then ``_richcmp`` should be defined (as well as ``__richcmp__``
> >         as usual).
> > ```
> > Why not define directly `__richcmp__` in that case?

> 
> Because rich comparison after coercion calls `_richcmp`, not `__richcmp__`. The only reason this works for `Integer` is that `ZZ` has no sub-rings: it is never the common parent of two different parents.


Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.

So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.

Do you have an example of a `Parent` where we want to avoid coercions?



---

archive/issue_comments_235606.json:
```json
{
    "body": "Replying to [comment:60 vdelecroix]:\n> Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.\n> \n> So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.\n\nI guess you're right. It's just much less obvious (as `_cmp_` is used after coercion, not `__richcmp__`).\n\n> Do you have an example of a `Parent` where we want to avoid coercions?\n\nSee `src/sage/numerical/linear_functions.pyx` which deals with \"symbolic\" linear inequalities. Here, `(a <= b) <= c` should construct the symbolic inequality `a <= b <= c`.",
    "created_at": "2015-04-28T06:42:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235606",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:60 vdelecroix]:
> Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.
> 
> So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.

I guess you're right. It's just much less obvious (as `_cmp_` is used after coercion, not `__richcmp__`).

> Do you have an example of a `Parent` where we want to avoid coercions?

See `src/sage/numerical/linear_functions.pyx` which deals with "symbolic" linear inequalities. Here, `(a <= b) <= c` should construct the symbolic inequality `a <= b <= c`.



---

archive/issue_comments_235607.json:
```json
{
    "body": "I would really like the following in `Element._richcmp_`\n\n```diff\ndiff --git a/src/sage/structure/element.pyx b/src/sage/structure/element.pyx\nindex 6981135..12cb669 100644\n--- a/src/sage/structure/element.pyx\n+++ b/src/sage/structure/element.pyx\n@@ -1047,11 +1047,21 @@ cdef class Element(SageObject):\n             ...\n             NotImplementedError: comparison not implemented for <type 'sage.structure.element.Element'>\n         \"\"\"\n         # Obvious case\n         if left is right:\n             return rich_to_bool(op, 0)\n \n         cdef int c\n+        if op == Py_NE:\n+            try:\n+                left_eq = left.__eq__\n+            except AttributeError:\n+                pass\n+            else:\n+                if isinstance(left_eq, MethodType):\n+                    return False if left_eq(right) else True\n+\n         try:\n             c = left._cmp_(right)\n         except NotImplementedError:\n```\nthat would allow element implementing `__eq__` to benefit of `__ne__` for free. What do you think? Perhaps not for this ticket though (thinking about #18305). It is a bit dangerous since `__eq__` would not go through coercions but `__ne__` would.",
    "created_at": "2015-04-28T06:46:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235607",
    "user": "https://github.com/videlec"
}
```

I would really like the following in `Element._richcmp_`

```diff
diff --git a/src/sage/structure/element.pyx b/src/sage/structure/element.pyx
index 6981135..12cb669 100644
--- a/src/sage/structure/element.pyx
+++ b/src/sage/structure/element.pyx
@@ -1047,11 +1047,21 @@ cdef class Element(SageObject):
             ...
             NotImplementedError: comparison not implemented for <type 'sage.structure.element.Element'>
         """
         # Obvious case
         if left is right:
             return rich_to_bool(op, 0)
 
         cdef int c
+        if op == Py_NE:
+            try:
+                left_eq = left.__eq__
+            except AttributeError:
+                pass
+            else:
+                if isinstance(left_eq, MethodType):
+                    return False if left_eq(right) else True
+
         try:
             c = left._cmp_(right)
         except NotImplementedError:
```
that would allow element implementing `__eq__` to benefit of `__ne__` for free. What do you think? Perhaps not for this ticket though (thinking about #18305). It is a bit dangerous since `__eq__` would not go through coercions but `__ne__` would.



---

archive/issue_comments_235608.json:
```json
{
    "body": "Replying to [comment:61 jdemeyer]:\n> Replying to [comment:60 vdelecroix]:\n> > Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.\n> > \n> > So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.\n\n> I guess you're right. It's just much less obvious (as `_cmp_` is used after coercion, not `__richcmp__`).\n> \n> > Do you have an example of a `Parent` where we want to avoid coercions?\n\n> See `src/sage/numerical/linear_functions.pyx` which deals with \"symbolic\" linear inequalities. Here, `(a <= b) <= c` should construct the symbolic inequality `a <= b <= c`.\n\nI see. Could you add this one to the documentation of `Element._richcmp` then?",
    "created_at": "2015-04-28T06:47:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235608",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:61 jdemeyer]:
> Replying to [comment:60 vdelecroix]:
> > Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.
> > 
> > So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.

> I guess you're right. It's just much less obvious (as `_cmp_` is used after coercion, not `__richcmp__`).
> 
> > Do you have an example of a `Parent` where we want to avoid coercions?

> See `src/sage/numerical/linear_functions.pyx` which deals with "symbolic" linear inequalities. Here, `(a <= b) <= c` should construct the symbolic inequality `a <= b <= c`.

I see. Could you add this one to the documentation of `Element._richcmp` then?



---

archive/issue_comments_235609.json:
```json
{
    "body": "Replying to [comment:62 vdelecroix]:\n> that would allow element implementing `__eq__` to benefit of `__ne__` for free. What do you think? Perhaps not for this ticket though (thinking about #18305). It is a bit dangerous since `__eq__` would not go through coercions but `__ne__` would.\n\n\nI don't like it so much. I think a Python class can easily do\n\n```\ndef __ne__(self, other):\n    return not (self == other)\n```\n\nAnd then you're indeed bringing coercion in the story and you're assuming that rich comparisons return `True` or `False` and not something symbolic.",
    "created_at": "2015-04-28T07:00:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235609",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:62 vdelecroix]:
> that would allow element implementing `__eq__` to benefit of `__ne__` for free. What do you think? Perhaps not for this ticket though (thinking about #18305). It is a bit dangerous since `__eq__` would not go through coercions but `__ne__` would.


I don't like it so much. I think a Python class can easily do

```
def __ne__(self, other):
    return not (self == other)
```

And then you're indeed bringing coercion in the story and you're assuming that rich comparisons return `True` or `False` and not something symbolic.



---

archive/issue_comments_235610.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-28T08:21:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235610",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235611.json:
```json
{
    "body": "I am running long tests. If these are good, this is good for me.\n\nVincent",
    "created_at": "2015-04-28T08:23:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235611",
    "user": "https://github.com/videlec"
}
```

I am running long tests. If these are good, this is good for me.

Vincent



---

archive/issue_comments_235612.json:
```json
{
    "body": "All tests passed!",
    "created_at": "2015-04-28T08:40:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235612",
    "user": "https://github.com/videlec"
}
```

All tests passed!



---

archive/issue_comments_235613.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-04-28T08:40:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235613",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_235614.json:
```json
{
    "body": "Great, thanks!",
    "created_at": "2015-04-28T10:17:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235614",
    "user": "https://github.com/jdemeyer"
}
```

Great, thanks!



---

archive/issue_comments_235615.json:
```json
{
    "body": "Another follow-up: #18322",
    "created_at": "2015-04-28T16:12:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235615",
    "user": "https://github.com/jdemeyer"
}
```

Another follow-up: #18322



---

archive/issue_comments_235616.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-04-29T03:13:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17653#issuecomment-235616",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_050955.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-04-29T03:13:44Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/17653",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17653#event-50955"
}
```
