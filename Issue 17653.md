# Issue 17653: Remove _cmp_c_impl

Issue created by migration from Trac.

Original creator: jdemeyer

Original creation time: 2015-03-03 09:34:04

CC:  dkrenn

Instead of

```
    def _cmp_(left, right)
    cdef int _cmp_c_impl(left, right) except -2
```

we should have

```
    cpdef int _cmp_(left, right) except -2
```



---

Comment by jdemeyer created at 2015-03-03 22:33:51

New commits:


---

Comment by vdelecroix created at 2015-03-04 09:37:47

If it is slower this is very bad. Do you know why? Isn't a `cdef` function call equivalent to `cpdef` function call?

Vincent


---

Comment by jdemeyer created at 2015-03-04 11:09:49

Replying to [comment:6 vdelecroix]:
> If it is slower this is very bad. Do you know why?
Yes, see [https://groups.google.com/forum/#!topic/sage-devel/AXYk1uEfuPE](https://groups.google.com/forum/#!topic/sage-devel/AXYk1uEfuPE)


---

Comment by mmezzarobba created at 2015-03-04 15:52:06

Related: #10130.


---

Comment by git created at 2015-03-04 16:28:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2015-03-05 10:42:12

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2015-03-05 10:49:30

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2015-03-06 07:34:41

See also #16537


---

Comment by git created at 2015-03-06 08:42:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2015-03-13 17:20:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-16 09:44:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-04-25 14:28:46

Changing status from needs_review to needs_info.


---

Comment by vdelecroix created at 2015-04-25 14:28:46

## sage.structure.element

1. In the documentation of `sage.structure.element` emphasize what should be done for Python classes as well (and the potential difference between Python and Cython). It is not very clear to me! What I understood is that we should:
 - implement `__cmp__(left,right)` or/and `_richcmp_(left,right,op)`
 - avoid `__eq__`, `__ne__`, etc

2. What about putting

```
# Obvious case
if left is right:
    return _rich_to_bool(op, 0)
```

  directly in `__richcmp__`?

## sage.structure.parent

3. The default comparison for parents is by id which is natural (and I guess what Python does). But the default hash is not based on id and is the stupid one inherited from `SageObject`. Is there a reason?

4. Why not using `_rich_to_bool` in `parent.pyx` instead of

```
if op == 0:  #< 
    return r  < 0
elif op == 2: #==
    return r == 0 
elif op == 4: #>
    return r  > 0
elif op == 1: #<=
    return r <= 0
elif op == 3: #!=
    return r != 0
elif op == 5: #>=
    return r >= 0 
```

  And by the way, why is there a method `cdef _rich_to_bool` on element? it would be useful as a standalone function in other places.


---

Comment by jdemeyer created at 2015-04-25 15:23:38

Replying to [comment:20 vdelecroix]:
> == sage.structure.element ==
> 
> 1. In the documentation of `sage.structure.element` emphasize what should be done for Python classes as well (and the potential difference between Python and Cython). It is not very clear to me!
Unfortunately, it is not very clear to me either. In particular, I don't find good Python documentation about the interaction between `__cmp__`, rich comparisons like `__eq__` and `__hash__` and what Python does when you call `cmp(x,y)`. It seems that `cmp(x,y)` only calls `x.__cmp__(y)` when `x` and `y` have the same type, but I don't find this anywhere documented. And I know that inheritance works in a strange way for comparisons, but I also don't quite know how.


---

Comment by jdemeyer created at 2015-04-25 15:40:06

Replying to [comment:20 vdelecroix]:
> 2. What about putting
> {{{
> # Obvious case
> if left is right:
>     return _rich_to_bool(op, 0)
> }}}
>   directly in `__richcmp__`?

Because `__richcmp__` should absolutely be as simple as possible. Don't forget that _every subclass_ needs a `__richcmp__` method (because of Python's strange inheritance rules regarding comparison).


---

Comment by jdemeyer created at 2015-04-25 15:45:03

Replying to [comment:20 vdelecroix]:
> 3. The default comparison for parents is by id which is natural (and I guess what Python does). But the default hash is not based on id and is the stupid one inherited from `SageObject`. Is there a reason?
I don't know. This ticket doesn't change anything to hashing, so I consider this outside the scope of this ticket (but you might have a point though).


---

Comment by git created at 2015-04-25 20:38:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-25 20:46:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-04-25 20:47:16

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2015-04-25 20:47:16

OK, I improved `rich_to_bool` a lot.


---

Comment by vdelecroix created at 2015-04-26 09:57:41

I did some experimentations with Python classes. The conclusion is:

     just define `_cmp_` and `_richcmp_` (even though you redefine `__hash__`)

Then:
- rich  comparisons and comparisons work when it involves elements with the same parent (i.e. the newly defined `_cmp_` and `_richcmp_` gets called)
- rich comparisons involving coercion is fine
- comparison involving coercion is *wrong*: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.

Actually, this is not only a bug in Python but also in Cython! I added print statement in each comparisons function in `Element` and see

```
sage: cmp(1,1/3)
Element._richcmp(1,1/3,2)
Element._richcmp(1,1/3,2)
Element._richcmp_(1,1/3,2)
Element._richcmp(1,1/3,0)
Element._richcmp(1,1/3,0)
Element._richcmp_(1,1/3,0)
Element._richcmp(1,1/3,4)
Element._richcmp(1,1/3,4)
Element._richcmp_(1,1/3,4)
1
```


Vincent


---

Comment by vdelecroix created at 2015-04-26 10:03:08

Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called! So the test in `Element._cmp` seems useless.


---

Comment by vdelecroix created at 2015-04-26 10:07:41

Replying to [comment:28 vdelecroix]:
> Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called! So the test in `Element._cmp` seems useless.

Except if you do not define `_richcmp_` and do some rich comparisons (this is the case in `sage.rings.qqbar.AlgebraicReal` for example).


---

Comment by jdemeyer created at 2015-04-26 10:33:39

Replying to [comment:27 vdelecroix]:
> - comparison involving coercion is *wrong*: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.
> 
> Actually, this is not only a bug in Python
Bug or feature?


---

Comment by vdelecroix created at 2015-04-26 10:34:25

And implementing `_richcmp_` instead of `__cmp__` in `AlgebraicReal` I got an incredible speedup (see #18303).


---

Comment by jdemeyer created at 2015-04-26 10:36:26

Replying to [comment:28 vdelecroix]:
> Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!
Of course not, that's a general rule for inheritance.

> So the test in `Element._cmp` seems useless.
What do you mean?


---

Comment by vdelecroix created at 2015-04-26 10:40:52

Replying to [comment:32 jdemeyer]:
> Replying to [comment:28 vdelecroix]:
> > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!
> Of course not, that's a general rule for inheritance.

I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?

> > So the test in `Element._cmp` seems useless.
> What do you mean?

Sorry, I forgot a `_`. I wanted to say `Element._cmp_`. The default implementation does check whether `__cmp__` is redefined in element classes. This code is called only if `__cmp__` is defined but not `_richcmp_`. And it seems much better to define `_richcmp_` in children classes.

Vincent


---

Comment by vdelecroix created at 2015-04-26 10:43:14

Replying to [comment:30 jdemeyer]:
> Replying to [comment:27 vdelecroix]:
> > - comparison involving coercion is *wrong*: if you call `cmp(a,b)` with `a` and `b` between two parents `A` and `B` and a coercion `B -> A` then `Element.__richcmp__` is called instead of `Element.__cmp__`.
> > 
> > Actually, this is not only a bug in Python
> Bug or feature?

Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!


---

Comment by jdemeyer created at 2015-04-26 10:44:51

Replying to [comment:34 vdelecroix]:
> Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!

I agree. Unfortunately this is general Python behaviour and not something this ticket can fix.


---

Comment by jdemeyer created at 2015-04-26 10:45:51

Replying to [comment:33 vdelecroix]:
> Replying to [comment:32 jdemeyer]:
> > Replying to [comment:28 vdelecroix]:
> > > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!
> > Of course not, that's a general rule for inheritance.
> 
> I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?
I don't understand what you are saying. For any method `foo`, the statement "if you redefine `foo` in your Element class then `Element.foo` is not called" is true.


---

Comment by vdelecroix created at 2015-04-26 10:47:38

Replying to [comment:36 jdemeyer]:
> Replying to [comment:33 vdelecroix]:
> > Replying to [comment:32 jdemeyer]:
> > > Replying to [comment:28 vdelecroix]:
> > > > Moreover if you redefine `__cmp__` in your Element class then `Element.__cmp__` is not called!
> > > Of course not, that's a general rule for inheritance.
> > 
> > I thought this was not the case for cython classes which redefine `__hash__`! Is it only true for `__richcmp__`?
> I don't understand what you are saying. For any method `foo`, the statement "if you redefine `foo` in your Element class then `Element.foo` is not called" is true.

Why in extension class one has to copy/paste the definition of `__richcmp__`?


---

Comment by vdelecroix created at 2015-04-26 10:51:27

Replying to [comment:35 jdemeyer]:
> Replying to [comment:34 vdelecroix]:
> > Call it whatever you want: `cmp(a1,a2)` (same type) calls `__cmp__` but `cmp(a,b)` (different types) does not and use `__richcmp__` instead. The consequence is that you might perform three times the coercion while calling `cmp` with elements with different parents!
> 
> I agree. Unfortunately this is general Python behaviour and not something this ticket can fix.

It needs to be emphasized in the doc then. We should try hard to avoid `cmp(x,y)`!


---

Comment by vdelecroix created at 2015-04-26 13:27:15

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-04-26 13:27:15

5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).

6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?

7. There should be a mention of the Python issue that `cmp(a,b)` with `a` and `b` of different types does not call `_cmp_` (or `__cmp__`)


---

Comment by vdelecroix created at 2015-04-26 14:39:52

8. For `right_to_bool_sgn`:
  - I found the following more readable

```
cdef inline bint rich_to_bool_sgn(int op, long c):
    return rich_to_bool(op, (c > 0) - (c < 0))
```

  and in `Integer._cmp_`, you could optimize the sign check as well (either with your version or the one above)
  - why the input is `long c` and not `int c`? the output of `mpz_cmp` is an `int` for example.


---

Comment by jdemeyer created at 2015-04-26 15:36:13

Replying to [comment:37 vdelecroix]:
> Why in extension class one has to copy/paste the definition of `__richcmp__`?
This is vaguely explained in [https://docs.python.org/2/reference/datamodel.html#object.__hash__](https://docs.python.org/2/reference/datamodel.html#object.__hash__) (when reading this, mentally replace `__eq__` by `__richcmp__`)


---

Comment by jdemeyer created at 2015-04-26 16:18:00

This is how Python implements `cmp`:

```c
static int
do_cmp(PyObject *v, PyObject *w)
{
    int c;
    cmpfunc f;

    if (v->ob_type == w->ob_type
        && (f = v->ob_type->tp_compare) != NULL) {
        c = (*f)(v, w);
        if (PyInstance_Check(v)) {
            /* Instance tp_compare has a different signature.
               But if it returns undefined we fall through. */
            if (c != 2)
                return c;
            /* Else fall through to try_rich_to_3way_compare() */
        }
        else
            return adjust_tp_compare(c);
    }
    /* We only get here if one of the following is true:
       a) v and w have different types
       b) v and w have the same type, which doesn't have tp_compare
       c) v and w are instances, and either __cmp__ is not defined or
          __cmp__ returns NotImplemented
    */
    c = try_rich_to_3way_compare(v, w);
    if (c < 2)
        return c;
    c = try_3way_compare(v, w);
    if (c < 2)
        return c;
    return default_3way_compare(v, w);
}
```


Note how `tp_compare` is only called if the types of `v` and `w` are equal. If not, `__richcmp__` is used. Only if `__richcmp__` is not implemented, then `__cmp__` is tried after all.


---

Comment by jdemeyer created at 2015-04-26 18:58:15

Replying to [comment:40 vdelecroix]:
> 8. For `right_to_bool_sgn`:
>   - I found the following more readable
> {{{
> cdef inline bint rich_to_bool_sgn(int op, long c):
>     return rich_to_bool(op, (c > 0) - (c < 0))
> }}}
Sure, I can change that.

>   - why the input is `long c` and not `int c`? the output of `mpz_cmp` is an `int` for example.
It's an `inline` function, so it won't matter much for performance. `long` is more general than `int`, so if there is ever a use case for a `long`, it will be possible.


---

Comment by jdemeyer created at 2015-04-26 19:01:01

Replying to [comment:39 vdelecroix]:
> 5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).
> 
> 6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?

Can we please postpone the pure Python case to a new ticket? I feel like this ticket is already getting big enough and I would prefer to focus on Cython here.


---

Comment by vdelecroix created at 2015-04-26 19:11:34

Replying to [comment:44 jdemeyer]:
> Replying to [comment:39 vdelecroix]:
> > 5. For Python classes, I guess that one needs to implement `_cmp_` and/or `_richcmp_`. This must be precised in the doc of `Element/Parent`. For this reason, we need a `py_rich_to_bool` available at the level of Python (as well as the operators `Py_EQ`, `Py_NE`, etc).
> > 
> > 6. I think we should avoid implenting `__eq__`, `__ne__` because one can do with `_richcmp_` that would take care of coercions. What do you think?
> 
> Can we please postpone the pure Python case to a new ticket? I feel like this ticket is already getting big enough and I would prefer to focus on Cython here.

And there are already two tickets depending on it ;-) I opened #18305

Vincent


---

Comment by jdemeyer created at 2015-04-26 19:39:44

For the documentation, I opened #18306.


---

Comment by jdemeyer created at 2015-04-26 20:05:13

Replying to [comment:43 jdemeyer]:
> It's an `inline` function, so it won't matter much for performance. `long` is more general than `int`, so if there is ever a use case for a `long`, it will be possible.

Hmm, just checked the assembly output of GCC 4.8.4 and it doesn't actually optimize this properly. So I'll stick to `int` indeed.


---

Comment by git created at 2015-04-26 20:59:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-04-26 21:00:02

For the assembly literate: with this new branch,

```
return rich_to_bool(op, (c > 0) - (c < 0))
```

becomes

```
    xorl    %edx, %edx
    testl   %eax, %eax        # test c
    setg    %dl               # c > 0
    shrl    $31, %eax         # c < 0 computed as ((unsigned int)c) >> 31
    subl    %eax, %edx        # shift = (c > 0) - (c < 0)
    movl    $184563750, %eax  # bits = 184563750
    sall    $3, %edx          # shift *= 8
    addl    %r12d, %edx       # shift += op
    btl %edx, %eax            # test bit "shift" of "bits"
    jnc ...
```

----
New commits:


---

Comment by jdemeyer created at 2015-04-26 21:00:31

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-04-26 22:03:26

9. implementation of `_(rich)cmp`:
  - Why in `_(rich)cmp` it starts with the case `not have_same_parent_c(left,right)` instead of `have_same_parent_c(left,right)`. It would make it more readable the other way around.

```
cdef _richcmp(left, right):
    if have_same_parent_c(left, right):
        return left._richcmp_(<Element>right, op)

    # different parents
    global coercion_model
    cdef int r
    ...
```

  - In `return left._(rich)cmp_(<Element>right, op)` is the `<Element>` really needed or usefull?
  - could `_left, _right = coercion_model.canonical_coercion(left, right)` be replaced with `left, right = coercion_model.canonical_coercion(left, right)`. As far as I see, there is no need of these extra variables.

10. Could you add some minimal documentation to `_(rich)cmp` and `_(rich)cmp_` like

```
def _richcmp(left, right):
    r"""
    Rich comparisons of elements

    This should not be overriden! To implement comparisons override ``_richcmp_``
    or/and ``_cmp_``.
    """

def _richcmp_(left, right):
    r"""
    Default implementation of rich comparisons for elements

    By default it tries to see if `_cmp_` is implemented otherwise does a
    comparison by id for ``==`` and ``!=``. Calling this default method
    with ``<``, ``<=``, ``>`` or ``>=`` will raise a ``NotImplementedError``.

    EXAMPLES::

        sage: from sage.structure.parent import Parent
        sage: from sage.structure.element import Element
        sage: P = Parent()
        sage: e1 = Element(P); e2 = Element(P)
        sage: e1 == e1    # indirect doctest
        True
        sage: e1 == e2    # indirect doctest
        False
        sage: e1 < e2     # indirect doctest
        Traceback (most recent call last):
        ...
        NotImplementedError: comparison not implemented for
        <type 'sage.structure.element.Element'>
    """
```

 and I think that `_cmp_` and `_richcmp_` deserves a sphinx directive to make them appear in the reference manual.


---

Comment by vdelecroix created at 2015-04-26 22:03:26

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2015-04-27 06:13:43

Replying to [comment:51 vdelecroix]:
> 9. implementation of `_(rich)cmp`:
>   - Why in `_(rich)cmp` it starts with the case `not have_same_parent_c(left,right)` instead of `have_same_parent_c(left,right)`. It would make it more readable the other way around.
I don't know why it would be more readable, but I can change it.

>   - In `return left._(rich)cmp_(<Element>right, op)` is the `<Element>` really needed or usefull?
It's useful for efficiency. Note how `_(rich)cmp_` is declared with `Element right`. By explicitly calling this with `<Element>right`, Cython does not need to check that `right` is indeed an `Element`.

>   - could `_left, _right = coercion_model.canonical_coercion(left, right)` be replaced with `left, right = coercion_model.canonical_coercion(left, right)`. As far as I see, there is no need of these extra variables.
Perhaps surprisingly, there is a need at least for an extra variable `_left`. The point is that `left` is a "self" argument which Cython will always assume and require that it is an instance of `Element`.


---

Comment by git created at 2015-04-27 11:12:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-04-27 11:19:28

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2015-04-27 11:19:28

OK, I made some further changes to `_richcmp`. There is one important functional change: when comparing two elements of the same type but different parents such that no coercion is possible (e.g. vectors over a different finite field), comparison is done by `id` instead of always returning `True` for `__lt__`:

before:

```
sage: v = vector(GF(5), [1])
sage: w = vector(GF(7), [1])
sage: v < w
True
sage: w < v
True
```


after, `id(v)` and `id(w)` are compared.

This caused some doctest failures, which I simply removed (there was not much point in those tests). I also discovered #18308 this way (where there should be a coercion, but there isn't).


---

Comment by vdelecroix created at 2015-04-27 14:44:57

You wrote in the doc of `_richcmp`

```
        If a class wants to implement rich comparison without coercion,
        then ``_richcmp`` should be defined (as well as ``__richcmp__``
        as usual).
```

Why not define directly `__richcmp__` in that case? This is exactly what is done in `Integer` (and also `Rational` in #18304). These could be cited as examples BTW.


---

Comment by jdemeyer created at 2015-04-27 15:39:30

Replying to [comment:55 vdelecroix]:
> You wrote in the doc of `_richcmp`
> {{{
>         If a class wants to implement rich comparison without coercion,
>         then ``_richcmp`` should be defined (as well as ``__richcmp__``
>         as usual).
> }}}
> Why not define directly `__richcmp__` in that case?

Because rich comparison after coercion calls `_richcmp`, not `__richcmp__`. The only reason this works for `Integer` is that `ZZ` has no sub-rings: it is never the common parent of two different parents.


---

Comment by jdemeyer created at 2015-04-27 15:52:58

For `Rational` in #18304, a similar argument holds: the only coercion to `QQ` from a Sage `Parent` is from `ZZ`. Since you're not using the coercion framework for this comparison between `Integer` and `Rational`, you're safe.

In other words: both work for very specific reasons, they are not examples to follow.


---

Comment by git created at 2015-04-27 18:15:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-27 18:44:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-04-28 06:20:38

Replying to [comment:56 jdemeyer]:
> Replying to [comment:55 vdelecroix]:
> > You wrote in the doc of `_richcmp`
> > {{{
> >         If a class wants to implement rich comparison without coercion,
> >         then ``_richcmp`` should be defined (as well as ``__richcmp__``
> >         as usual).
> > }}}
> > Why not define directly `__richcmp__` in that case?
> 
> Because rich comparison after coercion calls `_richcmp`, not `__richcmp__`. The only reason this works for `Integer` is that `ZZ` has no sub-rings: it is never the common parent of two different parents.

Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.

So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.

Do you have an example of a `Parent` where we want to avoid coercions?


---

Comment by jdemeyer created at 2015-04-28 06:42:51

Replying to [comment:60 vdelecroix]:
> Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.
> 
> So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.
I guess you're right. It's just much less obvious (as `_cmp_` is used after coercion, not `__richcmp__`).

> Do you have an example of a `Parent` where we want to avoid coercions?
See `src/sage/numerical/linear_functions.pyx` which deals with "symbolic" linear inequalities. Here, `(a <= b) <= c` should construct the symbolic inequality `a <= b <= c`.


---

Comment by vdelecroix created at 2015-04-28 06:46:20

I would really like the following in `Element._richcmp_`

```diff
diff --git a/src/sage/structure/element.pyx b/src/sage/structure/element.pyx
index 6981135..12cb669 100644
--- a/src/sage/structure/element.pyx
+++ b/src/sage/structure/element.pyx
`@``@` -1047,11 +1047,21 `@``@` cdef class Element(SageObject):
             ...
             NotImplementedError: comparison not implemented for <type 'sage.structure.element.Element'>
         """
         # Obvious case
         if left is right:
             return rich_to_bool(op, 0)
 
         cdef int c
+        if op == Py_NE:
+            try:
+                left_eq = left.__eq__
+            except AttributeError:
+                pass
+            else:
+                if isinstance(left_eq, MethodType):
+                    return False if left_eq(right) else True
+
         try:
             c = left._cmp_(right)
         except NotImplementedError:
```

that would allow element implementing `__eq__` to benefit of `__ne__` for free. What do you think? Perhaps not for this ticket though (thinking about #18305). It is a bit dangerous since `__eq__` would not go through coercions but `__ne__` would.


---

Comment by vdelecroix created at 2015-04-28 06:47:19

Replying to [comment:61 jdemeyer]:
> Replying to [comment:60 vdelecroix]:
> > Right, but `_richcmp` will call `_richcmp_`/`_cmp_`. In Integers (and Rationals after #18304) there is also this `_cmp_` implemented and if everything else failed in `__richcmp__` there is precisely `Element._richcmp(self, other, op)`.
> > 
> > So even if you implement a subset of `ZZ`/`QQ` as a new parent (let say the additive group `3 ZZ` or the ring `ZZ[1/p]`) then it would be fine with comparisons with integers/rationals as soon as you define a coercion `3 ZZ -> ZZ`/`ZZ[1/p] -> QQ`. So my mistake, the situation for `ZZ` and `QQ` is a bit different: `Integer/Rational` do not avoid coercion in rich comparisons, they just try to avoid it for most common cases.
> I guess you're right. It's just much less obvious (as `_cmp_` is used after coercion, not `__richcmp__`).
> 
> > Do you have an example of a `Parent` where we want to avoid coercions?
> See `src/sage/numerical/linear_functions.pyx` which deals with "symbolic" linear inequalities. Here, `(a <= b) <= c` should construct the symbolic inequality `a <= b <= c`.

I see. Could you add this one to the documentation of `Element._richcmp` then?


---

Comment by jdemeyer created at 2015-04-28 07:00:57

Replying to [comment:62 vdelecroix]:
> that would allow element implementing `__eq__` to benefit of `__ne__` for free. What do you think? Perhaps not for this ticket though (thinking about #18305). It is a bit dangerous since `__eq__` would not go through coercions but `__ne__` would.

I don't like it so much. I think a Python class can easily do

```
def __ne__(self, other):
    return not (self == other)
```


And then you're indeed bringing coercion in the story and you're assuming that rich comparisons return `True` or `False` and not something symbolic.


---

Comment by git created at 2015-04-28 08:21:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-04-28 08:23:57

I am running long tests. If these are good, this is good for me.

Vincent


---

Comment by vdelecroix created at 2015-04-28 08:40:41

All tests passed!


---

Comment by vdelecroix created at 2015-04-28 08:40:41

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2015-04-28 10:17:45

Great, thanks!


---

Comment by jdemeyer created at 2015-04-28 16:12:33

Another follow-up: #18322


---

Comment by vbraun created at 2015-04-29 03:13:44

Resolution: fixed
