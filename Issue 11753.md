# Issue 11753: Attach ignores inheritance of classes spread over distinct files

Issue created by migration from Trac.

Original creator: johanbosman

Original creation time: 2011-10-14 22:38:02

Assignee: ncalexan

CC:  mstreng

Keywords: attach inheritance

Suppose one has a file named aap.sage with the following contents:

```
class Aap(SageObject):
    pass  # Minimum example
```

and a file named noot.sage that looks like:

```
class Noot(Aap):
    pass  # Minimum example
```

Okay, and suppose one attaches both files:

```
sage: attach aap.sage
sage: attach noot.sage
```

After working with both files for a while, one changes something in the class Aap and the file aap.sage becomes:

```
class Aap(SageObject):
    def mies(self):
        print "Wim, zus, Jet!"
```

Now suppose that, *after* this change, one initializes a Noot object:

```
sage: noot = Noot()
```

Then the following gives an error:

```
sage: noot.mies()
...
AttributeError: 'Noot' object has no attribute 'mies'
```

If, instead, one re-attaches the files, everything works fine:

```
sage: attach aap.sage
sage: attach noot.sage
sage: noot = Noot()
sage: noot.mies()
Wim, zus, Jet!
```

Of course, the whole point of attaching files is that one shouldn't have to re-attach them.


---

Comment by johanbosman created at 2011-10-15 01:49:58

Changing assignee from ncalexan to jason.


---

Comment by johanbosman created at 2011-10-15 01:49:58

Changing component from sage-mode to misc.


---

Comment by mstreng created at 2011-10-15 09:05:24

Possible solution: make 2 different modes, one in which only changed files are reloaded (speed), and one in which every file is reloaded as soon as one changes (solves your problem).

The new patch I'm writing at #11812 also introduces different modes: one in which sage files are preparsed through memory and one in which they are preparsed through a file. #11812 will have a big overlap with #11925. This means that maybe I could do both tickets at once, but at the very least one ticket should depend on the other to avoid conflicting patches.


---

Comment by mstreng created at 2011-10-16 13:50:56

Replying to [comment:2 mstreng]:
> Possible solution: make 2 different modes, one in which only changed files are reloaded (speed), and one in which every file is reloaded as soon as one changes (solves your problem).

Starting from #11812, this would mean extending sage.misc.preparser.load_attach_mode with an option like "reload_all", and to change sage.misc.preparser.modified_attached_files accordingly.


---

Comment by mstreng created at 2011-10-16 16:24:59

Workaround: end aap.sage with `load noot.sage`

That way, when aap.sage changes and is reloaded, noot.sage is loaded afterwards.


---

Comment by ncalexan created at 2011-10-28 19:22:25

I see Marco has given several work-arounds, which you can probably make work.  Be aware that circular dependencies will break the work-around, though.

Various people in the Python community have tried to address the issue, which is that loaded objects, in particular class definitions, do not modify existing objects but rather add new objects to the namespace.  Google "reload.py" or "xreload.py" to see attempts to solve this.  (Attempts that, in my experience, are worse than the problem.)

The only language/environment I know that hot-patches class definitions satisfactorily is Smalltalk, although I would be willing to bet Erlang and friends could do it too.  If you know of others, please tell me -- it is a canonically hard problem and I would love to know more solutions.
