# Issue 18148: deallocate pari when sage quits

archive/issues_018148.json:
```json
{
    "body": "CC:  leif jpflori\n\nAs global module variables point toward the (unique) 'PariInstance' instance built by Sage, and because those are nto automatically cleaned, this instance is never deleted. Thus, we do it exlicitly in `quit_sage`.\n\nNathann\n\n[1] https://groups.google.com/d/topic/sage-devel/E-U4otPW9_0/discussion\n\nIssue created by migration from https://trac.sagemath.org/ticket/18385\n\n",
    "created_at": "2015-05-09T06:38:29Z",
    "labels": [
        "memleak",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.7",
    "title": "deallocate pari when sage quits",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18148",
    "user": "ncohen"
}
```
CC:  leif jpflori

As global module variables point toward the (unique) 'PariInstance' instance built by Sage, and because those are nto automatically cleaned, this instance is never deleted. Thus, we do it exlicitly in `quit_sage`.

Nathann

[1] https://groups.google.com/d/topic/sage-devel/E-U4otPW9_0/discussion

Issue created by migration from https://trac.sagemath.org/ticket/18385





---

archive/issue_comments_244730.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-05-09T06:38:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244730",
    "user": "ncohen"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_244731.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-09T06:40:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244731",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_244732.json:
```json
{
    "body": "I don't like this. How can you be sure that no PARI code will be executed after deallocating the PARI stack?",
    "created_at": "2015-05-09T08:26:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244732",
    "user": "jdemeyer"
}
```

I don't like this. How can you be sure that no PARI code will be executed after deallocating the PARI stack?



---

archive/issue_comments_244733.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-05-09T08:26:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244733",
    "user": "jdemeyer"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_244734.json:
```json
{
    "body": "> I don't like this. How can you be sure that no PARI code will be executed after deallocating the PARI stack?\n\nI am not, and you are right this is probably not a good idea after all. Do you know how we could do to have this be deallocated when it should?",
    "created_at": "2015-05-09T08:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244734",
    "user": "ncohen"
}
```

> I don't like this. How can you be sure that no PARI code will be executed after deallocating the PARI stack?

I am not, and you are right this is probably not a good idea after all. Do you know how we could do to have this be deallocated when it should?



---

archive/issue_comments_244735.json:
```json
{
    "body": "Of course it's not nice, but the only alternatives that come to my mind are:\n\n* Add even more Valgrind suppressions.  (IMHO odd.)\n\n* Remove the global variable which is bad anyway. (Implies a performance penalty.)\n\n* Convince Cython to call the deallocator.  (I have no idea how; `del` in `quit_sage()` doesn't work.)",
    "created_at": "2015-05-09T09:07:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244735",
    "user": "leif"
}
```

Of course it's not nice, but the only alternatives that come to my mind are:

* Add even more Valgrind suppressions.  (IMHO odd.)

* Remove the global variable which is bad anyway. (Implies a performance penalty.)

* Convince Cython to call the deallocator.  (I have no idea how; `del` in `quit_sage()` doesn't work.)



---

archive/issue_comments_244736.json:
```json
{
    "body": "We should probably benchmark option !#2.",
    "created_at": "2015-05-09T09:09:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244736",
    "user": "leif"
}
```

We should probably benchmark option !#2.



---

archive/issue_comments_244737.json:
```json
{
    "body": "I am against solving this problem \"by proxy\". The problem isn't that `pari` is never deallocated, the problem is apparently that Cython global variables are never deallocated. Even if you fix pari, then there are still a lot of other global variables with the same problem.",
    "created_at": "2015-11-24T10:57:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244737",
    "user": "jdemeyer"
}
```

I am against solving this problem "by proxy". The problem isn't that `pari` is never deallocated, the problem is apparently that Cython global variables are never deallocated. Even if you fix pari, then there are still a lot of other global variables with the same problem.



---

archive/issue_comments_244738.json:
```json
{
    "body": "Replying to [comment:9 jdemeyer]:\n> The problem isn't that `pari` is never deallocated, the problem is apparently that Cython global variables are never deallocated.\n\nA little googling gives me the impression that this is a wide-spread problem with python (extension) modules: there is no way to \"unload\" a module (which would be the time to deallocate global variables), and it seems it doesn't exist because people haven't been able to solve the subtle problems that arise in deciding when and in what order unloading should happen (especially extension modules seem to be complicated this way)\n\nIndeed, without extra information, the fact that arbitrary code could be executed upon deallocation means there is no sure-fire way to decide a correct way to order module deallocation. It wouldn't be hard to write 2 modules A and B such that the deallocation code of one requires the other module to be functional. One would require a rather careful protocol specification to allow module deactivation.\n\nWithout extra information, you cannot start deallocating global variables unless you know the module has been \"deactivated\". So I think Cython in general will not be solving this problem any time soon.",
    "created_at": "2015-11-24T18:51:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18148",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18148#issuecomment-244738",
    "user": "nbruin"
}
```

Replying to [comment:9 jdemeyer]:
> The problem isn't that `pari` is never deallocated, the problem is apparently that Cython global variables are never deallocated.

A little googling gives me the impression that this is a wide-spread problem with python (extension) modules: there is no way to "unload" a module (which would be the time to deallocate global variables), and it seems it doesn't exist because people haven't been able to solve the subtle problems that arise in deciding when and in what order unloading should happen (especially extension modules seem to be complicated this way)

Indeed, without extra information, the fact that arbitrary code could be executed upon deallocation means there is no sure-fire way to decide a correct way to order module deallocation. It wouldn't be hard to write 2 modules A and B such that the deallocation code of one requires the other module to be functional. One would require a rather careful protocol specification to allow module deactivation.

Without extra information, you cannot start deallocating global variables unless you know the module has been "deactivated". So I think Cython in general will not be solving this problem any time soon.
