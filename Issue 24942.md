# Issue 24942: ParentMethods: use a metaclass which does not bind methods

Issue created by migration from https://trac.sagemath.org/ticket/25179

Original creator: jdemeyer

Original creation time: 2018-04-16 10:11:20

CC:  nthiery

There are various instances in Sage of code like

```
someclass.ParentMethods.method.__func__
```

This is because we typically want to get the actual function from the `ParentMethods` body without binding to `ParentMethods`. This may apply to more general descriptors besides functions, although those don't seem used in `ParentMethods`.

To solve this, I propose a simple metaclass which does not call `__get__` upon attribute access.


---

Comment by nthiery created at 2018-04-16 10:25:32

Hi Jeroen,

I agree that the idiom is not great :-)
(though it makes explicit that something non trivial is happening)

Do you have a way to implement your proposition without having to specify a super class or metaclass in each and every `XXXMethods` class?


---

Comment by jdemeyer created at 2018-04-16 11:46:22

Replying to [comment:1 nthiery]:
> Do you have a way to implement your proposition without having to specify a super class or metaclass in each and every `XXXMethods` class?

I don't think so. My idea would be to replace

```
class ParentMethods:
```

by

```
class ParentMethods(Namespace):
```


Of course, the current code works so it's not required to do that change everywhere. I would suggest to do the change only when needed.


---

Comment by git created at 2018-04-16 12:30:57

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-04-16 12:33:21

These are the minimal changes needed to get rid of the existing `__func__` accesses related to `ParentMethods` and `ElementMethods`.


---

Comment by jdemeyer created at 2018-04-16 12:33:21

Changing status from new to needs_review.


---

Comment by nthiery created at 2018-04-17 08:02:33

Thanks for investigating this. I definitely see the point of trying to improve the idiom which expose an implementation detail about bound/unbound methods. However I am reluctant with the current solution. Somehow it's too unlocal and non explicit. The risk is that a developper will see the idiom (without `__func__`) in the target class, try to replicate it, without noticing that there is something special to be done in the original class.

I would be more in favor of a local and explicit idiom like:

```
    foo = unbind(Bars.ParentMethods.foo)
```

or

```
    foo = get_unbound(Bars.ParentMethod, "foo")
```


where we would use `unbind` to hide the implementation details and support any kind of object,
not just methods.

What do you think? Opinions anyone else?


---

Comment by jdemeyer created at 2018-04-17 12:51:11

Replying to [comment:6 nthiery]:
> where we would use `unbind` to hide the implementation details and support any kind of object,
> not just methods.

This wouldn't simply because you cannot "unbind" arbitrary objects. Imagine


```
class X:
    @property
    def answer(self):
        return 42
```

There is no way to unbind `42` to the `property` object `X.answer`.

`get_unbound` would work: it's essentially a one-liner to implement that because it's exactly what the C API function `_PyType_Lookup` does. It gets the bare attribute from a class and it doesn't fancy stuff like `__get__` or `__getattr__` or metaclass shenanigans.


---

Comment by jdemeyer created at 2018-04-17 12:56:45

I'll try to implement that on a different branch.


---

Comment by git created at 2018-04-17 16:19:39

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-04-17 20:48:29

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-04-18 08:40:34

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-04-18 08:45:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-04-18 08:48:15

Changing status from needs_work to needs_review.


---

Comment by embray created at 2018-04-18 09:54:36

This is neat, but it seems like extreme overkill for a relatively minor issue.  Were there any other use cases for this you had in mind?  Because the current use case is handled much more simply by other means.


---

Comment by embray created at 2018-04-18 09:58:37

Replying to [comment:5 jdemeyer]:
> These are the minimal changes needed to get rid of the existing `__func__` accesses related to `ParentMethods` and `ElementMethods`.

I'm not sure what you mean by this.  While I'm not particularly fond of the solution in #24955 either, it's not clear how this is any better, much less simpler.


---

Comment by embray created at 2018-04-18 10:02:13

I'm also -1 on immense mucking around with Python interpreter internals for seemingly little need/benefit.  Although I agree it may be a useful capability to have and might be worth proposing upstream.

As a different way of replacing the current idiom for copying methods from another class's `ParentMethods`, I had also floated the idea in #24955 of a class decorator that does the same thing.  This avoids the need for a metaclass or inheritence--just something like ``@`inherit_methods_from(<cls>, [<list of method names>])`.  Maybe "inherit" is not the best word choice though if we want to avoid allusion to class inheritance.


---

Comment by jdemeyer created at 2018-04-18 10:51:39

Replying to [comment:15 embray]:
> Were there any other use cases for this you had in mind?

There are various instances of `obj.__dict__[method]` in Sage which could be replaced by `rawattr(obj, method)`. But I haven't looked too closely.


---

Comment by jdemeyer created at 2018-04-18 12:02:57

Replying to [comment:17 embray]:
> something like ``@`inherit_methods_from(<cls>, [<list of method names>])`.  Maybe "inherit" is not the best word choice though if we want to avoid allusion to class inheritance.

This would only help to implement fake inheritance, it wouldn't help to check for inheritance for example.

What I like about `rawattr()` is that it's very general: it works both on instances (which would give bound methods) and on classes (which would give unbound methods). Also, it's not specific to methods: it works with arbitrary descriptors (say, `lazy_attribute`). These are two advantages compared to `six.get_unbound_function`.


---

Comment by embray created at 2018-04-19 12:03:47

Replying to [comment:18 jdemeyer]:
> Replying to [comment:15 embray]:
> > Were there any other use cases for this you had in mind?
> 
> There are various instances of `obj.__dict__[method]` in Sage which could be replaced by `rawattr(obj, method)`. But I haven't looked too closely.

So what's wrong with


```
def getattr_raw(obj, attr, default=None):
    return obj.__dict__.get(attr, default)
```

?

(I think the real implementation is a little more complicated than that but not by much).  Incidentally I prefer a name that still contains `getattr` making it clearer that it's like `getattr` but more direct.  The problem with "rawattr" IMO is there's no verb in the name.  That's a triviality though.


---

Comment by jdemeyer created at 2018-04-19 12:26:43

Replying to [comment:20 embray]:
> So what's wrong with
> 
> {{{
> def getattr_raw(obj, attr, default=None):
>     return obj.__dict__.get(attr, default)
> }}}
> ?

I'm not sure I understand your question.

If your question is "why don't you simply implement `rawattr` (whatever the name) like this?", then my answer is:

1. It doesn't get attributes from subclasses.

2. It only looks up the attribute in the instance, not in the class.

If your question is "why does `rawattr` need to support subclasses?", then my answer is: that's what normal attribute lookup also does.

If your question is "why does `rawattr` look both in the instance and in the class?", then my answer is: it makes it convenient to replace `__func__` regardless of whether the method was bound or unbound.


---

Comment by jdemeyer created at 2018-04-19 12:31:03

To put it differently: I wanted `rawattr()` to behave as much as possible like `getattr()`, just without binding.


---

Comment by nthiery created at 2018-04-19 20:09:25

Hi Erik, Jeroen,

The `rawattr` approach sounds more explicit, versatile and local than the class decorator.

Nice point to have an idiom analoguous to one that many developers will already know (`getattr`); it helps build quickly a mental model. So maybe a good name could be something like `getattr_unbounded`, or `get_unbounded_attr`.

I don't have a strong opinion for whether it should lookup just the class or also the super classes. In the use cases I met the former is sufficient, but the latter would not hurt. Performance does not matter, since the code will be executed just a couple times when reading the file. The latter hides an implementation detail (where exactly the method is implemented), enabling to move it up when appropriate; that's good. And if we decide to rely on the analogy with `getattr`, we might as well be as analogous as possible.

Cheers,
                      Nicolas


---

Comment by nthiery created at 2018-04-19 20:11:43

Replying to [comment:7 jdemeyer]:
> Replying to [comment:6 nthiery]:
> > where we would use `unbind` to hide the implementation details and support any kind of object, not just methods.
> 
> This wouldn't simply because you cannot "unbind" arbitrary objects.

Ah, right, good point:-) I somehow confused myself with documentation lookup where 'a.foo?' actually gets the object by name and therefore can retrieve the unbound object.


---

Comment by embray created at 2018-04-20 12:58:47

Replying to [comment:21 jdemeyer]:
> If your question is "why does `rawattr` look both in the instance and in the class?", then my answer is: it makes it convenient to replace `__func__` regardless of whether the method was bound or unbound.

I don't understand this statement.  Maybe you meant a different question?  If you want to get the function from a method (bound or unbound) that doesn't have anything to do with the class afaik.

I agree with the usefulness of such a utility, and I also agree that if we have it then it's a good solution for copying a method from one class to another.  I would still prefer a different way to do that is some kind of more explicit pseudo-inheritance.  But just as a straightforward technical solution to "I want to get some attribute off an object without going through descriptors" I agree this is useful.

I just don't know why the implementation has to be so complicated.  My point above was that a utility like that can be written just as easily in pure Python (and has been--there's plenty of precedence for it).  Slightly slower, maybe, but I'd want to actually see a performance critical application to weigh against the complexity of the implementation (I'd be less bothered if it weren't messing with apparently undocumented internals).


---

Comment by embray created at 2018-04-20 13:02:19

Replying to [comment:23 nthiery]:
>     Hi Erik, Jeroen,
> 
> The `rawattr` approach sounds more explicit, versatile and local than the class decorator.
> 
> Nice point to have an idiom analoguous to one that many developers will already know (`getattr`); it helps build quickly a mental model. So maybe a good name could be something like `getattr_unbounded`, or `get_unbounded_attr`.

I don't like anything referring to "bound" since that's very specific to methods.  It could also apply to other descriptors (e.g. I have written descriptors that are "bound" to a specific instance of a class when accessed through the instance).  But that's just one pattern for descriptors and isn't necessarily applicable in all cases.

I can't recall where, but I've seen this spelled `raw_getattr()` before.  Similarly, Sphinx has a `safe_getattr()`, but that serves a different purpose.


---

Comment by embray created at 2018-04-20 13:07:21

Replying to [comment:26 embray]:
> Replying to [comment:23 nthiery]:
> >     Hi Erik, Jeroen,
> > 
> > The `rawattr` approach sounds more explicit, versatile and local than the class decorator.
> > 
> > Nice point to have an idiom analoguous to one that many developers will already know (`getattr`); it helps build quickly a mental model. So maybe a good name could be something like `getattr_unbounded`, or `get_unbounded_attr`.
> 
> I don't like anything referring to "bound" since that's very specific to methods.  It could also apply to other descriptors (e.g. I have written descriptors that are "bound" to a specific instance of a class when accessed through the instance).  But that's just one pattern for descriptors and isn't necessarily applicable in all cases.


This is partly why I'm also confused about how this function is documented:


```
+    Like ``getattr(obj, name)`` but without binding the attribute to
+    the object. This can be used to easily get unbound methods or other
+    descriptors.
```


There's nothing about `getattr()` that has to do with "binding the attribute to the object".  That wording is really confusing to me and makes me not understand what this is supposed to do.  It's somewhat applicable to methods but not to all attributes by any means.


---

Comment by embray created at 2018-04-20 13:12:41

I think I know what you mean now--I think you're just referring general passing of the instance to the descriptor's `__get__` as a "binding" operation.  That makes more sense, but could be worded more clearly.


---

Comment by embray created at 2018-04-20 13:17:24

I think my problem just comes down to how I read "binding the attribute to the object" (and maybe it's my reading that's wrong).  I think I would have worded this just subtly differently like

"Like `getattr()` but without invoking the binding behavior of descriptors under normal attribute access."


---

Comment by nthiery created at 2018-04-20 14:24:37

Replying to [comment:29 embray]:
> I think my problem just comes down to how I read "binding the attribute to the object" (and maybe it's my reading that's wrong).

I guess my own reading is influenced by the first line of the 
[Descriptor How To](https://docs.python.org/2/howto/descriptor.html):


```
    In general, a descriptor is an object attribute with “binding behavior”
```


No idea what the average reading will be though.

>  I think I would have worded this just subtly differently like
> 
> "Like `getattr()` but without invoking the binding behavior of descriptors under normal attribute access."

Sounds good to me!


---

Comment by jdemeyer created at 2018-04-23 14:07:15

Replying to [comment:25 embray]:
> Replying to [comment:21 jdemeyer]:
> > If your question is "why does `rawattr` look both in the instance and in the class?", then my answer is: it makes it convenient to replace `__func__` regardless of whether the method was bound or unbound.
> 
> I don't understand this statement.

Suppose `X` is a class. I meant that we should support both `rawattr(X, name)` (getting the attribute from `X` itself) and `rawattr(X(), name)` (getting the attribute from `X().__class__`)


---

Comment by jdemeyer created at 2018-04-23 14:12:17

Replying to [comment:25 embray]:
> I just don't know why the implementation has to be so complicated.

I don't think that the implementation is complicated at all. I actually think it would be _more_ complicated in pure Python since pure Python has no equivalent for `_PyType_Lookup`.

Also note that most of the complications come from the support for old-style instances and classes. Once you remove that, it's basically three lines of code.


---

Comment by jdemeyer created at 2018-04-23 14:49:09

Replying to [comment:25 embray]:
> I just don't know why the implementation has to be so complicated.

Do you mean that the functionality of `raw_getattr()` should be simplified (that would make it less analogous to `getattr`) or that the implementation of that functionality can be simplified? Or is it just that you consider it complicated only because it's implemented in C?


---

Comment by git created at 2018-04-23 15:32:37

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-04-23 15:35:51

Renamed `rawattr` -> `raw_getattr`


---

Comment by embray created at 2018-04-23 15:42:21

Replying to [comment:33 jdemeyer]:
> Replying to [comment:25 embray]:
> > I just don't know why the implementation has to be so complicated.
> 
> Do you mean that the functionality of `raw_getattr()` should be simplified (that would make it less analogous to `getattr`) or that the implementation of that functionality can be simplified? Or is it just that you consider it complicated only because it's implemented in C?

Sorry, yes, I should clarify "complicated".  In part I mean that it's implemented in C, though I don't believe that alone makes it complicated.  I'm more concerned about the over-reliance on undocumented internals.

I could just as easily write this function in pure Python, and I _would_ be interested in a performance comparison between a pure python version and this C version, but I could try doing that myself.

To be clear I'm otherwise +1 on this--that's my only misgiving at this point.


---

Comment by tscrim created at 2018-04-23 23:37:46

FYI - I have a new use-case for this on #25146 where I want to treat functions as class-level attributes, but Python by default binds them as methods.


---

Comment by jdemeyer created at 2018-04-24 07:57:37

Replying to [comment:36 embray]:
> I'm more concerned about the over-reliance on undocumented internals.

Well, the internals of old-style instances and classes aren't likely going to change in Python 2.7.16. And `_PyType_Lookup` and `_PyObject_GetDictPtr` are indeed private, but pretty stable: they have existed for a long time and still do in Python master.


---

Comment by jdemeyer created at 2018-04-24 08:33:34

I am starting to think that a `super`-like syntax might be better: something like `namespace(obj).attr` instead of `raw_getattr(obj, "attr")`.

Advantages:

1. It allows specifying the attribute name in a more natural way, not as string.

2. `namespace(obj)` is an object which can be created once (and even stored or passed around) in case that you need to access many raw attributes of the same object.

3. Usable as class decorator to create namespace "classes" (whether this would still be a class or not remains to be seen).

The main disadvantage is that it would be more complicated to implement and slower.


---

Comment by embray created at 2018-05-14 11:34:26

For Python 3.3+ (and I think for practical purposes we're not interested in Python versions below 3.3) it looks like you want to use [PyObject_GenericGetDict](https://docs.python.org/3/c-api/object.html#c.PyObject_GenericGetDict).  This does practically the same thing you're doing with `_PyObject_GetDictPtr` but it also correctly implements the semantics of [PEP-412](https://www.python.org/dev/peps/pep-0412/).

For Python 2.7 I agree it should be safe-enough since it's not going to change.

As far as `_PyType_Lookup` is concerned, while I'm still wary of using any function that's not part of the limited API, I see now that we were already using it anyways so I'm not going to bother about it here, and I don't really see a better alternative--ISTM this might be a good candidate for adding to the documented API since it is important for implementing custom attribute access on extension types.


---

Comment by embray created at 2018-05-14 11:35:12

I like the idea of the `namespace` type, but it's also useful to have the stand-alone `raw_getattr`.  `namespace` would then just be built on top of that.


---

Comment by jdemeyer created at 2018-05-15 14:34:51

Replying to [comment:40 embray]:
> for practical purposes we're not interested in Python versions below 3.3

Did you forget that 2.7 is still the default and only supported version?


EDIT: I guess you meant 3.x with x < 3.


---

Comment by embray created at 2018-05-15 14:56:49

Yes, Python 3 versions below 3.3 (and really 3.6, but I'm thinking about what Python 3 versions are still in some distros...)


---

Comment by jdemeyer created at 2018-05-15 15:17:34

I don't think that there is anything wrong with using `_PyObject_GetDictPtr`. It does exactly what I want. I don't need to create the dict when it's not there and I don't need exceptions thrown when the object does not support `__dict__`.

And it only works on Python 3, so it would only complicate the code.

If you insist, I will use it though.


---

Comment by embray created at 2018-05-15 16:55:37

No, it's okay. I just think it goes without saying that internal functions should be avoided.  This whole thing could be written in pure Python and it seems like an overwrought pre-mature optimization not to.  OTOH I feel like it's a fault on the Python side that a) this function doesn't just come built-in--sometimes it is useful, especially for introspection, to bypass some of the high-level attribute machinery, and b) that this can't currently be easily implemented by third-party C code without reliance on internal functions. Which in turn gives more credence to the idea that this should be a built-in.

I think I would like to propose that to python-ideas if you don't mind, and use your code as an example.


---

Comment by jdemeyer created at 2018-05-15 20:16:30

Replying to [comment:45 embray]:
> This whole thing could be written in pure Python

Yes, it *could* be written in Python. It *could* also be written in C.

You seem to find it a problem that it's implemented in C but I don't understand why. I would argue that the C implementation is conceptually simpler than the potential Python implementation because Python doesn't have the equivalent of `_PyType_Lookup`.


---

Comment by jdemeyer created at 2018-05-15 20:26:58

Replying to [comment:45 embray]:
> I think I would like to propose that to python-ideas if you don't mind, and use your code as an example.

Feel free. But do remove the Python 2 stuff if you quote my code.


---

Comment by embray created at 2018-05-16 09:56:08

Python is practically pseudocode IMO.  It's almost always conceptually simpler than C (especially if you're also relying on undocumented internals to do something).


---

Comment by embray created at 2018-05-16 09:57:09

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-05-18 17:49:54

Resolution: fixed
