# Issue 15384: Implement regular partition tuples

archive/issues_015384.json:
```json
{
    "body": "Assignee: sage-combinat\n\nCC:  sage-combinat @AndrewAtLarge\n\nKeywords: regular partition tuples\n\nAs the title states and needed for #15508.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15621\n\n",
    "created_at": "2014-01-02T17:26:11Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.3",
    "title": "Implement regular partition tuples",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15384",
    "user": "https://github.com/tscrim"
}
```
Assignee: sage-combinat

CC:  sage-combinat @AndrewAtLarge

Keywords: regular partition tuples

As the title states and needed for #15508.

Issue created by migration from https://trac.sagemath.org/ticket/15621





---

archive/issue_comments_198252.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-01-02T17:26:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198252",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_198253.json:
```json
{
    "body": "There is a notable change to the behavior of `PartitionTuples`, in that it now always returns elements of itself (previously it returned partitions if the element was of level 1).",
    "created_at": "2014-01-02T17:44:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198253",
    "user": "https://github.com/tscrim"
}
```

There is a notable change to the behavior of `PartitionTuples`, in that it now always returns elements of itself (previously it returned partitions if the element was of level 1).



---

archive/issue_comments_198254.json:
```json
{
    "body": "Hi Travis,\n\nFirst, I'd like to say that I am very much against the advertised change that `PartitionTuples` now always returns a element of this class in level 1 as I think that this is mathematically incorrect (...and it will mean that I have to change some of my own code:). On the other hand, if this is necessary for #15508 or #15525 then one way to preserve mathematical correctness might be to use coercions/conversions in level 1? Also, if one does this then in `partition_tuple.py` shouldn't\n\n```\nsage: [5,1,1] in PartitionTuples() \nTrue\n```\n\nreturn `False`? \n\nSecondly, I am not sure how useful the implemented class `RegularPartitionTuples` will be. In level 1 this class is useful because the regular partitions index the irreducible representations of the Hecke algebra of type A and (equivalently) a related crystal graph for the irreducible highest weight representation of the quantised affine special linear group. For higher levels I think that the corresponding sets of partition tuples are more complicated than the class you have implemented.\n\nThe documentation does not seem to say what an element of `RegularPartitionTuples` is but from the code it looks like these things are just tuples of regular partitions. These partition tuples do not index the crystal bases of the higher level Fock spaces so if this is what this patch implements then it is probably not what you want for #15508. Except in level 1, the only known descriptions of the partition tuples that arise in the Fock space combinatorics are recursive: more explicitly, these are the partition tuples for which you can construct a path in the crystal graph starting from the empty partition tuple.\n\nI have an implementation of the class that is needed for the Fock spaces in `u/andrew.mathas/combinat/tableaux_residues` where they are called `KleshchevPartitions` in `partition_tuple.py`. If I haven't misread what your code does I would be happy to help in trying to merge these two branches  --  I don't care what the class is called. My code first implements \"good node sequences\" for partition tuples. This is the combinatorial data that you need to describe the realisation of the crystal graph that corresponds to the Fock space. The iterator for `KleshchevPartitions` then, in effect, constructs the crystal graph.\n\nI wasn't planning on putting this code into sage any time soon because I thought that no one was interested in it apart from me -- although it is already avalable on git. As a result I haven't properly tested my code, although it is documented and it probably works:) It is also worth mentioning that your Fock space code should give another way of constructing these partition (tuples) using the degrees of the higher level \"LLT polynomials\" that arise (so it shouldn't need this class). Finally, unfortunately, there are at least four different natural conventions for these objects, all of which are probably used by some one -- in level 1, there are two natural choices related by conjugation of partitions and in higher levels you can conjugate and reverse the order of the partitions in the tuple.\n\nAndrew",
    "created_at": "2014-01-03T20:53:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198254",
    "user": "https://github.com/AndrewAtLarge"
}
```

Hi Travis,

First, I'd like to say that I am very much against the advertised change that `PartitionTuples` now always returns a element of this class in level 1 as I think that this is mathematically incorrect (...and it will mean that I have to change some of my own code:). On the other hand, if this is necessary for #15508 or #15525 then one way to preserve mathematical correctness might be to use coercions/conversions in level 1? Also, if one does this then in `partition_tuple.py` shouldn't

```
sage: [5,1,1] in PartitionTuples() 
True
```

return `False`? 

Secondly, I am not sure how useful the implemented class `RegularPartitionTuples` will be. In level 1 this class is useful because the regular partitions index the irreducible representations of the Hecke algebra of type A and (equivalently) a related crystal graph for the irreducible highest weight representation of the quantised affine special linear group. For higher levels I think that the corresponding sets of partition tuples are more complicated than the class you have implemented.

The documentation does not seem to say what an element of `RegularPartitionTuples` is but from the code it looks like these things are just tuples of regular partitions. These partition tuples do not index the crystal bases of the higher level Fock spaces so if this is what this patch implements then it is probably not what you want for #15508. Except in level 1, the only known descriptions of the partition tuples that arise in the Fock space combinatorics are recursive: more explicitly, these are the partition tuples for which you can construct a path in the crystal graph starting from the empty partition tuple.

I have an implementation of the class that is needed for the Fock spaces in `u/andrew.mathas/combinat/tableaux_residues` where they are called `KleshchevPartitions` in `partition_tuple.py`. If I haven't misread what your code does I would be happy to help in trying to merge these two branches  --  I don't care what the class is called. My code first implements "good node sequences" for partition tuples. This is the combinatorial data that you need to describe the realisation of the crystal graph that corresponds to the Fock space. The iterator for `KleshchevPartitions` then, in effect, constructs the crystal graph.

I wasn't planning on putting this code into sage any time soon because I thought that no one was interested in it apart from me -- although it is already avalable on git. As a result I haven't properly tested my code, although it is documented and it probably works:) It is also worth mentioning that your Fock space code should give another way of constructing these partition (tuples) using the degrees of the higher level "LLT polynomials" that arise (so it shouldn't need this class). Finally, unfortunately, there are at least four different natural conventions for these objects, all of which are probably used by some one -- in level 1, there are two natural choices related by conjugation of partitions and in higher levels you can conjugate and reverse the order of the partitions in the tuple.

Andrew



---

archive/issue_comments_198255.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-01-05T18:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198255",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_198256.json:
```json
{
    "body": "Hey Andrew,\n\nReplying to [comment:3 andrew.mathas]:\n> First, I'd like to say that I am very much against the advertised change that `PartitionTuples` now always returns a element of this class in level 1 as I think that this is mathematically incorrect (...and it will mean that I have to change some of my own code:). On the other hand, if this is necessary for #15508 or #15525 then one way to preserve mathematical correctness might be to use coercions/conversions in level 1? Also, if one does this then in `partition_tuple.py` shouldn't\n> {{{\n> sage: [5,1,1] in PartitionTuples() \n> True\n> }}}\n> return `False`? \n\nI was thinking it was necessary for #15508, but then I realized I was directly using the parent class instead of just going through `PartitionTuples`. I'll change this back, and put some warnings about this. Although I think we should make sure we can convert from level 1 partition tuples to partitions if the user happens to accidentally have created one.\n\n> Secondly, I am not sure how useful the implemented class `RegularPartitionTuples` will be.\n>\n> ...\n>\n> I wasn't planning on putting this code into sage any time soon because I thought that no one was interested in it apart from me -- although it is already avalable on git. As a result I haven't properly tested my code, although it is documented and it probably works:)\n\nIf I understand Fayers correctly, the generalized LLT works for the full tensor product space and the `RegularPartitionTuples` should index that basis. I had put a TODO message in #15508 about wanting to use a smaller domain. I'm now thinking the best thing to do is just do that now and have both spaces available, but that's something specifically for #15508.\n\nI have #15584 which constructs Kleshchev partitions (as well some other crystals, but I can separate out just the Kleshchev partitions if desired), but does so by using the signature rule. I just skimmed over your code, and I think it's different that how you're doing it, but I very easily could be wrong. Nevertheless, we can check them against each other, and if you want, get your code on Kleshchev partitions into Sage as well. I will then use either of them (whichever turns out to be faster/more useful/put into sage) to index the HW basis for #15508.\n\n> It is also worth mentioning that your Fock space code should give another way of constructing these partition (tuples) using the degrees of the higher level \"LLT polynomials\" that arise (so it shouldn't need this class).\n\nIt would be useful for the `__getitem__` and `_element_constructor_` of the HW repr, but I don't think it wouldn't be useful for creating the indexing set for the basis.\n\n> Finally, unfortunately, there are at least four different natural conventions for these objects, all of which are probably used by some one -- in level 1, there are two natural choices related by conjugation of partitions and in higher levels you can conjugate and reverse the order of the partitions in the tuple.\n\nThe last one is the oh-so-fun<sup>TM</sup> Kashiwara vs. anti-Kashiwara for tensor products of crystals, but the conjugation should be easy enough to handle. In conclusion there's more to do for #15584, #15525, #15508, and here.",
    "created_at": "2014-01-05T18:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198256",
    "user": "https://github.com/tscrim"
}
```

Hey Andrew,

Replying to [comment:3 andrew.mathas]:
> First, I'd like to say that I am very much against the advertised change that `PartitionTuples` now always returns a element of this class in level 1 as I think that this is mathematically incorrect (...and it will mean that I have to change some of my own code:). On the other hand, if this is necessary for #15508 or #15525 then one way to preserve mathematical correctness might be to use coercions/conversions in level 1? Also, if one does this then in `partition_tuple.py` shouldn't
> {{{
> sage: [5,1,1] in PartitionTuples() 
> True
> }}}
> return `False`? 

I was thinking it was necessary for #15508, but then I realized I was directly using the parent class instead of just going through `PartitionTuples`. I'll change this back, and put some warnings about this. Although I think we should make sure we can convert from level 1 partition tuples to partitions if the user happens to accidentally have created one.

> Secondly, I am not sure how useful the implemented class `RegularPartitionTuples` will be.
>
> ...
>
> I wasn't planning on putting this code into sage any time soon because I thought that no one was interested in it apart from me -- although it is already avalable on git. As a result I haven't properly tested my code, although it is documented and it probably works:)

If I understand Fayers correctly, the generalized LLT works for the full tensor product space and the `RegularPartitionTuples` should index that basis. I had put a TODO message in #15508 about wanting to use a smaller domain. I'm now thinking the best thing to do is just do that now and have both spaces available, but that's something specifically for #15508.

I have #15584 which constructs Kleshchev partitions (as well some other crystals, but I can separate out just the Kleshchev partitions if desired), but does so by using the signature rule. I just skimmed over your code, and I think it's different that how you're doing it, but I very easily could be wrong. Nevertheless, we can check them against each other, and if you want, get your code on Kleshchev partitions into Sage as well. I will then use either of them (whichever turns out to be faster/more useful/put into sage) to index the HW basis for #15508.

> It is also worth mentioning that your Fock space code should give another way of constructing these partition (tuples) using the degrees of the higher level "LLT polynomials" that arise (so it shouldn't need this class).

It would be useful for the `__getitem__` and `_element_constructor_` of the HW repr, but I don't think it wouldn't be useful for creating the indexing set for the basis.

> Finally, unfortunately, there are at least four different natural conventions for these objects, all of which are probably used by some one -- in level 1, there are two natural choices related by conjugation of partitions and in higher levels you can conjugate and reverse the order of the partitions in the tuple.

The last one is the oh-so-fun<sup>TM</sup> Kashiwara vs. anti-Kashiwara for tensor products of crystals, but the conjugation should be easy enough to handle. In conclusion there's more to do for #15584, #15525, #15508, and here.



---

archive/issue_comments_198257.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n\n> I was thinking it was necessary for #15508, but then I realized I was directly using the parent class instead of just going through `PartitionTuples`. I'll change this back, and put some warnings about this. Although I think we should make sure we can convert from level 1 partition tuples to partitions if the user happens to accidentally have created one.\n\nPerhaps I am being too precious here:) In a discussion on sage-combinat Simon King was certainly very much against the current behaviour...and changing this is certainly not so drastic for my code. The main difference/annoyance is that with this change the level 1 partition tuples would be missing many of the methods of their honest partition counter-parts. Another way out would be to force partition tuples to have level at least 2.\n\n> If I understand Fayers correctly, the generalized LLT works for the full tensor product space and the `RegularPartitionTuples` should index that basis. I had put a TODO message in #15508 about wanting to use a smaller domain. I'm now thinking the best thing to do is just do that now and have both spaces available, but that's something specifically for #15508.\n\nOK, I need to look at Fayers properly to see what he does. I've been meaning to do this anyway because my promised comments on #15508 require this.\n\n> I have #15584 which constructs Kleshchev partitions (as well some other crystals, but I can separate out just the Kleshchev partitions if desired), but does so by using the signature rule. I just skimmed over your code, and I think it's different that how you're doing it, but I very easily could be wrong. Nevertheless, we can check them against each other, and if you want, get your code on Kleshchev partitions into Sage as well. I will then use either of them (whichever turns out to be faster/more useful/put into sage) to index the HW basis for #15508.\n\nI suspect that it comes down to the same thing: I am guessing that you are using Kashiwarra's theorem for the tensor product of crystal graphs, in which case our methods should be equivalent.\n\n> > It is also worth mentioning that your Fock space code should give another way of constructing these partition (tuples) using the degrees of the higher level \"LLT polynomials\" that arise (so it shouldn't need this class).\n> \n> It would be useful for the `__getitem__` and `_element_constructor_` of the HW repr, but I don't think it wouldn't be useful for creating the indexing set for the basis.\n\nI agree it is not useful for constructing the indexing set but I think that it does speed up the calculation of e basis for the highest weight module, primarily because the canonical bases elements which appear in L(\\Lambda) are identified by their maximal degree term so you don't ever need to compute the set of Kleshchev multipartitions.\n\nAndrew",
    "created_at": "2014-01-05T19:36:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198257",
    "user": "https://github.com/AndrewAtLarge"
}
```

Replying to [comment:4 tscrim]:

> I was thinking it was necessary for #15508, but then I realized I was directly using the parent class instead of just going through `PartitionTuples`. I'll change this back, and put some warnings about this. Although I think we should make sure we can convert from level 1 partition tuples to partitions if the user happens to accidentally have created one.

Perhaps I am being too precious here:) In a discussion on sage-combinat Simon King was certainly very much against the current behaviour...and changing this is certainly not so drastic for my code. The main difference/annoyance is that with this change the level 1 partition tuples would be missing many of the methods of their honest partition counter-parts. Another way out would be to force partition tuples to have level at least 2.

> If I understand Fayers correctly, the generalized LLT works for the full tensor product space and the `RegularPartitionTuples` should index that basis. I had put a TODO message in #15508 about wanting to use a smaller domain. I'm now thinking the best thing to do is just do that now and have both spaces available, but that's something specifically for #15508.

OK, I need to look at Fayers properly to see what he does. I've been meaning to do this anyway because my promised comments on #15508 require this.

> I have #15584 which constructs Kleshchev partitions (as well some other crystals, but I can separate out just the Kleshchev partitions if desired), but does so by using the signature rule. I just skimmed over your code, and I think it's different that how you're doing it, but I very easily could be wrong. Nevertheless, we can check them against each other, and if you want, get your code on Kleshchev partitions into Sage as well. I will then use either of them (whichever turns out to be faster/more useful/put into sage) to index the HW basis for #15508.

I suspect that it comes down to the same thing: I am guessing that you are using Kashiwarra's theorem for the tensor product of crystal graphs, in which case our methods should be equivalent.

> > It is also worth mentioning that your Fock space code should give another way of constructing these partition (tuples) using the degrees of the higher level "LLT polynomials" that arise (so it shouldn't need this class).
> 
> It would be useful for the `__getitem__` and `_element_constructor_` of the HW repr, but I don't think it wouldn't be useful for creating the indexing set for the basis.

I agree it is not useful for constructing the indexing set but I think that it does speed up the calculation of e basis for the highest weight module, primarily because the canonical bases elements which appear in L(\Lambda) are identified by their maximal degree term so you don't ever need to compute the set of Kleshchev multipartitions.

Andrew



---

archive/issue_comments_198258.json:
```json
{
    "body": "Replying to [comment:5 andrew.mathas]:\n> Perhaps I am being too precious here:) In a discussion on sage-combinat Simon King was certainly very much against the current behaviour...and changing this is certainly not so drastic for my code. The main difference/annoyance is that with this change the level 1 partition tuples would be missing many of the methods of their honest partition counter-parts. Another way out would be to force partition tuples to have level at least 2.\n\nJust to be clear, I'm not changing the output of things like `PartitionTuples(level=1)`, this will still return `Partitions`, but instead the `__iter__()` over elements of `PartitionTuples()` and the corresponding `_element_constructor_()`, which where not returning elements of the corresponding parent object. So we get things like\n\n```\nsage: P = PartitionTuples()\nsage: pt = P([[3,1,1]]); pt\n([3, 1, 1])\nsage: pt.parent() is P\nTrue\n```\n\nwhere previously the element constructed was a `Partition` object whose parent was `Partitions()`. As I recall, Simon was against the parent object returned what not a subclass of `PartitionTuple` (but I'm okay with it). I'd be surprised if you were using something specific to `Partition` when iterating or constructing elements from a parent over varying levels (at least without a check on the level).",
    "created_at": "2014-01-05T21:35:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198258",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:5 andrew.mathas]:
> Perhaps I am being too precious here:) In a discussion on sage-combinat Simon King was certainly very much against the current behaviour...and changing this is certainly not so drastic for my code. The main difference/annoyance is that with this change the level 1 partition tuples would be missing many of the methods of their honest partition counter-parts. Another way out would be to force partition tuples to have level at least 2.

Just to be clear, I'm not changing the output of things like `PartitionTuples(level=1)`, this will still return `Partitions`, but instead the `__iter__()` over elements of `PartitionTuples()` and the corresponding `_element_constructor_()`, which where not returning elements of the corresponding parent object. So we get things like

```
sage: P = PartitionTuples()
sage: pt = P([[3,1,1]]); pt
([3, 1, 1])
sage: pt.parent() is P
True
```

where previously the element constructed was a `Partition` object whose parent was `Partitions()`. As I recall, Simon was against the parent object returned what not a subclass of `PartitionTuple` (but I'm okay with it). I'd be surprised if you were using something specific to `Partition` when iterating or constructing elements from a parent over varying levels (at least without a check on the level).



---

archive/issue_comments_198259.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-05T00:37:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198259",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_198260.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-29T16:34:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198260",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_198261.json:
```json
{
    "body": "Hey Andrew,\n\nReplying to [comment:4 tscrim]:\n> Replying to [comment:3 andrew.mathas]:\n> > First, I'd like to say that I am very much against the advertised change that `PartitionTuples` now always returns a element of this class in level 1 as I think that this is mathematically incorrect (...and it will mean that I have to change some of my own code:). On the other hand, if this is necessary for #15508 or #15525 then one way to preserve mathematical correctness might be to use coercions/conversions in level 1? Also, if one does this then in `partition_tuple.py` shouldn't\n> > {{{\n> > sage: [5,1,1] in PartitionTuples() \n> > True\n> > }}}\n> > return `False`? \n> \n> I was thinking it was necessary for #15508, but then I realized I was directly using the parent class instead of just going through `PartitionTuples`. I'll change this back, and put some warnings about this. Although I think we should make sure we can convert from level 1 partition tuples to partitions if the user happens to accidentally have created one.\n\nI noticed an inconsistency with this. In particular, we currently have:-\n\n```\nsage: la = Partition([3,3,1])\nsage: PT = PartitionTuples()\nsage: la in PT\n```\n\nSo either we should have my change where the quoted example should be `True`, or we change it so that the example I gave returns `False`. Which would you prefer?",
    "created_at": "2015-10-29T16:43:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198261",
    "user": "https://github.com/tscrim"
}
```

Hey Andrew,

Replying to [comment:4 tscrim]:
> Replying to [comment:3 andrew.mathas]:
> > First, I'd like to say that I am very much against the advertised change that `PartitionTuples` now always returns a element of this class in level 1 as I think that this is mathematically incorrect (...and it will mean that I have to change some of my own code:). On the other hand, if this is necessary for #15508 or #15525 then one way to preserve mathematical correctness might be to use coercions/conversions in level 1? Also, if one does this then in `partition_tuple.py` shouldn't
> > {{{
> > sage: [5,1,1] in PartitionTuples() 
> > True
> > }}}
> > return `False`? 
> 
> I was thinking it was necessary for #15508, but then I realized I was directly using the parent class instead of just going through `PartitionTuples`. I'll change this back, and put some warnings about this. Although I think we should make sure we can convert from level 1 partition tuples to partitions if the user happens to accidentally have created one.

I noticed an inconsistency with this. In particular, we currently have:-

```
sage: la = Partition([3,3,1])
sage: PT = PartitionTuples()
sage: la in PT
```

So either we should have my change where the quoted example should be `True`, or we change it so that the example I gave returns `False`. Which would you prefer?



---

archive/issue_comments_198262.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2015-10-29T17:32:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198262",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_198263.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-29T17:34:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198263",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_198264.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-30T14:59:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198264",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_198265.json:
```json
{
    "body": "> I noticed an inconsistency with this. In particular, we currently have:-\n> {{{\n> sage: la = Partition([3,3,1])\n> sage: PT = PartitionTuples()\n> sage: la in PT\n> }}}\n> So either we should have my change where the quoted example should be `True`, or we change it so that the example I gave returns `False`. Which would you prefer?\n\nYes, this is certainly a bug. I would prefer the following:\n\n```\nsage: Partition([3,3,1]) in PartitionTuples()\nTrue\nsage: [3,3,1] in PartitionTuples()\nTrue   # ** currently returns False\n```\n\nI am not sure if this is compatible with what you are proposing.\n\nAndrew",
    "created_at": "2015-11-03T13:00:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198265",
    "user": "https://github.com/AndrewAtLarge"
}
```

> I noticed an inconsistency with this. In particular, we currently have:-
> {{{
> sage: la = Partition([3,3,1])
> sage: PT = PartitionTuples()
> sage: la in PT
> }}}
> So either we should have my change where the quoted example should be `True`, or we change it so that the example I gave returns `False`. Which would you prefer?

Yes, this is certainly a bug. I would prefer the following:

```
sage: Partition([3,3,1]) in PartitionTuples()
True
sage: [3,3,1] in PartitionTuples()
True   # ** currently returns False
```

I am not sure if this is compatible with what you are proposing.

Andrew



---

archive/issue_comments_198266.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-11-03T19:32:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198266",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_198267.json:
```json
{
    "body": "Replying to [comment:16 andrew.mathas]:\n> \n> > I noticed an inconsistency with this. In particular, we currently have:-\n> > {{{\n> > sage: la = Partition([3,3,1])\n> > sage: PT = PartitionTuples()\n> > sage: la in PT\n> > }}}\n> > So either we should have my change where the quoted example should be `True`, or we change it so that the example I gave returns `False`. Which would you prefer?\n> \n> Yes, this is certainly a bug. I would prefer the following:\n> {{{\n> sage: Partition([3,3,1]) in PartitionTuples()\n> True\n> sage: [3,3,1] in PartitionTuples()\n> True   # ** currently returns False\n> }}}\n> I am not sure if this is compatible with what you are proposing.\n\nYes it is as `__contains__` does not have to mean the checked object is an honest element of the parent. However it's just the output when passed through `PartitionTuples()` will be a tuple of size 1:\n\n```\nsage: PT = PartitionTuples()\nsage: [3,3,1] in PT\nTrue\nsage: PT([3,3,1])\n([3, 3, 1])\n```\n\nI was worried about which way you wanted given your statement on comment:3.\n\nHowever I will add a conversion from level 1 partition tuples to the corresponding set of partitions.",
    "created_at": "2015-11-03T19:32:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198267",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:16 andrew.mathas]:
> 
> > I noticed an inconsistency with this. In particular, we currently have:-
> > {{{
> > sage: la = Partition([3,3,1])
> > sage: PT = PartitionTuples()
> > sage: la in PT
> > }}}
> > So either we should have my change where the quoted example should be `True`, or we change it so that the example I gave returns `False`. Which would you prefer?
> 
> Yes, this is certainly a bug. I would prefer the following:
> {{{
> sage: Partition([3,3,1]) in PartitionTuples()
> True
> sage: [3,3,1] in PartitionTuples()
> True   # ** currently returns False
> }}}
> I am not sure if this is compatible with what you are proposing.

Yes it is as `__contains__` does not have to mean the checked object is an honest element of the parent. However it's just the output when passed through `PartitionTuples()` will be a tuple of size 1:

```
sage: PT = PartitionTuples()
sage: [3,3,1] in PT
True
sage: PT([3,3,1])
([3, 3, 1])
```

I was worried about which way you wanted given your statement on comment:3.

However I will add a conversion from level 1 partition tuples to the corresponding set of partitions.



---

archive/issue_comments_198268.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-11-03T20:02:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198268",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_198269.json:
```json
{
    "body": "I also noticed some places where containment checking led to errors being raised and took care of where I saw those on the last commit.\n\nI also elected to not have a level 1 partition tuple register as being contained in `Partitions` as getting equivalent forms of partition tuples, such as `[This is the Trac macro *4,3,3,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#4,3,3,1-macro)` and `([4,3,3,1])` (as a tuple/list of a list) seems fraught with issues and lots of checks that would likely cause slowdowns in the containment checks. If you are checking for containment, you probably are going to convert afterwards, so I would actually say the more pythonic way is to try the conversion and then handle the raised error if it cannot be done.\n\nPerhaps more succinctly, I don't think there is necessarily a perfect solution with the current implementation, but this is the best for our current applications.",
    "created_at": "2015-11-03T20:12:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198269",
    "user": "https://github.com/tscrim"
}
```

I also noticed some places where containment checking led to errors being raised and took care of where I saw those on the last commit.

I also elected to not have a level 1 partition tuple register as being contained in `Partitions` as getting equivalent forms of partition tuples, such as `[This is the Trac macro *4,3,3,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#4,3,3,1-macro)` and `([4,3,3,1])` (as a tuple/list of a list) seems fraught with issues and lots of checks that would likely cause slowdowns in the containment checks. If you are checking for containment, you probably are going to convert afterwards, so I would actually say the more pythonic way is to try the conversion and then handle the raised error if it cannot be done.

Perhaps more succinctly, I don't think there is necessarily a perfect solution with the current implementation, but this is the best for our current applications.



---

archive/issue_comments_198270.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-10T20:21:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198270",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_198271.json:
```json
{
    "body": "The code LGTM. Another issue that caught my mind in the process, but isn't exactly related, is #20584.",
    "created_at": "2016-05-10T20:24:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198271",
    "user": "https://github.com/darijgr"
}
```

The code LGTM. Another issue that caught my mind in the process, but isn't exactly related, is #20584.



---

archive/issue_comments_198272.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-05-10T20:25:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198272",
    "user": "https://github.com/darijgr"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_015038.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2016-05-17T07:16:50Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15384#event-15038"
}
```



---

archive/issue_comments_198273.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-05-17T07:16:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15384",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15384#issuecomment-198273",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
