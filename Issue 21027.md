# Issue 21027: Factoring and Irreducibility Related Methods in Skew Polynomials

Issue created by migration from Trac.

Original creator: arpitdm

Original creation time: 2016-08-17 11:23:33

CC:  tscrim caruso jsrn dlucas vbraun

We propose the addition of the following methods and classes to skew polynomials: 

1. def random_irreducible in `class SkewPolynomialRing_general` in `skew_polynomial_ring.py`

2. Following functions to the `class SkewPolynomial_finite_field_dense`:
- def is_irreducible
- def bound
- def type
- cdef SkewPolynomial_finite_field_dense _rdivisor_c
- def irreducible_divisor
- def irreducible_divisor_with_norm
- def irreducible_divisors
- def _irreducible_divisors
- def count_irreducible_divisors
- cdef _factor_c
- cdef _factor_uniform_c
- def factor(self,distribution=None):
- def count_factorizations(self):
- def count_factorisations(self):
- def factorizations
- def factorisations

Note: The original ticket #13215 first introduced this functionality. That was subsequently modified to support the basic implementation of skew polynomials and the factoring and irreducibility related methods from that ticket that were removed are being reintroduced here.


---

Comment by arpitdm created at 2016-08-17 11:27:56

Please also note that the current code is more or less just what was in the original patch for #13215 related to Factoring and Irreducibility methods. No effort has been made yet to accommodate for changes in #13215 since this addition was factored out.


---

Comment by caruso created at 2020-04-03 19:04:04

Where is the code of this ticket?

Should I copy it from https://trac.sagemath.org/attachment/ticket/13215/trac_13215_skew_polynomials.patch or can I find it somewhere on git?


---

Comment by caruso created at 2020-04-04 09:14:48

OK, I found it.
----
Last 10 new commits:


---

Comment by git created at 2020-04-10 21:07:38

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2020-04-14 12:20:18

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2020-04-15 13:11:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-16 12:10:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2020-04-16 12:13:21

Changing status from new to needs_review.


---

Comment by git created at 2020-04-16 14:18:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-04-17 00:19:59

Can you rebase the branch off #21262 so the commits/changes specific to this ticket are easier to review?

Also there are added functions in `skew_polynomial_element.pyx` that do not have doctests and formatting should be

```
- some really long text that needs to be wrapped on
  multiple lines should have the text start on the
  same line as the first character that is not the
  bullet point/number
```



---

Comment by caruso created at 2020-04-17 09:15:17

> Can you rebase the branch off #21262 so the commits/changes specific to this ticket are easier to review?

I tried to do it but it fails. So I create a new branch and push my changes on top of ticket #21262.


---

Comment by git created at 2020-04-17 13:42:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-04-17 15:40:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-04-21 01:37:09

Thank you, that helped a lot. It looks good and quite impressive. However, I do have a few comments:

In `_left_lcm_cofactor`, is `while not V3.is_zero():` faster than `while not V3:`? Experience tells me the latter is nearly always faster. Also would it make sense to have this be an inlined cdef function? Could you specify the types of some of the variables there (you can do this in `def` methods too)? Same comment for the `_right_lcm_cofactor`.

Could `_reduced_norm_factored` also be an inlined cdef method? Same for all of the other hidden methods like `_irreducible_divisors` (possibly not inlined)?

I would do it like this in `type` to make it more clear what the loop is testing:

```diff
+            d = self.right_gcd(NS)
+            deg = d.degree() / degN
+            while deg == 0:
-            while True:
-                d = self.right_gcd(NS)
-                deg = d.degree()/degN
-                if deg == 0:
-                    break
                 if m >= 0:
                     if deg == 1:
                         type += m * [1]
                         break
                     m -= deg
                 self = self // d
                 type.append(deg)
+                d = self.right_gcd(NS)
+                deg = d.degree() / degN
```

Can you also specify the type of some of the variables, like the lists? This should make the C code cleaner and offer some micro speedups (especially if you use `type.extend(m * [1])` instead of `type += m * [1]`). Also, since the result is cached, you should ultimately make it a tuple (or some other immutable object).

Why do you initialize `_types` to be `None` instead of an empty dict? It seems like a reasonable thing to do and have an `__init__` method to me.

This syntax is somewhat deprecated `for j from 0 <= j < e:` -> `for j in range(e):`.

The following are all for `_rdivisor_c`:

I think it be faster to do:

```diff
-Integer((E.cardinality()-1)/2)
+<Integer>( (E.cardinality()-1) // 2 )
```


Rather than compute `lM` and then take the transpose, I think it would be must better to construct directly in transpose form (which requires a little more computation, but I think it is faster).

I would pull the `if skew_ring.characteristic() == 2:` test outside of the `while` loop and store it as a boolean variable. In that case you can also do `zz = yy` to avoid an extra function call.

Back to general comments: It would be nice to be more PEP8 compliant and have things like `if P1.degree() == degN: break` on 2 lines IMO.

I would restructure the last part fo `left_irreducible_factor` as:

```python
        if not uniform:
            LD = P1 // P1.right_gcd(NS // D)
            if LD.degree() == degN:
                return LD
        while True:
            R = skew_ring.random_element((deg,deg))
            if NS.right_gcd(R) == 1: break
        D = NS.right_gcd(D*R)
        LD = P1 // P1.right_gcd(NS // D)
        if LD.degree() == degN:
            return LD
```

Yes, there is some code repetition, but it make the overall logic easier IMO.

In `_factor_uniform_c`, you know `type[0]` is an `int`, so I would explicitly make that cast `if <int>(type[0]) > 1:` to simplify the C code. Actually, you might want to locally make the `type` variable an array of `int`s to not have to do these casts everywhere and speedup element access. For the `q_jordan`, why is `maxtype` being converted to a partition? This is not needed for the function AFAICS. (Side note, this might be a good reason to consider Cythonizing these low-level but important combinatorial objects.)

`while 1:` -> `while True:`

In `factor`:

```diff
         - ``uniform`` -- a boolean (default: ``False``); whether the 
-        output irreducible divisor should be uniformly distributed
-        among all possibilities
+          output irreducible divisor should be uniformly distributed
+          among all possibilities
```

Also `sig_on` and `sig_off` should not contain Python code I believe. Just put it around the `self._factor_c()` call.

Also, our convention is the 1-line descriptions should end with a period/full-stop.


---

Comment by git created at 2020-04-21 16:17:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2020-04-21 16:17:55

I think I addressed all your remarks.


---

Comment by tscrim created at 2020-04-22 00:42:14

Thank you. So I have gotten a look at the C code and did another pass, and I have a few more comments. I think this will be the last batch.

Could you separate the main part of `right_quo_rem` (and same for the left) into a `cdef` that assumes an input in the parent? This should improve the C code in `_left_lcm_cofactor` (same for the right).

Instead of calling `N.parent()`, you can you the (inline) C function `parent(N)`.

I think this could be simplified in `type()`:

```diff
-i = [ n for n,_ in self._norm_factor ].index(N)
-m = self._norm_factor[i][1]
+m = -1
+for n, mp in self._norm_factor:
+    if n == N:
+        m = mp
+        break
```

This way you don't create a whole new list and have to iterate through the entire `self._norm_factor` nor obtain the index again.

It would be nice to put the imports

```
from sage.matrix.matrix_space import MatrixSpace
from sage.matrix.matrix2 import NotFullRankError
```

at the top-level. I guess this is the import loop we had on the other ticket? I still need to fix that...

I guess we don't know anything about the type of `N` in `_rdivisor_c`, correct?

In this line, do you really need to create a new list?

```
X = <SkewPolynomial_finite_field_dense>Q._new_c(Q._coeffs[:],Q._parent)
```

If so, then I think it is better to do `list(Q._coeffs)`.

I still think the `M = MatrixSpace(E,e,e)(lM).transpose()` is relatively expensive and could be avoided. For example:

```python
lM = [None] * e**2
for j in range(e):
    for i in range(e):
        coeffs = [skew_ring._retraction(X[t*r+i]) for t in range(d)]
        value = E(coeffs)
        lM[i*e+j] = value
```



```diff
-xx = PE(W.list() + [E(-1)])
+xx = PE((<list> W.list()) + [E(-1)])
```


I think instead of `mul = lambda a,b: a*b` and for the other in `_irreducible_divisors`, it would be better to have little inline cdef functions `lmul` and `rmul` (say in the `pxd` file) that you set `mul` to. This seems to make the C code better.

This is impossible: `if len(a) < 0:`. Did you mean `if len(a) == 0`, in which case it is faster to just do `if not a:`?

I am not 100% sure that this is safe:

```
cdef RingElement unit = <RingElement>self.leading_coefficient()
```

Is it possible to have something over a commutative base ring that whose elements are not a `RingElement`? There are such things, like the ring of symmetric functions (granted, this is not a finite field, but merely to point out such things can exists within Sage). There might not be any benefit for specifying the type here.

Take advantage of the caching:

```diff
-skew_ring(1)
+skew_ring.one()
```


So you don't have to create an intermediate object:

```diff
-cdef list indices = list(Permutations(len(factorsN)).random_element())
+from sage.misc.prandom import sample  # Do this import at the top level\
+m = len(factorsN)
+cdef list indices = <list> sample(range(1,m+1), m))
```


Missed one:

```diff
-maxcount = q_jordan(Partition(maxtype),cardE)
+maxcount = q_jordan(maxtype, cardE)
```



---

Comment by git created at 2020-04-23 13:01:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2020-04-23 13:22:17

Replying to [comment:22 tscrim]:
> Could you separate the main part of `right_quo_rem` (and same for the left) into a `cdef` that assumes an input in the parent? This should improve the C code in `_left_lcm_cofactor` (same for the right).

It's done, I think. Please tell me if I've implemented correctly what you had in mind.

I tried to call the methods `_left_quo_rem` and `_right_quo_rem` in `_irreducible_divisors` but the following lines fail:

```
    quo_rem = SkewPolynomial_finite_field._right_quo_rem
    quo_rem2 = SkewPolynomial_finite_field._left_quo_rem
```

I don't know why exactly.

> It would be nice to put the imports
> {{{
> from sage.matrix.matrix_space import MatrixSpace
> from sage.matrix.matrix2 import NotFullRankError
> }}}
> at the top-level. I guess this is the import loop we had on the other ticket? I still need to fix that...

Yes, it creates import errors. And indeed, it would be nice to fix it.

> I guess we don't know anything about the type of `N` in `_rdivisor_c`, correct?

Well, it's a polynomial. So probably an instance of the generic class `Polynomial` (or maybe even `Polynomial_generic_dense`) but I'm not sure it will always be the case.

Another point: From time to time, I got errors with `sig_on()` and `sig_off()`, e.g.:

```
sage: k.<a> = GF(5^4)
sage: Frob = k.frobenius_endomorphism(2)
sage: S.<x> = k['x', Frob]
sage: P = x^2 + a + a^25
sage: P.factor()
Traceback (most recent call last):
...
SystemError: calling remove_from_pari_stack() inside sig_on()
```

So, I've removed them and added a call to `sig_check()` in the methods `_left_quo_rem` and `_right_quo_rem` (which are called repeatedly by all nontrivial algorithms). Is this okay?


---

Comment by tscrim created at 2020-04-24 02:33:43

Replying to [comment:24 caruso]:
> Replying to [comment:22 tscrim]:
> > Could you separate the main part of `right_quo_rem` (and same for the left) into a `cdef` that assumes an input in the parent? This should improve the C code in `_left_lcm_cofactor` (same for the right).
> 
> It's done, I think. Please tell me if I've implemented correctly what you had in mind.
> 
> I tried to call the methods `_left_quo_rem` and `_right_quo_rem` in `_irreducible_divisors` but the following lines fail:
> {{{
>     quo_rem = SkewPolynomial_finite_field._right_quo_rem
>     quo_rem2 = SkewPolynomial_finite_field._left_quo_rem
> }}}
> I don't know why exactly.

So I think it is because Cython doesn't know that those should be function pointers and will have the same signature. You might be able to make them actual function pointers since you know everything is the correct type. However, I am not sure exactly how to do this as Cython tutorials don't seem to talk much about how to do function pointers, much less with cdef methods.

> > It would be nice to put the imports
> > {{{
> > from sage.matrix.matrix_space import MatrixSpace
> > from sage.matrix.matrix2 import NotFullRankError
> > }}}
> > at the top-level. I guess this is the import loop we had on the other ticket? I still need to fix that...
> 
> Yes, it creates import errors. And indeed, it would be nice to fix it.

This is now #29561, which fixes the import loop when I tested it.

> > I guess we don't know anything about the type of `N` in `_rdivisor_c`, correct?
> 
> Well, it's a polynomial. So probably an instance of the generic class `Polynomial` (or maybe even `Polynomial_generic_dense`) but I'm not sure it will always be the case.

That's fine. I just wanted to ask to see if I was missing something.

> Another point: From time to time, I got errors with `sig_on()` and `sig_off()`, e.g.:
> {{{
> sage: k.<a> = GF(5^4)
> sage: Frob = k.frobenius_endomorphism(2)
> sage: S.<x> = k['x', Frob]
> sage: P = x^2 + a + a^25
> sage: P.factor()
> Traceback (most recent call last):
> ...
> SystemError: calling remove_from_pari_stack() inside sig_on()
> }}}
> So, I've removed them and added a call to `sig_check()` in the methods `_left_quo_rem` and `_right_quo_rem` (which are called repeatedly by all nontrivial algorithms). Is this okay?

I am pretty certain that is okay. Although I am not such a Cython expert to say it is surely correct.


---

Comment by caruso created at 2020-04-25 13:07:23

Replying to [comment:24 caruso]:
> I tried to call the methods `_left_quo_rem` and `_right_quo_rem` in `_irreducible_divisors` but the following lines fail:
> {{{
>     quo_rem = SkewPolynomial_finite_field._right_quo_rem
>     quo_rem2 = SkewPolynomial_finite_field._left_quo_rem
> }}}
> I don't know why exactly.

It's really weird. It really looks like a bug in a cython compiler. For instance,

```
    quo_rem = SkewPolynomial_finite_field.right_quo_rem
    quo_rem2 = SkewPolynomial_finite_field._left_quo_rem
```

sometimes works... but not always. (And I couldn't figure out on what it depends.)


---

Comment by git created at 2020-04-25 13:13:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-04-26 04:41:13

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2020-04-26 04:41:13

Replying to [comment:26 caruso]:
> Replying to [comment:24 caruso]:
> > I tried to call the methods `_left_quo_rem` and `_right_quo_rem` in `_irreducible_divisors` but the following lines fail:
> > {{{
> >     quo_rem = SkewPolynomial_finite_field._right_quo_rem
> >     quo_rem2 = SkewPolynomial_finite_field._left_quo_rem
> > }}}
> > I don't know why exactly.
> 
> It's really weird. It really looks like a bug in a cython compiler. For instance,
> {{{
>     quo_rem = SkewPolynomial_finite_field.right_quo_rem
>     quo_rem2 = SkewPolynomial_finite_field._left_quo_rem
> }}}
> sometimes works... but not always. (And I couldn't figure out on what it depends.)

That is strange. Well, I think that can be a mystery for another day for additional optimization. I have done everything I can see is natural to do. Thank you for caring care of all of those changes.


---

Comment by caruso created at 2020-04-26 09:22:28

Great!

Since, I merged #29561 in this ticket, I think it's better if I give a positive review to #29561 right now. We will see later for pyflakes issues.


---

Comment by git created at 2020-05-07 15:41:57

Changing status from positive_review to needs_review.


---

Comment by git created at 2020-05-07 15:41:57

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by caruso created at 2020-05-07 15:42:51

Conflict resolved.


---

Comment by caruso created at 2020-05-07 15:42:51

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2020-06-03 23:50:31

Hi Volker, is there some reason this hasn't yet been merged in? All of the dependency tickets were closed (I removed them in case that is causing some issues with your scripts).


---

Comment by vbraun created at 2020-06-21 22:37:20

Resolution: fixed
