# Issue 28932: Maximal and critical angles for cones

Issue created by migration from https://trac.sagemath.org/ticket/29169

Original creator: mjo

Original creation time: 2020-02-09 00:40:28

CC:  jipilab novoselt tscrim chapoton

My paper with two algorithms for finding the maximal/critical angles between polyhedral convex cones was accepted:

  http://www.optimization-online.org/DB_HTML/2019/01/7048.html

I've already written these algorithms in sage, so it would be nice to add them to the library. I just need to clean up some of the documentation.



---

Comment by mjo created at 2020-02-09 01:38:27

Work in progress on `u/mjo/ticket/29169`. Doesn't build or anything yet.


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by jipilab created at 2020-04-20 10:01:47

New commits:


---

Comment by git created at 2020-06-23 13:31:25

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-06-23 17:24:57

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2020-06-23 17:42:09

I can keep tweaking the documentation forever, but I think this is in good condition to get some third-party feedback.


---

Comment by mjo created at 2020-06-23 17:42:09

Changing status from new to needs_review.


---

Comment by mjo created at 2020-06-23 17:43:22

(You can check the docs with `sage -docbuild --include-tests-blocks --underscore`)


---

Comment by chapoton created at 2020-06-24 06:55:52

* dependency field was missing #
* Author field is empty


---

Comment by chapoton created at 2020-06-24 20:16:47

patchbot complains about coverage and unused import


---

Comment by git created at 2020-06-25 03:01:51

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2020-06-25 03:05:42

The unused import was legit (and is now fixed), but the coverage warning is for the `critical_angles` and `max_angle` functions that are wrapped by the methods of the same name in the cone class. All of the documentation (and unit tests) is on the cone methods, because that's what people will use.

(I can add some trivial tests if a happy coverage report is worth it, but so far I have avoided it as it's a complete waste of CPU time.)


---

Comment by chapoton created at 2020-06-25 08:22:51

I think that coverage is mandatory, sorry. Very simple tests would do, and you can tag them with `#indirect doctest` if they do not use the method directly.

More annoying, the latest patchbot reports a `Timed Out`, which is not acceptable.


---

Comment by git created at 2020-06-27 01:46:16

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2020-06-27 01:52:33

I think that will make patchbot happy. I added some trivial tests where they were absent, and fixed the timeout issue (fingers crossed) by adding `# long time` in a bunch of places and reducing the max test size in others.


---

Comment by @kliem created at 2020-09-08 06:18:37

I'm willing to review this, but I'd much rather go through it one by one.
Is it possible to implement the functions one by one?

I didn't check, maybe it all depends on each other.


---

Comment by mjo created at 2020-09-08 12:51:20

They're largely intertwined, but I could still commit some of the helper functions individually if that would make reviewing easier.

The reason for all of the separate functions (and the size of the module) is that `critical_angles` and `max_angle` do a lot of the same stuff. The max angle is a critical angle -- so `critical_angles` will find it -- but if all we're looking for is the biggest one then we can bail out as soon as we find it. That makes `max_angle` faster, but naturally the two share a lot of code, all of which I've tried to factor out into sensibly-named helper functions.

Once I defined the helper functions, they needed docstrings, tests, and examples.... meaning that a lot of relatively trivial things shared between `critical_angles` and `max_angle` take up a page or two of code. The `inverse_spd` function, for example, is two lines of implementation and a page of docs. If only one of `critical_angles` or `max_angle` were present, all of those functions would be inlined. Some of them make sense out of context, but others like `check_gevp_feasibility` are 100% tied to the implementation of `critical_angles` and `max_angle`, and are separate only to avoid copy/pasting their code.


---

Comment by @kliem created at 2020-09-08 12:54:11

Ok. I think I can also just look at the helper functions and work my way up.


---

Comment by @kliem created at 2020-09-16 12:52:16

- Totally minor: If your in this situation, your cone is probably the trivial cone or the ambient space for real. It sounds like you claim that it isn't:


```diff
-            raise ValueError("this cone cannot be trivial or the ambient space")
+            raise ValueError("the cone may not be trivial or the ambient space")
```


  or just delete the "this"

Other than this, the changes to `src/sage/geometry/cone.py` seem fine to me.


---

Comment by mjo created at 2020-09-17 12:45:47

I see what you're saying, but in informal English I think "may not" suffers from the same problem. Likewise for "must not". How about "the cone should not be..."? I have been unable to trick my brain into reading that incorrectly =)


---

Comment by @kliem created at 2020-09-18 06:07:32

`the cone should not be` is fine. I wouldn't want to worry about it too much.


---

Comment by @kliem created at 2020-09-18 08:44:57

- `inverse_spd`: Wouldn't that fit better into `matrix/matrix2.pyx`. This is where `cholesky` is defined.
- `_normalize_gevp_solution`: Fine.
- This error message is a full sentence.

```diff
+        ValueError: The ambient dimension must be a positive integer (there
+        are no nontrivial cones in dimension 0).
```

  I think just the part in the parenthesis would be a fine error message.

  otherwise `_random_admissible_cone` is fine
- 

```diff
+    # The standard cone containment tests don't work with normalized
+    # vectors in QQbar.
+    u_is_in_P = all( g.inner_product(u) >= 0 for g in P.dual() )
+    v_is_in_Q = all( h.inner_product(v) >= 0 for h in Q.dual() )
```

  I would propose fixing this.

```
sage: 3/2*vector([1,-1,0]) in P                                                                                                                                                     
True
sage: QQbar(2).sqrt()*vector([1,-1,0]) in P  
... # very long traceback
ValueError: Cannot coerce non-integral Algebraic Real 1.414213562373095? to Integer
```

  This is awful and inconsistent. There is no way you can convert the point `[3/2, -3/2, 0]` to be a lattice point.
  According to the documentation it should have returned `False`.
  I would propose fixing this as a dependency of this ticket:
  - outsource `dual_rays` or similar from `dual`
  - use `dual_rays` to improve `_contains` to behave coercion-like with your code
  - then you can just compute `u in P`.
  
  If I ask whether a rational or real algebraic point is contained in a cone, I want coercion.
  
  The second thing: `all( z.inner_product(h) >= 0 for h in Q )` could then be reduced to `z in Q.dual()` (which is a bit wasteful, but not more than the current state). This could be exposed somehow as well as this is the general question whether `Q` satisfies some inequality, but that is probably not a priority.

- `gevp_licis` not fast, but if the time of running this is not relevant, it should be fine.


---

Comment by @kliem created at 2020-09-18 08:49:52

In examples you define this `G_index_sets = list(gevp_licis(G))` without ever using it or printing it.


---

Comment by mjo created at 2020-09-18 12:49:42

Replying to [comment:24 gh-kliem]:
>   
> This is awful and inconsistent... If I ask whether a rational or real algebraic point is contained in a cone, I want coercion.
>   

Me too, but I anticipate that Andrey will object. The cone module is fairly strict; if you want to do anything "dirty," you have to leave the lattice and move to your own vector space. You've probably seen this in other tickets of mine where I have to throw away the lattice structure of (say) a dual cone to be able to treat its rays as objects in the primal space. It's often annoying, but it's consistent within the cone module. And it's technically correct, even from the convex analysis/geometry perspective, so long as you use the traditional definition of "dual cone" where the elements lie in a dual vector space. So I've learned to live with it.

In either case, you are right that it should return `False` as documented.


---

Comment by git created at 2020-09-18 12:51:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @kliem created at 2020-09-18 13:00:25

How about `def contains(self, coerce=False)` or similar. So Andrey can have his way, but we are still not creating copies of stuff at places where they do not belong.

It's still strange that it would accept a vector but not a point in the dual lattice as input.

In a way it makes sense:

```
sage: 2 in range(2,5)                                                                                                                                                                                                                                                                                                                                                      
True
sage: 2.5 in range(2,5)                                                                                                                                                                                                                                                                                                                                                    
False
```

This is completely natural and I can see that you want this behavior for a cone. However, the other question should still be accessible. As you cannot change the base ring of a cone (can you?) it would be nice for the cone to provide some answer for you.

Replying to [comment:26 mjo]:
> Replying to [comment:24 gh-kliem]:
> >   
> > This is awful and inconsistent... If I ask whether a rational or real algebraic point is contained in a cone, I want coercion.
> >   
> 
> Me too, but I anticipate that Andrey will object. The cone module is fairly strict; if you want to do anything "dirty," you have to leave the lattice and move to your own vector space. You've probably seen this in other tickets of mine where I have to throw away the lattice structure of (say) a dual cone to be able to treat its rays as objects in the primal space. It's often annoying, but it's consistent within the cone module. And it's technically correct, even from the convex analysis/geometry perspective, so long as you use the traditional definition of "dual cone" where the elements lie in a dual vector space. So I've learned to live with it.
> 
> In either case, you are right that it should return `False` as documented.


---

Comment by novoselt created at 2020-09-18 15:09:21

Replying to [comment:28 gh-kliem]:
> It's still strange that it would accept a vector but not a point in the dual lattice as input.

For any vector space with a basis it is quite natural to have conversion from the set of numbers, i.e. a vector from `ZZ^n` to that vector space. And the backward map is fairly natural as well. However a composition of such maps does not give a natural map between two vector spaces with chosen bases. On that ground dual lattice elements are not accepted as points in the primal lattice. And the reason why this particular case is explicitly prohibited is that it is a fairly common mistake in toric geometry to work with elements/cones of the wrong lattice, so it helps to catch mistakes. Volker's alternative code was actually having completely unrelated classes for a lattice and its dual to make sure that there is no conversion/coercion happening between them.

So I am strongly against changing this behaviour in any situation. Having explicit non-default way to mix lattices is perfectly fine, of course.


---

Comment by novoselt created at 2020-09-18 15:16:28

Regarding checking rational/algebraic/float vectors for cone containment - it would be nice for it to work. The problem is, I guess, how to write down the check. For my purposes working with rational numbers was always sufficient and it has the advantage of exact computations, so no need to worry about precision issues. If you can add code to handle more cases - please do it and it has nothing to do with distinction between dual lattices!


---

Comment by mkoeppe created at 2020-09-18 16:05:38

Replying to [comment:29 novoselt]:
> [...] dual lattice elements are not accepted as points in the primal lattice. And the reason why this particular case is explicitly prohibited is that it is a fairly common mistake in toric geometry to work with elements/cones of the wrong lattice, so it helps to catch mistakes. Volker's alternative code was actually having completely unrelated classes for a lattice and its dual to make sure that there is no conversion/coercion happening between them.

As a side remark, a weakness of the vector space / free module code in `sage.modules` is that dual spaces / modules are not implemented. The newer code in `sage.tensor.modules` fixes this, and it would be a great improvement if `sage.geometry.cone` and `sage.geometry.toric_lattice` could integrate with that.


---

Comment by mjo created at 2020-09-18 20:32:46

Replying to [comment:30 novoselt]:
> If you can add code to handle more cases - please do it and it has nothing to do with distinction between dual lattices!

I was mainly worried about being able to take, say, `M(1,1)` and (through coercion) come to the conclusion that it lives in the nonnegative quadrant of the lattice `N`. But thanks to some implementation details, that appears not to be a problem. I'll post something soon.


---

Comment by novoselt created at 2020-09-19 03:08:38

Replying to [comment:31 mkoeppe]:
> As a side remark, a weakness of the vector space / free module code in `sage.modules` is that dual spaces / modules are not implemented. The newer code in `sage.tensor.modules` fixes this, and it would be a great improvement if `sage.geometry.cone` and `sage.geometry.toric_lattice` could integrate with that.

Thank you so much for the pointer! I surely wished for this when I was implementing toric stuff.


---

Comment by git created at 2020-09-19 16:24:41

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2020-09-28 14:25:31

Changing status from needs_review to needs_work.


---

Comment by mjo created at 2020-09-28 14:25:31

I'll need to rebase this again once #30654 is reviewed.


---

Comment by git created at 2020-09-29 14:59:05

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2020-09-29 15:00:53

Cherry-picked the two commits from #30654, and replaced the `inverse_spd` function with the `inverse_positive_definite` method.


---

Comment by mjo created at 2020-09-29 15:00:53

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2020-11-01 18:06:25

red branch => needs work


---

Comment by chapoton created at 2020-11-01 18:06:25

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-11-03 14:55:44

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2020-11-03 14:57:05

Changing status from needs_work to needs_review.


---

Comment by mjo created at 2020-11-03 14:57:05

Needed a rebase, I think.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by git created at 2021-12-02 00:09:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mkoeppe created at 2022-03-04 06:24:45

Typo: `greather` -> `greater`


---

Comment by mkoeppe created at 2022-03-04 06:28:52

Wondering if there shouldn't be a variant of these methods that returns the tan of the angle rather the angle. Could one then expect that the output would be rational for rational input?


---

Comment by mkoeppe created at 2022-03-04 06:29:59

Another typo: `constuct` -> `construct`.

Run `tox -e codespell`?


---

Comment by mkoeppe created at 2022-03-04 06:35:07

Replying to [comment:50 mkoeppe]:
> Wondering if there shouldn't be a variant of these methods that returns the tan of the angle rather the angle. Could one then expect that the output would be rational for rational input?

Or, in the methods that return a witness pair of angles, just do not output the angle, as it is trivial to recover?

This would eliminate the dependency on `sage.symbolic` (for #32432)


---

Comment by mkoeppe created at 2022-03-04 06:38:05

Also there seems to be no doctest for `exact=False`


---

Comment by mkoeppe created at 2022-03-04 06:45:37

I'd suggest to get rid of `_lists_equivalent` and just write `set(l1) == set(l2)`


---

Comment by mkoeppe created at 2022-03-04 06:48:46

Perhaps `_solve_gevp_naive` and `solve_gevp_nonzero` should be generators?


---

Comment by git created at 2022-03-06 21:03:12

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2022-03-06 21:06:17

Replying to [comment:54 mkoeppe]:
> I'd suggest to get rid of `_lists_equivalent` and just write `set(l1) == set(l2)`

Doesn't work when the lists contain (mutable, not-hashable) vectors unfortunately. I also tried sage's `Set()` in case I had overlooked that originally but it's not checking equality element-wise.

I fixed the typos and converted those methods to generators. I'll add tests for `exact=False` when I get a chance.


---

Comment by mkoeppe created at 2022-03-06 21:13:40

Replying to [comment:57 mjo]:
> Doesn't work when the lists contain (mutable, not-hashable) vectors unfortunately.

Perhaps just change the code so it creates immutable vectors?


---

Comment by mjo created at 2022-03-07 01:02:48

Replying to [comment:58 mkoeppe]:
> 
> Perhaps just change the code so it creates immutable vectors?

That _still_ doesn't work because


```
sage: set([AA(0)]) == set([ZZ(0)])
False
```


The `_lists_equivalent` function is used to compare eigenvalue/vector results coming from three different places, two of which use `extend=True` and can "silently" jump from e.g. the rationals to the algebraic field. I could probably get them all to return eigenvalues in the same field, but it really doesn't matter for the tests. It's a lot easier to compare them with `==` than it would be to make the tests or the functions themselves more complicated.


---

Comment by git created at 2022-03-07 01:02:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2022-03-07 13:46:49

Replying to [comment:52 mkoeppe]:
> Replying to [comment:50 mkoeppe]:
> > Wondering if there shouldn't be a variant of these methods that returns the tan of the angle rather the angle. Could one then expect that the output would be rational for rational input?
> 
> Or, in the methods that return a witness pair of angles, just do not output the angle, as it is trivial to recover?
> 
> This would eliminate the dependency on `sage.symbolic` (for #32432)
> 

This makes some engineering sense, but I'd prefer to keep the nice interface (e.g `max_angle` versus `min_cos_of_angle`). The internal functions could easily be reworked, but in the user-facing portion, I think we should give people what they're actually looking for and not make them compute it themselves (which would require `sage.symbolic` anyway).


---

Comment by mkoeppe created at 2022-03-07 17:37:11


```
+            raise ValueError('eigenspace of dimension %d > 1 '
+                             'corresponding to eigenvalue %s'
+                              % (mult, cos_theta))
```

Shouldn't this be a `NotImplementedError`?


---

Comment by mkoeppe created at 2022-03-07 17:49:29

`gevp_licis` can be replaced by `sage.matroids.linear_matroid.LinearMatroid(G).independent_sets()`


---

Comment by mkoeppe created at 2022-03-07 18:12:24


```
+    if exact:
+        ring = QQbar
```

Do you really need `QQbar` or is `AA` enough?


---

Comment by git created at 2022-03-08 00:25:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2022-03-08 00:32:11

Replying to [comment:62 mkoeppe]:
> Shouldn't this be a `NotImplementedError`?

IIRC I checked the python docs for `NotImplementedError` and thought some other error would be more accurate. It's not that we've chosen not to implement this; rather, we encountered a value that we don't know how to handle while performing some other computation. If you prefer `NotImplementedError` though I don't care all that much.


> `gevp_licis` can be replaced by `sage.matroids.linear_matroid.LinearMatroid(G).independent_sets()`

Not entirely, but the latter gives a much faster implementation, thanks! I also added some docs stating that our subsets need to be ordered similarly. It's in the paper but wasn't in the code.


> Do you really need `QQbar` or is `AA` enough? 

I don't remember why I wrote it that way but I can't find a reason for `QQbar` now, so I've changed it.


---

Comment by mkoeppe created at 2022-03-08 00:48:32


```
+    for I in G_index_sets:
+        G_I = G[range(n),I]
+        I_complement = [ i for i in range(P.nrays()) if not i in I ]
+        G_I_c_T = G[range(n),I_complement].transpose()
+
+        for J in H_index_sets:
+            J_complement = [ j for j in range(Q.nrays()) if not j in J ]
```

I think this code would be slightly cleaner if `I` and `J` were just `frozenset`.
Then you can write `G_I = G[range(n),sorted(I)]` and `I_complement = range(P.nrays()) - I`


---

Comment by mjo created at 2022-03-08 02:19:17

Replying to [comment:67 mkoeppe]:
> 
> I think this code would be slightly cleaner if `I` and `J` were just `frozenset`.
> Then you can write ... `I_complement = range(P.nrays()) - I`

Should that work? I get `unsupported operand type(s) for -: 'range' and 'frozenset'`.

If you meant `frozenset(range(P.nrays()))`, then that would work; still, we'd have to sort the whole thing again to make sure that `I_complement` has the same order as `I` itself (and that we can use it as a matrix index).


---

Comment by mkoeppe created at 2022-03-08 02:27:50

Replying to [comment:68 mjo]:
> If you meant `frozenset(range(P.nrays()))`

I guess that's what I meant


---

Comment by mkoeppe created at 2022-03-09 19:53:32

Replying to [comment:59 mjo]:
> {{{
> sage: set([AA(0)]) == set([ZZ(0)])
> False
> }}}
> 
> The `_lists_equivalent` function is used to compare eigenvalue/vector results coming from three different places, two of which use `extend=True` and can "silently" jump from e.g. the rationals to the algebraic field. 

The doctests could be changed to just compare with the results in the correct field, so that you don't run into the hashing contract violation `hash(AA(0)) == hash(ZZ(0)) => False`.


---

Comment by git created at 2022-03-09 21:24:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2022-03-09 21:33:40

That should do it. Even if the input vectors are rational we convert them to `AA`, and then the resulting matrix is over `AA`, so there's actually not too many options for the eigenvalue field (the other is `RDF`).


---

Comment by mkoeppe created at 2022-03-09 22:23:28

Thanks for making this change!


---

Comment by mkoeppe created at 2022-03-09 22:23:50


```
+Finding the maximal (or equivalently, the minimal) angle between two
```

How is this equivalent?


---

Comment by mjo created at 2022-03-09 23:25:10

Replying to [comment:74 mkoeppe]:
> How is this equivalent?

The minimal angle between `P` and `Q` is pi minus the maximal angle between `P` and `-Q`, akin to how minimizing some real `f` is the same as maximizing `-f` and flipping the result.


---

Comment by mkoeppe created at 2022-03-10 00:04:09

Thanks.


---

Comment by mkoeppe created at 2022-03-10 00:05:18

Does the change to `src/sage/misc/randstate.pyx` belong here on this ticket?


---

Comment by mkoeppe created at 2022-03-10 00:06:23

Looks good to me now, but probably the PEP 8 police may want to have a word


---

Comment by git created at 2022-03-10 01:40:44

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2022-03-10 01:42:52

Replying to [comment:77 mkoeppe]:
> Does the change to `src/sage/misc/randstate.pyx` belong here on this ticket?

Nope, dropped. There's also a commit titled *UNDO ME* that should be dropped before merging, but for now it allows the docs to build.


---

Comment by tscrim created at 2022-03-10 01:45:04

You don't need the `\` here:

```
            if (other.lattice_dim() != self.lattice_dim()):
                raise ValueError("lattice dimensions of self and other "\
                                 "must agree")
            if other.is_trivial() or other.is_full_space():
                raise ValueError("other cone cannot be trivial or the "\
                                 "ambient space")
```

(The parentheses take care of it.)

No period/full-stop at the end of `INPUT:` lines.

In `_normalize_gevp_solution`, do you need to pass the full tuple? I guess this makes the code easier. If so, I would replace `irrelevant` with `ignored`.

No space around the list; e.g.:

```diff
-G_index_sets = [ s for s in gevp_licis(G) if not len(s) == n ]
+G_index_sets = [s for s in gevp_licis(G) if not len(s) == n]
```


Some of your `# long time` are misaligned compared to others in their block (it isn't a big issue, it was just visually jarring for me).


---

Comment by git created at 2022-03-10 02:22:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-03-10 02:23:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-03-17 18:21:50

Replying to [comment:81 mjo]:
> Nope, dropped. There's also a commit titled *UNDO ME* that should be dropped before merging, but for now it allows the docs to build.

Yes, what's up with that?


---

Comment by mjo created at 2022-03-17 19:01:29

Replying to [comment:85 mkoeppe]:
> Replying to [comment:81 mjo]:
> > Nope, dropped. There's also a commit titled *UNDO ME* that should be dropped before merging, but for now it allows the docs to build.
> 
> Yes, what's up with that?

Without it, the docs aren't built for `cone_critical_angles.py`, so there's no way to tell if the syntax/formatting is totally broken. I can remove it if everyone's happy with the rest.
