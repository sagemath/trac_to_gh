# Issue 18704: Poset documentation polishing: chains

Issue created by migration from https://trac.sagemath.org/ticket/18941

Original creator: jmantysalo

Original creation time: 2015-07-22 20:32:29

CC:  tscrim kdilks

Do some polishing to `is_chain_of_poset()`, `maximal_antichains()` and so on at `posets.py`.


---

Comment by jmantysalo created at 2015-07-22 20:54:57

Changing type from enhancement to defect.


---

Comment by jmantysalo created at 2015-07-22 20:54:57

Found a bug -> type changed to defect.

Which one is correct: "Return the chains of the poset.", "Return all the chains of the poset.", "Return all chains of the poset." or "Return chains of the poset."?


---

Comment by jmantysalo created at 2015-07-23 06:32:08

Code for `maximal_chains()` seems complicated. Why not just something like


```
list(P.hasse_diagram().all_paths_iterator(starting_vertices=P.minimal_elements(),
ending_vertices=P.maximal_elements()))
```


Argument `partial` does not seem to used in anywhere, it is just an implementation detail exposed to the user. Can it be removed?


---

Comment by jmantysalo created at 2015-07-23 09:05:27

Changing type from defect to enhancement.


---

Comment by jmantysalo created at 2015-07-23 09:05:27

As deprecation needs a ticket number, it is best to make correction at a new ticket. I opened #18944 for that.


---

Comment by jmantysalo created at 2015-07-23 14:00:12

New commits:


---

Comment by git created at 2015-07-24 11:19:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-24 11:34:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-24 11:46:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-07-24 11:52:41

Ready for review, because I can look at #18944 later. Besides documentation there is one minor code change in `is_chain_of_poset`: I added


```
if not hasattr(elms, '__getitem__'):
    raise TypeError("ordered=True not combatible with type %s for elms" % type(elms))
```



---

Comment by jmantysalo created at 2015-07-24 11:52:41

Changing status from new to needs_review.


---

Comment by git created at 2015-07-24 12:41:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-07-27 07:42:51

Thanks Kevin.

As a side note, there should be a link to `is_antichain_of_poset()` (on [all, including infinite] posets category) in the index of `posets.py`. But I can add it later, when we see if #18534 gets accepted or not.


---

Comment by chapoton created at 2015-07-30 13:52:22

not combatible ?


---

Comment by jmantysalo created at 2015-07-30 21:37:39

Replying to [comment:12 chapoton]:
> not combatible ?

Isn't it a clash if patch A modifies lines N and N+1, and patch B adds a line between the same lines?

But in any case, I can do this later if somebody wants to review #18534. It is two lines long, should I split it to make it easier for reviewers to read...?


---

Comment by chapoton created at 2015-07-31 06:39:27

typo: "combatible" is not an English word


---

Comment by git created at 2015-08-09 14:59:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-08-09 15:01:30

Replying to [comment:14 chapoton]:
> typo: "combatible" is not an English word

Ah, now I see the error. Corrected.


---

Comment by ncohen created at 2015-09-02 13:09:28

Looks good to go, but why do you remove so many doctests of `is_chain_of_poset`?

Nathann


---

Comment by jmantysalo created at 2015-09-02 15:44:44

Replying to [comment:17 ncohen]:
> Looks good to go, but why do you remove so many doctests of `is_chain_of_poset`?

Because I (as always...) didn't think about the code but about the user. They were on `EXAMPLES`-part, and I think they were not all needed to show the idea of the function. Do you want me to add a `TESTS`-part?


---

Comment by ncohen created at 2015-09-02 15:45:51

> Because I (as always...) didn't think about the code but about the user. They were on `EXAMPLES`-part, and I think they were not all needed to show the idea of the function. Do you want me to add a `TESTS`-part?

Yep yep, you can move them to a "TESTS" section if you think they do not bring anything to the user.

Nathann


---

Comment by jmantysalo created at 2015-09-02 15:52:03

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2015-09-02 15:52:03

Replying to [comment:19 ncohen]:
> > Because I (as always...) didn't think about the code but about the user. They were on `EXAMPLES`-part, and I think they were not all needed to show the idea of the function. Do you want me to add a `TESTS`-part?
> 
> Yep yep, you can move them to a "TESTS" section if you think they do not bring anything to the user.

OK, I'll do that. (And hope that `TESTS` will be foldable or hidden part some day.)

I should also add `is_antichain_of_poset()` to `SEEALSO`. As #19078 shows red, I can do this now and correct it later.


---

Comment by git created at 2015-09-03 06:51:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-03 06:59:53

I added some tests. As Macaulay2 has function `dilworthNumber`, I added the synonym to docstring of `widht`; this is non-relating change.

Ready for review. Nathann, remember to change name of the reviewer if you are going to do it.


---

Comment by jmantysalo created at 2015-09-03 06:59:53

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2015-09-03 07:37:28

> I added some tests. As Macaulay2 has function `dilworthNumber`, I added the synonym to docstring of `widht`; this is non-relating change.

Okay.

- You must add a 'the' before 'given' in the description of 'is_chain_of_poset', in the index.

- This should work, and it does not:

```
sage: posets.DiamondPoset(4).is_chain_of_poset(iter([3]),ordered=True)
...
TypeError: ordered=True not compatible with type <type 'listiterator'> for elms
```


You cannot rely on things like the existence of `__getitem__` to deduce something unrelated, like whether the ordering "matters" or not. You can rely on existing standards, but defining one in a patch won't make it true. In particular:


```
sage: Set([1,2,3])[0]
1
```


Say that it only take a list as input or do nothing. TIf the user provides a set and says that the order matters, well, I say that (s)he should be bitten as a result.

Nathann


---

Comment by jmantysalo created at 2015-09-03 07:59:55

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2015-09-03 07:59:55

Replying to [comment:23 ncohen]:
> In particular:
> 
> {{{
> sage: Set([1,2,3])[0]
> 1
> }}}

Duh. So there is no way at all in Python to check if a given container item has fixed order? And in theory `(Set([1,2,3])[1], Set([1,2,3])[1])` could return `(3,2)`. In reality after `P=Poset({'a':[1]})` the command `P.is_chain_of_poset({'a', 1}, ordered=True)` will return `True` or `False` depending on the machine that runs Python.


---

Comment by ncohen created at 2015-09-03 08:02:50

> Duh. So there is no way at all in Python to check if a given container item has fixed order?

What is a 'fixed order' from the point of view of the computer? What you want to know is if the order given is the one *intended* by the user. I don't think that there is a way to do that, neither in this language nor in another. If you want something reliable, test that input is a list, or just trust the user to not do anything stupid.

Nathann


---

Comment by jmantysalo created at 2015-09-03 08:16:45

Replying to [comment:25 ncohen]:
> > Duh. So there is no way at all in Python to check if a given container item has fixed order?
> 
> What is a 'fixed order' from the point of view of the computer? What you want to know is if the order given is the one *intended* by the user.

By fixed order I meant deterministic output. After `x=['a',1]` we always have `x[1]==1` in every implementation of Python. After `y={'a', 1}` we always get error from `y[1]`. After `z=Set(x)` we don't know the output of `z[1]`. (Which sounds odd... "second item of a set"?)

But anyway, thanks. I will change the code. As all kinds of iterables were accepted before, I guess that is the way to continue. And it makes no sense to pick out most common "wrong" types, as it would give false impression of security to the user.


---

Comment by ncohen created at 2015-09-03 08:19:20

> And it makes no sense to pick out most common "wrong" types, as it would give false impression of security to the user.

+1. We should do what we can to help them avoid mistakes, but we can't protect them against themselves.

Nathann


---

Comment by jmantysalo created at 2015-09-03 10:16:07

Replying to [comment:23 ncohen]:

> - This should work, and it does not:
> {{{
> sage: posets.DiamondPoset(4).is_chain_of_poset(iter([3]),ordered=True)
> ...
> TypeError: ordered=True not compatible with type <type 'listiterator'> for elms
> }}}

Arghs. Just noticed that this does not work in Sage even before this patch. It the right correction


```
if not hasattr(elms, '__getitem__'):
    sorted_o = elms
else:
    sorted_o = list(elms)
```


? Or is there still something more to think about?


---

Comment by ncohen created at 2015-09-03 10:24:27

> ? Or is there still something more to think about?

If you want to support any iterable as input, I guess that the best is this


```
sage: elms = range(10)
sage: it1 = iter(elms)
sage: it2 = iter(elms)
sage: it2.next()
0
sage: zip(it1,it2)
[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)]
```


But that's really a lot of infrastructure for a very small impact.

Nathann


---

Comment by ncohen created at 2015-09-03 10:25:57

(not to mention that you have to check whether `it2.next()` yields a `StopIterator` exception)


---

Comment by git created at 2015-09-03 11:06:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-03 11:09:46

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2015-09-03 11:09:46

Replying to [comment:29 ncohen]:

> But that's really a lot of infrastructure for a very small impact.

True. Feels lazy today -> put to needs_review without this. And after all, this ticket was about documentation, which is now polished. (Or at least one more pair of eyes have read it throught.)


---

Comment by tscrim created at 2015-09-03 13:57:58

You could use `sorted` to make deterministic output (in doctests?) (at least since integers has a nice total ordering)...


---

Comment by jmantysalo created at 2015-09-03 17:54:37

Replying to [comment:33 tscrim]:
> You could use `sorted` to make deterministic output (in doctests?) (at least since integers has a nice total ordering)...

No no, this is different thing. The problem is that `Set([1,2])[1]` might return `1` or `2`. Hence it is not meaningful to ask if `Set([1,2])` is an _ordered_ chain of for example `ChainPoset(4)`. But we have no way to check _when_ the user asks something not meaningful.


---

Comment by jmantysalo created at 2015-09-21 15:30:31

`ping -c 1 kevin`...


---

Comment by kdilks created at 2015-09-30 17:15:20

Changing status from needs_review to positive_review.


---

Comment by kdilks created at 2015-09-30 17:15:20

All the changes you made look good to me, positive review.

Two comments related to things I saw while looking through the code (which should probably go in separate tickets):

1) Somebody should finally implement the wrapper that gives you all antichains of a specified size.

2) In `is_chain_of_poset`, I think there should be an additional optional parameter `strict`, so that when `ordered=True`, you can test whether a given list of elements is a weakly increasing chain or a strictly increasing chain. Right now it only tests for strict chains.


---

Comment by jmantysalo created at 2015-09-30 17:54:38

Replying to [comment:36 kdilks]:
> All the changes you made look good to me, positive review.

Thanks!

> Two comments related to things I saw while looking through the code (which should probably go in separate tickets):
> 
> 1) Somebody should finally implement the wrapper that gives you all antichains of a specified size.

True. Same applies to chains of specified size.

> 2) In `is_chain_of_poset`, I think there should be an additional optional parameter `strict`, so that when `ordered=True`, you can test whether a given list of elements is a weakly increasing chain or a strictly increasing chain. Right now it only tests for strict chains.

?? Isn't it just another way? Name of the parameter should propably be `saturated`.


---

Comment by kdilks created at 2015-09-30 18:06:35

`saturated` is something that only applies to strict chains, and it means that all of your elements differ by a covering relation. Using the standard partial (well...total) order on the integers,

`[1,1,2,2,3,3]` is a weak chain.
`[1,3,5,7]` is a strict but not saturated chain.
`[2,3,4,5]` is a strict and saturated chain.

Right now, if `ordered=True`, then it will tell you if your list of elements is a strict but not necessarily saturated chain (in the order given). If `ordered=False`, then it tells you whether the set of elements you give it can be ordered in some way to make a chain.


---

Comment by vbraun created at 2015-10-12 07:16:10

Resolution: fixed
