# Issue 30132: Parallel docbuild, cythonization: Use GNU make's POSIX jobserver protocol

archive/issues_030132.json:
```json
{
    "body": "CC:  @dimpase @orlitzky @jhpalmieri @etn40ff\n\nThe correct way out of the mess with recommending `MAKE='make -j8'` instead of `make -j8` (which we do because of the outdated GNU make 3.81 on macOS - see #21610, #30345) is to use GNU make's POSIX job server protocol - https://www.gnu.org/software/make/manual/html_node/POSIX-Jobserver.html\n\nIssue created by migration from https://trac.sagemath.org/ticket/30369\n\n",
    "created_at": "2020-08-15T13:40:38Z",
    "labels": [
        "build",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "Parallel docbuild, cythonization: Use GNU make's POSIX jobserver protocol",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30132",
    "user": "@mkoeppe"
}
```
CC:  @dimpase @orlitzky @jhpalmieri @etn40ff

The correct way out of the mess with recommending `MAKE='make -j8'` instead of `make -j8` (which we do because of the outdated GNU make 3.81 on macOS - see #21610, #30345) is to use GNU make's POSIX job server protocol - https://www.gnu.org/software/make/manual/html_node/POSIX-Jobserver.html

Issue created by migration from https://trac.sagemath.org/ticket/30369





---

archive/issue_comments_428793.json:
```json
{
    "body": "For example https://github.com/catkin/catkin_tools/blob/master/catkin_tools/execution/job_server.py",
    "created_at": "2020-08-15T13:49:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428793",
    "user": "@mkoeppe"
}
```

For example https://github.com/catkin/catkin_tools/blob/master/catkin_tools/execution/job_server.py



---

archive/issue_comments_428794.json:
```json
{
    "body": "Copying my comment from #30345:\n\nWe're having trouble here because we're conflating two different things. The sage distribution has a top-level makefile that's used to initiate high-level tasks -- in particular installing SPKGs -- convenient to execute. Many of those high-level tasks themselves have build systems, separate from sage, that involve Make. We're passing the distribution's `make` flags down to the individual build systems and trying to coordinate the two as if it was one large build system, but it really isn't.\n\nWhen in doubt, copy Gentoo: our package manager has `--jobs` and `--load-average` arguments that control how many package installation jobs get executed at once. We then also have a `MAKEFLAGS` variable that is passed to the individual build systems. (A better name would be something like `BUILDJOBS`, but the name is historical.) Sage's distribution Makefile can likely always be invoked with `-j1` with no performance penalty; it's the individual build systems that need something like `-j8`.\n\nSo, my suggestion: we copy Gentoo, and create something like a `SAGE_BUILD_JOBS` variable that defaults to `4` (everyone has at least dual-core by now?). We can then document that the top-level `make` need not be invoked with `-j<anything>`, and within that top-level Makefile, we would pass `-j${SAGE_BUILD_JOBS}` to any Make-based SPKG build systems. If we encounter a non-Make build system, we can then still do what the user asked, and pass whatever flags are necessary to run the build with `${SAGE_BUILD_JOBS}` threads.\n\nI think that's less complicated that trying to coordinate the two levels, and doesn't wed us further to GNU's implementation of Make.",
    "created_at": "2020-08-17T12:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428794",
    "user": "@orlitzky"
}
```

Copying my comment from #30345:

We're having trouble here because we're conflating two different things. The sage distribution has a top-level makefile that's used to initiate high-level tasks -- in particular installing SPKGs -- convenient to execute. Many of those high-level tasks themselves have build systems, separate from sage, that involve Make. We're passing the distribution's `make` flags down to the individual build systems and trying to coordinate the two as if it was one large build system, but it really isn't.

When in doubt, copy Gentoo: our package manager has `--jobs` and `--load-average` arguments that control how many package installation jobs get executed at once. We then also have a `MAKEFLAGS` variable that is passed to the individual build systems. (A better name would be something like `BUILDJOBS`, but the name is historical.) Sage's distribution Makefile can likely always be invoked with `-j1` with no performance penalty; it's the individual build systems that need something like `-j8`.

So, my suggestion: we copy Gentoo, and create something like a `SAGE_BUILD_JOBS` variable that defaults to `4` (everyone has at least dual-core by now?). We can then document that the top-level `make` need not be invoked with `-j<anything>`, and within that top-level Makefile, we would pass `-j${SAGE_BUILD_JOBS}` to any Make-based SPKG build systems. If we encounter a non-Make build system, we can then still do what the user asked, and pass whatever flags are necessary to run the build with `${SAGE_BUILD_JOBS}` threads.

I think that's less complicated that trying to coordinate the two levels, and doesn't wed us further to GNU's implementation of Make.



---

archive/issue_comments_428795.json:
```json
{
    "body": "IIRC, Sage cannot be built with a nonGnu make, anyway.\n\nIMHO Gentoo's way looks a bit like a workaround for old buggy Gnu Make.",
    "created_at": "2020-08-17T13:36:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428795",
    "user": "@dimpase"
}
```

IIRC, Sage cannot be built with a nonGnu make, anyway.

IMHO Gentoo's way looks a bit like a workaround for old buggy Gnu Make.



---

archive/issue_comments_428796.json:
```json
{
    "body": "Replying to [comment:2 mjo]:\n> Copying my comment from #30345:\n> \n> We're having trouble here because we're conflating two different things. The sage distribution has a top-level makefile that's used to initiate high-level tasks -- in particular installing SPKGs -- convenient to execute. Many of those high-level tasks themselves have build systems, separate from sage, that involve Make. We're passing the distribution's `make` flags down to the individual build systems and trying to coordinate the two as if it was one large build system, but it really isn't.\n\nNo, the point of the jobserver is that one does NOT have to distinguish these \"two different things\". The jobserver manages the load. \n\nWe do not have a problem with the jobserver. We are careful to pass down the make options to sub-makes. This works.\n\nWe have a problem with the python-based build systems that do not use the jobserver, and this ticket proposes a specific way to solve it.",
    "created_at": "2020-08-17T13:51:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428796",
    "user": "@mkoeppe"
}
```

Replying to [comment:2 mjo]:
> Copying my comment from #30345:
> 
> We're having trouble here because we're conflating two different things. The sage distribution has a top-level makefile that's used to initiate high-level tasks -- in particular installing SPKGs -- convenient to execute. Many of those high-level tasks themselves have build systems, separate from sage, that involve Make. We're passing the distribution's `make` flags down to the individual build systems and trying to coordinate the two as if it was one large build system, but it really isn't.

No, the point of the jobserver is that one does NOT have to distinguish these "two different things". The jobserver manages the load. 

We do not have a problem with the jobserver. We are careful to pass down the make options to sub-makes. This works.

We have a problem with the python-based build systems that do not use the jobserver, and this ticket proposes a specific way to solve it.



---

archive/issue_comments_428797.json:
```json
{
    "body": "Replying to [comment:3 dimpase]:\n> IIRC, Sage cannot be built with a nonGnu make, anyway.\n\nThe Makefiles generated by autotools are POSIX compatible, it's only the hand-written Makefiles that are a problem. We generate those with a bootstrap script anyway, so at least in theory it would be possible to coerce them into being POSIX compatible.\n \n> IMHO Gentoo's way looks a bit like a workaround for old buggy Gnu Make.\n\nIt's just a way to let users specify how many jobs should be used to build each package in a source-based distribution. The number of packages that will be installed simultaneously is something else. Our situation isn't much different, except that the \"package manager\" is also Make.",
    "created_at": "2020-08-17T14:02:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428797",
    "user": "@orlitzky"
}
```

Replying to [comment:3 dimpase]:
> IIRC, Sage cannot be built with a nonGnu make, anyway.

The Makefiles generated by autotools are POSIX compatible, it's only the hand-written Makefiles that are a problem. We generate those with a bootstrap script anyway, so at least in theory it would be possible to coerce them into being POSIX compatible.
 
> IMHO Gentoo's way looks a bit like a workaround for old buggy Gnu Make.

It's just a way to let users specify how many jobs should be used to build each package in a source-based distribution. The number of packages that will be installed simultaneously is something else. Our situation isn't much different, except that the "package manager" is also Make.



---

archive/issue_comments_428798.json:
```json
{
    "body": "Replying to [comment:5 mjo]:\n> It's just a way to let users specify how many jobs should be used to build each package in a source-based distribution. The number of packages that will be installed simultaneously is something else. Our situation isn't much different, except that the \"package manager\" is also Make.\n\nUsers should have no reason to be interested in this distinction. All that matters is throughput.",
    "created_at": "2020-08-17T14:03:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428798",
    "user": "@mkoeppe"
}
```

Replying to [comment:5 mjo]:
> It's just a way to let users specify how many jobs should be used to build each package in a source-based distribution. The number of packages that will be installed simultaneously is something else. Our situation isn't much different, except that the "package manager" is also Make.

Users should have no reason to be interested in this distinction. All that matters is throughput.



---

archive/issue_comments_428799.json:
```json
{
    "body": "Replying to [comment:4 mkoeppe]:\n> \n> No, the point of the jobserver is that one does NOT have to distinguish these \"two different things\". The jobserver manages the load. \n> \n\nYou can certainly integrate the two cleanly with the jobserver approach, but that doesn't change my opinion that they're conceptually two different quantities. The first is how many high-level tasks I'd like to run at the same time (doc building, package installation), and the second is how many threads I'd like to use to perform each of those tasks.\n\n> Users should have no reason to be interested in this distinction. All that matters is throughput. \n\nMaybe not, but we could default both to the same number to accomplish that out-of-the-box. Experience has shown that most people are happy with one package installation at a time, and then a configurable number of jobs. High-level tasks are generally free, while low level ones tend to chew up CPU/RAM. What I personally care about is the number of low-level build threads, which should be the number of package-installation threads times the number of per-package-build-threads. Again using Gentoo as an example, I usually leave this at one package at a time, and then ~four build threads per package.",
    "created_at": "2020-08-17T14:09:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428799",
    "user": "@orlitzky"
}
```

Replying to [comment:4 mkoeppe]:
> 
> No, the point of the jobserver is that one does NOT have to distinguish these "two different things". The jobserver manages the load. 
> 

You can certainly integrate the two cleanly with the jobserver approach, but that doesn't change my opinion that they're conceptually two different quantities. The first is how many high-level tasks I'd like to run at the same time (doc building, package installation), and the second is how many threads I'd like to use to perform each of those tasks.

> Users should have no reason to be interested in this distinction. All that matters is throughput. 

Maybe not, but we could default both to the same number to accomplish that out-of-the-box. Experience has shown that most people are happy with one package installation at a time, and then a configurable number of jobs. High-level tasks are generally free, while low level ones tend to chew up CPU/RAM. What I personally care about is the number of low-level build threads, which should be the number of package-installation threads times the number of per-package-build-threads. Again using Gentoo as an example, I usually leave this at one package at a time, and then ~four build threads per package.



---

archive/issue_comments_428800.json:
```json
{
    "body": "Replying to [comment:7 mjo]:\n> we could default both to the same number to accomplish that out-of-the-box. Experience has shown that most people are happy with one package installation at a time, and then a configurable number of jobs.\n\nSorry, this does not match the typical experience in Sage at all. Throughput comes from building many packages in parallel.",
    "created_at": "2020-08-17T14:14:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428800",
    "user": "@mkoeppe"
}
```

Replying to [comment:7 mjo]:
> we could default both to the same number to accomplish that out-of-the-box. Experience has shown that most people are happy with one package installation at a time, and then a configurable number of jobs.

Sorry, this does not match the typical experience in Sage at all. Throughput comes from building many packages in parallel.



---

archive/issue_comments_428801.json:
```json
{
    "body": "One other thing that distinguishes Gentoo and sage-the-distribution is that Sage is fortunate enough to only have C, C++, Fortran, and python packages for now. Some day that will probably change, and then it's a lot simpler to pass a flag to whatever newfangled build system is involved than it would be to integrate that build system with the GNU Make job server.",
    "created_at": "2020-08-17T14:15:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428801",
    "user": "@orlitzky"
}
```

One other thing that distinguishes Gentoo and sage-the-distribution is that Sage is fortunate enough to only have C, C++, Fortran, and python packages for now. Some day that will probably change, and then it's a lot simpler to pass a flag to whatever newfangled build system is involved than it would be to integrate that build system with the GNU Make job server.



---

archive/issue_comments_428802.json:
```json
{
    "body": "Replying to [comment:9 mjo]:\n> .... whatever newfangled build system ...\n\nsuch as ninja? Note https://github.com/Kitware/ninja/releases, https://forums.gentoo.org/viewtopic-t-1110292-view-previous.html",
    "created_at": "2020-08-17T14:34:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428802",
    "user": "@mkoeppe"
}
```

Replying to [comment:9 mjo]:
> .... whatever newfangled build system ...

such as ninja? Note https://github.com/Kitware/ninja/releases, https://forums.gentoo.org/viewtopic-t-1110292-view-previous.html



---

archive/issue_comments_428803.json:
```json
{
    "body": "Replying to [comment:10 mkoeppe]:\n> Replying to [comment:9 mjo]:\n> > .... whatever newfangled build system ...\n> \n> such as ninja? Note https://github.com/Kitware/ninja/releases, https://forums.gentoo.org/viewtopic-t-1110292-view-previous.html\n> \n\nI actually had Meson in mind, but this is also a good example. Utilizing the job server has the potential to be more efficient, if e.g. you're only able to build one package at a time due to a bunch of linear dependencies (in that case, you're getting `1*N` instead of `M*N` jobs where `M` is the number of jobs you want your package manager to execute in parallel). But as with ninja, the trade-off is that someone would have to write and maintain a huge patch to the build system to support the jobserver protocol, and then it only works with GNU make. Without the patch, we pass e.g. `-j8` to ninja (just like with Make) and it works fine. Maybe slightly less efficient, but a lot less complicated.",
    "created_at": "2020-08-17T15:03:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428803",
    "user": "@orlitzky"
}
```

Replying to [comment:10 mkoeppe]:
> Replying to [comment:9 mjo]:
> > .... whatever newfangled build system ...
> 
> such as ninja? Note https://github.com/Kitware/ninja/releases, https://forums.gentoo.org/viewtopic-t-1110292-view-previous.html
> 

I actually had Meson in mind, but this is also a good example. Utilizing the job server has the potential to be more efficient, if e.g. you're only able to build one package at a time due to a bunch of linear dependencies (in that case, you're getting `1*N` instead of `M*N` jobs where `M` is the number of jobs you want your package manager to execute in parallel). But as with ninja, the trade-off is that someone would have to write and maintain a huge patch to the build system to support the jobserver protocol, and then it only works with GNU make. Without the patch, we pass e.g. `-j8` to ninja (just like with Make) and it works fine. Maybe slightly less efficient, but a lot less complicated.



---

archive/issue_comments_428804.json:
```json
{
    "body": "And actually, I knew that Meson didn't use Make as its backend, but... it uses Ninja! So they're the same example.",
    "created_at": "2020-08-17T15:07:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428804",
    "user": "@orlitzky"
}
```

And actually, I knew that Meson didn't use Make as its backend, but... it uses Ninja! So they're the same example.



---

archive/issue_comments_428805.json:
```json
{
    "body": "Anyway, thanks for the discussion. It is good that we are aware of the longer term context. We'll see in which direction things move (I predict that more build systems embrace the job server protocol, or improvements of it).\n\n\nTo return to the technical point of this ticket: I propose to create a wrapper script in Python that tries to acquire >= A, <= B jobs from the jobserver within <= T wall clock seconds, sets the environment variable `SAGE_NUM_THREADS` to min(C, NUM_JOBS_RECEIVED), and invokes an arbitrary script.  Using this for the sagelib build and docbuild will allow us to replace the recommendation `MAKE='make -j8' make` by the familiar `make -j8`, and will likely be an improvement over the status quo in terms of load management.",
    "created_at": "2020-08-17T15:28:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428805",
    "user": "@mkoeppe"
}
```

Anyway, thanks for the discussion. It is good that we are aware of the longer term context. We'll see in which direction things move (I predict that more build systems embrace the job server protocol, or improvements of it).


To return to the technical point of this ticket: I propose to create a wrapper script in Python that tries to acquire >= A, <= B jobs from the jobserver within <= T wall clock seconds, sets the environment variable `SAGE_NUM_THREADS` to min(C, NUM_JOBS_RECEIVED), and invokes an arbitrary script.  Using this for the sagelib build and docbuild will allow us to replace the recommendation `MAKE='make -j8' make` by the familiar `make -j8`, and will likely be an improvement over the status quo in terms of load management.



---

archive/issue_comments_428806.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30132",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30132#issuecomment-428806",
    "user": "@mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
