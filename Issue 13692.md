# Issue 13692: Fix cython's gc_track and gc_untrack

archive/issues_013692.json:
```json
{
    "body": "Assignee: @rlmill\n\nCC:  simonking jpflori\n\nIn a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.\n\nInstall only the new spkg at [http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg](http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg)\n\nIssue created by migration from https://trac.sagemath.org/ticket/13896\n\n",
    "closed_at": "2013-01-07T20:58:26Z",
    "created_at": "2013-01-01T18:52:39Z",
    "labels": [
        "component: memleak",
        "blocker",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.6",
    "title": "Fix cython's gc_track and gc_untrack",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13692",
    "user": "https://github.com/nbruin"
}
```
Assignee: @rlmill

CC:  simonking jpflori

In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.

Install only the new spkg at [http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg](http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg)

Issue created by migration from https://trac.sagemath.org/ticket/13896





---

archive/issue_comments_169530.json:
```json
{
    "body": "Patch to more reliably produce crash",
    "created_at": "2013-01-01T18:53:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169530",
    "user": "https://github.com/nbruin"
}
```

Patch to more reliably produce crash



---

archive/issue_comments_169531.json:
```json
{
    "body": "Attachment [double-free-crash.patch](tarball://root/attachments/some-uuid/ticket13896/double-free-crash.patch) by @nbruin created at 2013-01-01 18:55:35\n\nWith attached patch applied to 5.6.beta2 (and probably also other versions close to it),\n\n```\nsage -t devel/sage/sage/modules/module.pyx\n```\nwill crash relatively reliably on several machines (including `sage.math`)",
    "created_at": "2013-01-01T18:55:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169531",
    "user": "https://github.com/nbruin"
}
```

Attachment [double-free-crash.patch](tarball://root/attachments/some-uuid/ticket13896/double-free-crash.patch) by @nbruin created at 2013-01-01 18:55:35

With attached patch applied to 5.6.beta2 (and probably also other versions close to it),

```
sage -t devel/sage/sage/modules/module.pyx
```
will crash relatively reliably on several machines (including `sage.math`)



---

archive/issue_comments_169532.json:
```json
{
    "body": "I'd like to see this ticket as a blocker, anyone against this idea?",
    "created_at": "2013-01-02T16:48:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169532",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I'd like to see this ticket as a blocker, anyone against this idea?



---

archive/issue_comments_169533.json:
```json
{
    "body": "Replying to [comment:3 jpflori]:\n> I'd like to see this ticket as a blocker, anyone against this idea?\n\nSince this is the ultimate \"can generate segfaults anywhere\", it's a prime candidate for blocker status. However, we're fully at the mercy of cython developers as to when this gets fixed. Also, if we release with this bug unfixed, we might as well leave #715 in too, since this one has a much wider possible impact :-).",
    "created_at": "2013-01-02T17:34:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169533",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:3 jpflori]:
> I'd like to see this ticket as a blocker, anyone against this idea?

Since this is the ultimate "can generate segfaults anywhere", it's a prime candidate for blocker status. However, we're fully at the mercy of cython developers as to when this gets fixed. Also, if we release with this bug unfixed, we might as well leave #715 in too, since this one has a much wider possible impact :-).



---

archive/issue_comments_169534.json:
```json
{
    "body": "Ok, Ive put it as blocker.\n\nFor those who want to play while waiting for upstream, I've posted a p0 Cython spkg which does \"something\" with PyObject_GC_[Un]Track.\nNot sure it makes any sense, but it seems to make our bug disappear.\nIt's at\nhttp://boxen.math.washington.edu/home/jpflori/cython-0.17.3.p0.spkg",
    "created_at": "2013-01-02T19:22:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169534",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Ok, Ive put it as blocker.

For those who want to play while waiting for upstream, I've posted a p0 Cython spkg which does "something" with PyObject_GC_[Un]Track.
Not sure it makes any sense, but it seems to make our bug disappear.
It's at
http://boxen.math.washington.edu/home/jpflori/cython-0.17.3.p0.spkg



---

archive/issue_comments_169535.json:
```json
{
    "body": "Changing priority from major to blocker.",
    "created_at": "2013-01-02T19:22:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169535",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing priority from major to blocker.



---

archive/issue_comments_169536.json:
```json
{
    "body": "Apologies. I saw I linked to the wrong file. [Include/object.h](http://svn.python.org/projects/python/trunk/Include/object.h) also has some interesting information, but it looks like it is a bit out-of-date on some bits. In particular, if you look at the actual use of the TRASHCAN macros:\n\n```\n    PyObject_GC_UnTrack(self);\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_BEGIN(self);\n    --_PyTrash_delete_nesting;\n...\n  endlabel:\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_END(self);\n    --_PyTrash_delete_nesting;\n```\nwith the explanation a little lower:\n\n```\n       Q. Why the bizarre (net-zero) manipulation of\n          _PyTrash_delete_nesting around the trashcan macros?\n\n       A. Some base classes (e.g. list) also use the trashcan mechanism.\n          The following scenario used to be possible:\n\n          - suppose the trashcan level is one below the trashcan limit\n\n          - subtype_dealloc() is called\n\n          - the trashcan limit is not yet reached, so the trashcan level\n        is incremented and the code between trashcan begin and end is\n        executed\n\n          - this destroys much of the object's contents, including its\n        slots and __dict__\n\n          - basedealloc() is called; this is really list_dealloc(), or\n        some other type which also uses the trashcan macros\n\n          - the trashcan limit is now reached, so the object is put on the\n        trashcan's to-be-deleted-later list\n\n          - basedealloc() returns\n\n          - subtype_dealloc() decrefs the object's type\n\n          - subtype_dealloc() returns\n\n          - later, the trashcan code starts deleting the objects from its\n        to-be-deleted-later list\n\n          - subtype_dealloc() is called *AGAIN* for the same object\n\n          - at the very least (if the destroyed slots and __dict__ don't\n        cause problems) the object's type gets decref'ed a second\n        time, which is *BAD*!!!\n\n          The remedy is to make sure that if the code between trashcan\n          begin and end in subtype_dealloc() is called, the code between\n          trashcan begin and end in basedealloc() will also be called.\n          This is done by decrementing the level after passing into the\n          trashcan block, and incrementing it just before leaving the\n          block.\n\n          But now it's possible that a chain of objects consisting solely\n          of objects whose deallocator is subtype_dealloc() will defeat\n          the trashcan mechanism completely: the decremented level means\n          that the effective level never reaches the limit.      Therefore, we\n          *increment* the level *before* entering the trashcan block, and\n          matchingly decrement it after leaving.  This means the trashcan\n          code will trigger a little early, but that's no big deal.\n```\nIt's probably better to leave out the trashcan for now. It seems like rather tricky code and I'm not sure it's part of the official Python C-API (it might be something internal, just like they use some macros themselves they find unsafe for use in extension modules)",
    "created_at": "2013-01-02T19:42:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169536",
    "user": "https://github.com/nbruin"
}
```

Apologies. I saw I linked to the wrong file. [Include/object.h](http://svn.python.org/projects/python/trunk/Include/object.h) also has some interesting information, but it looks like it is a bit out-of-date on some bits. In particular, if you look at the actual use of the TRASHCAN macros:

```
    PyObject_GC_UnTrack(self);
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_BEGIN(self);
    --_PyTrash_delete_nesting;
...
  endlabel:
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_END(self);
    --_PyTrash_delete_nesting;
```
with the explanation a little lower:

```
       Q. Why the bizarre (net-zero) manipulation of
          _PyTrash_delete_nesting around the trashcan macros?

       A. Some base classes (e.g. list) also use the trashcan mechanism.
          The following scenario used to be possible:

          - suppose the trashcan level is one below the trashcan limit

          - subtype_dealloc() is called

          - the trashcan limit is not yet reached, so the trashcan level
        is incremented and the code between trashcan begin and end is
        executed

          - this destroys much of the object's contents, including its
        slots and __dict__

          - basedealloc() is called; this is really list_dealloc(), or
        some other type which also uses the trashcan macros

          - the trashcan limit is now reached, so the object is put on the
        trashcan's to-be-deleted-later list

          - basedealloc() returns

          - subtype_dealloc() decrefs the object's type

          - subtype_dealloc() returns

          - later, the trashcan code starts deleting the objects from its
        to-be-deleted-later list

          - subtype_dealloc() is called *AGAIN* for the same object

          - at the very least (if the destroyed slots and __dict__ don't
        cause problems) the object's type gets decref'ed a second
        time, which is *BAD*!!!

          The remedy is to make sure that if the code between trashcan
          begin and end in subtype_dealloc() is called, the code between
          trashcan begin and end in basedealloc() will also be called.
          This is done by decrementing the level after passing into the
          trashcan block, and incrementing it just before leaving the
          block.

          But now it's possible that a chain of objects consisting solely
          of objects whose deallocator is subtype_dealloc() will defeat
          the trashcan mechanism completely: the decremented level means
          that the effective level never reaches the limit.      Therefore, we
          *increment* the level *before* entering the trashcan block, and
          matchingly decrement it after leaving.  This means the trashcan
          code will trigger a little early, but that's no big deal.
```
It's probably better to leave out the trashcan for now. It seems like rather tricky code and I'm not sure it's part of the official Python C-API (it might be something internal, just like they use some macros themselves they find unsafe for use in extension modules)



---

archive/issue_comments_169537.json:
```json
{
    "body": "I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.\n\nAnyway I agree it is a better take to leave that out for now, and anyway, upstream will decide what is the best.\n\nSo I've updated the spkg to not include the trashcan parts.",
    "created_at": "2013-01-02T19:54:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169537",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.

Anyway I agree it is a better take to leave that out for now, and anyway, upstream will decide what is the best.

So I've updated the spkg to not include the trashcan parts.



---

archive/issue_comments_169538.json:
```json
{
    "body": "Attachment [cython-0.17.3.p0.diff](tarball://root/attachments/some-uuid/ticket13896/cython-0.17.3.p0.diff) by jpflori created at 2013-01-02 19:54:51",
    "created_at": "2013-01-02T19:54:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169538",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Attachment [cython-0.17.3.p0.diff](tarball://root/attachments/some-uuid/ticket13896/cython-0.17.3.p0.diff) by jpflori created at 2013-01-02 19:54:51



---

archive/issue_comments_169539.json:
```json
{
    "body": "Replying to [comment:7 jpflori]:\n> I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.\n\n\nIn fact, I think the precautions taken are *not enough* for general cython classes. With the little\n\n```\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_BEGIN(self);\n    --_PyTrash_delete_nesting;\n    ...\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_END(self);\n    --_PyTrash_delete_nesting;\n```\ndance they are making sure there is room for *one* extra trashcan nesting *provided that that call doesn't use the same trick*. However, a cython class could have a whole inheritance hierarchy going here (that would all use this trick too!), so I'm pretty sure that the exact scenario they describe could still happen. You'd need to know the depth of the inheritance line (for deallocs, multiple inheritance can't happen, right?) and ensure there's enough room for all those.",
    "created_at": "2013-01-02T21:39:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169539",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:7 jpflori]:
> I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.


In fact, I think the precautions taken are *not enough* for general cython classes. With the little

```
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_BEGIN(self);
    --_PyTrash_delete_nesting;
    ...
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_END(self);
    --_PyTrash_delete_nesting;
```
dance they are making sure there is room for *one* extra trashcan nesting *provided that that call doesn't use the same trick*. However, a cython class could have a whole inheritance hierarchy going here (that would all use this trick too!), so I'm pretty sure that the exact scenario they describe could still happen. You'd need to know the depth of the inheritance line (for deallocs, multiple inheritance can't happen, right?) and ensure there's enough room for all those.



---

archive/issue_comments_169540.json:
```json
{
    "body": "https://github.com/cython/cython/commit/9a08ff23544ac9afd8392715c660898e1f3a762f\n\nComing up with a nice clean test was...interesting.",
    "created_at": "2013-01-02T22:24:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169540",
    "user": "https://github.com/robertwb"
}
```

https://github.com/cython/cython/commit/9a08ff23544ac9afd8392715c660898e1f3a762f

Coming up with a nice clean test was...interesting.



---

archive/issue_comments_169541.json:
```json
{
    "body": "Just one potentially naive question:\nshouldn't the object get retracked iff you're going to call another dealloc method?\nor conversely, if the type does not extend a previous type, shouldn't the object stay untracked when you call tp_free?\nI'm not sure it would really matter if the object is still tracked in this latter case, but I got this feeling when staring at CPython's code today.\n\nAnyway, it just made me think of what will happen if your extension class is GC tracked, but the base class is not? In this case you're lost because if you track your object before calling the base dealloc, then you will not untrack it there. Is that even possible? And anyway if a class is not gc tracked, or is not a container I guess it cannot be weakrefed...",
    "created_at": "2013-01-02T22:31:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169541",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Just one potentially naive question:
shouldn't the object get retracked iff you're going to call another dealloc method?
or conversely, if the type does not extend a previous type, shouldn't the object stay untracked when you call tp_free?
I'm not sure it would really matter if the object is still tracked in this latter case, but I got this feeling when staring at CPython's code today.

Anyway, it just made me think of what will happen if your extension class is GC tracked, but the base class is not? In this case you're lost because if you track your object before calling the base dealloc, then you will not untrack it there. Is that even possible? And anyway if a class is not gc tracked, or is not a container I guess it cannot be weakrefed...



---

archive/issue_comments_169542.json:
```json
{
    "body": "The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.",
    "created_at": "2013-01-02T22:47:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169542",
    "user": "https://github.com/robertwb"
}
```

The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.



---

archive/issue_comments_169543.json:
```json
{
    "body": "Thanks for pointing that out.",
    "created_at": "2013-01-02T23:03:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169543",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Thanks for pointing that out.



---

archive/issue_comments_169544.json:
```json
{
    "body": "Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.",
    "created_at": "2013-01-03T05:06:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169544",
    "user": "https://github.com/robertwb"
}
```

Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.



---

archive/issue_comments_169545.json:
```json
{
    "body": "trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)",
    "created_at": "2013-01-03T07:32:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169545",
    "user": "https://github.com/nbruin"
}
```

trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)



---

archive/issue_comments_169546.json:
```json
{
    "body": "Replying to [comment:13 robertwb]:\n> Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.\n\n\nThis does look good to me. JP has already confirmed that this fixed the issue (as does your elegant test in the cython suite). Your pre.spkg has some different files in it, but I guess that's why you don't consider it an actual spkg.",
    "created_at": "2013-01-03T07:48:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169546",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:13 robertwb]:
> Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.


This does look good to me. JP has already confirmed that this fixed the issue (as does your elegant test in the cython suite). Your pre.spkg has some different files in it, but I guess that's why you don't consider it an actual spkg.



---

archive/issue_comments_169547.json:
```json
{
    "body": "Replying to [comment:11 robertwb]:\n> The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.\n\nSorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.\n\nIf the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?\nIn particular won't a call to gc_list_remove(o) be missing?",
    "created_at": "2013-01-03T12:39:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169547",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Replying to [comment:11 robertwb]:
> The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.

Sorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.

If the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?
In particular won't a call to gc_list_remove(o) be missing?



---

archive/issue_comments_169548.json:
```json
{
    "body": "Replying to [comment:16 jpflori]:\n> Replying to [comment:11 robertwb]:\n> > The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.\n\n> Sorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.\n> \n> If the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?\n> In particular won't a call to gc_list_remove(o) be missing?\n\n\nThe base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance.",
    "created_at": "2013-01-03T17:19:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169548",
    "user": "https://github.com/robertwb"
}
```

Replying to [comment:16 jpflori]:
> Replying to [comment:11 robertwb]:
> > The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.

> Sorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.
> 
> If the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?
> In particular won't a call to gc_list_remove(o) be missing?


The base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance.



---

archive/issue_comments_169549.json:
```json
{
    "body": "Replying to [comment:14 nbruin]:\n> trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)\n\n\nYeah, this is a separate (and more complicated to resolve) issue.",
    "created_at": "2013-01-03T17:22:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169549",
    "user": "https://github.com/robertwb"
}
```

Replying to [comment:14 nbruin]:
> trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)


Yeah, this is a separate (and more complicated to resolve) issue.



---

archive/issue_comments_169550.json:
```json
{
    "body": "Replying to [comment:17 robertwb]:\n> The base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance. \n... so suppose we have a superclass that doesn't do the untrack/track dance (so this must be a non-container superclass of a container class. We're entering rather hypothetical territory here). We'll be entering its dealloc with tracking SET. I guess the actual memory free happens by our class, so I guess the list of GC-tracked objects will be properly amended eventually. Can we prove that no GC or trashcan-shelving of this intermediate object will happen in between? I guess it's unlikely because non-container types should be easy to deallocate ... unless some callous person writes an extension class that does hold references to other objects but is convinced that those will never lead to cycles and hence makes it non-GC-tracked. Some weakref callbacks and a GC could then find a partially torn down object tracked by the GC. Multithreaded stuff could make this even worse, but I guess we're protected by the GIL here.\n\nIt should probably be mandated that *any* container type *has to* participate in GC. For a non-container type it's hard to see how a dealloc could ever be interrupted or interleaved by a GC. So this note is probably more a request for clarification (addition to documentation somewhere?) why this is not a problem than a diagnosis of a bug.",
    "created_at": "2013-01-03T17:52:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169550",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:17 robertwb]:
> The base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance. 
... so suppose we have a superclass that doesn't do the untrack/track dance (so this must be a non-container superclass of a container class. We're entering rather hypothetical territory here). We'll be entering its dealloc with tracking SET. I guess the actual memory free happens by our class, so I guess the list of GC-tracked objects will be properly amended eventually. Can we prove that no GC or trashcan-shelving of this intermediate object will happen in between? I guess it's unlikely because non-container types should be easy to deallocate ... unless some callous person writes an extension class that does hold references to other objects but is convinced that those will never lead to cycles and hence makes it non-GC-tracked. Some weakref callbacks and a GC could then find a partially torn down object tracked by the GC. Multithreaded stuff could make this even worse, but I guess we're protected by the GIL here.

It should probably be mandated that *any* container type *has to* participate in GC. For a non-container type it's hard to see how a dealloc could ever be interrupted or interleaved by a GC. So this note is probably more a request for clarification (addition to documentation somewhere?) why this is not a problem than a diagnosis of a bug.



---

archive/issue_comments_169551.json:
```json
{
    "body": "I think it helps to look at the generated code. Suppose one has\n\n```\ncdef class A: ...\ncdef class B(A): ...\ncdef class C(B): ...\n...\n```\n\nIn this case one has, roughly, \n\n```\ntp_dealloc_A(self) {\n   [optional untrack]\n   bodyA\n   [optional track]\n   PY_TYPE(self)->tp_free(self)\n}\n\ntp_dealloc_B(self) {\n   [optional untrack]\n   bodyB\n   [optional track]\n   tp_dealloc_A(self)\n}\n\ntp_dealloc_C(self) {\n   [optional untrack]\n   bodyC\n   [optional track]\n   tp_dealloc_B(self)\n}\n\n...\n\n```\n\nbodyX consists of decrefing Python members, traversing weakrefs, and (if present)\n\n```\nPyRef(self)++;\nX.__dealloc__(self);\nPyRef(self)--;\n```\n\nThe track/untrack markers are added exactly when Python/weakref members are present, which is where a garbage collection might happen.  (When executing __dealloc__ the refcount is incremented, also preventing garbage collection.)\n\nWhat could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython.",
    "created_at": "2013-01-03T19:05:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169551",
    "user": "https://github.com/robertwb"
}
```

I think it helps to look at the generated code. Suppose one has

```
cdef class A: ...
cdef class B(A): ...
cdef class C(B): ...
...
```

In this case one has, roughly, 

```
tp_dealloc_A(self) {
   [optional untrack]
   bodyA
   [optional track]
   PY_TYPE(self)->tp_free(self)
}

tp_dealloc_B(self) {
   [optional untrack]
   bodyB
   [optional track]
   tp_dealloc_A(self)
}

tp_dealloc_C(self) {
   [optional untrack]
   bodyC
   [optional track]
   tp_dealloc_B(self)
}

...

```

bodyX consists of decrefing Python members, traversing weakrefs, and (if present)

```
PyRef(self)++;
X.__dealloc__(self);
PyRef(self)--;
```

The track/untrack markers are added exactly when Python/weakref members are present, which is where a garbage collection might happen.  (When executing __dealloc__ the refcount is incremented, also preventing garbage collection.)

What could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython.



---

archive/issue_comments_169552.json:
```json
{
    "body": "> \n> What could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython. \n\nThat is exactly what I was thinking about, and IIRC what is looked for in the CPython subtype_dealloc when looking for the base type.\n\nIf you say it cannot happy in Cython, I'm very happy with that!",
    "created_at": "2013-01-03T19:13:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169552",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

> 
> What could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython. 

That is exactly what I was thinking about, and IIRC what is looked for in the CPython subtype_dealloc when looking for the base type.

If you say it cannot happy in Cython, I'm very happy with that!



---

archive/issue_comments_169553.json:
```json
{
    "body": "Are you sure this is the case, e.g., for category_object and sage_object?\nI see a TPFLAGS_HAVE_GC on the former but not on the latter.",
    "created_at": "2013-01-03T20:35:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169553",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Are you sure this is the case, e.g., for category_object and sage_object?
I see a TPFLAGS_HAVE_GC on the former but not on the latter.



---

archive/issue_comments_169554.json:
```json
{
    "body": "Robert's cython test case (I spent quite some time twice to find it, so I'm storing it here for future reference)",
    "created_at": "2013-01-03T21:09:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169554",
    "user": "https://github.com/nbruin"
}
```

Robert's cython test case (I spent quite some time twice to find it, so I'm storing it here for future reference)



---

archive/issue_comments_169555.json:
```json
{
    "body": "Attachment [double_dealloc_T796.pyx](tarball://root/attachments/some-uuid/ticket13896/double_dealloc_T796.pyx) by @vbraun created at 2013-01-03 21:21:15\n\nAnd Robert just released Cython 0.17.4, see https://groups.google.com/d/topic/cython-users/s3ycj83Yctw/discussion",
    "created_at": "2013-01-03T21:21:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169555",
    "user": "https://github.com/vbraun"
}
```

Attachment [double_dealloc_T796.pyx](tarball://root/attachments/some-uuid/ticket13896/double_dealloc_T796.pyx) by @vbraun created at 2013-01-03 21:21:15

And Robert just released Cython 0.17.4, see https://groups.google.com/d/topic/cython-users/s3ycj83Yctw/discussion



---

archive/issue_comments_169556.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-01-03T21:47:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169556",
    "user": "https://github.com/robertwb"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_169557.json:
```json
{
    "body": "Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg",
    "created_at": "2013-01-03T21:47:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169557",
    "user": "https://github.com/robertwb"
}
```

Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg



---

archive/issue_comments_169558.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-01-04T09:38:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169558",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_169559.json:
```json
{
    "body": "Typo in the version number:\n\n```\n### cython-0.17.3 (Robert Bradshaw, 3 January 2013)\n```\nshould be\n\n```\n### cython-0.17.4 (Robert Bradshaw, 3 January 2013)\n```",
    "created_at": "2013-01-04T09:38:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169559",
    "user": "https://github.com/jdemeyer"
}
```

Typo in the version number:

```
### cython-0.17.3 (Robert Bradshaw, 3 January 2013)
```
should be

```
### cython-0.17.4 (Robert Bradshaw, 3 January 2013)
```



---

archive/issue_comments_169560.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2013-01-04T12:57:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169560",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_169561.json:
```json
{
    "body": "Fixed `SPKG.txt`.",
    "created_at": "2013-01-04T12:57:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169561",
    "user": "https://github.com/jdemeyer"
}
```

Fixed `SPKG.txt`.



---

archive/issue_comments_169562.json:
```json
{
    "body": "D'oh. Thanks.",
    "created_at": "2013-01-04T18:26:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169562",
    "user": "https://github.com/robertwb"
}
```

D'oh. Thanks.



---

archive/issue_events_039009.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-07T20:58:26Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13692#event-39009"
}
```



---

archive/issue_comments_169563.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-01-07T20:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169563",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_comments_169564.json:
```json
{
    "body": "I have not seen anymore segmentation faults regarding #715, so this might have fixed it.",
    "created_at": "2013-01-10T09:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169564",
    "user": "https://github.com/jdemeyer"
}
```

I have not seen anymore segmentation faults regarding #715, so this might have fixed it.



---

archive/issue_comments_169565.json:
```json
{
    "body": "Yay! Congratulations to everybody and a special thanks to Simon for pushing the weak caches!",
    "created_at": "2013-01-10T09:55:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13692",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13692#issuecomment-169565",
    "user": "https://github.com/vbraun"
}
```

Yay! Congratulations to everybody and a special thanks to Simon for pushing the weak caches!
