# Issue 15299: Implement symplectic and orthogonal bases of Sym

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2013-12-17 21:12:49

Assignee: sage-combinat

CC:  sage-combinat darij simonking nthiery

Keywords: days54, sym

Following a paper of Chari and Kleber: _Symmetric functions and representations of quantum affine algebras_, arxiv:0011161v1. We implement the symplectic and orthogonal (filtered) bases of Sym.


---

Comment by tscrim created at 2013-12-17 21:16:16

Changing status from new to needs_review.


---

Comment by tscrim created at 2013-12-17 21:16:16

Darij (or anyone else who wants to review this),

Nicolas said it's fine being in `GradedHopfAlgebrasWithBasis` since `Sym` does admit a graded basis, even if the given basis itself is not graded.


---

Comment by darij created at 2013-12-20 11:10:57

I fear Nicolas is wrong here:

```
sage: o = Sym.o()
sage: TestSuite(o).run()
Failure in _test_antipode:
Traceback (most recent call last):
  File "/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 282, in run
    test_method(tester = tester)
  File "/home/darij/gitsage/sage-5.13.beta1/local/lib/python2.7/site-packages/sage/categories/hopf_algebras_with_basis.py", line 263, in _test_antipode
    tester.assert_(SI(x) == self.counit(x) * self.one())
  File "/home/darij/gitsage/sage-5.13.beta1/local/lib/python/unittest/case.py", line 424, in assertTrue
    raise self.failureException(msg)
AssertionError: False is not true
------------------------------------------------------------
The following tests failed: _test_antipode
```

The problem is that the counit is still defined as the constant coefficient, but that's only true for graded bases. Concrete example:

```
sage: o[2].counit()
0
sage: s(o[2]).counit()
-1
```


The same issue would be happening with antipode and degree_negation if not for the fact that the o and sp bases happen to be graded w.r.t. the induced ZZ/2ZZ-grading.


---

Comment by git created at 2013-12-27 06:22:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2013-12-27 06:27:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2013-12-27 06:27:48

Replying to [comment:2 darij]:
> I fear Nicolas is wrong here
>
> ...
>
> The problem is that the counit is still defined as the constant coefficient, but that's only true for graded bases.

Yep, but that's technically a fault with the generic symmetric function code, not the category (which I think does it via coercion by default). Fixed.

> The same issue would be happening with antipode and degree_negation if not for the fact that the o and sp bases happen to be graded w.r.t. the induced ZZ/2ZZ-grading.

Again, not the category, but it's nice to know these things.
----
New commits:


---

Comment by darij created at 2013-12-27 15:14:08

I see. Can it be that the `SymmetricFunctionsBases` class should be split into `SymmetricFunctionsBases` and `SymmetricFunctionsConnectedGradedBases` or else we risk running into this whenever other new methods are implemented? If so, I'd suggest doing this (I can do it myself), although I'd wait for #15473 to be merged beforehand.


---

Comment by git created at 2013-12-27 15:51:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2013-12-27 16:11:43

I doubt there will be too many new methods which a general implementation does not involve coercing to a basis where we can do the computation explicitly, so I don't think it's necessary. Nevertheless, something for another ticket (possibly after a sage-combinat-devel discussion).


---

Comment by chapoton created at 2014-04-18 20:17:42

There is a typo "Scirmshaw"


---

Comment by git created at 2014-04-19 05:44:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-04-19 05:44:28

XP


---

Comment by git created at 2015-01-03 04:32:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-02-06 09:26:21

Please do not use abbreviations like "lps" in the name of functions.

Nathann


---

Comment by chapoton created at 2015-04-25 17:22:14

missing doctests in sf.py, see patchbot report


---

Comment by chapoton created at 2015-04-25 17:22:14

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-10-06 02:31:08

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by tscrim created at 2015-10-06 02:34:43

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2015-10-06 02:34:43

I added the requisite doctests and I also implemented functionality for bases of `Sym` to be considered filtered (although we could make these bases be `ZZ / 2ZZ`-graded but the `ZZ`-filtration is more natural), which requires #17096.


---

Comment by git created at 2015-10-06 02:41:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-10-06 12:17:15

Travis, thanks for pointing this out to me.  The `st` basis in ticket #19327 is very similar and since the group of permutation matrices are orthogonal matrices, it will be that `o(lambda)` has a positive `st` expansion.

There is an explicit formula for the change of basis from `sp` and `o` to Schur basis (that is almost exactly the same as the `_s_to_sp_on_basis` and `_s_to_o_on_basis` that you have implemented, it just alternates in sign by degree and the set of partitions you sum over are transposed).  Is it faster to use the triangularity like you have here?  Are you aware of it and have you tried it?


---

Comment by tscrim created at 2015-10-06 12:54:56

No, I was not aware of it and haven't tried it. I'm guessing that just comes from a m√∂bius inversion? I suspect it will be significantly faster than using triangularity. Just to make sure I understand the computation, I keep the same coefficient up to a sign (which is the size of `mu`) and then take `mu.transpose()` as the basis element? And/Or do I need to transpose inside the coefficients?


---

Comment by zabrocki created at 2015-10-06 13:17:56

What I said in my last comment isn't quite right.  It is in my paper with Mark Shimozono "Deformed universal characters for classical and affine algebras, Journal of Algebra, 299 (2006), pp. 33-61" (arXiv:math.CO/0404288) but it probably goes back to Koike and Terada or maybe even Littlewood.  It is equation (4.1)+(4.5) for the orthogonal and (4.1)+(4.4) for the symplectic in my paper.


---

Comment by zabrocki created at 2015-10-06 17:42:15

I'm sorry, but I can't compile anything new right now so I am afraid to push anything.  I can write functions on a working version of sage and I am pretty sure the following is right (following the model of `_s_to_o_on_basis`):

```
    def _o_to_s_on_basis(self, lam):
        import sage.libs.lrcalc.lrcalc as lrcalc
        from sage.combinat.partition import Partitions
        R = self.base_ring()
        return self._from_dict({ mu: R.sum(
            (-1)**j*lrcalc.lrcoef_unsafe(lam, mu, nu)
            for nu in Partitions(2*j)
              if all(nu.arm_length(i,i)==nu.leg_length(i,i)+1
                for i in range(nu.frobenius_rank())) )
            for j in range(sum(lam)//2+1)
            for mu in Partitions(sum(lam)-2*j) })
```

Moreover, if you switch `arm` and `leg` then that is the `_sp_to_s_on_basis`.

Your `_s_to_o_on_basis` has lots of extra looping going on that is not necessary.  Because `|lam|==|mu|+|nu|` you can remove one sum.  Because `nu` has to be an even partition, you don't need to run over `j` odd.  Here is a suggested modification:


```
def _s_to_o_on_basis(self, lam):
    import sage.libs.lrcalc.lrcalc as lrcalc
    from sage.combinat.partition import Partitions
    R = self.base_ring()
    return self._from_dict({ mu: R.sum( lrcalc.lrcoef_unsafe(lam, mu, nu)
                                 for nu in Partitions(2*j)
                                     if all(x % 2 == 0 for x in nu))
                                 for j in range(sum(lam)//2+1)
                                 for mu in Partitions(sum(lam)-2*j) })
```



---

Comment by zabrocki created at 2015-10-06 17:49:44

I just thought about it and it would probably be better in `_s_to_o_on_basis` to loop over partitions of `j` and double the lengths of the parts of the partition.


---

Comment by git created at 2015-10-06 20:38:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-06 20:41:24

Thank you for those suggestions Mike. I implemented all of them, and they resulted in orders of magnitude speedups (including the inverse basis transformations).


---

Comment by git created at 2015-10-06 20:46:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-06 20:55:01

At some point in the future, we should implement the single box version and the Hall-Littlewood analogs given in your paper with Mark.


---

Comment by zabrocki created at 2015-10-08 11:22:14

Here is an important question to resolve we can set to positive review.  Is the following right?

```
sage: s(o.an_element().homogeneous_component(0))
2*s[]
sage: s(o.an_element()).homogeneous_component(0)
-s[]
```

I think the answer is no but I don't want to change it before I get full opinions.  I think that we should look carefully to see if there other methods that are also filter dependent.


---

Comment by zabrocki created at 2015-10-08 12:28:05

Lets look carefully:

```
sage: o[2].is_homogeneous()
True
sage: s(o[2]).is_homogeneous()
False
sage: o.an_element().degree_zero_coefficient()
2
sage: s(o.an_element()).degree_zero_coefficient()
-1
```

`degree_negation` seems to work fine but that is special for these bases (and would not say work for the odd-symplectic basis or irreducible S_n character basis).  It would be better if on filtered bases that these methods were done by coercion.


---

Comment by tscrim created at 2015-10-08 15:29:37

I would say that is okay because the COB morphism is as filtered algebras, so we can't expect homogeneous components to go to homogeneous components. However this should still work for top-degree homogeneous components.

So do you want me to do some surgery on the category of Sym bases and make 2 basis categories, one for the filtered and one for the graded? We could then have some generic code for the filtered that uses coercion for those methods that implicitly rely on the basis being graded.


---

Comment by zabrocki created at 2015-10-08 17:11:30

To me, the degree of the symmetric function is well defined, even if the basis is filtered.  Degree is what we use on the classical symmetric function bases (not the size of the indexing partition...that is different).  That means homogeneous component, degree and counit are not computed by the size of the indexing partition.

I think that it would be a good idea to factor out those and have two basis categories as you suggest.


---

Comment by git created at 2015-10-08 17:33:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-09 02:00:28

Okay, I've done some reworking of things at the category level, including adding a `counit_by_coercion` for realizations.

However I get MRO issues when dealing with the finite fields that I don't know how to deal with. I've convinced myself that the categories are almost correct; I want to make this change

```diff
         cat = HopfAlgebras(self.base().base_ring())
         return [self.base().Realizations(),
                 cat.Commutative().WithBasis(),
-                cat.Graded().Realizations()]
+                cat.Commutative().Graded().Realizations()]
```

But if I do that, I get `KeyError: (225536, 70)` from the c3 controlled!

So I don't know what to do at this point. Nicolas, Simon, do you have any ideas?
----
New commits:


---

Comment by tscrim created at 2015-10-09 02:01:18

Changing status from needs_review to needs_info.


---

Comment by darij created at 2015-10-09 03:04:45

Could this be related to the error in #11979 ?

Also, a trifle:


```
+class FilteredSymmetricFunctionsBases(Category_realization_of_parent):
+    r"""
+    The category of graded bases of the ring of symmetric functions.
```

s/graded/filtered/

(Thanks for fixing the categorical hack that made filtered bases pretend to be graded -- IIRC that was the reason why I was skeptical about this ticket!)


---

Comment by tscrim created at 2015-10-09 03:30:18

Yes, I would say so, and also on #15475. The most annoying thing is that it works for NCSF! However the reason why I can't add the commutative is something I have no understanding of what fails.


---

Comment by zabrocki created at 2015-10-09 11:44:33

To be clear, I'm finding when testing the file `sfa.py` there are errors

```
    s = SymmetricFunctions(FiniteField(29)).s()
Exception raised:
    Traceback (most recent call last):
...
    TypeError: Cannot create a consistent method resolution
    order (MRO) for bases GradedAlgebras.subcategory_class, CommutativeAlgebras.subcategory_class, Bialgebras.subcategory_class
```

Are you able to trigger them outside of the testing environment?  When I enter them by hand they work fine.


---

Comment by tscrim created at 2015-10-09 11:59:01

Yes, those are the errors I get when doctesting `sfa.py`.

You have to do (in a fresh startup of Sage):

```
sage: SymmetricFunctions(Integers(23))
sage: SymmetricFunctions(FiniteField(23))
```

It also fails if you do it in the other order as well.


---

Comment by nthiery created at 2015-10-12 12:37:13

Hi!

Could it be that we are mixing categories parametrized by a base ring, and categories parametrized by the category that base ring? Something like ``HopfAlgebras(Fields()).XXX()`` and ``Bialgebras(GF(3)).YYY()`` ?


---

Comment by tscrim created at 2015-10-12 15:37:14

Replying to [comment:41 nthiery]:
> Could it be that we are mixing categories parametrized by a base ring, and categories parametrized by the category that base ring? Something like `HopfAlgebras(Fields()).XXX()` and `Bialgebras(GF(3)).YYY()` ?

AFAIK we aren't mixing things like that. This is that wonderful category refinement issue that somehow was somehow magically working beforehand, but I think that was because the categories for the bases weren't quite correct.


---

Comment by tscrim created at 2015-10-22 03:39:04

I wonder if the problem stems from this line in `__classcall_private__` of `Modules`:

```
if base_ring in _Fields or (isinstance(base_ring, Category)
                            and base_ring.is_subcategory(_Fields)):
```

or this line in `extra_super_categories` of `FilteredAlgebras`:

```
if base_ring in Fields:
```

and that one/both of these triggers the category refinement and breaks the MRO, which was in the process of being constructed when these were called.

```
sage: R = Integers(7)
sage: R.category()
Join of Category of finite commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
sage: HopfAlgebras(R)
Category of hopf algebras over Ring of integers modulo 7
sage: R.category()
Join of Category of finite fields and Category of subquotients of monoids and Category of quotients of semigroups
```

Yet this still doesn't explain why this works for NCSF. I think that might be a key in figuring out what is going wrong.


---

Comment by zabrocki created at 2015-10-22 15:08:52

You could be on to something here.  If I delete the following lines:

```
-        if dispatch:
-            if base_ring in _Fields or (isinstance(base_ring, Category)
-                                        and base_ring.is_subcategory(_Fields)):
-                from vector_spaces import VectorSpaces
-                return VectorSpaces(base_ring, check=False)
```

I find that your example in comment 40 does not raise an error.


---

Comment by tscrim created at 2015-10-26 14:52:10

However, I don't think that is the right solution. `:/` The check is reasonable and necessary.

Granted, my current proposal is a major hack, but I don't think too many people will be creating many instances of Sym over various large finite fields (and there are more computationally intensive parts necessary for working with Sym). I'm tired of trying to deal with this here, so I just checked if the base ring was a field before any categories get created.

There is also another issue with C3 in that I get a `KeyError` if I make this change:

```diff
         cat = HopfAlgebras(self.base().base_ring())
         return [self.base().Realizations(),
                 cat.Commutative().WithBasis(),
-                cat.Graded().Realizations()]
+                cat.Commutative().Graded().Realizations()]
```

This is what it should be, but because everything commutative will come from the `cat.Commutative().WithBasis()`, I think we are okay for now.

I really would like to push this ticket in and later reach in and fix the category-refinement/MRO/C3 issues on a separate ticket.
----
New commits:


---

Comment by tscrim created at 2015-10-26 14:55:30

I should also mention that there are other places where category refinement would make sense, such as for finite-dimensional algebras after doing an `is_commutative` or `is_unital` test, so IMO it could be useful beyond prime testing for finite fields.


---

Comment by tscrim created at 2015-10-26 14:55:30

Changing status from needs_info to needs_review.


---

Comment by zabrocki created at 2015-10-26 20:23:42

What does the line "R in Fields()" do?  It looks to me like it returns True or False and goes on to the next line.


---

Comment by tscrim created at 2015-10-26 21:47:44

It makes sure that `R` has had its category refined (if it needs to). Thus this is not done in the process of building the MRO/category heirarchy for `Sym`.


---

Comment by zabrocki created at 2015-10-27 00:33:36

Changing status from needs_review to needs_work.


---

Comment by zabrocki created at 2015-10-27 00:33:36

I don't think that this is a bad way of resolving this, but it may be pushing the problem elsewhere.  I am seeing:

```
File "combinat/ncsf_qsym/qsym.py", line 1873, in sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Monomial.lambda_of_monomial
Failed example:
    M = QuasiSymmetricFunctions(Integers(5)).Monomial()
```


Are ncsf/qsym going to require the same hack?  Will every combinatorial Hopf algebra require it?


---

Comment by tscrim created at 2015-10-27 03:29:15

I've not been getting those errors, but Volker just posted on #19397 an issue that smells like the same thing. So right now I'm thinking, "*!`@`$, we have to deal with this now". `:/` Nicolas, Simon, I will need you two to get involved now I think.


---

Comment by zabrocki created at 2015-10-27 11:32:46

One strange feature is that the error that you post in comment 40 is triggered on QSym and NCSymD but not on NCSF or NCSym (at least on my computer).  That is,

```
sage: NCSymD = SymmetricFunctionsNonCommutingVariablesDual(FiniteField(23))
sage: NCSymD = SymmetricFunctionsNonCommutingVariablesDual(Integers(23))
```

triggers an error but

```
sage: NCSym = SymmetricFunctionsNonCommutingVariables(FiniteField(23))
sage: NCSym = SymmetricFunctionsNonCommutingVariables(Integers(23))
```

does not.


---

Comment by tscrim created at 2015-10-31 17:54:46

The `NCSymD` is caused by this part of the `__init__`:

```
        Sym = SymmetricFunctions(self.base_ring())
        Sym_h_to_w = Sym.h().module_morphism(w.sum_of_partitions,
                                             triangular='lower',
                                             inverse_on_support=w._set_par_to_par,
                                             codomain=w, category=category)
```

Ah...`QSym` fails for the same reason...

I think they all will need this hack for now. I know this is pushing the problem further down, but I don't know of a way to resolve it at present (or at least without forcing a prime check for finite rings).

Although there is the issue on comment:45 that is likely unrelated and needs a fix at some point too... I think there might be some issue(s) with join categories...

I also have been working on #19397 under the assumption that these are the same problem. However I am pretty sure this is not the case now and they are different problems (I would love to be wrong).


---

Comment by git created at 2015-11-02 01:08:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2015-11-02 01:23:42

I agree.  In the end this is a minor change as a hack.  It doesn't locate the problem, but it does fix it from being triggered.  I've pushed some changes which add doctests and replaced `assert(R in Rings())` with `assert(R in Fields() or R in Rings())` in in the `__init__` method for all of these Hopf algebras.  I'll get back to Jean-Baptist's Hopf algebra implementations after we resolve these issues and see if his code can be used to get around these problem.


---

Comment by git created at 2015-11-02 02:32:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-11-02 02:36:55

I'm okay with things. So let's just leave this hack in there since it works for now. It is also documented for testing later on. Therefore I think we are back to needs review.


---

Comment by tscrim created at 2015-11-02 02:36:55

Changing status from needs_work to needs_review.


---

Comment by zabrocki created at 2015-11-02 12:12:09

Changing status from needs_review to positive_review.


---

Comment by zabrocki created at 2015-11-02 12:12:09

I think it looks good and all tests pass.  Positive review.


---

Comment by tscrim created at 2015-11-02 14:03:57

Thanks Mike!


---

Comment by vbraun created at 2015-11-03 23:59:25

Resolution: fixed
