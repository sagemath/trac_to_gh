# Issue 31558: faster conversion between power series and polynomials

Issue created by migration from https://trac.sagemath.org/ticket/31795

Original creator: @mwageringel

Original creation time: 2021-05-08 13:45:15

CC:  vdelecroix

This ticket adds a method `homogeneous_components` for multivariate polynomials, which is then used to improve the performance of conversions from multivariate power series to polynomials and vice versa.

These conversions are called frequently in some operations with power series, so this can be a bottleneck. The implementation avoids calls to `subs()` which are slow.

Results:

```
set_random_seed(0)
R.<x,y,z> = QQ[[]]
f = R.random_element(20, 40)
%timeit f.polynomial()  # calls _send_to_fg()
p = f.polynomial()
%timeit R(p)  # calls _send_to_bg()
```


With the above tests, I get about a `2×` speedup in the first and more than a 10× speedup in the second case:

```
# before
41.9 µs ± 837 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
1.64 ms ± 10.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

# after
17.6 µs ± 116 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
130 µs ± 484 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
```


If I replace `f` by a smaller element `f = R.random_element(3, 5)`, I get a 7× speedup for the first and more than a 2× speedup for the second test:

```
# before
20.5 µs ± 115 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
82.8 µs ± 429 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

# after
2.77 µs ± 41 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
31.3 µs ± 102 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
```




---

Comment by @mwageringel created at 2021-05-08 13:57:52

There is more performance to be gained with power series (multiplication, in particular), but this ticket is a first easy step.
----
New commits:


---

Comment by @mwageringel created at 2021-05-08 13:57:52

Changing status from new to needs_review.


---

Comment by tmonteil created at 2021-05-18 15:03:47

Your construction for computing homogeneous components looks complicated. What do you think about the branch [u/tmonteil/31795](https://git.sagemath.org/sage.git/log/?h=u/tmonteil/31795) ?


---

Comment by tmonteil created at 2021-05-18 15:03:47

Changing status from needs_review to needs_info.


---

Comment by slelievre created at 2021-05-18 17:19:56

Replying to [comment:2 tmonteil]:
> Your construction for computing homogeneous components looks complicated. What do you think about the branch [u/tmonteil/31795](https://git.sagemath.org/sage.git/log/?h=u/tmonteil/31795) ?

It adds two nice commits:

- [dff03f3f: simplify the code of homogeneous_components](https://git.sagemath.org/sage.git/commit/?h=u/tmonteil/31795&id=dff03f3f3bf75481f5ad174b0a6e3a645defbcf8)
- [aafd615c: multivariate polynomial rings should be callable with no argument](https://git.sagemath.org/sage.git/commit/?h=u/tmonteil/31795&id=aafd615c13d45305339b99fefa18572f50986e0c)


---

Comment by git created at 2021-05-18 19:05:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mwageringel created at 2021-05-18 19:06:18

Replying to [comment:2 tmonteil]:
> Your construction for computing homogeneous components looks complicated. What do you think about the branch [u/tmonteil/31795](https://git.sagemath.org/sage.git/log/?h=u/tmonteil/31795) ?

This is much simpler indeed and about as fast, at least for libsingular polynomials. Thank you.

I have slightly changed the default factory to use the `.zero()` method, which is about 10% faster in my testing. Otherwise, I am happy with your changes.


---

Comment by @mwageringel created at 2021-05-18 19:06:18

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2021-05-19 05:50:47

If you want to squeeze some more speed out, I would do

```python
cdef ETuple m
d = defaultdict(dict)
from collections import defaultdict
for m, c in self.iterator_exp_coeff():
   d[m.unweighted_degree()][m] = c
return {k: self._parent(d[k]) for k in d}
```

This way you avoid creating more transient objects as `+=` is not truly in-place. The corresponding parent constructor will be faster at handling the group. As a proof-of-concept:

```
sage: R.<a,b,c> = PolynomialRing(QQ, 3, order='lex')
sage: def test1(p):
....:     return R.sum(m*c for m,c in p)
sage: def test2(p): 
....:     d = {m: c for m, c in p.iterator_exp_coeff()} 
....:     return R(d)

sage: %timeit test1(p)
7.78 µs ± 20 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit test2(p)
7.09 µs ± 38.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```



---

Comment by tscrim created at 2021-05-19 06:12:11

What I wrote in comment:6 won't work in the graded case. Here is a modified version:

```python
d = defaultdict(dict)
from collections import defaultdict
for c, m in self:
   d[m.degree()][m.exponents()[0]] = c
return {k: self._parent(d[k]) for k in d}
```


Timings:

```
sage: def test2(p):
....:     d = {m.exponents()[0]: c for c,m in p}
....:     return R(d)

sage: %timeit test1(p)
7.91 µs ± 168 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit test2(p)
9.75 µs ± 73.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```

However, if we change rings:

```
sage: S.<a,b,c> = PolynomialRing(ZZ, order=TermOrder('wdegrevlex', (1,2,3)))
sage: p = a + b + c
sage: %timeit test1(p)
27.7 µs ± 710 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage: %timeit test2(p)
9.92 µs ± 153 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```


Based off this, what I would propose would be this:

```python
cdef ETuple m
d = defaultdict(dict)
from collections import defaultdict
if self._parent.__term_order._weights:
    for c, mon in self:
        d[mon.degree()][mon.exponents()[0]] = c
    return {k: self._parent(d[k]) for k in d}
# Otherwise it is unweighted
for m, c in self.iterator_exp_coeff():
   d[m.unweighted_degree()][m] = c
return {k: self._parent(d[k]) for k in d}
```



---

Comment by git created at 2021-05-20 18:06:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mwageringel created at 2021-05-20 18:10:14

Replying to [comment:7 tscrim]:
> Based off this, what I would propose would be this:
> <...>

Thanks. I have been able to replicate your timings and have updated the branch accordingly.


---

Comment by tscrim created at 2021-05-23 05:27:09

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2021-05-23 05:27:09

There might be some extra speed that can be worked out by providing a specialized version of `homogeneous_components` for libsingular polynomials. Although something about blood and stones comes to mind. So this is good enough as a first implementation. Thank you.


---

Comment by @mwageringel created at 2021-05-23 13:19:52

Replying to [comment:10 tscrim]:
> There might be some extra speed that can be worked out by providing a specialized version of `homogeneous_components` for libsingular polynomials.

Yes, for sure. For now, I think it is more worthwhile to look into the performance of multiplication of power series next (there are two problems: the product does not take advantage of truncation, and it is computed using Karatsuba (I think) which is not a good choice considering that power series are represented as univariate polynomials over a multivariate base ring).

Thanks for the review.


---

Comment by vbraun created at 2021-06-19 20:57:35

Resolution: fixed
