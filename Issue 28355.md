# Issue 28355: generic log/exp for univariate polynomials

Issue created by migration from https://trac.sagemath.org/ticket/28592

Original creator: vdelecroix

Original creation time: 2019-10-11 17:07:19

CC:  mmezzarobba

We implement generic `_log_series` and `_exp_series` on univariate polynomials.


---

Comment by vdelecroix created at 2019-10-11 17:07:50

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2019-10-11 17:07:50

New commits:


---

Comment by chapoton created at 2019-10-11 18:12:38

What is the advantage compared to the existing

```
sage: R.<x> = QQ[[]]
sage: (1 + x).O(4).log()
x - 1/2*x^2 + 1/3*x^3 + O(x^4)
```

?


---

Comment by mmezzarobba created at 2019-10-12 06:41:22

`@`Frédéric: The advantage is that it allows us to have specialized implementations for specific coefficient rings using the existing polynomial classes. I think the idea is that, eventually, operations on elements of power series rings should become wrappers for these `_XXX_series()` methods. It also makes it possible to call truncated operations without the overhead of constructing a power series when you have a polynomial.

`@`Vincent: From a quick look, the code looks fine to me, but isn't it a bit of a pity to have a quadratic-time implementation while there are simple quasi-linear algorithms? (Integrate f'/f to compute log(f), Newton-invert to get exp(f).) I'm not saying you need to change it, but should you want to do it, [here](https://github.com/Apostolus/SERIES-CALCULATION/blob/master/series.py) is an implementation done in a small student project I supervised where initial goal was to submit the code to Sage, but the students didn't do it and I never took the time to clean up the code myself.


---

Comment by vdelecroix created at 2019-10-13 01:28:50

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2019-10-13 01:28:50

Thanks Mark for the pointer. I just quickly implemented that because I needed it! I should rather backport what is in power series (ODE integration).


---

Comment by vdelecroix created at 2019-10-15 06:08:12

The `solve_linear_ode` (from power series) is limited to degree one differential equations and hence does not handle `cos` and `sin`. This is kind of unfortunate...


---

Comment by git created at 2019-10-15 07:09:39

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2019-10-15 07:10:12

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2019-10-15 13:00:57

Thank you for the implementation!

* A small bug:

```
sage: S.<t> = SR[]
....: S(3)._log_series(1)
0
```

* A failing test:

```
File "src/sage/rings/polynomial/polynomial_element.pyx", line 10228, in sage.rings.polynomial.polynomial_element.Polynomial._log_series
Failed example:
    x._log_series()
Expected:
    Traceback (most recent call last):
    ...
    ValueError: can not take logarithm with zero constant coefficient
Got:
    <BLANKLINE>
    Traceback (most recent call last):
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 681, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1123, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.rings.polynomial.polynomial_element.Polynomial._log_series[10]>", line 1, in <module>
        x._log_series()
    TypeError: _log_series() takes exactly one argument (0 given
```

* `self = self[1:]` would be better than `self -= a0` over RLF, intervals, ...
* I'm not sure if testing the characteristic instead of just letting the code fail with a division by zero is actually a good idea, because there may be applications where one wants to compute truncated series to a precision < characteristic. But that's a really minor detail, and largely a matter of taste.

Replying to [comment:5 vdelecroix]:
> The `solve_linear_ode` (from power series) is limited to degree one differential equations and hence does not handle `cos` and `sin`. This is kind of unfortunate...

FWIW, one way to compute sin/cos without code for solving ODEs of order two is via 1/(1+t²) → arctan → tan → tan²/2.


---

Comment by mmezzarobba created at 2019-10-15 13:00:57

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2019-10-15 16:59:57

Replying to [comment:8 mmezzarobba]:

Thanks for the feedback!

> * `self = self[1:]` would be better than `self -= a0` over RLF, intervals, ...

I have a question about this. There is the class function `shift(self, n)` that is supposed to do the same thing as `self[n:]` (when `n` is positive). However, the shift is very often not optimized and goes through lists and calling the parent. Is there a prefered way (for readability/uniformity of the code)?

> * I'm not sure if testing the characteristic instead of just letting the code fail with a division by zero is actually a good idea, because there may be applications where one wants to compute truncated series to a precision < characteristic. But that's a really minor detail, and largely a matter of taste.


Fine. It will make the code faster :-)

> Replying to [comment:5 vdelecroix]:
> > The `solve_linear_ode` (from power series) is limited to degree one differential equations and hence does not handle `cos` and `sin`. This is kind of unfortunate...
> 
> FWIW, one way to compute sin/cos without code for solving ODEs of order two is via 1/(1+t²) → arctan → tan → tan²/2.

This gives you arctan and tan. But how do you extract cos/sin from there?


---

Comment by vdelecroix created at 2019-10-15 17:15:40

The implementation fails for non-commutative base rings

```
sage: M = MatrixSpace(ZZ,2)
sage: x = polygen(M)
sage: p = 1 + M([2,1,0,4]) * x + M([1,0,-1,3]) * x**2 + M([1,1,1,1]) * x**3
sage: p._log_series(10)._exp_series(10) == p
False
```

Is there a way to fix it or should I forbid non-commutative base rings?


---

Comment by vdelecroix created at 2019-10-15 17:16:36

Replying to [comment:9 vdelecroix]:
> Replying to [comment:8 mmezzarobba]:
> 
> > * `self = self[1:]` would be better than `self -= a0` over RLF, intervals, ...
> 

This is not the same operation. There is a shift in the degree with `self[1:]`.


---

Comment by vdelecroix created at 2019-10-15 17:24:15

Replying to [comment:10 vdelecroix]:
> The implementation fails for non-commutative base rings
> {{{
> sage: M = MatrixSpace(ZZ,2)
> sage: x = polygen(M)
> sage: p = 1 + M([2,1,0,4]) * x + M([1,0,-1,3]) * x**2 + M([1,1,1,1]) * x**3
> sage: p._log_series(10)._exp_series(10) == p
> False
> }}}
> Is there a way to fix it or should I forbid non-commutative base rings?

Note that the naive series expansion that I initially wrote work for non-commutative rings!


---

Comment by vdelecroix created at 2019-10-15 17:30:00

Replying to [comment:12 vdelecroix]:
> Replying to [comment:10 vdelecroix]:
> > The implementation fails for non-commutative base rings
> > {{{
> > sage: M = MatrixSpace(ZZ,2)
> > sage: x = polygen(M)
> > sage: p = 1 + M([2,1,0,4]) * x + M([1,0,-1,3]) * x**2 + M([1,1,1,1]) * x**3
> > sage: p._log_series(10)._exp_series(10) == p
> > False
> > }}}
> > Is there a way to fix it or should I forbid non-commutative base rings?
> 
> Note that the naive series expansion that I initially wrote work for non-commutative rings!

... modulo #28610


---

Comment by vdelecroix created at 2019-10-15 17:37:42

Last question: the following is kind of wrong

```
sage: x = polygen(ZZ)
sage: (1+x)._log_series(5)
- 1/4*x^4 + 1/3*x^3 - 1/2*x^2 + x
```

as the answer belongs to `QQ[x]` and not `ZZ[x]`. The reason is that the `integral` method silently makes a coercion to the fraction field. Should `integral` be more careful with promotion of base rings?


---

Comment by git created at 2019-10-15 18:36:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-10-15 18:38:20

Needs review again! Now one can take logarithm over `MatrixSpace(Zmod(77), 2)['x']`.


---

Comment by vdelecroix created at 2019-10-15 18:38:20

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2019-10-16 00:48:48

Replying to [comment:3 mmezzarobba]:
> `@`Frédéric: The advantage is that it allows us to have specialized implementations for specific coefficient rings using the existing polynomial classes. I think the idea is that, eventually, operations on elements of power series rings should become wrappers for these `_XXX_series()` methods. It also makes it possible to call truncated operations without the overhead of constructing a power series when you have a polynomial.

Performance is to me the main motivation

```
sage: R.<x> = QQ[[]]
sage: %timeit f = (1 + x - 2*x^2 + 3*x^3).O(100).log(100)
1000 loops, best of 5: 1.1 ms per loop
sage: %timeit f = (1 + x - 2*x^2 + 3*x^3).O(1000).log(1000)
100 loops, best of 5: 12.1 ms per loop
```

versus

```
sage: R.<x> = QQ[]
sage: %timeit f = (1 + x - 2*x^2 + 3*x^3)._log_series(100)
10000 loops, best of 5: 57.6 µs per loop
sage: %timeit f = (1 + x - 2*x^2 + 3*x^3)._log_series(1000)
100 loops, best of 5: 7.97 ms per loop
```

(not excessively impressive though)

I opened #28612 to rewrite the implementation of `.log()`/`.exp()` on power series to call the `._log_series()`/`._exp_series()` of the underlying polynomial.


---

Comment by vdelecroix created at 2019-10-16 04:41:32

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2019-10-16 04:41:32

grrr, there is a bug with p-adic polynomial rings and the coercion model

```
sage: cm = get_coercion_model()
sage: cm.bin_op(QQ['x'].one(), ZZ.one(), operator.truediv).parent()
Univariate Polynomial Ring in x ...
sage: cm.bin_op(Qp(7)['x'].one(), ZZ.one(), operator.truediv).parent()
Fraction Field of Univariate Polynomial Ring in x ...
```



---

Comment by vdelecroix created at 2019-10-16 04:54:07

Boils down to

```
sage: cm.get_action(QQ['x'], ZZ, operator.truediv)
Right inverse action by Rational Field on Univariate Polynomial Ring in x over Rational Field
with precomposition on right by Natural morphism:
  From: Integer Ring
  To:   Rational Field
sage: cm.get_action(Qp(7)['x'], ZZ, operator.truediv)
```



---

Comment by vdelecroix created at 2019-10-16 05:00:27

which boils down to

```
sage: cm.get_action(QQ['x'], ZZ, operator.mul)
Right scalar multiplication by Integer Ring on Univariate Polynomial Ring in x over Rational Field
sage: cm.get_action(Qp(7)['x'], ZZ, operator.mul)
```



---

Comment by mmezzarobba created at 2019-10-16 10:15:26

Replying to [comment:9 vdelecroix]:
> > FWIW, one way to compute sin/cos without code for solving ODEs of order two is via 1/(1+t²) → arctan → tan → tan²/2.
> 
> This gives you arctan and tan. But how do you extract cos/sin from there?

I meant tan(z/2) in the last step, sorry; and then sin and cos using the rational parametrisation of the circle.


---

Comment by mmezzarobba created at 2019-10-16 10:17:02

Replying to [comment:11 vdelecroix]:
> Replying to [comment:9 vdelecroix]:
> > Replying to [comment:8 mmezzarobba]:
> > 
> > > * `self = self[1:]` would be better than `self -= a0` over RLF, intervals, ...
> > 
> 
> This is not the same operation. There is a shift in the degree with `self[1:]`.

Is there?


```
sage: P.<x> = QQ[]
sage: (1 + x)[1:]
x
```



---

Comment by mmezzarobba created at 2019-10-16 11:53:40

Replying to [comment:10 vdelecroix]:
> The implementation fails for non-commutative base rings

Hmm, right, I hadn't thought of that.

> Is there a way to fix it or should I forbid non-commutative base rings?

I don't know, sorry.


---

Comment by vdelecroix created at 2019-10-16 17:20:20

Replying to [comment:18 vdelecroix]:
> grrr, there is a bug with p-adic polynomial rings and the coercion model
> {{{
> sage: cm = get_coercion_model()
> sage: cm.bin_op(QQ['x'].one(), ZZ.one(), operator.truediv).parent()
> Univariate Polynomial Ring in x ...
> sage: cm.bin_op(Qp(7)['x'].one(), ZZ.one(), operator.truediv).parent()
> Fraction Field of Univariate Polynomial Ring in x ...
> }}}

Opened #28618...


---

Comment by embray created at 2020-01-06 14:10:03

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.
