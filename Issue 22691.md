# Issue 22691: Conversion between gmpy2 and sage integers

Issue created by migration from Trac.

Original creator: vklein

Original creation time: 2017-05-02 09:03:14

CC:  vdelecroix

Conversion between gmpy2 and sage integers:
- Implement method `__mpz__` on sage integer: return an gmpy2 mpz 
- Implement method `__mpq__` on sage rational: return an gmpy2 mpq
- Implement constructor for sage integer and rational with respectively mpz and mpq parameters.
- Provide coercion.


---

Comment by vklein created at 2017-05-02 15:05:37

Set assignee to vklein.


---

Comment by vdelecroix created at 2017-05-11 15:26:21

Changing keywords from "" to "jsb++".


---

Comment by vdelecroix created at 2017-05-11 15:28:40

Changing keywords from "jsb++" to "thursdaysbdx".


---

Comment by git created at 2017-05-16 14:06:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-05-17 17:22:33

Looks good. Some small remarks.

1) For the error about missing `gmpy2` you can use `PackageNotFoundError` from `sage.misc.package`

2) `add __mpz__() to class Rational` should be `add __mpq__() to class Rational`

3) You have an indentation problem here
{{{ 
Coercion for gmpy2 numbers    
    sage: from gmpy2 import * # optional - gmpy2
    sage: a, b = cm.canonical_coercion(mpz(5), 10) # optional - gmpy2
    sage: a, b # optional - gmpy2
}}}
It should be

```
Coercion for gmpy2 numbers::

    sage: from gmpy2 import * # optional - gmpy2
    sage: a, b = cm.canonical_coercion(mpz(5), 10) # optional - gmpy2
    sage: a, b # optional - gmpy2
```


4) There should be tests for `a + b`, `a * b`, `a / b` when one of `a` or `b` is from Sage and the other from `gmpy2`

5) Couldn't you share

```
#Handle gmpy2 objects
elif is_gmpy2_type(type(x)):
    return self.canonical_coercion(py_scalar_to_element(x), y)
elif is_gmpy2_type(type(y)):
    return self.canonical_coercion(x, py_scalar_to_element(y))
```

  with the associated code that deals with numpy types?


---

Comment by git created at 2017-05-18 11:33:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vklein created at 2017-05-18 13:27:43

Replying to [comment:8 vdelecroix]:
Done with commit [54c04ae](https://git.sagemath.org/sage.git/commit/?id=54c04ae7c0bf7d48ca89c1e21c4184133e4c6a9c)


---

Comment by vdelecroix created at 2017-05-18 15:59:40

With [PR #137 from gmpy2](https://github.com/aleaxit/gmpy/pull/137)

- you can get rid of the function `get_gmpy2_path()` and most of the declarations in `sage/libs/gmpy2.pxd`.

- you can add tests for conversions using the methods `__mpz__` and `__mpq__`

```
sage: import gmpy2
sage: gmpy2.mpz(23)
```

  and

```
sage: import gmpy2
sage: gmpy2.mpq(12/14)    
```



---

Comment by jdemeyer created at 2017-05-18 16:00:36

Is the coercion really needed? I mean, we cannot add coercion in Sage for every single external package. Is it really important that we can add a Sage polynomial to a gmpy2 integer for example?


---

Comment by vdelecroix created at 2017-05-18 16:07:15

Replying to [comment:18 jdemeyer]:
> Is the coercion really needed? I mean, we cannot add coercion in Sage for every single external package. Is it really important that we can add a Sage polynomial to a gmpy2 integer for example?

Not sure. Why do we provide coercion for `numpy`? It is convenient to have `Integer('2') + gmpy2.mpz('3')` working.


---

Comment by jdemeyer created at 2017-05-18 17:23:35

Replying to [comment:19 vdelecroix]:
> It is convenient to have `Integer('2') + gmpy2.mpz('3')` working.

Even if you agree with this, one needs to wonder whether the result should be a Sage integer or a gmpy2 integer (that's why I mentioned polynomials in [comment:18])


---

Comment by vklein created at 2017-05-22 10:21:46

The coercion aspect has been moved into another ticket #23052.


---

Comment by git created at 2017-05-22 12:43:57

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-05-22 16:03:55

Didn't we patch Cython in #22728 precisely to avoid needed to mess with include paths?


---

Comment by git created at 2017-05-22 23:37:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-05-22 23:40:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-05-23 06:48:59

Changing component from packages: optional to packages: standard.


---

Comment by vdelecroix created at 2017-05-23 07:03:45

- Is there a need of `get_gmpy2_path`?
- I think we should avoid the import `gmpy2` completely and that `is_gmpy2_type` can be much faster. I made [issue #139](https://github.com/aleaxit/gmpy/issues/139)
- Also test

```
sage: Integer(mpz(3))
sage: Rational(mpq(2, 3))
sage: Rational(mpz(5))
```



---

Comment by git created at 2017-05-23 14:25:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-05-24 15:08:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-05-24 15:59:50

In case a `mpz` is used to construct a `Rational` I would modify 

```
self.__set_value(integer.Integer(x), base)
```

to

```
mpq_set_z(self.value, MPZ(<MPZ_Object *> x))
```



---

Comment by vklein created at 2017-05-24 16:15:55

It may be faster but you lose a standard processing for all integer types.
For example if 

```
elif isinstance(x, integer.Integer):
            set_from_Integer(self, x)
}}} 
evolve in some way you must copy the modification for the MPZ_Object case.


---

Comment by vdelecroix created at 2017-06-01 19:54:35

Replying to [comment:33 vklein]:
> It may be faster but you lose a standard processing for all integer types.
> For example if 
> {{{
> elif isinstance(x, integer.Integer):
>             set_from_Integer(self, x)
> }}} 
> evolve in some way you must copy the modification for the MPZ_Object case. 

It is not only faster, it is much easier to read.

The concerned code is the following

```
elif MPQ_Check(<PyObject *> x):
    mpq_set(self.value, MPQ(<MPQ_Object *> x))
elif MPZ_Check(<PyObject *> x):
    self.__set_value(integer.Integer(x), base)
```

I don't see the logic in converting `x` to a Sage Integer and then calling `__set_value` instead of using the straightforward `mpq_set_z(...)`.

BTW, I don't understand your comment. What should be an evolution of `set_from_Integer`? An integer is a rational with denominator 1. This will not change in any near future.


---

Comment by vklein created at 2017-06-01 21:43:27

Replying to [comment:34 vdelecroix]:
> ...
> It is not only faster, it is much easier to read.
> 
Not sure if there is a clear difference in readability between the two options, 
by the way there are many recursive call in this function.

Another reason for the present choice was to be consistent with numpy.integer processing.
When modifying an existing code i tend to stick to the preceding coding style,
(And having a standard processing for all int type is an understandable design choice).
On the other hand in numpy.integer case doing a recursive call seems to be most concise way to do it, 
wich as you demonstrated is not the case for gmpy2 mpz.

That being said i got your point and prefer your solution.


---

Comment by git created at 2017-06-07 16:25:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-06-15 12:18:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by vdelecroix created at 2017-06-15 14:04:27

I thought that we agreed on [comment:32 comment:32]...


---

Comment by vklein created at 2017-06-15 14:06:42

A merge error


---

Comment by git created at 2017-06-15 14:32:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-06-22 12:26:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-06-22 16:51:19

Changing component from packages: standard to interfaces.


---

Comment by git created at 2017-06-23 12:03:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2017-06-23 13:08:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by vklein created at 2017-06-23 13:10:00

rebase on 8.0.beta12


---

Comment by vdelecroix created at 2017-06-23 13:11:11

With `RealNumber` you should check if precision is kept. Like with this number

```
sage: R = RealField(256)
sage: R.pi()
3.141592653589793238462643383279502884197169399375105820974944592307816406286
```

Is there a way to check the precision of a real number with gmpy2?


---

Comment by vklein created at 2017-06-23 13:49:02

Yes you can do it with the mpfr's precision attribute.


```

sage: from gmpy2 import mpfr
sage: R = RealField(256)
sage: r = mpfr(R.pi())
sage: r.precision
256

```

I will add this as a doctest


---

Comment by git created at 2017-06-23 13:55:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-13 14:22:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by jdemeyer created at 2017-11-13 14:40:45

Replying to [ticket:22928 vklein]:
> *All these features need `gmpy2` being a standard package.*

I don't think that this is completely true. I understand why you think so, but it shouldn't be too hard to implement this as an optional interface.


---

Comment by vklein created at 2017-11-13 15:02:51

At the begining i ve tried to make it optional. I don't rememeber exactly why i have come to the conclusion that  it can't be optional.
I will take a second look at it.


---

Comment by git created at 2017-11-14 09:11:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by vklein created at 2017-11-14 09:21:34

rebase on 8.1.rc0


---

Comment by jdemeyer created at 2017-11-14 11:08:08

There is some very ugly Cython code in this branch. I guess this is mostly caused by upstream's ignorance on how to do Cython declarations correctly. I'll try to fix this.


---

Comment by jdemeyer created at 2017-11-14 11:08:30

Working on this...


---

Comment by jdemeyer created at 2017-11-14 11:10:22

Is there any reason why we need this many commits? Can I just squash all that to 1 commit?


---

Comment by vklein created at 2017-11-14 11:28:22

Just historical reason.
The gmpy2's cython interface has evolved since this version. You can look if it covers what seems relevant to you [PR#155](https://github.com/aleaxit/gmpy/pull/155).

The plan of my last push was just to rebase this ticket before integrating the future stable version of gmpy2


---

Comment by jdemeyer created at 2017-11-14 12:35:12

I made an upstream pull request https://github.com/aleaxit/gmpy/pull/169 to clean up some Cython declarations.

Then, I cleaned up the branch on this ticket using that PR and I made this branch independent of the gmpy2 upgrade for easier development.
----
New commits:


---

Comment by vklein created at 2017-11-14 12:51:14

Thanks ! I will update the tarball of #22927, so people can test this ticket without doing their own (as current one doesn't contain the new cython interface).


---

Comment by jdemeyer created at 2017-11-14 13:07:47

Now working on making gmpy2 optional...


---

Comment by git created at 2017-11-14 15:32:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vklein created at 2017-11-14 15:40:27

working on complex types (`__mpc__` function and constructor)


---

Comment by jdemeyer created at 2017-11-16 18:39:05

New commits:


---

Comment by vdelecroix created at 2017-11-16 18:50:04

The documentation

```
Convert Sage ``ComplexNumber`` to gmpy2 ``Complex``.
```

refers to a type `Complex` that does not exist in gmpy2 and `ComplexNumber` should be one of `ComplexDoubleElement`, `MPComplexNumber` or `ComplexNumber` which are three distinct classes.


---

Comment by git created at 2017-11-17 08:55:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-24 16:53:43

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vklein created at 2017-11-24 16:55:43

Rebase on the last Trac #22927 HEAD


---

Comment by vklein created at 2017-11-24 16:56:01

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2017-11-24 17:02:28

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-11-24 17:02:28

This branch will not work. The commit in #24215 is `7f06e71` but you rebased it here. So there will be a conflict.


---

Comment by git created at 2017-11-24 18:33:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vklein created at 2017-11-24 18:39:51

rework done


---

Comment by vklein created at 2017-11-24 18:39:51

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2017-11-28 12:40:11

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-11-28 12:40:11


```
sage: import gmpy2
sage: gmpy2.mpz(1/2)
--> SEGFAULT <--
```



---

Comment by jdemeyer created at 2017-11-28 12:44:13

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-11-28 12:44:13

Replying to [comment:78 vdelecroix]:
> {{{
> sage: import gmpy2
> sage: gmpy2.mpz(1/2)
> --> SEGFAULT <--
> }}}

That is really a bug in `gmpy2`, not in Sage.


---

Comment by vdelecroix created at 2017-11-28 12:55:07

Indeed https://github.com/aleaxit/gmpy/issues/173


---

Comment by jdemeyer created at 2017-11-28 13:39:25

I might review this, but only after the dependencies have been merged in a beta.


---

Comment by jdemeyer created at 2017-12-14 12:06:55

Rebased to 8.2.beta0
----
New commits:


---

Comment by vklein created at 2017-12-14 15:18:24

Thanks for the rebase.


---

Comment by vklein created at 2017-12-22 10:45:17

rebase on 24417 in progress.


---

Comment by vklein created at 2017-12-22 10:45:17

Changing status from needs_review to needs_work.


---

Comment by vklein created at 2017-12-22 17:07:29

New commits:


---

Comment by vklein created at 2017-12-22 17:07:29

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2018-01-02 20:24:47

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2018-01-02 20:24:47

Some trivial merge/rebase to be done on 8.2.beta2


---

Comment by git created at 2018-01-14 17:18:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vklein created at 2018-01-14 17:20:23

Changing status from needs_work to needs_review.


---

Comment by vklein created at 2018-01-14 17:20:23

Rebase on 8.2.beta2


---

Comment by vdelecroix created at 2018-01-15 16:00:49

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2018-01-15 16:00:49

Sage is crashing

```
ImportError: /opt/sage/local/lib/python2.7/site-packages/sage/rings/complex_number.so: undefined symbol: mpc_set_fr_fr
```

The reason is that you are importing `from sage.libs.mpc cimport *` in `complex_number.pyx` and that this header file does not have the proper distutils directive. Just apply the patch

```diff
diff --git a/src/sage/libs/mpc.pxd b/src/sage/libs/mpc.pxd
index 0e12d31468..0067b8b126 100644
--- a/src/sage/libs/mpc.pxd
+++ b/src/sage/libs/mpc.pxd
`@``@` -1,3 +1,5 `@``@`
+# distutils: libraries = gmp mpfr mpc
+
 from sage.libs.gmp.types cimport *
 from sage.libs.mpfr.types cimport *
```



---

Comment by vdelecroix created at 2018-01-15 16:04:14

You should test different precisions for each possible type (that is `RealField(prec)`, `ComplexField(prec)` and `MPComplexField(prec)`).


---

Comment by vdelecroix created at 2018-01-15 16:04:24

The following is not nice

```
sage: gmpy2.mpfr(gmpy2.mpq('1/3'), precision=123).precision
123
sage: RealNumber(gmpy2.mpfr(gmpy2.mpq('1/3'), precision=123))
0.33333333333333333333333333333333333332
sage: _.prec()    # why not 123?
130
```

And this is even worse

```
sage: ComplexNumber(gmpy2.mpc(gmpy2.mpq('1/3'), precision=123r))
Traceback (most recent call last):
...
TypeError: unable to coerce to a ComplexNumber: <type 'str'>
```



---

Comment by vdelecroix created at 2018-01-15 16:05:25

Funny behavior of `gmpy2` precision with Sage integers

```
sage: gmpy2.mpfr('1.0', precision=40)
mpfr('1.0',40)
sage: gmpy2.mpc('1.0', precision=40)
Traceback (most recent call last):
...
TypeError: precision for mpc() must be integer or tuple
```

Is that worth an issue?


---

Comment by vklein created at 2018-01-15 16:13:05

> {{{#!diff
> diff --git a/src/sage/libs/mpc.pxd b/src/sage/libs/mpc.pxd
> index 0e12d31468..0067b8b126 100644
> --- a/src/sage/libs/mpc.pxd
> +++ b/src/sage/libs/mpc.pxd
> `@``@` -1,3 +1,5 `@``@`
> +# distutils: libraries = gmp mpfr mpc
> +
>  from sage.libs.gmp.types cimport *
>  from sage.libs.mpfr.types cimport *
> }}}
I have miss this one but encoutered it on 23024. It has been solved by updating module_list.py 
by adding mpc as a lib to sage.rings.complex_number Extension. 
What is the best way to fix it between these two ?


---

Comment by vdelecroix created at 2018-01-15 16:17:26

Modifying `module_list.py` is not a good idea. If I write my own Cython file with

```
from sage.rings.complex_number cimport whatever
```

Then my program will not compile.

addendum: will not compile if I do not explicitely state that my program needs to be linked against mpc... that would better to be automatic (especially in interactive use of Cython inside Sage)


---

Comment by vklein created at 2018-01-15 16:27:11

Ok i see.

Replying to [comment:95 vdelecroix]:
> Funny behavior of `gmpy2` precision with Sage integers
> {{{
> sage: gmpy2.mpfr('1.0', precision=40)
> mpfr('1.0',40)
> sage: gmpy2.mpc('1.0', precision=40)
> Traceback (most recent call last):
> ...
> TypeError: precision for mpc() must be integer or tuple
> }}}
> Is that worth an issue?
I think it is. I will look at it and open an issue if needed.


---

Comment by jdemeyer created at 2018-01-16 14:51:49

Replying to [comment:92 vdelecroix]:
> {{{#!diff
> diff --git a/src/sage/libs/mpc.pxd b/src/sage/libs/mpc.pxd
> index 0e12d31468..0067b8b126 100644
> --- a/src/sage/libs/mpc.pxd
> +++ b/src/sage/libs/mpc.pxd
> `@``@` -1,3 +1,5 `@``@`
> +# distutils: libraries = gmp mpfr mpc
> +
>  from sage.libs.gmp.types cimport *
>  from sage.libs.mpfr.types cimport *
> }}}

See #24549 for that.


---

Comment by vklein created at 2018-01-16 15:47:26

Replying to [comment:94 vdelecroix]:
> And this is even worse
> {{{
> sage: ComplexNumber(gmpy2.mpc(gmpy2.mpq('1/3'), precision=123r))
> Traceback (most recent call last):
> ...
> TypeError: unable to coerce to a [ComplexNumber](ComplexNumber): <type 'str'>
> }}}

But should we really use [ComplexNumber](ComplexNumber) this way ?\\
This call the function create_ComplexNumber and his first parameter is supposed to be the real part only.
\\
In your call the first parameter is the whole complex number.
\\
Secondly create_ComplexNumber always try to convert the parameters (real and imag) into string before calling the [ComplexNumber](ComplexNumber) constructor. \\
Given that if you try to call ComplexNumber() with another complex type as parameter you will get the same result :


```
sage: cn = ComplexNumber(5,4)
sage: ComplexNumber(cn)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: unable to coerce to a ComplexNumber: <type 'str'>
```



---

Comment by vdelecroix created at 2018-01-17 12:35:35

The `ComplexNumber` function is wrong in several ways (see #13110). Just ignore it.


---

Comment by vklein created at 2018-01-22 09:26:08

Replying to [comment:94 vdelecroix]:
> The following is not nice
> {{{
> sage: gmpy2.mpfr(gmpy2.mpq('1/3'), precision=123).precision
> 123
> sage: RealNumber(gmpy2.mpfr(gmpy2.mpq('1/3'), precision=123))
> 0.33333333333333333333333333333333333332
> sage: _.prec()    # why not 123?
> 130
Like for `ComplexNumber` function it seems that `RealNumber` function it's not designed to be used this way. It's supposed to take a string as first parameter. \\

That being said the gmpy2's precision is not currently transmitted with `RR` function.


```
sage: RR(gmpy2.mpfr(gmpy2.mpq('1/3'), precision=123))
0.333333333333333
sage: _.prec()
53
```


I am on it.


---

Comment by vklein created at 2018-01-22 10:54:49

The only fix i see so far would be do a new `mpfr_init2` during `_set ` call. It's a little ugly :

```
#real_mpfr.pyx line 1467
   elif HAVE_GMPY2 and type(x) is gmpy2.mpfr:
       self._parent = self._parent.to_prec(x.precision)
       mpfr_init2(self.value, x.precision)
       mpfr_set(self.value, (<gmpy2.mpfr>x).f, parent.rnd)
```


Or we can assume the user shoud do that :


```
sage: R = RealField(128)
sage: R(gmpy2.mpfr(gmpy2.mpq('1/3'), precision=128))
0.33333333333333333333333333333333333333
sage: _.prec()
128
```



---

Comment by vdelecroix created at 2018-01-22 14:28:32

`RealNumber` should be ignored for the same reason (it is aimed to be used by the preparser). You can read #13110 that I already mentioned in [comment:101 comment:101].


---

Comment by vklein created at 2018-01-22 14:35:03

Sure ! My current question was more about what should we do for the `RR` function. Should we transmit the precision (and replacing the parent during `__c_init__` or during `_set`) or rely on a consistent usage of `RealField` ?


---

Comment by vdelecroix created at 2018-01-22 16:44:54

Replying to [comment:102 vklein]:
> Replying to [comment:94 vdelecroix]:
> {{{
> sage: RR(gmpy2.mpfr(gmpy2.mpq('1/3'), precision=123))
> 0.333333333333333
> sage: _.prec()
> 53
> }}}

That's fine. `RR` is the field of floating-point numbers with 53 bits of precision (stupidly named).


---

Comment by vdelecroix created at 2018-01-22 18:05:57

That is to say: `RR` is not a function. It is the object `RealField(53)`.

```
sage: RR is RealField(53)
True
```



---

Comment by git created at 2018-01-23 10:51:15

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vklein created at 2018-01-23 10:54:51

Changing status from needs_work to needs_review.


---

Comment by vklein created at 2018-01-23 10:54:51

Add some test with different precision [comment:93](https://trac.sagemath.org/ticket/22928#comment:93).\\
Rebase on #24549.


---

Comment by vdelecroix created at 2018-01-23 11:04:24

You do not need to put `# optional - gmpy2` everywhere. Only where you explicitely need `gmpy2`.

Could you also doctest the fact that the composition of conversions `Sage number -> gmpy2 number -> Sage number` is the identity when precisions are set appropriately (ie we get back an equal element)? For example

```
sage: MPCF = MPComplexField(63)
sage: x = MPCF('15.64E+128', '15.64E+128')
sage: y = mpc(x)         # optional - gmpy2
sage: y.precision        # optional - gmpy2
(63, 63)
sage: MPCF(y) == x       # optional - gmpy2
True
```

And also the other way around `gmpy2 number -> Sage number -> gmpy2 number`

```
sage: x = gmpy2.mpc('1.324+4e50j', precision=(70,70))  # optional - gmpy2
sage: y = ComplexField(70)(x)                          # optional - gmpy2
sage: gmpy2.mpc(y) == x                                # optional - gmpy2
True
```



---

Comment by vklein created at 2018-01-23 13:03:29

Changing status from needs_review to needs_work.


---

Comment by vklein created at 2018-01-23 13:03:29

Ok i will add this type of doctest.


---

Comment by vklein created at 2018-01-23 13:56:50

These tests works with `MPComplexField` and `RealField` but they didn't work with `ComplexField` in `gmpy2 number -> Sage number -> gmpy2 number` way :


```
sage: x = gmpy2.mpc('1.324+4e50j', precision=(70,70))
sage: y = ComplexField(70)(x)
sage: gmpy2.mpc(y) == x
False
sage: x
mpc('1.3240000000000000000005+3.9999999999999999999976e+50j',(70,70))
sage: gmpy2.mpc(y)
mpc('1.3240000000000000657252+4.0000000000000003051908e+50j',(70,70))
```

Is this an issue or a normal rounding behaviour ?


---

Comment by vdelecroix created at 2018-01-23 15:06:45

Replying to [comment:112 vklein]:
> These tests works with `MPComplexField` and `RealField` but they didn't work with `ComplexField` in `gmpy2 number -> Sage number -> gmpy2 number` way :
> 
> {{{
> sage: x = gmpy2.mpc('1.324+4e50j', precision=(70,70))
> sage: y = ComplexField(70)(x)
> sage: gmpy2.mpc(y) == x
> False
> }}}
> Is this an issue or a normal rounding behaviour ?

To me, this is an issue. The code in your example should just be copying `mpfr_t` values around.


---

Comment by vdelecroix created at 2018-01-23 15:07:17

Are you sure that `precision` means the same thing on both sides?


---

Comment by vklein created at 2018-01-23 15:54:58

I think that the problem is that we just copy the values of real and imag part and both of them are `gmpy2.mpfr` with their own precision.


```
sage: x = gmpy2.mpc('1.324+4e50j', precision=(70,70))
sage: x.precision
(70, 70)
sage: x.real.precision
53
sage: x.imag.precision
53
sage: x
mpc('1.3240000000000000000005+3.9999999999999999999976e+50j',(70,70))
sage: x.real, x.imag
(mpfr('1.3240000000000001'), mpfr('4.0000000000000003e+50'))
```


`MPComplexField` works fine because it use mpc_set and not two mpfr_set.


---

Comment by vdelecroix created at 2018-01-23 15:59:48

I don't know if it is a bug from `gmpy2` but having `x.real` to return a double precision and not the corresponding `gmpy2.mpfr` with the same precision as the real part is weird. Would be nice to see whether it is intended in `gmpy2`.

For this ticket you could just avoid using `.real` and `.imag` in the `ComplexNumber` code.


---

Comment by vdelecroix created at 2018-01-23 16:01:11

Specification are really cool!

```
imag
    Returns the imaginary component.
real
    Returns the real component.
```

(see https://github.com/aleaxit/gmpy/blob/master/docs/mpc.rst)


---

Comment by vklein created at 2018-01-23 16:53:47

Yes very accurate !

It works fine without `.real` and `.imag`. Tests are running now.


---

Comment by git created at 2018-01-23 21:13:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vklein created at 2018-01-23 21:14:47

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2018-01-24 08:04:16

Do you really need the cast `<mpc_t>`? This is already explicit in the `gmpy2` Cython header.


---

Comment by vklein created at 2018-01-24 08:16:55

I think i do at least 

```
 mpfr_set(self.__im, (<gmpy2.mpc>real).c.im, rnd)
                                                      ^
------------------------------------------------------------

sage/rings/complex_number.pyx:197:55: Cannot convert Python object to '__mpfr_struct *'
```


What syntax would you suggest ?


---

Comment by vdelecroix created at 2018-01-24 09:31:15

Replying to [comment:122 vklein]:
> I think i do at least 
> {{{
>  mpfr_set(self.__im, (<gmpy2.mpc>real).c.im, rnd)
>                                                       ^
> ------------------------------------------------------------
> 
> sage/rings/complex_number.pyx:197:55: Cannot convert Python object to '__mpfr_struct *'
> }}}
> 
> What syntax would you suggest ?

The one in your comment. There might be something wrong with the Cython headers. Maybe the following change in `gmpy2.pxd` might be enough 

```diff
diff --git a/src/gmpy2.pxd b/src/gmpy2.pxd
index 7cdcc72..d6cac1b 100644
--- a/src/gmpy2.pxd
+++ b/src/gmpy2.pxd
`@``@` -45,7 +45,8 `@``@` cdef extern from "mpfr.h":
 cdef extern from "mpc.h":
     # mpc complexes
     ctypedef struct __mpc_struct:
-        pass
+        mpfr_t re
+        mpfr_t im
     ctypedef __mpc_struct mpc_t[1];
     ctypedef __mpc_struct *mpc_ptr;
     ctypedef const __mpc_struct *mpc_srcptr;
```



---

Comment by vklein created at 2018-01-24 09:57:30

It works with your solution. That being said i am not sure if avoiding a cast is worth patching `gmpy2`. \\
I would rather keep the current syntax and do a proper pull request for `gmpy2`.


---

Comment by jdemeyer created at 2018-01-24 14:51:50

Replying to [comment:118 vklein]:
> Yes very accurate !
> 
> It works fine without `.real` and `.imag`. Tests are running now.

This is also obviously an upstream bug.


---

Comment by jdemeyer created at 2018-01-24 15:19:52

In `complex_number.pyx` you are only using the `mpc_t` type, nothing else from MPC. So just use `from sage.libs.mpc.types cimport mpc_t`.


---

Comment by jdemeyer created at 2018-01-24 15:20:34

I think it would be good to at least _report_ the bugs upstream to gmpy2.


---

Comment by jdemeyer created at 2018-01-24 15:21:34

Changing status from needs_review to needs_work.


---

Comment by vklein created at 2018-01-24 18:48:53

Replying to [comment:127 jdemeyer]:
> I think it would be good to at least _report_ the bugs upstream to gmpy2.

Sure you're right. https://github.com/aleaxit/gmpy/issues/179


---

Comment by git created at 2018-01-24 18:56:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vklein created at 2018-01-24 18:59:05

Changing status from needs_work to needs_review.


---

Comment by vklein created at 2018-01-24 18:59:05

Replying to [comment:126 jdemeyer]:
> In `complex_number.pyx` you are only using the `mpc_t` type, nothing else from MPC. So just use `from sage.libs.mpc.types cimport mpc_t`.

Done


---

Comment by jdemeyer created at 2018-01-24 20:10:12

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2018-01-24 20:10:12

Replying to [comment:132 vklein]:
> Replying to [comment:126 jdemeyer]:
> > In `complex_number.pyx` you are only using the `mpc_t` type, nothing else from MPC. So just use `from sage.libs.mpc.types cimport mpc_t`.
> 
> Done

No. I wrote `from sage.libs.mpc.types cimport mpc_t` and I meant exactly what I wrote.


---

Comment by vklein created at 2018-01-24 22:12:20

Doctests crash at runtime with the later syntax. 


```
sage -t --long src/sage/rings/complex_number.pyx
Traceback (most recent call last):
  File "/home/vklein/odk/sage/src/bin/sage-runtests", line 123, in <module>
    from sage.doctest.control import DocTestController
  File "/home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/doctest/control.py", line 33, in <module>
    from .sources import FileDocTestSource, DictAsObject
  File "/home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/doctest/sources.py", line 32, in <module>
    from .parsing import SageDocTestParser
  File "/home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/doctest/parsing.py", line 57, in <module>
    from sage.all import RealIntervalField
  File "/home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/all.py", line 87, in <module>
    from sage.misc.all       import *         # takes a while
  File "/home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/misc/all.py", line 84, in <module>
    from .functional import (additive_order,
  File "/home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/misc/functional.py", line 27, in <module>
    from sage.rings.complex_double import CDF
  File "sage/rings/integer.pxd", line 7, in init sage.rings.complex_double
  File "sage/rings/rational.pxd", line 8, in init sage.rings.integer
  File "sage/rings/rational.pyx", line 94, in init sage.rings.rational
  File "sage/rings/real_mpfr.pyx", line 1, in init sage.rings.real_mpfr
  File "sage/rings/complex_number.pxd", line 6, in init sage.libs.mpmath.utils
ImportError: /home/vklein/odk/sage/local/lib/python2.7/site-packages/sage/rings/complex_number.so: undefined symbol: mpc_set_fr_fr
```



---

Comment by vdelecroix created at 2018-01-25 07:11:47

Indeed, `mpc/types.pxd` does not contain the distutils directive for libraries. Since `types.pxd` is included in all other files in `mpc/` it makes more sense to have the directive in this file rather than in `__init__.pxd`.


---

Comment by jdemeyer created at 2018-01-25 08:45:05

But who is calling `mpc_set_fr_fr` in that file?


---

Comment by jdemeyer created at 2018-01-25 08:52:36

I see. The `gmpy2` function `GMPy_MPC_From_mpfr` requires MPC.


---

Comment by vdelecroix created at 2018-01-25 09:07:05

Should we add a distutils directive to the `gmpy2.pxd` header?


---

Comment by jdemeyer created at 2018-01-25 09:10:18

Replying to [comment:138 vdelecroix]:
> Should we add a distutils directive to the `gmpy2.pxd` header?

No because not everybody using that header will need every library. It seems overkill to require gmp and mpfr and mpc if you only ever use the `mpz_t` type.

I was thinking about something else: it is trivial to replace `mpc_set_fr_fr` by two `mpfr_set` calls. So maybe we could just do that. I'll try to create a PR for gmpy2.


---

Comment by vdelecroix created at 2018-01-25 09:29:36

Replying to [comment:139 jdemeyer]:
> Replying to [comment:138 vdelecroix]:
> > Should we add a distutils directive to the `gmpy2.pxd` header?
> 
> No because not everybody using that header will need every library. It seems overkill to require gmp and mpfr and mpc if you only ever use the `mpz_t` type.
> 
> I was thinking about something else: it is trivial to replace `mpc_set_fr_fr` by two `mpfr_set` calls. So maybe we could just do that. I'll try to create a PR for gmpy2.

Using `mpc_set_fr_fr` would impose to link against mpfr. A cleaner possibility is to split the `gmpy2` headers into 3 headers `gmpy2.gmp`, `gmpy2.mpfr` and `gmpy2.mpc`. Each of them with a proper distutils directive.


---

Comment by jdemeyer created at 2018-01-25 09:38:27

Replying to [comment:140 vdelecroix]:
> Using `mpc_set_fr_fr` would impose to link against mpfr.

I guess you mean "using `mpfr_set` would impose to link against mpfr".

But that is in fact a very logical requirement, since the input type of `GMPy_MPC_From_mpfr` is `mpfr_t`. So you already need to have an `mpfr_t` in order to use that function, which makes it likely that you are using MPFR already.


---

Comment by vdelecroix created at 2018-01-25 09:41:19

Replying to [comment:142 jdemeyer]:
> Replying to [comment:140 vdelecroix]:
> > Using `mpc_set_fr_fr` would impose to link against mpfr.
> 
> I guess you mean "using `mpfr_set` would impose to link against mpfr".
> 
> But that is in fact a very logical requirement, since the input type of `GMPy_MPC_From_mpfr` is `mpfr_t`. So you already need to have an `mpfr_t` in order to use that function, which makes it likely that you are using MPFR already.

And using a `mpc` from `gmpy2` does not imply that you are using `mpc`!?


---

Comment by vklein created at 2018-01-25 10:01:17

Will it be so inconsistent to just stick with `from sage.libs.mpc cimport *` for this ticket? \\
I don't see clearly how much impact it has on memory/performance.


---

Comment by jdemeyer created at 2018-01-25 10:02:19

Replying to [comment:143 vdelecroix]:
> And using a `mpc` from `gmpy2` does not imply that you are using `mpc`!?

Sure, but in an indirect way, through the `gmpy2` package. My point is that you shouldn't require the MPC library in the Cython module which creates a `gmpy2.mpc` object.


---

Comment by jdemeyer created at 2018-01-25 10:03:59

Replying to [comment:144 vklein]:
> Will it be so inconsistent to just stick with `from sage.libs.mpc cimport *` for this ticket? \\
> I don't see clearly how much impact it has on memory/performance.

I agree... we can still fix this later. I'd like to wait a little bit for an answer from upstream though.


---

Comment by jdemeyer created at 2018-01-25 10:04:41

With my patch to gmpy2, the following works:

```diff
diff --git a/src/sage/rings/complex_number.pyx b/src/sage/rings/complex_number.pyx
index bf0e4a3..76782c3 100644
--- a/src/sage/rings/complex_number.pyx
+++ b/src/sage/rings/complex_number.pyx
`@``@` -31,7 +31,7 `@``@` from __future__ import absolute_import, print_function
 import math
 import operator
 
-from sage.libs.mpc cimport mpc_t
+from sage.libs.mpc.types cimport mpc_t
 from sage.libs.mpfr cimport *
 from sage.structure.element cimport FieldElement, RingElement, Element, ModuleElement
 from sage.categories.map cimport Map
`@``@` -193,8 +193,8 `@``@` cdef class ComplexNumber(sage.structure.element.FieldElement):
             elif isinstance(real, complex):
                 real, imag = real.real, real.imag
             elif HAVE_GMPY2 and type(real) is gmpy2.mpc:
-                mpfr_set(self.__re, (<mpc_t>(<gmpy2.mpc>real).c).re, rnd)
-                mpfr_set(self.__im, (<mpc_t>(<gmpy2.mpc>real).c).im, rnd)
+                mpfr_set(self.__re, (<gmpy2.mpc>real).c.re, rnd)
+                mpfr_set(self.__im, (<gmpy2.mpc>real).c.im, rnd)
                 return
             else:
                 imag = 0
```



---

Comment by vklein created at 2018-01-25 15:12:28

And i have fixed issue ​[gmpy2 issue #179](https://github.com/aleaxit/gmpy/pull/179) with this PR
https://github.com/aleaxit/gmpy/pull/181.

What should we do next ? :
- Waiting for a gmpy2 release.
- Doing sage patchs for gmpy2 (maybe after `gmpy2` PR's are reviewed and merged).
- Or switch this ticket in need_review as it is.


---

Comment by vdelecroix created at 2018-01-25 15:54:49

Replying to [comment:148 vklein]:
> And i have fixed issue ​[gmpy2 issue #179](https://github.com/aleaxit/gmpy/pull/179) with this PR
> https://github.com/aleaxit/gmpy/pull/181.
> 
> What should we do next ? :
> - Waiting for a gmpy2 release.
> - Doing sage patchs for gmpy2 (maybe after `gmpy2` PR's are reviewed and merged).
> - Or switch this ticket in need_review as it is.

I would say
- create a patch and add it to gmpy2
- move the ticket in needs review
- wait for the PR to be accepted before setting it to positive review
The rationale is that we are currently testing gmpy2 integration. At the time it stabilizes, we should ask for a new release and remove all of Sage patches.


---

Comment by jdemeyer created at 2018-01-25 16:03:50

Fine for me!


---

Comment by git created at 2018-01-26 10:31:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-26 10:44:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vklein created at 2018-01-26 10:48:47

Changing status from needs_work to needs_review.


---

Comment by vklein created at 2018-01-26 10:48:47

Patch are done. The corresponding PRs are merged.


---

Comment by jdemeyer created at 2018-01-26 10:52:24

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2018-01-26 10:52:24

You need to bump the `gmpy2` version number for the patches to apply.


---

Comment by git created at 2018-01-26 10:58:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vklein created at 2018-01-26 10:59:04

Changing status from needs_work to needs_review.


---

Comment by vklein created at 2018-01-26 10:59:04

I see, thanks.


---

Comment by vdelecroix created at 2018-01-26 13:26:58

The following line misses a `# optional - gmpy2`

```
            sage: x = mpfr(R.pi())
```



---

Comment by vklein created at 2018-01-26 13:32:06

Yeah and two others after this one 


```
sage: y = RealField(128)(x) 
sage: mpfr(y) == x
```


I will rerun tests without gmpy2 package installed


---

Comment by vklein created at 2018-01-26 13:33:17

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-01-26 16:16:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vklein created at 2018-01-26 16:20:09

All test without gmpy2 passed, tests with gmpy2 are runnings.


---

Comment by vdelecroix created at 2018-01-26 16:31:20

needs review? The branch is fine for me in the current state.


---

Comment by vklein created at 2018-01-26 16:33:08

Changing status from needs_work to needs_review.


---

Comment by vklein created at 2018-01-26 16:33:08

Okay then.


---

Comment by vdelecroix created at 2018-01-26 16:37:05

In `real_double.pyx` you call `cimport gmpy2` but does not do `gmpy2.import_gmpy2()`.


---

Comment by vklein created at 2018-01-26 20:40:30

Yes but `real_double.pyx` do `cimport sage.ring.integer` and the later call `gmpy2.import_gmpy2()`.


---

Comment by jdemeyer created at 2018-01-27 08:05:22

Replying to [comment:166 vklein]:
> Yes but `real_double.pyx` do `cimport sage.ring.integer` and the later call `gmpy2.import_gmpy2()`. 

This sentence makes me sad and worried at the same time. It shows that you absolutely do not understand what `import_gmpy2()` does.

The _real reason_ that you don't need `import_gmpy2()` in that file is that you are simply not calling any gmpy2 functions in that Cython module.


---

Comment by vdelecroix created at 2018-01-30 14:25:45

Is it ok Jeroen?


---

Comment by jdemeyer created at 2018-01-30 14:30:48

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-02-02 12:06:15

Resolution: fixed


---

Comment by slabbe created at 2018-05-01 09:05:55

A small remark to say that some warnings associated to gmpy2 appear at each run of `sage -b` (without gmpy2):


```
[sagelib-8.2.rc3] sage/rings/complex_double.pyx: cannot find cimported module 'gmpy2'
[sagelib-8.2.rc3] sage/rings/complex_number.pyx: cannot find cimported module 'gmpy2'
[sagelib-8.2.rc3] sage/rings/integer.pyx: cannot find cimported module 'gmpy2'
[sagelib-8.2.rc3] sage/rings/complex_mpc.pyx: cannot find cimported module 'gmpy2'
[sagelib-8.2.rc3] sage/rings/rational.pyx: cannot find cimported module 'gmpy2'
[sagelib-8.2.rc3] sage/rings/real_double.pyx: cannot find cimported module 'gmpy2'
[sagelib-8.2.rc3] sage/rings/real_mpfr.pyx: cannot find cimported module 'gmpy2'
```


Is it possible to clean this?


---

Comment by vklein created at 2018-05-01 09:25:00

According to Jeroen it's harmless and will require a cython patch to fix it.


---

Comment by jdemeyer created at 2018-05-01 09:36:24

Replying to [comment:171 slabbe]:
> Is it possible to clean this?

Unfortunately, it's not easy to properly fix. The basic problem is that the `cimport` is parsed very very early in the Cython build system, at a point where macros like `HAVE_GMPY2` are not considered yet.
