# Issue 24572: Speed up lattice precision p-adics

archive/issues_024572.json:
```json
{
    "body": "CC:  roed caruso tristanvaccon\n\nKeywords: lattice precision\n\n* Drop labels keyword in parents & make parents more unique\n* Switch to templates for elements\n* Switch to cython for precision lattice\n* Specialized data structure for matrix\n* Make pickling and conversion more robust (pickling should dump the full lattice matrix and unpickling restores the matrix but puts it next to the existing matrix)\n* Share precision lattice between all parents with the same p.\n\nIssue created by migration from https://trac.sagemath.org/ticket/24809\n\n",
    "created_at": "2018-02-21T15:34:28Z",
    "labels": [
        "padics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.2",
    "title": "Speed up lattice precision p-adics",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24572",
    "user": "saraedum"
}
```
CC:  roed caruso tristanvaccon

Keywords: lattice precision

* Drop labels keyword in parents & make parents more unique
* Switch to templates for elements
* Switch to cython for precision lattice
* Specialized data structure for matrix
* Make pickling and conversion more robust (pickling should dump the full lattice matrix and unpickling restores the matrix but puts it next to the existing matrix)
* Share precision lattice between all parents with the same p.

Issue created by migration from https://trac.sagemath.org/ticket/24809





---

archive/issue_comments_344748.json:
```json
{
    "body": "About pickling/unpickling, I propose the following interface:\n\n- (usual syntax) if `x` is a p-adic, `dumps(x)` saves `x` as `approx + O(p^prec)` but diffused digits implying `x` are not saved\n- if `R` is a parent (and/or a precision lattice maybe), `R.dumps_elements(x,y,z,...)` saves the approximation of all listed elements together with a lattice representing the precision on this set of elements\n- `loads(obj)` loads the stored variables in `obj` (they can be many of them if `obj` was constructed by `dumps_elements`) as new independant variables.\n\nHow does it sound?",
    "created_at": "2018-02-22T08:56:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24572",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24572#issuecomment-344748",
    "user": "caruso"
}
```

About pickling/unpickling, I propose the following interface:

- (usual syntax) if `x` is a p-adic, `dumps(x)` saves `x` as `approx + O(p^prec)` but diffused digits implying `x` are not saved
- if `R` is a parent (and/or a precision lattice maybe), `R.dumps_elements(x,y,z,...)` saves the approximation of all listed elements together with a lattice representing the precision on this set of elements
- `loads(obj)` loads the stored variables in `obj` (they can be many of them if `obj` was constructed by `dumps_elements`) as new independant variables.

How does it sound?



---

archive/issue_comments_344749.json:
```json
{
    "body": "I am not sure how `dumps_elements` would integrate with the usual pickling workflow, say when pickling something like a matrix.\n\nI think a simpler interface is not harder implement and makes things less surprising:\n* Whenever we pickle an element we pickle its entire precision lattice. So, if we happen to pickle many elements at the same time, say a polynomial, we pickle their lattice (once.)\n* Restoring elements just appends the pickled lattice to the existing lattice and does a \"drop unused columns\".\n\nWhile this is not a very space-efficient format (but I guess we don't care) it gives us both behaviours you describe above automatically, doesn't it?",
    "created_at": "2018-02-22T09:16:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24572",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24572#issuecomment-344749",
    "user": "saraedum"
}
```

I am not sure how `dumps_elements` would integrate with the usual pickling workflow, say when pickling something like a matrix.

I think a simpler interface is not harder implement and makes things less surprising:
* Whenever we pickle an element we pickle its entire precision lattice. So, if we happen to pickle many elements at the same time, say a polynomial, we pickle their lattice (once.)
* Restoring elements just appends the pickled lattice to the existing lattice and does a "drop unused columns".

While this is not a very space-efficient format (but I guess we don't care) it gives us both behaviours you describe above automatically, doesn't it?
