# Issue 24027: Allow "generic" PolynomialRing implementation

Issue created by migration from https://trac.sagemath.org/ticket/24264

Original creator: jdemeyer

Original creation time: 2017-11-22 12:59:12

CC:  embray tscrim

It is possible to specify a specific backend like `PolynomialRing(QQ, 'x', implementation="singular")` but the opposite (asking for a generic Sage implementation) is not. Fix this by allowing `implementation="generic"`.


---

Comment by embray created at 2017-11-22 13:01:01

+1


---

Comment by jdemeyer created at 2017-11-23 09:52:33

This is harder than expected due to caching. Currently, the caching does not take into account the `implementation` keyword. That is an existing bug, but it makes it pointless to add more support for the `implementation` keyword.


---

Comment by embray created at 2017-11-23 10:14:54

Wouldn't it make sense to fix that?  It doesn't need to use the "implementation" keyword per se, but it would make sense if the type a method was called on was also cached?

I'm likely missing something though since I don't know exactly what you mean in this case by "caching".


---

Comment by jdemeyer created at 2017-11-23 11:39:21

Replying to [comment:6 embray]:
> Wouldn't it make sense to fix that?

Of course. I'm just saying that this makes it harder than I initially expected.


---

Comment by jdemeyer created at 2017-11-23 11:41:57

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-11-23 11:41:57

New commits:


---

Comment by jdemeyer created at 2017-11-23 12:26:48

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-11-23 14:14:44

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-11-23 14:15:33

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-11-23 22:24:26

This change:

```diff
diff --git a/src/sage/algebras/free_algebra.py b/src/sage/algebras/free_algebra.py
index e6c66e9..09db35d 100644
--- a/src/sage/algebras/free_algebra.py
+++ b/src/sage/algebras/free_algebra.py
@@ -269,7 +269,7 @@ class FreeAlgebraFactory(UniqueFactory):
         # test if we can use libSingular/letterplace
         if implementation == "letterplace":
             args = [arg for arg in (arg1, arg2) if arg is not None]
-            kwds = dict(sparse=sparse, order=order, implementation="singular")
+            kwds = dict(order=order, implementation="singular")
             if name is not None:
                 kwds["name"] = name
             if names is not None:
```

seems to cause multiple failures with the free algebra:

```
sage -t --long src/sage/algebras/free_algebra.py  # 12 doctests failed
sage -t --long src/sage/algebras/letterplace/letterplace_ideal.pyx  # Bad exit: 14
sage -t --long src/sage/algebras/letterplace/free_algebra_letterplace.pyx  # 19 doctests failed
sage -t --long src/sage/algebras/letterplace/free_algebra_element_letterplace.pyx  # 31 doctests failed
```

See patchbots.

Also, we (and singular?) only have sparse implementations for multivariate polynomials, right?


---

Comment by jdemeyer created at 2017-11-24 09:20:44

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-11-24 10:19:14

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-24 10:24:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-11-24 10:25:41

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-11-24 10:26:53

Replying to [comment:15 tscrim]:
> seems to cause multiple failures with the free algebra:

Fixed by allowing `sparse=None` to mean `sparse=True` in the multi-variate case.


---

Comment by jdemeyer created at 2017-11-27 08:07:01

Patchbot is green now.


---

Comment by tscrim created at 2017-11-27 08:32:05

What are your thoughts about changing `_implementation_names` to `_implementation`, which only takes a string? It is only used to differentiate between FLINT and NTL implementations in coercion. I think it could simplify the code overall.

Furthermore, how do you feel about instead of storing a key for all implementation keywords possible, we instead standardize the implementation keyword to always give the actual implementation. I know it is a little more brittle, but I think it will make the code more clean and would work well with the above suggestion. I haven't yet fully attempted this, but I will be happy to do this if you do not object.

One thing that definitely needs fixing: By allowing generic coercions, we are introducing a memory leak via cyclic coercion between the generic and FLINT implementations:

```
sage: RF.<x> = PolynomialRing(ZZ, implementation='FLINT')
sage: RG.<x> = PolynomialRing(ZZ, implementation='generic')
sage: RF.coerce_map_from(RG)
sage: RF.has_coerce_map_from(RG)
True
sage: RG.has_coerce_map_from(RF)
True
```

I've been told that this circular coercion gives a memory leak because the co(?)domain is cached by the coercion model. Although I cannot reproduce it:

```
sage: import gc
sage: for i in range(10000):
....:     if i % 100 == 0:
....:         get_memory_usage()
....:     R = PolynomialRing(ZZ, 'x%s'%i, implementation='FLINT')
....:     S = PolynomialRing(ZZ, 'x%s'%i, implementation='generic')
....:     assert R is not S
....:     assert R.coerce_map_from(S) is not None
....:     assert S.coerce_map_from(R) is not None
....:     del R
....:     del S
....:     _ = gc.collect()
5872.29296875
5872.29296875
5872.29296875
5872.29296875
...
```

However, it does introduce a *very* subtle reason why code could suddenly become slow by multiplying things in the opposite order. We will have to update things accordingly in that spot in `PolynomialRing._coerce_map_from_`.


---

Comment by jdemeyer created at 2017-11-27 09:35:31

Replying to [comment:22 tscrim]:
> Furthermore, how do you feel about instead of storing a key for all implementation keywords possible, we instead standardize the implementation keyword to always give the actual implementation.

Well, this will slow down creating polynomial rings. Every time that you create a polynomial ring with `implementation=None` (which is the default, so the most common case), you will need to run some code to figure out the implementation.

Let me give a counter-proposal: instead of making `_implementation_names` an attribute, we create a static method on the polynomial ring class:

```python
# Assuming that the implementation for a given polynomial ring class
# depends only on the base_ring, which is currently the case.
@staticmethod
def _implementation_names(base_ring, implementation):
    # Default implementation for generic polynomial rings
    if implementation is None or implementation == "generic":
        return ["generic", None]
    raise ValueError("unknown implementation {!r}".format(implementation))
```


I think that this will lead to cleaner code without the performance loss of normalizing the `implementation` every time.


---

Comment by tscrim created at 2017-11-27 22:39:21

Replying to [comment:23 jdemeyer]:
> Replying to [comment:22 tscrim]:
> > Furthermore, how do you feel about instead of storing a key for all implementation keywords possible, we instead standardize the implementation keyword to always give the actual implementation.
> 
> Well, this will slow down creating polynomial rings. Every time that you create a polynomial ring with `implementation=None` (which is the default, so the most common case), you will need to run some code to figure out the implementation.

Ah, that is a good point about having to process the input.

> Let me give a counter-proposal: instead of making `_implementation_names` an attribute, we create a static method on the polynomial ring class:
> {{{
> #!python
> # Assuming that the implementation for a given polynomial ring class
> # depends only on the base_ring, which is currently the case.
> `@`staticmethod
> def _implementation_names(base_ring, implementation):
>     # Default implementation for generic polynomial rings
>     if implementation is None or implementation == "generic":
>         return ["generic", None]
>     raise ValueError("unknown implementation {!r}".format(implementation))
> }}}
> 
> I think that this will lead to cleaner code without the performance loss of normalizing the `implementation` every time.

+1 Do you want me to do this or will you?


---

Comment by jdemeyer created at 2017-11-30 10:47:37

Let me give this a try.


---

Comment by jdemeyer created at 2017-11-30 13:14:55

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-11-30 15:58:01

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-11-30 15:59:28

Replying to [comment:25 jdemeyer]:
> Let me give this a try.

Done. This was more work than I initially thought, but I am happy with the result. The code looks cleaner than before.


---

Comment by jdemeyer created at 2017-11-30 15:59:28

Changing status from needs_work to needs_review.


---

Comment by git created at 2017-11-30 21:30:04

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2017-11-30 22:12:54

It definitely is cleaner to me as well. Some comments:

- This seems fragile:
  {{{#!python
        implementation = self._implementation_names(implementation, base_ring)[0]
        if implementation == "NTL":
  }}}
  I would instead do
  {{{#!python
        implementation = self._implementation_names(implementation, base_ring)[0]
        if "NTL" in implementation:
  }}}
- The cyclic coercion (comment:22) should get a doctest for only the generic to FLINT (if I am reading the code correctly).
- This feels a bit fragile to me
  {{{#!python
  if self.element_class.__name__ != 'Polynomial_integer_dense_flint':
  }}}
  I'm guessing you are doing this to avoid a circular import? What about doing something similar to what is currently there and checking the implementation name?
- Some `_implementation_names_impl` have doctests and others do not (including some with mildly non-trivial behavior).

Can you also explain why you have the ``@`classmethod` and the ``@`staticmethod`? I'm not quite sure I understand why we need the redirection.


---

Comment by jdemeyer created at 2017-12-01 09:56:36

Replying to [comment:30 tscrim]:
> - This seems fragile:
>   {{{#!python
>         implementation = self._implementation_names(implementation, base_ring)[0]
>         if implementation == "NTL":
>   }}}
>   I would instead do
>   {{{#!python
>         implementation = self._implementation_names(implementation, base_ring)[0]
>         if "NTL" in implementation:
>   }}}

Why? I don't understand your objection.

> - Some `_implementation_names_impl` have doctests and others do not (including some with mildly non-trivial behavior).

Well, all of them are tested somewhere. Some are tested explicitly by calling `_implementation_names_impl`; some are tested indirectly by constructing an instance of a polynomial ring class; still others are testing using the polynomial ring constructor.

> Can you also explain why you have the ``@`classmethod` and the ``@`staticmethod`? I'm not quite sure I understand why we need the redirection.

It was just simpler that way. First of all, the actual implementations can just `return NotImplemented` instead of raising an exception. This also simplifies one check in the polynomial constructor where I'm using list comprehension to check for `NotImplemented`. You cannot use list comprehension with a condition "raises `ValueError`".

Second, the wrapper method `_implementation_names()` does a sanity check of the output of `_implementation_names_impl()`: it checks that the given `implementation` is in the output list.


---

Comment by jdemeyer created at 2017-12-01 11:52:28

Replying to [comment:22 tscrim]:
> One thing that definitely needs fixing: By allowing generic coercions, we are introducing a memory leak via cyclic coercion between the generic and FLINT implementations:

That is a very deep rabbit hole.

First of all, note that cyclic coercion is already possible in other cases:

```
sage: R = PolynomialRing(GF(3), 't', implementation='FLINT')
sage: S = PolynomialRing(GF(3), 't', implementation='NTL')
sage: R
Univariate Polynomial Ring in t over Finite Field of size 3
sage: S
Univariate Polynomial Ring in t over Finite Field of size 3 (using NTL)
sage: R.has_coerce_map_from(S)
True
sage: S.has_coerce_map_from(R)
True
```


There are two related issues when trying to fix this:

(A) The polynomial ring itself does not store its implementation or any other information which could help to determine in which way a coercion should go.

(B) Pickling doesn't work correctly for non-default implementations:

```
# Continuing the example above
sage: loads(dumps(S)) is S
False
sage: loads(dumps(S)) is R
True
```


Currently, one could fix (A) by not allowing coercions between different implementations. But then (B) gives trouble because then there isn't even a coercion between `loads(dumps(S))` and `S`.

Suggestions??


---

Comment by tscrim created at 2017-12-01 11:53:28

Replying to [comment:31 jdemeyer]:
> Replying to [comment:30 tscrim]:
> > - This seems fragile:
> >   {{{#!python
> >         implementation = self._implementation_names(implementation, base_ring)[0]
> >         if implementation == "NTL":
> >   }}}
> >   I would instead do
> >   {{{#!python
> >         implementation = self._implementation_names(implementation, base_ring)[0]
> >         if "NTL" in implementation:
> >   }}}
> 
> Why? I don't understand your objection.

I either missed, didn't remember, or didn't quite understand the implication of the "The first element in the list is the canonical name." part of the `OUTPUT`. So I thought you were using an undocumented specification.

> > - Some `_implementation_names_impl` have doctests and others do not (including some with mildly non-trivial behavior).
> 
> Well, all of them are tested somewhere. Some are tested explicitly by calling `_implementation_names_impl`; some are tested indirectly by constructing an instance of a polynomial ring class; still others are testing using the polynomial ring constructor.

Would it be possible to have at least one of those tests local to each of these functions? It would make it easier to debug if something broke later on.

> > Can you also explain why you have the ``@`classmethod` and the ``@`staticmethod`? I'm not quite sure I understand why we need the redirection.
> 
> It was just simpler that way. First of all, the actual implementations can just `return NotImplemented` instead of raising an exception. This also simplifies one check in the polynomial constructor where I'm using list comprehension to check for `NotImplemented`. You cannot use list comprehension with a condition "raises `ValueError`".
>
> Second, the wrapper method `_implementation_names()` does a sanity check of the output of `_implementation_names_impl()`: it checks that the given `implementation` is in the output list.

Thank you for the explanations. Makes sense to me, and it made it easy to see where these features are being used.


---

Comment by tscrim created at 2017-12-01 12:10:45

Replying to [comment:32 jdemeyer]:
> Replying to [comment:22 tscrim]:
> > One thing that definitely needs fixing: By allowing generic coercions, we are introducing a memory leak via cyclic coercion between the generic and FLINT implementations:
> 
> That is a very deep rabbit hole.
> 
> First of all, note that cyclic coercion is already possible in other cases:
> {{{
> sage: R = PolynomialRing(GF(3), 't', implementation='FLINT')
> sage: S = PolynomialRing(GF(3), 't', implementation='NTL')
> sage: R
> Univariate Polynomial Ring in t over Finite Field of size 3
> sage: S
> Univariate Polynomial Ring in t over Finite Field of size 3 (using NTL)
> sage: R.has_coerce_map_from(S)
> True
> sage: S.has_coerce_map_from(R)
> True
> }}}

I know some people would consider that a bug, and even if is not, it could create strange behavior and slowdowns because of moving between implementations.

> There are two related issues when trying to fix this:
> 
> (A) The polynomial ring itself does not store its implementation or any other information which could help to determine in which way a coercion should go.

It has to store something in order to get the different string representations. As for determining which way to make the coercion is a bit more arbitrary, but something we can do in the `_coerce_map_from_`.

> (B) Pickling doesn't work correctly for non-default implementations:
> {{{
> # Continuing the example above
> sage: loads(dumps(S)) is S
> False
> sage: loads(dumps(S)) is R
> True
> }}}
> 
> Currently, one could fix (A) by not allowing coercions between different implementations. But then (B) gives trouble because then there isn't even a coercion between `loads(dumps(S))` and `S`.

That's a bug (and somewhat horrifying).

> Suggestions??

(B) deserves a ticket all on its own. Although (A) is currently addressed for `ZZ` rings:

```
sage: R = PolynomialRing(ZZ, 't', implementation="FLINT")
sage: S = PolynomialRing(ZZ, 't', implementation="NTL")
sage: R.has_coerce_map_from(S)
True
sage: S.has_coerce_map_from(R)
False
```

I can't think of a simple way with the current framework that we can have an ordering on the implementations that would correspond to the coercion order. I feel like we would need to add another ``@`staticmethod` specifying this (with a default of `[None]` when there is only 1 implementation, the default).

I am also happy addressing (A) more thoroughly on a followup if we just add a test for

```
sage: T = PolynomialRing(ZZ, 't', implementation="generic")
```

and the non-cyclic coercion with R and S above.


---

Comment by jdemeyer created at 2017-12-04 09:03:04

Replying to [comment:34 tscrim]:
> I am also happy addressing (A) more thoroughly on a followup if we just add a test for
> {{{
> sage: T = PolynomialRing(ZZ, 't', implementation="generic")
> }}}
> and the non-cyclic coercion with R and S above.

Yes, I would rather do that. This ticket is already getting quite big...


---

Comment by jdemeyer created at 2017-12-04 09:16:01

Follow-up tickets: #24319, #24320 (Note that I do not plan to work on these)


---

Comment by jdemeyer created at 2017-12-04 10:07:09

Part of the mess in polynomial rings is that the logic for constructing them is separated in different places:

1. The constructor `PolynomialRing`

2. The `_implementation_names_impl()` method of the polynomial ring.

3. The `__init__` method of the polynomial ring.

There are also two non-equivalent ways to pass an implementation: using the `implementation` keyword or using the `element_class` keyword.


---

Comment by jdemeyer created at 2017-12-04 10:11:15

I feel like only `PolynomialRing` should take an `implementation` and not `__init__`. Instead, the `implementation` should be translated somewhere to an `element_class` which is passed to `__init__`.

But that will be for a follow-up.


---

Comment by git created at 2017-12-04 10:29:52

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-12-04 10:31:52

I hope that this addresses all your concerns.


---

Comment by tscrim created at 2017-12-06 13:54:54

Yes, it does. Thank you.


---

Comment by tscrim created at 2017-12-06 13:54:54

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2017-12-06 14:40:19

Finally... I initially started with this ticket thinking "this should only take 1 hour" :-)


---

Comment by tscrim created at 2017-12-06 14:42:21

Ah, I know that feeling. Although in my case, that has always been a sign I am in for a whole day of programming. :P


---

Comment by embray created at 2017-12-06 15:09:32

Replying to [comment:42 jdemeyer]:
> Finally... I initially started with this ticket thinking "this should only take 1 hour" :-)

I "love" when that happens.  I haven't really followed this closely since it quickly went beyond any understanding I have of the coercion system, but I'm glad it will be fixed.

The next thing to do might be to fix cases like the one I pointed out in #24263 to ensure that the polynomial implementation that's supposed to be being tested is actually the one being tested.


---

Comment by vbraun created at 2017-12-11 15:34:15

See patchbot


---

Comment by vbraun created at 2017-12-11 15:34:15

Changing status from positive_review to needs_work.


---

Comment by git created at 2017-12-12 17:03:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-12-12 17:03:59

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-12-12 23:48:23

Trivial thing, but can we break this output line since it is so long:

```
            ValueError: domain (Full MatrixSpace of 2 by 2 dense matrices over Univariate Polynomial Ring in x over Integer Ring)
             and codomain (Univariate Polynomial Ring in t over Univariate Polynomial Ring in x over Integer Ring)
             must have the same functorial construction over their base rings
```

Otherwise LGTM and you can set a positive review on my behalf.


---

Comment by jdemeyer created at 2017-12-13 13:10:20

Replying to [comment:48 tscrim]:
> Trivial thing, but can we break this output line since it is so long

Shouldn't the output in doctests match the *actual* output from the terminal? If the actual output is one long line, shouldn't the doctest reflect that?

If you insist, I will change it though.


---

Comment by tscrim created at 2017-12-13 13:29:55

Replying to [comment:49 jdemeyer]:
> Replying to [comment:48 tscrim]:
> > Trivial thing, but can we break this output line since it is so long
> 
> Shouldn't the output in doctests match the *actual* output from the terminal? If the actual output is one long line, shouldn't the doctest reflect that?
> 
> If you insist, I will change it though.

My usually 90 char wide terminal splits it (essentially randomly) and we have the guideline of 80 char/line in documentation. So with that in mind, I was suggesting the most logical places to split that and keep the lines short. If you would rather leave it as one really (really) long line, then I won't insist, but it makes it much more manageable for me and is in the spirit of the rest of Sage's doc. (I would also not oppose a strict 80 char/line cuts as well.)


---

Comment by jdemeyer created at 2017-12-13 15:55:56

Replying to [comment:50 tscrim]:
> and we have the guideline of 80 char/line in documentation.

In my mind, there is a difference between the different parts of the documentation:

1. *textual documentation*: word wrap as usual

2. *code in EXAMPLES*: follow PEP 8, which means trying to limit the line lengths

3. *output in EXAMPLES*: I think it is best to keep the exact formatting of the output and not randomly wrap lines.


---

Comment by tscrim created at 2017-12-14 04:23:39

The problem is it is so ugly on my screen that I cannot read it at once with my default settings. IMO, there is no benefit in keeping it "exactly" (where I would say that is not completely accurate with how terminals can wrap) in the doc without some breaks (in this case, I think they are logical). Although this is effectively bikeshedding, and I don't care enough to die on this hill.


---

Comment by tscrim created at 2017-12-14 04:23:39

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-12-14 23:32:46


```
sage -t --long --warn-long 65.5 src/sage/rings/morphism.pyx
**********************************************************************
File "src/sage/rings/morphism.pyx", line 361, in sage.rings.morphism
Failed example:
    phi3 = RingHomomorphism_from_base(H, R.hom([x])); phi3
Expected:
    Ring endomorphism of Univariate Quotient Polynomial Ring in a over Finite Field of size 2 with modulus x^2 + x + 1
      Defn: Induced from base ring by
            Ring endomorphism of Univariate Polynomial Ring in x over Finite Field of size 2 (using NTL)
              Defn: x |--> x
Got:
    Ring endomorphism of Univariate Quotient Polynomial Ring in a over Finite Field of size 2 with modulus x^2 + x + 1
      Defn: Induced from base ring by
            Ring endomorphism of Univariate Polynomial Ring in x over Finite Field of size 2 (using GF2X)
              Defn: x |--> x
**********************************************************************
```



---

Comment by vbraun created at 2017-12-14 23:32:46

Changing status from positive_review to needs_work.


---

Comment by tscrim created at 2017-12-22 05:42:52

Jeroen, will you update the output here, or should I do it?


---

Comment by jdemeyer created at 2017-12-22 10:51:33

I forgot about this ticket. If you can update it, please do.


---

Comment by tscrim created at 2017-12-23 07:05:01

Changing status from needs_work to positive_review.


---

Comment by tscrim created at 2017-12-23 07:05:01

Updated.
----
New commits:


---

Comment by git created at 2017-12-23 07:05:35

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2017-12-23 07:05:35

Changing status from positive_review to needs_review.


---

Comment by tscrim created at 2017-12-23 07:05:54

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2017-12-23 07:05:54

Commit, then push. `:p`


---

Comment by vbraun created at 2017-12-25 18:20:42

Resolution: fixed
