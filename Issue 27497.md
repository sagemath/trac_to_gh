# Issue 27497: Fractional chromatic number

Issue created by migration from https://trac.sagemath.org/ticket/27734

Original creator: @ed359

Original creation time: 2019-04-27 02:21:43

CC:  tscrim




---

Comment by git created at 2019-05-03 18:54:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @ed359 created at 2019-05-03 19:00:55

Changing component from PLEASE CHANGE to graph theory.


---

Comment by @ed359 created at 2019-05-03 19:00:55

Changing type from PLEASE CHANGE to enhancement.


---

Comment by @ed359 created at 2019-05-03 19:00:55

Changing priority from major to minor.


---

Comment by @ed359 created at 2019-05-03 19:00:55

Set assignee to @ed359.


---

Comment by git created at 2019-05-03 21:57:10

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by dcoudert created at 2019-05-04 08:52:23

I have several comments here:
- method `fractional_chromatic_number` could be in file `graph_coloring.py`

- The LP formulation using independent sets is elegant, but can be used on small graphs only. For instance, a 5x5 grid has already 55447 independent sets... You could add a "compact" formulation that could be used on larger graphs.

- You can also add simple optimization like partition into connected components.

- `optimim` -> `optimum`


---

Comment by @ed359 created at 2019-05-08 00:42:22

Replying to [comment:5 dcoudert]:
> I have several comments here:
> - method `fractional_chromatic_number` could be in file `graph_coloring.py`
>

Sure, should I move `fractional_chromatic_index` too? And what about `fractional_clique_number`? One does not usually arrive at the definition of fractional clique number via coloring, but they're dual LPs so very related!


> - The LP formulation using independent sets is elegant, but can be used on small graphs only. For instance, a 5x5 grid has already 55447 independent sets... You could add a "compact" formulation that could be used on larger graphs.
>

I don't know of a fancy algorithm for fractional chromatic number that would be asymptotically better than the LP. I forgot an optimisation which makes the LP smaller by using _maximal_ independent sets for the variables, and it could save some time and memory to index the LP variables by ints rather than frozensets. 
I don't know how to get around a call to `IndependentSets` of some kind though.

> - You can also add simple optimization like partition into connected components.

This sounds useful, I'll investigate.

> 
> - `optimim` -> `optimum`


---

Comment by dcoudert created at 2019-05-08 10:31:32

> Sure, should I move `fractional_chromatic_index` too? And what about `fractional_clique_number`? One does not usually arrive at the definition of fractional clique number via coloring, but they're dual LPs so very related!

Yes, move them all.

> > - The LP formulation using independent sets is elegant, but can be used on small graphs only. For instance, a 5x5 grid has already 55447 independent sets... You could add a "compact" formulation that could be used on larger graphs.
> >
> 
> I don't know of a fancy algorithm for fractional chromatic number that would be asymptotically better than the LP.

I tried another formulation with `n^2` binary variables and `O(n^2)` fractional variables but it's effectively way slower.

You could add a note saying that the number of independent sets and the time to generate them can be huge.

> I forgot an optimisation which makes the LP smaller by using _maximal_ independent sets for the variables, 
OK

> and it could save some time and memory to index the LP variables by ints rather than frozensets.
> I don't know how to get around a call to `IndependentSets` of some kind though.

At least, you can do:

```
        Is = [frozenset(I) for I in IndependentSets(G, maximal=True)]
```

`IndependentSets` is an iterator, so your code generates twice each set. Furthermore, when you check `v in I`, it is way faster when `I` is a set and not a list.



Don't forget to check trivial cases like bipartite graphs.


---

Comment by git created at 2019-05-09 02:27:14

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2019-05-09 03:02:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-05-09 04:11:22

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @ed359 created at 2019-05-09 04:15:24

New commits:


---

Comment by git created at 2019-05-09 04:41:08

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2019-05-09 05:34:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ed359 created at 2019-05-09 05:47:07

Replying to [comment:7 dcoudert]:

I've added the optimisations we discussed. Apologies for (a) the pointless git noise on this ticket, and (b) the following silly issue. 

I can't see how to move a class method to another file. In `generic_graph.py` lines 23426-23443 it appears that one can simply write `from sage.module import method` inside the class definition to make `method` appear on the class, e.g.


```python
class Foo:
    from sage.module import method

f = Foo()
f.method() # works!
```


but any variation of this I have tried leads to sage crashing on start with an `ImportError`. The traceback is sufficiently cryptic that I can't diagnose the problem. 

For now I just add a one-line method the usual `def method():` way to the `sage.graphs.Graph` class that imports and calls the method defined in `sage.graphs.graph_coloring.py` that I want, but there should be a better way!


---

Comment by dcoudert created at 2019-05-09 06:57:42

This should work. It avoids circular imports. As the branch is in `public/`, you can modify it. 
----
New commits:


---

Comment by git created at 2019-05-12 21:57:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ed359 created at 2019-05-12 21:58:14

Changing status from new to needs_review.


---

Comment by dcoudert created at 2019-05-13 15:23:30

Some quick comments:
- In all input blocks, the alignement of the 2nd line is only 2 spaces more than the first line, not 4.

```diff
-    - ``solver`` -- (default: ``"PPL"``); specify a Linear Program (LP)
-        solver to be used. If set to ``None``, the default one is used. For
+    - ``solver`` -- (default: ``"PPL"``); specify a Linear Program (LP)
+      solver to be used. If set to ``None``, the default one is used. For
```


- I don't know the number of needed spaces for `.. NOTE::` inside the `INPUT` block. Have you tried building the documentation ? does it looks good ? I cannot check by myself (unable to build the doc yet. I will try to fix that)

- I'm not convinced by `only_maximal`. Why not `maximal_only` or simply `maximal`?
Furthermore, if it is proven that you can use maximal independent sets only, then why do we need this parameter ? Of course if not proven it's a different story.

- in documentation, you can use ``G`` instead of `G`.

- we need double ```` for True, False and None, so ```True``` not ``True``

- It's a very good idea to introduce ``@`doc_index("Coloring")`.


---

Comment by @ed359 created at 2019-05-13 17:39:57

Strangely, I can't find a reference for the maximal thing, but here's a proof in pythonic pseudocode (since I can't see how to write math in a ticket):

  Let `Is` be the set of all independent sets of `G`, and `MIs` be the subset of `Is` consisting of maximal independent sets.
  
  If `w` is a nonnegative weight function on independent sets that is feasible in the LP, we have for all vertices `u` of the graph, `sum(w[I] for I in Is if u in I) >= 1`. 
  
  Suppose that there exists `J in Is` with `w[J] > 0` and a vertex `v` such that `J + [v] in Is`. Then form `x` from `w` by `x[J] = 0`, `x[J + [v]] = w[J] + w[J+[v]]`, and `x[I] = w[I]` for all other `I`. Then `x` is also feasible as moving weight to a larger independent set can only increase the sum of weights over `I in Is if u in I` and the objective values for `w` and `x` are the same by construction. By repeatedly applying this trick we obtain a weight function supported only on `MIs`.

There's a tradeoff though: if you consider all independent sets then it's valid to use the LP with equality constraints, but it is invalid to impose equality constraints *and* to drop variables corresponding to non-maximal independent sets (the LP can become infeasible).

Someone with better knowledge of the inner workings of LP solvers could make a call as to which is preferable. My understanding is that for some algorithms each inequality constraint is replaced by an additional variable and an equality constraint. But having two variables for each maximal independent set should still be cheaper than having a single variable for each independent set. I guess benchmarks are warranted, but I don't have the time.


---

Comment by dcoudert created at 2019-05-14 08:44:40

Check Section 2.1 of [1]. Not a formal proof, but give complementary arguments.



[1] I. Caragiannis, Afonso Ferreira, C. Kaklamanis, Stéphane Pérennes, Hervé Rivano. Fractional Path Coloring in Bounded Degree Trees with Applications
Algorithmica, Springer Verlag, 2010, 58 (2), pp.516-540. ⟨10.1007/s00453-009-9278-3⟩
https://hal.archives-ouvertes.fr/hal-00371052


---

Comment by dcoudert created at 2020-08-09 22:57:51

I have rebuild the branch over sage 9.2.beta7 and fix various compilation, doctests and doc build issues.
----
New commits:


---

Comment by dcoudert created at 2020-08-10 12:25:16

Issues reported by the patchbots seems uncorrelated and I cannot reproduce them.


---

Comment by dcoudert created at 2020-08-18 12:01:02

For me this patch is now good to go, but I would appreciate an external opinion. Thanks.


---

Comment by tscrim created at 2020-08-18 23:29:50

It is fine, but if I wanted to nitpick about the doc: The `INPUT:` bullet point should not end with a period/full-stop (except for those really long ones). Also a missing period here:

```diff
     matchings in the following relaxed way
 
     .. MATH::
 
-        \forall e \in E(G), \sum_{e \in M_i} \alpha_i \geq 1
+        \forall e \in E(G), \sum_{e \in M_i} \alpha_i \geq 1.
 
     For more information, see the :wikipedia:`Fractional_coloring`.
```



---

Comment by git created at 2020-08-19 12:56:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-19 13:18:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-08-19 13:21:28

I did required changes and
- removed parameter `only_maximal`. It is correct to consider only maximal independent sets and very costly to consider all independent sets. I added the only reference I know with an explanation of the correctness.
- use decomposition into biconnected components instead of simply connected components. It's faster this way.


---

Comment by tscrim created at 2020-08-19 23:04:09

Your changes LGTM. If the rest is reviewed, then this is a positive review.


---

Comment by dcoudert created at 2020-08-20 07:25:19

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2020-08-20 07:25:19

Thank you.


---

Comment by vbraun created at 2020-08-23 16:28:15

Resolution: fixed
