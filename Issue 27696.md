# Issue 27696: subs in fraction field wrong

Issue created by migration from https://trac.sagemath.org/ticket/27933

Original creator: dkrenn

Original creation time: 2019-06-05 04:59:04

CC:  slelievre


```
sage: P.<sP> = PolynomialRing(QQ)
sage: F = P.fraction_field(); sF = F.gen()
sage: sF.subs(sP+1)
sP
```

which is clearly wrong. And even explicitly specifying the variable

```
....: sage: sF.subs(sF=sP+1) 
sP
```

gives something wrong.


---

Comment by tscrim created at 2019-06-05 05:43:18

I can confirm this is wrong and it is something isolated with `subs`:

```
sage: sF(sP+1)
sP + 1
```

Something with the `subs` logic is quite strange. It is assuming that the unnamed parameter input is a `dict`, which is very scary (try `sF.subs(2)` an watch the `TypeError` get thrown). If none of the conditions are true, then it just simply adds the parent generator in. So I think that is what is happening since

```
sage: sP in (sP+1)
False
```


Note that your second test is not good because `sF` is not a variable name of `F`, `sP` is:

```
sage: sF.parent().gens()
(sP,)
sage: sF.subs(sP=sP+1)
sP + 1
```



---

Comment by dkrenn created at 2019-06-05 06:08:34

Replying to [comment:1 tscrim]:
> Note that your second test is not good because `sF` is not a variable name of `F`, `sP` is:
> {{{
> sage: sF.parent().gens()
> (sP,)
> sage: sF.subs(sP=sP+1)
> sP + 1
> }}}

Indeed; deleted from description and put as a comment here.


---

Comment by dkrenn created at 2019-06-05 06:10:12

Also specifying a variable

```
....: sage: sF.subs(sF=sP+1)
sP
```

gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess


---

Comment by tscrim created at 2019-06-05 06:22:36

Replying to [comment:4 dkrenn]:
> Also specifying a variable
> {{{
> ....: sage: sF.subs(sF=sP+1)
> sP
> }}}
> gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess

Note that `sP` (=`sF` as a Python pointer) is the variable, so this is correct. I am not convinced that this should be an error since you could consider it lifting up to the fraction field `R(sP,sF)` and then the resulting polynomial has no `sF` variable, and hence it projects back down to `R(sP)`. IMO, the input still makes (mathematical) sense and would cause programming headaches in some cases where you would have to be extra careful about the parent and which variables you were allowed to pass in.


---

Comment by dkrenn created at 2019-06-05 06:27:22

Replying to [comment:5 tscrim]:
> Replying to [comment:4 dkrenn]:
> > Also specifying a variable
> > {{{
> > ....: sage: sF.subs(sF=sP+1)
> > sP
> > }}}
> > gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess
> 
> Note that `sP` (=`sF` as a Python pointer) is the variable, so this is correct. I am not convinced that this should be an error since you could consider it lifting up to the fraction field `R(sP,sF)` and then the resulting polynomial has no `sF` variable, and hence it projects back down to `R(sP)`. IMO, the input still makes (mathematical) sense and would cause programming headaches in some cases where you would have to be extra careful about the parent and which variables you were allowed to pass in.

I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right?


---

Comment by tscrim created at 2019-06-05 06:33:45

Replying to [comment:6 dkrenn]:
> I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right? 

What about if `f` is over something that does have `a` as a variable, say `f` is in *Z*[a][x]? It starts getting expensive to do this check recursively every time just to then run the computation recursively.

On the other hand, suppose you are doing something in *Z*[x][a], and you do a `subs` that removes the `a` (say, a special case in a list of things), so now `f` is in *Z*[x] and this raises an error on just this one part of the computation. You have to expand out what could be a simple list comprehension.

So I think the current behavior is the most desirable.


---

Comment by dkrenn created at 2019-06-06 05:28:22

Replying to [comment:7 tscrim]:
> Replying to [comment:6 dkrenn]:
> > I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right? 
> 
> What about if `f` is over something that does have `a` as a variable, say `f` is in *Z*[a][x]? It starts getting expensive to do this check recursively every time just to then run the computation recursively.

I agree that this would be expensive. This is, I guess, why it is not done and subs always(?) substitutes only in the current structure, but *not* in substructures (like coefficents for polynomials). 

> On the other hand, suppose you are doing something in *Z*[x][a], and you do a `subs` that removes the `a` (say, a special case in a list of things), so now `f` is in *Z*[x] and this raises an error on just this one part of the computation. You have to expand out what could be a simple list comprehension.

So, I always think of `subs` to be something that might change the ring. If you want to subs `a=1` and stay in the ring where you are, you can always do `subs(a=R(1))`.

However, I understand your point and agree that this is somehow desirable.

Nevertheless it remains the issue reported.


---

Comment by embray created at 2019-07-03 11:39:12

Moving open critical and blocker issues to the next release milestone (optimistically).


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by slelievre created at 2021-04-13 20:39:36

From the documentation:

```
sage: sF.subs?
...
   Substitutes given generators with given values while not touching
   other generators. This is a generic wrapper around "__call__". The
   syntax is meant to be compatible with the corresponding method for
   symbolic expressions.
...
```

It expects a dictionary or named arguments:

```
sage: sF.subs({sP: sP + 1})
sP + 1
sage: sF.subs(sP=sP + 1)
sP + 1
```


Maybe the problems arises because `sP + 1` can be turned into a dict?

```
sage: (sP + 1).dict()
{0: 1, 1: 1}
```


One could check the arguments of the `subs` method
to avoid the surprise reported in this ticket.

Possibly with a way to bypass the checks for speed.


---

Comment by mkoeppe created at 2021-05-10 17:42:09

Moving to 9.4, as 9.3 has been released.
