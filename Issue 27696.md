# Issue 27696: subs in fraction field wrong

archive/issues_027696.json:
```json
{
    "body": "CC:  @slel\n\n\n```\nsage: P.<sP> = PolynomialRing(QQ)\nsage: F = P.fraction_field(); sF = F.gen()\nsage: sF.subs(sP+1)\nsP\n```\n\nwhich is clearly wrong. And even explicitly specifying the variable\n\n```\n....: sage: sF.subs(sF=sP+1) \nsP\n```\n\ngives something wrong.\n\nIssue created by migration from https://trac.sagemath.org/ticket/27933\n\n",
    "created_at": "2019-06-05T04:59:04Z",
    "labels": [
        "basic arithmetic",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "subs in fraction field wrong",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27696",
    "user": "@dkrenn"
}
```
CC:  @slel


```
sage: P.<sP> = PolynomialRing(QQ)
sage: F = P.fraction_field(); sF = F.gen()
sage: sF.subs(sP+1)
sP
```

which is clearly wrong. And even explicitly specifying the variable

```
....: sage: sF.subs(sF=sP+1) 
sP
```

gives something wrong.

Issue created by migration from https://trac.sagemath.org/ticket/27933





---

archive/issue_comments_390989.json:
```json
{
    "body": "I can confirm this is wrong and it is something isolated with `subs`:\n\n```\nsage: sF(sP+1)\nsP + 1\n```\n\nSomething with the `subs` logic is quite strange. It is assuming that the unnamed parameter input is a `dict`, which is very scary (try `sF.subs(2)` an watch the `TypeError` get thrown). If none of the conditions are true, then it just simply adds the parent generator in. So I think that is what is happening since\n\n```\nsage: sP in (sP+1)\nFalse\n```\n\n\nNote that your second test is not good because `sF` is not a variable name of `F`, `sP` is:\n\n```\nsage: sF.parent().gens()\n(sP,)\nsage: sF.subs(sP=sP+1)\nsP + 1\n```\n",
    "created_at": "2019-06-05T05:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390989",
    "user": "@tscrim"
}
```

I can confirm this is wrong and it is something isolated with `subs`:

```
sage: sF(sP+1)
sP + 1
```

Something with the `subs` logic is quite strange. It is assuming that the unnamed parameter input is a `dict`, which is very scary (try `sF.subs(2)` an watch the `TypeError` get thrown). If none of the conditions are true, then it just simply adds the parent generator in. So I think that is what is happening since

```
sage: sP in (sP+1)
False
```


Note that your second test is not good because `sF` is not a variable name of `F`, `sP` is:

```
sage: sF.parent().gens()
(sP,)
sage: sF.subs(sP=sP+1)
sP + 1
```




---

archive/issue_comments_390990.json:
```json
{
    "body": "Replying to [comment:1 tscrim]:\n> Note that your second test is not good because `sF` is not a variable name of `F`, `sP` is:\n> {{{\n> sage: sF.parent().gens()\n> (sP,)\n> sage: sF.subs(sP=sP+1)\n> sP + 1\n> }}}\n\nIndeed; deleted from description and put as a comment here.",
    "created_at": "2019-06-05T06:08:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390990",
    "user": "@dkrenn"
}
```

Replying to [comment:1 tscrim]:
> Note that your second test is not good because `sF` is not a variable name of `F`, `sP` is:
> {{{
> sage: sF.parent().gens()
> (sP,)
> sage: sF.subs(sP=sP+1)
> sP + 1
> }}}

Indeed; deleted from description and put as a comment here.



---

archive/issue_comments_390991.json:
```json
{
    "body": "Also specifying a variable\n\n```\n....: sage: sF.subs(sF=sP+1)\nsP\n```\n\ngives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess",
    "created_at": "2019-06-05T06:10:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390991",
    "user": "@dkrenn"
}
```

Also specifying a variable

```
....: sage: sF.subs(sF=sP+1)
sP
```

gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess



---

archive/issue_comments_390992.json:
```json
{
    "body": "Replying to [comment:4 dkrenn]:\n> Also specifying a variable\n> {{{\n> ....: sage: sF.subs(sF=sP+1)\n> sP\n> }}}\n> gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess\n\nNote that `sP` (=`sF` as a Python pointer) is the variable, so this is correct. I am not convinced that this should be an error since you could consider it lifting up to the fraction field `R(sP,sF)` and then the resulting polynomial has no `sF` variable, and hence it projects back down to `R(sP)`. IMO, the input still makes (mathematical) sense and would cause programming headaches in some cases where you would have to be extra careful about the parent and which variables you were allowed to pass in.",
    "created_at": "2019-06-05T06:22:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390992",
    "user": "@tscrim"
}
```

Replying to [comment:4 dkrenn]:
> Also specifying a variable
> {{{
> ....: sage: sF.subs(sF=sP+1)
> sP
> }}}
> gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess

Note that `sP` (=`sF` as a Python pointer) is the variable, so this is correct. I am not convinced that this should be an error since you could consider it lifting up to the fraction field `R(sP,sF)` and then the resulting polynomial has no `sF` variable, and hence it projects back down to `R(sP)`. IMO, the input still makes (mathematical) sense and would cause programming headaches in some cases where you would have to be extra careful about the parent and which variables you were allowed to pass in.



---

archive/issue_comments_390993.json:
```json
{
    "body": "Replying to [comment:5 tscrim]:\n> Replying to [comment:4 dkrenn]:\n> > Also specifying a variable\n> > {{{\n> > ....: sage: sF.subs(sF=sP+1)\n> > sP\n> > }}}\n> > gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess\n> \n> Note that `sP` (=`sF` as a Python pointer) is the variable, so this is correct. I am not convinced that this should be an error since you could consider it lifting up to the fraction field `R(sP,sF)` and then the resulting polynomial has no `sF` variable, and hence it projects back down to `R(sP)`. IMO, the input still makes (mathematical) sense and would cause programming headaches in some cases where you would have to be extra careful about the parent and which variables you were allowed to pass in.\n\nI am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right?",
    "created_at": "2019-06-05T06:27:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390993",
    "user": "@dkrenn"
}
```

Replying to [comment:5 tscrim]:
> Replying to [comment:4 dkrenn]:
> > Also specifying a variable
> > {{{
> > ....: sage: sF.subs(sF=sP+1)
> > sP
> > }}}
> > gives something wrong. (Note that `sF` is not the variable, but `s` is.) The proper  result here should be an error message, I guess
> 
> Note that `sP` (=`sF` as a Python pointer) is the variable, so this is correct. I am not convinced that this should be an error since you could consider it lifting up to the fraction field `R(sP,sF)` and then the resulting polynomial has no `sF` variable, and hence it projects back down to `R(sP)`. IMO, the input still makes (mathematical) sense and would cause programming headaches in some cases where you would have to be extra careful about the parent and which variables you were allowed to pass in.

I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right?



---

archive/issue_comments_390994.json:
```json
{
    "body": "Replying to [comment:6 dkrenn]:\n> I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right? \n\nWhat about if `f` is over something that does have `a` as a variable, say `f` is in **Z**[a][x]? It starts getting expensive to do this check recursively every time just to then run the computation recursively.\n\nOn the other hand, suppose you are doing something in **Z**[x][a], and you do a `subs` that removes the `a` (say, a special case in a list of things), so now `f` is in **Z**[x] and this raises an error on just this one part of the computation. You have to expand out what could be a simple list comprehension.\n\nSo I think the current behavior is the most desirable.",
    "created_at": "2019-06-05T06:33:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390994",
    "user": "@tscrim"
}
```

Replying to [comment:6 dkrenn]:
> I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right? 

What about if `f` is over something that does have `a` as a variable, say `f` is in **Z**[a][x]? It starts getting expensive to do this check recursively every time just to then run the computation recursively.

On the other hand, suppose you are doing something in **Z**[x][a], and you do a `subs` that removes the `a` (say, a special case in a list of things), so now `f` is in **Z**[x] and this raises an error on just this one part of the computation. You have to expand out what could be a simple list comprehension.

So I think the current behavior is the most desirable.



---

archive/issue_comments_390995.json:
```json
{
    "body": "Replying to [comment:7 tscrim]:\n> Replying to [comment:6 dkrenn]:\n> > I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right? \n> \n> What about if `f` is over something that does have `a` as a variable, say `f` is in **Z**[a][x]? It starts getting expensive to do this check recursively every time just to then run the computation recursively.\n\nI agree that this would be expensive. This is, I guess, why it is not done and subs always(?) substitutes only in the current structure, but *not* in substructures (like coefficents for polynomials). \n\n> On the other hand, suppose you are doing something in **Z**[x][a], and you do a `subs` that removes the `a` (say, a special case in a list of things), so now `f` is in **Z**[x] and this raises an error on just this one part of the computation. You have to expand out what could be a simple list comprehension.\n\nSo, I always think of `subs` to be something that might change the ring. If you want to subs `a=1` and stay in the ring where you are, you can always do `subs(a=R(1))`.\n\nHowever, I understand your point and agree that this is somehow desirable.\n\nNevertheless it remains the issue reported.",
    "created_at": "2019-06-06T05:28:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390995",
    "user": "@dkrenn"
}
```

Replying to [comment:7 tscrim]:
> Replying to [comment:6 dkrenn]:
> > I am not sure I get this: My worries here come from the following (reformulated): I want to do `f.subs(a=b)`, but `f` does not have any generator `a`, then I think an error seems appropriate, right? 
> 
> What about if `f` is over something that does have `a` as a variable, say `f` is in **Z**[a][x]? It starts getting expensive to do this check recursively every time just to then run the computation recursively.

I agree that this would be expensive. This is, I guess, why it is not done and subs always(?) substitutes only in the current structure, but *not* in substructures (like coefficents for polynomials). 

> On the other hand, suppose you are doing something in **Z**[x][a], and you do a `subs` that removes the `a` (say, a special case in a list of things), so now `f` is in **Z**[x] and this raises an error on just this one part of the computation. You have to expand out what could be a simple list comprehension.

So, I always think of `subs` to be something that might change the ring. If you want to subs `a=1` and stay in the ring where you are, you can always do `subs(a=R(1))`.

However, I understand your point and agree that this is somehow desirable.

Nevertheless it remains the issue reported.



---

archive/issue_comments_390996.json:
```json
{
    "body": "Moving open critical and blocker issues to the next release milestone (optimistically).",
    "created_at": "2019-07-03T11:39:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390996",
    "user": "@embray"
}
```

Moving open critical and blocker issues to the next release milestone (optimistically).



---

archive/issue_comments_390997.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390997",
    "user": "@embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_390998.json:
```json
{
    "body": "From the documentation:\n\n```\nsage: sF.subs?\n...\n   Substitutes given generators with given values while not touching\n   other generators. This is a generic wrapper around \"__call__\". The\n   syntax is meant to be compatible with the corresponding method for\n   symbolic expressions.\n...\n```\n\nIt expects a dictionary or named arguments:\n\n```\nsage: sF.subs({sP: sP + 1})\nsP + 1\nsage: sF.subs(sP=sP + 1)\nsP + 1\n```\n\n\nMaybe the problems arises because `sP + 1` can be turned into a dict?\n\n```\nsage: (sP + 1).dict()\n{0: 1, 1: 1}\n```\n\n\nOne could check the arguments of the `subs` method\nto avoid the surprise reported in this ticket.\n\nPossibly with a way to bypass the checks for speed.",
    "created_at": "2021-04-13T20:39:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390998",
    "user": "@slel"
}
```

From the documentation:

```
sage: sF.subs?
...
   Substitutes given generators with given values while not touching
   other generators. This is a generic wrapper around "__call__". The
   syntax is meant to be compatible with the corresponding method for
   symbolic expressions.
...
```

It expects a dictionary or named arguments:

```
sage: sF.subs({sP: sP + 1})
sP + 1
sage: sF.subs(sP=sP + 1)
sP + 1
```


Maybe the problems arises because `sP + 1` can be turned into a dict?

```
sage: (sP + 1).dict()
{0: 1, 1: 1}
```


One could check the arguments of the `subs` method
to avoid the surprise reported in this ticket.

Possibly with a way to bypass the checks for speed.



---

archive/issue_comments_390999.json:
```json
{
    "body": "Moving to 9.4, as 9.3 has been released.",
    "created_at": "2021-05-10T17:42:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27696#issuecomment-390999",
    "user": "@mkoeppe"
}
```

Moving to 9.4, as 9.3 has been released.
