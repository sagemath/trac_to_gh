# Issue 34177: Implement Key polynomials

Issue created by migration from https://trac.sagemath.org/ticket/34414

Original creator: tkarn

Original creation time: 2022-08-23 13:10:51

CC:  tkarn tscrim

Keywords: gsoc2022 key-polynomial

Implement the Key polynomials as an algebra with basis indexed by compositions.


---

Comment by tkarn created at 2022-08-23 13:12:30

Last 10 new commits:


---

Comment by tkarn created at 2022-08-23 13:12:30

Set assignee to tkarn.


---

Comment by git created at 2022-08-25 04:45:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-25 19:07:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-29 20:55:05

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-08-30 03:13:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tkarn created at 2022-08-30 03:14:46

Changing status from new to needs_review.


---

Comment by tkarn created at 2022-08-30 03:14:46

There are probably things to do to extend this in the future, but here is a working implementation for the basic computations.


---

Comment by tscrim created at 2022-08-30 06:01:52

Some quick comments:

- I might call it `KeyPolynomialBasis` or something like this to indicate that it is a choice of basis for the ring of polynomials in infinitely many variables.
- No need to declare the metaclass. It comes from `UniqueRepresentation`.
- In the doc, you should specify that it is indexed by integer vectors with no trailing zeros. (Ideally I would want this for the actual basis elements, but this is not worth the trouble of actually programming it.)
- You should not need to implement `one()`. That should come from the category.
- `expand()` should take a number of variables (optional) argument.
- The divided difference operators are acting on polynomials and only involve polynomials. They should not be methods of the class.
- A good check would be to show the divided difference operators on the polynomials simply swaps two indices in the weak composition (when in order) of the key polynomial basis index. (Hopefully that makes sense, I don't think I explained it too well.)
- It would be better to implement `product` instead of `product_on_basis` as doing `(K[A] + K[B]) * (K[C] + K[D])` would go back and forth on each of the 4 products rather than just once on the pair.
- You seem to be doing a lot of work in `expand()`. I would just do the appropriate divided difference operator as you start sorting. At the end of the day, you're having to do the classical bubble sort algorithm and not gaining anything by first using a smarter sorting algorithm.
- It might be good to have coercions from the (infinte) polynomial rings over the same base ring implemented using `_coerce_map_from_`. Although I am not yet 100% sold on this because it neglects the name of the polynomials and it might mean dealing with subtleties when the base ring is a polynomial ring.


---

Comment by tkarn created at 2022-08-30 17:18:56

Thanks for the comments!

Replying to [comment:9 tscrim]:
> - `expand()` should take a number of variables (optional) argument.

This one I think I disagree with. The expansion is always going to be into the infinite variable polynomial ring, and the variable with largest index occuring in the expansion is implied by the composition. The only reason I see to have a number of variables argument is to have a fewer number of variables. Is that a thing that one would ever want to do mathematically? I know there is sometimes a reason to do that for expanding Schur polynomials as GLn characters, which is in my head as an analogous thing.


---

Comment by git created at 2022-08-30 17:59:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by tkarn created at 2022-08-30 18:01:45

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-08-30 21:26:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2022-08-31 00:45:37

Replying to [comment:10 tkarn]:
> Replying to [comment:9 tscrim]:
> > - `expand()` should take a number of variables (optional) argument.
> 
> This one I think I disagree with. The expansion is always going to be into the infinite variable polynomial ring, and the variable with largest index occuring in the expansion is implied by the composition.

I might want to do the expansion in a finite polynomial ring of my choosing. You will probably have to do something slightly special when the number of variables is less than the natural minimal number.

> The only reason I see to have a number of variables argument is to have a fewer number of variables. Is that a thing that one would ever want to do mathematically? I know there is sometimes a reason to do that for expanding Schur polynomials as GLn characters, which is in my head as an analogous thing.

On the contrary, you might want it to be living in a larger polynomial ring. You are equating the weak compositions up to trailing zeros, but what if I want to look at all key polynomials in, say, a 4 variable polynomial ring only? This can matter for coercion and substitution purposes.

Actually, that makes me think we probably should also implement a true finite number of variables version. Mathematically, you are secretly implementing the projective limit coming from a tower of polynomial rings under the natural projections (which when precomposed with the natural inclusions give the identity map on each component). The key basis with `n` variables is naturally a subset of the key basis of `n + k` variables. The integer vectors are already available:

```
sage: IV3 = IntegerVectors(k=3)
sage: IV3
Integer vectors of length 3
```

This might also give some speedups for some of the computations.

Lastly, instead of modifying `_element_constructor_`, you are probably better off implementing a new `_monomial` function to strip trailing 0s in the infinite variable case. The infinite polynomial ring would then be handled by the coercion mentioned above. This would make other construction methods more uniform.


---

Comment by git created at 2022-09-06 21:59:25

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-09-07 00:41:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-08 21:53:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-09 03:32:04

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-09-10 21:02:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-10 22:34:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-11 15:15:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tkarn created at 2022-09-11 15:18:22

Changing status from needs_work to needs_review.


---

Comment by tkarn created at 2022-09-11 15:18:22

It now accepts a specified polynomial ring or a specified number of variables.


---

Comment by tscrim created at 2022-09-11 23:24:12

You should have a separate function/method that parses the input for `pi` and `divided_difference` so that they handle their inputs in the same way.

The `_divided_difference()` should not work monomial by monomial, but instead just do the division on the polynomial. I am pretty sure this will be faster for larger polynomials. If this was a deliberate choice, then please provide some timings.

The string representation of the `Parent` is better saying “Key polynomial basis of {BR}”.

The docstring of the `Parent` should start with a one line description, and possibly a longer more mathematical description. Afterwards, the lines after `EXAMPLES:` is over-indented.

You don’t need to hold onto `_basis_keys`. This is already done by `_indices` (or if you want a little less encapsulation breaking, `self.basis().keys()`).


---

Comment by git created at 2022-09-13 16:28:40

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-09-13 16:29:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-09-13 18:10:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-13 18:57:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by tkarn created at 2022-09-13 18:57:49

Replying to [comment:29 git]:
> Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:
> ||[7e01109](https://git.sagemath.org/sage.git/commit/?id=7e01109ae78f947e010b08b081789267a2944f96)||`rename key polynomial basis and make constructor`||
> ||[7b43c50](https://git.sagemath.org/sage.git/commit/?id=7b43c5056e5a3d839b65c09a464500ea33b43297)||`First draft of finite polynomial`||
> ||[136e323](https://git.sagemath.org/sage.git/commit/?id=136e32313022b297bf9fca47c311c542079d8548)||`Replace the strong referernce to _IntegerVectors to deal with specified lengths.`||
> ||[9f88795](https://git.sagemath.org/sage.git/commit/?id=9f887953743a1b2a9479c9460b258ab60172c580)||`Add trim only when in infinite case`||
> ||[5876a85](https://git.sagemath.org/sage.git/commit/?id=5876a858ab931c80f3ed581de4d7bbecb5a91835)||`Fix error in self._basis_keys`||
> ||[a0cd0f0](https://git.sagemath.org/sage.git/commit/?id=a0cd0f0059c47c0bbba5dca1d7ad4d803d57dcb8)||`All tests pass`||
> ||[e20e2a0](https://git.sagemath.org/sage.git/commit/?id=e20e2a027fc9a928e1e7853f856462a63c0a48d4)||`Combine finite and infinte classes`||
> ||[fe0f762](https://git.sagemath.org/sage.git/commit/?id=fe0f7624d8ddae6ef16a494f212e1cdcc42c9a4d)||`Fix vector length bug`||
> ||[124638c](https://git.sagemath.org/sage.git/commit/?id=124638ccb2ab0fafda5dcab1461e177a33cbb2cc)||`Add tests`||
> ||[af76efb](https://git.sagemath.org/sage.git/commit/?id=af76efb4433159cd2e7b03ff2ce88d8c5d34ec41)||`self._basis_keys -> self._indices, simplify key polynomial basis repr, add a sentence for class level description`||

Rebasing off of #34527


---

Comment by git created at 2022-09-13 21:35:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-15 04:57:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by tkarn created at 2022-09-15 04:58:26

After rebasing off of #34535 all tests pass.


---

Comment by git created at 2022-09-15 22:55:40

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by tkarn created at 2022-09-15 22:56:21

Rebased off of #34535 commit 1f0a3d0 and all tests still pass.


---

Comment by git created at 2022-09-21 17:55:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tkarn created at 2022-09-21 17:57:48

Is there anything I am forgetting to do on this?


---

Comment by tscrim created at 2022-09-21 23:57:20

Nothing you are forgetting I think, but you can simplify the s<sub>i</sub> action:

```python
f = # some polynomial
g = f.parent().gens()
sf = f.subs({g[i-1]:g[i], g[i]:g[i-1]})
```

I think works (I cannot test right now). Or `f(**{repr(g[i-1]):g[i], repr(g[i]): g[i-1]})` should work.


---

Comment by tkarn created at 2022-09-24 15:33:05

Replying to [comment:40 Travis Scrimshaw]:
> Nothing you are forgetting I think, but you can simplify the s<sub>i</sub> action:
> {{{#!python
> f = # some polynomial
> g = f.parent().gens()
> sf = f.subs({g[i-1]:g[i], g[i]:g[i-1]})
> }}}
> I think works (I cannot test right now). Or `f(**{repr(g[i-1]):g[i], repr(g[i]): g[i-1]})` should work.


Turns out this only works in the finite case. In the infinite case:


```
sage: R.<z> = InfinitePolynomialRing(QQ)
sage: f = z[1] + z[1]*z[2]*z[3]
sage: f.subs({z[1]:z[0]})
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [3], in <cell line: 1>()
----> 1 f.subs({z[Integer(1)]:z[Integer(0)]})

File ~/Applications/sage/src/sage/structure/element.pyx:830, in sage.structure.element.Element.subs()
    828 if str(gen) in kwds:
    829     variables.append(kwds[str(gen)])
--> 830 elif in_dict and gen in in_dict:
    831     variables.append(in_dict[gen])
    832 else:

TypeError: unhashable type: 'InfinitePolynomialGen'
```


See #34581.


---

Comment by git created at 2022-09-24 16:27:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tkarn created at 2022-09-24 16:32:00

Replying to [comment:40 Travis Scrimshaw]:
> you can simplify the s<sub>i</sub> action

Done in both cases without using `.subs()` for the infinite case.


---

Comment by tscrim created at 2022-09-25 00:53:10

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2022-09-25 00:53:10

Thanks for the updates.

I don't quite understand why that code works for the infinite case. I think depending on #34581 is the right way to go. We should be able to fix that one fairly quickly.

Some more comments on this:

- Rename `poly_gen()` -> `poly_gens()` as it returns all of the generators.
- `while f.monomials():` seems wasteful; you can simply check `while f:` (is not 0).
- In `from_polynomial()`, I would separate out the `self._indices(m).trim()` into a separate helper method
  {{{#!python
if self._k:
    def build_index(m):
        return self._indices(m)
else:
    def build_index(m):
        return self._indices(m).trim()
  }}}
  Furthermore I am not certain that the monomials and exponents will always be given in lex order. While it is a bit more computationally intensive, I think you should call `max(f.exponents())`. You can then use that to build the monomial and/or get the coefficient. This allows you to remove the code duplication.
- Since you have an element class, you are better implementing `_mul_` there as that avoids some indirection.


---

Comment by tkarn created at 2022-10-14 00:26:43

Also try when the base ring is something more interesting than `ZZ` or `QQ`.
