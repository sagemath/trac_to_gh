# Issue 22852: Use Cython language_level=3 when using Python 3

Issue created by migration from https://trac.sagemath.org/ticket/23089

Original creator: aapitzsch

Original creation time: 2017-05-27 09:59:54

Keywords: python3

to enable Python 3 source code semantics.

https://cython.readthedocs.io/en/latest/src/reference/compilation.html#compiler-directives


---

Comment by aapitzsch created at 2017-05-27 10:04:34

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-05-27 10:36:44

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2017-05-27 10:36:44

Why?


---

Comment by jdemeyer created at 2017-05-27 10:37:18

In other words: which problem does this solve?


---

Comment by aapitzsch created at 2017-05-27 10:45:33

> Unprefixed string literals become *str* objects when compiling with language level 2 and *unicode* objects (i.e. Python 3 *str*) with language level 3.

https://cython.readthedocs.io/en/latest/src/tutorial/strings.html


---

Comment by jdemeyer created at 2017-05-27 10:53:39

That doesn't answer my question.

Let me rephrase my question: there are 3 reasonable choices for the `language_level` option.

(A) Always `language_level=2` _(the current situation)_

(B) Always `language_level=3`

(C) `language_level=2` on Python 2 and `language_level=3` on Python 3

*Why* is (C) better than (A)?

And there is an additional question: why is (C) better than (B)?


---

Comment by aapitzsch created at 2017-05-27 20:27:28

I haven't looked at (B) because I didn't want to change the behaviour of Sage on Python 2.

Setting `language_level=3` on Python 3 helped to discover (some) import errors already at compile time and not at runtime. And I assume (haven't tested) that using `language_level=3` could lead to less `unicode` problems than using `language_level=2` and could simplify the way to Sage on Python 3.

Jeroen, you have more experience with Cython, so I assume you can provide more knowledge-based arguments for one or the other.


---

Comment by jdemeyer created at 2017-05-27 21:54:27

Replying to [comment:7 aapitzsch]:
> Jeroen, you have more experience with Cython, so I assume you can provide more knowledge-based arguments for one or the other.

It's not really a Cython-specific thing, it's a more general philosophy. When writing Python code, you can try to

(A) use Python 2 semantics as much as possible

(B) use Python 3 semantics as much as possible

(C) use Python 2 semantics on Python 2 and Python 3 semantics on Python 3

For plain Python, (A) is not possible in many cases because Python 3 removes a feature (for example: `__cmp__`, string literals interpreted as `bytes`, `dict.iteritems`). With Cython, the sitation for (A) is better because some Python 2 features are supported by Cython regardless of Python version.

For plain Python, (B) is often possible (using `from __future__` imports or packages like `six`).

And (C) is usually where trouble lies (strings interpreted as `bytes`/`unicode` depending on the Python version, different division semantics...).

Based on this, I believe that (C) is the worst option. Of course, this is just a personal opinion...


---

Comment by jdemeyer created at 2017-06-09 12:30:24

Any more suggestions here? If not, should we close this as wontfix?


---

Comment by aapitzsch created at 2017-06-10 10:04:19

I tried to compile sage on Python 2 with `language_level=3`. There are some issues like

```
Unicode objects only support coercion to Py_UNICODE*.
```

which should be easily fixable.
A bigger problem are errors like

```
names = ['A{}'.format(''.join(str(x) for x in sorted(F))) for F in flats]  
                                                     ^

sage/matroids/matroid.pyx:7527:66: local variable 'F' referenced before assignment
```

https://github.com/cython/cython/issues/1159

https://github.com/cython/cython/issues/1351

If we don't want to switch now, we should at least make the sage code as much level 3 compatible as possible to allow an easier transition later.


---

Comment by jdemeyer created at 2017-06-20 15:17:31

Replying to [comment:10 aapitzsch]:
> If we don't want to switch now, we should at least make the sage code as much level 3 compatible as possible to allow an easier transition later.

I agree in principle. On the other hand, I think this should literally be the last of our Python 3 worries. There is nothing really wrong with the status quo and there are plenty of other things which still need to be fixed for Python 3.

So I suggest to close this ticket as wontfix for now.


---

Comment by aapitzsch created at 2017-06-25 21:07:11

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2017-06-26 07:40:36

Changing status from needs_review to positive_review.


---

Comment by embray created at 2017-07-13 07:54:31

Closing tickets in the sage-duplicate/invalid/wontfix module with positive_review (i.e. someone has confirmed they should be closed).


---

Comment by embray created at 2017-07-13 07:54:31

Resolution: wontfix


---

Comment by embray created at 2017-09-08 08:02:40

I definitely think this is the right way to go.  It's terribly confusing when trying to port to Python 3 if you have Python 2/3 straddling pure Python code that behaves like Python 2 on Python 2 and like Python 3 on Python 3, but then totally different semantics when you cross over into Cython land.  

That said, until the Cython issue is fixed it will be hard to get very far into this.  In the short term I could write a hacky workaround by rewriting some list comprehensions as for loops (after all, in Cython there's not as much immediate benefit to list comprehensions, I don't think).  But it would be best not to do that just because Cython has a bug...


---

Comment by jdemeyer created at 2017-09-08 08:46:27

Replying to [comment:15 embray]:
> I definitely think this is the right way to go.  It's terribly confusing when trying to port to Python 3 if you have Python 2/3 straddling pure Python code that behaves like Python 2 on Python 2 and like Python 3 on Python 3, but then totally different semantics when you cross over into Cython land.

I would argue that the confusion is more in the Python land than in the Cython land.

You are saying that we should make the code behave _more different_ in Python 2 and Python 3 and that will make our life easier?  I say it's a bad thing and we should be happy that Cython allows us to worry less about Python 2/3 compatibility.


---

Comment by embray created at 2017-09-08 08:53:15

It's a problem from a maintenance standpoint.  It's bad enough going between Python and Cython as it is, and having to remember their (sometimes subtle) differences.  Now it's saying "even if you're developing for Python 3 you have to go back to Python 2 (sort of) when you're editing Cython code".  It also means that the idioms used to support Python 2 and 3 shift when going between Python and Cython, and it also means that extra special care is needed when passing string-like objects at the interface between Python and Cython (which, in most cases, is not an interface one should be thinking about at all).


---

Comment by jdemeyer created at 2017-09-08 09:06:32

Replying to [comment:17 embray]:
> it also means that extra special care is needed when passing string-like objects at the interface between Python and Cython

I thought we discussed this on sage-devel. Cython knows that `str = unicode` on Python 3 and string literals are `str = unicode` on Python 3, regardless of `language_level`.

Note that using `language_level=3` does turn on `from __future__ import unicode_literals`. But on Python 3, that doesn't change anything.


---

Comment by jdemeyer created at 2017-09-08 09:09:24

I agree that there are many issues with `bytes` vs. `unicode` in Cython code in Python 3. I agree so far. But few or none of those issues are fixed with `language_level=3`. It's a red herring, the `language_level` really doesn't change that much.


---

Comment by embray created at 2017-09-08 09:21:43

Just to make sure I'm clear about this, I'm only talking about enabling `language_level=3` on python3, not python2.  The fact that all string literals become unicode on Python 3 does make a big difference in porting sanity.


---

Comment by embray created at 2017-09-08 09:39:49

I think I'm confused about this line in the docs:

> Unprefixed string literals become str objects when compiling with language level 2 and unicode objects (i.e. Python 3 str) with language level 3.

The first part of the sentence doesn't specify what they mean by "str", because this doesn't seem to agree with my experience of turning on `language_level=3` (where suddenly string literals were being treated as unicode and breaking whenever passed to an interface that expects `char *`).

Anyways, another reason to do this is that we'll probably want to use other Python 3 features eventually so it would be good to enable.


---

Comment by jdemeyer created at 2017-09-08 10:00:32

Replying to [comment:21 embray]:
> I think I'm confused about this line in the docs:
> 
> > Unprefixed string literals become str objects when compiling with language level 2 and unicode objects (i.e. Python 3 str) with language level 3.

In Cython code, it's best to think of `bytes`, `str` and `unicode` as three distinct types (that's what Cython does internally). It just happes that `str is bytes` on Python 2 and `str is unicode` on Python 3.

So then, unprefixed string literals are `str` with `language_level=2` (exactly the same as in plain Python), they are `unicode` with `language_level=3` (exactly the same as in plain Python with `from __future__ import unicode_literals`).


---

Comment by embray created at 2017-10-18 15:32:03

Yes, that matches my understanding, but `s/plain Python/plain Python 2/`.  On Python 3 unprefixed strings are also "unicode" type, so `language_level=3` is just consistent with Python 3 in this regard and better for use in conjunction with plain Python 3 code.

Anyways, this is all a moot point until and unless the issues in Cython are fixed, which may be difficult.  I'm working on it but it's not high priority now.  I agree with you that it's not a big deal either way, but I do think using `language_level=2` with Python 3 is confusing and error-prone.


---

Comment by jdemeyer created at 2017-10-18 18:26:48

Replying to [comment:23 embray]:
> Yes, that matches my understanding, but `s/plain Python/plain Python 2/`.

What I wrote in [comment:22] is true both for Python 2 and Python 3.


---

Comment by embray created at 2017-10-19 10:09:21

You wrote "they are `unicode` with `language_level=3`" which doesn't make sense because there is no type called "unicode" in Python 3.  That statement only makes sense on Python 2.


---

Comment by jdemeyer created at 2017-10-20 09:41:46

Replying to [comment:25 embray]:
> You wrote "they are `unicode` with `language_level=3`" which doesn't make sense because there is no type called "unicode" in Python 3.

It does make sense if you first read the first paragraph of my comment in [comment:22]


---

Comment by embray created at 2017-10-23 08:15:36

Replying to [comment:26 jdemeyer]:
> Replying to [comment:25 embray]:
> > You wrote "they are `unicode` with `language_level=3`" which doesn't make sense because there is no type called "unicode" in Python 3.
> 
> It does make sense if you first read the first paragraph of my comment in [comment:22]

Maybe I did read that paragraph and _it_ didn't make sense.


---

Comment by jdemeyer created at 2017-10-23 08:31:14

Let me clarify: when Cython compiles Cython code to C, it doesn't yet know if the C code will be compiled as Python 2 and Python 3. So when it sees a `"string"` literal, it doesn't really know what king of string it will be. To solve this, Cython internally really has 3 string types: `bytes`, `str` and `unicode`. Both `bytes` and `unicode` are easy to deal with, since they refer to the same type on Python 2 and Python 3 (*). To deal with `str`, it uses macros like

```
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
```


(*) I know that they renamed `unicode` to `str` on Python 3, but that is really a superficial change in the Python language. The C API function names start with `PyUnicode`, and that is what Cython really cares about.


---

Comment by embray created at 2017-10-23 08:44:25

I didn't realize that even when compiling Python 3 sources Cython still defines "unicode" as a built-in, which is surprising--that's part of my confusion.

I was looking at the code myself just now, and I think my confusion with your explanation comes from the fact that you're referring to "three distinct types".  And it's true, that it has the _names_ `unicode`, `str`, and `bytes` in all cases.  But that doesn't mean there are three distinct types.  On any given Python there are only two distinct types and all we're talking about is changing around which labels we assign to which types.  I'm confused when you speak of "distinct types" because it makes me think that Cython is reimplementing Python 2 `str`s in Python 3 which doesn't make sense to do, and I was pretty sure _wasn't_ done.

Anyways we're in agreement that language_level doesn't do much in the end.  It does also make some difference in how string literals are parsed which might lead to confusion somewhere, but I don't think it's critical.


---

Comment by jdemeyer created at 2017-10-23 08:57:35

Replying to [comment:29 embray]:
> But that doesn't mean there are three distinct types.

From Cython's point of view, there really are 3 types because Cython doesn't know whether the C code will be compiled as Python 2 or Python 3. It is only after the fact that it "happens" that str maps to bytes or unicode.

But the Cython compiler has 3 classes `BytesNode`, `UnicodeNode` and `StringNode` to deal with the 3 kinds of string constants. And this is where the `from __future__ import unicode_literals` (which is implied by `language_level=3`) comes in: unprefixed `"string"` literals becomes `UnicodeNode` instead of `StringNode`.


---

Comment by embray created at 2017-10-23 09:03:04

FWIW this is also helpful:


```
    builtin_entries = {

        "type":   ["((PyObject*)&PyType_Type)", py_object_type],

        "bool":   ["((PyObject*)&PyBool_Type)", py_object_type],
        "int":    ["((PyObject*)&PyInt_Type)", py_object_type],
        "long":   ["((PyObject*)&PyLong_Type)", py_object_type],
        "float":  ["((PyObject*)&PyFloat_Type)", py_object_type],
        "complex":["((PyObject*)&PyComplex_Type)", py_object_type],

        "bytes":  ["((PyObject*)&PyBytes_Type)", py_object_type],
        "bytearray":   ["((PyObject*)&PyByteArray_Type)", py_object_type],
        "str":    ["((PyObject*)&PyString_Type)", py_object_type],
        "unicode":["((PyObject*)&PyUnicode_Type)", py_object_type],
        ...
```


This is how it determines certain built-in names.  Incidentally Python 2 has `#define PyBytes_Type PyString_Type` in its headers, but Python 3 does not have `#define PyString_Type PyUnicode_Type` which is why Cython has to include that explicitly.

I disagree with your read on the situation.  The parser/compiler may have three Node types which makes sense, but there aren't three distinct types at runtime ever.


---

Comment by jdemeyer created at 2018-10-04 15:27:24

See #26403 for a related ticket that I'm working on.
