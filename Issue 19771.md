# Issue 19771: Implement non-recursive iterator for compositions

archive/issues_019771.json:
```json
{
    "body": "Assignee: sage-combinat\n\nCC:  sage-combinat @darijgr @fchapoton @nthiery @videlec\n\nKeywords: iterator\n\nCompositions currently uses a recursive iterator, which also has extra overhead of converting between the element classes. \n\nIssue created by migration from https://trac.sagemath.org/ticket/20008\n\n",
    "created_at": "2016-02-04T00:53:13Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.1",
    "title": "Implement non-recursive iterator for compositions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19771",
    "user": "https://github.com/tscrim"
}
```
Assignee: sage-combinat

CC:  sage-combinat @darijgr @fchapoton @nthiery @videlec

Keywords: iterator

Compositions currently uses a recursive iterator, which also has extra overhead of converting between the element classes. 

Issue created by migration from https://trac.sagemath.org/ticket/20008





---

archive/issue_comments_271400.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-02-04T00:53:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271400",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_271401.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-04T00:54:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271401",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_271402.json:
```json
{
    "body": "Some timings with the current branch:\n\n```\nsage: C = Compositions(5)\nsage: %timeit for x in C: pass\nThe slowest run took 8.30 times longer than the fastest. This could mean that an intermediate result is being cached\n10000 loops, best of 3: 34.9 \u00b5s per loop\nsage: C = Compositions(10)\nsage: %timeit for x in C: pass\n1000 loops, best of 3: 1.1 ms per loop\nsage: C = Compositions(20)\nsage: %timeit for x in C: pass\n1 loops, best of 3: 1.18 s per loop\n```\n\nversus the old version:\n\n```\nsage: C = Compositions(5)\nsage: %timeit for x in C: pass\nThe slowest run took 10.67 times longer than the fastest. This could mean that an intermediate result is being cached \n1000 loops, best of 3: 187 \u00b5s per loop\nsage: C = Compositions(10)\nsage: %timeit for x in C: pass\n100 loops, best of 3: 9.11 ms per loop\nsage: C = Compositions(20)\nsage: %timeit for x in C: pass\n1 loops, best of 3: 15.7 s per loop\n```\n\nAlso, the old version instantly fails for large `n` because of the recursion:\n\n```\nsage: C = Compositions(1000)\nsage: for x in C: pass\n...\nRuntimeError: maximum recursion depth exceeded in cmp\n```\n",
    "created_at": "2016-02-04T03:20:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271402",
    "user": "https://github.com/tscrim"
}
```

Some timings with the current branch:

```
sage: C = Compositions(5)
sage: %timeit for x in C: pass
The slowest run took 8.30 times longer than the fastest. This could mean that an intermediate result is being cached
10000 loops, best of 3: 34.9 µs per loop
sage: C = Compositions(10)
sage: %timeit for x in C: pass
1000 loops, best of 3: 1.1 ms per loop
sage: C = Compositions(20)
sage: %timeit for x in C: pass
1 loops, best of 3: 1.18 s per loop
```

versus the old version:

```
sage: C = Compositions(5)
sage: %timeit for x in C: pass
The slowest run took 10.67 times longer than the fastest. This could mean that an intermediate result is being cached 
1000 loops, best of 3: 187 µs per loop
sage: C = Compositions(10)
sage: %timeit for x in C: pass
100 loops, best of 3: 9.11 ms per loop
sage: C = Compositions(20)
sage: %timeit for x in C: pass
1 loops, best of 3: 15.7 s per loop
```

Also, the old version instantly fails for large `n` because of the recursion:

```
sage: C = Compositions(1000)
sage: for x in C: pass
...
RuntimeError: maximum recursion depth exceeded in cmp
```




---

archive/issue_comments_271403.json:
```json
{
    "body": "Grammar error in doc.\n\nMore importantly, though, I'm not sure I understand the algorithm. Why does it not decrement `s` in the `s > n` case? What is the logic behind the algorithm anyway?",
    "created_at": "2016-02-04T22:40:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271403",
    "user": "https://github.com/darijgr"
}
```

Grammar error in doc.

More importantly, though, I'm not sure I understand the algorithm. Why does it not decrement `s` in the `s > n` case? What is the logic behind the algorithm anyway?



---

archive/issue_comments_271404.json:
```json
{
    "body": "Replying to [comment:5 darij]:\n> Grammar error in doc.\n> \n> More importantly, though, I'm not sure I understand the algorithm. Why does it not decrement `s` in the `s > n` case?\n\nActually, that case never happens unless `n < 0`. So that could be removed.\n\n> What is the logic behind the algorithm anyway?\n\nThe idea is to find the lex smallest composition by adding a box each step. If we have a composition of `n`, then yield and remove the last column and add a box to the new final column. Otherwise add a box to the end. Hmmm....implementing it directly from that would probably be a little cleaner since `cur` would always be a valid partition. Let me change that now.",
    "created_at": "2016-02-04T22:59:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271404",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:5 darij]:
> Grammar error in doc.
> 
> More importantly, though, I'm not sure I understand the algorithm. Why does it not decrement `s` in the `s > n` case?

Actually, that case never happens unless `n < 0`. So that could be removed.

> What is the logic behind the algorithm anyway?

The idea is to find the lex smallest composition by adding a box each step. If we have a composition of `n`, then yield and remove the last column and add a box to the new final column. Otherwise add a box to the end. Hmmm....implementing it directly from that would probably be a little cleaner since `cur` would always be a valid partition. Let me change that now.



---

archive/issue_comments_271405.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-04T23:03:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271405",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_271406.json:
```json
{
    "body": "Replying to [comment:6 tscrim]:\n> Replying to [comment:5 darij]:\n> > Grammar error in doc.\n\nHow about this?\n\n> > What is the logic behind the algorithm anyway?\n> \n> The idea is to find the lex smallest composition by adding a box each step. If we have a composition of `n`, then yield and remove the last column and add a box to the new final column. Otherwise add a box to the end. Hmmm....implementing it directly from that would probably be a little cleaner since `cur` would always be a valid partition. Let me change that now.\n\nActually, now I remember why I did it how it is, so I wouldn't have to check that `cur` is non-empty when I did my backtracking.",
    "created_at": "2016-02-04T23:04:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271406",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:6 tscrim]:
> Replying to [comment:5 darij]:
> > Grammar error in doc.

How about this?

> > What is the logic behind the algorithm anyway?
> 
> The idea is to find the lex smallest composition by adding a box each step. If we have a composition of `n`, then yield and remove the last column and add a box to the new final column. Otherwise add a box to the end. Hmmm....implementing it directly from that would probably be a little cleaner since `cur` would always be a valid partition. Let me change that now.

Actually, now I remember why I did it how it is, so I wouldn't have to check that `cur` is non-empty when I did my backtracking.



---

archive/issue_comments_271407.json:
```json
{
    "body": "LGTM! This is actually a nice lexicographic iterator over all compositions of size `\\leq n`.\n\nIf you doctest sage/combinat  (this iterator is used a lot, and who knows what could happen), feel free to set this to positive review.",
    "created_at": "2016-02-04T23:21:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271407",
    "user": "https://github.com/darijgr"
}
```

LGTM! This is actually a nice lexicographic iterator over all compositions of size `\leq n`.

If you doctest sage/combinat  (this iterator is used a lot, and who knows what could happen), feel free to set this to positive review.



---

archive/issue_comments_271408.json:
```json
{
    "body": "Hi!\n\nThanks Travis; the timing is indeed way better.\n\nVincent, what do you think? This looks like a step in our general direction of splitting:\n\n- a lowlevel library of super-fast itertools style iterators producing plain data structures\n- higher level layer views, with all the Parent, Element goodies.\n\nI haven't followed much the progress in this direction. But I am wondering whether we want to go further (here or in a later ticket) by moving the iterator in a separate Cython file possibly using C-level data structure like vector<int> or ClonableIntArray.\n\nThe other thing is that the algorithm here is exactly that of IntegerListLex, with in principle, the same complexity. Of course the later has overhead since it needs to handle all the additional constraints. Yet it would reduce code bloat to focus on optimizing/cythonizing IntegerListLex rather than having a bunch of non cythonized (by lack of manpower) python methods for special cases.\n\nCheers,",
    "created_at": "2016-02-05T08:55:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271408",
    "user": "https://github.com/nthiery"
}
```

Hi!

Thanks Travis; the timing is indeed way better.

Vincent, what do you think? This looks like a step in our general direction of splitting:

- a lowlevel library of super-fast itertools style iterators producing plain data structures
- higher level layer views, with all the Parent, Element goodies.

I haven't followed much the progress in this direction. But I am wondering whether we want to go further (here or in a later ticket) by moving the iterator in a separate Cython file possibly using C-level data structure like vector<int> or ClonableIntArray.

The other thing is that the algorithm here is exactly that of IntegerListLex, with in principle, the same complexity. Of course the later has overhead since it needs to handle all the additional constraints. Yet it would reduce code bloat to focus on optimizing/cythonizing IntegerListLex rather than having a bunch of non cythonized (by lack of manpower) python methods for special cases.

Cheers,



---

archive/issue_comments_271409.json:
```json
{
    "body": "I'm wondering how much we could get by going one step further and moving `IntegerListsLex` to a small standalone C/C++ library, where we can really get to low-level optimizations. Although I see some technical challenges with this; in particular, taking functions as input and the lambda functions involved with the current implementation. Perhaps Cython will be sufficient.\n\nI agree that this would further benefit from cythonization/C-ifying. Right now we don't have a set place upon where we can put these functions. I also do not see them as code bloat because to really optimize `IntegerListsLex`, we will almost certainly have specialized implementations for special cases to avoid overhead of the general case. (This implementation can be easily tweaked to cover a number of other cases, but would likely have bad performance in general.)\n\nHowever, I think we should do all of these things on a separate ticket(s), which is why I'm setting this to a positive review given [comment:9 Darij's comment] and the green patchbot. Feel free to set it back if you disagree. Yet +1 to adding a common place/library for all of these iterator functions (and their cython/C versions).",
    "created_at": "2016-02-05T17:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271409",
    "user": "https://github.com/tscrim"
}
```

I'm wondering how much we could get by going one step further and moving `IntegerListsLex` to a small standalone C/C++ library, where we can really get to low-level optimizations. Although I see some technical challenges with this; in particular, taking functions as input and the lambda functions involved with the current implementation. Perhaps Cython will be sufficient.

I agree that this would further benefit from cythonization/C-ifying. Right now we don't have a set place upon where we can put these functions. I also do not see them as code bloat because to really optimize `IntegerListsLex`, we will almost certainly have specialized implementations for special cases to avoid overhead of the general case. (This implementation can be easily tweaked to cover a number of other cases, but would likely have bad performance in general.)

However, I think we should do all of these things on a separate ticket(s), which is why I'm setting this to a positive review given [comment:9 Darij's comment] and the green patchbot. Feel free to set it back if you disagree. Yet +1 to adding a common place/library for all of these iterator functions (and their cython/C versions).



---

archive/issue_comments_271410.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-02-05T17:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271410",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_054535.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-02-06T10:28:58Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19771#event-54535"
}
```



---

archive/issue_comments_271411.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-02-06T10:28:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19771#issuecomment-271411",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
