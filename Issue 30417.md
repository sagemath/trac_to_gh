# Issue 30417: Add fast matrix inverse for Hermitian positive-definite matrices

Issue created by migration from https://trac.sagemath.org/ticket/30654

Original creator: mjo

Original creation time: 2020-09-24 13:32:00

CC:  @mwageringel @kliem

To implement #29169, a fast inverse function for matrices known to be symmetric and positive-definite is used. The body of the function for a matrix `M` amounts to,


```
L_inverse = M.cholesky().inverse()
return L_inverse.transpose()*L_inverse
```


Instead, we can add this directly to the Matrix classes. A general method should use the conjugate-transpose (for complex matrices) instead of the plain transpose.

A few thoughts:

1. In sage, `is_positive_definite()` already requires that the matrix be symmetric, so I guess the new method should be called `inverse_positive_definite()` without mention of symmetry.
2. Currently the function fails with an error in `cholesky()` if it is given an asymmetric or indefinite matrix. Presumably this is acceptable even for a matrix method?
3. Should the method be public, or private to begin with?
4. In a perfect world, we would be able to quickly check if the fast inverse could be used in the generic matrix `inverse()` method, so that end users don't need to know about the custom fast inverse. Is this even possible? (I'm not willing to completely overhaul the `inverse()` method to use partial information obtained from a failed cholesky attempt.) Octave provides a separate `cholinv` function which suggests I'm not missing anything obvious.


---

Comment by @mwageringel created at 2020-09-24 16:43:29

Regarding the public interface, adding an `algorithm` keyword to the generic `inverse()` would be in line with Sage's conventions. For example, the method `eigenvalues()` of double dense matrices takes an `algorithm='hermitian'` argument, which then calls an implementation specialized for Hermitian matrices.


---

Comment by @kliem created at 2020-09-24 17:13:15

1. Sounds reasonable
2. `cholesky` is also in matrix. So I would assume this is ok.
3. public. If I know nothing about numerics and for some reason I need to invert a real matrix, I'm thankful for any help than I can get.
  At some point I was thankful, that the method `right_kernel_matrix` is public. Because `right_kernel` echolonizes, which isn't what you want for real matrices.
4. Real matrices do not have algorithms for inverse yet, they just inherit from matrix2.


---

Comment by mjo created at 2020-09-27 15:20:32

Replying to [comment:1 gh-mwageringel]:
> Regarding the public interface, adding an `algorithm` keyword to the generic `inverse()` would be in line with Sage's conventions. For example, the method `eigenvalues()` of double dense matrices takes an `algorithm='hermitian'` argument, which then calls an implementation specialized for Hermitian matrices.

I've thought about this for a few days and decided to go with a separate method. The two implementations share no code, so ultimately you still wind up with a separate function, but copy/pasted inside of the `inverse` method and guarded by an "if" statement rather than by the user. It's like using `call_function('foo')` to run `foo()`... aesthetically painful, and a tiny bit slower. It would be nice to share the OUTPUT documentation, but then we'd also have to put a bunch of conditionals like "if `algorithm="positive definite"` and if the matrix is not positive-definite,..." into the docstring for `inverse()`. So altogether I think this is cleaner.

If that seriously bothers anyone down the line, the `inverse_positive_definite` method can be made private, and `if algorithm == "positive definite": return self._inverse_positive_definite()` can be added to the top of `inverse()`.


---

Comment by mjo created at 2020-09-27 15:24:45

The branch I pushed has some problem that I have yet to debug:


```
sage: from sage.misc.prandom import choice ## line 12421 ##
sage: set_random_seed() ## line 12422 ##
sage: n = ZZ.random_element(5) ## line 12423 ##
sage: ring = choice([ZZ, QQ, AA, QQbar]) ## line 12424 ##
sage: A = matrix.random(ring, n) ## line 12425 ##
sage: I = matrix.identity(ring, n) ## line 12426 ##
sage: A = A*A.conjugate_transpose() + I ## line 12427 ##
sage: A.is_positive_definite() ## line 12428 ##
True
sage: actual = A.inverse_positive_definite() ## line 12430 ##
------------------------------------------------------------------------
/home/mjo/src/sage.git/local/lib/python3.8/site-packages/cysignals/signals.cpython-38-x86_64-linux-gnu.so(+0x5a76)[0x7fc77ea33a76]
...
183 0x0000000000000000 in ?? ()
#184 0x00007fc78049fec0 in PyRun_FileExFlags ()
#185 0x00007fc78049ffc0 in PyRun_SimpleFileExFlags ()
#186 0x00007fc7804ba4a0 in Py_RunMain ()
#187 0x00007fc7804bb040 in Py_BytesMain ()
#188 0x00007fc780179c40 in __libc_start_main ()
#189 0x0000557184b94710 in _start ()

[Inferior 1 (process 20324) detached]
Saved trace to /home/mjo/.sage/crash_logs/crash_qaj09oo3.log
```



---

Comment by mjo created at 2020-09-28 03:41:21

It turns out that sage is just terrible at inverting (even three-by-three unit-lower-triangular) random matrices with entries in `AA` or `QQbar`. I've neutered that test case to keep it from crashing on pathological examples.


---

Comment by mjo created at 2020-09-28 03:41:21

Changing status from new to needs_review.


---

Comment by @kliem created at 2020-09-29 03:40:06

You didn't link the branch yet.


---

Comment by mjo created at 2020-09-29 11:46:35

derp


---

Comment by @kliem created at 2020-09-29 14:14:40

Ok. LGTM and the bot is green.

Although I find myself wondering, why we have the `LU` method, but it is not exposed to invert real matrices.


---

Comment by @kliem created at 2020-09-29 14:14:40

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-10-05 20:12:41

Resolution: fixed
