# Issue 16576: symbolic Legendre / associated Legendre functions / polynomials

Issue created by migration from https://trac.sagemath.org/ticket/16813

Original creator: rws

Original creation time: 2014-08-13 15:15:55

Existing numeric functions are `legendre_P`, `legendre_Q`, `gen_legendre_P`, and `gen_legendre_Q` which correspond to P(n,x) / Q(n,x) and associated Legendre P(n,m,x) / Q(n,m,x).

They should be made symbolic. FLINT has fast code for P(n,x).

 * PQ(n,x)
   * https://en.wikipedia.org/wiki/Legendre_polynomials
   * http://mathworld.wolfram.com/LegendrePolynomial.html
 * PQ(n,m,x)
   * https://en.wikipedia.org/wiki/Associated_Legendre_polynomials
   * http://mathworld.wolfram.com/AssociatedLegendrePolynomial.html
 * functions PQ
   * https://en.wikipedia.org/wiki/Legendre_function
   * http://mathworld.wolfram.com/LegendreFunctionoftheFirstKind.html
   * http://mathworld.wolfram.com/LegendreFunctionoftheSecondKind.html


---

Comment by maldun created at 2014-08-24 20:08:30

Hi!

Good to see that someone else is working on making the orthogonal polynomials symbolic, since my research interests shifted heavily in the past years.

A good read on Legendre polynomials is also the bible for ortho polys: Abramowitz and Stegun [http://people.math.sfu.ca/~cbm/aands/page_331.htm](http://people.math.sfu.ca/~cbm/aands/page_331.htm)

There you will find also much information on special values and other properties.
I currently have some time left and can help with one thing or the other if you like,


---

Comment by rws created at 2014-08-26 11:29:41

Fine! See also http://trac.sagemath.org/wiki/symbolics/functions


---

Comment by rws created at 2014-08-27 14:02:24

OK I have a question. What is the equivalent recursive algorithm to https://github.com/sagemath/sage/blob/master/src/sage/functions/orthogonal_polys.py#L812-834
for Legendre polynomials?

The link is valid as long #16812 is not merged.


---

Comment by maldun created at 2014-08-27 14:08:48

Replying to [comment:3 rws]:
> OK I have a question. What is the equivalent recursive algorithm to https://github.com/sagemath/sage/blob/master/src/sage/functions/orthogonal_polys.py#L812-834
> for Legendre polynomials?
> 
> The link is valid as long #16812 is not merged.

Hi!

You won't have luck to find an equivalent recursion algorithm for Legendre Polynomials, since the recursion algorithm for Chebyshev Polynomials uses the fact that cheby polynomials are cosines in disguise, and thus one is able to build Cheby polyis in O(log N) time. For Legendre polynomials you have to use the classic recursion formula given in [https://en.wikipedia.org/wiki/Legendre_polynomials#Recursive_definition](https://en.wikipedia.org/wiki/Legendre_polynomials#Recursive_definition)


---

Comment by maldun created at 2014-08-27 14:24:46

Maybe this could help you:

I already implemented all Orthopolys one time: http://trac.sagemath.org/attachment/ticket/9706/trac_9706_ortho_polys.patch

they only would need cleanup/restructuring. Maybe you can reuse some of the implemented methods (like recursions and derivatives)


---

Comment by rws created at 2014-09-01 13:58:31

Some timings for P(n,z):

```
sage: legendre_P(100,2.5)
6.39483750487443e66
sage: timeit('legendre_P(100,2.5)')
25 loops, best of 3: 21 ms per loop

sage: from mpmath import legenp 
sage: legenp(100,0,2.5)
mpf('6.3948375048744286e+66')
sage: timeit('legenp(100,0,2.5)')
625 loops, best of 3: 97.2 µs per loop

sage: from scipy.special import eval_legendre
sage: eval_legendre(int(100),float(2.5))
6.3948375048744324e+66
sage: timeit('eval_legendre(int(100),float(2.5))')
625 loops, best of 3: 7.62 µs per loop

sage: eval_legendre(int(10^5),float(1.00001))
3.1548483029540554e+192
sage: timeit('eval_legendre(int(10^6),float(2.5))')
25 loops, best of 3: 11.8 ms per loop
sage: eval_legendre(int(10^6),float(2.5))
inf

```

while `legenp` will already bail out at 10<sup>5</sup> because of F convergence issues.


---

Comment by rws created at 2014-09-01 14:14:16

With P(n,x) symbolics and algebra, Pari is much better than Maxima

```
sage: P.<t> = QQ[]
sage: timeit('legendre_P(1000,t)')
5 loops, best of 3: 2.8 s per loop
sage: timeit('pari.pollegendre(1000,t)')
625 loops, best of 3: 366 µs per loop
```



---

Comment by rws created at 2014-09-04 12:38:02

This is a proof of concept patch, and one can already use `legendre_P` and see from that and the code how the other three functions will look like. So, now would be a good time for fundamental criticism 8)
----
New commits:


---

Comment by rws created at 2014-09-07 05:48:45

Replying to [comment:1 maldun]:
> A good read on Legendre polynomials is also the bible for ortho polys: Abramowitz and Stegun [http://people.math.sfu.ca/~cbm/aands/page_331.htm](http://people.math.sfu.ca/~cbm/aands/page_331.htm)
This appears outdated, it is replaced by http://dlmf.nist.gov/14


---

Comment by maldun created at 2014-09-07 09:35:38

Replying to [comment:10 rws]:
> Replying to [comment:1 maldun]:
> > A good read on Legendre polynomials is also the bible for ortho polys: Abramowitz and Stegun [http://people.math.sfu.ca/~cbm/aands/page_331.htm](http://people.math.sfu.ca/~cbm/aands/page_331.htm)
> This appears outdated, it is replaced by http://dlmf.nist.gov/14

You can't call a source outdated, which still covers information that the newer source doesn't. I checked your link, and some things from A&S are missign e.g. explicit representation of Legendre Polynomials with their polynomial coefficients.
And on another note: I don't see much harm in citing a classic work on this topic ...


---

Comment by rws created at 2014-09-09 16:24:22

Replying to [comment:5 maldun]:
> I already implemented all Orthopolys one time: http://trac.sagemath.org/attachment/ticket/9706/trac_9706_ortho_polys.patch
> 
> they only would need cleanup/restructuring. Maybe you can reuse some of the implemented methods (like recursions and derivatives)
I am not sure about the derivatives. For `P(3,2,x).diff(x)` I get `-45*x^2 + 15` (Wolfram agrees) while with your formula (lines 2377-2395 of the patch) I get (after simplification) `-45*x^2 - 15`.

Update: what's your reference there?


---

Comment by maldun created at 2014-09-09 17:38:19

Replying to [comment:12 rws]:
> Replying to [comment:5 maldun]:
> > I already implemented all Orthopolys one time: http://trac.sagemath.org/attachment/ticket/9706/trac_9706_ortho_polys.patch
> > 
> > they only would need cleanup/restructuring. Maybe you can reuse some of the implemented methods (like recursions and derivatives)
> I am not sure about the derivatives. For `P(3,2,x).diff(x)` I get `-45*x^2 + 15` (Wolfram agrees) while with your formula (lines 2377-2395 of the patch) I get (after simplification) `-45*x^2 - 15`.
> 
> Update: what's your reference there?

It seems you are right. from Gradshteyn-Ryzhik p.1004 formula 8.731-1 we have the relation

```
P(n,m,x).diff(x) = ((n+1-m)*P(n+1,m,x)-(n+1)*x*P(n,m,x))/(x**2-1)
```

The same relation holds for gen_legendre_Q

I suppose that's an copy/paste/rewrite mistake from my side.


---

Comment by rws created at 2014-09-12 15:28:38

Also, your recursive functions for `Q(n,x)` and `Q(n,m,x)` appear to be wrong:

```
sage: legendre_Q.eval_recursive(2,x).subs(x=3)
13/2*I*pi + 13/2*log(2) - 9/2
sage: legendre_Q.eval_recursive(2,x).subs(x=3).n()
0.00545667363964419 + 20.4203522483337*I
sage: legendre_Q(2,3.)
0.00545667363964451 - 20.4203522483337*I
```

The latter result from mpmath is supported by Wolfram.

As to `Q(n,m,x)`:

```
sage: gen_legendre_Q(2,1,x).subs(x=3)
-1/8*sqrt(-2)*(72*I*pi + 72*log(2) - 50)
sage: gen_legendre_Q(2,1,x).subs(x=3).n()
39.9859464434253 + 0.0165114736149170*I
sage: gen_legendre_Q(2,1,3.)
-39.9859464434253 + 0.0165114736149193*I
```

Again, Wolfram supports the latter value from mpmath (symbolic as `(25 i)/(2 sqrt(2))-18 i sqrt(2) ((log(4))/2+1/2 (-log(2)-i pi))`).


---

Comment by rws created at 2014-09-13 08:37:07

OK, I resolved it by using `conjugate()` on every logarithm in the `Q(n,x)` algorithms (on which the `Q(n,m,x)` recurrence is based, too).

Update: it however makes symbolic work tedious and differentiation impossible, at the moment.

See also https://groups.google.com/forum/?hl=en#!topic/sage-support/bEMPMEYeZKU on derivatives of conjugates in Sage.


---

Comment by maldun created at 2014-09-13 13:51:41

Thanks for resolving this issue! I suppose I wasn't careful enough with complex arguments. But in my defense: I hadn't time to test this codes well enough when I wrote them ... but hopefully they give some useful informations.

concerning complex conjugation: I hope my answer on the mailing list give some clues: [https://groups.google.com/forum/?hl=en#!topic/sage-support/bEMPMEYeZKU](https://groups.google.com/forum/?hl=en#!topic/sage-support/bEMPMEYeZKU)

Replying to [comment:15 rws]:
> OK, I resolved it by using `conjugate()` on every logarithm in the `Q(n,x)` algorithms (on which the `Q(n,m,x)` recurrence is based, too).
> 
> Update: it however makes symbolic work tedious and differentiation impossible, at the moment.
> 
> See also https://groups.google.com/forum/?hl=en#!topic/sage-support/bEMPMEYeZKU on derivatives of conjugates in Sage.


---

Comment by rws created at 2014-09-13 13:56:17

Replying to [comment:16 maldun]:
> Thanks for resolving this issue!
Unfortunately, while it would be easy to resolve this numerically, the instances of `conjugate()` introduced in the recurrence will make symbolic results from the recurrence unreadable and, in case of derivatives, impossible to use. A different way of computing the recurrences is needed, one which does away with usage of `conjugate()`.


---

Comment by maldun created at 2014-09-13 14:22:55

Hi!

We have several possible ways out of this:
1) avoid recursion for symbolic argument for Legendre_Q and use another library (maxima, flint, sympy ... ) for evaluation.
2) Let it be, but avoid it as default method.
3) Maybe more elegantly: There is a more closed relation for legendre_Q (but it's not really a recursion):


```
Q(n,z) = ½P(n,z) ln((z+1)/(z-1)) - W(n-1,z)
```

with

```
W(n,z) = Σ_{k=1}^n (1/k) P(k-1,z) P(n-k,z)
```

(Gradshteyn-Ryzhik p 1019f)

Maybe we could find an recursion for W(n,z)

Hope this could be of some use

Edit there should be a recursion since W(n,z) is the convolution of aseries of   holonomic functions, and if I remeber correctly there is an theorem saying that convolutions of holonomic functions are also holonomic, thus should have a recursion.

Edit: The above mentioned relation can also be found here: [http://people.math.sfu.ca/~cbm/aands/page_334.htm](http://people.math.sfu.ca/~cbm/aands/page_334.htm)


---

Comment by rws created at 2014-09-13 15:11:50


```
sage: from ore_algebra import *
sage: def W(n):
    return sum([(1/k)*legendre_P(k-1,t)*legendre_P(n-k,t) for k in range(1,n+1)])
....: 
sage: R.<t> = QQ['t']
sage: guess([W(n) for n in range(1,10)], OreAlgebra(R['n'], 'Sn'))
(-n - 3)*Sn^2 + (2*t*n + 5*t)*Sn - n - 2
```



---

Comment by maldun created at 2014-09-13 15:44:31

Nice! I didn't know that sage already supports Ore Algebras.
It appears that my holonomic function package on Mathematica stopped to work.


---

Comment by rws created at 2014-09-13 16:05:36

I always need some time to figure out the final form (that offset of `n`!) but: n*W<sub>n</sub> = (2tn-t)*W<sub>n-1</sub> - (n-1)W<sub>n-2</sub> (W<sub>0</sub>=0, W<sub>1</sub>=1).


---

Comment by rws created at 2014-09-14 07:33:09

However, this will yield the same result unless the `log` has `conjugate` associated with it. This shows your recurrence is actually correct but numerical results derived from it by substitution may need a warning about the log branch. I know not enough about calculus, maybe I'll ask again, this time on sage-devel, if there should be a switch for `log()` to select the branch in case of numerical evaluation. What do you think?


---

Comment by rws created at 2014-09-14 07:56:44

I think there must be another different formula, because Wolfram has this for `Q(2,x)`:

```
sage: ((3*x^2-1)/2*(log(x+1)-log(1-x))/2-3*x/2).subs(x=3)
-13/2*I*pi + 13/2*log(4) - 13/2*log(2) - 9/2
sage: ((3*x^2-1)/2*(log(x+1)-log(1-x))/2-3*x/2).subs(x=3).n()
0.00545667363964419 - 20.4203522483337*I
```

which yields the correct value without use of `conjugate`.

The first few `Q(n,x)` from Wolfram are:

```
Q(0,x) = 1/2 log(x+1)-1/2 log(1-x)
Q(1,x) = x (1/2 log(x+1)-1/2 log(1-x))-1
Q(2,x) = 1/2 (3 x^2-1) (1/2 log(x+1)-1/2 log(1-x))-(3 x)/2
Q(3,x) = -(5 x^2)/2-1/2 (3-5 x^2) x (1/2 log(x+1)-1/2 log(1-x))+2/3
```

which makes clear that instead of `log((1+x)/(1-x)).conjugate()` we should just use `log(1+x)-log(1-x)`, of course. Oh well.


---

Comment by maldun created at 2014-09-14 10:27:55

Oh yeah it's again the non uniqueness of the representation of the complex logarithm


```
sage: log((x+1)/(1-x)).subs(x=3)
I*pi + log(2)
sage: (log(x+1)-log(1-x)).subs(x=3).simplify_log()
-I*pi + log(2)
sage: log((x+1)/(1-x)).subs(x=3).conjugate()
-I*pi + log(2)
```


confusing as hell ...

I think Wolfram uses the log(1+x)-log(1-x) representation simply by the fact that it is independent of the branch in the following sense:
Let log(x) = ln|x| + i*arg(x) + 2kπi and log(y) = ln|y| + i*arg(y) + 2kπi
then 

```
log(x) - log(y) = ln|x| + i*arg(x) + 2kπi- ln|y| + i*arg(y) + 2kπi = 
# ln|x/y| + i*(arg(x) - arg(y)) + 0 
```

I.e. if we have the same branch on the logarithm the module of 2kπi cancels out.

That means the formula isn't exactly wrong, it uses simply a different branch of the logarithm. But the representation of log as difference saves us indeed a lot of trouble, and as showed above is independent of the branch we use.

Nevertheless I think we should stick to the recursion with W(n,x), because from a computational view it is a lot better since:

1) The computational complexity is the same (solving a two term recursion)

2) we save computation time since we don't have to simplify expressions containing logarithms but only polynomials which are much simpler to handle and expand.


---

Comment by git created at 2014-09-14 13:52:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2014-09-14 14:01:02

Changing status from new to needs_review.


---

Comment by rws created at 2014-09-14 14:01:02

Replying to [comment:24 maldun]:
> Nevertheless I think we should stick to the recursion with W(n,x), because from a computational view it is a lot better since:
> 
> 1) The computational complexity is the same (solving a two term recursion)
> 
> 2) we save computation time since we don't have to simplify expressions containing logarithms but only polynomials which are much simpler to handle and expand.
Well, I have implemented your recurrence using multivariate polynomials where the generator `l` stands for the `log` term and gets substituted subsequently. This is already twice as fast as Maxima. However, your intuition was right that the `W(n,x)` formula is still faster, my guess because univariate polys are faster than multi. Note that the `P(n,x)` have to be computed, too, but nevertheless it's about 10x the speed of Maxima (which BTW uses the wrong log branch as well).

I might add some introductory doc cleanup but the functions themselves are now finished. Please review.


---

Comment by maldun created at 2014-09-14 15:49:08

Replying to [comment:26 rws]:

> Well, I have implemented your recurrence using multivariate polynomials where the generator `l` stands for the `log` term and gets substituted subsequently. This is already twice as fast as Maxima. However, your intuition was right that the `W(n,x)` formula is still faster, my guess because univariate polys are faster than multi. Note that the `P(n,x)` have to be computed, too, but nevertheless it's about 10x the speed of Maxima (which BTW uses the wrong log branch as well).
> 
> I might add some introductory doc cleanup but the functions themselves are now finished. Please review.

If Maxima uses also this branch of the logarithm we should make sure that changing the branch of the logarithm does not interfere with existing code. Have you already testet the complete sage library with

```
sage -testall
```

?

We should also ask on the mailing list if there are some objections with that. 

Personally I'm fine with both, as long as it is consistent, since using another branch of the logarithm is not wrong, but maybe not expected. (Maybe I programmed the recursion that way, since I compared it with Maxima that time, so that the output does not change)


---

Comment by rws created at 2014-09-14 16:23:48

Replying to [comment:27 maldun]:
> Have you already testet the complete sage library with
> {{{
> sage -testall
> }}}
> ?
Buildbot task is queued.


---

Comment by maldun created at 2014-09-15 08:30:53

Replying to [comment:28 rws]:
> Replying to [comment:27 maldun]:
> > Have you already testet the complete sage library with
> > {{{
> > sage -testall
> > }}}
> > ?
> Buildbot task is queued.

I asked on sage-devel if there are other objections on using the log(1+z) - log(1-z) representation: https://groups.google.com/forum/?hl=en#!topic/sage-devel/5_4Pr8GypUA
Let's see what the other developers think.


---

Comment by rws created at 2014-09-15 09:04:15

I'm afk for some time, will see when I get back.


---

Comment by rws created at 2014-09-30 13:54:34

Replying to [comment:29 maldun]:
> Replying to [comment:28 rws]:
> > Replying to [comment:27 maldun]:
> > > Have you already testet the complete sage library with
> > > {{{
> > > sage -testall
> > > }}}
> > > ?
> > Buildbot task is queued.
And tested successfully, see the top of the ticket.


---

Comment by maldun created at 2014-09-30 17:33:23

Very good! Since there are no objections on sage-devel this ticket only needs review now.


---

Comment by git created at 2014-12-06 09:44:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-02-24 09:36:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2015-03-12 09:23:11

Changing status from needs_review to needs_work.


---

Comment by mmezzarobba created at 2015-03-12 09:23:11

I'm getting several doctest failures like:

```
File "src/sage/functions/orthogonal_polys.py", line 1426, in sage.functions.orthogonal_polys.Func_legendre_Q._maxima_init_evaled_
Failed example:
    legendre_Q._maxima_init_evaled_(20,x).coeff(x^10)
Expected:
    -29113619535/131072*log(-(x + 1)/(x - 1))
Got:
    doctest:1: DeprecationWarning: coeff is deprecated. Please use coefficient instead.
    See http://trac.sagemath.org/17438 for details.
    -29113619535/131072*log(-(x + 1)/(x - 1))
```



---

Comment by git created at 2015-03-12 09:53:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-03-12 09:53:58

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2015-03-12 15:22:59

Sorry if that's a stupid question, but why do you need to override `__call__`? In any case I guess a comment explaining the reason would be useful.


---

Comment by mmezzarobba created at 2015-03-12 15:27:57


```
sage: legendre_P(0, 1).n()
...
AttributeError: 'int' object has no attribute 'n'
sage: legendre_P(1, 1).n()
1.00000000000000
```



---

Comment by mmezzarobba created at 2015-03-12 15:32:46


```
sage: legendre_P(42, 12345678)
1464081544112412716366892468459853695115358209756840823628776385121841706762162962766108364297738809627122469598911070029409071998031560780937314580877929546448067606814039101080853578172130265741673137107647826759931295833598386722228898959000304822089300102623241891719774710215869248045233381461475507593850687226480251/549755813888
sage: legendre_P(42, RR(12345678))
+infinity
sage: legendre_P(42, Reals(100)(12345678))
2.6631488146675341638308827323e309
```


→ Consistent so far. But:


```
sage: legendre_P(42, Reals(20)(12345678))
legendre_P(42, 1.2346e7)
```



---

Comment by mmezzarobba created at 2015-03-12 15:38:53

Perhaps related to the previous comment, I'm no fan of the mechanism used to choose `real_parent`. Do you have an example where this code would be useful that could not be handled at the level of `Function` or perhaps `OrthogonalPolynomial`?


---

Comment by mmezzarobba created at 2015-03-12 15:52:59

More on the wishlist side of things: The numerical evaluation methods return nonsense in cases where Maple, say, is accurate.

```
sage: legendre_P(201/2, 0).n()
365146.687569733
sage: legendre_P(201/2, 0).n(100).n()
0.0561386178630179
```



---

Comment by rws created at 2015-03-12 15:53:36

Changing status from needs_review to needs_work.


---

Comment by mmezzarobba created at 2015-03-12 16:12:20


```
sage: legendre_P(x, x, x)
...
TypeError: Symbolic function legendre_P takes exactly 2 arguments (3 given)
```

but:

```
sage: legendre_P(1, x, x)
x
```



---

Comment by mmezzarobba created at 2015-03-12 16:28:01

Why does `Func_legendre_P.__call__` contain:

```
       elif algorithm == 'recursive':
           return self.eval_recursive(n, x)
```

while `Func_legendre_P` has no method `eval_recursive`?


---

Comment by git created at 2015-03-13 16:44:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-03-13 16:46:55

Changing status from needs_work to needs_review.


---

Comment by rws created at 2015-03-13 16:46:55

This addresses all issues. Indeed the changes were necessary, thanks for your input.

If you set one of the ortho poly tickets to positive, then please wait with the other, so I can remove merge conflicts.


---

Comment by mmezzarobba created at 2015-03-14 08:21:41

Thank you for fixing all this.

One more remark: the main module docstring needs updating (at least to remove the TODO about associated Legendre polynomials, perhaps also to clarify what relies on Maxima and what doesn't).


---

Comment by mmezzarobba created at 2015-03-14 08:44:09

Also, like in the case of #17151, I think having:

```
sage: legendre_P(0, x).parent()
Integer Ring
sage: legendre_P(0, SR(1)).parent()
Integer Ring
```

is a bug.

Compare for example:

```
sage: sin(0).parent() # not sure I like this, but somehow makes sense
Integer Ring
sage: sin(SR(0)).parent()
Symbolic Ring
```



---

Comment by mmezzarobba created at 2015-03-14 08:52:51

`legendre_P` does not know that `P(n, 1) == 1`.


---

Comment by mmezzarobba created at 2015-03-14 09:02:20

I find it strange that `Func_legendre_Q` and `Func_assoc_legendre_{P,Q}`derive from `OrthogonalPolynomial` since these functions are not polynomials, even for fixed integer m and n. And in fact the same argument could apply to `Func_legendre_P` itself, since they seem to work for non-integer n, even though only the case of integer n appears to be documented.


---

Comment by mmezzarobba created at 2015-03-14 09:09:51

Not sure what to think about that:

```
sage: legendre_P(10, polygen(CC, 'x'))
46189/256*x^10 - 109395/256*x^8 + 45045/128*x^6 - 15015/128*x^4 + 3465/256*x^2 - 63/256
sage: legendre_P(10, polygen(CC, 'x'), algorithm='pari')
180.425781250000*x^10 - 427.324218750000*x^8 + 351.914062500000*x^6 - 117.304687500000*x^4 + 13.5351562500000*x^2 - 0.246093750000000
sage: legendre_P(10, polygen(CC, 'x'), coerce=False)
...
TypeError: arguments must be symbolic expressions
sage: legendre_P(10, polygen(CC, 'x'), algorithm='pari', coerce=False)
180.425781250000*x^10 - 427.324218750000*x^8 + 351.914062500000*x^6 - 117.304687500000*x^4 + 13.5351562500000*x^2 - 0.246093750000000
sage: legendre_P(10, polygen(RIF, 'x'))
46189/256*(x)^10 - 109395/256*(x)^8 + 45045/128*(x)^6 - 15015/128*(x)^4 + 3465/256*(x)^2 - 63/256
```


Is the idea that calls to `legendre_P(n, x)` with no `algorithm` keyword will always take the branch corresponding to `x` in `SR`, but the user can obtain faster evaluations at integers etc. by specifying `algorithm='pari'` is they know what they are doing?


---

Comment by rws created at 2015-03-14 09:24:19

Replying to [comment:51 mmezzarobba]:
> I find it strange that `Func_assoc_legendre_{P,Q}`derive from `OrthogonalPolynomial` since these functions are not polynomials, even for fixed integer m and n.
https://en.wikipedia.org/wiki/Associated_Legendre_polynomials
"...they satisfy the orthogonality condition..."


---

Comment by rws created at 2015-03-14 09:26:08

Of course, I'd rather have it all under `functions/holonomic/`...


---

Comment by mmezzarobba created at 2015-03-14 09:40:49

Replying to [comment:53 rws]:
> Replying to [comment:51 mmezzarobba]:
> > I find it strange that `Func_assoc_legendre_{P,Q}`derive from `OrthogonalPolynomial` since these functions are not polynomials, even for fixed integer m and n.
> https://en.wikipedia.org/wiki/Associated_Legendre_polynomials
> "...they satisfy the orthogonality condition..."

Sure, but they are not polynomials. It is necessarily wrong to use the class `OrthogonalPolynomial` for things that are not, strictly speaking, orthogonal polynomials if really necessary, but then there should at least be a clear warning in the documentation of that class.

Replying to [comment:54 rws]:
> Of course, I'd rather have it all under functions/holonomic/...

I'm not sure being holonomic or not makes a big difference for a symbolic function. What do you have in mind?

(As for me, I would like to have an implementation of general holonomic functions in Sage at some point, but I'm more thinking of a parent entirely separate from `SR` and with conversion methods to and from symbolic functions. Symbolic functions that happen to be holonomic could have a method that returns their representation using a system of linear functional equations, and could use that to implement operations for which no better function-specific code is available.)


---

Comment by mmezzarobba created at 2015-03-14 09:45:33


```
sage: legendre_Q(-1., 0.)
(+infinity)*sqrt(pi)*sin(0.500000000000000*pi)
```



---

Comment by mmezzarobba created at 2015-03-14 09:46:56


```
sage: legendre_Q(1, 1, algorithm='pari')
...
AttributeError: 'Func_legendre_Q' object has no attribute 'eval_pari'
```


but


```
sage: legendre_Q(-1, 1, algorithm=pari)
...
TypeError: __call__() got an unexpected keyword argument 'algorithm'
```



---

Comment by mmezzarobba created at 2015-03-14 09:50:27


```
sage: legendre_Q(-1, x)
...
UnboundLocalError: local variable 'help3' referenced before assignment
```



---

Comment by mmezzarobba created at 2015-03-14 09:52:28

I find it surprising that:

```
sage: legendre_Q(0, x)
1/2*log(x + 1) - 1/2*log(-x + 1)
sage: legendre_Q(0, pi)
1/2*log(pi + 1) - 1/2*log(-pi + 1)
```

but:

```
sage: legendre_Q(0, 2)
legendre_Q(0, 2)
```

and even:

```
sage: legendre_Q(0, SR(2))
legendre_Q(0, 2)
```



---

Comment by mmezzarobba created at 2015-03-14 10:04:58

A fun one:

```
sage: a = legendre_Q(0, 1/2)
sage: a.n()
0.549306144334055
sage: maple(a).evalf()
.5493061443-1.570796327*I
```


I think the issue is that Maple uses non-standard branch cuts for the Legendre functions, so that the conversion to Maple is not correct.


---

Comment by mmezzarobba created at 2015-03-14 10:07:21

Changing status from needs_review to needs_work.


---

Comment by rws created at 2015-03-14 14:40:11

Replying to [comment:52 mmezzarobba]:
> Is the idea that calls to `legendre_P(n, x)` with no `algorithm` keyword will always take the branch corresponding to `x` in `SR`, but the user can obtain faster evaluations at integers etc. by specifying `algorithm='pari'` is they know what they are doing?
Effectively, one of the `__call__` methods (at this point of time `OrthogonalPolynomial.__call__`) dispatches to the resp. `eval_...` method. If no match is found (and `algorithm` is `None`) `__call__` returns to somewhere in the `BuiltinFunction/Function` classes to either return a held object or call `evalf`. Jeroen wanted to implement a default list of `algorithm/eval_...` pairs checked automatically but, if this keeps coming up, I'll put it high on my list.
> I'm not sure being holonomic or not makes a big difference for a symbolic function. What do you have in mind?
It's just a natural category for special functions, corresponding to a D-finite series expansion.


---

Comment by rws created at 2015-03-14 15:14:38

Replying to [comment:49 mmezzarobba]:
> Also, like in the case of #17151, I think having:
> {{{
> sage: legendre_P(0, x).parent()
> Integer Ring
> sage: legendre_P(0, SR(1)).parent()
> Integer Ring
> }}}
> is a bug.
This is now #17953.


---

Comment by rws created at 2015-06-30 06:06:25

From the ask.sagemath issue there is also this discrepancy:

```
sage: -1/2*sqrt(3)*gen_legendre_P(1/2, -1, -5/3)
-0.483843755630126 + 0.369716687246133*I

vs. Maple:
A := z -> exp(I*Pi*z)*hypergeom([-z,1/2],[2],4):
evalf(A(1/2)); -0.3697166872 + 0.4838437556 I
```



---

Comment by rws created at 2015-06-30 15:28:27

Changing type from enhancement to defect.


---

Comment by rws created at 2015-06-30 16:17:35

Replying to [comment:52 mmezzarobba]:
> Is the idea that calls to `legendre_P(n, x)` with no `algorithm` keyword will always take the branch corresponding to `x` in `SR`, but the user can obtain faster evaluations at integers etc. by specifying `algorithm='pari'` is they know what they are doing?
No, there is no idea, I just haven't figured out why the `BuiltinFunction` mechanism won't give me the original `x`, so I klugded something in `OrthogonalFunction.__call__` triggered by `algorithm`. This will have to be fixed but not today.


---

Comment by rws created at 2015-07-01 07:29:13

`@`mezzarobba: The problem with non-numeric arguments not getting through unconverted to `function::eval` cannot be solved with the current `BuiltinFunction`. Some numerics aren't even converted but throw an error, see #17790. I thus think that the given examples with `polygen(CC)` as argument cannot be implemented at the moment without kludging a taylor-made `__call__` method, and should be worked around using substitution. A solution will only be possible with #18832.


---

Comment by git created at 2015-07-01 09:38:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-01 13:10:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-07-01 13:11:33

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2015-08-09 18:14:59

needs rebase, does not apply


---

Comment by chapoton created at 2015-08-09 18:14:59

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-08-10 06:12:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-08-10 06:16:29

I have absolutely no idea why there is a merge conflict in `orthogonal_polys.py` when no one did a change there in the develop branch. Will see if this continues.


---

Comment by rws created at 2015-08-10 06:16:46

Changing status from needs_work to needs_review.


---

Comment by rws created at 2015-10-24 06:45:42

Squashed it all into one commit.
----
New commits:


---

Comment by chapoton created at 2016-03-26 19:44:21

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2016-03-26 19:44:21

Changing keywords from "" to "orthogonal".


---

Comment by chapoton created at 2016-03-26 19:44:21

some failing doctests, see bot report


---

Comment by git created at 2016-03-27 05:52:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-03-27 05:56:12

The failure in `symbolic/expression_conversions.py` is due to a random bug and we now depend on #19464.


---

Comment by rws created at 2016-03-29 13:42:33

Replying to [comment:68 rws]:
> `@`mezzarobba: The problem with non-numeric arguments not getting through unconverted to `function::eval` cannot be solved with the current `BuiltinFunction`. Some numerics aren't even converted but throw an error, see #17790. I thus think that the given examples with `polygen(CC)` as argument cannot be implemented at the moment without kludging a taylor-made `__call__` method, and should be worked around using substitution. A solution will only be possible with #18832.
I have opened #20312 on which the above depends.


---

Comment by git created at 2016-07-19 07:33:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-07-19 07:34:27

Changing status from needs_work to needs_review.


---

Comment by rws created at 2016-08-04 06:22:16

Maybe it's better to factor out the associated function stuff, regardless if Python or C++.


---

Comment by mmezzarobba created at 2016-09-16 13:36:20

Changing status from needs_review to positive_review.


---

Comment by mmezzarobba created at 2016-09-16 13:36:20

Time to get this merged, I guess. I'm still not 100% happy with how evaluation behaves (ideally, in the cases where the function is a polynomial, one would like to be able to evaluate it on elements of any ℚ-algebra), but getting it right in all cases looks difficult, and imperfect code is more useful than no code at all  `:-)`.


---

Comment by rws created at 2016-09-16 14:04:14

Agree and thanks for the review.


---

Comment by tscrim created at 2016-10-30 22:43:00

Changing status from positive_review to needs_work.


---

Comment by tscrim created at 2016-10-30 22:43:00

Needs rebase.


---

Comment by git created at 2016-10-31 06:12:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-10-31 06:13:36

Changing status from needs_work to needs_review.


---

Comment by rws created at 2016-10-31 06:13:36

Review needed for the last two commits.


---

Comment by tscrim created at 2016-10-31 14:51:37

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2016-11-10 19:34:01

One failing doctest, see patchbot.


---

Comment by tscrim created at 2016-11-10 19:34:01

Changing status from positive_review to needs_work.


---

Comment by rws created at 2016-11-11 07:30:47

Does not fail here. Note the patchbot is running 7.5beta1 not 2, and there were `gegenbauer` changes with pynac-0.7.0. I'll try to trigger the bots.


---

Comment by rws created at 2016-11-11 07:30:47

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2016-11-11 14:51:37

I ended up accidentally trying this on my beta1 as well. All is good.


---

Comment by tscrim created at 2016-11-11 14:51:37

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-11-19 22:38:50

The dependency is invalid/wontfix. What are you depending on?


---

Comment by rws created at 2016-11-20 08:50:12

Replying to [comment:95 vbraun]:
> The dependency is invalid/wontfix. What are you depending on?
Actually I don't recall and couldn't find out how `floor(x,hold=True)` was fixed. That bug was the reason for the `random_expr()` doctest fail in this and some other ticket. I'll remove the dependency.


---

Comment by vbraun created at 2016-11-21 21:56:30

Resolution: fixed
