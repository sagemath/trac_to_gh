# Issue 14658: Compositions accept any input

Issue created by migration from Trac.

Original creator: stumpc5

Original creation time: 2013-07-06 15:37:28

Assignee: sage-combinat

CC:  chrisjamesberg andrew.mathas vivianepons tscrim aschilling

Keywords: composition, FindStat


```
sage: sage: Composition([1,0,-1])
[1, 0, -1]
sage: sage: Composition('ASDF')
['A', 'S', 'D', 'F']
```



---

Comment by chapoton created at 2013-09-20 11:52:01

This is no longer the case in 5.12.beta5.

Can we close this as invalid ?


---

Comment by stumpc5 created at 2013-09-20 12:07:37

Replying to [comment:1 chapoton]:
> Can we close this as invalid ?

I don't have any recent version of Sage installed -- do compositions now only accept valid input? In that case, this ticket is obsolete.

Thanks, Christian


---

Comment by chapoton created at 2013-09-20 12:19:08

I was wrong, too bad.

The problem is still there in 5.12.beta5. It was only the ascii-art that was not able to draw these bad "compositions" !

So the ticket is open !


---

Comment by chapoton created at 2013-10-19 17:00:13

Changing status from new to needs_review.


---

Comment by chapoton created at 2013-10-19 17:00:13

Here is a patch, needs review.


---

Comment by nbruin created at 2013-10-19 17:29:06

The thing that mainly surprises me is that

```
sage: a=Hom(ZZ,ZZ)(1)
sage: b=Hom(ZZ,ZZ)(1)
sage: Composition(a,b)
```

fails. Composition is such an overused term in mathematics that I think it's ill-advised to expose some specialist combinatorial notion of the term in the global scope.


---

Comment by stumpc5 created at 2013-10-19 21:41:05

Replying to [comment:5 nbruin]:
> Composition is such an overused term in mathematics that I think it's ill-advised to expose some specialist combinatorial notion of the term in the global scope.

You are certainly right in criticizing the current use of this term. Since not many people read this ticket, and its aim is only to fix a little bug in this method: could you cross-post your comment to Sage-Combinat?


---

Comment by nbruin created at 2013-10-20 17:13:00

Replying to [comment:6 stumpc5]:
> You are certainly right in criticizing the current use of this term. Since not many people read this ticket, and its aim is only to fix a little bug in this method: could you cross-post your comment to Sage-Combinat?
I'm not a member of that list, so I don't think I can crosspost there.


---

Comment by darij created at 2013-10-20 17:34:19

Can't we use `Compose` for the composition of maps? Unfortunately I don't know how to rename the combinatorial notion of compositions (`IntegerComposition` feels like the entries don't have to be positive), and just hiding it would create a lot of confusion.


---

Comment by stumpc5 created at 2013-10-20 17:40:54

Replying to [comment:8 darij]:
> Can't we use `Compose` for the composition of maps? Unfortunately I don't know how to rename the combinatorial notion of compositions (`IntegerComposition` feels like the entries don't have to be positive), and just hiding it would create a lot of confusion.

We use `Partition` for `IntegerPartition`, though it could as well refer to `SetPartition` or whatever else. For me `IntegerPartition` is a partition of a positive integer. I would be totally fine with using `IntegerPartition` and `IntegerComposition`.


---

Comment by andrew.mathas created at 2013-10-20 19:14:37

Replying to [comment:9 stumpc5]:
> We use `Partition` for `IntegerPartition`, though it could as well refer to `SetPartition` or whatever else. For me `IntegerPartition` is a partition of a positive integer. I would be totally fine with using `IntegerPartition` and `IntegerComposition`.

I am against changing the name of the `Partition` class to `IntegerPartition`. This would create a major patch bomb as `Partition` is used in many places -- a quick and dirty count with grep gives me 114 different python files. 

More importantly, even though the name `IntegerPartition` is not bad, I do not think it is what most people would guess when looking for partitions so this change would, in effect, make `sage ` harder to use. Of the files using `Partition`, 29 of them are outside of the `combinat` directory so presumably the usage of this class is wider than just algebraic combinatorics). 

As far as I am aware there is no name conflict with the name `Partition` (btw, there already is a separate `SetPartition` class). The only justification for changing this name given so far is in order to maintain name consistency with a potential name change for `Composition`. I do not think that this is a good argument.

With regard to `Composition`, I do not have any strong feelings. I do not see anything wrong with having both `IntegerComposition` and `Partition` in the name-space. On the other hand, since no one has noticed a problem with `Composition` before I don't really understand why there is suddenly a problem now, especially as a much superior notation is already available for the composition of two maps:

```
sage: a=Hom(ZZ,ZZ)(1)
sage: b=Hom(ZZ,ZZ)(1)
sage: a*b
Ring endomorphism of Integer Ring
  Defn: 1 |--> 1
```

As there already is a really good way to compose maps in sage I don't find the argument for changing the meaning of `Composition` very compelling.


---

Comment by darij created at 2013-10-20 19:16:49

Why do we need a class for compositions of maps, by the way? Isn't that the same as just... maps?


---

Comment by nbruin created at 2013-10-20 19:51:32

Replying to [comment:11 darij]:
> Why do we need a class for compositions of maps, by the way? Isn't that the same as just... maps?

We don't, and the composition of maps can be obtained using `phi*psi` (which will have its own clashes if you want pointwise products for maps into a multiplicative group). However, the fact that the slot in the global namespace is in principle available doesn't imply it should be used for a special notion.

The title of the ticket already shows the confusion that can arise: The ticket complains that `Composition` is too lax with its argument checking and at the same time it seems `Composition` doesn't accept inputs that are perfectly valid for a mathematically widely accepted meaning of the word. 

Note that the full name is fine:

```
sage.combinat.composition.Composition
```

[Note that it is a function, not a class, by the way]. I just think it's inappropriate to import it into the global namespace under such a generic name. If you make that

```
from sage.combinat.composition import Composition as IntegerComposition
```

you should be fine and a lot less ambiguous already. With a system that is the scope of sage we really have to be careful with the global namespace. It is a very scarce resource.

I like `IntegerComposition`, by the way, and I don't think `Partition` is that problematic. If that becomes problematic, we can probably write a generic Partition routine to be imported in the global namespace that dispatches to the appropriate routine (IntegerPartition or SetPartition or whatever) based on type of the input parameters.


---

Comment by darij created at 2013-10-20 19:56:38

It is a class:

```
class Composition(CombinatorialObject, Element):
```


Shouldn't a function "composition" be written in lowercase?


---

Comment by nbruin created at 2013-10-20 20:00:22

Replying to [comment:10 andrew.mathas]:
> I am against changing the name of the `Partition` class to `IntegerPartition`. This would create a major patch bomb as `Partition` is used in many places -- a quick and dirty count with grep gives me 114 different python files. 

Such a change wouldn't have to be that invasive. The function `sage.combinat.partition.Partition` could retain its name and all library code would be importing that anyway, so no changes are necessary outside the obviously affected files and the odd doctest. One would just do

```
from sage.combinat.partition import Partition as IntegerPartition
```

to get the right routine in the global namespace. And perhaps provide a routine `Partition` to dispatch over different `Partition` types. (I don't think !Partition is particularly problematic, though).


---

Comment by darij created at 2013-10-20 20:01:59

It would slow things down, though... unless we change all calls to `Partition` via patchbombing.


---

Comment by nbruin created at 2013-10-20 20:15:17

Replying to [comment:13 darij]:
> It is a class:
> {{{
> class Composition(CombinatorialObject, Element):
> }}}
Ah you're right. It wasn't in Sage 5.7. 
> Shouldn't a function "composition" be written in lowercase?
That depends. If it's a "factory function" it's really meant to be a class constructor, but some implementation details prevented it from being written that way. So then the capitalization could still make sense. With that in mind it's more a judgement call whether to capitalize something.

> It would slow things down, though... unless we change all calls to `Partition` via patchbombing. 
Do you have timings to back that up? It shouldn't (depending on what "It" is).

If you mean using a `from ... import ... as ...` construction: that should lead to exactly the same performance. It just means the link in the relevant namespace dict is stored under a different key than would be chosen by default. There is no extra link step to follow.

If you mean the extra redirection in a global namespace generic dispatch routine: yes, that would have a bit of overhead. But that's always the case: it's much better to use specific routines, that are likely not available directly from the global namespace.


---

Comment by darij created at 2013-10-21 03:14:16

"If you mean the extra redirection in a global namespace generic dispatch routine: yes, that would have a bit of overhead. But that's always the case: it's much better to use specific routines, that are likely not available directly from the global namespace."

Oops, when I said that "it" would slow things down, I meant the generic dispatch routine (as factory or function or whatever). And I know that this can be fixed by calling specific routines; I'm just saying it'll probably require a patchbomb this way or another, because at the moment I think most code that builds compositions calls `Composition`.


---

Comment by nbruin created at 2013-10-21 04:54:57

Replying to [comment:17 darij]:

> Oops, when I said that "it" would slow things down, I meant the generic dispatch routine (as factory or function or whatever). And I know that this can be fixed by calling specific routines; I'm just saying it'll probably require a patchbomb this way or another, because at the moment I think most code that builds compositions calls `Composition`.

They won't be importing it from the global scope (they wouldn't even have a convenient way of accessing it). The files that use `Composition` would have a line `from sage.combinat.composition import Composition` and that wouldn't be affected in any way. No need to patch that.


---

Comment by nbruin created at 2013-10-22 00:54:37

I wouldn't have expected this at first blush, but after reading `Composition.__classcall_private__` it's pretty obvious why
in terms of performance, `Composition` should not be called directly:

```
sage: timeit("Composition([1,2,3,4])",number=100000)
100000 loops, best of 3: 8.01 µs per loop
sage: timeit("Compositions()([1,2,3,4])",number=100000)
100000 loops, best of 3: 6.8 µs per loop
sage: C=Compositions()
sage: timeit("C([1,2,3,4])",number=100000)
100000 loops, best of 3: 4.64 µs per loop
```

so perhaps the best solution is indeed to deprecate `Composition` as an entry in the global namespace?

Note that the reported behaviour in the ticket still needs fixing. The currently attached patch doesn't solve the problem below. I expect that the fix has to go into the `__init__` rather than into the `classcall_private`.

```
sage: Compositions()('ASDF')
['A', 'S', 'D', 'F']
sage: Compositions()('ASDF').parent()
Compositions of non-negative integers
```



---

Comment by darij created at 2013-10-22 03:24:23

Replying to [comment:19 nbruin]:
> {{{
> sage: timeit("Composition([1,2,3,4])",number=100000)
> 100000 loops, best of 3: 8.01 µs per loop
> sage: timeit("Compositions()([1,2,3,4])",number=100000)
> 100000 loops, best of 3: 6.8 µs per loop
> sage: C=Compositions()
> sage: timeit("C([1,2,3,4])",number=100000)
> 100000 loops, best of 3: 4.64 µs per loop
> }}}

Convincing. Thank you!!


---

Comment by chapoton created at 2013-10-22 08:42:17

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2013-10-22 08:42:17

OMG ! So many failing doctests ! It seems that we should allow 0 in the compositions..


---

Attachment

new version of the patch, allowing nonnegative (>=0) integers as inputs


---

Comment by darij created at 2013-11-04 23:02:21

Hmm; what exactly fails if you disallow 0? It looks like just requiring >= 0 kicks the can down the road, and that with a speed penalty that is noticeable when the composition is large and might become problematic in NSym/QSym-related code:


```
%timeit Composition([3,2,1])
%timeit a = Composition([2,1,6,2,2,6,1,3,2,2,3,5,2])
%timeit Composition([])

before

sage: %timeit Composition([3,2,1])
100000 loops, best of 3: 13.9 us per loop
sage: %timeit a = Composition([2,1,6,2,2,6,1,3,2,2,3,5,2])
100000 loops, best of 3: 15.8 us per loop
sage: %timeit Composition([])
100000 loops, best of 3: 12.1 us per loop

after

sage: %timeit Composition([3,2,1])
100000 loops, best of 3: 16 us per loop
sage: %timeit a = Composition([2,1,6,2,2,6,1,3,2,2,3,5,2])
10000 loops, best of 3: 21.4 us per loop
sage: %timeit Composition([])
100000 loops, best of 3: 12.8 us per loop
```



---

Comment by chapoton created at 2013-11-05 08:25:22

Well, have a look at the patchbot report here, for the version forbidding the zeroes:

http://patchbot.sagemath.org/log/14862/Fedora/19/x86_64/3.11.2-201.fc19.x86_64/desktop/2013-10-22%2008:49:29%20+0100?short

It involves *many* different failures, apparently.


---

Comment by darij created at 2013-11-05 16:37:27

Ouch! Thanks for finding these things. The very idea that weights of tableaux should be compositions isn't particularly literate (and it seems to account for most of the failures). I see two ways to fix this:

* Add a `WeakCompositions` class that checks for nonnegativity (rather than positivity) and only removes trailing zeroes on uniformization. (A weak composition is a finitely supported infinite sequence of nonnegative integers.)

* Let the weight just be an iterable, with checks being done in `__classcall__`

I'd much prefer to have this decided before the tableau rewrite...


---

Comment by tscrim created at 2013-11-05 23:39:04

The weak compositions are suppose to be `IntegerVectors`, but as I recall, there is abuse of `Composition` as I believe those failing doctests imply.

Also I'm not against adding checks to `Composition`, but I do not want to change the name (including `Partition`).


---

Comment by andrew.mathas created at 2013-11-06 07:25:47

Replying to [comment:25 darij]:
> Ouch! Thanks for finding these things. The very idea that weights of tableaux should be compositions isn't particularly literate (and it seems to account for most of the failures). I see two ways to fix this:
> 
> * Add a `WeakCompositions` class that checks for nonnegativity (rather than positivity) and only removes trailing zeroes on uniformization. (A weak composition is a finitely supported infinite sequence of nonnegative integers.)
> 
> * Let the weight just be an iterable, with checks being done in `__classcall__`
> 
> I'd much prefer to have this decided before the tableau rewrite...

I'm not sure what is slated for the tableaux rewrite (is this just the plan to move over to ClonableIntArray?), but from a representation theoretic perspective we should definitely allow the parts of compositions to be zero.


---

Comment by chapoton created at 2014-01-09 19:51:01

New commits:


---

Comment by git created at 2014-06-02 19:59:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-23 09:49:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2015-05-26 09:47:54

Shouldn't we have a "check=True" flag on the constructor? I'd be happier if the checking could be avoided.
