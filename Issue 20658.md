# Issue 20658: Computing ordinary models of plane curves

archive/issues_020658.json:
```json
{
    "body": "CC:  bhutz mmarco\n\nKeywords: gsoc2016\n\nGiven a plane curve, it is possible to transform it into a plane curve with only ordinary singularities via application of a finite sequence of quadratic transformation maps.\n\nImplement a function at the curve class level to apply the standard quadratic transformation (the birational automorphism of `P2` sending `(x : y : z)` to `(yz : xz : xy)`) and a function to transform a given plane curve into one with only ordinary singularities.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20895\n\n",
    "created_at": "2016-06-28T07:37:02Z",
    "labels": [
        "algebraic geometry",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.4",
    "title": "Computing ordinary models of plane curves",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20658",
    "user": "gjorgenson"
}
```
CC:  bhutz mmarco

Keywords: gsoc2016

Given a plane curve, it is possible to transform it into a plane curve with only ordinary singularities via application of a finite sequence of quadratic transformation maps.

Implement a function at the curve class level to apply the standard quadratic transformation (the birational automorphism of `P2` sending `(x : y : z)` to `(yz : xz : xy)`) and a function to transform a given plane curve into one with only ordinary singularities.

Issue created by migration from https://trac.sagemath.org/ticket/20895





---

archive/issue_comments_285267.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-05T08:13:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285267",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_285268.json:
```json
{
    "body": "Okay, here's my first attempt at the implementation. I improved the affine tangents function to work with QQbar, and added some helper functions to apply the standard Cremona transformation, find the equation of the line between two projective plane points, and to move a curve into excellent position as defined in Fulton's alg. curves book. I haven't yet been able to find a good way to mitigate the dependency on QQbar, so right now I just restrict to QQbar curves entirely. Moving curves to excellent position seems to take > 2 seconds even for basic curves and quickly becomes impractical for more complicated curves. The new functionality does seem to be working correctly on the basic examples I've tested though.\n\nDo you think it's possible to reduce the dependency on QQbar computations?",
    "created_at": "2016-07-05T08:54:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285268",
    "user": "gjorgenson"
}
```

Okay, here's my first attempt at the implementation. I improved the affine tangents function to work with QQbar, and added some helper functions to apply the standard Cremona transformation, find the equation of the line between two projective plane points, and to move a curve into excellent position as defined in Fulton's alg. curves book. I haven't yet been able to find a good way to mitigate the dependency on QQbar, so right now I just restrict to QQbar curves entirely. Moving curves to excellent position seems to take > 2 seconds even for basic curves and quickly becomes impractical for more complicated curves. The new functionality does seem to be working correctly on the basic examples I've tested though.

Do you think it's possible to reduce the dependency on QQbar computations?



---

archive/issue_comments_285269.json:
```json
{
    "body": "Take a look at the `.as_number_field_element()` method of algebraic numbers, and the `number_field_elements_from_algebraics`function. They allow you to get a number field to embed your numbers. So you can proceed this way: use QQbar just to compute the roots you need. Once done that, find a number field where everything you need may fit (that is, it should be an extension of your current field that contains the needed elements), and extend your base ring. From there, you can keep working in a concrete number field which should be much faster than QQbar.",
    "created_at": "2016-07-05T12:11:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285269",
    "user": "mmarco"
}
```

Take a look at the `.as_number_field_element()` method of algebraic numbers, and the `number_field_elements_from_algebraics`function. They allow you to get a number field to embed your numbers. So you can proceed this way: use QQbar just to compute the roots you need. Once done that, find a number field where everything you need may fit (that is, it should be an extension of your current field that contains the needed elements), and extend your base ring. From there, you can keep working in a concrete number field which should be much faster than QQbar.



---

archive/issue_comments_285270.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-07T07:22:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285270",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_285271.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-08T00:29:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285271",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_285272.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-08T06:28:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285272",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_285273.json:
```json
{
    "body": "Alright, I experimented with embedding into numberfields, but after doing some timing analysis, I found that the biggest use of time was finding intersection points of a given curve with the lines used to create a change of coordinates map to move the curve into excellent position. I tried revising the excellent_position and ordinary_model functions in the first of the last three commits to reduce the costs of these computations, but they still used a lot of time even for simple examples.\n\nIn the last two commits I tried a different approach and gave the excellent_position function an option to accept a list/tuple of three points to use to create the transformation (without checks), and modified the ordinary model function so that it now creates lists of vertices incrementally without explicitly checking that they put the curve into excellent position and passes them to excellent_position. To verify that the nonordinary singularities do become resolved, I'm using that after every application of excellent_position + quadratic_transformation, if the given curve was actually put into excellent position, the resulting curve should either have a smaller apparent genus (arithmetic genus - sum m*(m-1)/2 as m runs over the curve's singular point multiplicities), or should have fewer nonordinary singularities. This gives an upper bound for the number of applications of excellent_position + quadratic_transformation needed to resolve the nonordinary singularities, and so if the nonordinary singularities are not resolved after this number of transformations, a new set of vertices is used.\n\nSo far this seems to work pretty quickly for curves of degree < 5, but is somewhat hit-or-miss for higher degree curves. The transformed curves can also have high degrees when multiple transformations are needed to resolve all of the nonordinary singularities, and sometimes don't seem very practically useful. I think the code is a bit too much of a mess right now for this to be ready for review, but does the method of implementation seem okay so far? Do you think there's a way I can make the transformations nicer?",
    "created_at": "2016-07-08T07:23:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285273",
    "user": "gjorgenson"
}
```

Alright, I experimented with embedding into numberfields, but after doing some timing analysis, I found that the biggest use of time was finding intersection points of a given curve with the lines used to create a change of coordinates map to move the curve into excellent position. I tried revising the excellent_position and ordinary_model functions in the first of the last three commits to reduce the costs of these computations, but they still used a lot of time even for simple examples.

In the last two commits I tried a different approach and gave the excellent_position function an option to accept a list/tuple of three points to use to create the transformation (without checks), and modified the ordinary model function so that it now creates lists of vertices incrementally without explicitly checking that they put the curve into excellent position and passes them to excellent_position. To verify that the nonordinary singularities do become resolved, I'm using that after every application of excellent_position + quadratic_transformation, if the given curve was actually put into excellent position, the resulting curve should either have a smaller apparent genus (arithmetic genus - sum m*(m-1)/2 as m runs over the curve's singular point multiplicities), or should have fewer nonordinary singularities. This gives an upper bound for the number of applications of excellent_position + quadratic_transformation needed to resolve the nonordinary singularities, and so if the nonordinary singularities are not resolved after this number of transformations, a new set of vertices is used.

So far this seems to work pretty quickly for curves of degree < 5, but is somewhat hit-or-miss for higher degree curves. The transformed curves can also have high degrees when multiple transformations are needed to resolve all of the nonordinary singularities, and sometimes don't seem very practically useful. I think the code is a bit too much of a mess right now for this to be ready for review, but does the method of implementation seem okay so far? Do you think there's a way I can make the transformations nicer?



---

archive/issue_comments_285274.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-07-17T09:01:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285274",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_285275.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-07-17T20:45:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285275",
    "user": "gjorgenson"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_285276.json:
```json
{
    "body": "I implemented a new approach for excellent_position that no longer requires computing intersection points and works for number fields. I think the computations are faster now and I revised ordinary_model to leave the checks to excellent_position. ordinary_model works for number fields as well by returning a curve defined over an extension if any of the coordinates of the non-ordinary singularities are not contained in the original base field.\n\nI also cleaned up the code and removed unnecessary changes that were implemented in previous commits, such as the line function for projective space.",
    "created_at": "2016-07-17T20:45:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285276",
    "user": "gjorgenson"
}
```

I implemented a new approach for excellent_position that no longer requires computing intersection points and works for number fields. I think the computations are faster now and I revised ordinary_model to leave the checks to excellent_position. ordinary_model works for number fields as well by returning a curve defined over an extension if any of the coordinates of the non-ordinary singularities are not contained in the original base field.

I also cleaned up the code and removed unnecessary changes that were implemented in previous commits, such as the line function for projective space.



---

archive/issue_comments_285277.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-20T09:17:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285277",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_285278.json:
```json
{
    "body": "I made some improvements to the functionality here and I think this should be ready for review.\n\nChanges made in this ticket up to this point have been to add an ordinary_model function along with two helper functions, quadratic_transform and excellent_position, to the projective plane curve class. The is_ordinary_singularity and tangents functions for affine curves were also modified to reduce the need for QQbar computations.\n\nOverall the ordinary_model function appears to be working properly, but still becomes very slow for most curves of degree > 5. I think this slowdown is mainly due to the rate at which the degrees of the quadratic transforms of the curves can grow.",
    "created_at": "2016-08-20T09:44:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285278",
    "user": "gjorgenson"
}
```

I made some improvements to the functionality here and I think this should be ready for review.

Changes made in this ticket up to this point have been to add an ordinary_model function along with two helper functions, quadratic_transform and excellent_position, to the projective plane curve class. The is_ordinary_singularity and tangents functions for affine curves were also modified to reduce the need for QQbar computations.

Overall the ordinary_model function appears to be working properly, but still becomes very slow for most curves of degree > 5. I think this slowdown is mainly due to the rate at which the degrees of the quadratic transforms of the curves can grow.



---

archive/issue_comments_285279.json:
```json
{
    "body": "I did not find any functionality issues, but here are some comments\n\n- in affine_curve.py is there a reason you have \n\n```\nfrom sage.arith.misc import binomial\n```\n\nin the function and not with the rest of the imports\n\n- in affine tangents()\n\n\n```\nt = T.degree(vars[0])\nfor monom in T.monomials():\n    if monom.degree(vars[0]) < t:\n        t = monom.degree(vars[0]\n```\n\nseems to just be doing\n\n```\nmin([e1 for e1,e2 in T.exponents()])\n```\n\nis that right? If so, you can simplify both instances.\n\n- in is_ord : projective\n\n\n```\nC = self.affine_patch(i)\nQ = list(P)\nt = Q.pop(i)\nQ = [1/t*Q[j] for j in range(self.ambient_space().dimension_relative())]\n```\n\n\nYou can just say\n\n```\nC(Q.dehomogenize(i))\n```\n\nto get the affine point\n\n- in excellent position: projective\n\n\n```\nd = self.defining_polynomial().degree()\n```\n\nis there no C.degree() function for plane curves??\n\n\n```\nif all([g.degree(PP.gens()[0]) > 0 for g in T.monomials()]):\n```\n\nseems simpler as\n\n```\nif all([e[0] > 0 for e in T.exponents()]):\n```\n\n\nalso this function fails over QQbar since .divides() does not work. You should either fix that or specify in the documentation that you need a number field\n\n- in def ordinary_model(self):\n\n\n```\nReturn an ordinary plane curve model of this curve.\n```\n\nActually you are returning the morphism from the curve to an ordinary model. You should either match the description of excellent position or return the curve and add a return_mapping parameter. Either way, I think both functions should do the same thing.\n\nI'd also like an example to show that all singularities are now ordinary.\n\n```\n[C.is_ordinary_singularity(Q) for Q in C.singular_points()]\n```\n\n\nin extension()\n\nnot sure why you are doing this:\n\n```\n# make sure the defining polynomial variable names are the same for K, N\nN = NumberField(K.defining_polynomial().parent()(F.defining_polynomial()), str(K.gen()))\n```\n\nbecause\n\n```\nsage: K.<v>=QuadraticField(2)\nsage: N = NumberField(K.defining_polynomial().parent()(x^3+2), str(K.gen()))\nsage: N.gen()==K.gen()\nFalse\n```\n",
    "created_at": "2016-08-25T14:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285279",
    "user": "bhutz"
}
```

I did not find any functionality issues, but here are some comments

- in affine_curve.py is there a reason you have 

```
from sage.arith.misc import binomial
```

in the function and not with the rest of the imports

- in affine tangents()


```
t = T.degree(vars[0])
for monom in T.monomials():
    if monom.degree(vars[0]) < t:
        t = monom.degree(vars[0]
```

seems to just be doing

```
min([e1 for e1,e2 in T.exponents()])
```

is that right? If so, you can simplify both instances.

- in is_ord : projective


```
C = self.affine_patch(i)
Q = list(P)
t = Q.pop(i)
Q = [1/t*Q[j] for j in range(self.ambient_space().dimension_relative())]
```


You can just say

```
C(Q.dehomogenize(i))
```

to get the affine point

- in excellent position: projective


```
d = self.defining_polynomial().degree()
```

is there no C.degree() function for plane curves??


```
if all([g.degree(PP.gens()[0]) > 0 for g in T.monomials()]):
```

seems simpler as

```
if all([e[0] > 0 for e in T.exponents()]):
```


also this function fails over QQbar since .divides() does not work. You should either fix that or specify in the documentation that you need a number field

- in def ordinary_model(self):


```
Return an ordinary plane curve model of this curve.
```

Actually you are returning the morphism from the curve to an ordinary model. You should either match the description of excellent position or return the curve and add a return_mapping parameter. Either way, I think both functions should do the same thing.

I'd also like an example to show that all singularities are now ordinary.

```
[C.is_ordinary_singularity(Q) for Q in C.singular_points()]
```


in extension()

not sure why you are doing this:

```
# make sure the defining polynomial variable names are the same for K, N
N = NumberField(K.defining_polynomial().parent()(F.defining_polynomial()), str(K.gen()))
```

because

```
sage: K.<v>=QuadraticField(2)
sage: N = NumberField(K.defining_polynomial().parent()(x^3+2), str(K.gen()))
sage: N.gen()==K.gen()
False
```




---

archive/issue_comments_285280.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-08-25T14:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285280",
    "user": "bhutz"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_285281.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2016-08-30T08:32:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285281",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_285282.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-08-30T09:43:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285282",
    "user": "gjorgenson"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_285283.json:
```json
{
    "body": "Thanks for reviewing this. I was a bit busy with preparing for the semester and wasn't able to finish working on the next update until now.\n\nI made the suggested changes and also merged this with ticket 20790 (has been closed) to fix a conflict with the imports. The projective subscheme multiplicity and intersection_multiplicity functions now use the point dehomogenize function as well for cleaner code. I also added a degree function override for projective plane curves which just returns the degree of the defining polynomial of the curve to avoid using the slower Hilbert polynomial computation. \n\nIn\n\n`N = NumberField(K.defining_polynomial().parent()(F.defining_polynomial()), str(K.gen()))`\n\nI don't think `str(K.gen())` is needed and can be replaced with an arbitrary variable name, but the reason I am using `K.defining_polynomial().parent()(F.defining_polynomial())` is to make the defining polynomials of `N` and `K` have the same variable name. If the names are different the composite_fields function raises an error:\n\n\n```\nR.<x> = QQ[]\nS.<y> = QQ[]\nN.<a> = NumberField(x^2 + 1)\nM.<b> = NumberField(y^2 - 7)\nN.composite_fields(M)\nTraceback (click to the left of this block for traceback)\n...\nsage.libs.pari.handle_error.PariError: inconsistent variables in\npolcompositum, x != y\n```\n",
    "created_at": "2016-08-30T09:43:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285283",
    "user": "gjorgenson"
}
```

Thanks for reviewing this. I was a bit busy with preparing for the semester and wasn't able to finish working on the next update until now.

I made the suggested changes and also merged this with ticket 20790 (has been closed) to fix a conflict with the imports. The projective subscheme multiplicity and intersection_multiplicity functions now use the point dehomogenize function as well for cleaner code. I also added a degree function override for projective plane curves which just returns the degree of the defining polynomial of the curve to avoid using the slower Hilbert polynomial computation. 

In

`N = NumberField(K.defining_polynomial().parent()(F.defining_polynomial()), str(K.gen()))`

I don't think `str(K.gen())` is needed and can be replaced with an arbitrary variable name, but the reason I am using `K.defining_polynomial().parent()(F.defining_polynomial())` is to make the defining polynomials of `N` and `K` have the same variable name. If the names are different the composite_fields function raises an error:


```
R.<x> = QQ[]
S.<y> = QQ[]
N.<a> = NumberField(x^2 + 1)
M.<b> = NumberField(y^2 - 7)
N.composite_fields(M)
Traceback (click to the left of this block for traceback)
...
sage.libs.pari.handle_error.PariError: inconsistent variables in
polcompositum, x != y
```




---

archive/issue_comments_285284.json:
```json
{
    "body": "The updates look fine to me and all tests still pass.",
    "created_at": "2016-09-07T19:50:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285284",
    "user": "bhutz"
}
```

The updates look fine to me and all tests still pass.



---

archive/issue_comments_285285.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-09-07T19:50:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285285",
    "user": "bhutz"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_285286.json:
```json
{
    "body": "OUPUT ?",
    "created_at": "2016-09-09T18:10:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285286",
    "user": "chapoton"
}
```

OUPUT ?



---

archive/issue_comments_285287.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-09-10T09:00:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20658",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20658#issuecomment-285287",
    "user": "vbraun"
}
```

Resolution: fixed
