# Issue 172: memory leak in pyrex

Issue created by migration from Trac.

Original creator: was

Original creation time: 2006-11-30 17:12:59

Assignee: was


```
On Thu, 30 Nov 2006 08:49:48 -0800, Igor Khavkine <igor.kh`@`gmail.com> wrote:

> I've recently run into the following bug in Pyrex's code generation.
> Consider the following .pyx file:
>
> ---- bug.pyx ----
> cdef class T:
> 	cdef int i
> 	cdef int j
> 	cdef int a[1]
>
> cdef void leak (void *obj):
> 	cdef T t
> 	(<T> obj).j = 1
> 	(<T> obj).i = (<T> obj).i + 1
> 	(<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
> 	t = <T> obj
> 	t.a[0] = t.a[0] + 1
> -----------------
>
> The C code generated by Pyrex 0.9.3 lacks a Py_DECREF at the place of
> the indicated line. Thus, every time the function leak() is run, the
> object pointed to by obj gets an extra reference count. All the other
> lines in leak() produce correct code.
>
> Funny enough, the only way I noticed this bug when the reference counter
> on one of my objects overflowed and became negative, which caused some
> mysterious deallocations to take place when the garbage collector was
> invoked.
>
> This bug sounds similar in spirit to the one reported by Jonathan Doda,
> which is marked fixed in the 0.9.4 release notes. However, I have not
> tested with that version and am not sure whether that fix also applies
> to this bug.

I just tested your example with what I think is the latest version
of Pyrex with all patches I know of applied, and the bug is definitely
still there.  You can actually try it all out interactively on this web
page:   http://modular.math.washington.edu:8101/leak

William
```



 == leak ==




```
%pyrex

cdef extern from "Python.h":
   void Py_DECREF(PyObject* o)

cdef class T:
    cdef int i
    cdef int j
    cdef int a[10000]
 
cdef void leak (void *obj, int decref):
    cdef T t
    (<T> obj).j = 1
    (<T> obj).i = (<T> obj).i + 1
    (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
    if decref:
        Py_DECREF(<PyObject*>obj)
    t = <T> obj
    t.a[0] = t.a[0] + 1

def test(int n, int decref):
    cdef int i
    cdef T t
    for i from 0 <= i < n:
       t = T()
       leak(<void*> t, decref)
```



```
get_memory_usage()
///
355.19921875
```



```
test(1000,0)
```



```
get_memory_usage()
///
393.40625
```



```
test(1000,1)
```



```
get_memory_usage()
///
393.40625
```



```

```



---

Comment by was created at 2006-12-01 00:33:47


```
Greg Ewing does not consider this a bug.  I still do.

Igor Khavkine wrote:
 
> cdef void leak (void *obj):
> 	cdef T t
> 	(<T> obj).j = 1
> 	(<T> obj).i = (<T> obj).i + 1
> 	(<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
> 	t = <T> obj
> 	t.a[0] = t.a[0] + 1
 
Is there any reason you couldn't write this as
 
   cdef void leak (T obj):
     obj.j = 1
     obj.i = obj.i + 1
     obj.a[0] = obj.a[0] + 1
 
The reference counting behaviour of typecasts involving
object references is not well defined, and you do it at
your own risk. It's much better to declare things as
having the appropriate type wherever possible.
 
If you really must use a typecast, it's safest to just
do one of them and put the result into an appropriately
typed local as soon as possible, e.g.
 
   cdef void leak (void *obj):
     cdef T t
     t = <T>obj
     t.j = 1
     t.i = t.i + 1
     t.a[0] = t.a[0] + 1
 
--
Greg
 
```



---

Comment by was created at 2006-12-01 01:12:41


```
On 11/30/06, Greg Ewing <greg.ewing`@`canterbury.ac.nz> wrote:
> Igor Khavkine wrote:
>  
> > cdef void leak (void *obj):
> >       cdef T t
> >       (<T> obj).j = 1
> >       (<T> obj).i = (<T> obj).i + 1
> >       (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
> >       t = <T> obj
> >       t.a[0] = t.a[0] + 1
>  
> Is there any reason you couldn't write this as
>  
>    cdef void leak (T obj):
>      obj.j = 1
>      obj.i = obj.i + 1
>      obj.a[0] = obj.a[0] + 1
 
The only reason (albeit not an insurmountable one) is that leak()
would be called from C code and have its argument as an opaque object
handle (void *).
 
> If you really must use a typecast, it's safest to just
> do one of them and put the result into an appropriately
> typed local as soon as possible, e.g.
>  
>    cdef void leak (void *obj):
>      cdef T t
>      t = <T>obj
>      t.j = 1
>      t.i = t.i + 1
>      t.a[0] = t.a[0] + 1
 
That's the solution that I've already adopted. And I've already
checked that the code generated from the last two lines of my example
is correct.
 
> The reference counting behaviour of typecasts involving
> object references is not well defined, and you do it at
> your own risk.
 
That's somewhat misleading. Each line in my example, except the
indicated one, produces correct code. I think anyone, who's seen that
the first two assignments in leak() work properly, would expect the
third one to work as well. That's why it's a bug.
 
Igor
```



---

Comment by was created at 2007-01-13 02:38:44

Changing type from defect to enhancement.


---

Comment by was created at 2007-01-13 02:38:44

This is pretty weird and subtle...  Change to enhancement...


---

Comment by malb created at 2008-08-23 23:16:15

This is fixed by Cython:

```
sage: get_memory_usage()
664.1328125
sage: test(1000,0)
sage: get_memory_usage()
664.1328125
```

I'm voting for *invalid*.


---

Comment by mabshoff created at 2008-08-24 17:07:46

Resolution: invalid


---

Comment by mabshoff created at 2008-08-24 17:07:46

Yes, invalid it is.

Cheers,

Michael
