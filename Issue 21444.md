# Issue 21444: Metaclass framework

archive/issues_021444.json:
```json
{
    "body": "Keywords: metaclass dynamic\n\nCurrently, SageMath hardcodes the metaclasses DynamicMetaclass, DynamicClasscallMetaclass, DynamicInheritComparisonMetaclass, DynamicInheritComparisonClasscallMetaclass, NestedClassMetaclass, InheritComparisonMetaclass, and InheritComparisonClasscallMetaclass. \n\nApparently, they are all based on few single-purpose metaclasses (DynamicMetaclass, InheritComparisonMetaclass, NestedClassMetaclass and ClasscallMetaclass), and the hardcoded combinations exist because Python doesn't allow much freedom when providing different metaclasses in the bases of a class definition. And apparently several combinations are missing.\n\nThe purpose of this ticket is to allow for an automatic creation of combined metaclasses, so that only the single-purpose metaclasses need to be implemented, and all other metaclasses will be created dynamically.\n\nThe approach is by introducing a meta-metaclass SageMetaclass --- i.e., any metaclass in Sage is *instance* of SageMetaclass.\n\nIssue created by migration from https://trac.sagemath.org/ticket/21681\n\n",
    "created_at": "2016-10-11T13:41:09Z",
    "labels": [
        "component: refactoring"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "Metaclass framework",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21444",
    "user": "https://github.com/simon-king-jena"
}
```
Keywords: metaclass dynamic

Currently, SageMath hardcodes the metaclasses DynamicMetaclass, DynamicClasscallMetaclass, DynamicInheritComparisonMetaclass, DynamicInheritComparisonClasscallMetaclass, NestedClassMetaclass, InheritComparisonMetaclass, and InheritComparisonClasscallMetaclass. 

Apparently, they are all based on few single-purpose metaclasses (DynamicMetaclass, InheritComparisonMetaclass, NestedClassMetaclass and ClasscallMetaclass), and the hardcoded combinations exist because Python doesn't allow much freedom when providing different metaclasses in the bases of a class definition. And apparently several combinations are missing.

The purpose of this ticket is to allow for an automatic creation of combined metaclasses, so that only the single-purpose metaclasses need to be implemented, and all other metaclasses will be created dynamically.

The approach is by introducing a meta-metaclass SageMetaclass --- i.e., any metaclass in Sage is *instance* of SageMetaclass.

Issue created by migration from https://trac.sagemath.org/ticket/21681





---

archive/issue_comments_297282.json:
```json
{
    "body": "The branch is just `sage-7.4.rc0` without any extra commits... was this intentional?\n\nAs explained on the `sage-devel` post, I am curious to see if you can make this work on Python 3.",
    "created_at": "2016-10-11T15:04:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297282",
    "user": "https://github.com/jdemeyer"
}
```

The branch is just `sage-7.4.rc0` without any extra commits... was this intentional?

As explained on the `sage-devel` post, I am curious to see if you can make this work on Python 3.



---

archive/issue_comments_297283.json:
```json
{
    "body": "Replying to [comment:2 jdemeyer]:\n> The branch is just `sage-7.4.rc0` without any extra commits... was this intentional?\n\nYes.\n \n> As explained on the `sage-devel` post, I am curious to see if you can make this work on Python 3.\n\nI am confident that it would work on Python 3, of course with the modified syntax\n\n```\nclass Foo(metaclass=Bar):\n    ...\n```\n\ninstead of\n\n```\nclass Foo:\n   __metaclass__ = Bar\n```\n",
    "created_at": "2016-10-11T15:12:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297283",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:2 jdemeyer]:
> The branch is just `sage-7.4.rc0` without any extra commits... was this intentional?

Yes.
 
> As explained on the `sage-devel` post, I am curious to see if you can make this work on Python 3.

I am confident that it would work on Python 3, of course with the modified syntax

```
class Foo(metaclass=Bar):
    ...
```

instead of

```
class Foo:
   __metaclass__ = Bar
```




---

archive/issue_comments_297284.json:
```json
{
    "body": "Replying to [comment:3 SimonKing]:\n> I am confident that it would work on Python 3\n\nI am very interested to see how you would do this!",
    "created_at": "2016-10-11T15:24:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297284",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:3 SimonKing]:
> I am confident that it would work on Python 3

I am very interested to see how you would do this!



---

archive/issue_comments_297285.json:
```json
{
    "body": "Replying to [comment:4 jdemeyer]:\n> I am very interested to see how you would do this!\n\nThe idea is: \"metaclass used in Sage\" should be synonymous to \"instance (not sub-class!) of SageMetaclass\" (hence, SageMetaclass is a metametaclass and is itself a subclass of type).\n\nSageMetaclass defines a `__call__` method for its instances (thus overriding `type.__call__`). When such instance is used as a metaclass when defining a class, then the metaclass' `__call__` method inspects the bases of the to-be-created class and dynamically creates (if necessary) a common sub-class of the metaclasses of the bases. Eventually, the class is created as an instance of the common (dynamic) metaclass. And python will be happy, because the metaclass of the new class is a sub-class of the metaclasses of the given bases.\n\nBoth in Python 2 and in Python 3, the metaclass is called during creation of a class (which is where all magic happens). That's why I think it should work on Python 3 as well.",
    "created_at": "2016-10-11T15:46:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297285",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:4 jdemeyer]:
> I am very interested to see how you would do this!

The idea is: "metaclass used in Sage" should be synonymous to "instance (not sub-class!) of SageMetaclass" (hence, SageMetaclass is a metametaclass and is itself a subclass of type).

SageMetaclass defines a `__call__` method for its instances (thus overriding `type.__call__`). When such instance is used as a metaclass when defining a class, then the metaclass' `__call__` method inspects the bases of the to-be-created class and dynamically creates (if necessary) a common sub-class of the metaclasses of the bases. Eventually, the class is created as an instance of the common (dynamic) metaclass. And python will be happy, because the metaclass of the new class is a sub-class of the metaclasses of the given bases.

Both in Python 2 and in Python 3, the metaclass is called during creation of a class (which is where all magic happens). That's why I think it should work on Python 3 as well.



---

archive/issue_comments_297286.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-10-12T14:53:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297286",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_297287.json:
```json
{
    "body": "One comment: since this isn't really Sage-specific, could you use a different name instead of `SageMetaclass`, something which does not refer to Sage?",
    "created_at": "2016-10-12T15:02:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297287",
    "user": "https://github.com/jdemeyer"
}
```

One comment: since this isn't really Sage-specific, could you use a different name instead of `SageMetaclass`, something which does not refer to Sage?



---

archive/issue_comments_297288.json:
```json
{
    "body": "I have pushed a proof of concept. The following works:\n\n```\nsage: from sage.structure.metaclass.metaclass import MyNestedClass, MyUniqueRepresentation\nsage: class MyCombinedExample(MyNestedClass, MyUniqueRepresentation):\n....:     pass\n....: \nsage: C = MyCombinedExample(4,5)\nsage: C is MyCombinedExample(4,5)\nTrue\nsage: C is MyCombinedExample(5,5)\nFalse\nsage: C.Test() is C.Test()\nTrue\nsage: loads(dumps(C)) is C\nTrue\n```\n\n\nThe metaclasses of the base classes MyNestedClass and MyUniqueRepresentation in the above class definition are incompatible:\n\n```\nsage: type(MyUniqueRepresentation).__mro__\n(<class 'sage.structure.metaclass.metaclass.ClasscallMetaclass'>,\n <type 'type'>,\n <type 'object'>)\nsage: type(MyNestedClass).__mro__\n(<class 'sage.structure.metaclass.metaclass.NestedClassMetaclass'>,\n <type 'type'>,\n <type 'object'>)\n```\n\nNonetheless, it just works. In fact, the resulting class is instance of a metaclass that is created on the fly:\n\n```\nsage: type(C)\n<class '__main__.MyCombinedExample'>\nsage: type(type(C))\n<class '__main__.ClasscallNestedClassMetaclass'>\nsage: type(type(type(C)))\n<class 'sage.structure.metaclass.metaclass.DynamicSageMetaclass'>\n```\n\n\nSlightly strange for me is this: The metaclass that actually appears in the definition of `ClasscallMetaclass` and `NestedClassMetaclass` is not the class `SageMetaclass` but the function `sage_metaclass` --- from the patch:\n\n```\nfrom sage.misc.nested_class import nested_pickle\nclass NestedClassMetaclass:\n    __metaclass__ = sage_metaclass\n    def __init__(cls, name, bases, namespace):\n        nested_pickle(cls)\n```\n\n\nIf I replace `sage_metaclass` by `SageMetaclass` then the example stops working, which is something I don't fully understand. Unless Python 3 disallows to use a function as `__metaclass__`, there is hope that it would work with Python 3 as well.",
    "created_at": "2016-10-12T15:03:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297288",
    "user": "https://github.com/simon-king-jena"
}
```

I have pushed a proof of concept. The following works:

```
sage: from sage.structure.metaclass.metaclass import MyNestedClass, MyUniqueRepresentation
sage: class MyCombinedExample(MyNestedClass, MyUniqueRepresentation):
....:     pass
....: 
sage: C = MyCombinedExample(4,5)
sage: C is MyCombinedExample(4,5)
True
sage: C is MyCombinedExample(5,5)
False
sage: C.Test() is C.Test()
True
sage: loads(dumps(C)) is C
True
```


The metaclasses of the base classes MyNestedClass and MyUniqueRepresentation in the above class definition are incompatible:

```
sage: type(MyUniqueRepresentation).__mro__
(<class 'sage.structure.metaclass.metaclass.ClasscallMetaclass'>,
 <type 'type'>,
 <type 'object'>)
sage: type(MyNestedClass).__mro__
(<class 'sage.structure.metaclass.metaclass.NestedClassMetaclass'>,
 <type 'type'>,
 <type 'object'>)
```

Nonetheless, it just works. In fact, the resulting class is instance of a metaclass that is created on the fly:

```
sage: type(C)
<class '__main__.MyCombinedExample'>
sage: type(type(C))
<class '__main__.ClasscallNestedClassMetaclass'>
sage: type(type(type(C)))
<class 'sage.structure.metaclass.metaclass.DynamicSageMetaclass'>
```


Slightly strange for me is this: The metaclass that actually appears in the definition of `ClasscallMetaclass` and `NestedClassMetaclass` is not the class `SageMetaclass` but the function `sage_metaclass` --- from the patch:

```
from sage.misc.nested_class import nested_pickle
class NestedClassMetaclass:
    __metaclass__ = sage_metaclass
    def __init__(cls, name, bases, namespace):
        nested_pickle(cls)
```


If I replace `sage_metaclass` by `SageMetaclass` then the example stops working, which is something I don't fully understand. Unless Python 3 disallows to use a function as `__metaclass__`, there is hope that it would work with Python 3 as well.



---

archive/issue_comments_297289.json:
```json
{
    "body": "Replying to [comment:7 jdemeyer]:\n> One comment: since this isn't really Sage-specific, could you use a different name instead of `SageMetaclass`, something which does not refer to Sage?\n\nSure, so far it is just a proof of concept.\n\nWould you agree with `MetaMetaclass` and (for the function that actually appears in the metaclass definitions) `meta_metaclass`? Or maybe just `Metaclass` and `metaclass`.",
    "created_at": "2016-10-12T15:04:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297289",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:7 jdemeyer]:
> One comment: since this isn't really Sage-specific, could you use a different name instead of `SageMetaclass`, something which does not refer to Sage?

Sure, so far it is just a proof of concept.

Would you agree with `MetaMetaclass` and (for the function that actually appears in the metaclass definitions) `meta_metaclass`? Or maybe just `Metaclass` and `metaclass`.



---

archive/issue_comments_297290.json:
```json
{
    "body": "Replying to [comment:9 SimonKing]:\n> Would you agree with `MetaMetaclass` and (for the function that actually appears in the metaclass definitions) `meta_metaclass`? Or maybe just `Metaclass` and `metaclass`.\n\nWhat about `AutoMetaclass` to refer to the *automatic* creation of combined metaclasses?",
    "created_at": "2016-10-12T15:31:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297290",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:9 SimonKing]:
> Would you agree with `MetaMetaclass` and (for the function that actually appears in the metaclass definitions) `meta_metaclass`? Or maybe just `Metaclass` and `metaclass`.

What about `AutoMetaclass` to refer to the *automatic* creation of combined metaclasses?



---

archive/issue_comments_297291.json:
```json
{
    "body": "Replying to [comment:10 jdemeyer]:\n> Replying to [comment:9 SimonKing]:\n> > Would you agree with `MetaMetaclass` and (for the function that actually appears in the metaclass definitions) `meta_metaclass`? Or maybe just `Metaclass` and `metaclass`.\n> \n> What about `AutoMetaclass` to refer to the *automatic* creation of combined metaclasses?\n\nThere are two things in the code: `SageMetaclass`, which is for hard-coded (single purpose, atomic) metaclasses, and `DynamicSageMetaclass` for those that are dynamically created.\n\nWhat about the following scheme:\n\n- `BaseMetaclass` (instead of `SageMetaclass`): Its instances are metaclasses that are basic in the sense that one can combine them.\n- `DynamicMetaclass` or `CombinedMetaclass` (instead of `DynamicSageMetaclass`): Its instances are metaclasses that are dynamically/automatically created from a combination of base metaclasses.\n- `auto_metaclass`: The function that I currently call `sage_metaclass`. It returns an instance of `BaseMetaclass` or `CombinedMetaclass`, depending on the context.\n- The base metaclasses should be named `<Feature>ClassMetaclass`, which corresponds to the existing naming scheme in Sage and means that an instance of `<Feature>ClassMetaclass` is a class that provides a single feature (such as: It has a classcall, or it allows nesting).\n- The combined metaclasses should be named `<Feature1><Feature2>...<Feature_n>ClassMetaclass` (which in the current proof of concept is slightly different). So, it would be `ClasscallDynamicNestedClassMetaclass` for a metaclass whose instances are dynamic classes that have a classcall and allow nesting.\n\nI think `auto_metaclass` would be a good name for the function that appears in the metaclass definition, i.e.\n\n```\nclass NestedClassMetaclass:\n    __metaclass__ = auto_metaclass\n    def __init__(cls, name, bases, namespace):\n        nested_pickle(cls)\n```\n",
    "created_at": "2016-10-12T16:10:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297291",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:10 jdemeyer]:
> Replying to [comment:9 SimonKing]:
> > Would you agree with `MetaMetaclass` and (for the function that actually appears in the metaclass definitions) `meta_metaclass`? Or maybe just `Metaclass` and `metaclass`.
> 
> What about `AutoMetaclass` to refer to the *automatic* creation of combined metaclasses?

There are two things in the code: `SageMetaclass`, which is for hard-coded (single purpose, atomic) metaclasses, and `DynamicSageMetaclass` for those that are dynamically created.

What about the following scheme:

- `BaseMetaclass` (instead of `SageMetaclass`): Its instances are metaclasses that are basic in the sense that one can combine them.
- `DynamicMetaclass` or `CombinedMetaclass` (instead of `DynamicSageMetaclass`): Its instances are metaclasses that are dynamically/automatically created from a combination of base metaclasses.
- `auto_metaclass`: The function that I currently call `sage_metaclass`. It returns an instance of `BaseMetaclass` or `CombinedMetaclass`, depending on the context.
- The base metaclasses should be named `<Feature>ClassMetaclass`, which corresponds to the existing naming scheme in Sage and means that an instance of `<Feature>ClassMetaclass` is a class that provides a single feature (such as: It has a classcall, or it allows nesting).
- The combined metaclasses should be named `<Feature1><Feature2>...<Feature_n>ClassMetaclass` (which in the current proof of concept is slightly different). So, it would be `ClasscallDynamicNestedClassMetaclass` for a metaclass whose instances are dynamic classes that have a classcall and allow nesting.

I think `auto_metaclass` would be a good name for the function that appears in the metaclass definition, i.e.

```
class NestedClassMetaclass:
    __metaclass__ = auto_metaclass
    def __init__(cls, name, bases, namespace):
        nested_pickle(cls)
```




---

archive/issue_comments_297292.json:
```json
{
    "body": "Did you already test on Python 3? Because personally, I am still thinking that you are wasting your time to implement something which won't work anyway. But of course, I am gladly proven wrong.",
    "created_at": "2016-10-13T06:25:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297292",
    "user": "https://github.com/jdemeyer"
}
```

Did you already test on Python 3? Because personally, I am still thinking that you are wasting your time to implement something which won't work anyway. But of course, I am gladly proven wrong.



---

archive/issue_comments_297293.json:
```json
{
    "body": "Attempt to do the same tricks in Python3",
    "created_at": "2016-10-13T11:31:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297293",
    "user": "https://github.com/simon-king-jena"
}
```

Attempt to do the same tricks in Python3



---

archive/issue_comments_297294.json:
```json
{
    "body": "Attachment [metatest3.py](tarball://root/attachments/some-uuid/ticket21681/metatest3.py) by @simon-king-jena created at 2016-10-13 11:34:54\n\nThe attachment:metatest3.py is an attempt to port stuff to Python3 --- which sadly fails. In Python3, I get\n\n```\n>>> exec(open(\"/home/king/Sage/work/metaclass/metatest3.py\").read())\n>>> class MyCombinedExample(MyNestedClass, MyUniqueRepresentation):\n...     class SomeClass:\n...         pass\n...     class SomeCachedClass(MyUniqueRepresentation):\n...         def __init__(self, x):\n...             self.x = x\n... \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\n```\n\nwhereas the analogous example in Sage works.",
    "created_at": "2016-10-13T11:34:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297294",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [metatest3.py](tarball://root/attachments/some-uuid/ticket21681/metatest3.py) by @simon-king-jena created at 2016-10-13 11:34:54

The attachment:metatest3.py is an attempt to port stuff to Python3 --- which sadly fails. In Python3, I get

```
>>> exec(open("/home/king/Sage/work/metaclass/metatest3.py").read())
>>> class MyCombinedExample(MyNestedClass, MyUniqueRepresentation):
...     class SomeClass:
...         pass
...     class SomeCachedClass(MyUniqueRepresentation):
...         def __init__(self, x):
...             self.x = x
... 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
```

whereas the analogous example in Sage works.



---

archive/issue_comments_297295.json:
```json
{
    "body": "I am now trying whether using !ABCMeta (from Python's abc module) can help. It would hopefully fool Python into believing that the different metaclasses are subclasses of each other and thus would make it stop complaining about metaclass conflicts.",
    "created_at": "2016-10-13T12:10:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297295",
    "user": "https://github.com/simon-king-jena"
}
```

I am now trying whether using !ABCMeta (from Python's abc module) can help. It would hopefully fool Python into believing that the different metaclasses are subclasses of each other and thus would make it stop complaining about metaclass conflicts.



---

archive/issue_comments_297296.json:
```json
{
    "body": "From some tests, I get the impression that the abc module of Python 3 is broken. I am getting errors like\n\n```\n>>> SageMetaclass.__subclasscheck__(NestedClassMetaclass, type(1))\nbeing called <class '__main__.NestedClassMetaclass'> <class 'int'>\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python3.5/abc.py\", line 225, in __subclasscheck__\n    for scls in cls.__subclasses__():\nTypeError: descriptor '__subclasses__' of 'type' object needs an argument\n```\n\nhence, the error does not occur in a call in my code but in a call at line 225 of the abc module.",
    "created_at": "2016-10-13T12:23:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297296",
    "user": "https://github.com/simon-king-jena"
}
```

From some tests, I get the impression that the abc module of Python 3 is broken. I am getting errors like

```
>>> SageMetaclass.__subclasscheck__(NestedClassMetaclass, type(1))
being called <class '__main__.NestedClassMetaclass'> <class 'int'>
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python3.5/abc.py", line 225, in __subclasscheck__
    for scls in cls.__subclasses__():
TypeError: descriptor '__subclasses__' of 'type' object needs an argument
```

hence, the error does not occur in a call in my code but in a call at line 225 of the abc module.



---

archive/issue_comments_297297.json:
```json
{
    "body": "I made progress regarding Python 3, but at the end of the day you may be right: It seems that it won't work.\n\nThe question is *why* it won't. The error is \"TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\". However, using Python's abc-module, I arranged things so that `issubclass(ClasscallMetaclass,NestedClassMetaclass)` returns true.\n\nHence, it seems that Python does in fact not use the logic of `issubclass` when dealing with a metaclass. The remaining questions are: What does Python do instead, and how can it be hooked?",
    "created_at": "2016-10-13T15:13:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297297",
    "user": "https://github.com/simon-king-jena"
}
```

I made progress regarding Python 3, but at the end of the day you may be right: It seems that it won't work.

The question is *why* it won't. The error is "TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases". However, using Python's abc-module, I arranged things so that `issubclass(ClasscallMetaclass,NestedClassMetaclass)` returns true.

Hence, it seems that Python does in fact not use the logic of `issubclass` when dealing with a metaclass. The remaining questions are: What does Python do instead, and how can it be hooked?



---

archive/issue_comments_297298.json:
```json
{
    "body": "Replying to [comment:16 SimonKing]:\n> However, using Python's abc-module, I arranged things so that `issubclass(ClasscallMetaclass,NestedClassMetaclass)` returns true.\n\nJust a minor comment: you don't need the `abc` module for that (especially if it's giving you problems). You could just define `__instancecheck__` and/or `__subclasscheck__` directly.",
    "created_at": "2016-10-13T15:21:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297298",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:16 SimonKing]:
> However, using Python's abc-module, I arranged things so that `issubclass(ClasscallMetaclass,NestedClassMetaclass)` returns true.

Just a minor comment: you don't need the `abc` module for that (especially if it's giving you problems). You could just define `__instancecheck__` and/or `__subclasscheck__` directly.



---

archive/issue_comments_297299.json:
```json
{
    "body": "Replying to [comment:16 SimonKing]:\n> Hence, it seems that Python does in fact not use the logic of `issubclass` when dealing with a metaclass.\n\nRight, it uses [PyType_IsSubtype](https://docs.python.org/3/c-api/type.html#c.PyType_IsSubtype) which doesn't use `__subclasscheck__`.\n\n> The remaining questions are: What does Python do instead, and how can it be hooked?\n\nIt checks only the MRO. Basically, it implements `issubclass(x, y)` as `y in x.__mro__`.",
    "created_at": "2016-10-13T15:28:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297299",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:16 SimonKing]:
> Hence, it seems that Python does in fact not use the logic of `issubclass` when dealing with a metaclass.

Right, it uses [PyType_IsSubtype](https://docs.python.org/3/c-api/type.html#c.PyType_IsSubtype) which doesn't use `__subclasscheck__`.

> The remaining questions are: What does Python do instead, and how can it be hooked?

It checks only the MRO. Basically, it implements `issubclass(x, y)` as `y in x.__mro__`.



---

archive/issue_comments_297300.json:
```json
{
    "body": "Replying to [comment:18 jdemeyer]:\n> Right, it uses [PyType_IsSubtype](https://docs.python.org/3/c-api/type.html#c.PyType_IsSubtype) which doesn't use `__subclasscheck__`.\n\nOuch. That's efficient, but bad for my purpose.\n\nI just came up with a totally different approach.\n\nIn a nutshell: There should only be a single metaclass (hence, there will be no metaclass conflict), but there are also several functions affecting the class creation, and the metaclass will choose which of the functions are to be applied, based on attributes of the class and its bases.\n\n\nMore elaborated:\n\nOne could have just a single meta*class*, say, `class UniversalMetaclass(type)`, and a couple of *functions*, say, `nested_class_metaclass` and `classcall_metaclass`. These functions would return instances of `UniversalMetaclass`. So, roughly one would have\n\n```\nclass SomeNestedClass(metaclass=nested_class_metaclass):\n    ...\n\nclass UniqueRepresentation(metaclass=classcall_metaclass):\n    ...\nsage: type(SomeNestedClass) == type(UniqueRepresentation) == UniversalMetaclass\nTrue\n```\n\n\nNow, when one does\n\n```\nclass CombinedClass(UniqueRepresentation, SomeNestedClass):\n    ...\n```\n\nthen first of all Python 3 would not complain, since the metaclasses of both bases are identical. What we want is that the features used in the creation of `UniqueRepresentation` (namely addition of a classcall method)  and of `NestedClass` (namely invocation of `nested_pickle` upon creation of the class) are combined.\n\nSo, the question is: Given `UniqueRepresentation` and `SomeNestedClass`, how can we access the functions `classcall_metaclass` and `nested_class_metaclass`? In Python 2, this would be `UniqueRepresentation.__metaclass__`, but that's gone in Python 3.\n\nBut why couldn't we simply have our own attribute, say, `cls.__features__`, returning a tuple (or frozen set) of functions that were invoked during creation of the class `cls`?\n\nIn the creation of `CombinedClass`, Python 3 would conclude that `UniversalMetaclass` is responsible for the class creation (as it is the common metaclass of the bases).\n\nWe could make it so that `UniversalMetaclass` applies each function in `X.__features__` during creation of `CombinedClass`, for each base class `X` of `CombinedClass`, but of course without repetitions. And finally, it would store the tuple of functions in `CombinedClass.__features__`.\n\nI will try this.",
    "created_at": "2016-10-13T16:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297300",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:18 jdemeyer]:
> Right, it uses [PyType_IsSubtype](https://docs.python.org/3/c-api/type.html#c.PyType_IsSubtype) which doesn't use `__subclasscheck__`.

Ouch. That's efficient, but bad for my purpose.

I just came up with a totally different approach.

In a nutshell: There should only be a single metaclass (hence, there will be no metaclass conflict), but there are also several functions affecting the class creation, and the metaclass will choose which of the functions are to be applied, based on attributes of the class and its bases.


More elaborated:

One could have just a single meta*class*, say, `class UniversalMetaclass(type)`, and a couple of *functions*, say, `nested_class_metaclass` and `classcall_metaclass`. These functions would return instances of `UniversalMetaclass`. So, roughly one would have

```
class SomeNestedClass(metaclass=nested_class_metaclass):
    ...

class UniqueRepresentation(metaclass=classcall_metaclass):
    ...
sage: type(SomeNestedClass) == type(UniqueRepresentation) == UniversalMetaclass
True
```


Now, when one does

```
class CombinedClass(UniqueRepresentation, SomeNestedClass):
    ...
```

then first of all Python 3 would not complain, since the metaclasses of both bases are identical. What we want is that the features used in the creation of `UniqueRepresentation` (namely addition of a classcall method)  and of `NestedClass` (namely invocation of `nested_pickle` upon creation of the class) are combined.

So, the question is: Given `UniqueRepresentation` and `SomeNestedClass`, how can we access the functions `classcall_metaclass` and `nested_class_metaclass`? In Python 2, this would be `UniqueRepresentation.__metaclass__`, but that's gone in Python 3.

But why couldn't we simply have our own attribute, say, `cls.__features__`, returning a tuple (or frozen set) of functions that were invoked during creation of the class `cls`?

In the creation of `CombinedClass`, Python 3 would conclude that `UniversalMetaclass` is responsible for the class creation (as it is the common metaclass of the bases).

We could make it so that `UniversalMetaclass` applies each function in `X.__features__` during creation of `CombinedClass`, for each base class `X` of `CombinedClass`, but of course without repetitions. And finally, it would store the tuple of functions in `CombinedClass.__features__`.

I will try this.



---

archive/issue_comments_297301.json:
```json
{
    "body": "I did some research on the differences of Python 2 and Python 3 regarding metaclasses. In Python 2, the metaclass seems to come into play quite late in the class creation. But in Python 3, the first step is to determine the metaclass (which means that incompatible metaclasses of the bases result in an immediate error). Then, `metaclass.__prepare__` is called to initialise the namespace of the to-be-created class. Then, the body of the class definition is executed, followed by calling the metaclass to actually create the class. And eventually, class decorators are called.\n\nSo, we have in Python 3:\n\n```\n>>> def c_decorator(cls):\n...     print(\"decorating the class\")\n...     return cls\n... \n>>> class Meta(type):\n...     @classmethod\n...     def __prepare__(mcls, name, bases):\n...         print(\"preparing the namespace\")\n...         return dict()\n...     def __new__(cls, name, bases, namespace):\n...         print(\"new class\")\n...         return type(name, bases, namespace)\n... \n>>> @c_decorator\n... class C(metaclass=Meta):\n...     pass\n... \npreparing the namespace\nnew class\ndecorating the class\n```\n\nBoth `__prepare__` and class decorators are new in Python 3. Perhaps they can be used?\n\nAgain, it would be needed to have a `UniversalMetaclass`, since there must be no conflicts with the metaclasses of the bases. Then, `UniversalMetaclass.__prepare__` can add some information to the class' namespace, taking into account the bases. Based on this information, `UniversalMetaclass.__new__` can do special things during the class creation.\n\nClass decorators seem less relevant to me. They are called after creation of the class, but they wouldn't be called again when sub-classing. So, that post-production should better be done inside of `UniversalMetaclass.__new__`.",
    "created_at": "2016-10-13T23:55:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297301",
    "user": "https://github.com/simon-king-jena"
}
```

I did some research on the differences of Python 2 and Python 3 regarding metaclasses. In Python 2, the metaclass seems to come into play quite late in the class creation. But in Python 3, the first step is to determine the metaclass (which means that incompatible metaclasses of the bases result in an immediate error). Then, `metaclass.__prepare__` is called to initialise the namespace of the to-be-created class. Then, the body of the class definition is executed, followed by calling the metaclass to actually create the class. And eventually, class decorators are called.

So, we have in Python 3:

```
>>> def c_decorator(cls):
...     print("decorating the class")
...     return cls
... 
>>> class Meta(type):
...     @classmethod
...     def __prepare__(mcls, name, bases):
...         print("preparing the namespace")
...         return dict()
...     def __new__(cls, name, bases, namespace):
...         print("new class")
...         return type(name, bases, namespace)
... 
>>> @c_decorator
... class C(metaclass=Meta):
...     pass
... 
preparing the namespace
new class
decorating the class
```

Both `__prepare__` and class decorators are new in Python 3. Perhaps they can be used?

Again, it would be needed to have a `UniversalMetaclass`, since there must be no conflicts with the metaclasses of the bases. Then, `UniversalMetaclass.__prepare__` can add some information to the class' namespace, taking into account the bases. Based on this information, `UniversalMetaclass.__new__` can do special things during the class creation.

Class decorators seem less relevant to me. They are called after creation of the class, but they wouldn't be called again when sub-classing. So, that post-production should better be done inside of `UniversalMetaclass.__new__`.



---

archive/issue_comments_297302.json:
```json
{
    "body": "Should we close this?",
    "created_at": "2018-09-08T09:29:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297302",
    "user": "https://github.com/jdemeyer"
}
```

Should we close this?



---

archive/issue_comments_297303.json:
```json
{
    "body": "Replying to [comment:21 jdemeyer]:\n> Should we close this?\n\nI stopped working on it. However, given the last few comments, \"won't fix\" would be the wrong resolution, because I do think that the topic should be reconsidered after switching to Python3.",
    "created_at": "2018-09-08T09:32:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21444#issuecomment-297303",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:21 jdemeyer]:
> Should we close this?

I stopped working on it. However, given the last few comments, "won't fix" would be the wrong resolution, because I do think that the topic should be reconsidered after switching to Python3.



---

archive/issue_events_057431.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-07-04T05:12:59Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/21444",
    "milestone": "sage-wishlist",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/21444#event-57431"
}
```
