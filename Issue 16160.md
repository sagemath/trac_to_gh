# Issue 16160: Symbolic cmp

Issue created by migration from Trac.

Original creator: vbraun

Original creation time: 2014-05-25 17:25:28

CC:  vdelecroix mmezzarobba jpflori




---

Comment by vbraun created at 2014-05-25 17:28:42

Changing component from PLEASE CHANGE to symbolics.


---

Comment by vbraun created at 2014-05-25 17:28:42

Changing type from PLEASE CHANGE to defect.


---

Comment by burcin created at 2014-05-25 18:08:38

I can see how that might be surprising. :)

IIRC, that was a conscious decision to expose the print order from Pynac to !Python/Sage to be used for sorting lists, etc. where symbolic expressions occur. I guess many places in the code call `cmp()` instead of using the comparison operators.

We would need to get rid of this design for Python 3 compatibility anyway. Shall we remove support for `cmp()` and change all places where lists are returned from symbolics to explicitly call the print order?


---

Comment by vbraun created at 2014-05-25 18:12:41

Yes, thats what I'm thinking as well. I'll write a `print_order` function and see if I can get rid of all cmp calls...


---

Comment by vdelecroix created at 2014-05-27 14:35:22

New commits:


---

Comment by rws created at 2014-09-05 16:40:14

Trying to push this ticket a bit. I also found this `cmp` call:

```
 File "matrix_integer_dense.pyx", line 604, in sage.matrix.matrix_integer_dense.Matrix_integer_dense.__richcmp__ (build/cythonized/sage/matrix/matrix_integer_dense.c:9503)
  File "element.pyx", line 873, in sage.structure.element.Element._richcmp (build/cythonized/sage/structure/element.c:8891)
  File "element.pyx", line 855, in sage.structure.element.Element._richcmp_ (build/cythonized/sage/structure/element.c:8615)
  File "element.pyx", line 902, in sage.structure.element.Element._richcmp (build/cythonized/sage/structure/element.c:9316)
  File "element.pyx", line 949, in sage.structure.element.Element._richcmp_c_impl (build/cythonized/sage/structure/element.c:9645)
  File "matrix_dense.pyx", line 126, in sage.matrix.matrix_dense.Matrix_dense._cmp_c_impl (build/cythonized/sage/matrix/matrix_dense.c:3092)
  File "expression.pyx", line 3066, in sage.symbolic.expression.Expression.__cmp__ (build/cythonized/sage/symbolic/expression.cpp:16865)
```

Do I understand it right that this should call `math_sorted` instead of `cmp`?
----
New commits:


---

Comment by vbraun created at 2014-09-05 20:02:42

The problem is IMHO what to do with Python 3. Sure we can play the two different comparisons (cmp vs. rich) in Python 2 against each other, but in Py3 there will be only one comparison. So either
* Comparison is always symbolic, and sorting will have to call `__bool__` on the symbolic inequalities. We then need to make that a total order instead of returning `False` all the time. Slow.
* Comparison is never symbolic, and you need to call `x.symbolic_less(y)`. Could be beautified by the preparser. The actual comparison returns the internal term order. Fast.
Thought? Maybe that topic is more fodder for sage-devel...


---

Comment by rws created at 2014-09-05 20:18:31

Yes, it's a bit over my head.


---

Comment by kcrisman created at 2015-02-03 04:10:46

Was there ever any consensus on sage-devel on this?  I'm leaning toward the first option, but not strongly.


---

Comment by rws created at 2015-02-17 16:45:48

Replying to [comment:12 kcrisman]:
> Was there ever any consensus on sage-devel on this?  I'm leaning toward the first option, but not strongly.
You probably mean https://groups.google.com/forum/?hl=en#!searchin/sage-devel/cmp/sage-devel/092yBmHfXQo/4qfS_JHLJdwJ and #16537, #17175. The newsgroup thread is mainly about equality/hashing and a bit of richcmp, not the two choices above. I am just starting to read about this.


---

Comment by rws created at 2015-02-17 17:24:00

Changing priority from major to critical.


---

Comment by rws created at 2015-10-23 06:18:54

When #19040 is done `__cmp__` could simply delegate to `__nonzero__`.


---

Comment by rws created at 2015-10-24 09:26:11

The newest verson of #19040 is in the `u/rws/19312-1` branch of #19312

So, the way to resolve this IMO would be to
 1. merge #19312
 2. merge #19040 using the `u/rws/19312-1` branch of #19312
 3. using `__nonzero__` to implement `__cmp__`


---

Comment by rws created at 2016-03-02 07:34:06

There is also a more minimal solution (part of #19040): scan the expression, if it contains variables use print order, if not use math order.


---

Comment by rws created at 2016-03-06 16:32:37

With this we introduce a mixed sort key for symbolics which is numerically correct and symbolically fast. This is part of the work on #19040 and adds to/benefits from Volker's abstraction of orders of comparison.
----
New commits:


---

Comment by rws created at 2016-03-06 16:32:37

Changing status from new to needs_review.


---

Comment by git created at 2016-03-07 08:17:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-03-10 09:30:26

The results for the `RealSet` examples would be at the moment:

```
sage: RealSet((0, pi),[pi, pi],(pi,4))
[pi, 0) + (pi, 4)
sage: RealSet((0, pi),[0, pi],(pi,4))
[pi, 0] + (pi, 0) + (pi, 4)
sage: RealSet((0, pi),[0, 3.5],(pi,4))
(pi, 4)
```



---

Comment by rws created at 2016-03-10 09:37:24

So there is still

```
sage: cmp(pi,0)
1
sage: cmp(pi,SR(0))
-1
sage: cmp(0,pi)
-1
sage: cmp(SR(0),pi)
-1
```



---

Comment by rws created at 2016-03-10 09:37:53

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-03-10 13:56:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-03-10 14:05:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-03-10 14:06:13

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-03-11 07:55:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-03-11 07:58:25

Consider the commit by Volker Braun (the first) reviewed by me. Please review everything else.


---

Comment by dimpase created at 2016-03-11 10:41:42

hmm, patchbots are still not happy...


---

Comment by rws created at 2016-03-11 13:53:54

That was a blind merge of develop, sigh.


---

Comment by git created at 2016-03-11 15:35:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-03-14 09:09:19

It is interesting to see from the remaining fail in `random_test` that print order itself is a buggy concept: it either makes incorrect comparisons (`e>SR(0)` False) or fail transitivity if this is fixed in mixed order (`(x>e,e>SR(0),x>SR(0)) -> (True,True,False)`). So, mixed order in the present form would be no longer transitive.


---

Comment by rws created at 2016-03-14 09:21:33

Effectively the only way to refine comparison then is by introducing a `None` result which would exclude the above case from being flagged. Opinions would be very welcome.


---

Comment by dimpase created at 2016-03-14 09:59:59

perhaps someone should have a look at interfaces/mathematica.py where one has `__cmp__` for Mathematica objects, returning -1 if it falls through. Another bug? (cf. #18888)


---

Comment by rws created at 2016-03-14 13:37:57

Replying to [comment:39 dimpase]:
> perhaps someone should have a look at interfaces/mathematica.py where one has `__cmp__` for Mathematica objects, returning -1 if it falls through. Another bug? (cf. #18888)
Has nothing to do with this ticket.


---

Comment by git created at 2016-03-18 08:05:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2016-03-18 08:09:41

This restores transitivity by moving all expressions with variables to the right of all the numbers in a sorted list: `[1, sqrt(2), e, pi, sin(1/x), sqrt(x), x]`


---

Comment by vbraun created at 2016-03-23 19:13:47

Isn't it dangerous to compare constants by float, this will go wrong because of rounding  when you have equal or near equal numbers.


---

Comment by rws created at 2016-03-23 22:00:28

How about extending constants with an `evalf` member so that in comparisons the precision can be successively increased. Reaching the prec limit before a decision will return 0, ie equal.

Isn't this quite hypothetical, compared to the concretely buggy behaviour now?


---

Comment by vbraun created at 2016-03-24 08:40:25

Its perhaps not that hypothetical, the old joke (aka Heegner number)

```
$ python
>>> from math import exp, pi, sqrt
>>> exp(pi*sqrt(163)) == 262537412640768256
True
```

comes to mind. But I agree that this could be tackled on a future ticket.


---

Comment by mmezzarobba created at 2016-03-24 15:24:07

I don't understand what you are trying to do here, can someone please explain?

(In my understanding, calling `cmp` means you are asking for a _total_ order on the elements of the parent where the comparison ends up taking place. As most parents don't admit such an order that is compatible with their structure, it is a bug to call `cmp` and expect a mathematically meaningful answer. In contrast, it is perfectly okay for `cmp` to implement any arbitrary total order, provided that rich comparisons are implemented too. And it is acceptable, though not ideal due to the issues with Python3, to call `cmp` when you need to sort elements in an arbitrary way.)


---

Comment by rws created at 2016-03-24 15:51:17

At the moment there is one total order (print, mathematically wrong both in expressions with and without variables). Total math order OTOH is slow because of proving and undecidable. It is possible to have two total orders side-by-side where one half (within the set of expressions without variables) is fast, correct, and meaningful; and print order (within and with the set of expressions with variables) is fast as usual.

It is needed because `cmp` is used in Sage to sort expressions in a meaningful way, contrary to what you state.


---

Comment by mmezzarobba created at 2016-03-24 15:59:57

Replying to [comment:47 rws]:
> It is needed because `cmp` is used in Sage to sort expressions in a meaningful way, contrary to what you state.

I'm not saying that it is not used that way, I am saying that, as far as I understand, when it is used that way, the bug is there.


---

Comment by mmezzarobba created at 2016-03-24 16:03:22

Replying to [comment:47 rws]:
> It is possible to have two total orders side-by-side where one half (within the set of expressions without variables) is fast, correct, and meaningful

It will never be _correct_ in the sense that you can rely on it in mathematical algorithms, since the zero test for constant symbolic expressions is undecidable. At best it will be a nice and natural print order. Which is not a bad thing, but I don't understand if that's the goal of this ticket (and, if not, what the goal is).


---

Comment by rws created at 2016-03-24 16:18:09

Look at the ticket description. The goal is to fix those errors. If that means to remove the usage of `cmp` in those parts of Sage, then please say so. I'm not a Python guy and am not in the know what `cmp` is supposed to do. I want to fix those pesky errors that block the new piecewise functions for years now.


---

Comment by mmezzarobba created at 2016-03-24 16:22:47

Replying to [comment:50 rws]:
> Look at the ticket description. The goal is to fix those errors. If that means to remove the usage of `cmp` in those parts of Sage, then please say so.

I don't know. I tried to explain what I _believe_ is the convention used in sage (or perhaps the most reasonable of several incompatible conventions currently in use), but I'm genuinely interested in knowing if other people agree.


---

Comment by vbraun created at 2016-04-15 22:31:20

Better than what we currently have...


---

Comment by vbraun created at 2016-04-15 22:31:20

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-04-16 15:35:38

Resolution: fixed
