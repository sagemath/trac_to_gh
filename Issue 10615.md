# Issue 10615: Refactor category support for morphisms (Hom is not a functorial construction!)

archive/issues_010615.json:
```json
{
    "body": "Assignee: @nthiery\n\nCC:  sage-combinat simonking\n\nHom is currently implemented as a covariant functorial\nconstruction:\n\n\n```\n    sage: Rings().hom_category()\n    Category of hom sets in Category of rings\n    sage: Rings().hom_category().super_categories()\n    [Category of hom sets in Category of sets]\n```\n\n\nThe intention was to model the fact that a morphism in a category is\nalso a morphism in any super category, via the forgetful functor. With\nthe example above, if A and B are rings, then a ring morphism phi:\nA->B is also a set morphism. However, at the level of parents, and as\nnoted in the documentation of sage.category.HomCategory, this is\nmathematically plain wrong: if A and B are rings, then Hom(A,B) in the\ncategory of rings does not coincide with Hom(A,B) in the category of\nsets.\n\nI, Nicolas, take full blame for this misfeature; it was just the\nshortest route to implement some urgently needed features about\nmorphisms, and still get that huge chunk of category code done.\n\nHere are some thoughts for a proper implementation:\n\n- Add support for a HomMethods subclass, similar to ElementMethods\n  and ParentMethods. If Cat is a category, then Cat.ElementMethods\n  will provide generic methods for morphisms in Cat and any\n  subcategory. This will require to implement the building of a\n  hierarchy of abstract classes Cat.method_class. And to either tweak\n  sage.categories.morphism.Morphism to add inheritance from this\n  class, as is done in Element and Parent, or to tweak the\n  implementation of Homset.element_class so that, for H a homset in\n  Cat, H.element_class would inherit from Cat.method_class besides\n  the usual stuff (I guess I prefer the later option).\n\n- Reimplement HomCategory. For Cat a category, the purpose of\n  Cat.hom_category() shall be to provide mathematical information\n  about its homsets (e.g. that a homset in the category of vector\n  spaces is also a vector space). It should ignore the super\n  categories of C in general, except if is a full subcategory (a\n  homset in the category of finite groups is also a homset in the\n  category of groups).\n\n- If CatA is a subcategory of catB, add automatic coercion (or just\n  conversion?) from Hom(A,B, CatA) to Hom(A, B, CatB), modeling the\n  appropriate forgetful functor. There are too many such coercions\n  for them to be registered explicitly. So this probably need to be\n  implemented through a specific CatB._has_coerce_map_from(A) for\n  homsets.\n\n  Some extra work will probably be needed if one wants to handle\n  mixed morphism arithmetic (e.g. having the sum of an algebra\n  morphism and a coalgebra morphism return a vector space morphism).\n\nIssue created by migration from https://trac.sagemath.org/ticket/10668\n\n",
    "created_at": "2011-01-21T09:28:03Z",
    "labels": [
        "component: categories",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Refactor category support for morphisms (Hom is not a functorial construction!)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/10615",
    "user": "https://github.com/nthiery"
}
```
Assignee: @nthiery

CC:  sage-combinat simonking

Hom is currently implemented as a covariant functorial
construction:


```
    sage: Rings().hom_category()
    Category of hom sets in Category of rings
    sage: Rings().hom_category().super_categories()
    [Category of hom sets in Category of sets]
```


The intention was to model the fact that a morphism in a category is
also a morphism in any super category, via the forgetful functor. With
the example above, if A and B are rings, then a ring morphism phi:
A->B is also a set morphism. However, at the level of parents, and as
noted in the documentation of sage.category.HomCategory, this is
mathematically plain wrong: if A and B are rings, then Hom(A,B) in the
category of rings does not coincide with Hom(A,B) in the category of
sets.

I, Nicolas, take full blame for this misfeature; it was just the
shortest route to implement some urgently needed features about
morphisms, and still get that huge chunk of category code done.

Here are some thoughts for a proper implementation:

- Add support for a HomMethods subclass, similar to ElementMethods
  and ParentMethods. If Cat is a category, then Cat.ElementMethods
  will provide generic methods for morphisms in Cat and any
  subcategory. This will require to implement the building of a
  hierarchy of abstract classes Cat.method_class. And to either tweak
  sage.categories.morphism.Morphism to add inheritance from this
  class, as is done in Element and Parent, or to tweak the
  implementation of Homset.element_class so that, for H a homset in
  Cat, H.element_class would inherit from Cat.method_class besides
  the usual stuff (I guess I prefer the later option).

- Reimplement HomCategory. For Cat a category, the purpose of
  Cat.hom_category() shall be to provide mathematical information
  about its homsets (e.g. that a homset in the category of vector
  spaces is also a vector space). It should ignore the super
  categories of C in general, except if is a full subcategory (a
  homset in the category of finite groups is also a homset in the
  category of groups).

- If CatA is a subcategory of catB, add automatic coercion (or just
  conversion?) from Hom(A,B, CatA) to Hom(A, B, CatB), modeling the
  appropriate forgetful functor. There are too many such coercions
  for them to be registered explicitly. So this probably need to be
  implemented through a specific CatB._has_coerce_map_from(A) for
  homsets.

  Some extra work will probably be needed if one wants to handle
  mixed morphism arithmetic (e.g. having the sum of an algebra
  morphism and a coalgebra morphism return a vector space morphism).

Issue created by migration from https://trac.sagemath.org/ticket/10668





---

archive/issue_comments_111060.json:
```json
{
    "body": "Replying to [ticket:10668 nthiery]:\n> The intention was to model the fact that a morphism in a category is\n> also a morphism in any super category, via the forgetful functor. With\n> the example above, if A and B are rings, then a ring morphism phi:\n> A->B is also a set morphism. However, at the level of parents, and as\n> noted in the documentation of sage.category.HomCategory, this is\n> mathematically plain wrong: if A and B are rings, then Hom(A,B) in the\n> category of rings does not coincide with Hom(A,B) in the category of\n> sets.\n\nI don't see why this should be wrong: Any ring homomorphism is a set homomorphism. Hence, `Hom_Rings()(A,B)` is a subset of `Hom_Sets()(A,B)`  --  nobody claims that they coincide.\n\n> Here are some thoughts for a proper implementation:\n> \n>  - Add support for a HomMethods subclass, similar to ElementMethods\n>    and ParentMethods. If Cat is a category, then Cat.ElementMethods\n>    will provide generic methods for morphisms in Cat and any\n>    subcategory.\n\nYou mean \"Cat.HomMethods will provide...\", I guess.\n\n>  - Reimplement HomCategory. For Cat a category, the purpose of\n>    Cat.hom_category() shall be to provide mathematical information\n>    about its homsets (e.g. that a homset in the category of vector\n>    spaces is also a vector space). It should ignore the super\n>    categories of C in general, except if is a full subcategory (a\n>    homset in the category of finite groups is also a homset in the\n>    category of groups).\n\nThe approach with `HomMethods` would provide methods defined for homsets, whereas the fact that a homset of vector spaces is a vector space has implications for the methods of *elements* of the homsets (i.e., for methods of morphisms).\n\nI don't know whether we need special methods for homset, but of course it would be nice to have homsets that are vector spaces.\n\nWhat about the following approach:\n\n* There is the base class `sage.categories.category.HomCategory`. I suggest to provide it with an optional argument `hom_structure`. Define, for example, `H = HomCategory(Algebras(QQ),hom_structure=VectorSpaces(QQ))`. Then, `H` is the category of homsets in the category of algebras over `QQ`, and each homset would automatically be a vector space over `QQ`. Moreover, `H` would be a sub-category of `VectorSpaces(QQ)`.\n\n* I suggest to introduce a lazy attribute `C.hom_structure`, that defaults to `C.HomStructure` if that exists, and otherwise returns the join of `S.hom_structure` for all `S in C.super_categories()`. Then, `C.hom_category()` defaults to `HomCategory(C, hom_structure=C.hom_structure)`.\n\n* Of course, any category can define a custom `HomStructure` (e.g., in the `__init__` method of `VectorSpaces(R)`, we would define `self.HomStructure=self`, ensuring that `self.hom_structure` is the right thing). In order to avoid an infinite recursion of the lazy attribute, we also need to define `Objects().HomStructure=Objects()`.\n\n\n>  - If CatA is a subcategory of catB, add automatic coercion (or just\n>    conversion?) from Hom(A,B, CatA) to Hom(A, B, CatB), modeling the\n>    appropriate forgetful functor. There are too many such coercions\n>    for them to be registered explicitly. So this probably need to be\n>    implemented through a specific CatB._has_coerce_map_from(A) for\n>    homsets.\n\nThat would be a good candidate for your `HomMethods`, don't you think?\n\n>    Some extra work will probably be needed if one wants to handle\n>    mixed morphism arithmetic (e.g. having the sum of an algebra\n>    morphism and a coalgebra morphism return a vector space morphism).\n\nI guess that would be an extension of the `sage.categories.pushout` formalism.\n\nAnyway, my suggestion is to start with the `hom_structure` approach, as it seems to be relatively straight forward to implement.",
    "created_at": "2011-01-21T15:04:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111060",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [ticket:10668 nthiery]:
> The intention was to model the fact that a morphism in a category is
> also a morphism in any super category, via the forgetful functor. With
> the example above, if A and B are rings, then a ring morphism phi:
> A->B is also a set morphism. However, at the level of parents, and as
> noted in the documentation of sage.category.HomCategory, this is
> mathematically plain wrong: if A and B are rings, then Hom(A,B) in the
> category of rings does not coincide with Hom(A,B) in the category of
> sets.

I don't see why this should be wrong: Any ring homomorphism is a set homomorphism. Hence, `Hom_Rings()(A,B)` is a subset of `Hom_Sets()(A,B)`  --  nobody claims that they coincide.

> Here are some thoughts for a proper implementation:
> 
>  - Add support for a HomMethods subclass, similar to ElementMethods
>    and ParentMethods. If Cat is a category, then Cat.ElementMethods
>    will provide generic methods for morphisms in Cat and any
>    subcategory.

You mean "Cat.HomMethods will provide...", I guess.

>  - Reimplement HomCategory. For Cat a category, the purpose of
>    Cat.hom_category() shall be to provide mathematical information
>    about its homsets (e.g. that a homset in the category of vector
>    spaces is also a vector space). It should ignore the super
>    categories of C in general, except if is a full subcategory (a
>    homset in the category of finite groups is also a homset in the
>    category of groups).

The approach with `HomMethods` would provide methods defined for homsets, whereas the fact that a homset of vector spaces is a vector space has implications for the methods of *elements* of the homsets (i.e., for methods of morphisms).

I don't know whether we need special methods for homset, but of course it would be nice to have homsets that are vector spaces.

What about the following approach:

* There is the base class `sage.categories.category.HomCategory`. I suggest to provide it with an optional argument `hom_structure`. Define, for example, `H = HomCategory(Algebras(QQ),hom_structure=VectorSpaces(QQ))`. Then, `H` is the category of homsets in the category of algebras over `QQ`, and each homset would automatically be a vector space over `QQ`. Moreover, `H` would be a sub-category of `VectorSpaces(QQ)`.

* I suggest to introduce a lazy attribute `C.hom_structure`, that defaults to `C.HomStructure` if that exists, and otherwise returns the join of `S.hom_structure` for all `S in C.super_categories()`. Then, `C.hom_category()` defaults to `HomCategory(C, hom_structure=C.hom_structure)`.

* Of course, any category can define a custom `HomStructure` (e.g., in the `__init__` method of `VectorSpaces(R)`, we would define `self.HomStructure=self`, ensuring that `self.hom_structure` is the right thing). In order to avoid an infinite recursion of the lazy attribute, we also need to define `Objects().HomStructure=Objects()`.


>  - If CatA is a subcategory of catB, add automatic coercion (or just
>    conversion?) from Hom(A,B, CatA) to Hom(A, B, CatB), modeling the
>    appropriate forgetful functor. There are too many such coercions
>    for them to be registered explicitly. So this probably need to be
>    implemented through a specific CatB._has_coerce_map_from(A) for
>    homsets.

That would be a good candidate for your `HomMethods`, don't you think?

>    Some extra work will probably be needed if one wants to handle
>    mixed morphism arithmetic (e.g. having the sum of an algebra
>    morphism and a coalgebra morphism return a vector space morphism).

I guess that would be an extension of the `sage.categories.pushout` formalism.

Anyway, my suggestion is to start with the `hom_structure` approach, as it seems to be relatively straight forward to implement.



---

archive/issue_comments_111061.json:
```json
{
    "body": "Replying to [comment:1 SimonKing]:\n> Replying to [ticket:10668 nthiery]:\n> > The intention was to model the fact that a morphism in a category is\n> > also a morphism in any super category, via the forgetful functor. With\n> > the example above, if A and B are rings, then a ring morphism phi:\n> > A->B is also a set morphism. However, at the level of parents, and as\n> > noted in the documentation of sage.category.HomCategory, this is\n> > mathematically plain wrong: if A and B are rings, then Hom(A,B) in the\n> > category of rings does not coincide with Hom(A,B) in the category of\n> > sets.\n> \n> I don't see why this should be wrong: Any ring homomorphism is a set homomorphism. Hence, `Hom_Rings()(A,B)` is a subset of `Hom_Sets()(A,B)`  --  nobody claims that they coincide.\n\nVery short answer for now: here the question is whether Hom_Rings()(A,B) is an object of Hom_Sets(). It's not. The point of VectorSpaces().HomCategory() is to encode mathematical information about the homsets, like the fact that Hom(A,B) is itself a vector space. We don't want this information to be applied to a homset of a subcategory (a homset in Algebras() being certainly not a vector space).",
    "created_at": "2011-01-21T15:26:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111061",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:1 SimonKing]:
> Replying to [ticket:10668 nthiery]:
> > The intention was to model the fact that a morphism in a category is
> > also a morphism in any super category, via the forgetful functor. With
> > the example above, if A and B are rings, then a ring morphism phi:
> > A->B is also a set morphism. However, at the level of parents, and as
> > noted in the documentation of sage.category.HomCategory, this is
> > mathematically plain wrong: if A and B are rings, then Hom(A,B) in the
> > category of rings does not coincide with Hom(A,B) in the category of
> > sets.
> 
> I don't see why this should be wrong: Any ring homomorphism is a set homomorphism. Hence, `Hom_Rings()(A,B)` is a subset of `Hom_Sets()(A,B)`  --  nobody claims that they coincide.

Very short answer for now: here the question is whether Hom_Rings()(A,B) is an object of Hom_Sets(). It's not. The point of VectorSpaces().HomCategory() is to encode mathematical information about the homsets, like the fact that Hom(A,B) is itself a vector space. We don't want this information to be applied to a homset of a subcategory (a homset in Algebras() being certainly not a vector space).



---

archive/issue_comments_111062.json:
```json
{
    "body": "Replying to [comment:2 nthiery]:\n> Very short answer for now: here the question is whether Hom_Rings()(A,B) is an object of Hom_Sets(). It's not. The point of VectorSpaces().HomCategory() is to encode mathematical information about the homsets, like the fact that Hom(A,B) is itself a vector space. We don't want this information to be applied to a homset of a subcategory (a homset in Algebras() being certainly not a vector space).\n\nRight.\n\nNevertheless, I believe that an attribute like `C.hom_structure` would be a convenient way to declare that the homsets of `C` all have a particular structure (like `Rings()` or `VectorSpaces(C.base_ring())`) and that therefore `C.hom_category()` is a sub-category of `C.hom_structure`.\n\nSo, for now, the only detail that I have to withdraw from my proposal is that `C.hom_structure` will not be influenced by `X.hom_structure` for a super-category `X` of `C`.",
    "created_at": "2011-01-21T18:31:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111062",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:2 nthiery]:
> Very short answer for now: here the question is whether Hom_Rings()(A,B) is an object of Hom_Sets(). It's not. The point of VectorSpaces().HomCategory() is to encode mathematical information about the homsets, like the fact that Hom(A,B) is itself a vector space. We don't want this information to be applied to a homset of a subcategory (a homset in Algebras() being certainly not a vector space).

Right.

Nevertheless, I believe that an attribute like `C.hom_structure` would be a convenient way to declare that the homsets of `C` all have a particular structure (like `Rings()` or `VectorSpaces(C.base_ring())`) and that therefore `C.hom_category()` is a sub-category of `C.hom_structure`.

So, for now, the only detail that I have to withdraw from my proposal is that `C.hom_structure` will not be influenced by `X.hom_structure` for a super-category `X` of `C`.



---

archive/issue_comments_111063.json:
```json
{
    "body": "Replying to [comment:4 nthiery]:\n\nMore later when I'll have recharged my battery ...",
    "created_at": "2011-01-22T08:39:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111063",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:4 nthiery]:

More later when I'll have recharged my battery ...



---

archive/issue_comments_111064.json:
```json
{
    "body": "Replying to [ticket:10668 nthiery]:\n>  - Add support for a MorphismsMethods subclass, similar to\n>    ElementMethods and ParentMethods. If Cat is a category, then\n>    Cat.MorphismMethods will provide generic methods for morphisms in\n>    Cat and in any subcategory.\n\nNot in a sub-category! Namely, if `Cat` is the category of F-vectorspaces, then `Cat.MorphismMethods` would include addition and skalar multiplication. But for a sub-category of `Cat`, such as F-algebras, we don't want that, as you had pointed out.\n\n> This can be achieved by:\n> \n>     - Building of a hierarchy of abstract classes Cat.morphism_class,\n>       similar to Cat.element_class and Cat.parent_class (10 lines of\n>       code; see Category.element_class).\n\nI don't see such hierarchy.\n\n>     - Having morphisms in Cat inherit from Cat.morphism_class.\n\nI really think the `Cat.hom_structure` formalism that I suggested would be easier. \n\nAny category would provide its own hom-structure (and there would be *no* inheritance for sub-categories), of course `Objects()` being the default hom-structure.\n\nThen, homsets in `Cat` would inherit from `Cat.hom_structure.parent_class`, whereas morphisms in `Cat` would inherit from `Cat.hom_structure.element_class`.\n\nIn particular, there is no need to provide `Cat.HomMethods` or `Cat.MorphismMethods`. In fact, they are redundant: If you simply state that `Cat.hom_structure` is `VectorSpaces(QQ)`, then the morphisms already have the element methods of vector spaces, whereas in your approach you needed to restate (copy-and-paste) them as `Cat.MorphismMethods`.",
    "created_at": "2011-01-22T09:08:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111064",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [ticket:10668 nthiery]:
>  - Add support for a MorphismsMethods subclass, similar to
>    ElementMethods and ParentMethods. If Cat is a category, then
>    Cat.MorphismMethods will provide generic methods for morphisms in
>    Cat and in any subcategory.

Not in a sub-category! Namely, if `Cat` is the category of F-vectorspaces, then `Cat.MorphismMethods` would include addition and skalar multiplication. But for a sub-category of `Cat`, such as F-algebras, we don't want that, as you had pointed out.

> This can be achieved by:
> 
>     - Building of a hierarchy of abstract classes Cat.morphism_class,
>       similar to Cat.element_class and Cat.parent_class (10 lines of
>       code; see Category.element_class).

I don't see such hierarchy.

>     - Having morphisms in Cat inherit from Cat.morphism_class.

I really think the `Cat.hom_structure` formalism that I suggested would be easier. 

Any category would provide its own hom-structure (and there would be *no* inheritance for sub-categories), of course `Objects()` being the default hom-structure.

Then, homsets in `Cat` would inherit from `Cat.hom_structure.parent_class`, whereas morphisms in `Cat` would inherit from `Cat.hom_structure.element_class`.

In particular, there is no need to provide `Cat.HomMethods` or `Cat.MorphismMethods`. In fact, they are redundant: If you simply state that `Cat.hom_structure` is `VectorSpaces(QQ)`, then the morphisms already have the element methods of vector spaces, whereas in your approach you needed to restate (copy-and-paste) them as `Cat.MorphismMethods`.



---

archive/issue_comments_111065.json:
```json
{
    "body": "Replying to [comment:6 SimonKing]:\n> Not in a sub-category! Namely, if `Cat` is the category of\n> F-vectorspaces, then `Cat.MorphismMethods` would include addition\n> and skalar multiplication. But for a sub-category of `Cat`, such as\n> F-algebras, we don't want that, as you had pointed out.\n\nOf course addition should not be put in MorphismMethods. On the other\nhand, there are a lot of generic operations on morphisms that pass\ndown to subcategories, like inverting a morphism (say in the category\nof finite sets) or computing the matrix/the rank/the det/you_name_it\nof a morphism of finite dimensional vector space. It is essential to\npass those generic methods down to subcategories.\n\nThat is not a vague though that popped up when I created this ticket,\nbut a concrete feature that we have been longing for years and we\ncould not implement in MuPAD (MuPAD categories did not handle\nmorphisms) despite our many use cases.\n\n> I really think the `Cat.hom_structure` formalism that I suggested\n> would be easier.\n\nAnd I think mine is no more complicated, while being more consistent\nwith the rest of the framework :-)\n\nIt seems like most of the discussion comes from confusion and\nvagueness (and I take my share of the blame for that). So let's both\nwrite a little prototype to have a concrete ground to discuss on. We\ndon't have to include the coercion / push_out part in this prototype\nsince we agree on it. I can try to implement mine sometime next week.\n\n> In particular, there is no need to provide `Cat.HomMethods` or\n> `Cat.MorphismMethods`. In fact, they are redundant: If you simply\n> state that `Cat.hom_structure` is `VectorSpaces(QQ)`, then the\n> morphisms already have the element methods of vector spaces, whereas\n> in your approach you needed to restate (copy-and-paste) them as\n> `Cat.MorphismMethods`.\n\nCat.HomCategory() will still use the standard super_categories()\napproach to state that it is a subcategory of VectorSpaces(), and its\nelements will inherit from VectorSpaces().element_class.\n\nCheers,\n\t\t\t\tNicolas\n\nPS: by the way, I am wondering if we should be using Cat.objects() or\nCat.Objects() (given that we already have Cat.Quotients(),\nCat.Subobjects(), Cat.CartesianProducts(), ...). Here, I am thinking\nabout using the occasion to replace Cat.hom_category() by Cat.Homsets().",
    "created_at": "2011-01-22T10:36:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111065",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:6 SimonKing]:
> Not in a sub-category! Namely, if `Cat` is the category of
> F-vectorspaces, then `Cat.MorphismMethods` would include addition
> and skalar multiplication. But for a sub-category of `Cat`, such as
> F-algebras, we don't want that, as you had pointed out.

Of course addition should not be put in MorphismMethods. On the other
hand, there are a lot of generic operations on morphisms that pass
down to subcategories, like inverting a morphism (say in the category
of finite sets) or computing the matrix/the rank/the det/you_name_it
of a morphism of finite dimensional vector space. It is essential to
pass those generic methods down to subcategories.

That is not a vague though that popped up when I created this ticket,
but a concrete feature that we have been longing for years and we
could not implement in MuPAD (MuPAD categories did not handle
morphisms) despite our many use cases.

> I really think the `Cat.hom_structure` formalism that I suggested
> would be easier.

And I think mine is no more complicated, while being more consistent
with the rest of the framework :-)

It seems like most of the discussion comes from confusion and
vagueness (and I take my share of the blame for that). So let's both
write a little prototype to have a concrete ground to discuss on. We
don't have to include the coercion / push_out part in this prototype
since we agree on it. I can try to implement mine sometime next week.

> In particular, there is no need to provide `Cat.HomMethods` or
> `Cat.MorphismMethods`. In fact, they are redundant: If you simply
> state that `Cat.hom_structure` is `VectorSpaces(QQ)`, then the
> morphisms already have the element methods of vector spaces, whereas
> in your approach you needed to restate (copy-and-paste) them as
> `Cat.MorphismMethods`.

Cat.HomCategory() will still use the standard super_categories()
approach to state that it is a subcategory of VectorSpaces(), and its
elements will inherit from VectorSpaces().element_class.

Cheers,
				Nicolas

PS: by the way, I am wondering if we should be using Cat.objects() or
Cat.Objects() (given that we already have Cat.Quotients(),
Cat.Subobjects(), Cat.CartesianProducts(), ...). Here, I am thinking
about using the occasion to replace Cat.hom_category() by Cat.Homsets().



---

archive/issue_comments_111066.json:
```json
{
    "body": "Replying to [comment:7 nthiery]:\n> Replying to [comment:6 SimonKing]:\n> > Not in a sub-category! Namely, if `Cat` is the category of\n> > F-vectorspaces, then `Cat.MorphismMethods` would include addition\n> > and skalar multiplication. But for a sub-category of `Cat`, such as\n> > F-algebras, we don't want that, as you had pointed out.\n> \n> Of course addition should not be put in MorphismMethods. On the other\n> hand, there are a lot of generic operations on morphisms that pass\n> down to subcategories, like inverting a morphism (say in the category\n> of finite sets) or computing the matrix/the rank/the det/you_name_it\n> of a morphism of finite dimensional vector space. It is essential to\n> pass those generic methods down to subcategories.\n\nI see. Yes, for those kind of methods, your approach makes very much sense.\n\nBut what would actually prevent us from doing *both*? Our two approaches are good for different things, and they are orthogonal to each other. If I understand correctly, you suggest that there should be `Cat.morphism_class` from which morphisms inherit, analogous to `Cat.element_class`, thereby getting \"hereditary\" (to sub-categories) methods. I suggest that `Cat` should have an attribute that allows `Cat.hom_category()` to assign the correct category to the homset category (hence, `Cat.hom_category().is_subcategory(Cat.hom_structure)`), so that homomorphism would inherit from `Cat.hom_structure.element_class` (by the existing framework - hence, my suggestion is indeed very consistent with with the existing framework :-).\n\nIs there any reason to not have a double inheritance from `Cat.morphism_class` and `Cat.hom_structure.element_class` (`Cat.hom_structure` being a category)?\n\n> So let's both\n> write a little prototype to have a concrete ground to discuss on. We\n> don't have to include the coercion / push_out part in this prototype\n> since we agree on it. I can try to implement mine sometime next week.\n\nOK.\n\n> Cat.HomCategory() will still use the standard super_categories()\n> approach to state that it is a subcategory of VectorSpaces(), and its\n> elements will inherit from VectorSpaces().element_class.\n\nOK, this is what I suggested above: One needs to introduce a standard mechanism to declare the category which `Cat.hom_category()` is sub-category of.",
    "created_at": "2011-01-22T14:58:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111066",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:7 nthiery]:
> Replying to [comment:6 SimonKing]:
> > Not in a sub-category! Namely, if `Cat` is the category of
> > F-vectorspaces, then `Cat.MorphismMethods` would include addition
> > and skalar multiplication. But for a sub-category of `Cat`, such as
> > F-algebras, we don't want that, as you had pointed out.
> 
> Of course addition should not be put in MorphismMethods. On the other
> hand, there are a lot of generic operations on morphisms that pass
> down to subcategories, like inverting a morphism (say in the category
> of finite sets) or computing the matrix/the rank/the det/you_name_it
> of a morphism of finite dimensional vector space. It is essential to
> pass those generic methods down to subcategories.

I see. Yes, for those kind of methods, your approach makes very much sense.

But what would actually prevent us from doing *both*? Our two approaches are good for different things, and they are orthogonal to each other. If I understand correctly, you suggest that there should be `Cat.morphism_class` from which morphisms inherit, analogous to `Cat.element_class`, thereby getting "hereditary" (to sub-categories) methods. I suggest that `Cat` should have an attribute that allows `Cat.hom_category()` to assign the correct category to the homset category (hence, `Cat.hom_category().is_subcategory(Cat.hom_structure)`), so that homomorphism would inherit from `Cat.hom_structure.element_class` (by the existing framework - hence, my suggestion is indeed very consistent with with the existing framework :-).

Is there any reason to not have a double inheritance from `Cat.morphism_class` and `Cat.hom_structure.element_class` (`Cat.hom_structure` being a category)?

> So let's both
> write a little prototype to have a concrete ground to discuss on. We
> don't have to include the coercion / push_out part in this prototype
> since we agree on it. I can try to implement mine sometime next week.

OK.

> Cat.HomCategory() will still use the standard super_categories()
> approach to state that it is a subcategory of VectorSpaces(), and its
> elements will inherit from VectorSpaces().element_class.

OK, this is what I suggested above: One needs to introduce a standard mechanism to declare the category which `Cat.hom_category()` is sub-category of.



---

archive/issue_comments_111067.json:
```json
{
    "body": "> But what would actually prevent us from doing *both*?\n\nAh, good, we now fund the point were we did not understand each\nother. The plan is definitely to do both! That is have inheritance\nfrom Cat.morphism_class and Cat.hom_category().element_class.\n\n> OK, this is what I suggested above: One needs to introduce a\n> standard mechanism to declare the category which\n> `Cat.hom_category()` is sub-category of.\n\nAnd that's a second misunderstanding: this mechanism already exists,\nand I am not planning to remove it (though the syntax might change a\ntiny bit; we probably don't need the extra_super_categories thingy,\nand just use super_categories.\n\nWhat do you think of using the occasion to rename Cat.hom_category()\ninto Cat.Homsets(), for consistency with Cat.Quotients() and the like?\n\nCheers,\n\t\t\t\tNicolas",
    "created_at": "2011-01-22T21:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111067",
    "user": "https://github.com/nthiery"
}
```

> But what would actually prevent us from doing *both*?

Ah, good, we now fund the point were we did not understand each
other. The plan is definitely to do both! That is have inheritance
from Cat.morphism_class and Cat.hom_category().element_class.

> OK, this is what I suggested above: One needs to introduce a
> standard mechanism to declare the category which
> `Cat.hom_category()` is sub-category of.

And that's a second misunderstanding: this mechanism already exists,
and I am not planning to remove it (though the syntax might change a
tiny bit; we probably don't need the extra_super_categories thingy,
and just use super_categories.

What do you think of using the occasion to rename Cat.hom_category()
into Cat.Homsets(), for consistency with Cat.Quotients() and the like?

Cheers,
				Nicolas



---

archive/issue_comments_111068.json:
```json
{
    "body": "Replying to [comment:9 nthiery]:\n> > OK, this is what I suggested above: One needs to introduce a\n> > standard mechanism to declare the category which\n> > `Cat.hom_category()` is sub-category of.\n> \n> And that's a second misunderstanding: this mechanism already exists,\n> and I am not planning to remove it (though the syntax might change a\n> tiny bit; we probably don't need the extra_super_categories thingy,\n> and just use super_categories.\n\nWhat mechanism do you mean? I am of course aware of the `extra_super_category` method - but `sage.categories.category.HomCategory.extra_super_category()` returns `[]`, and `sage.categories.category.HomCategory.super_categories()` returns stuff that we don't want (namely `C.hom_category()` for all `C` in `self.base_category.super_categories()`).\n\nOf course, it would suffice to make `VectorSpaces(QQ).hom_category().extra_super_categories()` return `[VectorSpaces(QQ)]`. But this would currently require to introduce a custom `HomCategory` class for `VectorSpaces` that overrides the method of the `HomCategory` base class. This is not nice and should be simplified.\n\nWhat I plan is: Remove inheritance of the hom-categories of the super-categories of the base-category from `sage.categories.category.HomCategory.super_categories()`; it should basically return `self.extra_super_categories()+[Sets()]`. Moreover, define `sage.categories.category.HomCategory.extra_super_categories()` like this:\n\n```\ndef extra_super_categories(self):\n    try:\n        return [self.base_category.hom_structure]\n    except AttributeError:\n        return []\n```\n\n\nThen, in the init-method of the category of vector spaces, one would simply add the line\n\n```\n        self.hom_structure = self\n```\n\n\nSimilarly (I hope that I am not confusing things now), one would add the line\n\n```\n        self.hom_structure = LeftModules(self.base_ring())\n```\n\nto the init method of *right* modules; and `self.hom_structure = RightModules(self.base_ring())` for left modules, and so on. That seems easier than defining a whole class `HomCategory` for `LeftModules`.\n\n> What do you think of using the occasion to rename Cat.hom_category()\n> into Cat.Homsets(), for consistency with Cat.Quotients() and the like?\n\nPersonally, I don't like uppercase method names, and I remember that it is officially recommended to avoid capital letters in Python method or function or module names, whereas upper case is recommended to use for classes (but I do not remember where I was reading that recommendation).\n\nBest regards,\n\nSimon",
    "created_at": "2011-01-22T22:38:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111068",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:9 nthiery]:
> > OK, this is what I suggested above: One needs to introduce a
> > standard mechanism to declare the category which
> > `Cat.hom_category()` is sub-category of.
> 
> And that's a second misunderstanding: this mechanism already exists,
> and I am not planning to remove it (though the syntax might change a
> tiny bit; we probably don't need the extra_super_categories thingy,
> and just use super_categories.

What mechanism do you mean? I am of course aware of the `extra_super_category` method - but `sage.categories.category.HomCategory.extra_super_category()` returns `[]`, and `sage.categories.category.HomCategory.super_categories()` returns stuff that we don't want (namely `C.hom_category()` for all `C` in `self.base_category.super_categories()`).

Of course, it would suffice to make `VectorSpaces(QQ).hom_category().extra_super_categories()` return `[VectorSpaces(QQ)]`. But this would currently require to introduce a custom `HomCategory` class for `VectorSpaces` that overrides the method of the `HomCategory` base class. This is not nice and should be simplified.

What I plan is: Remove inheritance of the hom-categories of the super-categories of the base-category from `sage.categories.category.HomCategory.super_categories()`; it should basically return `self.extra_super_categories()+[Sets()]`. Moreover, define `sage.categories.category.HomCategory.extra_super_categories()` like this:

```
def extra_super_categories(self):
    try:
        return [self.base_category.hom_structure]
    except AttributeError:
        return []
```


Then, in the init-method of the category of vector spaces, one would simply add the line

```
        self.hom_structure = self
```


Similarly (I hope that I am not confusing things now), one would add the line

```
        self.hom_structure = LeftModules(self.base_ring())
```

to the init method of *right* modules; and `self.hom_structure = RightModules(self.base_ring())` for left modules, and so on. That seems easier than defining a whole class `HomCategory` for `LeftModules`.

> What do you think of using the occasion to rename Cat.hom_category()
> into Cat.Homsets(), for consistency with Cat.Quotients() and the like?

Personally, I don't like uppercase method names, and I remember that it is officially recommended to avoid capital letters in Python method or function or module names, whereas upper case is recommended to use for classes (but I do not remember where I was reading that recommendation).

Best regards,

Simon



---

archive/issue_comments_111069.json:
```json
{
    "body": "A technical question:\n\nFor things to work, it is needed that `Fields().hom_category().parent_class` inherits from `Rings().hom_category().parent_class`.\n\nI thought that the inheritance would be provided by the category framework, if we have `Fields().hom_category().is_subcategory(Rings().hom_category())` (which, I guess, is mathematically correct). Unfortunately, even though I arranged things so that indeed `Fields().hom_category().is_subcategory(Rings().hom_category())`, I still get no inheritance of the parent classes.\n\nSo, how can one inherit the parent class of a super-category?",
    "created_at": "2011-01-23T09:58:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111069",
    "user": "https://github.com/simon-king-jena"
}
```

A technical question:

For things to work, it is needed that `Fields().hom_category().parent_class` inherits from `Rings().hom_category().parent_class`.

I thought that the inheritance would be provided by the category framework, if we have `Fields().hom_category().is_subcategory(Rings().hom_category())` (which, I guess, is mathematically correct). Unfortunately, even though I arranged things so that indeed `Fields().hom_category().is_subcategory(Rings().hom_category())`, I still get no inheritance of the parent classes.

So, how can one inherit the parent class of a super-category?



---

archive/issue_comments_111070.json:
```json
{
    "body": "Replying to [comment:11 SimonKing]:\n> A technical question:\n> \n> For things to work, it is needed that `Fields().hom_category().parent_class` inherits from `Rings().hom_category().parent_class`.\n\nSorry for asking: It seems to work. I misinterpreted an error message.",
    "created_at": "2011-01-23T10:05:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111070",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:11 SimonKing]:
> A technical question:
> 
> For things to work, it is needed that `Fields().hom_category().parent_class` inherits from `Rings().hom_category().parent_class`.

Sorry for asking: It seems to work. I misinterpreted an error message.



---

archive/issue_comments_111071.json:
```json
{
    "body": "I wonder whether it wouldn't be better to build upon #10667. There, amongst other things, I try to separate `CategoryObject` from `SageObject` and remove some inappropriate category stuff from elements and morphisms. I think that this part of #10667 could help me to implement my approach.\n\nI suggest that *I* prepare my patch on top of #10667; you can of course do differently with the implementation of your approach.",
    "created_at": "2011-01-23T11:20:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111071",
    "user": "https://github.com/simon-king-jena"
}
```

I wonder whether it wouldn't be better to build upon #10667. There, amongst other things, I try to separate `CategoryObject` from `SageObject` and remove some inappropriate category stuff from elements and morphisms. I think that this part of #10667 could help me to implement my approach.

I suggest that *I* prepare my patch on top of #10667; you can of course do differently with the implementation of your approach.



---

archive/issue_comments_111072.json:
```json
{
    "body": "Replying to [comment:13 SimonKing]:\n> I wonder whether it wouldn't be better to build upon #10667. There, amongst other things, I try to separate `CategoryObject` from `SageObject` and remove some inappropriate category stuff from elements and morphisms. I think that this part of #10667 could help me to implement my approach.\n> \n> I suggest that *I* prepare my patch on top of #10667; you can of course do differently with the implementation of your approach.\n\nSure, please take the easiest route for you! #10667 is already large enough, and I see the point of not introducing yet another dependency :-)\n\nCheers,",
    "created_at": "2011-01-23T13:53:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111072",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:13 SimonKing]:
> I wonder whether it wouldn't be better to build upon #10667. There, amongst other things, I try to separate `CategoryObject` from `SageObject` and remove some inappropriate category stuff from elements and morphisms. I think that this part of #10667 could help me to implement my approach.
> 
> I suggest that *I* prepare my patch on top of #10667; you can of course do differently with the implementation of your approach.

Sure, please take the easiest route for you! #10667 is already large enough, and I see the point of not introducing yet another dependency :-)

Cheers,



---

archive/issue_comments_111073.json:
```json
{
    "body": "I just uploaded a preliminary patch, implementing my approach. The patch isn't finished (lacking doc tests), but is ready for discussion. It depends on #10667 (though it might apply with some noise without #10667 - test, if you like).\n\nFeatures:\n\n**__Structure of hom sets__**\n\nAs I announced, I introduced an attribute for categories `C` that determines a category which `C.hom_category()` is sub-category of. I call this attribute `C.hom_structure`:\n\n```\n# This was already fixed by #10667\nsage: LeftModules(ZZ).hom_category()\nCategory of hom sets in Category of left modules over Integer Ring\nsage: type(LeftModules(ZZ).hom_category())\n<class 'sage.categories.sets_cat.Sets.HomCategory'>\n# This is new:\nsage: LeftModules(ZZ).hom_category().is_subcategory(RightModules(ZZ))\nTrue\nsage: issubclass(LeftModules(ZZ).hom_category().parent_class, RightModules(ZZ).parent_class)\nTrue\n# Reason for it working:\nsage: LeftModules(ZZ).hom_structure\nCategory of right modules over Integer Ring\n```\n\nThe attribute `C.hom_structure` is used in `sage.categories.HomCategory.extra_super_categories()`.\n\n**Hierarchy of hom-categories**\n\nRecall that currently, the hierarchy of hom-categories goes parallel with the hierarchy of their base categories, which is wrong.\n\nHowever, if `C1` is a *full* sub-category of `C2` then (and *only* then) we should indeed have `C1.hom_category().is_subcategory(C2.hom_category())`. Similar to the method `C.super_categories()`, I introduce an attribute `C.full_subcategory_of`, that provides a list of immediate super categories in which `C` is full.\n\nWith that, I have:\n\n```\nsage: IntegralDomains().full_subcategory_of\n[Category of commutative rings, Category of domains]\nsage: Domains().full_subcategory_of\n[Category of rings]\nsage: IntegralDomains().hom_category().is_subcategory(CommutativeRings().hom_category())\nTrue\nsage: IntegralDomains().hom_category().is_subcategory(Rings().hom_category())\nTrue\n```\n\nand, in particular\n\n```\nsage: issubclass(IntegralDomains().hom_category().parent_class, Rings().hom_category().parent_class)\nTrue\n```\n\n\n**Self-criticism**\n\nIt is not very pythonic to do those things with an attribute - usually, methods are better. However, an attribute is easier to add, and it is faster to access.\n\nI am not sure whether I got the \"full subcategory\" business right in all cases.",
    "created_at": "2011-01-23T19:40:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111073",
    "user": "https://github.com/simon-king-jena"
}
```

I just uploaded a preliminary patch, implementing my approach. The patch isn't finished (lacking doc tests), but is ready for discussion. It depends on #10667 (though it might apply with some noise without #10667 - test, if you like).

Features:

**__Structure of hom sets__**

As I announced, I introduced an attribute for categories `C` that determines a category which `C.hom_category()` is sub-category of. I call this attribute `C.hom_structure`:

```
# This was already fixed by #10667
sage: LeftModules(ZZ).hom_category()
Category of hom sets in Category of left modules over Integer Ring
sage: type(LeftModules(ZZ).hom_category())
<class 'sage.categories.sets_cat.Sets.HomCategory'>
# This is new:
sage: LeftModules(ZZ).hom_category().is_subcategory(RightModules(ZZ))
True
sage: issubclass(LeftModules(ZZ).hom_category().parent_class, RightModules(ZZ).parent_class)
True
# Reason for it working:
sage: LeftModules(ZZ).hom_structure
Category of right modules over Integer Ring
```

The attribute `C.hom_structure` is used in `sage.categories.HomCategory.extra_super_categories()`.

**Hierarchy of hom-categories**

Recall that currently, the hierarchy of hom-categories goes parallel with the hierarchy of their base categories, which is wrong.

However, if `C1` is a *full* sub-category of `C2` then (and *only* then) we should indeed have `C1.hom_category().is_subcategory(C2.hom_category())`. Similar to the method `C.super_categories()`, I introduce an attribute `C.full_subcategory_of`, that provides a list of immediate super categories in which `C` is full.

With that, I have:

```
sage: IntegralDomains().full_subcategory_of
[Category of commutative rings, Category of domains]
sage: Domains().full_subcategory_of
[Category of rings]
sage: IntegralDomains().hom_category().is_subcategory(CommutativeRings().hom_category())
True
sage: IntegralDomains().hom_category().is_subcategory(Rings().hom_category())
True
```

and, in particular

```
sage: issubclass(IntegralDomains().hom_category().parent_class, Rings().hom_category().parent_class)
True
```


**Self-criticism**

It is not very pythonic to do those things with an attribute - usually, methods are better. However, an attribute is easier to add, and it is faster to access.

I am not sure whether I got the "full subcategory" business right in all cases.



---

archive/issue_comments_111074.json:
```json
{
    "body": "Attachment [trac10668-category_support_for_homsets.patch](tarball://root/attachments/some-uuid/ticket10668/trac10668-category_support_for_homsets.patch) by @simon-king-jena created at 2011-01-23 19:46:15\n\nCategory support for hom categories - depends on #10667",
    "created_at": "2011-01-23T19:46:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111074",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac10668-category_support_for_homsets.patch](tarball://root/attachments/some-uuid/ticket10668/trac10668-category_support_for_homsets.patch) by @simon-king-jena created at 2011-01-23 19:46:15

Category support for hom categories - depends on #10667



---

archive/issue_comments_111075.json:
```json
{
    "body": "Hi Simon!\n\nI finally got to work on this. See:\n\nhttp://combinat.sagemath.org/patches/file/tip/category-hom_methods-nt.patch\n\nIt's just a proof of concept. The core of the patch implementing the\ninfrastructure is about 10 lines of code. The rest is (partially)\nadapting the category code to make use of that infrastructure.  I\nhaven't run all tests, and there are a couple things failing here and\nthere, but it should be about correct. At least the tests of\nmodules_with_basis basically pass :-)\n\n# About attributes for specifying homset structures / full sub categories\n\nI much prefer to use methods instead:\n\n- This is consistent with what has been done so far (with\n  the method super_categories, ...)\n\n- It is easier for a subclass to override\n\n- It's only a tiny bit more verbose, since anyway one should write a\n  doctest for it, and since most categories do not have an __init__.\n\n\n# About full subcategories\n\nI totally agree that we want this concept. I am not sure yet about the\nsyntax though. In the draft, I have implemented a separate method\n\"full_super_categories\". However most of the time, this is quite\nredundant with the super_categories method. So I'd rather have instead\nthe method super_categories include the information in its result. An\noption would be to use something like:\n\n    def super_categories(self):\n        return [ (Semigroups(), \"full\"), Monoids() ]\n\nThen full_super_categories and all_super_categories, ... would extract\nthe relevant information from the above.\n\nWe could be more fancy to avoid breaking backward compatibility:\n\n    def super_categories(self):\n        return annotated_list( [ (Semigroups(), \"full\"), Monoids() ])\n\nwhere annotated_list would be a helper class whose instances would\nbehave like usual lists, except that one could query annotations on\ntheir elements, as in:\n\n\t\"full\" in l.annotations(Semigroups())\n\n\n# Things that still need discussion\n\n- Do we want all morphisms, and in particular SetMorphism's to\n  systematically inherit from categories (that wasn't the case yet)\n\n- How should categories specify the class to use for their homsets?\n  This currently is done in a couple spots by having\n  C.HomCategory.ParentMethods inherit from some specific homset. But\n  that's quite hugly (ParentMethods is supposed to be an abstract\n  class with just generic methods). Or maybe, that won't be needed\n  anymore once things will be cleaned up: there will be a single\n  concrete Homset class, and all the rest will be provided by the\n  categories?\n\n- Where should the constructors for the various types of morphisms be\n  stored? In C.MorphismMethods? In C.ParentMethods (like is currently\n  done with module_morphism)? Elsewhere?\n\n- super_categories and friends should probably return tuples instead\n  of lists. That's safer, especially since their results are cached.\n\n- We probably want to move HomCategory in its own file\n\n- Do we want to keep C.hom_category() or use C.Homsets() instead, for\n  consistency with C.CartesianProducts() and such.\n\nCheers,\n\t\t\t\tNicolas",
    "created_at": "2011-02-25T09:53:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111075",
    "user": "https://github.com/nthiery"
}
```

Hi Simon!

I finally got to work on this. See:

http://combinat.sagemath.org/patches/file/tip/category-hom_methods-nt.patch

It's just a proof of concept. The core of the patch implementing the
infrastructure is about 10 lines of code. The rest is (partially)
adapting the category code to make use of that infrastructure.  I
haven't run all tests, and there are a couple things failing here and
there, but it should be about correct. At least the tests of
modules_with_basis basically pass :-)

# About attributes for specifying homset structures / full sub categories

I much prefer to use methods instead:

- This is consistent with what has been done so far (with
  the method super_categories, ...)

- It is easier for a subclass to override

- It's only a tiny bit more verbose, since anyway one should write a
  doctest for it, and since most categories do not have an __init__.


# About full subcategories

I totally agree that we want this concept. I am not sure yet about the
syntax though. In the draft, I have implemented a separate method
"full_super_categories". However most of the time, this is quite
redundant with the super_categories method. So I'd rather have instead
the method super_categories include the information in its result. An
option would be to use something like:

    def super_categories(self):
        return [ (Semigroups(), "full"), Monoids() ]

Then full_super_categories and all_super_categories, ... would extract
the relevant information from the above.

We could be more fancy to avoid breaking backward compatibility:

    def super_categories(self):
        return annotated_list( [ (Semigroups(), "full"), Monoids() ])

where annotated_list would be a helper class whose instances would
behave like usual lists, except that one could query annotations on
their elements, as in:

	"full" in l.annotations(Semigroups())


# Things that still need discussion

- Do we want all morphisms, and in particular SetMorphism's to
  systematically inherit from categories (that wasn't the case yet)

- How should categories specify the class to use for their homsets?
  This currently is done in a couple spots by having
  C.HomCategory.ParentMethods inherit from some specific homset. But
  that's quite hugly (ParentMethods is supposed to be an abstract
  class with just generic methods). Or maybe, that won't be needed
  anymore once things will be cleaned up: there will be a single
  concrete Homset class, and all the rest will be provided by the
  categories?

- Where should the constructors for the various types of morphisms be
  stored? In C.MorphismMethods? In C.ParentMethods (like is currently
  done with module_morphism)? Elsewhere?

- super_categories and friends should probably return tuples instead
  of lists. That's safer, especially since their results are cached.

- We probably want to move HomCategory in its own file

- Do we want to keep C.hom_category() or use C.Homsets() instead, for
  consistency with C.CartesianProducts() and such.

Cheers,
				Nicolas



---

archive/issue_comments_111076.json:
```json
{
    "body": "Replying to [comment:16 nthiery]:\n\nSome notes after face to face discussion with Simon:\n\n>  - Do we want all morphisms, and in particular SetMorphism's to\n>    systematically inherit from categories (that wasn't the case yet)\n\nEventually yes.\n\n>  - How should categories specify the class to use for their homsets?\n>    This currently is done in a couple spots by having\n>    C.HomCategory.ParentMethods inherit from some specific homset. But\n>    that's quite hugly (ParentMethods is supposed to be an abstract\n>    class with just generic methods). Or maybe, that won't be needed\n>    anymore once things will be cleaned up: there will be a single\n>    concrete Homset class, and all the rest will be provided by the\n>    categories?\n\nEach category should have a `Homset` attribute specifying which\nconcrete class to use for its homset. The default value for that\nattribute (implemented as a lazy attribute) is too pickup the first\nnon default Homset attribute in the list of full_super_categories(),\nor sage.category.homset.Homset if there is none.\n\n>  - Where should the constructors for the various types of morphisms be\n>    stored? In C.MorphismMethods? In C.ParentMethods (like is currently\n>    done with module_morphism)? Elsewhere?\n\nFor `A` a parent, `A.hom(on_basis = [data],...)` would call\n`A.morphism_on_basis(data,...)`. This `morphism_on_basis` could\ntypically be implemented in `A`, or in `C.ParentMethods` for `C` the\ncategory of `A`.\n\nThere are 5-6 explicit hom functions in Sage that would need to be\ngeneralized to accept this syntax, while keeping backward\ncompatibility if no keyword is specified.\n\n>  - super_categories and friends should probably return tuples instead\n>    of lists. That's safer, especially since their results are cached.\n\nThe new `_super_categories` lazy attribute should be a tuple. In the\nlong run, all_super_categories and friends would best return tuples\nfor safety (especially since they are cached). Probably\nsuper_categories as well. It would be good to allow soon\nsuper_categories to return a tuple. However this might induce speed\nregression in the C3 implementation.\n\n>  - We probably want to move HomCategory in its own file\n\n+1\n\n>  - Do we want to keep C.hom_category() or use C.Homsets() instead, for\n>    consistency with C.CartesianProducts() and such.\n\nThat would make sense. Comments anyone?\n\nLittle inconvenient: possible confusion between `C.Homset` (the\nconcrete class to be used for homsets in this category) and\n`C.Homsets()` (the category of homsets in this category).\n\n\t\t\t\tSimon and Nicolas",
    "created_at": "2011-11-15T15:16:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111076",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:16 nthiery]:

Some notes after face to face discussion with Simon:

>  - Do we want all morphisms, and in particular SetMorphism's to
>    systematically inherit from categories (that wasn't the case yet)

Eventually yes.

>  - How should categories specify the class to use for their homsets?
>    This currently is done in a couple spots by having
>    C.HomCategory.ParentMethods inherit from some specific homset. But
>    that's quite hugly (ParentMethods is supposed to be an abstract
>    class with just generic methods). Or maybe, that won't be needed
>    anymore once things will be cleaned up: there will be a single
>    concrete Homset class, and all the rest will be provided by the
>    categories?

Each category should have a `Homset` attribute specifying which
concrete class to use for its homset. The default value for that
attribute (implemented as a lazy attribute) is too pickup the first
non default Homset attribute in the list of full_super_categories(),
or sage.category.homset.Homset if there is none.

>  - Where should the constructors for the various types of morphisms be
>    stored? In C.MorphismMethods? In C.ParentMethods (like is currently
>    done with module_morphism)? Elsewhere?

For `A` a parent, `A.hom(on_basis = [data],...)` would call
`A.morphism_on_basis(data,...)`. This `morphism_on_basis` could
typically be implemented in `A`, or in `C.ParentMethods` for `C` the
category of `A`.

There are 5-6 explicit hom functions in Sage that would need to be
generalized to accept this syntax, while keeping backward
compatibility if no keyword is specified.

>  - super_categories and friends should probably return tuples instead
>    of lists. That's safer, especially since their results are cached.

The new `_super_categories` lazy attribute should be a tuple. In the
long run, all_super_categories and friends would best return tuples
for safety (especially since they are cached). Probably
super_categories as well. It would be good to allow soon
super_categories to return a tuple. However this might induce speed
regression in the C3 implementation.

>  - We probably want to move HomCategory in its own file

+1

>  - Do we want to keep C.hom_category() or use C.Homsets() instead, for
>    consistency with C.CartesianProducts() and such.

That would make sense. Comments anyone?

Little inconvenient: possible confusion between `C.Homset` (the
concrete class to be used for homsets in this category) and
`C.Homsets()` (the category of homsets in this category).

				Simon and Nicolas



---

archive/issue_comments_111077.json:
```json
{
    "body": "Some food for thought (taken from Rings.HomCategory before #12876):\n\nWhen X is a quotient field, we can build a morphism from X to Y by\nspecifying the images of the generators. This is not something about\nthe category, because Y need not be a quotient field.",
    "created_at": "2012-04-30T08:11:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111077",
    "user": "https://github.com/nthiery"
}
```

Some food for thought (taken from Rings.HomCategory before #12876):

When X is a quotient field, we can build a morphism from X to Y by
specifying the images of the generators. This is not something about
the category, because Y need not be a quotient field.



---

archive/issue_comments_111078.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-22T20:06:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111078",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111079.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-06-22T22:24:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111079",
    "user": "https://github.com/nthiery"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_111080.json:
```json
{
    "body": "For the record: all long tests passed.",
    "created_at": "2014-06-22T22:25:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111080",
    "user": "https://github.com/nthiery"
}
```

For the record: all long tests passed.



---

archive/issue_comments_111081.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-23T01:34:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111081",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111082.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-07-03T01:21:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111082",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111083.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-07-11T08:42:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111083",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111084.json:
```json
{
    "body": "For the record: all long tests passed for me, and the pdf documentation compiles.",
    "created_at": "2014-07-11T09:32:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111084",
    "user": "https://github.com/nthiery"
}
```

For the record: all long tests passed for me, and the pdf documentation compiles.



---

archive/issue_comments_111085.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-15T09:20:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111085",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111086.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-15T10:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111086",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111087.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-15T10:41:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111087",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111088.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-18T09:15:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111088",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111089.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-03T09:21:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111089",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111090.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-03T09:31:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111090",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111091.json:
```json
{
    "body": "Work plan: Review this after #16340.",
    "created_at": "2014-10-13T15:26:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111091",
    "user": "https://github.com/simon-king-jena"
}
```

Work plan: Review this after #16340.



---

archive/issue_comments_111092.json:
```json
{
    "body": "Nicolas asked me to look at this here first, since he is now working on #16340.",
    "created_at": "2014-10-14T09:31:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111092",
    "user": "https://github.com/simon-king-jena"
}
```

Nicolas asked me to look at this here first, since he is now working on #16340.



---

archive/issue_comments_111093.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-10-14T13:49:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111093",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_111094.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T14:18:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111094",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111095.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T15:09:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111095",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111096.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T15:10:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111096",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111097.json:
```json
{
    "body": "For the record: I opened #17150, to make the conversion/coercion/call mechanism of homsets closer to what we do for other parents.",
    "created_at": "2014-10-14T18:33:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111097",
    "user": "https://github.com/simon-king-jena"
}
```

For the record: I opened #17150, to make the conversion/coercion/call mechanism of homsets closer to what we do for other parents.



---

archive/issue_comments_111098.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T18:55:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111098",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111099.json:
```json
{
    "body": "TODO:\n\nAdd documentation to the `category_of` method, which seems to return an instance of `HomsetsOf`. It is absolutely unclear to me what it is supposed to be or to do.",
    "created_at": "2014-10-14T19:03:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111099",
    "user": "https://github.com/simon-king-jena"
}
```

TODO:

Add documentation to the `category_of` method, which seems to return an instance of `HomsetsOf`. It is absolutely unclear to me what it is supposed to be or to do.



---

archive/issue_comments_111100.json:
```json
{
    "body": "I wonder about `Homsets.Endset.super_categories`, which returns `[Monoids()]`. Shouldn't this rather be *extra* super categories? If not, why not?",
    "created_at": "2014-10-14T19:17:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111100",
    "user": "https://github.com/simon-king-jena"
}
```

I wonder about `Homsets.Endset.super_categories`, which returns `[Monoids()]`. Shouldn't this rather be *extra* super categories? If not, why not?



---

archive/issue_comments_111101.json:
```json
{
    "body": "TODO:\n\nWe have\n\n```\nsage: Posets().Homsets().Endset().super_categories()\n[Category of homsets, Category of homsets of posets]\n```\n\nhence, in spite of `Homsets.Endset.super_categories`, the fact that endsets are monoids is not mentioned.",
    "created_at": "2014-10-14T19:21:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111101",
    "user": "https://github.com/simon-king-jena"
}
```

TODO:

We have

```
sage: Posets().Homsets().Endset().super_categories()
[Category of homsets, Category of homsets of posets]
```

hence, in spite of `Homsets.Endset.super_categories`, the fact that endsets are monoids is not mentioned.



---

archive/issue_comments_111102.json:
```json
{
    "body": "Why am I logged out of trac after few seconds? This has happened at least 10 times this evening.\n\nAnyway.\n\nWhat is the point of `Modules.EndCategory`? Shouldn't it be implemented as an axiom `Endset`, by the framework provided in this ticket?",
    "created_at": "2014-10-14T19:43:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111102",
    "user": "https://github.com/simon-king-jena"
}
```

Why am I logged out of trac after few seconds? This has happened at least 10 times this evening.

Anyway.

What is the point of `Modules.EndCategory`? Shouldn't it be implemented as an axiom `Endset`, by the framework provided in this ticket?



---

archive/issue_comments_111103.json:
```json
{
    "body": "The good news: All doctests pass. But I think it needs work, to address the concerns expressed in my previous comments.",
    "created_at": "2014-10-14T19:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111103",
    "user": "https://github.com/simon-king-jena"
}
```

The good news: All doctests pass. But I think it needs work, to address the concerns expressed in my previous comments.



---

archive/issue_comments_111104.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-10-14T19:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111104",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_111105.json:
```json
{
    "body": "Replying to [comment:48 SimonKing]:\n> TODO:\n> \n> We have\n> {{{\n> sage: Posets().Homsets().Endset().super_categories()\n> [Category of homsets, Category of homsets of posets]\n> }}}\n> hence, in spite of `Homsets.Endset.super_categories`, the fact that endsets are monoids is not mentioned.\n\nChanging `Homsets.Endset.super_categories` into `extra_supercategories` does not help. Nicolas, do you know how to fix that?",
    "created_at": "2014-10-14T19:55:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111105",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:48 SimonKing]:
> TODO:
> 
> We have
> {{{
> sage: Posets().Homsets().Endset().super_categories()
> [Category of homsets, Category of homsets of posets]
> }}}
> hence, in spite of `Homsets.Endset.super_categories`, the fact that endsets are monoids is not mentioned.

Changing `Homsets.Endset.super_categories` into `extra_supercategories` does not help. Nicolas, do you know how to fix that?



---

archive/issue_comments_111106.json:
```json
{
    "body": "Replying to [comment:50 SimonKing]:\n> The good news: All doctests pass. But I think it needs work, to address the concerns expressed in my previous comments.\n\nOops, I made a wrong test. When using extra_supercategories, the following does give the correct result:\n\n```\nsage: Posets().Homsets().Endset().is_subcategory(Monoids())\nTrue\n```\n",
    "created_at": "2014-10-14T19:57:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111106",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:50 SimonKing]:
> The good news: All doctests pass. But I think it needs work, to address the concerns expressed in my previous comments.

Oops, I made a wrong test. When using extra_supercategories, the following does give the correct result:

```
sage: Posets().Homsets().Endset().is_subcategory(Monoids())
True
```




---

archive/issue_comments_111107.json:
```json
{
    "body": "Replying to [comment:51 SimonKing]:\n> Replying to [comment:48 SimonKing]:\n> > We have\n> > {{{\n> > sage: Posets().Homsets().Endset().super_categories()\n> > [Category of homsets, Category of homsets of posets]\n> > }}}\n> > hence, in spite of `Homsets.Endset.super_categories`, the fact that endsets are monoids is not mentioned.\n\nThe source of confusion is that the first entry above should have read\nas \"Category of endsets\". I just fixed that (a trivial thing in\n_repr_) and will push shortly.\n\nNow I have::\n\n```\nsage: Posets().Endsets().super_categories()\n[Category of endsets, Category of homsets of posets]\n```\n\n\nAn it's normal that monoids don't show up above because they are a\nsuper category of the category of endsets. Just as a double check:\n\n\n```\nsage: Posets().Endsets().is_subcategory(Monoids())\nTrue\nsage: Posets().Homsets().Endset().is_subcategory(Monoids())\nTrue\n```\n\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-10-14T20:01:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111107",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:51 SimonKing]:
> Replying to [comment:48 SimonKing]:
> > We have
> > {{{
> > sage: Posets().Homsets().Endset().super_categories()
> > [Category of homsets, Category of homsets of posets]
> > }}}
> > hence, in spite of `Homsets.Endset.super_categories`, the fact that endsets are monoids is not mentioned.

The source of confusion is that the first entry above should have read
as "Category of endsets". I just fixed that (a trivial thing in
_repr_) and will push shortly.

Now I have::

```
sage: Posets().Endsets().super_categories()
[Category of endsets, Category of homsets of posets]
```


An it's normal that monoids don't show up above because they are a
super category of the category of endsets. Just as a double check:


```
sage: Posets().Endsets().is_subcategory(Monoids())
True
sage: Posets().Homsets().Endset().is_subcategory(Monoids())
True
```


Cheers,
                                 Nicolas



---

archive/issue_comments_111108.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T20:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111108",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111109.json:
```json
{
    "body": "Replying to [comment:53 nthiery]:\n> The source of confusion is that the first entry above should have read\n> as \"Category of endsets\". I just fixed that (a trivial thing in\n> _repr_) and will push shortly.\n\nGood. Please also add a test to the super_categories method. I have just push some typo fixes.",
    "created_at": "2014-10-14T20:11:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111109",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:53 nthiery]:
> The source of confusion is that the first entry above should have read
> as "Category of endsets". I just fixed that (a trivial thing in
> _repr_) and will push shortly.

Good. Please also add a test to the super_categories method. I have just push some typo fixes.



---

archive/issue_comments_111110.json:
```json
{
    "body": "Now I went through the whole diff. The only remaining issues are \"Add documentation to the category_of method\" and the `_repr_` problem you are working at now.\n\nSo, time for me to call it a day :-)",
    "created_at": "2014-10-14T20:21:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111110",
    "user": "https://github.com/simon-king-jena"
}
```

Now I went through the whole diff. The only remaining issues are "Add documentation to the category_of method" and the `_repr_` problem you are working at now.

So, time for me to call it a day :-)



---

archive/issue_comments_111111.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T20:25:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111111",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111112.json:
```json
{
    "body": "Replying to [comment:49 SimonKing]:\n> What is the point of `Modules.EndCategory`? Shouldn't it be implemented as an axiom `Endset`, by the framework provided in this ticket?\n\nGood catch; that piece had not been refactored. Now it even works :-)",
    "created_at": "2014-10-14T20:27:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111112",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:49 SimonKing]:
> What is the point of `Modules.EndCategory`? Shouldn't it be implemented as an axiom `Endset`, by the framework provided in this ticket?

Good catch; that piece had not been refactored. Now it even works :-)



---

archive/issue_comments_111113.json:
```json
{
    "body": "Replying to [comment:56 SimonKing]:\n> Now I went through the whole diff. The only remaining issues are \"Add documentation to the category_of method\" and the `_repr_` problem you are working at now.\n\nThe second piece is done now. I am about to work on the doc of ``category_of``.\n\n> So, time for me to call it a day :-)\n\nYes indeed, thanks so much!",
    "created_at": "2014-10-14T20:28:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111113",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:56 SimonKing]:
> Now I went through the whole diff. The only remaining issues are "Add documentation to the category_of method" and the `_repr_` problem you are working at now.

The second piece is done now. I am about to work on the doc of ``category_of``.

> So, time for me to call it a day :-)

Yes indeed, thanks so much!



---

archive/issue_comments_111114.json:
```json
{
    "body": "Replying to [comment:47 SimonKing]:\n> I wonder about `Homsets.Endset.super_categories`, which returns `[Monoids()]`. Shouldn't this rather be *extra* super categories? If not, why not?\n\nDone.",
    "created_at": "2014-10-14T20:29:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111114",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:47 SimonKing]:
> I wonder about `Homsets.Endset.super_categories`, which returns `[Monoids()]`. Shouldn't this rather be *extra* super categories? If not, why not?

Done.



---

archive/issue_comments_111115.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T21:02:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111115",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111116.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-10-14T21:03:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111116",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_events_027471.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2014-10-14T21:03:44Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10615#event-27471"
}
```



---

archive/issue_comments_111117.json:
```json
{
    "body": "I believe all discussion points have been addressed. Hence back to\nneeds review.",
    "created_at": "2014-10-14T21:03:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111117",
    "user": "https://github.com/nthiery"
}
```

I believe all discussion points have been addressed. Hence back to
needs review.



---

archive/issue_comments_111118.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-15T08:58:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111118",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111119.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-15T09:16:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111119",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_111120.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-10-15T10:03:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111120",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_111121.json:
```json
{
    "body": "All tests pass and all issues have been addressed. Hence, it's a positive review, of course modulo #16340.",
    "created_at": "2014-10-15T10:03:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111121",
    "user": "https://github.com/simon-king-jena"
}
```

All tests pass and all issues have been addressed. Hence, it's a positive review, of course modulo #16340.



---

archive/issue_comments_111122.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-10-16T21:10:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111122",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_027472.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-10-16T21:10:30Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10615#event-27472"
}
```



---

archive/issue_comments_111123.json:
```json
{
    "body": "Thanks Simon :-) And thanks for coming over; that was a productive trip!",
    "created_at": "2014-10-16T21:23:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10615",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10615#issuecomment-111123",
    "user": "https://github.com/nthiery"
}
```

Thanks Simon :-) And thanks for coming over; that was a productive trip!
