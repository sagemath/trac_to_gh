# Issue 23933: Add vector_space_over method to finite fields

Issue created by migration from Trac.

Original creator: klee

Original creation time: 2017-11-07 06:16:58

`vector_space()` method of finite fields is only over prime subfield of the finite field. New `vector_space_over()` method returns a vector space isomorphic to the finite field viewed as a vector space over an arbitrary subfield of the finite field.

The essential functionality was already implemented in #20284, aka `RelativeFiniteFieldExtension`.  But it is presently not accessible easily. I took the implementation idea from the ticket and reimplemented it as a method to finite fields and made the interface straightforward.


```
sage: E = GF(16)
sage: F = GF(4)
sage: V, from_V, to_V = E.vector_space_over(F)
sage: V 
sage: from_V
Isomorphism:
  From: Vector space of dimension 2 over Finite Field in z2 of size 2^2
  To:   Finite Field in z4 of size 2^4
sage: to_V
Isomorphism:
  From: Finite Field in z4 of size 2^4
  To:   Vector space of dimension 2 over Finite Field in z2 of size 2^2
```



---

Comment by git created at 2017-11-07 06:19:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-11-07 06:20:21

Changing status from new to needs_review.


---

Comment by git created at 2017-11-07 06:25:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-07 06:38:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-11-12 11:21:51

Wouldn't be possible to exend the current `vector_space` method with extra optional arguments `subfield` (which would default to the prime field as it used to be) and `basis`?


---

Comment by klee created at 2017-11-12 11:56:13

Replying to [comment:6 vdelecroix]:
> Wouldn't be possible to exend the current `vector_space` method with extra optional arguments `subfield` (which would default to the prime field as it used to be) and `basis`?

That was my first attempt. That was not so neat and I gave up that approach, mainly because my code relies on the `vector_space` method, which is fundamental, and in this approach, the code would be recursive. 

Now that you suggest that, I will try that approach again, as I don't have any hard reason to argue that the approach should be bad.


---

Comment by git created at 2017-11-14 00:32:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-11-14 07:12:40

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-11-14 07:12:40

1. The name `FiniteFieldIsomorphism` is very misleading. Furthermore, as a general comment "isomorphism" is not a precise term. What about "linear isomorphism" as in?

```
sage: E = GF(16)
sage: F = GF(4)
sage: V = VectorSpace(F, 2)
sage: Hom(V,E)
Set of Morphisms (Linear Transformations)
from Vector space of dimension 2 over Finite Field in z2 of size 2^2
to Finite Field in z4 of size 2^4
```


2. What is the point of having empty classes `MorphismFiniteFieldToVectorSpace` and `MorphismVectorSpaceToFiniteField`? I would prefer to simply remove them and have

```diff
-        phi = MorphismVectorSpaceToFiniteField(V, self, from_V)
-        psi = MorphismFiniteFieldToVectorSpace(self, V, to_V)
+        from sage.categories.homset import Hom
+        from sage.categories.morphism import SetMorphism
+        phi = SetMorphism(Hom(V, self), from_V)
+        psi = SetMorphism(Hom(self, V), to_V)
```

  An other option is to move all the code in `vector_space` (computation of `C`, the functions `to_V`, `from_V`, etc) within the classes.

3. Did you notice the asymetry of categories

```
sage: E = GF(16)
sage: F = GF(4)
sage: V = VectorSpace(F, 4)
Set of Morphisms (Linear Transformations)
from Vector space of dimension 2 over Finite Field in z2 of size 2^2
to Finite Field in z4 of size 2^4
sage: Hom(E,V)
Set of Morphisms
from Finite Field in z4 of size 2^4
to Vector space of dimension 2 over Finite Field in z2 of size 2^2
in Category of finite enumerated additive commutative additive groups
```


4. In the function `to_V` you should use directly `V` and not `vector`

5. In your call to `matrix` it is much faster to also specify the base ring and the dimensions.


---

Comment by klee created at 2017-11-17 08:33:16

Replying to [comment:12 vdelecroix]:
> 1. The name `FiniteFieldIsomorphism` is very misleading. Furthermore, as a general comment "isomorphism" is not a precise term. What about "linear isomorphism" as in?
> {{{
> sage: E = GF(16)
> sage: F = GF(4)
> sage: V = VectorSpace(F, 2)
> sage: Hom(V,E)
> Set of Morphisms (Linear Transformations)
> from Vector space of dimension 2 over Finite Field in z2 of size 2^2
> to Finite Field in z4 of size 2^4
> }}}
> 
> 2. What is the point of having empty classes `MorphismFiniteFieldToVectorSpace` and `MorphismVectorSpaceToFiniteField`? I would prefer to simply remove them and have
> {{{#!diff
> -        phi = MorphismVectorSpaceToFiniteField(V, self, from_V)
> -        psi = MorphismFiniteFieldToVectorSpace(self, V, to_V)
> +        from sage.categories.homset import Hom
> +        from sage.categories.morphism import SetMorphism
> +        phi = SetMorphism(Hom(V, self), from_V)
> +        psi = SetMorphism(Hom(self, V), to_V)
> }}}
>   An other option is to move all the code in `vector_space` (computation of `C`, the functions `to_V`, `from_V`, etc) within the classes.

I modelled these classes after the corresponding classes in `sage/rings/number_field/maps.py`. Look at the `NumberFieldIsomorphism`, `MapVectorSpaceToNumberField`, `MapNumberFieldToVectorSpace`.

The point is to have a proper `_repr_()` method (the morphisms are printed as `Isomorphism`).

The classes `MorphismVectorSpaceToFiniteField` and `MorphismFiniteFieldToVectorSpace` are not empty.  They are extended from `FiniteFieldIsomorphism`. So including inherited methods, each of them has 4 updated methods compared with `SetMorphism`.

I guess that you think "finite field isomorphism" is misleading. The intended meaning is "vector space isomorphism" for finite fields. I reject "linear isomorphism" (I never heard of this term). `FiniteFieldLinearTransformation` or `FiniteFieldLinearMap` is ok, but I don't prefer them over `FiniteFieldIsomorphism`.


---

Comment by git created at 2017-11-17 08:54:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-11-17 08:57:35

Replying to [comment:13 klee]:
> Replying to [comment:12 vdelecroix]:
> > 1. The name `FiniteFieldIsomorphism` is very misleading. Furthermore, as a general comment "isomorphism" is not a precise term. What about "linear isomorphism" as in?
> > {{{
> > sage: E = GF(16)
> > sage: F = GF(4)
> > sage: V = VectorSpace(F, 2)
> > sage: Hom(V,E)
> > Set of Morphisms (Linear Transformations)
> > from Vector space of dimension 2 over Finite Field in z2 of size 2^2
> > to Finite Field in z4 of size 2^4
> > }}}
> > 
> > 2. What is the point of having empty classes `MorphismFiniteFieldToVectorSpace` and `MorphismVectorSpaceToFiniteField`? I would prefer to simply remove them and have
> > {{{#!diff
> > -        phi = MorphismVectorSpaceToFiniteField(V, self, from_V)
> > -        psi = MorphismFiniteFieldToVectorSpace(self, V, to_V)
> > +        from sage.categories.homset import Hom
> > +        from sage.categories.morphism import SetMorphism
> > +        phi = SetMorphism(Hom(V, self), from_V)
> > +        psi = SetMorphism(Hom(self, V), to_V)
> > }}}
> >   An other option is to move all the code in `vector_space` (computation of `C`, the functions `to_V`, `from_V`, etc) within the classes.
> 
> I modelled these classes after the corresponding classes in `sage/rings/number_field/maps.py`. Look at the `NumberFieldIsomorphism`, `MapVectorSpaceToNumberField`, `MapNumberFieldToVectorSpace`.
> 
> The point is to have a proper `_repr_()` method (the morphisms are printed as `Isomorphism`).
> 
> The classes `MorphismVectorSpaceToFiniteField` and `MorphismFiniteFieldToVectorSpace` are not empty.  They are extended from `FiniteFieldIsomorphism`. So including inherited methods, each of them has 4 updated methods compared with `SetMorphism`.

As you can see, `sage/rings/number_field/maps.py` implements the conversion from the domain to the image in their `_call_` method. This is what I proposed in the end of the point 2 in [This is the Trac macro *comment:12* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:12-macro). So I would better go for this option.

Now, if you don't like moving the implementation of `for_V` and `to_V` as a `_call_` method of the linear isomorphisms classes you should just make the `_repr_` method more configurable. No need to make a new class.

> I guess that you think "finite field isomorphism" is misleading. The intended meaning is "vector space isomorphism" for finite fields. I reject "linear isomorphism" (I never heard of this term). `FiniteFieldLinearTransformation` or `FiniteFieldLinearMap` is ok, but I don't prefer them over `FiniteFieldIsomorphism`. 

I do. Let me say what I imagine when I read each class name
 - `FiniteFieldIsomorphism` : an isomorphism between two finite fields
 - `FiniteFieldLinearTransformation`: a linear map between two finite fields


---

Comment by klee created at 2017-11-17 09:03:14

> 3. Did you notice the asymetry of categories
> {{{
> sage: E = GF(16)
> sage: F = GF(4)
> sage: V = VectorSpace(F, 4)
> Set of Morphisms (Linear Transformations)
> from Vector space of dimension 2 over Finite Field in z2 of size 2^2
> to Finite Field in z4 of size 2^4
> sage: Hom(E,V)
> Set of Morphisms
> from Finite Field in z4 of size 2^4
> to Vector space of dimension 2 over Finite Field in z2 of size 2^2
> in Category of finite enumerated additive commutative additive groups
> }}}

No. This looks ugly. 

What do mean by "asymmetry of categories"? I get

```
sage: category(Hom(E,V))
Category of homsets of additive monoids
sage: category(Hom(V,E))
Category of homsets of additive monoids
```

Do you mean the printing?

Anyway, is this related with this ticket?


---

Comment by klee created at 2017-11-17 14:50:43

Replying to [comment:15 vdelecroix]:
> I do. Let me say what I imagine when I read each class name
>  - `FiniteFieldIsomorphism` : an isomorphism between two finite fields
>  - `FiniteFieldLinearTransformation`: a linear map between two finite fields

I understand your concern. But just `LinearTransformation` is also misleading because these maps are vector space *isomorphisms*. But I will not insist. This is not a big deal to me.

> As you can see, `sage/rings/number_field/maps.py` implements the conversion from the domain to the image in their `_call_` method. This is what I proposed in the end of the point 2 in [This is the Trac macro *comment:12* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:12-macro). So I would better go for this option.
> 
> Now, if you don't like moving the implementation of `for_V` and `to_V` as a `_call_` method of the linear isomorphisms classes you should just make the `_repr_` method more configurable. No need to make a new class.

I doubt that I understand your suggestions well. It seems that you have a clear view of how to code the maps. So I invite you to modify the branch (now public) as you prefer. I am quite willing to accept your modifications as long as Sage gets a working `E.vector_space(F)` method :-)


---

Comment by vdelecroix created at 2017-11-17 16:46:24

Replying to [comment:18 klee]:
> Replying to [comment:15 vdelecroix]:
> > I do. Let me say what I imagine when I read each class name
> >  - `FiniteFieldIsomorphism` : an isomorphism between two finite fields
> >  - `FiniteFieldLinearTransformation`: a linear map between two finite fields
> 
> I understand your concern. But just `LinearTransformation` is also misleading because these maps are vector space *isomorphisms*. But I will not insist. This is not a big deal to me.

Indeed, they are *vector space* isomorphisms ;-)

> > As you can see, `sage/rings/number_field/maps.py` implements the conversion from the domain to the image in their `_call_` method. This is what I proposed in the end of the point 2 in [This is the Trac macro *comment:12* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:12-macro). So I would better go for this option.
> > 
> > Now, if you don't like moving the implementation of `for_V` and `to_V` as a `_call_` method of the linear isomorphisms classes you should just make the `_repr_` method more configurable. No need to make a new class.
> 
> I doubt that I understand your suggestions well. It seems that you have a clear view of how to code the maps. So I invite you to modify the branch (now public) as you prefer. I am quite willing to accept your modifications as long as Sage gets a working `E.vector_space(F)` method :-) 

I am trying something.


---

Comment by vdelecroix created at 2017-11-18 17:32:26

I implemented what I proposed (and also squashed your commits into one).

For the sake of this ticket there are several things to be fixed

1. The code does not work with

```
sage: F = GF(9)
sage: x = polygen(F)
sage: E.<y> = F.extension(x^3 - x + 1)
sage: E.vector_space(F)
Traceback (most recent call last):
...
AttributeError: 'PolynomialQuotientRing_field_with_category' object has no attribute 'vector_space'
```


2. There are no examples involving a custom field such as `F = GF(9, 't', modulus=(x^2+x-1))`

3. It would be better to not impose the subfield to have a coercion implemented. I would propose to allow to pass a morphism as argument to vector space instead of a subfield. (as you wish that could be a double use of `subfield` or an extra argument `inclusion_map`).

4. The example `E = GF(16)` and  `F = GF(4)` is by far too trivial. In this case you have `V = GF(p<sup>n)</sup>m` with the same n and m.
----
New commits:


---

Comment by klee created at 2017-11-19 03:42:08

Replying to [comment:20 vdelecroix]:
> I implemented what I proposed (and also squashed your commits into one).
> 
> For the sake of this ticket there are several things to be fixed
> 
> 1. The code does not work with
> {{{
> sage: F = GF(9)
> sage: x = polygen(F)
> sage: E.<y> = F.extension(x^3 - x + 1)
> sage: E.vector_space(F)
> Traceback (most recent call last):
> ...
> AttributeError: 'PolynomialQuotientRing_field_with_category' object has no attribute 'vector_space'
> }}}
> 
> 2. There are no examples involving a custom field such as `F = GF(9, 't', modulus=(x^2+x-1))`

Right. These "finite fields" are actually `PolynomialQuotientRing_field`. They are second citizen in terms of functionality as finite fields. My opinion is that finite fields defined with custom modulus should be reimplemented to be elevated to the first class citizen, and the current `PolynomialQuotientRing_field` is just a patch work.

Anyway this ticket (or at least me) does not deal with `PolynomialQuotientRing_field`.


---

Comment by vdelecroix created at 2017-11-19 11:00:25

Replying to [comment:21 klee]:
> Replying to [comment:20 vdelecroix]:
> > I implemented what I proposed (and also squashed your commits into one).
> > 
> > For the sake of this ticket there are several things to be fixed
> > 
> > 1. The code does not work with
> > {{{
> > sage: F = GF(9)
> > sage: x = polygen(F)
> > sage: E.<y> = F.extension(x^3 - x + 1)
> > sage: E.vector_space(F)
> > Traceback (most recent call last):
> > ...
> > AttributeError: 'PolynomialQuotientRing_field_with_category' object has no attribute 'vector_space'
> > }}}
> > 
> > 2. There are no examples involving a custom field such as `F = GF(9, 't', modulus=(x^2+x-1))`
> 
> Right. These "finite fields" are actually `PolynomialQuotientRing_field`. They are second citizen in terms of functionality as finite fields. My opinion is that finite fields defined with custom modulus should be reimplemented to be elevated to the first class citizen, and the current `PolynomialQuotientRing_field` is just a patch work.
> 
> Anyway this ticket (or at least me) does not deal with `PolynomialQuotientRing_field`.

Second example is not

```
sage: F = GF(9, 't', modulus=(x^2+x-1))
sage: type(F)
<class 'sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category'>
```



---

Comment by git created at 2017-11-19 15:14:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-11-20 02:15:23

Changing status from needs_work to needs_review.


---

Comment by klee created at 2017-11-24 04:59:59

Replying to [comment:20 vdelecroix]:
> I implemented what I proposed 

Would you explain why this is necessary? As far as I understand, `C` is just constructed and mutable, and this code will make a duplicate copy of `C`. Why don't we just keep the original `C`?


```
+        if C.is_mutable():
+            C = C.__copy__()
+            C.set_immutable()
```



---

Comment by vdelecroix created at 2017-11-24 11:21:19

Replying to [comment:25 klee]:
> Replying to [comment:20 vdelecroix]:
> > I implemented what I proposed 
> 
> Would you explain why this is necessary? As far as I understand, `C` is just constructed and mutable, and this code will make a duplicate copy of `C`. Why don't we just keep the original `C`?
> 
> {{{
> +        if C.is_mutable():
> +            C = C.__copy__()
> +            C.set_immutable()
> }}}

The original `C` is kept if it is immutable which is the way to go from the point of view of the constructor. If you want to avoid the copy in your function, make the matrix argument immutable first...


---

Comment by klee created at 2017-11-24 13:53:51

Replying to [comment:26 vdelecroix]:
> Replying to [comment:25 klee]:
> > Replying to [comment:20 vdelecroix]:
> > > I implemented what I proposed 
> > 
> > Would you explain why this is necessary? As far as I understand, `C` is just constructed and mutable, and this code will make a duplicate copy of `C`. Why don't we just keep the original `C`?
> > 
> > {{{
> > +        if C.is_mutable():
> > +            C = C.__copy__()
> > +            C.set_immutable()
> > }}}
> 
> The original `C` is kept if it is immutable which is the way to go from the point of view of the constructor. If you want to avoid the copy in your function, make the matrix argument immutable first...

I know that by reading your code. From my point of view, the classes are only for `vector_space()` method or at least used only internally. Then I wonder why we worry that `C` could be mutable and that `C` could be changed after the object was constructed (which seems the situation that you worry about). In other words, I doubt that your code above could be useful really, unless you convince me...

Is your code just a common idiom in Sage when an argument for a constructor is a matrix, which could be mutable (so that the code is required as a convention)?


---

Comment by vdelecroix created at 2017-11-24 14:55:53

Replying to [comment:27 klee]:
> Replying to [comment:26 vdelecroix]:
> > Replying to [comment:25 klee]:
> > > Replying to [comment:20 vdelecroix]:
> > > > I implemented what I proposed 
> > > 
> > > Would you explain why this is necessary? As far as I understand, `C` is just constructed and mutable, and this code will make a duplicate copy of `C`. Why don't we just keep the original `C`?
> > > 
> > > {{{
> > > +        if C.is_mutable():
> > > +            C = C.__copy__()
> > > +            C.set_immutable()
> > > }}}
> > 
> > The original `C` is kept if it is immutable which is the way to go from the point of view of the constructor. If you want to avoid the copy in your function, make the matrix argument immutable first...
> 
> I know that by reading your code. From my point of view, the classes are only for `vector_space()` method or at least used only internally. Then I wonder why we worry that `C` could be mutable and that `C` could be changed after the object was constructed (which seems the situation that you worry about). In other words, I doubt that your code above could be useful really, unless you convince me...
> 
> Is your code just a common idiom in Sage when an argument for a constructor is a matrix, which could be mutable (so that the code is required as a convention)?

For now, the class is only built with `vector_space` but nobody knows the future. If you feel better with

```
assert C.is_immutable()
```

It is also fine for me.


---

Comment by klee created at 2017-11-24 15:27:05

Replying to [comment:28 vdelecroix]:
> For now, the class is only built with `vector_space` but nobody knows the future. 

Ok. I see your motivation now. Then I would set the matrix `C` immutable in `vector_sapce` to prevent the copying. 

What other issues do you have for this ticket? Are you ok with `FiniteFieldVectorSpaceIsomorphism`?


---

Comment by klee created at 2017-11-24 15:34:03

Currently `inclusion_map` argument is redundant. I may delete it if you agree.


---

Comment by vdelecroix created at 2017-11-24 15:35:44

Replying to [comment:29 klee]:
> Replying to [comment:28 vdelecroix]:
> > For now, the class is only built with `vector_space` but nobody knows the future. 
> 
> Ok. I see your motivation now. Then I would set the matrix `C` immutable in `vector_sapce` to prevent the copying. 
> 
> What other issues do you have for this ticket?

I left a stupid comment

```
# from_V
# needs C
```

in `maps_finite_field.py`

If this ticket is duplicating some features of what used to be implemented in linear code, then some appropriate deprecation has to be done (possibly in later ticket but please do create them)

> Are you ok with `FiniteFieldVectorSpaceIsomorphism`?

I am.


---

Comment by vdelecroix created at 2017-11-24 15:36:21

Replying to [comment:30 klee]:
> Currently `inclusion_map` argument is redundant. I may delete it if you agree. 

Redundant with what?


---

Comment by klee created at 2017-11-24 15:37:25

Replying to [comment:32 vdelecroix]:
> Replying to [comment:30 klee]:
> > Currently `inclusion_map` argument is redundant. I may delete it if you agree. 
> 
> Redundant with what?

`subfield` argument can take a morphism.


---

Comment by vdelecroix created at 2017-11-24 15:37:56

Replying to [comment:33 klee]:
> Replying to [comment:32 vdelecroix]:
> > Replying to [comment:30 klee]:
> > > Currently `inclusion_map` argument is redundant. I may delete it if you agree. 
> > 
> > Redundant with what?
> 
> `subfield` argument can take a morphism.

Ha ok. Very good.


---

Comment by git created at 2017-11-24 16:10:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2017-11-24 16:27:16

Replying to [comment:31 vdelecroix]:
> If this ticket is duplicating some features of what used to be implemented in linear code, then some appropriate deprecation has to be done (possibly in later ticket but please do create them)

Right. First we need some discussion. See #24279.


---

Comment by klee created at 2017-11-25 01:34:57

By the way, I am positive on Vincent's part of the code.


---

Comment by vdelecroix created at 2017-11-25 11:43:56

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2017-11-25 11:43:56

Let's go then.


---

Comment by klee created at 2017-11-25 12:10:54

Replying to [comment:38 vdelecroix]:
> Let's go then.

Thank you. The branch is way better than it originally was :-)


---

Comment by vbraun created at 2017-12-14 12:40:01

Resolution: fixed
