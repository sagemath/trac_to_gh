# Issue 17807: Implement categories for super algebras/modules

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-03-24 01:34:51

Assignee: tscrim

CC:  nthiery darij

Keywords: super

After some design discussion, a proposal for an implementation is to be a subcategory of `Graded` algebras/modules whose default even/odd considers the given grading as being `ZZ / 2 ZZ` compatible. Thus it will have the following methods:

- `is_even()`
- `is_odd()`
- `is_even_odd()`

The API will be the user defines a `degree` method which is then called by `is_even_odd()` and taken mod 2. Therefore if the user wants to have a special grading group, then the user can override `is_even_odd()` to translate that into 0 or 1. The hook of `is_even_odd` also allows the user to change the super behavior away from the grading group (which will get used in #17096).


---

Comment by tscrim created at 2015-03-24 02:55:30

Changing status from new to needs_review.


---

Comment by tscrim created at 2015-03-24 02:55:30

New commits:


---

Comment by darij created at 2015-03-28 16:57:51


```
+ def Super(self, base_ring=None):
+ r"""
+ Return the subcategory of the super objects of ``self``.
```


Is this really a subcategory? Super Lie algebras are not Lie algebras and cannot be reasonably made into such short of taking the even part...


---

Comment by tscrim created at 2015-03-28 17:19:23

Good point (this is different than `Graded`, which is where I copied things from). Think we should just replace the word "sub" with "associated"? If so, I can go make this change (in about 2 hours).


---

Comment by darij created at 2015-03-28 17:25:14

I'd just say "Return the super-analogue of ``self``" (the word "analogue" is a bit weasel, but I think it's better to err on this side). In general, there should be a canonical embedding from `C` into `C.Super()`, not the other way round.

What do you mean by "Same as :meth:`Graded`"?


---

Comment by tscrim created at 2015-03-28 23:42:02

Replying to [comment:4 darij]:
> I'd just say "Return the super-analogue of ``self``" (the word "analogue" is a bit weasel, but I think it's better to err on this side). In general, there should be a canonical embedding from `C` into `C.Super()`, not the other way round.

It's more of there is not a forgetful functor from `C.super()` to `C`, but I'll make this change.

> What do you mean by "Same as :meth:`Graded`"?

Meaning I copied it. <.< >.>


---

Comment by git created at 2015-03-28 23:47:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-03-28 23:50:53

I've made the change. Although actually, forgetting the "super" doesn't change the multiplication, just removes the notion of supercommuting elements and the degree. So there is a forgetful functor at least, right (or am I overthinking things)?


---

Comment by darij created at 2015-03-29 14:41:29

Forgetting the grading on a superalgebra gives you an algebra, yes. But forgetting the grading on a Lie superalgebra does not give you a Lie algebra; it gives something weird and unnamed. So forgetful functors should only exist in specific categories.


---

Comment by tscrim created at 2015-03-29 17:57:22

True, but I think for now we can live with the slight abuse since there are not plans currently (at least by me) to implement Lie superalgebras. Then again, IDK how much of the code I've written wouldn't work in the category for Lie superalgebras. ehh...I think we can cross that bridge if/when that's an issue.


---

Comment by darij created at 2015-03-29 22:49:47

Sorry but the assumption that "super X are graded X" (or just "super X are X") is fundamentally wrong. The longer we keep it in, the harder it will be to cross that bridge. It already causes wrong results:

```
sage: C = HopfAlgebras(QQ).Super()
sage: C.super_categories()
[Category of hopf algebras over Rational Field,
 Category of super algebras over Rational Field]
```

Super Hopf algebras are not Hopf algebras. In a Hopf algebra,
` (xy)_{(1)} \otimes (xy)_{(2)} = x_{(1)} y_{(1)} \otimes x_{(2)} y_{(2)} `
(using sumfree Sweedler notation), while in a super Hopf algebra,
` (xy)_{(1)} \otimes (xy)_{(2)} = (-1)^{\deg y_{(1)} \deg x_{(2)}} x_{(1)} y_{(1)} \otimes x_{(2)} y_{(2)} `.

In other news: In the `lift_module_morphism` method for Clifford algebras, did you really mean `Graded` in

```
        return Cl.module_morphism(on_basis=f, codomain=self,
                                  category=AlgebrasWithBasis(self.base_ring()).Graded())
```

(and not `Super`)?


---

Comment by tscrim created at 2015-03-29 23:42:07

Then I guess we need to change the default super categories thingy and just be explicit about things.
So then the category hierarchy should be

```
SuperHopf    GradedHopf
    |           |
SuperAlg      Hopf
       \     /
         Alg
```

right? So we could do an explicit override of the `SuperHopf`'s super category (at least, this is probably one of the very few instances where a super object is different notation from the graded).


---

Comment by darij created at 2015-04-02 00:32:43

Replying to [comment:11 tscrim]:
> So we could do an explicit override of the `SuperHopf`'s super category (at least, this is probably one of the very few instances where a super object is different notation from the graded).

Sorry, I just don't like this whole paradigm where a category liberally makes assumptions that the subcategory has to override if they are not satisfied. The category framework was created to mirror the mathematical structure of algebraic categories (or so I have been told). Mathematically, there is no reason why a superX should canonically be an X; the fact that this holds for many of the standard Xes (algebras, modules, etc.) is not inherent to the notion of "super"ness but to these Xes, so it shouldn't be reflected in any automatic inheritance. Does the way you implemented `Super` require `SuperX` to derive from `X`?


---

Comment by tscrim created at 2015-04-02 04:39:13

Currently yes, but I'm going to change it so that you have to explicitly set X to be supercategory of superX.


---

Comment by darij created at 2015-04-02 04:41:42

Thank you!


---

Comment by git created at 2015-04-02 06:24:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-04-02 06:48:43

I'm not happy with this because of how certain things in the category hierarchy are respected, even in this new version. In particular:

```
sage: C = HopfAlgebras(ZZ).WithBasis().Super(); C
Category of super hopf algebras with basis over Integer Ring
sage: sorted(C.super_categories(), key=str)
[Category of hopf algebras with basis over Integer Ring,
 Category of super algebras over Integer Ring,
 Category of super algebras with basis over Integer Ring]
```

I don't know a way around this currently...

However I'm starting to wonder if this is what we want. If we want two notions of super, the first is via a functorial construction for things like modules and algebras (and rings once the graded versions get implemented), and for other things if we want the `Super` call to go to a `Category_over_base_ring` subclass. Mainly the first examples satisfy the conditions of the regressive covariant functorial construction, but the others, like Hopf and Lie algebras, don't. Doing things this way also seem like they will simplify the implementation as a fringe benefit. Thoughts (inc. from Nicolas)?


---

Comment by nthiery created at 2015-04-07 12:31:21

Replying to [comment:16 tscrim]:
>  (inc. from Nicolas)?

I don't have the big picture at this point. Let's discuss this in Montreal!


---

Comment by tscrim created at 2015-04-13 14:27:03

#18174 will simplify this a bit.


---

Comment by git created at 2015-04-14 21:19:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-14 22:00:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-04-14 22:26:08

Changing keywords from "super" to "super, sd67".


---

Comment by git created at 2015-04-16 05:30:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-16 05:39:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-09 12:20:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-03 23:08:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-03 23:14:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2015-10-03 23:15:59

LGTM now; thanks for the commit!

For posterity: There are design issues that I don't fully like, but that are standard for Sage.


---

Comment by tscrim created at 2015-10-03 23:16:27

Changing status from needs_review to positive_review.


---

Comment by git created at 2015-10-06 02:13:31

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2015-10-06 02:13:31

Changing status from positive_review to needs_review.


---

Comment by tscrim created at 2015-10-06 02:14:23

One test should have been marked as `# indirect doctest`.


---

Comment by tscrim created at 2015-10-06 02:14:23

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-10-12 07:16:38

Resolution: fixed
