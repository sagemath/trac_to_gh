# Issue 29602: Implement `_zero_matrix` for dense integer and rational matrices

Issue created by migration from https://trac.sagemath.org/ticket/29839

Original creator: @kliem

Original creation time: 2020-06-10 13:12:29

Keywords: incidence matrix, zero entries

We implement a method that obtains a new `GF(2)` matrix that contains 1 if and only if the corresponding entry is zero.

Motivation: This method is useful to obtain the incidence matrix of of a polyhedron from the slack matrix in #29837.


---

Comment by @kliem created at 2020-06-10 13:13:34

Better suggestions for a name would be welcome. `_zero_matrix` is somewhat strange.


---

Comment by @kliem created at 2020-06-10 13:13:56

Changing status from new to needs_review.


---

Comment by @kliem created at 2020-06-10 13:13:56

New commits:


---

Comment by dimpase created at 2020-06-10 13:57:34

zero_pattern_matrix?


---

Comment by @kliem created at 2020-06-10 14:00:15

Better anyway. With public or semiprivate? (leading underscore).

Btw, there is a bug here. I copied this from `_mod_two` which apparently sets up the parent incorrect:


```
M = Matrix(ZZ, [[0,1],[0,1]])
sage: M._mod_int(2).transpose()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-8587f9dc80b2> in <module>()
----> 1 M._mod_int(Integer(2)).transpose()

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/matrix/matrix_mod2_dense.pyx in sage.matrix.matrix_mod2_dense.Matrix_mod2_dense.transpose (build/cythonized/sage/matrix/matrix_mod2_dense.c:10873)()
   1400             1
   1401         """
-> 1402         cdef Matrix_mod2_dense A = self.new_matrix(ncols = self._nrows,  nrows = self._ncols)
   1403         if self._nrows == 0 or self._ncols == 0:
   1404             return A

TypeError: Cannot convert sage.matrix.matrix_modn_dense_float.Matrix_modn_dense_float to sage.matrix.matrix_mod2_dense.Matrix_mod2_dense
sage:  MS = matrix_space.MatrixSpace(IntegerModRing(2), self._nrows, self._ncols)
```



---

Comment by dimpase created at 2020-06-10 14:01:51

shouldn't `def _zero_matrix(self):` (or rather named as in comment:3) be `cpdef`, to facilitate calling from Cython?


---

Comment by dimpase created at 2020-06-10 14:05:07

Replying to [comment:4 gh-kliem]:
> Better anyway. With public or semiprivate? (leading underscore).
> 
> Btw, there is a bug here. I copied this from `_mod_two` which apparently sets up the parent incorrect:
> 
> {{{
> M = Matrix(ZZ, [[0,1],[0,1]])
> sage: M._mod_int(2).transpose()
> ---------------------------------------------------------------------------
> TypeError                                 Traceback (most recent call last)
> <ipython-input-4-8587f9dc80b2> in <module>()
> ----> 1 M._mod_int(Integer(2)).transpose()
> 
> /srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/matrix/matrix_mod2_dense.pyx in sage.matrix.matrix_mod2_dense.Matrix_mod2_dense.transpose (build/cythonized/sage/matrix/matrix_mod2_dense.c:10873)()
>    1400             1
>    1401         """
> -> 1402         cdef Matrix_mod2_dense A = self.new_matrix(ncols = self._nrows,  nrows = self._ncols)
>    1403         if self._nrows == 0 or self._ncols == 0:
>    1404             return A
> 
> TypeError: Cannot convert sage.matrix.matrix_modn_dense_float.Matrix_modn_dense_float to sage.matrix.matrix_mod2_dense.Matrix_mod2_dense
> sage:  MS = matrix_space.MatrixSpace(IntegerModRing(2), self._nrows, self._ncols)
> }}}

why can't you use `mod`?

```
sage: M = Matrix(ZZ, [[0,1],[0,1]])
sage: M.mod(2)
[0 1]
[0 1]
```



---

Comment by @kliem created at 2020-06-10 14:34:41

Because it is slow. I just copied the construction of the parent from `_mod_two`.
I really don't know why, but `change_ring` is really slow (e.g. for `ZZ` -> `GF(2)`). It should be improved, but maybe not in this ticket.

`_mod_two` uses the ring with two elements to obtain the parent. However, `get_matrix_class` gives you `modn` in this case. It gives you `mod2` if you pass the field with two elements.


---

Comment by @kliem created at 2020-06-10 14:35:18

And `M.mod` is really not what I want. I just illustrated this bug.


---

Comment by @kliem created at 2020-06-10 14:44:43

Changing keywords from "incidence matrix, zero entries" to "incidence matrix, zero pattern".


---

Comment by git created at 2020-06-10 14:47:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-10 14:47:48

New commits:


---

Comment by @kliem created at 2020-06-10 20:05:00

Changing status from needs_review to needs_work.


---

Comment by @kliem created at 2020-06-10 20:05:00

I really want a new integer matrix.


---

Comment by git created at 2020-06-10 22:36:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-10 22:37:46

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2020-06-10 22:43:11

Have you tried doing either `x = 1 - x` or `x = not x`? These should be fast as they avoid intermediate function calls and the first should work for any ring (maybe replace `1` with `one` where `one = self.base_ring().one()`).


---

Comment by @kliem created at 2020-06-10 23:40:41

Replying to [comment:15 tscrim]:
> Have you tried doing either `x = 1 - x` or `x = not x`? These should be fast as they avoid intermediate function calls and the first should work for any ring (maybe replace `1` with `one` where `one = self.base_ring().one()`).

When? As in `slack_matrix.apply_map`?

This is slow, whatever I do.

If `slack_matrix` is the `slack_matrix` of the `polytopes.associahedron(['A', 9])` obtained e.g. with

```
sage: def get_slack(P):
....:     self = P
....:     Vrep_matrix = matrix(self.base_ring(), self.Vrepresentation())
....:     Hrep_matrix = matrix(self.base_ring(), self.Hrepresentation())
....:     hom_helper = matrix(self.base_ring(), [1 if v.is_vertex() else 0 for v
....:  in self.Vrepresentation()])
....:     hom_Vrep = hom_helper.stack(Vrep_matrix.transpose())
....:     slack_matrix = (Hrep_matrix * hom_Vrep).transpose()
....:     return slack_matrix

sage: slack_matrix = get_slack(polytopes.associahedron(['A', 9])
```


than the solution of this ticket needs about 15 ms. In comparison to


```
sage: %time incidence_matrix = M.apply_map(lambda y: not y, R=M.base_ring())
CPU times: user 281 ms, sys: 15.8 ms, total: 296 ms
Wall time: 296 ms
```


(which is 100 ms slower than the trivial `lambda y: y`).


---

Comment by tscrim created at 2020-06-11 01:15:25

For the `x = 1 - x`, I was thinking the matrix was already a 01 matrix (and perhaps you were trying to do it in-place). This is also slower than simply doing this?

```python
        cdef Py_ssize_t i, j
        for i from 0 <= i < self._nrows:
            for j from 0 <= j < self._ncols:
                if not self.get_unsafe(i, j):
                    M.set_unsafe_si(i, j, 1)
```

This is more generic, but perhaps it is slower for special cases (e.g., rationals) because it goes partially through Python.

I have some questions:

Should this be lifted up to a generic matrix method with a generic implementation of `get_is_zero_unsafe`?

Do you want to be an integer matrix or a mod2 matrix? The latter seems like it would be more memory efficient and possibly faster.

I am not sure it is safe to assume the initialized matrix is 0. Is this documented somewhere?


---

Comment by @kliem created at 2020-06-11 07:25:38

Good point. It is documented that the entries are not initialized.

So the following would be better:

```
cdef Matrix_integer_dense M = self._new(self._nrows, self._ncols)
cdef Py_ssize_t i, j
    for i from 0 <= i < self._nrows:
        for j from 0 <= j < self._ncols:
            if self.get_is_zero_unsafe(i, j):
                M.set_unsafe_si(i, j, 1)
            else:
                M.set_unsafe_si(i, j, 0)
```


For integers the difference between `if not self.get_unsafe(i, j)` and `if get_is_zero_unsafe(i, j)` is a factor of three. For rationals the difference is a factor of about 20.


---

Comment by @kliem created at 2020-06-11 07:28:23

`M.set_unsafe_si(i, j, self.get_is_zero_unsafe(i, j))` is a bit faster yet and almost the speed of not correctly initializing (26 ms vs 23 ms).


---

Comment by git created at 2020-06-11 09:21:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-11 09:28:29

the


---

Comment by git created at 2020-06-11 09:31:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-11 09:41:42

If you feel like `get_is_zero_unsafe` should be improved in other classes as well, please tell me. At the moment I would just leave it being optimized for those two classes that I need.


---

Comment by tscrim created at 2020-06-11 14:24:53

Thank you. It is looking a lot better. One other place where it might make sense to do additional specialized `get_is_zero_unsafe` would be cyclo, gf2e, gfpn, and modn matrices, but these can wait if they turn out to be harder to do (I can also do some of them tomorrow). A few more little things:

I don't understand this line:

```
cdef object one = M._coerce_element(1)
```

Why not use `R.one()`? Also, similar to one of my previous questions, do we want this to be over the general ring? In principle, the matrix could be over a rng, and so the result might not be valid over `R` but the operation/output still makes sense. I think whatever output type we want (either as a `ZZ`-matrix or a `Zmod(2)`-matrix) is fine as long as we document it.


```diff
-        NOTE::
+        .. NOTE::
 
-            This method can be optimized by improving :meth:`get_is_zero_unsafe`` for derived matrix classes.
+            This method can be optimized by improving :meth:`get_is_zero_unsafe` for derived matrix classes.
```



```diff
-.. warning::
+.. WARNING::
```


Do we want `get_is_zero_unsafe` to return a `bint` instead of an `int`? I don't hold a strong opinion, but I generally prefer the most restrictive/informative return type possible.


---

Comment by @kliem created at 2020-06-11 16:48:48

I prefer `int` for the following reason: It can be useful, if we guarantee that the value is either `1` or `0`. I'm not using it like this anymore, but I wouldn't burn bridges. This way we really guarantee that the method returns `1` or `0`. If we return a `bint` this would leave the impression that the exact value doesn't matter.


```
sage: cython('''
....: def foo(int a):
....:     cdef bint b = a
....:     return 2 - b
....: ''')
```


This is an example that `bint` really can take any integer value. If you run `foo(10)`, it will return `-8`.


---

Comment by @kliem created at 2020-06-11 18:17:22

Replying to [comment:24 tscrim]:
> Thank you. It is looking a lot better. One other place where it might make sense to do additional specialized `get_is_zero_unsafe` would be cyclo, gf2e, gfpn, and modn matrices, but these can wait if they turn out to be harder to do (I can also do some of them tomorrow). A few more little things:
> 
> I don't understand this line:
> {{{
> cdef object one = M._coerce_element(1)
> }}}
> Why not use `R.one()`? Also, similar to one of my previous questions, do we want this to be over the general ring? In principle, the matrix could be over a rng, and so the result might not be valid over `R` but the operation/output still makes sense.

I don't find an example of a matrix with base ring not a ring. It is mentioned in the constructor that such things exists, but I can't find it. Can you help me out?

We could have another optional argument, where you specify what you want to fill the matrix with, if not ones.

> I think whatever output type we want (either as a `ZZ`-matrix or a `Zmod(2)`-matrix) is fine as long as we document it.
> 
> {{{#!diff
> -        NOTE::
> +        .. NOTE::
>  
> -            This method can be optimized by improving :meth:`get_is_zero_unsafe`` for derived matrix classes.
> +            This method can be optimized by improving :meth:`get_is_zero_unsafe` for derived matrix classes.
> }}}
> 
> {{{#!diff
> -.. warning::
> +.. WARNING::
> }}}
> 
> Do we want `get_is_zero_unsafe` to return a `bint` instead of an `int`? I don't hold a strong opinion, but I generally prefer the most restrictive/informative return type possible.


---

Comment by git created at 2020-06-11 20:08:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-11 20:09:02

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-06-11 20:09:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-06-12 00:44:33

Sage explicitly only allows rings to be passed to matrices, despite what the documentation currently says:

```
sage: S = Semigroups().example()
sage: A = S.algebra(QQ)
sage: M = matrix(A, [[A.zero()]])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-5bed397dad10> in <module>()
----> 1 M = matrix(A, [[A.zero()]])

/home/uqtscrim/sage/local/lib/python3.7/site-packages/sage/matrix/constructor.pyx in sage.matrix.constructor.matrix (build/cythonized/sage/matrix/constructor.c:2479)()
    633     """
    634     immutable = kwds.pop('immutable', False)
--> 635     M = MatrixArgs(*args, **kwds).matrix()
    636     if immutable:
    637         M.set_immutable()

/home/uqtscrim/sage/local/lib/python3.7/site-packages/sage/matrix/args.pyx in sage.matrix.args.MatrixArgs.matrix (build/cythonized/sage/matrix/args.c:7668)()
    650             True
    651         """
--> 652         self.finalize()
    653 
    654         cdef Matrix M

/home/uqtscrim/sage/local/lib/python3.7/site-packages/sage/matrix/args.pyx in sage.matrix.args.MatrixArgs.finalize (build/cythonized/sage/matrix/args.c:10264)()
    932 
    933         if self.space is None:
--> 934             self.space = MatrixSpace(self.base, self.nrows, self.ncols,
    935                     sparse=self.sparse, **self.kwds)
    936 

/home/uqtscrim/sage/local/lib/python3.7/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1741)()
    320         """
    321         if cls.classcall is not None:
--> 322             return cls.classcall(cls, *args, **kwds)
    323         else:
    324             # Fast version of type.__call__(cls, *args, **kwds)

/home/uqtscrim/sage/local/lib/python3.7/site-packages/sage/matrix/matrix_space.py in __classcall__(cls, base_ring, nrows, ncols, sparse, implementation, **kwds)
    489         """
    490         if base_ring not in _Rings:
--> 491             raise TypeError("base_ring (=%s) must be a ring"%base_ring)
    492         nrows = int(nrows)
    493         if ncols is None:

TypeError: base_ring (=Algebra of An example of a semigroup: the left zero semigroup over Rational Field) must be a ring
```

So that might not something we need to worry about right now. Irregardless, I am still not convinced that we should be returning a matrix over the base ring and not either *Z* or *Z*<sub>2</sub>.

I see your argument for not using `bint`; it is actually a little disheartening to see that code block; but I see that as garbage-in, garbage-out. My counter point would be the `is_zero_unsage` is suppose to be recording a true/false value, which is what the `bint` is suppose to be for (equivalent to a `bool` in C). Plus it is standard that `1` is `True`. So even if it is not enforacble, it still carries contextual significance.


---

Comment by @kliem created at 2020-06-12 06:55:07

As for other rings I think I have questions with all of them:

- `gfpn` is `get_unsafe_int` guaranteed to be `0` if the entry is zero, or might it be `0` mod cardinality of field, if not, where do I find the cardinality?
- similar for `gf2e` and `modn`
- `cyclo` (I just realized this is probably easy)

EDIT:

For `gf2e` this is indirectly confirmed in `rings/finite_rings/element_givaro.pyx` in `fetch_int`.


---

Comment by git created at 2020-06-12 08:56:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-06-13 01:33:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-06-13 01:35:42

Okay, this is an implementation for all of the specialized dense matrices I mentioned before.

I really don't like how in the gf2e it redirects through python for such a key feature with `get_unsafe`. This needs to be removed and is now #29853. Likely the way to do it will be based on what is done for gfpn.

Some additions of better `__bool__` methods:

```
sage: K.<z> = CyclotomicField(3)
sage: A = matrix(K, 4, 3, [0, -z, -2, -2*z + 2, 2*z, z, z, 1-z, 2+3*z, z, 1+z, 0])
sage: %timeit bool(A)
10000000 loops, best of 5: 86.2 ns per loop
sage: %timeit bool(Z)
10000000 loops, best of 5: 152 ns per loop
```

versus before:

```
sage: %timeit bool(A)
The slowest run took 70.37 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 5: 8.49 µs per loop
sage: Z = matrix(K, 4, 3, 0)
sage: %timeit bool(Z)
The slowest run took 7.43 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 5: 50 µs per loop
```


I also made changes in other places where `get_is_unsafe_zero()` could be used. Like the above and in your use case, this likely has (potentially significantly) sped things up.


---

Comment by tscrim created at 2020-06-13 01:35:42

Changing status from needs_work to needs_review.


---

Comment by git created at 2020-06-13 01:59:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-06-13 02:05:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-06-13 02:23:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-06-13 02:25:35

Okay, that takes care of the sparse matrices and symbolic matrices.

Slightly surprisingly, the gap matrices don't benefit from not going through Sage (well, at least for integer matrices).

I am done now.


---

Comment by git created at 2020-06-13 09:38:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-13 09:39:14

IMO this is good now. The doctests should also pass.


---

Comment by git created at 2020-06-13 19:01:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-06-13 22:39:20

Thank you. Two more little things:

```diff
         INPUT:
 
-        - `ring` -- (optional); base ring of the output; default is `ZZ`
+        - `ring` -- (optional); base ring of the output; default is ``ZZ``
```

and we should add a test for the empty row/column and empty matrix for `Matrix_gf2e_dense.__bool__` (as that was a good catch). I can do this tomorrow.


---

Comment by git created at 2020-06-13 23:03:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-06-13 23:05:00

Replying to [comment:43 tscrim]:
> and we should add a test for the empty row/column and empty matrix for `Matrix_gf2e_dense.__bool__` (as that was a good catch).

Well the bot was segfaulting (and me to, when running the test).


---

Comment by tscrim created at 2020-06-13 23:46:00

Okay, then positive review. Thank you.


---

Comment by tscrim created at 2020-06-13 23:46:00

Changing status from needs_review to positive_review.


---

Comment by @kliem created at 2020-06-14 08:34:57

I like that you made a polyhedron only ticket, into a more general improvement for other parts as well.


---

Comment by slelievre created at 2020-06-18 02:09:57

(Slightly amending ticket description, please check that works for you.).


---

Comment by vbraun created at 2020-06-27 09:25:22

Resolution: fixed
