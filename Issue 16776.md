# Issue 16776: WordDatatype_char

archive/issues_016776.json:
```json
{
    "body": "CC:  slabbe\n\nKeywords: words\n\nCreation of a new class WordDatatype_char that has in backend an 'unsigned char *' and use it wherever possible. The implementation is much faster than anything else but is only available for alphabet contained in [0,255].\n\nIssue created by migration from https://trac.sagemath.org/ticket/17013\n\n",
    "created_at": "2014-09-20T15:17:18Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "title": "WordDatatype_char",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16776",
    "user": "vdelecroix"
}
```
CC:  slabbe

Keywords: words

Creation of a new class WordDatatype_char that has in backend an 'unsigned char *' and use it wherever possible. The implementation is much faster than anything else but is only available for alphabet contained in [0,255].

Issue created by migration from https://trac.sagemath.org/ticket/17013





---

archive/issue_comments_221848.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-09-20T15:35:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221848",
    "user": "vdelecroix"
}
```

New commits:



---

archive/issue_comments_221849.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-09-20T15:35:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221849",
    "user": "vdelecroix"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_221850.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-09-20T18:53:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221850",
    "user": "slabbe"
}
```

New commits:



---

archive/issue_comments_221851.json:
```json
{
    "body": "If Vincent agrees with my changes, then he can set this ticket to positive review.",
    "created_at": "2014-09-20T18:54:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221851",
    "user": "slabbe"
}
```

If Vincent agrees with my changes, then he can set this ticket to positive review.



---

archive/issue_comments_221852.json:
```json
{
    "body": "Here is one benchmark.\n\nBEFORE::\n\n\n```\n    sage: w = Word([0,-1,2]*100, alphabet=[0,-1,2])\n    sage: type(w)\n    <class 'sage.combinat.words.word.FiniteWord_list'>\n    sage: %timeit w.is_square_free()\n    1000 loops, best of 3: 417 \u00b5s per loop\n```\n\n\nAFTER::\n\n\n```\n    sage: w = Word([0,1,2]*100, alphabet=[0,1,2])\n    sage: type(w)\n    <class 'sage.combinat.words.word.FiniteWord_char'>\n    sage: %timeit w.is_square_free()\n    100000 loops, best of 3: 6.29 \u00b5s per loop\n```\n\n\nWe should also add here some benchmark about equality test and also `__getitem__`.",
    "created_at": "2014-09-20T18:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221852",
    "user": "slabbe"
}
```

Here is one benchmark.

BEFORE::


```
    sage: w = Word([0,-1,2]*100, alphabet=[0,-1,2])
    sage: type(w)
    <class 'sage.combinat.words.word.FiniteWord_list'>
    sage: %timeit w.is_square_free()
    1000 loops, best of 3: 417 µs per loop
```


AFTER::


```
    sage: w = Word([0,1,2]*100, alphabet=[0,1,2])
    sage: type(w)
    <class 'sage.combinat.words.word.FiniteWord_char'>
    sage: %timeit w.is_square_free()
    100000 loops, best of 3: 6.29 µs per loop
```


We should also add here some benchmark about equality test and also `__getitem__`.



---

archive/issue_comments_221853.json:
```json
{
    "body": "Replying to [comment:4 slabbe]:\n> We should also add here some benchmark about equality test and also `__getitem__`.\n\nEDIT: the timings were edited because there were not about `FiniteWord_str` but `FiniteWord_list`...\n\nCompetitions between:\n- Python string\n- `FiniteWord_str`\n- `FiniteWord_char`\n\n\n```\nsage: W1 = Words('abc')\nsage: W2 = Words([0,1,2])\nsage: w1 = W1(''.join(choice('abc') for _ in range(1000)))\nsage: w2 = W2([choice([0,1,2]) for _ in range(1000])\nsage: s = str(w1)\n```\n\nthen on slices\n\n```\nsage: timeit(\"for i in range(1000): u = w1[:i]\")\n25 loops, best of 3: 25.3 ms per loop\nsage: timeit(\"for i in range(1000): u = w2[:i]\")\n625 loops, best of 3: 237 \u00b5s per loop\nsage: timeit(\"for i in range(1000): u = s[:i]\")\n625 loops, best of 3: 129 \u00b5s per loop\n```\n\nand on equality\n\n```\nsage: timeit(\"w1 == w1\")\n625 loops, best of 3: 365 ns per loop\nsage: timeit(\"w2 == w2\")\n625 loops, best of 3: 187 ns per loop\nsage: timeit(\"s == s\")\n625 loops, best of 3: 86.6 ns per loop\n```\n\nSo Python strings are still ahead, but its much less ridiculous.\n\nVincent",
    "created_at": "2014-09-20T21:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221853",
    "user": "vdelecroix"
}
```

Replying to [comment:4 slabbe]:
> We should also add here some benchmark about equality test and also `__getitem__`.

EDIT: the timings were edited because there were not about `FiniteWord_str` but `FiniteWord_list`...

Competitions between:
- Python string
- `FiniteWord_str`
- `FiniteWord_char`


```
sage: W1 = Words('abc')
sage: W2 = Words([0,1,2])
sage: w1 = W1(''.join(choice('abc') for _ in range(1000)))
sage: w2 = W2([choice([0,1,2]) for _ in range(1000])
sage: s = str(w1)
```

then on slices

```
sage: timeit("for i in range(1000): u = w1[:i]")
25 loops, best of 3: 25.3 ms per loop
sage: timeit("for i in range(1000): u = w2[:i]")
625 loops, best of 3: 237 µs per loop
sage: timeit("for i in range(1000): u = s[:i]")
625 loops, best of 3: 129 µs per loop
```

and on equality

```
sage: timeit("w1 == w1")
625 loops, best of 3: 365 ns per loop
sage: timeit("w2 == w2")
625 loops, best of 3: 187 ns per loop
sage: timeit("s == s")
625 loops, best of 3: 86.6 ns per loop
```

So Python strings are still ahead, but its much less ridiculous.

Vincent



---

archive/issue_comments_221854.json:
```json
{
    "body": "Replying to [comment:3 slabbe]:\n> If Vincent agrees with my changes, then he can set this ticket to positive review.\n\nI am! Thanks for the review.\n\nVincent",
    "created_at": "2014-09-20T21:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221854",
    "user": "vdelecroix"
}
```

Replying to [comment:3 slabbe]:
> If Vincent agrees with my changes, then he can set this ticket to positive review.

I am! Thanks for the review.

Vincent



---

archive/issue_comments_221855.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-09-20T21:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221855",
    "user": "vdelecroix"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_221856.json:
```json
{
    "body": "> Competitions between:\n>  - Python string\n>  - `FiniteWord_str`\n>  - `FiniteWord_char`\n\nI believe you do not have `FiniteWord_str` in the competition...\n\n\n```\nsage: type(w1)                                     \n<class 'sage.combinat.words.word.FiniteWord_list'> \n```\n",
    "created_at": "2014-09-20T21:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221856",
    "user": "slabbe"
}
```

> Competitions between:
>  - Python string
>  - `FiniteWord_str`
>  - `FiniteWord_char`

I believe you do not have `FiniteWord_str` in the competition...


```
sage: type(w1)                                     
<class 'sage.combinat.words.word.FiniteWord_list'> 
```




---

archive/issue_comments_221857.json:
```json
{
    "body": "Instead of (note that you already have defined i as a `ssize_t`):\n\n\n```python\ncdef ssize_t i\nfor i in range(w._length-1, -1, -1):\n```\n\n\nMaybe the following is better and would allow to use `size_t` type?\n\n\n```python\ncdef size_t i\nfor i from w._length > i >= 0:\n```\n",
    "created_at": "2014-09-20T21:55:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221857",
    "user": "slabbe"
}
```

Instead of (note that you already have defined i as a `ssize_t`):


```python
cdef ssize_t i
for i in range(w._length-1, -1, -1):
```


Maybe the following is better and would allow to use `size_t` type?


```python
cdef size_t i
for i from w._length > i >= 0:
```




---

archive/issue_comments_221858.json:
```json
{
    "body": "Replying to [comment:8 slabbe]:\n> Instead of (note that you already have defined i as a `ssize_t`):\n> \n> {{{\n> #!python\n> cdef ssize_t i\n> for i in range(w._length-1, -1, -1):\n> }}}\n> \n> Maybe the following is better and would allow to use `size_t` type?\n> \n> {{{\n> #!python\n> cdef size_t i\n> for i from w._length > i >= 0:\n> }}}\n\nNope, it does note change anything. And be careful, your second loop is infinite (a size_t is always >= 0).",
    "created_at": "2014-09-20T21:56:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221858",
    "user": "vdelecroix"
}
```

Replying to [comment:8 slabbe]:
> Instead of (note that you already have defined i as a `ssize_t`):
> 
> {{{
> #!python
> cdef ssize_t i
> for i in range(w._length-1, -1, -1):
> }}}
> 
> Maybe the following is better and would allow to use `size_t` type?
> 
> {{{
> #!python
> cdef size_t i
> for i from w._length > i >= 0:
> }}}

Nope, it does note change anything. And be careful, your second loop is infinite (a size_t is always >= 0).



---

archive/issue_comments_221859.json:
```json
{
    "body": "Replying to [comment:7 slabbe]:\n> > Competitions between:\n> >  - Python string\n> >  - `FiniteWord_str`\n> >  - `FiniteWord_char`\n> \n> I believe you do not have `FiniteWord_str` in the competition...\n> \n> {{{\n> sage: type(w1)                                     \n> <class 'sage.combinat.words.word.FiniteWord_list'> \n> }}}\n\nOups... corrected. Does not change anything for slicing, but huge difference in equality.",
    "created_at": "2014-09-20T21:59:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221859",
    "user": "vdelecroix"
}
```

Replying to [comment:7 slabbe]:
> > Competitions between:
> >  - Python string
> >  - `FiniteWord_str`
> >  - `FiniteWord_char`
> 
> I believe you do not have `FiniteWord_str` in the competition...
> 
> {{{
> sage: type(w1)                                     
> <class 'sage.combinat.words.word.FiniteWord_list'> 
> }}}

Oups... corrected. Does not change anything for slicing, but huge difference in equality.



---

archive/issue_comments_221860.json:
```json
{
    "body": "Great, so I am ok with this ticket. Positive review as already set!\n\nS\u00e9bastien",
    "created_at": "2014-09-20T22:04:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221860",
    "user": "slabbe"
}
```

Great, so I am ok with this ticket. Positive review as already set!

Sébastien



---

archive/issue_comments_221861.json:
```json
{
    "body": "This is absolutely not the right way to handle exceptions:\n\n```\nif PySlice_GetIndicesEx(...) < 0:\n    return\n```\n\nThe fact that it \"works\" is because IPython picks up the exception much later than you intended. Note the botched traceback:\n\n```\nsage: Words([0,1,2,3])([0,1,0,2,0,3,1,2,3])[slice(\"foo\")]\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nTypeError: slice indices must be integers or None or have an __index__ method\n```\n\nThe right way is to declare your function as `except -1` and let Cython do the right thing. See http://docs.cython.org/src/userguide/language_basics.html#error-return-values",
    "created_at": "2014-09-24T15:34:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221861",
    "user": "jdemeyer"
}
```

This is absolutely not the right way to handle exceptions:

```
if PySlice_GetIndicesEx(...) < 0:
    return
```

The fact that it "works" is because IPython picks up the exception much later than you intended. Note the botched traceback:

```
sage: Words([0,1,2,3])([0,1,0,2,0,3,1,2,3])[slice("foo")]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
TypeError: slice indices must be integers or None or have an __index__ method
```

The right way is to declare your function as `except -1` and let Cython do the right thing. See http://docs.cython.org/src/userguide/language_basics.html#error-return-values



---

archive/issue_comments_221862.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-09-24T15:34:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221862",
    "user": "jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_221863.json:
```json
{
    "body": "See [https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece](https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece) for how such a declaration would look like.\n\nIf you feel like it, add that patch to the Cython package and then you can do\n\n```\nfrom cpython.slice cimport *\n```\n\ninstead of manually declaring the `PySlice_` functions.",
    "created_at": "2014-09-24T16:00:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221863",
    "user": "jdemeyer"
}
```

See [https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece](https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece) for how such a declaration would look like.

If you feel like it, add that patch to the Cython package and then you can do

```
from cpython.slice cimport *
```

instead of manually declaring the `PySlice_` functions.



---

archive/issue_comments_221864.json:
```json
{
    "body": "Hi Jeroen,\n\nAs you noticed, the commit in cython is 3 days old... and the reason is because I asked on the [cython-users list](https://groups.google.com/forum/#!topic/cython-users/2G-QguqmgKk). Patching is much more work than the declaration (see the last commit):\n\n```\ncdef extern from \"Python.h\":\n    int PySlice_GetIndicesEx(...) except -1\n```\n\n\nVincent",
    "created_at": "2014-09-24T16:13:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221864",
    "user": "vdelecroix"
}
```

Hi Jeroen,

As you noticed, the commit in cython is 3 days old... and the reason is because I asked on the [cython-users list](https://groups.google.com/forum/#!topic/cython-users/2G-QguqmgKk). Patching is much more work than the declaration (see the last commit):

```
cdef extern from "Python.h":
    int PySlice_GetIndicesEx(...) except -1
```


Vincent



---

archive/issue_comments_221865.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-09-24T16:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221865",
    "user": "vdelecroix"
}
```

New commits:



---

archive/issue_comments_221866.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-09-24T16:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221866",
    "user": "vdelecroix"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_221867.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-09-24T16:45:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221867",
    "user": "jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_221868.json:
```json
{
    "body": "Thanks!",
    "created_at": "2014-09-24T16:55:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221868",
    "user": "vdelecroix"
}
```

Thanks!



---

archive/issue_comments_221869.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-09-25T12:05:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221869",
    "user": "vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_221870.json:
```json
{
    "body": "Note that #15820 seems to address similar applications, but more general (without restriction to alphabets of length 255). In preliminary versions of bounded integer sequences, I experimented with `char*` as underlying data structure, but found that using GMP long integers with the shift operations provided by GMP was faster.",
    "created_at": "2014-12-13T23:24:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221870",
    "user": "SimonKing"
}
```

Note that #15820 seems to address similar applications, but more general (without restriction to alphabets of length 255). In preliminary versions of bounded integer sequences, I experimented with `char*` as underlying data structure, but found that using GMP long integers with the shift operations provided by GMP was faster.



---

archive/issue_comments_221871.json:
```json
{
    "body": "You should really compare the speed of the operations here with those from #15820. What I dislike about this ticket here is that it just talks about `WordDatatype_char` which doesn't mean anything to me: I never noticed that you were implementing sequences of integers in the interval [0,255].\n\nOn #15820, I insisted that the approach would be as general as possible. Of course, Simon King (the author) had a particular application in mind, but the code in #15820 never refers to that application, it is very general.",
    "created_at": "2014-12-14T08:32:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221871",
    "user": "jdemeyer"
}
```

You should really compare the speed of the operations here with those from #15820. What I dislike about this ticket here is that it just talks about `WordDatatype_char` which doesn't mean anything to me: I never noticed that you were implementing sequences of integers in the interval [0,255].

On #15820, I insisted that the approach would be as general as possible. Of course, Simon King (the author) had a particular application in mind, but the code in #15820 never refers to that application, it is very general.



---

archive/issue_comments_221872.json:
```json
{
    "body": "Hello,\n\nThe thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:\n1. code less readable\n2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)\nAnd implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.\n\nNevertheless, I would be happy to give it a try and do proper benchmarkings. There will be no problem to remove the data structure here if #15820 is just better.\n\nVincent",
    "created_at": "2014-12-14T09:14:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221872",
    "user": "vdelecroix"
}
```

Hello,

The thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:
1. code less readable
2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)
And implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.

Nevertheless, I would be happy to give it a try and do proper benchmarkings. There will be no problem to remove the data structure here if #15820 is just better.

Vincent



---

archive/issue_comments_221873.json:
```json
{
    "body": "Replying to [comment:21 vdelecroix]:\n> The thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:\n> 1. code less readable\n\nTrue for the underlying boilerplate functions. Not necessarily true for higher level code.\n\n\n> 2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)\n\nWhy can one not use `memcmp` and `memcpy`? Respectively, what's wrong with using `mpn_cmp` and similar functions?\n\n> And implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.\n\nIndeed, detection of subsequences (which is also implemented in #15820) is a bit more complicated than it would be with `char*`. Detection of subsequences is one of the operations I care about. Admittedly, with my application to right modules over path algebras in mind, I care more about testing whether a sequence *starts* with a given subsequence than whether it just *contains* the subsequence.",
    "created_at": "2014-12-14T10:05:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221873",
    "user": "SimonKing"
}
```

Replying to [comment:21 vdelecroix]:
> The thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:
> 1. code less readable

True for the underlying boilerplate functions. Not necessarily true for higher level code.


> 2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)

Why can one not use `memcmp` and `memcpy`? Respectively, what's wrong with using `mpn_cmp` and similar functions?

> And implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.

Indeed, detection of subsequences (which is also implemented in #15820) is a bit more complicated than it would be with `char*`. Detection of subsequences is one of the operations I care about. Admittedly, with my application to right modules over path algebras in mind, I care more about testing whether a sequence *starts* with a given subsequence than whether it just *contains* the subsequence.



---

archive/issue_comments_221874.json:
```json
{
    "body": "Of course, bounded integer sequences have one disadvantage for your applications: you can not prescribe an alphabet. Each bounded integer sequences is formed by integers between 0 and a prescribed bound.\n\nAnyway, here are some timings:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: w_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100, alphabet=range(16))\nsage: type(w_s)\n<class 'sage.combinat.words.word.FiniteWord_char'>\nsage: w_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100)\nsage: type(w_l)\n<class 'sage.combinat.words.word.FiniteWord_list'>\nsage: w_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*100)\nsage: type(w_t)\n<class 'sage.combinat.words.word.FiniteWord_tuple'>\nsage: w_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*100)\nsage: w2_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))\nsage: w2_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])\nsage: w2_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*99+(9,2,0,1,5,3,10,15,1,14,3,8))\nsage: w2_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])\nsage: list(w_s)==list(w_l)==list(w_t)==list(w_b)\nTrue\nsage: list(w2_s)==list(w2_l)==list(w2_t)==list(w2_b)\nTrue\n```\n\n\nComparison:\n\n```\nsage: %timeit w_s==w2_s\n100000 loops, best of 3: 2.57 \u00b5s per loop\nsage: %timeit w_l==w2_l\n10000 loops, best of 3: 57.8 \u00b5s per loop\nsage: %timeit w_t==w2_t\n10000 loops, best of 3: 56 \u00b5s per loop\nsage: %timeit w_b==w2_b\n1000000 loops, best of 3: 537 ns per loop\n```\n\n\nHash, which is not (yet?) cached for bounded integer sequences:\n\n```\nsage: %timeit hash(w_s)\n10000000 loops, best of 3: 137 ns per loop\nsage: %timeit hash(w_l)\n10000000 loops, best of 3: 138 ns per loop\nsage: %timeit hash(w_t)\n10000000 loops, best of 3: 137 ns per loop\nsage: %timeit hash(w_b)\n1000000 loops, best of 3: 246 ns per loop\n```\n\n\nConcatenation:\n\n```\nsage: list(w_s+w2_s)==list(w_l+w2_l)==list(w_t+w2_t)==list(w_b+w2_b)\nTrue\nsage: %timeit w_s+w2_s\n1000 loops, best of 3: 336 \u00b5s per loop\nsage: %timeit w_l+w2_l\n10000 loops, best of 3: 31.1 \u00b5s per loop\nsage: %timeit w_t+w2_t\n10000 loops, best of 3: 31.7 \u00b5s per loop\nsage: %timeit w_b+w2_b\n1000000 loops, best of 3: 1.05 \u00b5s per loop\n```\n\n\nSubsequence containment:\n\n```\nsage: sub_s = Word([9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))\nsage: sub_l = Word([9,2,0,1,5,3,10,15,1,14,3,8])\nsage: sub_t = Word((9,2,0,1,5,3,10,15,1,14,3,8))\nsage: sub_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,3,8])\nsage: W_s = w2_s+w_s\nsage: W_l = w2_l+w_l\nsage: W_t = w2_t+w_t\nsage: W_b = w2_b+w_b\nsage: sub_s.is_subword_of(W_s)\nTrue\nsage: sub_b in W_b\nTrue\nsage: %timeit sub_s.is_subword_of(W_s)\n10000 loops, best of 3: 21.3 \u00b5s per loop\nsage: %timeit sub_l.is_subword_of(W_l)\n100000 loops, best of 3: 10.9 \u00b5s per loop\nsage: %timeit sub_t.is_subword_of(W_t)\n100000 loops, best of 3: 10.7 \u00b5s per loop\nsage: %timeit sub_b in W_b\n100000 loops, best of 3: 10.8 \u00b5s per loop\n```\n\n\nSo, using a compressed data format (where many letters are squeezed into one machine word) is not bad for the operations above.",
    "created_at": "2014-12-14T10:31:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221874",
    "user": "SimonKing"
}
```

Of course, bounded integer sequences have one disadvantage for your applications: you can not prescribe an alphabet. Each bounded integer sequences is formed by integers between 0 and a prescribed bound.

Anyway, here are some timings:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: w_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100, alphabet=range(16))
sage: type(w_s)
<class 'sage.combinat.words.word.FiniteWord_char'>
sage: w_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100)
sage: type(w_l)
<class 'sage.combinat.words.word.FiniteWord_list'>
sage: w_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*100)
sage: type(w_t)
<class 'sage.combinat.words.word.FiniteWord_tuple'>
sage: w_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*100)
sage: w2_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))
sage: w2_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])
sage: w2_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*99+(9,2,0,1,5,3,10,15,1,14,3,8))
sage: w2_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])
sage: list(w_s)==list(w_l)==list(w_t)==list(w_b)
True
sage: list(w2_s)==list(w2_l)==list(w2_t)==list(w2_b)
True
```


Comparison:

```
sage: %timeit w_s==w2_s
100000 loops, best of 3: 2.57 µs per loop
sage: %timeit w_l==w2_l
10000 loops, best of 3: 57.8 µs per loop
sage: %timeit w_t==w2_t
10000 loops, best of 3: 56 µs per loop
sage: %timeit w_b==w2_b
1000000 loops, best of 3: 537 ns per loop
```


Hash, which is not (yet?) cached for bounded integer sequences:

```
sage: %timeit hash(w_s)
10000000 loops, best of 3: 137 ns per loop
sage: %timeit hash(w_l)
10000000 loops, best of 3: 138 ns per loop
sage: %timeit hash(w_t)
10000000 loops, best of 3: 137 ns per loop
sage: %timeit hash(w_b)
1000000 loops, best of 3: 246 ns per loop
```


Concatenation:

```
sage: list(w_s+w2_s)==list(w_l+w2_l)==list(w_t+w2_t)==list(w_b+w2_b)
True
sage: %timeit w_s+w2_s
1000 loops, best of 3: 336 µs per loop
sage: %timeit w_l+w2_l
10000 loops, best of 3: 31.1 µs per loop
sage: %timeit w_t+w2_t
10000 loops, best of 3: 31.7 µs per loop
sage: %timeit w_b+w2_b
1000000 loops, best of 3: 1.05 µs per loop
```


Subsequence containment:

```
sage: sub_s = Word([9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))
sage: sub_l = Word([9,2,0,1,5,3,10,15,1,14,3,8])
sage: sub_t = Word((9,2,0,1,5,3,10,15,1,14,3,8))
sage: sub_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,3,8])
sage: W_s = w2_s+w_s
sage: W_l = w2_l+w_l
sage: W_t = w2_t+w_t
sage: W_b = w2_b+w_b
sage: sub_s.is_subword_of(W_s)
True
sage: sub_b in W_b
True
sage: %timeit sub_s.is_subword_of(W_s)
10000 loops, best of 3: 21.3 µs per loop
sage: %timeit sub_l.is_subword_of(W_l)
100000 loops, best of 3: 10.9 µs per loop
sage: %timeit sub_t.is_subword_of(W_t)
100000 loops, best of 3: 10.7 µs per loop
sage: %timeit sub_b in W_b
100000 loops, best of 3: 10.8 µs per loop
```


So, using a compressed data format (where many letters are squeezed into one machine word) is not bad for the operations above.



---

archive/issue_comments_221875.json:
```json
{
    "body": "I forgot slicing:\n\n```\nsage: list(w_s[30:70]) == list(w_b[30:70])\nTrue\nsage: %timeit x=w_s[30:70]\n1000000 loops, best of 3: 1.02 \u00b5s per loop\nsage: %timeit x=w_l[30:70]\n10000 loops, best of 3: 20.6 \u00b5s per loop\nsage: %timeit x=w_t[30:70]\n10000 loops, best of 3: 21 \u00b5s per loop\nsage: %timeit x=w_b[30:70]\n1000000 loops, best of 3: 1.14 \u00b5s per loop\nsage: list(w_s[30:70:2]) == list(w_b[30:70:2])\nTrue\nsage: %timeit x=w_s[30:70:2]\n100000 loops, best of 3: 2.65 \u00b5s per loop\nsage: %timeit x=w_l[30:70:2]\n100000 loops, best of 3: 13.3 \u00b5s per loop\nsage: %timeit x=w_t[30:70:2]\n100000 loops, best of 3: 14.4 \u00b5s per loop\nsage: %timeit x=w_b[30:70:2]\n1000000 loops, best of 3: 1.63 \u00b5s per loop\n```\n",
    "created_at": "2014-12-14T10:33:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16776",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16776#issuecomment-221875",
    "user": "SimonKing"
}
```

I forgot slicing:

```
sage: list(w_s[30:70]) == list(w_b[30:70])
True
sage: %timeit x=w_s[30:70]
1000000 loops, best of 3: 1.02 µs per loop
sage: %timeit x=w_l[30:70]
10000 loops, best of 3: 20.6 µs per loop
sage: %timeit x=w_t[30:70]
10000 loops, best of 3: 21 µs per loop
sage: %timeit x=w_b[30:70]
1000000 loops, best of 3: 1.14 µs per loop
sage: list(w_s[30:70:2]) == list(w_b[30:70:2])
True
sage: %timeit x=w_s[30:70:2]
100000 loops, best of 3: 2.65 µs per loop
sage: %timeit x=w_l[30:70:2]
100000 loops, best of 3: 13.3 µs per loop
sage: %timeit x=w_t[30:70:2]
100000 loops, best of 3: 14.4 µs per loop
sage: %timeit x=w_b[30:70:2]
1000000 loops, best of 3: 1.63 µs per loop
```

