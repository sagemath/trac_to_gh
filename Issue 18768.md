# Issue 18768: inverse_series method for polynomials

Issue created by migration from https://trac.sagemath.org/ticket/19005

Original creator: vdelecroix

Original creation time: 2015-08-09 13:34:50

CC:  pernici mmezzarobba

The polynomials in Sage lack many series operation (see #18356 for some motivation). We implement a generic `cpdef Polynomial inverse_series(self, long prec)` method and specialized ones for polynomials using flint backends.


---

Comment by vdelecroix created at 2015-08-09 13:38:18

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2015-08-09 13:38:18

New commits:


---

Comment by mmezzarobba created at 2015-08-18 15:01:05

Hi Vincent,

Could you please explain why you'd like to have these features as methods of polynomial objects rather than power series objects? Thanks!


---

Comment by vdelecroix created at 2015-08-18 15:41:57

Hi Marc,

Replying to [comment:3 mmezzarobba]:
> Could you please explain why you'd like to have these features as methods of polynomial objects rather than power series objects? Thanks!

1. A power series just wraps a polynomial. So it would be better to have specialized algorithms for polynomials and wrap them at the power series level. Would you prefer one power series element per polynomial class? As soon as this is reviewed, I will change the power series implementation to use this method and it will be much faster. I can do that here if you prefer.

2. Power series are much slower and involving them in a polynomial algorithm implies a creation of parent (which is damn slow). Moreover you only care about the polynomial at the end. You can have a look at #18356 for motivation from this side.

Vincent


---

Comment by mmezzarobba created at 2015-08-25 10:15:58

Replying to [comment:4 vdelecroix]:
> > Could you please explain why you'd like to have these features as methods of polynomial objects rather than power series objects? Thanks!
> 
> 1. A power series just wraps a polynomial. So it would be better to have specialized algorithms for polynomials and wrap them at the power series level. Would you prefer one power series element per polynomial class?

No, as long as the methods you are implementing on polynomials are just helpers for generic implementations on power series, I agree. But I wouldn't want to clutter the interface of polynomials with every possible operation on power series, elements of quotients of polynomial rings, etc.

Anyway, this ticket probably wasn't the right place to make this comment, because I agree that inversion modulo x<sup>k</sup> is fundamental enough to be part of the interface of polynomials themselves.

> 2. Power series are much slower and involving them in a polynomial algorithm implies a creation of parent (which is damn slow).

Well, that's probably something that should be fixed on its own! `:-)`


---

Comment by mmezzarobba created at 2015-08-25 11:10:40

The docstring of `inverse_series` claims that it works over any ring, but after patching `matrix0.pyx` to make `is_unit` synonymous with `is_invertible`, I get:

```
sage: R.<x> = MatrixSpace(QQ, 2)[]
sage: pol = R.random_element()
sage: list(pol)
[
[   2    0]  [2 1]  [-1  0]
[-1/2 -1/2], [0 2], [ 2 -2]
]
sage: inv = pol.inverse_series(5)
sage: (inv*pol).truncate(5).degree()
4
sage: (pol*inv).truncate(5).degree()
4
```

Did you intend it to work over non-commutative rings?


---

Comment by mmezzarobba created at 2015-08-25 11:10:56

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-08-26 00:35:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-08-26 00:35:45

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-08-26 00:43:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by bruno created at 2015-08-27 09:37:10

Though I am not definitive on this, I find it weird to have the two distinct methods `inverse_mod` and `inverse_series` with `p.inverse_series(10) == p.inverse_mod(x^10)`. Wouldn't it be possible to make your code a special case of `inverse_mod`, or to make it a hidden function (`_inverse_series`) which is called as a special case of `inverse_mod`? Actually, these are two distinct changes I propose, with two distinct reasons:

  1. It would be make `inverse_mod` faster for monomials:
     {{{#!python
sage: %timeit p.inverse_series(10)
The slowest run took 24.39 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 1.96 µs per loop
sage: %timeit p.inverse_mod(x^10)
The slowest run took 6.16 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 26.2 µs per loop
      }}}

    2. The name `inverse_series` make me think that the result will be a series, so if I want a truncated series (that is a polynomial), I am more naturally inclined to try the `inverse_mod` method. And I suspect other users may have the same behavior.


---

Comment by vdelecroix created at 2015-08-27 23:28:25

Hi Bruno,

Replying to [comment:11 bruno]:
> Though I am not definitive on this, I find it weird to have the two distinct methods `inverse_mod` and `inverse_series` with `p.inverse_series(10) == p.inverse_mod(x^10)`. Wouldn't it be possible to make your code a special case of `inverse_mod`, or to make it a hidden function (`_inverse_series`) which is called as a special case of `inverse_mod`? Actually, these are two distinct changes I propose, with two distinct reasons:

I definitely do not want to involve a case search to get the inverse series (the calls to `isinstance`, `from sage.rings.ideal import Ideal` all the `if` takes a lot of time). The function `inverse_series` has type definition in input that will make it efficient in Cython code (e.g. power series). So I am against having it as a special case of `inverse_mod`. Thoug, if you think it would be interesting you can add a special case to `inverse_mod` but I am not sure it is worth it. It might be better to just add a `SEEALSO` in the documentation.

>     2. The name `inverse_series` make me think that the result will be a series, so if I want a truncated series (that is a polynomial), I am more naturally inclined to try the `inverse_mod` method. And I suspect other users may have the same behavior.

What about `truncated_inverse_series` or `inverse_series_trunc`? (there is already a `_mul_trunc_`).


---

Comment by git created at 2015-08-27 23:50:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2015-08-28 10:04:59

Hi Vincent, hi Bruno,

Replying to [comment:12 vdelecroix]:
> I definitely do not want to involve a case search to get the inverse series (the calls to `isinstance`, `from sage.rings.ideal import Ideal` all the `if` takes a lot of time). The function `inverse_series` has type definition in input that will make it efficient in Cython code (e.g. power series). So I am against having it as a special case of `inverse_mod`. Thoug, if you think it would be interesting you can add a special case to `inverse_mod` but I am not sure it is worth it. It might be better to just add a `SEEALSO` in the documentation.

I tend to agree.

> >     2. The name `inverse_series` make me think that the result will be a series, so if I want a truncated series (that is a polynomial), I am more naturally inclined to try the `inverse_mod` method. And I suspect other users may have the same behavior.
> 
> What about `truncated_inverse_series` or `inverse_series_trunc`? (there is already a `_mul_trunc_`). 

Ore perhaps `inverse_mod_xk`? I thought about suggesting a different name when I wrote my comments above, but I didn't find anything that I really liked better than `inverse_series`...


---

Comment by bruno created at 2015-08-28 14:11:44

Hi Vincent, hi (again) Marc,

Replying to [comment:14 mmezzarobba]:
> Hi Vincent, hi Bruno,
> 
> Replying to [comment:12 vdelecroix]:
> > I definitely do not want to involve a case search to get the inverse series (the calls to `isinstance`, `from sage.rings.ideal import Ideal` all the `if` takes a lot of time). The function `inverse_series` has type definition in input that will make it efficient in Cython code (e.g. power series). So I am against having it as a special case of `inverse_mod`. Thoug, if you think it would be interesting you can add a special case to `inverse_mod` but I am not sure it is worth it. It might be better to just add a `SEEALSO` in the documentation.
> 
> I tend to agree.
> 
Well, a `SEEALSO` looks like a good solution to me also.



> > >     2. The name `inverse_series` make me think that the result will be a series, so if I want a truncated series (that is a polynomial), I am more naturally inclined to try the `inverse_mod` method. And I suspect other users may have the same behavior.
> > 
> > What about `truncated_inverse_series` or `inverse_series_trunc`? (there is already a `_mul_trunc_`). 
> 
> Ore perhaps `inverse_mod_xk`? I thought about suggesting a different name when I wrote my comments above, but I didn't find anything that I really liked better than `inverse_series`...

My preferred choice goes to `inverse_series_trunc` (or `inverse_series_truncated` if you do not find it too long) since it will easily be found using tabulation and describes well the behavior.


---

Comment by git created at 2015-08-29 15:37:52

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2015-08-29 15:52:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-08-29 15:53:34

Rebased and updated with your last remarks.

Vincent


---

Comment by mmezzarobba created at 2015-09-01 18:21:32

* The generic version fails when the truncation order is negative (inconsistency with the others versions) or zero (which is a problem by itself):

```
sage: (1 + polygen(GF(2))).inverse_series_trunc(0)
...
ValueError: N (=0) must be a positive integer

sage: (1 + polygen(ZZ)).inverse_series_trunc(-1)
0
```

* I believe the doctest in `rings.py` that you fixed was meant to test the code path resulting in a `NotImplementedError`.
* You may want to change `two*current` to `current + current` in the generic implementation? (Not sure if this is a good idea, but it could be much faster for some rings.)
* Why the blank line in `matrix0.py`?
* “The method works _over_ any polynomial ring”?

Otherwise looks good to me.


---

Comment by mmezzarobba created at 2015-09-01 18:30:03

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-09-01 22:07:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-09-01 22:07:29

Replying to [comment:19 mmezzarobba]:
I fixed everything except

> * I believe the doctest in `rings.py` that you fixed was meant to test the code path resulting in a `NotImplementedError`.

Of course. I will not create a dummy ring just for checking this code path anyway.

Vincent


---

Comment by vdelecroix created at 2015-09-01 22:07:29

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2015-09-02 07:39:09

Replying to [comment:22 vdelecroix]:
> Replying to [comment:19 mmezzarobba]:
> I fixed everything except
> 
> > * I believe the doctest in `rings.py` that you fixed was meant to test the code path resulting in a `NotImplementedError`.
> 
> Of course. I will not create a dummy ring just for checking this code path anyway.

Fair enough. But I was wondering why you didn't just remove the test...


---

Comment by mmezzarobba created at 2015-09-02 07:39:09

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-09-02 17:25:29

Resolution: fixed
