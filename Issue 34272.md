# Issue 34272: Make IndexedFreeModuleElement a collections.abc.Mapping

Issue created by migration from https://trac.sagemath.org/ticket/34509

Original creator: mkoeppe

Original creation time: 2022-09-08 20:01:38

CC:  chapoton tscrim @mwageringel nthiery aschilling

Its implementation of `__iter__`, `__contains__`, `__len__` are not compatible with anything in the [collections.abc](https://docs.python.org/3/library/collections.abc.html) protocols.

To improve interoperability, we propose to make changes to make it a [collections.abc.Mapping](https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping) (= supporting the operations of a `dict` but without mutability):
 - Because a `Mapping` is a `Collection`, we change the `__iter__` method from yielding (key, value) items to yielding keys only. (Thus it will be compatible with the existing `__contains__` method which check for the presence of a key)
 - Add methods `keys`, `items`, `values` with the semantics familiar from `dict`.

(In #24815, it was proposed to make it a [collections.abc.Sequence](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence).)


---

Comment by tscrim created at 2022-09-08 23:39:37

I am against this change. They are vectors and only on their backend are implemented as a `dict`, but they are not dictionaries, nor mappings. Likewise, I strongly oppose changing them to iterating over keys. This brings their implementation further from the other free module vectors. The reason we iterate over both is because there is no natural way to order the basis so the sequence of coefficients occurs in a particular order (which will unfortunately be a source of incompatibility). Hence, most of the time when iterating we want to use both the support index and the coefficient. Being vectors, they don’t have `keys` and `values`, but `support` and `coefficients`. Nor do they have a reasonable notion of containment.

Contrast this to the “usual” free modules, where they have a natural compatibility with `sequence` as elements in R<sup>n</sup>, which are also how we think of finite sequences.


---

Comment by mkoeppe created at 2022-09-08 23:48:44

Replying to [comment:5 Travis Scrimshaw]:
> Being vectors, they don’t have `keys` and `values`, but `support` and `coefficients`. Nor do they have a reasonable notion of containment.

It does define `__contains__` currently; no change to that is proposed.

```
    def __contains__(self, x):
        """
        Returns whether or not a combinatorial object x indexing a basis
        element is in the support of self.
    ...
```



---

Comment by mkoeppe created at 2022-09-08 23:50:39

Replying to [comment:5 Travis Scrimshaw]:
> I strongly oppose changing them to iterating over keys. This brings their implementation further from the other free module vectors.

This makes no sense.


---

Comment by mkoeppe created at 2022-09-08 23:55:36

Replying to [comment:5 Travis Scrimshaw]:
> most of the time when iterating we want to use both the support index and the coefficient.

Yes, and there are two interpretations of this when the parent is a submodule.

- one is `monomial_coefficients`, which refers to the basis of the submodule
- one is the proposed new `items`, which will refer to the ambient. (This will be compatible with sparse vectors in `sage.modules`.)


---

Comment by tscrim created at 2022-09-08 23:58:47

Replying to [comment:7 Matthias Köppe]:
> Replying to [comment:5 Travis Scrimshaw]:
> > I strongly oppose changing them to iterating over keys. This brings their implementation further from the other free module vectors.
> 
> This makes no sense.

We want the two implementations to have the same API as much as possible. R<sup>n</sup> vectors iterate over coefficients, but iterating over keys/supports here would be the exact opposite of that behavior.


---

Comment by mkoeppe created at 2022-09-09 00:00:21

Yes, it makes no sense to say that returning `(key,value)` pairs is closer to being the "same API" as returning `value`s.


---

Comment by tscrim created at 2022-09-09 01:34:39

Replying to [comment:11 Matthias Köppe]:
> Yes, it makes no sense to say that returning `(key,value)` pairs is closer to being the "same API" as returning `value`s.

So actually returning the coefficient as part of the iterator instead of saying you should access it by a completely different method is exactly the same by your logic. You wouldn’t agree that it is a much smaller change to have R<sup>n</sup> vector iterators change to return the pairs?


---

Comment by mkoeppe created at 2022-09-09 01:38:06

Replying to [comment:13 Travis Scrimshaw]:
> change to have R<sup>n</sup> vector iterators change to return the pairs?

That would be a really bad change for dense vectors, which clearly want to be a `collections.abc.Sequence`


---

Comment by tscrim created at 2022-09-09 01:39:09

Replying to [comment:8 Matthias Köppe]:
> Replying to [comment:5 Travis Scrimshaw]:
> > most of the time when iterating we want to use both the support index and the coefficient.
> 
> Yes, and there are two interpretations of this when the parent is a submodule.
> 
> - one is `monomial_coefficients`, which refers to the basis of the submodule
> - one is the proposed new `items`, which will refer to the ambient. (This will be compatible with sparse vectors in `sage.modules`.)

Unfortunately because of different implementation goals (mainly the speed that is needed for the R<sup>n</sup> modules), we cannot enforce compatibility for everything. I would rather all vectors follow what CFM vectors do from a more abstract mathematical point of view, but we have to make trade-offs. This one is here very clear-cut.

Also, it isn’t just limited to sparse vectors, right?


---

Comment by tscrim created at 2022-09-09 01:39:50

Replying to [comment:14 Matthias Köppe]:
> Replying to [comment:13 Travis Scrimshaw]:
> > change to have R<sup>n</sup> vector iterators change to return the pairs?
> 
> That would be a really bad change for dense vectors, which clearly want to be a `collections.abc.Sequence`

I am not saying we should change it (see comment:15), but if we did, it would be smaller.


---

Comment by mkoeppe created at 2022-09-09 01:43:52

Replying to [comment:15 Travis Scrimshaw]:
> Unfortunately because of different implementation goals (mainly the speed that is needed for the R<sup>n</sup> modules), we cannot enforce compatibility for everything.

You'll have to be more concrete than that. There's nothing in the proposed change that has anything to do with performance.


---

Comment by mkoeppe created at 2022-09-09 03:24:54

I do see lots of uses of the idiom `... for (i, c) in self` in `sage.combinat`.

So maybe an easier change would be to get rid of the `__contains__` method (with deprecation, of course) to resolve this incompatibility. Then only uses of `if i in self` would have to be changed to `if i in self.support()`


---

Comment by tscrim created at 2022-09-09 03:27:33

Replying to [comment:17 Matthias Köppe]:
> Replying to [comment:15 Travis Scrimshaw]:
> > Unfortunately because of different implementation goals (mainly the speed that is needed for the R<sup>n</sup> modules), we cannot enforce compatibility for everything.
> 
> You'll have to be more concrete than that. There's nothing in the proposed change that has anything to do with performance.

If we change the iterator for R<sup>n</sup> modules to make it compatible with what `IndexedFreeModuleElement` does, then this would lead to slow downs because the R<sup>n</sup> module elements are fairly likely to be used in time-critical code sections (where extra indirections can matter).


---

Comment by tscrim created at 2022-09-09 03:30:27

Replying to [comment:18 Matthias Köppe]:
> I do see lots of uses of the idiom `... for (i, c) in self` in `sage.combinat`.
> 
> So maybe an easier change would be to get rid of the `__contains__` method (with deprecation, of course) to resolve this incompatibility. Then only uses of `if i in self` would have to be changed to `if i in self.support()`

+1 on this basically. I doubt anyone is using the support containment check where speed really matters, but that is my only slight hesitancy because that change would make it much slower (via the additional temporary object from `support()`). Perhaps a `self.index_in_support(i)` method instead?


---

Comment by mkoeppe created at 2022-09-09 04:25:43

Replying to [comment:19 Travis Scrimshaw]:
> Replying to [comment:17 Matthias Köppe]:
> > Replying to [comment:15 Travis Scrimshaw]:
> > > Unfortunately because of different implementation goals (mainly the speed that is needed for the R<sup>n</sup> modules), we cannot enforce compatibility for everything.
> > 
> > You'll have to be more concrete than that. There's nothing in the proposed change that has anything to do with performance.
> 
> If we change the iterator for R<sup>n</sup> modules to make it compatible with what `IndexedFreeModuleElement` does

OK, yes, that's just one of several reasons why this change would be bad. It's not being proposed here.


---

Comment by mkoeppe created at 2022-09-09 04:28:21

Replying to [comment:20 Travis Scrimshaw]:
> Replying to [comment:18 Matthias Köppe]:
> > I do see lots of uses of the idiom `... for (i, c) in self` in `sage.combinat`.
> > 
> > So maybe an easier change would be to get rid of the `__contains__` method (with deprecation, of course) to resolve this incompatibility. Then only uses of `if i in self` would have to be changed to `if i in self.support()`
> 
> +1 on this basically. I doubt anyone is using the support containment check where speed really matters, but that is my only slight hesitancy because that change would make it much slower (via the additional temporary object from `support()`). Perhaps a `self.index_in_support(i)` method instead?

Yes, of course the current implementation of `support()` is bad. It's another Python2-ish leftover of returning lists all the time.


---

Comment by mkoeppe created at 2022-09-09 04:31:02

By the way, can `_monomial_coefficients` really contain keys that have a zero value? I looked briefly and it seemed that for example arithmetic would always remove the zeros


---

Comment by mkoeppe created at 2022-09-09 04:32:32

If there's no zero value in `_monomial_coefficients`, then `support` can just return the `_monomial_coefficients.keys()` view.


---

Comment by mkoeppe created at 2022-09-09 04:37:36

Either way instead of inventing a new name such as `index_in_support`, we should just have `support` return a suitable object with a `__contains__` method.


---

Comment by mkoeppe created at 2022-09-10 05:43:40

I've updated the ticket description to reflect this revised plan


---

Comment by mkoeppe created at 2022-09-10 22:37:03

New commits:


---

Comment by git created at 2022-09-10 22:44:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-10 22:55:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-10 23:14:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-10 23:19:57

The proposed method `items` will be added in #34511


---

Comment by tscrim created at 2022-09-10 23:38:26

Replying to [comment:23 Matthias Köppe]:
> By the way, can `_monomial_coefficients` really contain keys that have a zero value? I looked briefly and it seemed that for example arithmetic would always remove the zeros

We have somewhat allowed for the possibility that it can hold zero coefficients, but we almost always in practice just remove them. We probably should just enforce this. This would make the `support()` call much cheaper, although checking containment could still be slow as it might be `list`-like checking rather than `set`-like. Anyways, I doubt it is used in much time critical code, but it is still good to keep similar performance in mind.


---

Comment by git created at 2022-09-10 23:41:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-10 23:57:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-11 00:05:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-11 00:07:34

Replying to [comment:37 Travis Scrimshaw]:
> Replying to [comment:23 Matthias Köppe]:
> > By the way, can `_monomial_coefficients` really contain keys that have a zero value? I looked briefly and it seemed that for example arithmetic would always remove the zeros
> 
> We have somewhat allowed for the possibility that it can hold zero coefficients, but we almost always in practice just remove them. We probably should just enforce this. This would make the `support()` call much cheaper

On the level of `CombinatorialFreeModule`, not the category, right? We can do that in a follow-up ticket. (The tensor modules don't enforce the sparsity, I think.)


---

Comment by mkoeppe created at 2022-09-11 00:08:38

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2022-09-11 00:10:32

This could of course be rewritten to avoid forming all these lists, but I don't know if it's worth it. Question for the author

```
index aa96f2b..e065b7e 100644
--- a/src/sage/categories/loop_crystals.py
+++ b/src/sage/categories/loop_crystals.py
@@ -456,7 +456,7 @@ class KirillovReshetikhinCrystals(Category_singleton):
             bsharp = None
             for b in self:
                 phi = b.Phi()
-                if phi.support() == [0] and phi[0] < ell:
+                if list(phi.support()) == [0] and phi[0] < ell:
                     bsharp = b
```



---

Comment by git created at 2022-09-11 00:12:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-11 00:34:58

Replying to [comment:41 Matthias Köppe]:
> Replying to [comment:37 Travis Scrimshaw]:
> > Replying to [comment:23 Matthias Köppe]:
> > > By the way, can `_monomial_coefficients` really contain keys that have a zero value? I looked briefly and it seemed that for example arithmetic would always remove the zeros
> > 
> > We have somewhat allowed for the possibility that it can hold zero coefficients, but we almost always in practice just remove them. We probably should just enforce this. This would make the `support()` call much cheaper
> 
> On the level of `CombinatorialFreeModule`, not the category, right? We can do that in a follow-up ticket. (The tensor modules don't enforce the sparsity, I think.)

I was thinking more for any `Parent` that uses the element class, but basically, yes.


---

Comment by mkoeppe created at 2022-09-11 00:35:51

Sure, yes, that's what I meant.


---

Comment by tscrim created at 2022-09-11 00:37:01

Replying to [comment:43 Matthias Köppe]:
> This could of course be rewritten to avoid forming all these lists, but I don't know if it's worth it. Question for the author
> {{{
> index aa96f2b..e065b7e 100644
> --- a/src/sage/categories/loop_crystals.py
> +++ b/src/sage/categories/loop_crystals.py
> `@``@` -456,7 +456,7 `@``@` class KirillovReshetikhinCrystals(Category_singleton):
>              bsharp = None
>              for b in self:
>                  phi = b.Phi()
> -                if phi.support() == [0] and phi[0] < ell:
> +                if list(phi.support()) == [0] and phi[0] < ell:
>                      bsharp = b
> }}}

I don’t think it is necessarily worth it as it won’t be run in tight loops. Although it would just become `if len(phi.support()) == 1 and 0 in phi.support() and phi[0] < ell:` I guess.


---

Comment by tscrim created at 2022-09-11 00:38:04

I guess one other option would be the `SupportView` to support comparisons with lists (and/or tuple)?


---

Comment by mkoeppe created at 2022-09-11 00:38:19

Well, using `len(phi.support())` wouldn't be much better because `len` has to iterate through the whole thing. 
Faster would be to do 

```
  i = iter(phi)
  next(i)
  try: next(i) except ...
```



---

Comment by mkoeppe created at 2022-09-11 00:39:00

Replying to [comment:48 Travis Scrimshaw]:
> I guess one other option would be the `SupportView` to support comparisons with lists (and/or tuple)?

Well, I think that's problematic because we don't even have `[1, 2] == (1, 2)`


---

Comment by tscrim created at 2022-09-11 00:40:14

Replying to [comment:49 Matthias Köppe]:
> Well, using `len(phi.support())` wouldn't be much better because `len` has to iterate through the whole thing. 
> Faster would be to do 
> {{{
>   i = iter(phi)
>   next(i)
>   try: next(i) except ...
> }}}

True, and that is complicated in an `if` statement.


---

Comment by mkoeppe created at 2022-09-11 00:41:12

Clear use case for https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.take


---

Comment by mkoeppe created at 2022-09-11 00:42:18

or https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.strictly_n


---

Comment by mkoeppe created at 2022-09-11 00:42:35

or https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.only


---

Comment by tscrim created at 2022-09-11 00:42:55

Replying to [comment:50 Matthias Köppe]:
> Replying to [comment:48 Travis Scrimshaw]:
> > I guess one other option would be the `SupportView` to support comparisons with lists (and/or tuple)?
> 
> Well, I think that's problematic because we don't even have `[1, 2] == (1, 2)`

Transitivity of `==` is indeed good to have. Well, maybe just comparisons with a list then? Or at least temporarily with a deprecation?


---

Comment by mkoeppe created at 2022-09-11 00:44:27

That would be doable but I think it's overkill.

I think the license to break functions like this, from the Python 2 to 3 transition, is not expired yet


---

Comment by tscrim created at 2022-09-11 00:47:29

This is a little different as it was the support of a vector, not the keys of a `dict`.


---

Comment by mkoeppe created at 2022-09-11 00:50:23

I'm referring to the general change in the Python library from explicit lists as return values to iterators


---

Comment by tscrim created at 2022-09-11 00:53:53

I think that would need a more general policy agreement discussed on sage-devel (as much as I would like to freely do this to a number of functions).


---

Comment by git created at 2022-09-11 00:54:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-11 00:56:02

OK, OK, I'll write an `__eq__` method with deprecation


---

Comment by tscrim created at 2022-09-11 01:00:47

Thank you. (So many things that return lists in `combinat` that would be better as iterators…)


---

Comment by mkoeppe created at 2022-09-11 01:05:48

Ha, this does catch a few places that do such comparisons


---

Comment by git created at 2022-09-11 01:06:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-11 01:08:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-11 01:08:58

ok, done


---

Comment by tscrim created at 2022-09-11 01:41:33

Should we also do comparisons with different `SupportView` objects, following python?

```
sage: d = {1:1, 2:2}
sage: dp = {1:-1, 2:-2}
sage: d.keys() == dp.keys()
True
```

Sorry if this was something you were planning to support and hadn’t gotten to that stage yet.


---

Comment by tscrim created at 2022-09-11 01:41:59

Replying to [comment:66 Matthias Köppe]:
> ok, done

Thank you.


---

Comment by mkoeppe created at 2022-09-11 01:46:08

Replying to [comment:67 Travis Scrimshaw]:
> Should we also do comparisons with different `SupportView` objects, following python?
> {{{
> sage: d = {1:1, 2:2}
> sage: dp = {1:-1, 2:-2}
> sage: d.keys() == dp.keys()
> True
> }}}
> Sorry if this was something you were planning to support and hadn’t gotten to that stage yet.

I'm unsure about this, and I think I would defer it to a follow-up ticket.

It could get full `collections.abc.Set` semantics actually, including `<=` as subset test etc. But that's a bit more work


---

Comment by mkoeppe created at 2022-09-11 02:07:28

In view of #29218, I would also move `__iter__` from `IndexedFreeModuleElement` to the category, next to `__len__`. Together they merely provide a default implementation of the `Sized` `Iterable` protocols. (Dense modules necessarily override both.)

The `length` method, on the other hand, is full specified and would be changed to not go through `__len__`.


---

Comment by mkoeppe created at 2022-09-11 02:38:58

But that will go to #29218.


---

Comment by mkoeppe created at 2022-09-11 04:10:31

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2022-09-11 04:10:31


```
sage -t --random-seed=124699541928353137721504742146487601068 doc/en/thematic_tutorials/lie/weyl_character_ring.rst  # 3 doctests failed
sage -t --random-seed=124699541928353137721504742146487601068 sage/algebras/quantum_groups/fock_space.py  # 80 doctests failed
sage -t --random-seed=124699541928353137721504742146487601068 sage/graphs/generators/random.py  # 1 doctest failed
sage -t --random-seed=124699541928353137721504742146487601068 sage/modules/tutorial_free_modules.py  # 1 doctest failed
```



---

Comment by git created at 2022-09-11 04:13:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-11 04:17:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-11 04:20:49

The failure in `sage/graphs/generators/random.py` is an unrelated random failure, I've added it to #32544.


---

Comment by mkoeppe created at 2022-09-11 04:23:39

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2022-09-11 17:32:27

All morally green, ready for review

(The Build&Test failure is another well-known random failure, in `sage/schemes/toric/sheaf/klyachko.py`, and Lint failures are known and unrelated.)


---

Comment by tscrim created at 2022-09-20 07:57:00

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-09-20 07:57:00

Sorry, lost track of this. LGTM.


---

Comment by mkoeppe created at 2022-09-20 16:29:23

Thank you!


---

Comment by vbraun created at 2022-09-22 22:35:05

Resolution: fixed
