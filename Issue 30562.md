# Issue 30562: Add Folder for Manifold Models

Issue created by migration from https://trac.sagemath.org/ticket/30799

Original creator: @mjungmath

Original creation time: 2020-10-20 10:33:59

CC:  egourgoulhon tscrim

I propose to add a new folder for manifold models:

`src/sage/manifolds/differentiable/models`

Furthermore, I suggest we move `EuclideanSpace` to that folder and make it, besides the global availability, accessible from the catalog, too. The idea is that any manifold model can be accessed via the catalog, and the corresponding files are stored in the `model` folder.

For manifolds with non-smooth structure (or non-diffeomorphic structures), we can add such a folder in `manifolds`, too. But I don't see the need yet.


---

Comment by @mjungmath created at 2020-10-20 10:41:33

There are now two way that I see (not related to this ticket directly):

1) The methods in `catalog.py` operate as a factory method for each model.

2) Each model manages its own factory in its corresponding file (as in `EuclideanSpace` right now).

Namely, some dimensions have peculiarities that we may want to consider (e.g. S<sup>3</sup> is parallelizable).


---

Comment by @mjungmath created at 2020-10-20 13:16:09

Here's my proposal in concrete form. Feedback is welcome.
----
New commits:


---

Comment by git created at 2020-10-20 13:16:46

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2020-10-20 13:28:41

I struggle a bit with the word "model". Other ideas are welcome.


---

Comment by tscrim created at 2020-10-21 09:24:16

I don't care for the name "model" as it means something slightly different to me than what you intend. I would say "examples" is a better name.


---

Comment by @mjungmath created at 2020-10-21 11:23:34

What about calling the folder simply `catalog`? Or would that mess up the structure with the `catalog.py` in the manifold's main folder?


---

Comment by egourgoulhon created at 2020-10-21 16:41:20

Thanks for this ticket. A folder dedicated to standard manifolds sounds like a good idea. Regarding the name, I would lean to `catalog` as suggested in comment:9, with an import statement of the form

```
from sage.manifolds.catalog import Torus   
```

instead of 

```
from sage.manifolds.differentiable.catalog import Torus   
```

which looks unnecessarily longer and probably more difficult to find via introspection. 

Apparently, there is no `catalog` folder in all `src/sage`, only `catalog.py` files. I don't know if there is any reason for this...


---

Comment by git created at 2020-10-21 18:06:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-10-21 18:08:24

Changing status from new to needs_review.


---

Comment by @mjungmath created at 2020-10-21 18:08:24

Doctest works out for `manifolds` folder. I hope I catched all docstrings refering to `EuclideanSpace` and `real_line`.


---

Comment by git created at 2020-10-21 19:08:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-10-21 22:01:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-10-21 23:07:39

Usually there is just a `catalog.py` because things are not sufficiently complex to warrant a separate subfolder and there can be simple(-ish) functions that create objects that benefit from being together in one file.


---

Comment by git created at 2020-10-22 09:16:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-10-22 10:37:37

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2020-10-22 14:12:46

Patchbot is green now. :)


---

Comment by @mjungmath created at 2020-10-22 19:19:31

Replying to [comment:10 egourgoulhon]:
> Thanks for this ticket. A folder dedicated to standard manifolds sounds like a good idea. Regarding the name, I would lean to `catalog` as suggested in comment:9, with an import statement of the form
> {{{
> from sage.manifolds.catalog import Torus   
> }}}
> instead of 
> {{{
> from sage.manifolds.differentiable.catalog import Torus   
> }}}
> which looks unnecessarily longer and probably more difficult to find via introspection. 
> 
> Apparently, there is no `catalog` folder in all `src/sage`, only `catalog.py` files. I don't know if there is any reason for this...

Btw, in addition to that, the examples can currently be invoked by

```
manifolds.Torus()
```


This comes from the fact that `all.py` imports


```
import sage.manifolds.catalog as manifolds
```


I think this is very nice, too.


---

Comment by @tobiasdiez created at 2020-10-23 07:59:27

I would suggest to import the different models in the `catalog/__init__.py` file, so that from a user-perspective there is no real difference in having a big `catalog.py` file or a `catalog` module. This would simplify the import

```
from sage.manifolds.differentiable.catalog.real_line import RealLine
```

to

```
from sage.manifolds.differentiable.catalog import RealLine
```



---

Comment by @mjungmath created at 2020-10-23 08:58:51

Replying to [comment:22 gh-tobiasdiez]:
> I would suggest to import the different models in the `catalog/__init__.py` file, so that from a user-perspective there is no real difference in having a big `catalog.py` file or a `catalog` module. This would simplify the import
> {{{
> from sage.manifolds.differentiable.catalog.real_line import RealLine
> }}}
> to
> {{{
> from sage.manifolds.differentiable.catalog import RealLine
> }}}

The import pattern is currently


```
S2 = manifolds.Sphere(2)
```


and


```
from sage.manifolds.catalog import Sphere

S2 = Sphere(2)
```


I think this is what we should promote. As Eric pointed out in comment:10,


```
from sage.manifolds.differentiable.catalog...
```


is something that should not be promoted, and I agree with him.

However, even if the import pattern is the same, the suggested folder structure is nice because it indicates what examples are differentiable manifolds and what not.


---

Comment by @tobiasdiez created at 2020-10-23 11:14:29

Ok, I also like these conventions. Then I would also promote them in the "normal" Sage code, e.g. `from sage.manifolds.catalog import EuclideanSpace` instead of `from sage.manifolds.differentiable.catalog.euclidean import EuclideanSpace` (in the changes in `catalog.py`).


---

Comment by @mjungmath created at 2020-10-23 12:02:38

Replying to [comment:24 gh-tobiasdiez]:
> Ok, I also like these conventions. Then I would also promote them in the "normal" Sage code, e.g. `from sage.manifolds.catalog import EuclideanSpace` instead of `from sage.manifolds.differentiable.catalog.euclidean import EuclideanSpace` (in the changes in `catalog.py`).

Then I see the problem that the imports rely on the catalog import pattern too much. If we decide to change it at some point, there is too much dependency involved. I personally don't care when the internal import statements are that long.

I think it is always good to import the modules internally from where they are. Besides, I can imagine that the work around could cause a slight slowdown, because the `catalog` module contains further code which is not necessary for the `EuclideanSpace`.

Eric, Travis? What do you say?


---

Comment by @mjungmath created at 2020-10-23 12:35:50

The more I think about it, the more I tend to an `examples` folder instead. This is at least consistent with other modules (see e.g. `homology`).


---

Comment by egourgoulhon created at 2020-10-23 12:42:55

Replying to [comment:21 gh-mjungmath]:
> 
> Btw, in addition to that, the examples can currently be invoked by
> {{{
> manifolds.Torus()
> }}}
> 
> This comes from the fact that `all.py` imports
> 
> {{{
> import sage.manifolds.catalog as manifolds
> }}}
> 
> I think this is very nice, too.
> 

Ah yes indeed, that's the standard way to use the catalog. Much better than the `import` statement I mentioned in comment:10. So let us forget about the latter.


---

Comment by egourgoulhon created at 2020-10-23 12:45:13

Replying to [comment:25 gh-mjungmath]:
> Replying to [comment:24 gh-tobiasdiez]:
> > Ok, I also like these conventions. Then I would also promote them in the "normal" Sage code, e.g. `from sage.manifolds.catalog import EuclideanSpace` instead of `from sage.manifolds.differentiable.catalog.euclidean import EuclideanSpace` (in the changes in `catalog.py`).
> 
> Then I see the problem that the imports rely on the catalog import pattern too much. If we decide to change it at some point, there is too much dependency involved. I personally don't care when the internal import statements are that long.

+1
> 
> I think it is always good to import the modules internally from where they are. 

Indeed.


---

Comment by git created at 2020-10-23 14:05:12

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2020-10-23 14:12:07

Changed `catalog` to `examples` and some further details. Wait for patchbot.


---

Comment by egourgoulhon created at 2020-10-23 20:40:37

I am not sure `examples` is a better name than `catalog` in the present case. Indeed, this folder shall contain most (all?) "standard" manifolds in low dimension: Euclidian spaces, spheres, tori, projective spaces, etc. It looks more than a mere collection of examples to me.


---

Comment by @mjungmath created at 2020-10-23 23:46:02

Replying to [comment:31 egourgoulhon]:
> I am not sure `examples` is a better name than `catalog` in the present case. Indeed, this folder shall contain most (all?) "standard" manifolds in low dimension: Euclidian spaces, spheres, tori, projective spaces, etc. It looks more than a mere collection of examples to me. 

The `homology` module for instance calls their catalog members "examples", too. Moreover, I would prefer `examples` because it doesn't pollute the namespace too much with the preexisting `catalog.py`.


---

Comment by tscrim created at 2020-10-24 05:23:11

I would also go for `examples` rather than `catalog` because we can add functions to the catalog file that are not sufficiently big/detailed to require their own file.

Also, I strongly support directly important from the files at hand. This makes it a little easier to see where cyclic imports are coming from and to help prevent that.


---

Comment by @tobiasdiez created at 2020-10-24 07:37:04

I vote for `catalog`. I thought the long-term goal was to replace the `catalog.py` file by the `catalog` module. You can then still easily add functions to `catalog/__init__py`.


---

Comment by @mjungmath created at 2020-10-24 08:46:40

Stalemate! :D

Replying to [comment:34 gh-tobiasdiez]:
> I vote for `catalog`. I thought the long-term goal was to replace the `catalog.py` file by the `catalog` module.

Not precisely. As Travis pointed out in comment:33, the `catalog.py` still contains entire code of "small" examples. Besides, I think it is best if the `catalog.py` also manages the factories to construct the examples at hand. Let me give two arguments for that:

1. For example, inheriting from a `Manifold` class makes that class a `UniqueRepresentation`. But that is not the behavior we want for examples constructed from `catalog.py` (compare `EuclideanSpace` or the `Manifold` class and the `Manifold` factory method imported to the global namespace).

2. The factory method can delegate special dimensions, exotic counterparts or different realizations to the corresponding implementation.

> You can then still easily add functions to `catalog/__init__py`.

I would advice against it. Nobody expects code in `__init__.py`.


---

Comment by tscrim created at 2020-10-24 08:47:22

Replying to [comment:34 gh-tobiasdiez]:
> I vote for `catalog`. I thought the long-term goal was to replace the `catalog.py` file by the `catalog` module. You can then still easily add functions to `catalog/__init__py`.

That doesn't quite make sense, `catalog.py` is a module (in Python-speak). If you mean folder, then no, that is not the long-term goal.

However, there is not any specific reason to not have code in `__init__.py`.


---

Comment by @tobiasdiez created at 2020-10-24 09:57:53

Ok, what is then the long-term goal?

- The `catalog.py` contains a few examples. But all of them are differentiable and seem complex enough to be put in a separate classes. Should they be put in separate files in the folder `manifolds/differentiable/catalog`?
- Where should one add a example that is not differentiable? The folder `manifolds/catalog` would be the natural choice. But having such a folder would lead to problems as packages have priority over modules, so the `catalog.py` module would not be visible. That's why I proposed to replace the `catalog` module (file) by the `catalog` package (directory).



----

> The factory method can delegate special dimensions, exotic counterparts or different realizations to the corresponding implementation.

I would solve this using the façade pattern. So, if dimension 2 would be special for the sphere, you have a class `Sphere` for every dimension that delegates its work to `Sphere2Dim` and `SphereHigherDim` where the actual implementation is taking place.


---

Comment by @mjungmath created at 2020-10-24 11:09:28

Replying to [comment:37 gh-tobiasdiez]:
> The `catalog.py` contains a few examples. But all of them are differentiable and seem complex enough to be put in a separate classes. Should they be put in separate files in the folder `manifolds/differentiable/catalog`?

You got a point. The most simple examples, Euclidean space and open intervals, are already complex enough to occupy whole files. On the other hand, some examples might stay primitive and are too short to occupy an own file.

> Where should one add a example that is not differentiable? The folder `manifolds/catalog` would be the natural choice. But having such a folder would lead to problems as packages have priority over modules, so the `catalog.py` module would not be visible. That's why I proposed to replace the `catalog` module (file) by the `catalog` package (directory).

This was exactly my worry and is the reason why I proposed `examples` as folder name. If we do as you propose, we additionally have to make sure that the documentation about the catalog remains at least somewhere; `__init__.py` is no option as far as I can see.

> I would solve this using the façade pattern. So, if dimension 2 would be special for the sphere, you have a class `Sphere` for every dimension that delegates its work to `Sphere2Dim` and `SphereHigherDim` where the actual implementation is taking place. 

This sounds like a reasonable approach, too. It is also consistent with the current implementation of `EuclideanSpace`.

On the other hand, the only thing I'm unsure about is whether this approach is flexible enough for adding new examples/alternatives step-by-step, also by developers who might not be not familiar with our discussion here. As for the factory method this is easy and comprehensible: just add another if-clause and/or option.


---

Comment by egourgoulhon created at 2020-10-24 12:24:25

Replying to [comment:38 gh-mjungmath]:
> Replying to [comment:37 gh-tobiasdiez]:
> > The `catalog.py` contains a few examples. But all of them are differentiable and seem complex enough to be put in a separate classes. Should they be put in separate files in the folder `manifolds/differentiable/catalog`?
> 
> You got a point. The most simple examples, Euclidean space and open intervals, are already complex enough to occupy whole files. On the other hand, some examples might stay primitive and are too short to occupy an own file.

Indeed.
> 
> > Where should one add a example that is not differentiable? The folder `manifolds/catalog` would be the natural choice. But having such a folder would lead to problems as packages have priority over modules, so the `catalog.py` module would not be visible. That's why I proposed to replace the `catalog` module (file) by the `catalog` package (directory).
> 
> This was exactly my worry and is the reason why I proposed `examples` as folder name. If we do as you propose, we additionally have to make sure that the documentation about the catalog remains at least somewhere; `__init__.py` is no option as far as I can see.
> 

OK, to be consistent with the rest of Sage code, it's probably wise to keep the `catalog.py` file and rename the folder(s) by something else than `catalog`. I was somewhat reluctant about `examples`, but at the moment I don't have any better name to suggest (besides `models` as already suggested by Michael, `realizations` came to my mind but I am not sure it's pertinent...).
> > I would solve this using the façade pattern. So, if dimension 2 would be special for the sphere, you have a class `Sphere` for every dimension that delegates its work to `Sphere2Dim` and `SphereHigherDim` where the actual implementation is taking place. 
> 
> This sounds like a reasonable approach, too. It is also consistent with the current implementation of `EuclideanSpace`.
> 

Yes. Most probably, we need a `Sphere2D` class, at least for the standard naming of spherical coordinates as (theta, phi). We shall also need special subclasses for parallelizable spheres
(S<sup>1</sup>, S<sup>3</sup> and S<sup>7</sup>).
> On the other hand, the only thing I'm unsure about is whether this approach is flexible enough for adding new examples/alternatives step-by-step, also by developers who might not be not familiar with our discussion here. As for the factory method this is easy and comprehensible: just add another if-clause and/or option.

Yes factory approach might be better in this respect. It avoids to invoke  `__classcall_private__`, as currently done in `EuclideanSpace`.


---

Comment by @mjungmath created at 2020-10-24 13:10:24

Allow me to summarize the accumulated discussion. Unfortunately, we can't start polls here (a feature I completely miss).

- For consistency, to keep the documentation, and to obtain a more comprehensible factory pattern, it is better to keep the `catalog.py`.
- In conclusion, we have to choose another name for the folders. Possible suggestions:
  1. `models`
  2. `examples`
  3. `realizations`
- Which pattern?
  1. Special dimensions of the same implementation could be treated via facade pattern as it has been done for `EuclideanSpace`, whereas more deviating realizations could be treated via factory method pattern in `catalog.py`.
  2. Everything is regulated via facade.
  3. Everything is regulated via factory method in `catalog.py`.

----

With respect to the last point, I suggest that _every_ cataloged manifold should have it's own method in `catalog.py` for documentation and unification reasons. This also avoids duplicated or circular imports.

----

Please let me know if I caught something wrong.


---

Comment by @tobiasdiez created at 2020-10-24 15:33:25

Ok, I'm convinced: +1 for `examples`. I would also tend to put every example in its own file. It's more consistent and I don't see any disadvantages of having "small" classes. 

For the pattern, it probably depends on the concrete example and how much the implementations differ. In general, the factory pattern is good when you have completely independent implementations of some interface (e.g. getting infos from a file vs from an web api) whereas the façade pattern excels at hiding the implementation details. You can also combine them easily.
For example, for the sphere one could imagine the following:
- A general class `Sphere` that acts as a façade for `Sphere2Dim` and `SphereHigherDim` (e.g. because you might have more effective ways to calculate in 2d).
- Classes for `d=1,3,7` deriving from `Sphere` and adding the parallelizable aspect.
- Factory method in `catalog.py` that based on the dimension invokes the constructor of `Sphere` or one of its subclasses for `d=1,3,7`


---

Comment by @mjungmath created at 2020-10-24 18:50:05

Replying to [comment:41 gh-tobiasdiez]:
> I would also tend to put every example in its own file. It's more consistent and I don't see any disadvantages of having "small" classes.

I disagree here. Dedicated methods to each example are a good thing anyway imho, see comment:40. So why not leave the simple constructions there?

> For the pattern, it probably depends on the concrete example and how much the implementations differ. In general, the factory pattern is good when you have completely independent implementations of some interface (e.g. getting infos from a file vs from an web api) whereas the façade pattern excels at hiding the implementation details. You can also combine them easily.
> For example, for the sphere one could imagine the following:
> - A general class `Sphere` that acts as a façade for `Sphere2Dim` and `SphereHigherDim` (e.g. because you might have more effective ways to calculate in 2d).
> - Classes for `d=1,3,7` deriving from `Sphere` and adding the parallelizable aspect.
> - Factory method in `catalog.py` that based on the dimension invokes the constructor of `Sphere` or one of its subclasses for `d=1,3,7`

Totally! I think this is how we should do it. The parallelizable cases have the same charts, but in contrast to their brothers a global frame which can be constructed in the corresponding classes. So, I'd prefer the façade pattern here as well. But this is something we should discuss in more detail in #30804.


---

Comment by git created at 2020-10-25 15:49:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-10-25 15:54:18

What about this? I think, the `UniqueRepresentation` behavior should now be consistent with `Manifold()`.

However, with this commit, there is a doctest error in line 215 of `real_line.py`...


---

Comment by @mjungmath created at 2020-10-25 20:10:12

Replying to [comment:45 gh-mjungmath]:
> However, with this commit, there is a doctest error in line 215 of `real_line.py`...

See #30830 for details.


---

Comment by @mjungmath created at 2020-10-26 10:26:40

Replying to [comment:45 gh-mjungmath]:
> What about this? I think, the `UniqueRepresentation` behavior should now be consistent with `Manifold()`.
> 
> However, with this commit, there is a doctest error in line 215 of `real_line.py`...

To elaborate: each manifold constructed from the global namespace, i.e. via the factory method, obtains a unique tag. That means, each invokation constructs a new object.

For consistency, this should hold for `OpenInterval` and `RealLine`, too. And for more consistency, it is good to manage this behavior via factory methods.

Please object if you disagree.


---

Comment by egourgoulhon created at 2020-10-26 11:08:44

Replying to [comment:47 gh-mjungmath]:
> Replying to [comment:45 gh-mjungmath]:
> > What about this? I think, the `UniqueRepresentation` behavior should now be consistent with `Manifold()`.
> > 
> > However, with this commit, there is a doctest error in line 215 of `real_line.py`...
> 
> To elaborate: each manifold constructed from the global namespace, i.e. via the factory method, obtains a unique tag. That means, each invokation constructs a new object.
> 
> For consistency, this should hold for `OpenInterval` and `RealLine`, too.

No, `OpenInterval` and `RealLine` are truely `UniqueRepresentation` objects. The unique tag trick shall not apply to them.

Anyway, the unique tag issue is beyond the scope of this ticket, I believe. 
At some point, we should get rid of `UniqueRepresentation` inheritance for generic manifolds. It is a workaround to have a correct pickling, which is necessary for parallelized computations.


---

Comment by @mjungmath created at 2020-10-26 11:13:59

Replying to [comment:48 egourgoulhon]:
> No, `OpenInterval` and `RealLine` are truely `UniqueRepresentation` objects. The unique tag trick shall not apply to them.

What is the intention behind it?

> Anyway, the unique tag issue is beyond the scope of this ticket, I believe. 
> At some point, we should get rid of `UniqueRepresentation` inheritance for generic manifolds. It is a workaround to have a correct pickling, which is necessary for parallelized computations.

You're right. However, it is somehow entwined. It wouldn't make sense to create a factory method somewhere else than in `catalog.py`.


---

Comment by egourgoulhon created at 2020-10-26 12:22:59

Replying to [comment:49 gh-mjungmath]:
> Replying to [comment:48 egourgoulhon]:
> > No, `OpenInterval` and `RealLine` are truely `UniqueRepresentation` objects. The unique tag trick shall not apply to them.
> 
> What is the intention behind it?

`RealLine()` or `OpenInterval(0,1)` fully defines the mathematical object, `Manifold(2, 'M')` does not.


---

Comment by @mjungmath created at 2020-10-26 12:37:42

Replying to [comment:50 egourgoulhon]:
> Replying to [comment:49 gh-mjungmath]:
> > Replying to [comment:48 egourgoulhon]:
> > > No, `OpenInterval` and `RealLine` are truely `UniqueRepresentation` objects. The unique tag trick shall not apply to them.
> > 
> > What is the intention behind it?
> 
> `RealLine()` or `OpenInterval(0,1)` fully defines the mathematical object, `Manifold(2, 'M')` does not.
> 

Mh, I see. And `EuclideanSpace(2)` could still yield two different but isomorphic mathematical entities.

But what about `OpenInterval(0,1)` and `OpenInterval(0,1, name='I')`. Or `OpenInterval(-oo,oo)` and `RealLine()`. Same mathematical object, but different instances.

I think, this should be catched via `__classcall_private__` then. However, that's definitely beyond the scope of this ticket.

----

So, what's your proposal with the import/method/catalog behavior then? Keep the version of comment:29?


---

Comment by tscrim created at 2020-10-27 23:07:09

Replying to [comment:48 egourgoulhon]:
> Replying to [comment:47 gh-mjungmath]:
> > Replying to [comment:45 gh-mjungmath]:
> > > What about this? I think, the `UniqueRepresentation` behavior should now be consistent with `Manifold()`.
> > > 
> > > However, with this commit, there is a doctest error in line 215 of `real_line.py`...
> > 
> > To elaborate: each manifold constructed from the global namespace, i.e. via the factory method, obtains a unique tag. That means, each invokation constructs a new object.
> > 
> > For consistency, this should hold for `OpenInterval` and `RealLine`, too.
> 
> No, `OpenInterval` and `RealLine` are truely `UniqueRepresentation` objects. The unique tag trick shall not apply to them.
> 
> Anyway, the unique tag issue is beyond the scope of this ticket, I believe. 
> At some point, we should get rid of `UniqueRepresentation` inheritance for generic manifolds. It is a workaround to have a correct pickling, which is necessary for parallelized computations.
> 

I still haven't forgotten that I promised you I would do that. It is on my to-do list. Sorry for taking so long.


---

Comment by git created at 2020-10-30 22:56:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2020-10-30 23:00:25

Like Eric pointed out correctly, some things discussed here go beyond the scope of this ticket. I reverted the branch to an older version, where I used lazy imports into `catalog.py`.

Lazy import should prevent circular and unneccessary imports.

Patchbot is already green.


---

Comment by tscrim created at 2020-10-31 07:21:40

We can do further changes in other tickets. I think it is good to take some smaller steps in each ticket.


---

Comment by tscrim created at 2020-10-31 07:21:40

Changing status from needs_review to positive_review.


---

Comment by @mjungmath created at 2020-10-31 12:10:11

I agree.

Thanks.


---

Comment by vbraun created at 2020-11-01 00:42:12

Resolution: fixed
