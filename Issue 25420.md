# Issue 25420: 1.coprime_integers(n) should return [0]

Issue created by migration from https://trac.sagemath.org/ticket/25657

Original creator: jdemeyer

Original creation time: 2018-06-25 08:41:34

CC:  chapoton

The method `coprime_integers` is documented to return only _positive_ integers, but it would be much more natural to return _non-negative_ integers. It would in particular imply that `len(n.coprime_integers(n)) == euler_phi(n)` (which currently fails for `n == 1`).

The fact that various callers of `coprime_integers` need to work around this shows that the current choice is wrong.


---

Comment by chapoton created at 2018-06-25 08:55:51

no. The reason why "euler_phi(1)=1" is because 1 is coprime to 1, not because 0 is coprime to 1.


---

Comment by jdemeyer created at 2018-06-25 09:12:33

Replying to [comment:1 chapoton]:
> 1 is coprime to 1, not because 0 is coprime to 1.

Well, both are true so it doesn't matter how you count. The point is `euler_phi(1) == 1`.


---

Comment by git created at 2018-06-25 09:45:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-06-25 09:45:26

Changing status from new to needs_review.


---

Comment by sbrandhorst created at 2018-07-03 19:42:56

In fact if a is an integer, then a divides 0 so the greatest common divisor 
of a and 0 is a. Thus 0 is not coprime to any integer. 
In particular 1.coprime_integers(n) should return [1,..., n-1] as is the case now.

Thus I would vote to close this ticket.


---

Comment by jdemeyer created at 2018-07-04 04:44:01

Replying to [comment:6 sbrandhorst]:
> In fact if a is an integer, then a divides 0 so the greatest common divisor 
> of a and 0 is a.

...which is equal to 1 in the case a == 1, so 0 is coprime to 1. That's the point of this ticket.


---

Comment by jdemeyer created at 2018-07-04 04:46:42

To put it in a different way: currently, we have

```
len(a.coprime_integers(n * a)) == n * euler_phi(a)
```

_except_ if a == 1. That's unexpected and a bug in my opinion.


---

Comment by sbrandhorst created at 2018-07-04 07:07:38

Replying to [comment:7 jdemeyer]:
> Replying to [comment:6 sbrandhorst]:
> > In fact if a is an integer, then a divides 0 so the greatest common divisor 
> > of a and 0 is a.
> 
> ...which is equal to 1 in the case a == 1, so 0 is coprime to 1. That's the point of this ticket.
Right, sorry :). 

The patchbot complains but the failing test

```
sage -t src/sage/schemes/hyperelliptic_curves/hyperelliptic_finite_field.py
```

passes on my machine. 

Your changes look fine. Though I do not have much experience with cython.
So I cannot really judge things like Integer(ilong) vs smallInteger(k). 
Is seems to be supposed to speedup for integers <256? Can you provide timings for this?

I am not sure if that was a bug. After all the behaviour matched the description.
We may want to add a deprecation warning to indicate the change in behaviour?


---

Comment by sbrandhorst created at 2018-07-04 07:23:24

Replying to [comment:2 jdemeyer]:
> Replying to [comment:1 chapoton]:
> > 1 is coprime to 1, not because 0 is coprime to 1.
> 
> Well, both are true so it doesn't matter how you count. The point is `euler_phi(1) == 1`.

If we stay close to the definition of euler_phi, then
`1.coprime_integers(n)` should return `[1]`
so it does matter. Returning `[0]` seems to be more pythonic, but returning `[1]` seems a little closer to math conventions. I would tend to the pythonic interpretation. But both behaviours are better than `[]`. So I am fine with either.


---

Comment by chapoton created at 2018-07-04 07:25:16

I do not like the proposed change. People not happy with `n.coprime_integers(n)` should just use `n.coprime_integers(n+1)`, which has the correct behaviour for n=1.


---

Comment by jdemeyer created at 2018-07-05 08:55:09

Replying to [comment:11 sbrandhorst]:
> Returning `[0]` seems to be more pythonic, but returning `[1]` seems a little closer to math conventions.

I disagree with the latter. I have never seen anybody write `n mod n`, mathematicians typically write `0 mod n`.

So both Python and math indicate that `[0]` is the right answer for `1.coprime_integers(1)`.


---

Comment by jdemeyer created at 2018-07-05 10:08:40

Replying to [comment:10 sbrandhorst]:
> I am not sure if that was a bug. After all the behaviour matched the description.
> We may want to add a deprecation warning to indicate the change in behaviour?

It's obvious to me that the current function doesn't do "The Right Thing". So it's a bug to me (even if documented).


---

Comment by pbruin created at 2018-07-09 11:57:15

I agree with Jeroen that the most natural definition for `1.coprime_integers(1)` is `[0]`.  My argument for this is that `n.coprime_integers(n)` should return representatives of the invertible residue classes modulo _n_, and the standard representative for the residue class of 0 modulo _n_ (which is only invertible if _n_ = 1) is 0.


---

Comment by pbruin created at 2018-07-10 13:38:34

Changing status from needs_review to positive_review.


---

Comment by pbruin created at 2018-07-10 13:38:34

In my opinion the function now does "The Right Thing", and test pass.


---

Comment by vbraun created at 2018-08-05 08:18:05

Resolution: fixed
