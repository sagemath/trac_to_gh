# Issue 28251: Torsion subgroup of elliptic curves over number fields: more efficient method

Issue created by migration from https://trac.sagemath.org/ticket/28488

Original creator: cremona

Original creation time: 2019-09-13 16:00:44

CC:  wuthrich

Keywords: elliptic curve torsion subgroup

Let E be an elliptic curve defined over a number field K.  Then E.torsion_subgroup() returns its torsion subgroup T,a finite abelian group with at most two generators, proceeding in two steps:
   1. Compute a bound B for (a multiple of) #T.
   2. For each p dividing B find the p-torsion then the p-power torsion then combine.
For step 1 we reduce E mod P for several primes P chosen such that the reduction map is injective on T, compute the cardinality of E mod P and take the gcd.  The current implementation finds the primes P using K.primes_above(p) for rational primes p, which in turn requires (as currently implemented) knowing the maximal order in K, and this can be prohibitively expensive.  (In current work I have fields K of degree 16 defined by polynomials whose discriminant has hundreds of digits, and the computation sometimes  does not finish even after several hours.)

The proposed improvement makes the computation of B trivially fast.  Assume for simplicity that K is defined by a monic polynomial f(X) in ZZ[X] and that the defining coefficients of E are in ZZ[a] where a is a root of f.  (The implementation will of course handle the general case.)  Take odd rational primes p not dividing disc(f) or the norm of cond(E).  The one can find the primes P above p simply by factoring f(X) mod p; to each factor f_i of degree d_i take a root a_i of f mod p and reduce E by mapping a to a_i, then compute its cardinality.  (We have avoided any p which are ramified in K or for which the order ZZ[a] is not p-maximal.)

A useful simplification is possible when E is actually defined over QQ (which is the case for my current project, where I have implemented this).  Now the cardinalities we need (whose gcd gives B) are just E.reduction(p).cardinality(extension_degree=d_i) as d_i runs over the degrees of the factors of f mod p.

My implementation of the special case has already been running over several million cases with deg(f) up to 21.


---

Comment by cremona created at 2019-09-13 16:10:18

Here is the code I have been using in the special case.

```
def torsion_bound_over_extension(E, pol, verbose=0):
    """Given E/Q and pol (monic irreducble in ZZ[X]) defining an                                                                                                                                                                                                            
    extension field K, compute an upper bound for E(K)_tors                                                                                                                                                                                                                 
    """
    Dpol = ZZ(pol.discriminant())
    Dcurve = ZZ(E.discriminant())
    np = 0
    bound = ZZ(0)
    Qtorsion = E.torsion_order()
    for p in primes(100):
        # Skip ramified primes and p=2.  As in the standard version:                                                                                                                                                                                                        
        # check if the formal group at the place is torsion-free                                                                                                                                                                                                            
        # if so the torsion injects into the reduction                                                                                                                                                                                                                      
        if p==2 or Dpol%p==0 or Dcurve%p==0:
            continue

        np += 1
        Emodp = E.reduction(p)
        degs = [fac.degree() for fac,e in pol.factor_mod(p)]
        bds = [Emodp.cardinality(extension_degree=d) for d in degs]
        newbound = gcd(bds)
        if verbose:
            print("Torsion orders over extension p={} are {} with gcd {}".format(p,bds,newbound))
        newbound = bound.gcd(newbound)
        if verbose:
            print("Bound from primes up to {} is {}".format(p,newbound))
        if bound == Qtorsion:
            return bound
        if np>10 and newbound==bound:
            return bound
        bound = newbound
    if bound==0:
        print("torsion_bound_over_extension error: no good primes up to 100")
    return bound
```



---

Comment by cremona created at 2019-09-17 08:40:51

I moved the torsion_bound function into ell_torsion.py (it used to be a method _torsion_bound of the elliptic curve class).

The code divides into 3 cases: (1) base field QQ, (2) base field not QQ but all a-invariants in QQ, (3) general.  It would be possible to extend (2) to cover any curve which is isomorphic to a base_change.
----
New commits:


---

Comment by cremona created at 2019-09-17 08:40:51

Changing status from new to needs_review.


---

Comment by chapoton created at 2019-09-18 06:58:44

ok, green bot. Thanks


---

Comment by chapoton created at 2019-09-18 06:58:44

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2019-09-18 06:59:37

one second, I will fix some details


---

Comment by chapoton created at 2019-09-18 06:59:37

Changing status from positive_review to needs_work.


---

Comment by chapoton created at 2019-09-18 07:09:06

John, please double check my last commit (only simple changes) and then you can set to positive on my behalf.
----
New commits:


---

Comment by chapoton created at 2019-09-18 07:09:06

Changing status from needs_work to needs_review.


---

Comment by cremona created at 2019-09-18 07:57:12

Changing status from needs_review to positive_review.


---

Comment by cremona created at 2019-09-18 07:57:12

Replying to [comment:5 chapoton]:
> John, please double check my last commit (only simple changes) and then you can set to positive on my behalf.
> ----
> New commits:
> ||[1c3d27e](https://git.sagemath.org/sage.git/commit?id=1c3d27ef734f42e1ac1737fbb23fa77997760c1a)||`trac 28488 fixing some details (pep8, doc, etc)`||

Looks good -- thanks for sorting out my bad style.  (I did originally used def red(c) and changed to a lambda at the last minute as it's a one-liner.)


---

Comment by chapoton created at 2019-09-30 08:12:27

moving milestone to 9.0 (after release of 8.9)


---

Comment by vbraun created at 2019-10-05 07:58:04

Resolution: fixed
