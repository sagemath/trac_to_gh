# Issue 28251: Torsion subgroup of elliptic curves over number fields: more efficient method

archive/issues_028251.json:
```json
{
    "body": "CC:  wuthrich\n\nKeywords: elliptic curve torsion subgroup\n\nLet E be an elliptic curve defined over a number field K.  Then E.torsion_subgroup() returns its torsion subgroup T,a finite abelian group with at most two generators, proceeding in two steps:\n1. Compute a bound B for (a multiple of) #T.\n2. For each p dividing B find the p-torsion then the p-power torsion then combine.\nFor step 1 we reduce E mod P for several primes P chosen such that the reduction map is injective on T, compute the cardinality of E mod P and take the gcd.  The current implementation finds the primes P using K.primes_above(p) for rational primes p, which in turn requires (as currently implemented) knowing the maximal order in K, and this can be prohibitively expensive.  (In current work I have fields K of degree 16 defined by polynomials whose discriminant has hundreds of digits, and the computation sometimes  does not finish even after several hours.)\n\nThe proposed improvement makes the computation of B trivially fast.  Assume for simplicity that K is defined by a monic polynomial f(X) in ZZ[X] and that the defining coefficients of E are in ZZ[a] where a is a root of f.  (The implementation will of course handle the general case.)  Take odd rational primes p not dividing disc(f) or the norm of cond(E).  The one can find the primes P above p simply by factoring f(X) mod p; to each factor f_i of degree d_i take a root a_i of f mod p and reduce E by mapping a to a_i, then compute its cardinality.  (We have avoided any p which are ramified in K or for which the order ZZ[a] is not p-maximal.)\n\nA useful simplification is possible when E is actually defined over QQ (which is the case for my current project, where I have implemented this).  Now the cardinalities we need (whose gcd gives B) are just E.reduction(p).cardinality(extension_degree=d_i) as d_i runs over the degrees of the factors of f mod p.\n\nMy implementation of the special case has already been running over several million cases with deg(f) up to 21.\n\nIssue created by migration from https://trac.sagemath.org/ticket/28488\n\n",
    "created_at": "2019-09-13T16:00:44Z",
    "labels": [
        "elliptic curves",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.0",
    "title": "Torsion subgroup of elliptic curves over number fields: more efficient method",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28251",
    "user": "cremona"
}
```
CC:  wuthrich

Keywords: elliptic curve torsion subgroup

Let E be an elliptic curve defined over a number field K.  Then E.torsion_subgroup() returns its torsion subgroup T,a finite abelian group with at most two generators, proceeding in two steps:
1. Compute a bound B for (a multiple of) #T.
2. For each p dividing B find the p-torsion then the p-power torsion then combine.
For step 1 we reduce E mod P for several primes P chosen such that the reduction map is injective on T, compute the cardinality of E mod P and take the gcd.  The current implementation finds the primes P using K.primes_above(p) for rational primes p, which in turn requires (as currently implemented) knowing the maximal order in K, and this can be prohibitively expensive.  (In current work I have fields K of degree 16 defined by polynomials whose discriminant has hundreds of digits, and the computation sometimes  does not finish even after several hours.)

The proposed improvement makes the computation of B trivially fast.  Assume for simplicity that K is defined by a monic polynomial f(X) in ZZ[X] and that the defining coefficients of E are in ZZ[a] where a is a root of f.  (The implementation will of course handle the general case.)  Take odd rational primes p not dividing disc(f) or the norm of cond(E).  The one can find the primes P above p simply by factoring f(X) mod p; to each factor f_i of degree d_i take a root a_i of f mod p and reduce E by mapping a to a_i, then compute its cardinality.  (We have avoided any p which are ramified in K or for which the order ZZ[a] is not p-maximal.)

A useful simplification is possible when E is actually defined over QQ (which is the case for my current project, where I have implemented this).  Now the cardinalities we need (whose gcd gives B) are just E.reduction(p).cardinality(extension_degree=d_i) as d_i runs over the degrees of the factors of f mod p.

My implementation of the special case has already been running over several million cases with deg(f) up to 21.

Issue created by migration from https://trac.sagemath.org/ticket/28488





---

archive/issue_comments_399010.json:
```json
{
    "body": "Here is the code I have been using in the special case.\n\n```\ndef torsion_bound_over_extension(E, pol, verbose=0):\n    \"\"\"Given E/Q and pol (monic irreducble in ZZ[X]) defining an                                                                                                                                                                                                            \n    extension field K, compute an upper bound for E(K)_tors                                                                                                                                                                                                                 \n    \"\"\"\n    Dpol = ZZ(pol.discriminant())\n    Dcurve = ZZ(E.discriminant())\n    np = 0\n    bound = ZZ(0)\n    Qtorsion = E.torsion_order()\n    for p in primes(100):\n        # Skip ramified primes and p=2.  As in the standard version:                                                                                                                                                                                                        \n        # check if the formal group at the place is torsion-free                                                                                                                                                                                                            \n        # if so the torsion injects into the reduction                                                                                                                                                                                                                      \n        if p==2 or Dpol%p==0 or Dcurve%p==0:\n            continue\n\n        np += 1\n        Emodp = E.reduction(p)\n        degs = [fac.degree() for fac,e in pol.factor_mod(p)]\n        bds = [Emodp.cardinality(extension_degree=d) for d in degs]\n        newbound = gcd(bds)\n        if verbose:\n            print(\"Torsion orders over extension p={} are {} with gcd {}\".format(p,bds,newbound))\n        newbound = bound.gcd(newbound)\n        if verbose:\n            print(\"Bound from primes up to {} is {}\".format(p,newbound))\n        if bound == Qtorsion:\n            return bound\n        if np>10 and newbound==bound:\n            return bound\n        bound = newbound\n    if bound==0:\n        print(\"torsion_bound_over_extension error: no good primes up to 100\")\n    return bound\n```\n",
    "created_at": "2019-09-13T16:10:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399010",
    "user": "cremona"
}
```

Here is the code I have been using in the special case.

```
def torsion_bound_over_extension(E, pol, verbose=0):
    """Given E/Q and pol (monic irreducble in ZZ[X]) defining an                                                                                                                                                                                                            
    extension field K, compute an upper bound for E(K)_tors                                                                                                                                                                                                                 
    """
    Dpol = ZZ(pol.discriminant())
    Dcurve = ZZ(E.discriminant())
    np = 0
    bound = ZZ(0)
    Qtorsion = E.torsion_order()
    for p in primes(100):
        # Skip ramified primes and p=2.  As in the standard version:                                                                                                                                                                                                        
        # check if the formal group at the place is torsion-free                                                                                                                                                                                                            
        # if so the torsion injects into the reduction                                                                                                                                                                                                                      
        if p==2 or Dpol%p==0 or Dcurve%p==0:
            continue

        np += 1
        Emodp = E.reduction(p)
        degs = [fac.degree() for fac,e in pol.factor_mod(p)]
        bds = [Emodp.cardinality(extension_degree=d) for d in degs]
        newbound = gcd(bds)
        if verbose:
            print("Torsion orders over extension p={} are {} with gcd {}".format(p,bds,newbound))
        newbound = bound.gcd(newbound)
        if verbose:
            print("Bound from primes up to {} is {}".format(p,newbound))
        if bound == Qtorsion:
            return bound
        if np>10 and newbound==bound:
            return bound
        bound = newbound
    if bound==0:
        print("torsion_bound_over_extension error: no good primes up to 100")
    return bound
```




---

archive/issue_comments_399011.json:
```json
{
    "body": "I moved the torsion_bound function into ell_torsion.py (it used to be a method _torsion_bound of the elliptic curve class).\n\nThe code divides into 3 cases: (1) base field QQ, (2) base field not QQ but all a-invariants in QQ, (3) general.  It would be possible to extend (2) to cover any curve which is isomorphic to a base_change.\n----\nNew commits:",
    "created_at": "2019-09-17T08:40:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399011",
    "user": "cremona"
}
```

I moved the torsion_bound function into ell_torsion.py (it used to be a method _torsion_bound of the elliptic curve class).

The code divides into 3 cases: (1) base field QQ, (2) base field not QQ but all a-invariants in QQ, (3) general.  It would be possible to extend (2) to cover any curve which is isomorphic to a base_change.
----
New commits:



---

archive/issue_comments_399012.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-09-17T08:40:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399012",
    "user": "cremona"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_399013.json:
```json
{
    "body": "ok, green bot. Thanks",
    "created_at": "2019-09-18T06:58:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399013",
    "user": "chapoton"
}
```

ok, green bot. Thanks



---

archive/issue_comments_399014.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-09-18T06:58:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399014",
    "user": "chapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_399015.json:
```json
{
    "body": "one second, I will fix some details",
    "created_at": "2019-09-18T06:59:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399015",
    "user": "chapoton"
}
```

one second, I will fix some details



---

archive/issue_comments_399016.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2019-09-18T06:59:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399016",
    "user": "chapoton"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_399017.json:
```json
{
    "body": "John, please double check my last commit (only simple changes) and then you can set to positive on my behalf.\n----\nNew commits:",
    "created_at": "2019-09-18T07:09:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399017",
    "user": "chapoton"
}
```

John, please double check my last commit (only simple changes) and then you can set to positive on my behalf.
----
New commits:



---

archive/issue_comments_399018.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-09-18T07:09:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399018",
    "user": "chapoton"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_399019.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-09-18T07:57:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399019",
    "user": "cremona"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_399020.json:
```json
{
    "body": "Replying to [comment:5 chapoton]:\n> John, please double check my last commit (only simple changes) and then you can set to positive on my behalf.\n> ----\n> New commits:\n> ||[1c3d27e](https://git.sagemath.org/sage.git/commit?id=1c3d27ef734f42e1ac1737fbb23fa77997760c1a)||`trac 28488 fixing some details (pep8, doc, etc)`||\n\nLooks good -- thanks for sorting out my bad style.  (I did originally used def red(c) and changed to a lambda at the last minute as it's a one-liner.)",
    "created_at": "2019-09-18T07:57:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399020",
    "user": "cremona"
}
```

Replying to [comment:5 chapoton]:
> John, please double check my last commit (only simple changes) and then you can set to positive on my behalf.
> ----
> New commits:
> ||[1c3d27e](https://git.sagemath.org/sage.git/commit?id=1c3d27ef734f42e1ac1737fbb23fa77997760c1a)||`trac 28488 fixing some details (pep8, doc, etc)`||

Looks good -- thanks for sorting out my bad style.  (I did originally used def red(c) and changed to a lambda at the last minute as it's a one-liner.)



---

archive/issue_comments_399021.json:
```json
{
    "body": "moving milestone to 9.0 (after release of 8.9)",
    "created_at": "2019-09-30T08:12:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399021",
    "user": "chapoton"
}
```

moving milestone to 9.0 (after release of 8.9)



---

archive/issue_comments_399022.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-10-05T07:58:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28251",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28251#issuecomment-399022",
    "user": "vbraun"
}
```

Resolution: fixed
