# Issue 27396: Redesign of the constructor for Hyperelliptic curves

Issue created by migration from https://trac.sagemath.org/ticket/27633

Original creator: annasomoza

Original creation time: 2019-04-10 08:28:48

CC:  sijsling mstreng vdelecroix slelievre




---

Comment by annasomoza created at 2019-04-11 08:35:16

Changing status from new to needs_review.


---

Comment by annasomoza created at 2019-04-11 08:35:16

Changing component from PLEASE CHANGE to number theory.


---

Comment by annasomoza created at 2019-04-11 08:35:16

Changing keywords from "" to "days98, hyperelliptic curves".


---

Comment by annasomoza created at 2019-04-11 08:35:16

Changing type from PLEASE CHANGE to enhancement.


---

Comment by vdelecroix created at 2019-04-11 08:48:49

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2019-04-11 08:48:49

This is a good move.

The logic in the following is weird

```
fld = map(lambda fnc : fnc(R), [is_FiniteField, is_RationalField, is_pAdicField])
fld_type = fld.index(True)
```

You would rather do something like

```
fields = [
   ("FiniteField", is_FiniteField, HyperellipticCurve_finite_field),
   ("RationalField", is_RationalField, HyperellipticCurve_rational_field),
   ("pAdicField", is_pAdicField, HyperellipticCurve_padic_field)]
for name, test, cls in fields:
    if test(R):
        ....    # treat the class
        break   # the tests are exclusive, no need to run through all cases
```



---

Comment by git created at 2019-04-11 09:07:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by annasomoza created at 2019-04-11 09:09:26

Agreed, with your approach the code is easier to understand.


---

Comment by annasomoza created at 2019-04-11 09:09:26

Changing status from needs_work to needs_review.


---

Comment by git created at 2019-04-11 12:38:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-04-11 12:43:22

Similarly, why do you construct a dictionary in the following

```
+    genus_class = {2:HyperellipticCurve_g2}
+    if g in genus_class.keys():
+        supercls.append(genus_class[g])
```

This is simpler as

```
if g == 2:
    supercls.append(HyperellipticCurve_g2)
```



---

Comment by annasomoza created at 2019-04-11 13:17:09

This I did with #22173 in mind, where I will add the class for genus 3 to the dictionary (I am working on it right now). In general, if more genus are added, then using the dictionary leads to a cleaner code than a list of ifs.


---

Comment by vdelecroix created at 2019-04-11 13:22:03

I see. What about?

```
if g == 2:
    supercls.append(HyperellipticCurve_g2)
# elif g == 3:
#     supercls.append(HyperellipticCurve_g3)
```



---

Comment by vdelecroix created at 2019-04-11 13:29:58

What do you think about removing the inheritance from `HyperellipticCurve_generic`
in `HyperellipticCurve_rational_field`, `HyperellipticCurve_padic_field`, etc? All the inheritance is handled by this new function anyway.

In this case, the function would be

```
cls = [HyperellipticCurve_generic]

...

if len(cls) > 1:   # contains more than just HyperellipticCurve_generic
    cls = type("HyperellipticCurve_" + "_".join(cls_name), tuple(cls), {})

return cls(PP, f, h, names=names, genus=g)
```



---

Comment by vdelecroix created at 2019-04-11 13:31:31

And last but not the least, you definitely don't to create twice the same class. The first reason for this is that if you construct twice a hyperelliptic curves over rational you want the type to be the same. But the type function will recreate a new class each time (even if it has the same name).

Also, you don't want to create classes that are not necessary. Creating a class for each genus is a waste of time.


---

Comment by git created at 2019-04-11 14:47:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by annasomoza created at 2019-04-11 14:50:09

Replying to [comment:9 vdelecroix]:
> I see. What about?
> {{{
> if g == 2:
>     supercls.append(HyperellipticCurve_g2)
> # elif g == 3:
> #     supercls.append(HyperellipticCurve_g3)
> }}}

How about this new version? There I just use the information of the classes that are imported in the module. 

Replying to [comment:10 vdelecroix]:
> What do you think about removing the inheritance from `HyperellipticCurve_generic`
> in `HyperellipticCurve_rational_field`, `HyperellipticCurve_padic_field`, etc? All the inheritance is handled by this new function anyway.
> 
> In this case, the function would be
> {{{
> cls = [HyperellipticCurve_generic]
> 
> ...
> 
> if len(cls) > 1:   # contains more than just HyperellipticCurve_generic
>     cls = type("HyperellipticCurve_" + "_".join(cls_name), tuple(cls), {})
> 
> return cls(PP, f, h, names=names, genus=g)
> }}}

The methods in `HyperellipticCurve_rational_field` and others use methods from `HyperellipticCurve_generic`, so I don't think that it is a good idea.

Replying to [comment:11 vdelecroix]:
> And last but not the least, you definitely don't to create twice the same class. The first reason for this is that if you construct twice a hyperelliptic curves over rational you want the type to be the same. But the type function will recreate a new class each time (even if it has the same name).
> 
> Also, you don't want to create classes that are not necessary. Creating a class for each genus is a waste of time.

Agreed, I included the functionality and added a test for it.


---

Comment by vdelecroix created at 2019-04-12 06:19:32

Replying to [comment:13 annasomoza]:
> Replying to [comment:9 vdelecroix]:
> > I see. What about?
> > {{{
> > if g == 2:
> >     supercls.append(HyperellipticCurve_g2)
> > # elif g == 3:
> > #     supercls.append(HyperellipticCurve_g3)
> > }}}
> 
> How about this new version? There I just use the information of the classes that are imported in the module. 

This is terrible. Explicit code is to my mind much better. With the current version, a curious person looking at the code would have no clue about how it works.


---

Comment by vdelecroix created at 2019-04-12 06:21:00

Otherwise, the caching with the dictionary is ok.


---

Comment by VivianePons created at 2019-04-12 07:44:00

The new version is good as it forces new contributions to follow the same name pattern and only requires to add the new class without changing the source code of the main function. 

So I don't think "terrible" is an appropriate adjective! (Unless you have an other way to catch the existing classes?) A list of ifs might just get very long and unpractical. 

I do agree that it is not very reader-friendly as it is. This could easily be fixed with more comments/documentation.


---

Comment by vdelecroix created at 2019-04-12 08:38:08

Replying to [comment:16 VivianePons]:
> The new version is good as it forces new contributions to follow the same name pattern and only requires to add the new class without changing the source code of the main function. 
> 
> So I don't think "terrible" is an appropriate adjective! (Unless you have an other way to catch the existing classes?) A list of ifs might just get very long and unpractical. 

The list has length one and after #22173 it will have length two. I don't understand this objection.

> I do agree that it is not very reader-friendly as it is. This could easily be fixed with more comments/documentation.

"Terrible design" is appropriate.

1. As I said it is unreadable.

2. The code is sensitive to code injection

```
sage: import sage.schemes.hyperelliptic_curves.constructor as constructor
sage: constructor.HyperellipticCurve_g3 = int
```

You might consider this as a super feature, but it is very much error prone.

3. The way it is written goes through several dictionary accesses and a try/except each time a hyperelliptic curve is created. This is a waste of time as you want constructors to be as light as possible.


---

Comment by VivianePons created at 2019-04-12 08:51:51

I understand the objection about security and efficiency. The argument that the list will be of length 2 is not very convincing though: the very purpose of this ticket is to write an architecture which allows for easy extensions. 

I would suggest we go back to the initial solution that was proposed: use a dictionary associating the class name to the actual class. I find it much more readable than the list of ifs and easier to extend.


---

Comment by git created at 2019-04-16 13:34:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by annasomoza created at 2019-04-16 13:38:04

Following Viviane's comment, I went back to using a dictionary.

I am not sure of the meaning of the error that the bot gives, I think it comes from the fact that some files where removed and is otherwise green.


---

Comment by vdelecroix created at 2019-04-16 13:43:59

You might want to test that inheritance is actually correct in the doctests

```
sage: R.<t> = PolynomialRing(GF(next_prime(10^9)))
sage: C = HyperellipticCurve(t^5 + t + 1)
sage: import inspect
sage: inspect.getmro(type(C))
(<class 'sage.schemes.hyperelliptic_curves.constructor.HyperellipticCurve_g2_FiniteField_with_category'>,
 <class 'sage.schemes.hyperelliptic_curves.constructor.HyperellipticCurve_g2_FiniteField'>,
 <class 'sage.schemes.hyperelliptic_curves.hyperelliptic_g2.HyperellipticCurve_g2'>,
 <class 'sage.schemes.hyperelliptic_curves.hyperelliptic_finite_field.HyperellipticCurve_finite_field'>,
 <class 'sage.schemes.hyperelliptic_curves.hyperelliptic_generic.HyperellipticCurve_generic'>,
 ...)
```



---

Comment by annasomoza created at 2019-04-16 14:15:17

Is it better to add a test for every case or with the one you gave it's enough?

Also, while looking into this I realized that I am duplicating the classes with only one superclass.

```
sage: R.<t> = PolynomialRing(GF(next_prime(10^9)))
sage: C = HyperellipticCurve(t^7 + t + 1)
sage: import inspect
sage: inspect.getmro(type(C))
(<class 'sage.schemes.hyperelliptic_curves.constructor.HyperellipticCurve_FiniteField_with_category'>,
 <class 'sage.schemes.hyperelliptic_curves.constructor.HyperellipticCurve_FiniteField'>,
 <class 'sage.schemes.hyperelliptic_curves.hyperelliptic_finite_field.HyperellipticCurve_finite_field'>,
 <class 'sage.schemes.hyperelliptic_curves.hyperelliptic_generic.HyperellipticCurve_generic'>,
...)
```


Would it be preferable to initiate the `created_classes` dictionary with the classes `HyperellipticCurve_g2`, `HyperellipticCurve_FiniteField`, etc to avoid that? That could also simplify the last part of the code if `HyperellipticCurve_generic` was added too.


---

Comment by git created at 2019-04-18 11:40:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-04-18 11:57:07

Even nicer.

One last little thing. In the documentation, you need a linebreak after `::`.


---

Comment by git created at 2019-04-18 12:03:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-04-18 12:11:51

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2019-04-18 12:11:51

Perfect! Thanks for your patience.


---

Comment by vbraun created at 2019-04-27 17:44:14

Resolution: fixed
