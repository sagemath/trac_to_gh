# Issue 31154: crystals.HighestWeight constructs wrong crystal for given weight

archive/issues_031154.json:
```json
{
    "body": "CC:  sage-combinat @dwbump @anneschilling @tscrim @nthiery\n\nAs illustrated by the following code, constructing a crystal of tableaux given a fundamental weight using `crystals.HighestWeight` does not always work.  Specifically, it fails for the spin representations, and for Cartan types `F_4`, `E_6`, `E_7` and `E_8`.\n\n```\nfrom sage.databases.findstat import _finite_irreducible_cartan_types_by_rank as cartan_types\nsage: for n in range(1,9):\n....:    for ct in cartan_types(n):\n....:        L = ct.root_system().weight_lattice()\n....:        La = L.fundamental_weights()\n....:        for wt in La:\n....:            for model in ['Tableaux', 'NakajimaMonomials', 'AlcovePaths', 'RiggedConfigurations']:\n....:                try:\n....:                    C = crystals.HighestWeight(wt, model=model)\n....:                    if not L.weyl_dimension(wt) == C.cardinality():\n....:                        print(ct, wt, model, \"bad cardinality\")\n....:                except Exception as e:\n....:                    print(ct, wt, model, e)\n\n['B', 2] Lambda[2] Tableaux bad cardinality\n['B', 3] Lambda[3] Tableaux bad cardinality\n['B', 4] Lambda[4] Tableaux bad cardinality\n['D', 4] Lambda[3] Tableaux bad cardinality\n['D', 4] Lambda[4] Tableaux bad cardinality\n['F', 4] Lambda[1] Tableaux not an element in the crystal\n['F', 4] Lambda[2] Tableaux not an element in the crystal\n['F', 4] Lambda[3] Tableaux not an element in the crystal\n['F', 4] Lambda[4] Tableaux not an element in the crystal\n['B', 5] Lambda[5] Tableaux bad cardinality\n['D', 5] Lambda[4] Tableaux bad cardinality\n['D', 5] Lambda[5] Tableaux bad cardinality\n['B', 6] Lambda[6] Tableaux bad cardinality\n['D', 6] Lambda[5] Tableaux bad cardinality\n['D', 6] Lambda[6] Tableaux bad cardinality\n['E', 6] Lambda[1] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 6] Lambda[2] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 6] Lambda[3] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 6] Lambda[4] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 6] Lambda[5] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 6] Lambda[6] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['B', 7] Lambda[7] Tableaux bad cardinality\n['D', 7] Lambda[6] Tableaux bad cardinality\n['D', 7] Lambda[7] Tableaux bad cardinality\n['E', 7] Lambda[1] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 7] Lambda[2] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 7] Lambda[3] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 7] Lambda[4] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 7] Lambda[5] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 7] Lambda[6] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['E', 7] Lambda[7] Tableaux Argument 'value' has incorrect type (expected tuple, got int)\n['B', 8] Lambda[8] Tableaux bad cardinality\n['D', 8] Lambda[7] Tableaux bad cardinality\n['D', 8] Lambda[8] Tableaux bad cardinality\n['E', 8] Lambda[1] Tableaux not an element in the crystal\n['E', 8] Lambda[2] Tableaux not an element in the crystal\n['E', 8] Lambda[3] Tableaux not an element in the crystal\n['E', 8] Lambda[4] Tableaux not an element in the crystal\n['E', 8] Lambda[5] Tableaux not an element in the crystal\n['E', 8] Lambda[6] Tableaux not an element in the crystal\n['E', 8] Lambda[7] Tableaux not an element in the crystal\n['E', 8] Lambda[8] Tableaux not an element in the crystal\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/31391\n\n",
    "created_at": "2021-02-13T14:52:34Z",
    "labels": [
        "component: combinatorics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.3",
    "title": "crystals.HighestWeight constructs wrong crystal for given weight",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31154",
    "user": "https://github.com/mantepse"
}
```
CC:  sage-combinat @dwbump @anneschilling @tscrim @nthiery

As illustrated by the following code, constructing a crystal of tableaux given a fundamental weight using `crystals.HighestWeight` does not always work.  Specifically, it fails for the spin representations, and for Cartan types `F_4`, `E_6`, `E_7` and `E_8`.

```
from sage.databases.findstat import _finite_irreducible_cartan_types_by_rank as cartan_types
sage: for n in range(1,9):
....:    for ct in cartan_types(n):
....:        L = ct.root_system().weight_lattice()
....:        La = L.fundamental_weights()
....:        for wt in La:
....:            for model in ['Tableaux', 'NakajimaMonomials', 'AlcovePaths', 'RiggedConfigurations']:
....:                try:
....:                    C = crystals.HighestWeight(wt, model=model)
....:                    if not L.weyl_dimension(wt) == C.cardinality():
....:                        print(ct, wt, model, "bad cardinality")
....:                except Exception as e:
....:                    print(ct, wt, model, e)

['B', 2] Lambda[2] Tableaux bad cardinality
['B', 3] Lambda[3] Tableaux bad cardinality
['B', 4] Lambda[4] Tableaux bad cardinality
['D', 4] Lambda[3] Tableaux bad cardinality
['D', 4] Lambda[4] Tableaux bad cardinality
['F', 4] Lambda[1] Tableaux not an element in the crystal
['F', 4] Lambda[2] Tableaux not an element in the crystal
['F', 4] Lambda[3] Tableaux not an element in the crystal
['F', 4] Lambda[4] Tableaux not an element in the crystal
['B', 5] Lambda[5] Tableaux bad cardinality
['D', 5] Lambda[4] Tableaux bad cardinality
['D', 5] Lambda[5] Tableaux bad cardinality
['B', 6] Lambda[6] Tableaux bad cardinality
['D', 6] Lambda[5] Tableaux bad cardinality
['D', 6] Lambda[6] Tableaux bad cardinality
['E', 6] Lambda[1] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[2] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[3] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[4] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[5] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[6] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['B', 7] Lambda[7] Tableaux bad cardinality
['D', 7] Lambda[6] Tableaux bad cardinality
['D', 7] Lambda[7] Tableaux bad cardinality
['E', 7] Lambda[1] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[2] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[3] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[4] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[5] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[6] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[7] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['B', 8] Lambda[8] Tableaux bad cardinality
['D', 8] Lambda[7] Tableaux bad cardinality
['D', 8] Lambda[8] Tableaux bad cardinality
['E', 8] Lambda[1] Tableaux not an element in the crystal
['E', 8] Lambda[2] Tableaux not an element in the crystal
['E', 8] Lambda[3] Tableaux not an element in the crystal
['E', 8] Lambda[4] Tableaux not an element in the crystal
['E', 8] Lambda[5] Tableaux not an element in the crystal
['E', 8] Lambda[6] Tableaux not an element in the crystal
['E', 8] Lambda[7] Tableaux not an element in the crystal
['E', 8] Lambda[8] Tableaux not an element in the crystal
```

Issue created by migration from https://trac.sagemath.org/ticket/31391





---

archive/issue_comments_444654.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-02-13T18:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444654",
    "user": "https://github.com/mantepse"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_444655.json:
```json
{
    "body": "This is only a tentative fix.  The special case `G2` looks silly to me.  Also, I think we should raise an error for type `E` and `F` and `model=\"Tableaux\"`, or do something better.\n\n---\nNew commits:",
    "created_at": "2021-02-13T18:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444655",
    "user": "https://github.com/mantepse"
}
```

This is only a tentative fix.  The special case `G2` looks silly to me.  Also, I think we should raise an error for type `E` and `F` and `model="Tableaux"`, or do something better.

---
New commits:



---

archive/issue_comments_444656.json:
```json
{
    "body": "This looks good to me as a fix. Do you mean the construction of the G2 tableaux crystal looks silly?",
    "created_at": "2021-02-13T23:51:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444656",
    "user": "https://github.com/anneschilling"
}
```

This looks good to me as a fix. Do you mean the construction of the G2 tableaux crystal looks silly?



---

archive/issue_comments_444657.json:
```json
{
    "body": "Hi Anne!\n\nWhat I mean is that the special casing of `G2` looks silly.  \n\n```\n+         if cartan_type.type() == \"G\":\n+            sh = sum([[i]*c for i, c in dominant_weight], [])\n+            sh = Partition(reversed(sh)).conjugate()\n+            return CrystalOfTableaux(cartan_type, shape=sh)\n+\n```\nI.e., in all cases but `G2` we use the ambient space to contruct the shape.\n\nPut differently, would you say that the following code is better, worse, or about equally good?\n\n```\n    if model == 'Tableaux':\n        if cartan_type.type() in [\"A\", \"C\", \"G\"]:\n            sh = sum([[i]*c for i,c in dominant_weight], [])\n            sh = Partition(reversed(sh)).conjugate()\n        elif cartan_type.type() in [\"B\", \"D\"]:\n            sh = dominant_weight.to_ambient().to_vector()\n            from sage.rings.integer_ring import ZZ\n            if sh[-1] in ZZ:\n                sh = Partition(sh)\n        else:\n            raise ValueError(\"invalid model\")\n        return CrystalOfTableaux(cartan_type, shape=sh)\n```",
    "created_at": "2021-02-14T21:18:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444657",
    "user": "https://github.com/mantepse"
}
```

Hi Anne!

What I mean is that the special casing of `G2` looks silly.  

```
+         if cartan_type.type() == "G":
+            sh = sum([[i]*c for i, c in dominant_weight], [])
+            sh = Partition(reversed(sh)).conjugate()
+            return CrystalOfTableaux(cartan_type, shape=sh)
+
```
I.e., in all cases but `G2` we use the ambient space to contruct the shape.

Put differently, would you say that the following code is better, worse, or about equally good?

```
    if model == 'Tableaux':
        if cartan_type.type() in ["A", "C", "G"]:
            sh = sum([[i]*c for i,c in dominant_weight], [])
            sh = Partition(reversed(sh)).conjugate()
        elif cartan_type.type() in ["B", "D"]:
            sh = dominant_weight.to_ambient().to_vector()
            from sage.rings.integer_ring import ZZ
            if sh[-1] in ZZ:
                sh = Partition(sh)
        else:
            raise ValueError("invalid model")
        return CrystalOfTableaux(cartan_type, shape=sh)
```



---

archive/issue_comments_444658.json:
```json
{
    "body": "I don't know anything about type `Q`, but the following also doesn't look quite right, does it?\n\n```\nsage: ct = CartanType(\"Q4\")\nsage: L = ct.root_system().weight_lattice()\nsage: La = L.fundamental_weights()\nsage: C = crystals.Tableaux(ct, shape=[3,1]); (C.highest_weight_vectors()[0].weight(), C.cardinality())\n((3, 1, 0, 0), 80)\nsage: C = crystals.HighestWeight(2*La[1]+La[2]); (C.highest_weight_vector().weight(), C.cardinality())\n((3, 1, 0, 0), 45)\n\nsage: L\nWeight lattice of the Root system of type ['A', 3]\n```",
    "created_at": "2021-02-14T21:30:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444658",
    "user": "https://github.com/mantepse"
}
```

I don't know anything about type `Q`, but the following also doesn't look quite right, does it?

```
sage: ct = CartanType("Q4")
sage: L = ct.root_system().weight_lattice()
sage: La = L.fundamental_weights()
sage: C = crystals.Tableaux(ct, shape=[3,1]); (C.highest_weight_vectors()[0].weight(), C.cardinality())
((3, 1, 0, 0), 80)
sage: C = crystals.HighestWeight(2*La[1]+La[2]); (C.highest_weight_vector().weight(), C.cardinality())
((3, 1, 0, 0), 45)

sage: L
Weight lattice of the Root system of type ['A', 3]
```



---

archive/issue_comments_444659.json:
```json
{
    "body": "One major issue for using the ambient space for G<sub>2</sub> is the realization of the fundamental weights are not naturally partitions like for the other types:\n\n```\nsage: RootSystem('G2').ambient_space().fundamental_weights()\nFinite family {1: (1, 0, -1), 2: (2, -1, -1)}\nsage: RootSystem('D4').ambient_space().fundamental_weights()\nFinite family {1: (1, 0, 0, 0), 2: (1, 1, 0, 0), 3: (1/2, 1/2, 1/2, -1/2), 4: (1/2, 1/2, 1/2, 1/2)}\n```\nHowever, I think your idea of converting to the ambient space is good. You also don't need to convert the list to a partition. Thus, the last `if` statement is unnecessary.\n\nThe type EF failures are expected as there is no (canonical) tableau realization and should be removed from the ticket description.\n\nAdditionally, I think the added doctest should be more tailored to the failure of the ticket, namely the spin representations in type BD.",
    "created_at": "2021-02-14T23:56:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444659",
    "user": "https://github.com/tscrim"
}
```

One major issue for using the ambient space for G<sub>2</sub> is the realization of the fundamental weights are not naturally partitions like for the other types:

```
sage: RootSystem('G2').ambient_space().fundamental_weights()
Finite family {1: (1, 0, -1), 2: (2, -1, -1)}
sage: RootSystem('D4').ambient_space().fundamental_weights()
Finite family {1: (1, 0, 0, 0), 2: (1, 1, 0, 0), 3: (1/2, 1/2, 1/2, -1/2), 4: (1/2, 1/2, 1/2, 1/2)}
```
However, I think your idea of converting to the ambient space is good. You also don't need to convert the list to a partition. Thus, the last `if` statement is unnecessary.

The type EF failures are expected as there is no (canonical) tableau realization and should be removed from the ticket description.

Additionally, I think the added doctest should be more tailored to the failure of the ticket, namely the spin representations in type BD.



---

archive/issue_comments_444660.json:
```json
{
    "body": "Hi Martin,\n\n> What I mean is that the special casing of `G2` looks silly.  \n> \n> ```\n> +         if cartan_type.type() == \"G\":\n> +            sh = sum([[i]*c for i, c in dominant_weight], [])\n> +            sh = Partition(reversed(sh)).conjugate()\n> +            return CrystalOfTableaux(cartan_type, shape=sh)\n> +\n> ```\n> I.e., in all cases but `G2` we use the ambient space to contruct the shape.\n> \n> Put differently, would you say that the following code is better, worse, or about equally good?\n> \n> ```\n>     if model == 'Tableaux':\n>         if cartan_type.type() in [\"A\", \"C\", \"G\"]:\n>             sh = sum([[i]*c for i,c in dominant_weight], [])\n>             sh = Partition(reversed(sh)).conjugate()\n>         elif cartan_type.type() in [\"B\", \"D\"]:\n>             sh = dominant_weight.to_ambient().to_vector()\n>             from sage.rings.integer_ring import ZZ\n>             if sh[-1] in ZZ:\n>                 sh = Partition(sh)\n>         else:\n>             raise ValueError(\"invalid model\")\n>         return CrystalOfTableaux(cartan_type, shape=sh)\n> ```\n\n\nI think either is fine as long as it is correct! I slightly like it better to use the conversion to the ambient lattice for most types.\n\nRegarding type Q, I do not think the tableaux model was ever implemented for this type, so I think it should not be used!\n\nBest,\n\nAnne",
    "created_at": "2021-02-15T02:14:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444660",
    "user": "https://github.com/anneschilling"
}
```

Hi Martin,

> What I mean is that the special casing of `G2` looks silly.  
> 
> ```
> +         if cartan_type.type() == "G":
> +            sh = sum([[i]*c for i, c in dominant_weight], [])
> +            sh = Partition(reversed(sh)).conjugate()
> +            return CrystalOfTableaux(cartan_type, shape=sh)
> +
> ```
> I.e., in all cases but `G2` we use the ambient space to contruct the shape.
> 
> Put differently, would you say that the following code is better, worse, or about equally good?
> 
> ```
>     if model == 'Tableaux':
>         if cartan_type.type() in ["A", "C", "G"]:
>             sh = sum([[i]*c for i,c in dominant_weight], [])
>             sh = Partition(reversed(sh)).conjugate()
>         elif cartan_type.type() in ["B", "D"]:
>             sh = dominant_weight.to_ambient().to_vector()
>             from sage.rings.integer_ring import ZZ
>             if sh[-1] in ZZ:
>                 sh = Partition(sh)
>         else:
>             raise ValueError("invalid model")
>         return CrystalOfTableaux(cartan_type, shape=sh)
> ```


I think either is fine as long as it is correct! I slightly like it better to use the conversion to the ambient lattice for most types.

Regarding type Q, I do not think the tableaux model was ever implemented for this type, so I think it should not be used!

Best,

Anne



---

archive/issue_comments_444661.json:
```json
{
    "body": "Replying to [comment:9 aschilling]:\n> Regarding type Q, I do not think the tableaux model was ever implemented for this type, so I think it should not be used!\n\n\nI have implemented it:\n\n```\nsage: C = crystals.Tableaux(['Q',3], shape=[3,1])                                                                 \nsage: C.cardinality()                                                                                             \n24\n```\n\nThe difference you are getting Martin is the fact the root system for the **q**<sub>n</sub> Lie superalgebra is the same as for **gl**<sub>n</sub>. So the weights do not know to distinguish themselves from the two Lie algebras. I don't think there is a reason for them to because root systems are not Lie algebras. We might want to revisit this decision though as `crystals.HighestWeight` will not be able to distinguish between the two types because of this.",
    "created_at": "2021-02-15T03:06:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444661",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:9 aschilling]:
> Regarding type Q, I do not think the tableaux model was ever implemented for this type, so I think it should not be used!


I have implemented it:

```
sage: C = crystals.Tableaux(['Q',3], shape=[3,1])                                                                 
sage: C.cardinality()                                                                                             
24
```

The difference you are getting Martin is the fact the root system for the **q**<sub>n</sub> Lie superalgebra is the same as for **gl**<sub>n</sub>. So the weights do not know to distinguish themselves from the two Lie algebras. I don't think there is a reason for them to because root systems are not Lie algebras. We might want to revisit this decision though as `crystals.HighestWeight` will not be able to distinguish between the two types because of this.



---

archive/issue_comments_444662.json:
```json
{
    "body": "Dear Anne, Daniel and Travis (I guess that T is a good approximation to E)!\n\nMy thought about *not* using the ambient space was that the choice of positive roots is quite arbitrary, and it might be more correct to (at least try to) avoid dependence on a specific choice.  So here is another version of the same code:\n\n```\n        n = cartan_type.rank()\n        from sage.modules.free_module_element import vector\n        from sage.rings.integer_ring import ZZ\n        from sage.rings.rational_field import QQ\n        d = {i: vector(QQ, [1]*i + [0]*(n-i)) for i in range(1, n+1)}\n        if cartan_type.type() == \"B\":\n            d[n] = vector(QQ, [1/2 for i in range(n)])\n        elif cartan_type.type() == \"D\":\n            d[n-1] = vector(QQ, [1/2 for i in range(n-1)] + [-1/2])\n            d[n] = vector(QQ, [1/2 for i in range(n)])\n        sh = sum((c*d[i] for i, c in dominant_weight), vector(QQ, n))\n        if sh[-1] in ZZ:\n            sh = Partition(sh)\n        return CrystalOfTableaux(cartan_type, shape=sh)\n```\nThe call to `Partition` should not be avoided, or probably done in `crystals.Tableaux`, because\n\n```\nsage: C1 = crystals.Tableaux(\"A4\", shape=[2,1]); C1\nThe crystal of tableaux of type ['A', 4] and shape(s) [[2, 1]]\nsage: C2 = crystals.Tableaux(\"A4\", shape=[2,1,0,0]); C2\nThe crystal of tableaux of type ['A', 4] and shape(s) [[2, 1, 0, 0]]\nsage: C1 == C2\nFalse\n```\n\nAlternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:\n\n```\n        sh = dominant_weight.to_ambient().to_vector()\n        if cartan_type.type() == \"G\":\n            sh = (-sh)[2:0:-1]\n        from sage.rings.integer_ring import ZZ\n        if cartan_type.type() in [\"B\", \"D\"] and sh[-1] not in ZZ:\n            return CrystalOfTableaux(cartan_type, shape=sh)\n\n        return CrystalOfTableaux(cartan_type, shape=Partition(sh))\n```\nNote that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.\n\nI assume that it's out of the question to change the choice of positive roots for `G_2`, right?\n\nConcerning the test, I must say that I like to have one (more or less) systematic test.  It would have saved me a day if something like it would have been available.",
    "created_at": "2021-02-15T09:22:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444662",
    "user": "https://github.com/mantepse"
}
```

Dear Anne, Daniel and Travis (I guess that T is a good approximation to E)!

My thought about *not* using the ambient space was that the choice of positive roots is quite arbitrary, and it might be more correct to (at least try to) avoid dependence on a specific choice.  So here is another version of the same code:

```
        n = cartan_type.rank()
        from sage.modules.free_module_element import vector
        from sage.rings.integer_ring import ZZ
        from sage.rings.rational_field import QQ
        d = {i: vector(QQ, [1]*i + [0]*(n-i)) for i in range(1, n+1)}
        if cartan_type.type() == "B":
            d[n] = vector(QQ, [1/2 for i in range(n)])
        elif cartan_type.type() == "D":
            d[n-1] = vector(QQ, [1/2 for i in range(n-1)] + [-1/2])
            d[n] = vector(QQ, [1/2 for i in range(n)])
        sh = sum((c*d[i] for i, c in dominant_weight), vector(QQ, n))
        if sh[-1] in ZZ:
            sh = Partition(sh)
        return CrystalOfTableaux(cartan_type, shape=sh)
```
The call to `Partition` should not be avoided, or probably done in `crystals.Tableaux`, because

```
sage: C1 = crystals.Tableaux("A4", shape=[2,1]); C1
The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1]]
sage: C2 = crystals.Tableaux("A4", shape=[2,1,0,0]); C2
The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1, 0, 0]]
sage: C1 == C2
False
```

Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:

```
        sh = dominant_weight.to_ambient().to_vector()
        if cartan_type.type() == "G":
            sh = (-sh)[2:0:-1]
        from sage.rings.integer_ring import ZZ
        if cartan_type.type() in ["B", "D"] and sh[-1] not in ZZ:
            return CrystalOfTableaux(cartan_type, shape=sh)

        return CrystalOfTableaux(cartan_type, shape=Partition(sh))
```
Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.

I assume that it's out of the question to change the choice of positive roots for `G_2`, right?

Concerning the test, I must say that I like to have one (more or less) systematic test.  It would have saved me a day if something like it would have been available.



---

archive/issue_comments_444663.json:
```json
{
    "body": "Dear Martin,\n\nI would vote for this option:\n\n\n> Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:\n> \n> ```\n>         sh = dominant_weight.to_ambient().to_vector()\n>         if cartan_type.type() == \"G\":\n>             sh = (-sh)[2:0:-1]\n>         from sage.rings.integer_ring import ZZ\n>         if cartan_type.type() in [\"B\", \"D\"] and sh[-1] not in ZZ:\n>             return CrystalOfTableaux(cartan_type, shape=sh)\n> \n>         return CrystalOfTableaux(cartan_type, shape=Partition(sh))\n> ```\n> Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.\n> \n> I assume that it's out of the question to change the choice of positive roots for `G_2`, right?\n\n\nWell, I would not do it for this ticket, but Dan or Travis might have other opinions.\n\nAnne",
    "created_at": "2021-02-15T23:37:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444663",
    "user": "https://github.com/anneschilling"
}
```

Dear Martin,

I would vote for this option:


> Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:
> 
> ```
>         sh = dominant_weight.to_ambient().to_vector()
>         if cartan_type.type() == "G":
>             sh = (-sh)[2:0:-1]
>         from sage.rings.integer_ring import ZZ
>         if cartan_type.type() in ["B", "D"] and sh[-1] not in ZZ:
>             return CrystalOfTableaux(cartan_type, shape=sh)
> 
>         return CrystalOfTableaux(cartan_type, shape=Partition(sh))
> ```
> Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.
> 
> I assume that it's out of the question to change the choice of positive roots for `G_2`, right?


Well, I would not do it for this ticket, but Dan or Travis might have other opinions.

Anne



---

archive/issue_comments_444664.json:
```json
{
    "body": "Replying to [comment:11 mantepse]:\n> My thought about *not* using the ambient space was that the choice of positive roots is quite arbitrary, and it might be more correct to (at least try to) avoid dependence on a specific choice.\n\n\nI don't think it was that arbitrary. Nicolas, were you the one who did the root system implementation? Do you have any comments on this?\n\n> The call to `Partition` should not be avoided, or probably done in `crystals.Tableaux`, because\n> \n> ```\n> sage: C1 = crystals.Tableaux(\"A4\", shape=[2,1]); C1\n> The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1]]\n> sage: C2 = crystals.Tableaux(\"A4\", shape=[2,1,0,0]); C2\n> The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1, 0, 0]]\n> sage: C1 == C2\n> False\n> ```\n\n\nYes, it should be avoided *here* in the highest weight crystals code. That is an issue with the `CrystalOfTableaux` code not sufficiently standardizing itself. There is also a strong argument for padding the list to have length `n`.\n\n> Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:\n> \n> ```\n>         sh = dominant_weight.to_ambient().to_vector()\n>         if cartan_type.type() == \"G\":\n>             sh = (-sh)[2:0:-1]\n>         from sage.rings.integer_ring import ZZ\n>         if cartan_type.type() in [\"B\", \"D\"] and sh[-1] not in ZZ:\n>             return CrystalOfTableaux(cartan_type, shape=sh)\n> \n>         return CrystalOfTableaux(cartan_type, shape=Partition(sh))\n> ```\n> Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.\n\n\nI also like this option except for the call to `Partition`.\n\n> I assume that it's out of the question to change the choice of positive roots for `G_2`, right?\n\n\nI agree with Anne that definitely not on this ticket.\n\n> Concerning the test, I must say that I like to have one (more or less) systematic test.  It would have saved me a day if something like it would have been available.\n\n\nIf you want a systematic test, I would explicitly write something in. My second option would be to use `CartanType.samples(finite=True)`. I don't like depending on something that is essentially downstream.",
    "created_at": "2021-02-16T03:59:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444664",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:11 mantepse]:
> My thought about *not* using the ambient space was that the choice of positive roots is quite arbitrary, and it might be more correct to (at least try to) avoid dependence on a specific choice.


I don't think it was that arbitrary. Nicolas, were you the one who did the root system implementation? Do you have any comments on this?

> The call to `Partition` should not be avoided, or probably done in `crystals.Tableaux`, because
> 
> ```
> sage: C1 = crystals.Tableaux("A4", shape=[2,1]); C1
> The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1]]
> sage: C2 = crystals.Tableaux("A4", shape=[2,1,0,0]); C2
> The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1, 0, 0]]
> sage: C1 == C2
> False
> ```


Yes, it should be avoided *here* in the highest weight crystals code. That is an issue with the `CrystalOfTableaux` code not sufficiently standardizing itself. There is also a strong argument for padding the list to have length `n`.

> Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:
> 
> ```
>         sh = dominant_weight.to_ambient().to_vector()
>         if cartan_type.type() == "G":
>             sh = (-sh)[2:0:-1]
>         from sage.rings.integer_ring import ZZ
>         if cartan_type.type() in ["B", "D"] and sh[-1] not in ZZ:
>             return CrystalOfTableaux(cartan_type, shape=sh)
> 
>         return CrystalOfTableaux(cartan_type, shape=Partition(sh))
> ```
> Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.


I also like this option except for the call to `Partition`.

> I assume that it's out of the question to change the choice of positive roots for `G_2`, right?


I agree with Anne that definitely not on this ticket.

> Concerning the test, I must say that I like to have one (more or less) systematic test.  It would have saved me a day if something like it would have been available.


If you want a systematic test, I would explicitly write something in. My second option would be to use `CartanType.samples(finite=True)`. I don't like depending on something that is essentially downstream.



---

archive/issue_comments_444665.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-17T22:07:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444665",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444666.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-17T22:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444666",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444667.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-17T22:14:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444667",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444668.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-17T22:17:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444668",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444669.json:
```json
{
    "body": "I tried to follow your recommendations.  Is it correct that type A is the only exception to the rule that the \"shape\" should have length at most n?  (I think that, in type A, removing the redundant columns is not a good idea.)\n\n(I don't know anything about the affine case, so please pay attention to it)",
    "created_at": "2021-02-17T22:27:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444669",
    "user": "https://github.com/mantepse"
}
```

I tried to follow your recommendations.  Is it correct that type A is the only exception to the rule that the "shape" should have length at most n?  (I think that, in type A, removing the redundant columns is not a good idea.)

(I don't know anything about the affine case, so please pay attention to it)



---

archive/issue_comments_444670.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-17T22:27:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444670",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444671.json:
```json
{
    "body": "Now that I am looking at the code and the changes, it seems more like we should standardize the shape to actually be a partition and strip the trailing zeros there. Plus, they are accessible via the `shapes` attribute. Sorry for the back-and-forth on this; the code has spoken.\n\nIn answer to [This is the Trac macro *comment:18* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:18-macro), type A is the only exception to the rule, and I agree we should not remove height n columns to make it a **gl**<sub>n</sub> object, which it more naturally is IMO.\n\nSince we are also fixing the input for `CrystalsOfTableaux` here, there is also this one:\n\n```\nsage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])\nThe crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]\n```\nI think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed.",
    "created_at": "2021-02-17T23:17:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444671",
    "user": "https://github.com/tscrim"
}
```

Now that I am looking at the code and the changes, it seems more like we should standardize the shape to actually be a partition and strip the trailing zeros there. Plus, they are accessible via the `shapes` attribute. Sorry for the back-and-forth on this; the code has spoken.

In answer to [This is the Trac macro *comment:18* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:18-macro), type A is the only exception to the rule, and I agree we should not remove height n columns to make it a **gl**<sub>n</sub> object, which it more naturally is IMO.

Since we are also fixing the input for `CrystalsOfTableaux` here, there is also this one:

```
sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])
The crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]
```
I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed.



---

archive/issue_comments_444672.json:
```json
{
    "body": "I agree with Travis' comments. Other than that the code looks good to me!",
    "created_at": "2021-02-18T05:49:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444672",
    "user": "https://github.com/anneschilling"
}
```

I agree with Travis' comments. Other than that the code looks good to me!



---

archive/issue_comments_444673.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-18T07:28:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444673",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444674.json:
```json
{
    "body": "I changed the code to convert to partitions whenever possible.\n\nCould you please be more explicit with your comment about\n\n```\nsage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])\nThe crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]\n```\nIt is unclear to me what input is OK and what should be rejected.",
    "created_at": "2021-02-18T07:33:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444674",
    "user": "https://github.com/mantepse"
}
```

I changed the code to convert to partitions whenever possible.

Could you please be more explicit with your comment about

```
sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])
The crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]
```
It is unclear to me what input is OK and what should be rejected.



---

archive/issue_comments_444675.json:
```json
{
    "body": "I just realized that I am still confused:\n\n```\nsage: ct = CartanType([\"A\", 3])\nsage: La = RootSystem(ct).weight_lattice().fundamental_weights()\nsage: La[1].to_ambient()\n(1, 0, 0, 0)\nsage: R = RootSystem(ct).root_space()\nsage: La = RootSystem(ct).root_space().fundamental_weights_from_simple_roots()\nsage: La[1].to_ambient()\n(3/4, -1/4, -1/4, -1/4)\n```",
    "created_at": "2021-02-18T11:59:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444675",
    "user": "https://github.com/mantepse"
}
```

I just realized that I am still confused:

```
sage: ct = CartanType(["A", 3])
sage: La = RootSystem(ct).weight_lattice().fundamental_weights()
sage: La[1].to_ambient()
(1, 0, 0, 0)
sage: R = RootSystem(ct).root_space()
sage: La = RootSystem(ct).root_space().fundamental_weights_from_simple_roots()
sage: La[1].to_ambient()
(3/4, -1/4, -1/4, -1/4)
```



---

archive/issue_comments_444676.json:
```json
{
    "body": "Replying to [comment:23 mantepse]:\n> I changed the code to convert to partitions whenever possible.\n> \n> Could you please be more explicit with your comment about\n> \n> ```\n> sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])\n> The crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]\n> ```\n> It is unclear to me what input is OK and what should be rejected.\n\n\nIt says in the documentation:\n\n   If the type is D_r, the shape is permitted to have a negative value\n   in the r-th position. Thus if the shape equals [s_1,...,s_r],\n   then s_r may be negative but in any case s_1 >= ... >=\n   s_{r-1} >= |s_r|. This crystal is related to that of shape\n   [s_1,...,|s_r|] by the outer automorphism of SO(2r).\n\nSo negative entries should not be allowed except in the r-th entry.",
    "created_at": "2021-02-18T17:10:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444676",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:23 mantepse]:
> I changed the code to convert to partitions whenever possible.
> 
> Could you please be more explicit with your comment about
> 
> ```
> sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])
> The crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]
> ```
> It is unclear to me what input is OK and what should be rejected.


It says in the documentation:

   If the type is D_r, the shape is permitted to have a negative value
   in the r-th position. Thus if the shape equals [s_1,...,s_r],
   then s_r may be negative but in any case s_1 >= ... >=
   s_{r-1} >= |s_r|. This crystal is related to that of shape
   [s_1,...,|s_r|] by the outer automorphism of SO(2r).

So negative entries should not be allowed except in the r-th entry.



---

archive/issue_comments_444677.json:
```json
{
    "body": "So, Travis, with\n\n> I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. \n\n\nyou are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?",
    "created_at": "2021-02-18T18:39:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444677",
    "user": "https://github.com/mantepse"
}
```

So, Travis, with

> I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. 


you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?



---

archive/issue_comments_444678.json:
```json
{
    "body": "Replying to [comment:27 mantepse]:\n> So, Travis, with\n> \n> > I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. \n\n> \n> you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?\n\n\nYes, `[1/2, ..., 1/2, -1/2]` is allowed.",
    "created_at": "2021-02-18T21:29:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444678",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:27 mantepse]:
> So, Travis, with
> 
> > I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. 

> 
> you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?


Yes, `[1/2, ..., 1/2, -1/2]` is allowed.



---

archive/issue_comments_444679.json:
```json
{
    "body": "Replying to [comment:28 aschilling]:\n> Replying to [comment:27 mantepse]:\n> > So, Travis, with\n> > \n> > > I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. \n\n> > \n> > you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?\n\n> \n> Yes, `[1/2, ..., 1/2, -1/2]` is allowed.\n\n\nWhat I mean is you cannot mix `[1/2, ..., 1/2, -1/2]` with `[1/2, ..., 1/2, 1/2]`:\n\n```\nsage: crystals.Tableaux(['D',4], [[1/2,1/2,1/2,-1/2],[1/2,1/2,1/2,1/2]])\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n...\nValueError: in type D spins should all be positive or negative\n```",
    "created_at": "2021-02-19T23:40:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444679",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:28 aschilling]:
> Replying to [comment:27 mantepse]:
> > So, Travis, with
> > 
> > > I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. 

> > 
> > you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?

> 
> Yes, `[1/2, ..., 1/2, -1/2]` is allowed.


What I mean is you cannot mix `[1/2, ..., 1/2, -1/2]` with `[1/2, ..., 1/2, 1/2]`:

```
sage: crystals.Tableaux(['D',4], [[1/2,1/2,1/2,-1/2],[1/2,1/2,1/2,1/2]])
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
...
ValueError: in type D spins should all be positive or negative
```



---

archive/issue_comments_444680.json:
```json
{
    "body": "Replying to [comment:24 mantepse]:\n> I just realized that I am still confused:\n> \n> ```\n> sage: ct = CartanType([\"A\", 3])\n> sage: La = RootSystem(ct).weight_lattice().fundamental_weights()\n> sage: La[1].to_ambient()\n> (1, 0, 0, 0)\n> sage: R = RootSystem(ct).root_space()\n> sage: La = RootSystem(ct).root_space().fundamental_weights_from_simple_roots()\n> sage: La[1].to_ambient()\n> (3/4, -1/4, -1/4, -1/4)\n> ```\n\nEverything in the type A root system can be considered up to scalar multiples of the `(1, 1, ..., 1)` vector. So these two can be considered to be the same element because it really lives in a quotient space.",
    "created_at": "2021-02-19T23:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444680",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:24 mantepse]:
> I just realized that I am still confused:
> 
> ```
> sage: ct = CartanType(["A", 3])
> sage: La = RootSystem(ct).weight_lattice().fundamental_weights()
> sage: La[1].to_ambient()
> (1, 0, 0, 0)
> sage: R = RootSystem(ct).root_space()
> sage: La = RootSystem(ct).root_space().fundamental_weights_from_simple_roots()
> sage: La[1].to_ambient()
> (3/4, -1/4, -1/4, -1/4)
> ```

Everything in the type A root system can be considered up to scalar multiples of the `(1, 1, ..., 1)` vector. So these two can be considered to be the same element because it really lives in a quotient space.



---

archive/issue_comments_444681.json:
```json
{
    "body": "Thank you for both explanations! I think the special SLn / GLn feature should not be ignored in `crystals.HighestWeight`, so I'll make another special case.",
    "created_at": "2021-02-20T07:47:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444681",
    "user": "https://github.com/mantepse"
}
```

Thank you for both explanations! I think the special SLn / GLn feature should not be ignored in `crystals.HighestWeight`, so I'll make another special case.



---

archive/issue_comments_444682.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-20T20:55:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444682",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_444683.json:
```json
{
    "body": "I could not see how to change the code to accomodate Travis' comment\n\n> the fact we force the spins to all be plus or minus is artificial and can be removed\n\n\nbut apart from this, I think it should be (slightly) better now.",
    "created_at": "2021-02-20T20:57:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444683",
    "user": "https://github.com/mantepse"
}
```

I could not see how to change the code to accomodate Travis' comment

> the fact we force the spins to all be plus or minus is artificial and can be removed


but apart from this, I think it should be (slightly) better now.



---

archive/issue_comments_444684.json:
```json
{
    "body": "Replying to [comment:33 mantepse]:\n> I could not see how to change the code to accomodate Travis' comment\n> \n> > the fact we force the spins to all be plus or minus is artificial and can be removed\n\n> \n> but apart from this, I think it should be (slightly) better now.\n\n\nI see. That is a bit tricky to remove that. So let's just leave that in.",
    "created_at": "2021-02-22T01:02:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444684",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:33 mantepse]:
> I could not see how to change the code to accomodate Travis' comment
> 
> > the fact we force the spins to all be plus or minus is artificial and can be removed

> 
> but apart from this, I think it should be (slightly) better now.


I see. That is a bit tricky to remove that. So let's just leave that in.



---

archive/issue_comments_444685.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-02-22T01:02:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444685",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_444686.json:
```json
{
    "body": "Thank you for looking at the code!\n\nOne more question: I currently do\n\n```\ndominant_weight = dominant_weight.to_ambient().to_weight_space(ZZ)\n```\ndo obtain a weight in the weight lattice.\n\nMaybe it would make sense to add a method `to_weight_space` to `RootSpace`, so we could just say\n\n```\ndominant_weight = dominant_weight.to_weight_space()\n```\n(`WeightSpaceElement` has a method `to_weight_space` which just returns `self`, whereas `dominant_weight.to_ambient().to_weight_space(ZZ)` has to do some real work)",
    "created_at": "2021-02-22T11:19:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444686",
    "user": "https://github.com/mantepse"
}
```

Thank you for looking at the code!

One more question: I currently do

```
dominant_weight = dominant_weight.to_ambient().to_weight_space(ZZ)
```
do obtain a weight in the weight lattice.

Maybe it would make sense to add a method `to_weight_space` to `RootSpace`, so we could just say

```
dominant_weight = dominant_weight.to_weight_space()
```
(`WeightSpaceElement` has a method `to_weight_space` which just returns `self`, whereas `dominant_weight.to_ambient().to_weight_space(ZZ)` has to do some real work)



---

archive/issue_comments_444687.json:
```json
{
    "body": "No, it does not because the Cartan matrix is not invertible in general. For example, in affine type since there is a nullspace that is spanned by the null root.",
    "created_at": "2021-02-22T23:14:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444687",
    "user": "https://github.com/tscrim"
}
```

No, it does not because the Cartan matrix is not invertible in general. For example, in affine type since there is a nullspace that is spanned by the null root.



---

archive/issue_comments_444688.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-03-09T00:01:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31154#issuecomment-444688",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_082234.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-03-09T00:01:24Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/31154",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31154#event-82234"
}
```
