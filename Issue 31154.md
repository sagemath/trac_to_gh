# Issue 31154: crystals.HighestWeight constructs wrong crystal for given weight

Issue created by migration from https://trac.sagemath.org/ticket/31391

Original creator: mantepse

Original creation time: 2021-02-13 14:52:34

CC:  sage-combinat bump aschilling tscrim nthiery

As illustrated by the following code, constructing a crystal of tableaux given a fundamental weight using `crystals.HighestWeight` does not always work.  Specifically, it fails for the spin representations, and for Cartan types `F_4`, `E_6`, `E_7` and `E_8`.

```
from sage.databases.findstat import _finite_irreducible_cartan_types_by_rank as cartan_types
sage: for n in range(1,9):
....:    for ct in cartan_types(n):
....:        L = ct.root_system().weight_lattice()
....:        La = L.fundamental_weights()
....:        for wt in La:
....:            for model in ['Tableaux', 'NakajimaMonomials', 'AlcovePaths', 'RiggedConfigurations']:
....:                try:
....:                    C = crystals.HighestWeight(wt, model=model)
....:                    if not L.weyl_dimension(wt) == C.cardinality():
....:                        print(ct, wt, model, "bad cardinality")
....:                except Exception as e:
....:                    print(ct, wt, model, e)

['B', 2] Lambda[2] Tableaux bad cardinality
['B', 3] Lambda[3] Tableaux bad cardinality
['B', 4] Lambda[4] Tableaux bad cardinality
['D', 4] Lambda[3] Tableaux bad cardinality
['D', 4] Lambda[4] Tableaux bad cardinality
['F', 4] Lambda[1] Tableaux not an element in the crystal
['F', 4] Lambda[2] Tableaux not an element in the crystal
['F', 4] Lambda[3] Tableaux not an element in the crystal
['F', 4] Lambda[4] Tableaux not an element in the crystal
['B', 5] Lambda[5] Tableaux bad cardinality
['D', 5] Lambda[4] Tableaux bad cardinality
['D', 5] Lambda[5] Tableaux bad cardinality
['B', 6] Lambda[6] Tableaux bad cardinality
['D', 6] Lambda[5] Tableaux bad cardinality
['D', 6] Lambda[6] Tableaux bad cardinality
['E', 6] Lambda[1] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[2] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[3] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[4] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[5] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 6] Lambda[6] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['B', 7] Lambda[7] Tableaux bad cardinality
['D', 7] Lambda[6] Tableaux bad cardinality
['D', 7] Lambda[7] Tableaux bad cardinality
['E', 7] Lambda[1] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[2] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[3] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[4] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[5] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[6] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['E', 7] Lambda[7] Tableaux Argument 'value' has incorrect type (expected tuple, got int)
['B', 8] Lambda[8] Tableaux bad cardinality
['D', 8] Lambda[7] Tableaux bad cardinality
['D', 8] Lambda[8] Tableaux bad cardinality
['E', 8] Lambda[1] Tableaux not an element in the crystal
['E', 8] Lambda[2] Tableaux not an element in the crystal
['E', 8] Lambda[3] Tableaux not an element in the crystal
['E', 8] Lambda[4] Tableaux not an element in the crystal
['E', 8] Lambda[5] Tableaux not an element in the crystal
['E', 8] Lambda[6] Tableaux not an element in the crystal
['E', 8] Lambda[7] Tableaux not an element in the crystal
['E', 8] Lambda[8] Tableaux not an element in the crystal
```



---

Comment by mantepse created at 2021-02-13 18:13:04

Changing status from new to needs_review.


---

Comment by mantepse created at 2021-02-13 18:13:04

This is only a tentative fix.  The special case `G2` looks silly to me.  Also, I think we should raise an error for type `E` and `F` and `model="Tableaux"`, or do something better.
----
New commits:


---

Comment by aschilling created at 2021-02-13 23:51:09

This looks good to me as a fix. Do you mean the construction of the G2 tableaux crystal looks silly?


---

Comment by mantepse created at 2021-02-14 21:18:28

Hi Anne!

What I mean is that the special casing of `G2` looks silly.  

```
+         if cartan_type.type() == "G":
+            sh = sum([[i]*c for i, c in dominant_weight], [])
+            sh = Partition(reversed(sh)).conjugate()
+            return CrystalOfTableaux(cartan_type, shape=sh)
+
```

I.e., in all cases but `G2` we use the ambient space to contruct the shape.

Put differently, would you say that the following code is better, worse, or about equally good?

```
    if model == 'Tableaux':
        if cartan_type.type() in ["A", "C", "G"]:
            sh = sum([[i]*c for i,c in dominant_weight], [])
            sh = Partition(reversed(sh)).conjugate()
        elif cartan_type.type() in ["B", "D"]:
            sh = dominant_weight.to_ambient().to_vector()
            from sage.rings.integer_ring import ZZ
            if sh[-1] in ZZ:
                sh = Partition(sh)
        else:
            raise ValueError("invalid model")
        return CrystalOfTableaux(cartan_type, shape=sh)
```



---

Comment by mantepse created at 2021-02-14 21:30:16

I don't know anything about type `Q`, but the following also doesn't look quite right, does it?

```
sage: ct = CartanType("Q4")
sage: L = ct.root_system().weight_lattice()
sage: La = L.fundamental_weights()
sage: C = crystals.Tableaux(ct, shape=[3,1]); (C.highest_weight_vectors()[0].weight(), C.cardinality())
((3, 1, 0, 0), 80)
sage: C = crystals.HighestWeight(2*La[1]+La[2]); (C.highest_weight_vector().weight(), C.cardinality())
((3, 1, 0, 0), 45)

sage: L
Weight lattice of the Root system of type ['A', 3]
```



---

Comment by tscrim created at 2021-02-14 23:56:26

One major issue for using the ambient space for G<sub>2</sub> is the realization of the fundamental weights are not naturally partitions like for the other types:

```
sage: RootSystem('G2').ambient_space().fundamental_weights()
Finite family {1: (1, 0, -1), 2: (2, -1, -1)}
sage: RootSystem('D4').ambient_space().fundamental_weights()
Finite family {1: (1, 0, 0, 0), 2: (1, 1, 0, 0), 3: (1/2, 1/2, 1/2, -1/2), 4: (1/2, 1/2, 1/2, 1/2)}
```

However, I think your idea of converting to the ambient space is good. You also don't need to convert the list to a partition. Thus, the last `if` statement is unnecessary.

The type EF failures are expected as there is no (canonical) tableau realization and should be removed from the ticket description.

Additionally, I think the added doctest should be more tailored to the failure of the ticket, namely the spin representations in type BD.


---

Comment by aschilling created at 2021-02-15 02:14:47

Hi Martin,

> What I mean is that the special casing of `G2` looks silly.  
> {{{
> +         if cartan_type.type() == "G":
> +            sh = sum([[i]*c for i, c in dominant_weight], [])
> +            sh = Partition(reversed(sh)).conjugate()
> +            return CrystalOfTableaux(cartan_type, shape=sh)
> +
> }}}
> I.e., in all cases but `G2` we use the ambient space to contruct the shape.
> 
> Put differently, would you say that the following code is better, worse, or about equally good?
> {{{
>     if model == 'Tableaux':
>         if cartan_type.type() in ["A", "C", "G"]:
>             sh = sum([[i]*c for i,c in dominant_weight], [])
>             sh = Partition(reversed(sh)).conjugate()
>         elif cartan_type.type() in ["B", "D"]:
>             sh = dominant_weight.to_ambient().to_vector()
>             from sage.rings.integer_ring import ZZ
>             if sh[-1] in ZZ:
>                 sh = Partition(sh)
>         else:
>             raise ValueError("invalid model")
>         return CrystalOfTableaux(cartan_type, shape=sh)
> }}}

I think either is fine as long as it is correct! I slightly like it better to use the conversion to the ambient lattice for most types.

Regarding type Q, I do not think the tableaux model was ever implemented for this type, so I think it should not be used!

Best,

Anne


---

Comment by tscrim created at 2021-02-15 03:06:46

Replying to [comment:9 aschilling]:
> Regarding type Q, I do not think the tableaux model was ever implemented for this type, so I think it should not be used!

I have implemented it:

```
sage: C = crystals.Tableaux(['Q',3], shape=[3,1])                                                                 
sage: C.cardinality()                                                                                             
24
```


The difference you are getting Martin is the fact the root system for the *q*<sub>n</sub> Lie superalgebra is the same as for *gl*<sub>n</sub>. So the weights do not know to distinguish themselves from the two Lie algebras. I don't think there is a reason for them to because root systems are not Lie algebras. We might want to revisit this decision though as `crystals.HighestWeight` will not be able to distinguish between the two types because of this.


---

Comment by mantepse created at 2021-02-15 09:22:48

Dear Anne, Daniel and Travis (I guess that T is a good approximation to E)!

My thought about *not* using the ambient space was that the choice of positive roots is quite arbitrary, and it might be more correct to (at least try to) avoid dependence on a specific choice.  So here is another version of the same code:

```
        n = cartan_type.rank()
        from sage.modules.free_module_element import vector
        from sage.rings.integer_ring import ZZ
        from sage.rings.rational_field import QQ
        d = {i: vector(QQ, [1]*i + [0]*(n-i)) for i in range(1, n+1)}
        if cartan_type.type() == "B":
            d[n] = vector(QQ, [1/2 for i in range(n)])
        elif cartan_type.type() == "D":
            d[n-1] = vector(QQ, [1/2 for i in range(n-1)] + [-1/2])
            d[n] = vector(QQ, [1/2 for i in range(n)])
        sh = sum((c*d[i] for i, c in dominant_weight), vector(QQ, n))
        if sh[-1] in ZZ:
            sh = Partition(sh)
        return CrystalOfTableaux(cartan_type, shape=sh)
```

The call to `Partition` should not be avoided, or probably done in `crystals.Tableaux`, because

```
sage: C1 = crystals.Tableaux("A4", shape=[2,1]); C1
The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1]]
sage: C2 = crystals.Tableaux("A4", shape=[2,1,0,0]); C2
The crystal of tableaux of type ['A', 4] and shape(s) [[2, 1, 0, 0]]
sage: C1 == C2
False
```


Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:

```
        sh = dominant_weight.to_ambient().to_vector()
        if cartan_type.type() == "G":
            sh = (-sh)[2:0:-1]
        from sage.rings.integer_ring import ZZ
        if cartan_type.type() in ["B", "D"] and sh[-1] not in ZZ:
            return CrystalOfTableaux(cartan_type, shape=sh)

        return CrystalOfTableaux(cartan_type, shape=Partition(sh))
```

Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.

I assume that it's out of the question to change the choice of positive roots for `G_2`, right?

Concerning the test, I must say that I like to have one (more or less) systematic test.  It would have saved me a day if something like it would have been available.


---

Comment by aschilling created at 2021-02-15 23:37:01

Dear Martin,

I would vote for this option:


> Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:
> {{{
>         sh = dominant_weight.to_ambient().to_vector()
>         if cartan_type.type() == "G":
>             sh = (-sh)[2:0:-1]
>         from sage.rings.integer_ring import ZZ
>         if cartan_type.type() in ["B", "D"] and sh[-1] not in ZZ:
>             return CrystalOfTableaux(cartan_type, shape=sh)
> 
>         return CrystalOfTableaux(cartan_type, shape=Partition(sh))
> }}}
> Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.
> 
> I assume that it's out of the question to change the choice of positive roots for `G_2`, right?

Well, I would not do it for this ticket, but Dan or Travis might have other opinions.

Anne


---

Comment by tscrim created at 2021-02-16 03:59:58

Replying to [comment:11 mantepse]:
> My thought about *not* using the ambient space was that the choice of positive roots is quite arbitrary, and it might be more correct to (at least try to) avoid dependence on a specific choice.

I don't think it was that arbitrary. Nicolas, were you the one who did the root system implementation? Do you have any comments on this?

> The call to `Partition` should not be avoided, or probably done in `crystals.Tableaux`, because
> {{{
> sage: C1 = crystals.Tableaux("A4", shape=[2,1]); C1
> The crystal of tableaux of type ['A', 4] and shape(s) [This is the Trac macro *2, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#2, 1-macro)
> sage: C2 = crystals.Tableaux("A4", shape=[2,1,0,0]); C2
> The crystal of tableaux of type ['A', 4] and shape(s) [This is the Trac macro *2, 1, 0, 0* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#2, 1, 0, 0-macro)
> sage: C1 == C2
> False
> }}}

Yes, it should be avoided _here_ in the highest weight crystals code. That is an issue with the `CrystalOfTableaux` code not sufficiently standardizing itself. There is also a strong argument for padding the list to have length `n`.

> Alternatively, here is a code which always relies on the chosen set of positive roots, but in a quirky way:
> {{{
>         sh = dominant_weight.to_ambient().to_vector()
>         if cartan_type.type() == "G":
>             sh = (-sh)[2:0:-1]
>         from sage.rings.integer_ring import ZZ
>         if cartan_type.type() in ["B", "D"] and sh[-1] not in ZZ:
>             return CrystalOfTableaux(cartan_type, shape=sh)
> 
>         return CrystalOfTableaux(cartan_type, shape=Partition(sh))
> }}}
> Note that moving the call to `Partition` to the individual `crystals.Tableaux` classes would save three more lines, including the import statement.

I also like this option except for the call to `Partition`.

> I assume that it's out of the question to change the choice of positive roots for `G_2`, right?

I agree with Anne that definitely not on this ticket.

> Concerning the test, I must say that I like to have one (more or less) systematic test.  It would have saved me a day if something like it would have been available.

If you want a systematic test, I would explicitly write something in. My second option would be to use `CartanType.samples(finite=True)`. I don't like depending on something that is essentially downstream.


---

Comment by git created at 2021-02-17 22:07:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-17 22:10:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-17 22:14:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-17 22:17:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-02-17 22:27:33

I tried to follow your recommendations.  Is it correct that type A is the only exception to the rule that the "shape" should have length at most n?  (I think that, in type A, removing the redundant columns is not a good idea.)

(I don't know anything about the affine case, so please pay attention to it)


---

Comment by git created at 2021-02-17 22:27:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-02-17 23:17:14

Now that I am looking at the code and the changes, it seems more like we should standardize the shape to actually be a partition and strip the trailing zeros there. Plus, they are accessible via the `shapes` attribute. Sorry for the back-and-forth on this; the code has spoken.

In answer to [This is the Trac macro *comment:18* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:18-macro), type A is the only exception to the rule, and I agree we should not remove height n columns to make it a *gl*<sub>n</sub> object, which it more naturally is IMO.

Since we are also fixing the input for `CrystalsOfTableaux` here, there is also this one:

```
sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])
The crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]
```

I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed.


---

Comment by aschilling created at 2021-02-18 05:49:38

I agree with Travis' comments. Other than that the code looks good to me!


---

Comment by git created at 2021-02-18 07:28:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-02-18 07:33:23

I changed the code to convert to partitions whenever possible.

Could you please be more explicit with your comment about

```
sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])
The crystal of tableaux of type ['D', 4] and shape(s) [[-1/2, 1/2, 1/2, -1/2]]
```

It is unclear to me what input is OK and what should be rejected.


---

Comment by mantepse created at 2021-02-18 11:59:55

I just realized that I am still confused:

```
sage: ct = CartanType(["A", 3])
sage: La = RootSystem(ct).weight_lattice().fundamental_weights()
sage: La[1].to_ambient()
(1, 0, 0, 0)
sage: R = RootSystem(ct).root_space()
sage: La = RootSystem(ct).root_space().fundamental_weights_from_simple_roots()
sage: La[1].to_ambient()
(3/4, -1/4, -1/4, -1/4)
```



---

Comment by aschilling created at 2021-02-18 17:10:53

Replying to [comment:23 mantepse]:
> I changed the code to convert to partitions whenever possible.
> 
> Could you please be more explicit with your comment about
> {{{
> sage: crystals.Tableaux(['D',4], shape=[-1/2,1/2,1/2,-1/2])
> The crystal of tableaux of type ['D', 4] and shape(s) [This is the Trac macro *-1/2, 1/2, 1/2, -1/2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#-1/2, 1/2, 1/2, -1/2-macro)
> }}}
> It is unclear to me what input is OK and what should be rejected.

It says in the documentation:

   If the type is D_r, the shape is permitted to have a negative value
   in the r-th position. Thus if the shape equals [s_1,...,s_r],
   then s_r may be negative but in any case s_1 >= ... >=
   s_{r-1} >= |s_r|. This crystal is related to that of shape
   [s_1,...,|s_r|] by the outer automorphism of SO(2r).

So negative entries should not be allowed except in the r-th entry.


---

Comment by mantepse created at 2021-02-18 18:39:54

So, Travis, with

> I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. 

you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?


---

Comment by aschilling created at 2021-02-18 21:29:01

Replying to [comment:27 mantepse]:
> So, Travis, with
> 
> > I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. 
> 
> you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?

Yes, `[1/2, ..., 1/2, -1/2]` is allowed.


---

Comment by tscrim created at 2021-02-19 23:40:51

Replying to [comment:28 aschilling]:
> Replying to [comment:27 mantepse]:
> > So, Travis, with
> > 
> > > I think the check is lacking and the fact we force the spins to all be plus or minus is artificial and can be removed. 
> > 
> > you are referring to the fact that `[1/2, ..., 1/2, -1/2]` is allowed?
> 
> Yes, `[1/2, ..., 1/2, -1/2]` is allowed.

What I mean is you cannot mix `[1/2, ..., 1/2, -1/2]` with `[1/2, ..., 1/2, 1/2]`:

```
sage: crystals.Tableaux(['D',4], [[1/2,1/2,1/2,-1/2],[1/2,1/2,1/2,1/2]])
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
...
ValueError: in type D spins should all be positive or negative
```



---

Comment by tscrim created at 2021-02-19 23:43:18

Replying to [comment:24 mantepse]:
> I just realized that I am still confused:
> {{{
> sage: ct = CartanType(["A", 3])
> sage: La = RootSystem(ct).weight_lattice().fundamental_weights()
> sage: La[1].to_ambient()
> (1, 0, 0, 0)
> sage: R = RootSystem(ct).root_space()
> sage: La = RootSystem(ct).root_space().fundamental_weights_from_simple_roots()
> sage: La[1].to_ambient()
> (3/4, -1/4, -1/4, -1/4)
> }}}
Everything in the type A root system can be considered up to scalar multiples of the `(1, 1, ..., 1)` vector. So these two can be considered to be the same element because it really lives in a quotient space.


---

Comment by mantepse created at 2021-02-20 07:47:20

Thank you for both explanations! I think the special SLn / GLn feature should not be ignored in `crystals.HighestWeight`, so I'll make another special case.


---

Comment by git created at 2021-02-20 20:55:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-02-20 20:57:19

I could not see how to change the code to accomodate Travis' comment

> the fact we force the spins to all be plus or minus is artificial and can be removed

but apart from this, I think it should be (slightly) better now.


---

Comment by tscrim created at 2021-02-22 01:02:53

Replying to [comment:33 mantepse]:
> I could not see how to change the code to accomodate Travis' comment
> 
> > the fact we force the spins to all be plus or minus is artificial and can be removed
> 
> but apart from this, I think it should be (slightly) better now.

I see. That is a bit tricky to remove that. So let's just leave that in.


---

Comment by tscrim created at 2021-02-22 01:02:53

Changing status from needs_review to positive_review.


---

Comment by mantepse created at 2021-02-22 11:19:17

Thank you for looking at the code!

One more question: I currently do

```
dominant_weight = dominant_weight.to_ambient().to_weight_space(ZZ)
```

do obtain a weight in the weight lattice.

Maybe it would make sense to add a method `to_weight_space` to `RootSpace`, so we could just say

```
dominant_weight = dominant_weight.to_weight_space()
```

(`WeightSpaceElement` has a method `to_weight_space` which just returns `self`, whereas `dominant_weight.to_ambient().to_weight_space(ZZ)` has to do some real work)


---

Comment by tscrim created at 2021-02-22 23:14:51

No, it does not because the Cartan matrix is not invertible in general. For example, in affine type since there is a nullspace that is spanned by the null root.


---

Comment by vbraun created at 2021-03-09 00:01:24

Resolution: fixed
