# Issue 31585: Check containment for combinatorial faces

Issue created by migration from https://trac.sagemath.org/ticket/31822

Original creator: @kliem

Original creation time: 2021-05-12 14:05:37

CC:  jipilab mkoeppe yzh

Keywords: combinatorial polyhedron, subface

We add a method `is_subface` to combinatorial faces.


---

Comment by @kliem created at 2021-05-12 14:05:41

Changing status from new to needs_review.


---

Comment by @kliem created at 2021-05-13 05:32:17

It works fine in the intended case.

However, it should raise an error, when `self` and `other` or not from the same `CombinatorialPolyhedron` (`NotImplementedError`?) and it should consider the case that `self` is from a dual face iterator and `other isn't.


---

Comment by @kliem created at 2021-05-13 05:32:17

Changing status from needs_review to needs_work.


---

Comment by git created at 2021-05-13 07:20:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2021-05-13 07:20:56

Changing status from needs_work to needs_review.


---

Comment by slelievre created at 2021-05-13 17:27:37

The pyflakes plugin complains that `facet` is not defined in this line:

```
            if isinstance(v, PolyhedronFace) and facet.dim() == 0:
```

Did you mean `v.dim()`?


---

Comment by slelievre created at 2021-05-13 17:27:37

Changing status from needs_review to needs_work.


---

Comment by git created at 2021-05-13 18:45:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-05-13 18:55:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by @kliem created at 2021-05-13 18:55:38

Changing status from needs_work to needs_review.


---

Comment by @kliem created at 2021-05-13 18:56:05

Replying to [comment:6 slelievre]:
> The pyflakes plugin complains that `facet` is not defined in this line:
> {{{
>             if isinstance(v, PolyhedronFace) and facet.dim() == 0:
> }}}
> Did you mean `v.dim()`?

Fixed in #29683 and rebased.


---

Comment by @kliem created at 2021-05-13 18:56:12

Thanks.


---

Comment by @kliem created at 2021-05-20 07:23:57

Nees rebase.


---

Comment by @kliem created at 2021-05-20 07:23:57

Changing status from needs_review to needs_work.


---

Comment by yzh created at 2021-05-22 11:51:09

`is_subface` looks correct. However I don't understand why you distinguished two cases on whether`self._dual == other_face._dual`. It seems to me that the `ambient_V_indices` containment check always works. Is it because using `face_issubset` in the first case is faster? Then, how about using `only_subfaces`?


```
sage: P = polytopes.cube()
sage: C = P.combinatorial_polyhedron()
```

is repeated in the doctest.


---

Comment by git created at 2021-05-22 11:59:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2021-05-22 12:15:48

Replying to [comment:13 yzh]:
> `is_subface` looks correct. However I don't understand why you distinguished two cases on whether`self._dual == other_face._dual`. It seems to me that the `ambient_V_indices` containment check always works. Is it because using `face_issubset` in the first case is faster? Then, how about using `only_subfaces`?

Using the face as a bitset is much much faster than creating a list. Well there would be a faster method for the second case by comparing directly the array instead of the list, but I don't think this case is very important anyway.

Here is some speed comparison:


```
sage: P = polytopes.hypercube(14, backend='field')                                                                                                                                  
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: it = C.face_iter(dual=False)                                                                                                                                                  
sage: f = next(it)                                                                                                                                                                  
sage: it.only_subfaces()                                                                                                                                                            
sage: f2 = next(it)                                                                                                                                                                 
sage: %timeit f2.is_subface(f)                                                                                                                                                      
80.2 ns ± 0.0408 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: %timeit f.is_subface(f2)                                                                                                                                                      
50.1 ns ± 0.0767 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: it2 = C.face_iter(dual=True)                                                                                                                                                  
sage: f3 = next(it2)                                                                                                                                                                
sage: %timeit f3.is_subface(f)                                                                                                                                                      
781 µs ± 444 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit f.is_subface(f3)                                                                                                                                                      
708 µs ± 239 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: while f3.dimension() < 12: 
....:     while not f3.is_subface(f): 
....:         f3 = next(it2) 
....:     it2.only_supfaces() 
....:     f3 = next(it2) 
....:                                                                                                                                                                               
sage: f3.dimension()                                                                                                                                                                
12
sage: %timeit f3.is_subface(f)                                                                                                                                                      
1.16 ms ± 619 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit f.is_subface(f3)                                                                                                                                                      
1.06 ms ± 256 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
```


Even the very difficult first case (`f2` is indeed a subface of `f`) only takes a few nano seconds to check all `2^14` bits. In comparison the other case is really slow (but it is also not optimized at all).

> 
> {{{
> sage: P = polytopes.cube()
> sage: C = P.combinatorial_polyhedron()
> }}}
> is repeated in the doctest.

Fixed.


---

Comment by yzh created at 2021-05-22 13:04:03

Replying to [comment:15 gh-kliem]:
> Replying to [comment:13 yzh]:
> In comparison the other case is really slow (but it is also not optimized at all).
If speed is a concern, then I'd recommend to check `self.dimension() <= other.dimension()` at least.

Does a face know about the original combinatorial polyhedron `C`? Is `f2.is_subface(f1)`   through something like `C.face_iter().find_face(f1).only_subfaces().find_face(f2)` faster than comparing `ambient_V_indices()`?


---

Comment by @kliem created at 2021-05-22 13:33:39

If `f1` and `f2` are in the same mode, then the current check is fast enough I think.

The other case is not really intended and I just have something that will work. However, if you want, I can do something more efficient. `find_face` is definitely not the best way of doing it, because it does way to much work. After all, I just have to get the coatom representation of `f1` and compare it with the atom representation of `f2` (the atoms of `f1` are the coatoms of `f2`).


---

Comment by yzh created at 2021-05-23 10:24:52

Replying to [comment:17 gh-kliem]:
> After all, I just have to get the coatom representation of `f1` and compare it with the atom representation of `f2` (the atoms of `f1` are the coatoms of `f2`).
If it's not too complicated to implement, this sounds like a great solution! I don't have a direct use case of "f1 and f2 not in the same mode", so I feel good about the ticket even if you won't implement the additional speed-up. However, I'd like to include the `self.dimension() <= other.dimension()` check, as mentioned above.


---

Comment by git created at 2021-05-23 19:12:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2021-05-23 19:17:05

Replying to [comment:18 yzh]:
> Replying to [comment:17 gh-kliem]:
> > After all, I just have to get the coatom representation of `f1` and compare it with the atom representation of `f2` (the atoms of `f1` are the coatoms of `f2`).
> If it's not too complicated to implement, this sounds like a great solution! I don't have a direct use case of "f1 and f2 not in the same mode", so I feel good about the ticket even if you won't implement the additional speed-up. However, I'd like to include the `self.dimension() <= other.dimension()` check, as mentioned above. 

The check `self.dimension() <= other.dimension()` is no improvement either way, when `self` and `other` are in same mode.

Here are the new timings:


```
sage: P = polytopes.hypercube(14, backend='field')                                                                                                                                  
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: it = C.face_iter(dual=False)                                                                                                                                                  
sage: f = next(it)                                                                                                                                                                  
sage: it.only_subfaces()                                                                                                                                                            
sage: f2 = next(it)                                                                                                                                                                 
sage: %timeit f.is_subface(f2)                                                                                                                                                      
42.2 ns ± 0.0401 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: %timeit f2.is_subface(f)                                                                                                                                                      
72.4 ns ± 0.0662 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: it2 = C.face_iter(dual=True)                                                                                                                                                  
sage: f3 = next(it2)                                                                                                                                                                
sage: %timeit f.is_subface(f3)                                                                                                                                                      
56.8 ns ± 0.0814 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: %timeit f3.is_subface(f)                                                                                                                                                      
78.1 µs ± 92.8 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage: while True: 
....:     while not f3.is_subface(f): 
....:         f3 = next(it2) 
....:     it2.only_supfaces() 
....:     if f3.dimension() == 12: 
....:         break 
....:     f3 = next(it2) 
....:                                                                                                                                                                               
sage: %timeit f.is_subface(f3)                                                                                                                                                      
58.5 ns ± 0.0699 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: %timeit f3.is_subface(f)                                                                                                                                                      
78.3 µs ± 46.5 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage: f3.dimension()                                                                                                                                                                
12
sage: f.is_subface(f3)                                                                                                                                                              
False
sage: f3.is_subface(f)                                                                                                                                                              
True
```



---

Comment by @kliem created at 2021-05-23 19:37:47

Btw, currently `face.coatom_rep` etc. is reinitialized. I expect things to be much faster on repeated calls, if I change the code to realize this.

However, this might be the more honest timing, as it reflects more realistic the amount of time the first call needs.


---

Comment by @kliem created at 2021-05-25 07:02:59

Caching `atom_rep` and `coatom_rep` (actually not cashing, but only remembering that it has already been computed), I get the following timings now:


```
sage: P = polytopes.hypercube(14, backend='field')                                                                                                                                  
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: it = C.face_iter(dual=False)                                                                                                                                                  
sage: f = next(it)                                                                                                                                                                   
sage: it2 = C.face_iter(dual=True)                                                                                                                                                  
sage: f3 = next(it2)                                                                                                                                                                
sage: %timeit f.is_subface(f3)                                                                                                                                                      
56.7 ns ± 0.0563 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: %timeit f3.is_subface(f)                                                                                                                                                      
7.12 µs ± 68.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: while True: 
....:     while not f3.is_subface(f): 
....:         f3 = next(it2) 
....:     it2.only_supfaces() 
....:     if f3.dimension() == 12: 
....:         break 
....:     f3 = next(it2) 
....:                                                                                                                                                                               
sage: %timeit f.is_subface(f3)                                                                                                                                                      
58.1 ns ± 0.0822 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
sage: %timeit f3.is_subface(f)                                                                                                                                                      
5.34 µs ± 2.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```



---

Comment by git created at 2021-05-25 07:06:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-06-23 01:08:35

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2021-06-23 01:08:35

I am guessing that this ticket "needs review"
----
Last 10 new commits:


---

Comment by mkoeppe created at 2021-06-23 01:24:08

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2021-06-23 01:24:08

I have not followed the discussion on timing, but the code looks fine to me, and passes tests.


---

Comment by @kliem created at 2021-06-23 11:36:08

Thank you.


---

Comment by vbraun created at 2021-07-01 20:44:58

Resolution: fixed
