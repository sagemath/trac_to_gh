# Issue 32964: Fix "referenced before assignment" warnings in matrices

Issue created by migration from https://trac.sagemath.org/ticket/33201

Original creator: mjo

Original creation time: 2022-01-17 20:01:15


```
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:283:19: local variable 'd' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:285:18: local variable 'd' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:289:11: local variable 'd' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:297:14: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:298:14: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:305:58: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:306:65: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:309:57: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:310:65: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:323:11: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:324:11: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:328:30: local variable 'one' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:329:15: local variable 'zero' referenced before assignment
[sagelib-9.5.rc2] warning: sage/matrix/matrix_modn_dense_template.pxi:283:19: local variable 'd' referenced before assignment
```



---

Comment by mjo created at 2022-01-17 20:07:06

Changing status from new to needs_review.


---

Comment by mjo created at 2022-01-17 20:07:06

New commits:


---

Comment by nbruin created at 2022-01-17 21:45:57

Normally, one does not write sub-optimal code just to satisfy a compiler. There had better be a very convincing reason! In this case I am even less convinced that a fix on our side is required, since there is an issue open in cython pertaining this: https://github.com/cython/cython/issues/1269

The "proper" solution would be a cython indicator that the first use site actually is an initialization. A little less precise, but perhaps a little easier to implement in cython: some indicator in the declaration that marks the variable as "don't check initialization-before-reference"; probably implemented as "treat this as initialized" (without generating actual initialization code).

Unless the cython issue is resolved satisfactorily, these examples show the application of a feature like that, and the cython folk may well be willing to implement it.


---

Comment by mjo created at 2022-01-17 22:04:09

Replying to [comment:2 nbruin]:
> Normally, one does not write sub-optimal code just to satisfy a compiler. There had better be a very convincing reason! In this case I am even less convinced that a fix on our side is required, since there is an issue open in cython pertaining this: https://github.com/cython/cython/issues/1269

...open for a decade, whose last comment is "Seems really not easy to fix."

But I disagree in principle: to satisfy a compiler is one of the best and most-common reasons to write sub-optimal code. There are several important warnings being thrown, but no one has noticed them because they're drowned out by this noise. We're talking about initializing a couple floats to zero. If that's the cost to make our cython output meaningful again, it's worth it.

> The "proper" solution would be a cython indicator that the first use site actually is an initialization. A little less precise, but perhaps a little easier to implement in cython: some indicator in the declaration that marks the variable as "don't check initialization-before-reference"; probably implemented as "treat this as initialized" (without generating actual initialization code).

This just moves the problem up one level to "does the cython comment still agree with the code it was written for?"


---

Comment by mjo created at 2022-01-18 00:48:29

I've tried to measure the impact of initialization but it seems not easy on a modern linux system. There are so many security features involved, it looks like I'm always getting zero pages from the kernel and that GCC is happy to take advantage of this. For trivial test programs, it's generating the same assembly with/without zero-initialization.

I'm sure it can be done but I really expect the performance penalty to be unmeasurable on any system capable of running sage. And in exchange it will be really nice to have the list of outstanding warnings be readable and actionable.


---

Comment by lorenz created at 2022-01-19 02:54:14

I would expect this initialization to get eliminated during compilation: The `F.init()` calls should get inlined, so the compiler can see that the value gets written to again immediately after (without ever being read from), which means the assignment can be omitted.

I don't think this has to do with zero pages (the compiler can't assume much about what happened to the stack before we got called).


---

Comment by mjo created at 2022-01-19 16:14:25

Replying to [comment:5 lorenz]:
> I would expect this initialization to get eliminated during compilation: The `F.init()` calls should get inlined, so the compiler can see that the value gets written to again immediately after (without ever being read from), which means the assignment can be omitted.

You're right. The following example is complicated enough that the (gcc-11) assembly differs at `-O0` and `-O1`, but is identical at `-O2`:


```C++
#include <iostream>
#include <givaro/modular-floating.h>

using namespace std;

typedef Givaro::Modular<double> Modular_double;

int main(int argc, char** argv) {
  double zero, one;
  //double zero = 0, one = 0;
  long modulus = 2;
  Modular_double F(modulus);
  F.init(zero, (int)0);
  F.init(one, (int)1);

  cout << "zero: " << zero << "\n" << "one: " << one << "\n";
  return 0;
}


---

Comment by mjo created at 2022-01-19 16:15:35

(And the `init` method is marked "inline", so this should happen reliably.)
